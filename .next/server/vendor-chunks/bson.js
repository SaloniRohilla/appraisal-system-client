"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bson";
exports.ids = ["vendor-chunks/bson"];
exports.modules = {

/***/ "(api)/../server/node_modules/bson/lib/bson.cjs":
/*!************************************************!*\
  !*** ../server/node_modules/bson/lib/bson.cjs ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction isAnyArrayBuffer(value) {\n    return ['[object ArrayBuffer]', '[object SharedArrayBuffer]'].includes(Object.prototype.toString.call(value));\n}\nfunction isUint8Array(value) {\n    return Object.prototype.toString.call(value) === '[object Uint8Array]';\n}\nfunction isRegExp(d) {\n    return Object.prototype.toString.call(d) === '[object RegExp]';\n}\nfunction isMap(d) {\n    return Object.prototype.toString.call(d) === '[object Map]';\n}\nfunction isDate(d) {\n    return Object.prototype.toString.call(d) === '[object Date]';\n}\n\nconst BSON_MAJOR_VERSION = 5;\nconst BSON_INT32_MAX = 0x7fffffff;\nconst BSON_INT32_MIN = -0x80000000;\nconst BSON_INT64_MAX = Math.pow(2, 63) - 1;\nconst BSON_INT64_MIN = -Math.pow(2, 63);\nconst JS_INT_MAX = Math.pow(2, 53);\nconst JS_INT_MIN = -Math.pow(2, 53);\nconst BSON_DATA_NUMBER = 1;\nconst BSON_DATA_STRING = 2;\nconst BSON_DATA_OBJECT = 3;\nconst BSON_DATA_ARRAY = 4;\nconst BSON_DATA_BINARY = 5;\nconst BSON_DATA_UNDEFINED = 6;\nconst BSON_DATA_OID = 7;\nconst BSON_DATA_BOOLEAN = 8;\nconst BSON_DATA_DATE = 9;\nconst BSON_DATA_NULL = 10;\nconst BSON_DATA_REGEXP = 11;\nconst BSON_DATA_DBPOINTER = 12;\nconst BSON_DATA_CODE = 13;\nconst BSON_DATA_SYMBOL = 14;\nconst BSON_DATA_CODE_W_SCOPE = 15;\nconst BSON_DATA_INT = 16;\nconst BSON_DATA_TIMESTAMP = 17;\nconst BSON_DATA_LONG = 18;\nconst BSON_DATA_DECIMAL128 = 19;\nconst BSON_DATA_MIN_KEY = 0xff;\nconst BSON_DATA_MAX_KEY = 0x7f;\nconst BSON_BINARY_SUBTYPE_DEFAULT = 0;\nconst BSON_BINARY_SUBTYPE_UUID_NEW = 4;\nconst BSONType = Object.freeze({\n    double: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    binData: 5,\n    undefined: 6,\n    objectId: 7,\n    bool: 8,\n    date: 9,\n    null: 10,\n    regex: 11,\n    dbPointer: 12,\n    javascript: 13,\n    symbol: 14,\n    javascriptWithScope: 15,\n    int: 16,\n    timestamp: 17,\n    long: 18,\n    decimal: 19,\n    minKey: -1,\n    maxKey: 127\n});\n\nclass BSONError extends Error {\n    get bsonError() {\n        return true;\n    }\n    get name() {\n        return 'BSONError';\n    }\n    constructor(message) {\n        super(message);\n    }\n    static isBSONError(value) {\n        return (value != null &&\n            typeof value === 'object' &&\n            'bsonError' in value &&\n            value.bsonError === true &&\n            'name' in value &&\n            'message' in value &&\n            'stack' in value);\n    }\n}\nclass BSONVersionError extends BSONError {\n    get name() {\n        return 'BSONVersionError';\n    }\n    constructor() {\n        super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);\n    }\n}\nclass BSONRuntimeError extends BSONError {\n    get name() {\n        return 'BSONRuntimeError';\n    }\n    constructor(message) {\n        super(message);\n    }\n}\n\nfunction nodejsMathRandomBytes(byteLength) {\n    return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));\n}\nconst nodejsRandomBytes = (() => {\n    try {\n        return (__webpack_require__(/*! crypto */ \"crypto\").randomBytes);\n    }\n    catch {\n        return nodejsMathRandomBytes;\n    }\n})();\nconst nodeJsByteUtils = {\n    toLocalBufferType(potentialBuffer) {\n        if (Buffer.isBuffer(potentialBuffer)) {\n            return potentialBuffer;\n        }\n        if (ArrayBuffer.isView(potentialBuffer)) {\n            return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);\n        }\n        const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);\n        if (stringTag === 'ArrayBuffer' ||\n            stringTag === 'SharedArrayBuffer' ||\n            stringTag === '[object ArrayBuffer]' ||\n            stringTag === '[object SharedArrayBuffer]') {\n            return Buffer.from(potentialBuffer);\n        }\n        throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`);\n    },\n    allocate(size) {\n        return Buffer.alloc(size);\n    },\n    equals(a, b) {\n        return nodeJsByteUtils.toLocalBufferType(a).equals(b);\n    },\n    fromNumberArray(array) {\n        return Buffer.from(array);\n    },\n    fromBase64(base64) {\n        return Buffer.from(base64, 'base64');\n    },\n    toBase64(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('base64');\n    },\n    fromISO88591(codePoints) {\n        return Buffer.from(codePoints, 'binary');\n    },\n    toISO88591(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('binary');\n    },\n    fromHex(hex) {\n        return Buffer.from(hex, 'hex');\n    },\n    toHex(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('hex');\n    },\n    fromUTF8(text) {\n        return Buffer.from(text, 'utf8');\n    },\n    toUTF8(buffer, start, end) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('utf8', start, end);\n    },\n    utf8ByteLength(input) {\n        return Buffer.byteLength(input, 'utf8');\n    },\n    encodeUTF8Into(buffer, source, byteOffset) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, 'utf8');\n    },\n    randomBytes: nodejsRandomBytes\n};\n\nfunction isReactNative() {\n    const { navigator } = globalThis;\n    return typeof navigator === 'object' && navigator.product === 'ReactNative';\n}\nfunction webMathRandomBytes(byteLength) {\n    if (byteLength < 0) {\n        throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);\n    }\n    return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));\n}\nconst webRandomBytes = (() => {\n    const { crypto } = globalThis;\n    if (crypto != null && typeof crypto.getRandomValues === 'function') {\n        return (byteLength) => {\n            return crypto.getRandomValues(webByteUtils.allocate(byteLength));\n        };\n    }\n    else {\n        if (isReactNative()) {\n            const { console } = globalThis;\n            console?.warn?.('BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.');\n        }\n        return webMathRandomBytes;\n    }\n})();\nconst HEX_DIGIT = /(\\d|[a-f])/i;\nconst webByteUtils = {\n    toLocalBufferType(potentialUint8array) {\n        const stringTag = potentialUint8array?.[Symbol.toStringTag] ??\n            Object.prototype.toString.call(potentialUint8array);\n        if (stringTag === 'Uint8Array') {\n            return potentialUint8array;\n        }\n        if (ArrayBuffer.isView(potentialUint8array)) {\n            return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));\n        }\n        if (stringTag === 'ArrayBuffer' ||\n            stringTag === 'SharedArrayBuffer' ||\n            stringTag === '[object ArrayBuffer]' ||\n            stringTag === '[object SharedArrayBuffer]') {\n            return new Uint8Array(potentialUint8array);\n        }\n        throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`);\n    },\n    allocate(size) {\n        if (typeof size !== 'number') {\n            throw new TypeError(`The \"size\" argument must be of type number. Received ${String(size)}`);\n        }\n        return new Uint8Array(size);\n    },\n    equals(a, b) {\n        if (a.byteLength !== b.byteLength) {\n            return false;\n        }\n        for (let i = 0; i < a.byteLength; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    fromNumberArray(array) {\n        return Uint8Array.from(array);\n    },\n    fromBase64(base64) {\n        return Uint8Array.from(atob(base64), c => c.charCodeAt(0));\n    },\n    toBase64(uint8array) {\n        return btoa(webByteUtils.toISO88591(uint8array));\n    },\n    fromISO88591(codePoints) {\n        return Uint8Array.from(codePoints, c => c.charCodeAt(0) & 0xff);\n    },\n    toISO88591(uint8array) {\n        return Array.from(Uint16Array.from(uint8array), b => String.fromCharCode(b)).join('');\n    },\n    fromHex(hex) {\n        const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);\n        const buffer = [];\n        for (let i = 0; i < evenLengthHex.length; i += 2) {\n            const firstDigit = evenLengthHex[i];\n            const secondDigit = evenLengthHex[i + 1];\n            if (!HEX_DIGIT.test(firstDigit)) {\n                break;\n            }\n            if (!HEX_DIGIT.test(secondDigit)) {\n                break;\n            }\n            const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);\n            buffer.push(hexDigit);\n        }\n        return Uint8Array.from(buffer);\n    },\n    toHex(uint8array) {\n        return Array.from(uint8array, byte => byte.toString(16).padStart(2, '0')).join('');\n    },\n    fromUTF8(text) {\n        return new TextEncoder().encode(text);\n    },\n    toUTF8(uint8array, start, end) {\n        return new TextDecoder('utf8', { fatal: false }).decode(uint8array.slice(start, end));\n    },\n    utf8ByteLength(input) {\n        return webByteUtils.fromUTF8(input).byteLength;\n    },\n    encodeUTF8Into(buffer, source, byteOffset) {\n        const bytes = webByteUtils.fromUTF8(source);\n        buffer.set(bytes, byteOffset);\n        return bytes.byteLength;\n    },\n    randomBytes: webRandomBytes\n};\n\nconst hasGlobalBuffer = typeof Buffer === 'function' && Buffer.prototype?._isBuffer !== true;\nconst ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;\nclass BSONDataView extends DataView {\n    static fromUint8Array(input) {\n        return new DataView(input.buffer, input.byteOffset, input.byteLength);\n    }\n}\n\nclass BSONValue {\n    get [Symbol.for('@@mdb.bson.version')]() {\n        return BSON_MAJOR_VERSION;\n    }\n}\n\nclass Binary extends BSONValue {\n    get _bsontype() {\n        return 'Binary';\n    }\n    constructor(buffer, subType) {\n        super();\n        if (!(buffer == null) &&\n            !(typeof buffer === 'string') &&\n            !ArrayBuffer.isView(buffer) &&\n            !(buffer instanceof ArrayBuffer) &&\n            !Array.isArray(buffer)) {\n            throw new BSONError('Binary can only be constructed from string, Buffer, TypedArray, or Array<number>');\n        }\n        this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;\n        if (buffer == null) {\n            this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);\n            this.position = 0;\n        }\n        else {\n            if (typeof buffer === 'string') {\n                this.buffer = ByteUtils.fromISO88591(buffer);\n            }\n            else if (Array.isArray(buffer)) {\n                this.buffer = ByteUtils.fromNumberArray(buffer);\n            }\n            else {\n                this.buffer = ByteUtils.toLocalBufferType(buffer);\n            }\n            this.position = this.buffer.byteLength;\n        }\n    }\n    put(byteValue) {\n        if (typeof byteValue === 'string' && byteValue.length !== 1) {\n            throw new BSONError('only accepts single character String');\n        }\n        else if (typeof byteValue !== 'number' && byteValue.length !== 1)\n            throw new BSONError('only accepts single character Uint8Array or Array');\n        let decodedByte;\n        if (typeof byteValue === 'string') {\n            decodedByte = byteValue.charCodeAt(0);\n        }\n        else if (typeof byteValue === 'number') {\n            decodedByte = byteValue;\n        }\n        else {\n            decodedByte = byteValue[0];\n        }\n        if (decodedByte < 0 || decodedByte > 255) {\n            throw new BSONError('only accepts number in a valid unsigned byte range 0-255');\n        }\n        if (this.buffer.byteLength > this.position) {\n            this.buffer[this.position++] = decodedByte;\n        }\n        else {\n            const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n            this.buffer[this.position++] = decodedByte;\n        }\n    }\n    write(sequence, offset) {\n        offset = typeof offset === 'number' ? offset : this.position;\n        if (this.buffer.byteLength < offset + sequence.length) {\n            const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n        }\n        if (ArrayBuffer.isView(sequence)) {\n            this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);\n            this.position =\n                offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n        }\n        else if (typeof sequence === 'string') {\n            const bytes = ByteUtils.fromISO88591(sequence);\n            this.buffer.set(bytes, offset);\n            this.position =\n                offset + sequence.length > this.position ? offset + sequence.length : this.position;\n        }\n    }\n    read(position, length) {\n        length = length && length > 0 ? length : this.position;\n        return this.buffer.slice(position, position + length);\n    }\n    value(asRaw) {\n        asRaw = !!asRaw;\n        if (asRaw && this.buffer.length === this.position) {\n            return this.buffer;\n        }\n        if (asRaw) {\n            return this.buffer.slice(0, this.position);\n        }\n        return ByteUtils.toISO88591(this.buffer.subarray(0, this.position));\n    }\n    length() {\n        return this.position;\n    }\n    toJSON() {\n        return ByteUtils.toBase64(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === 'hex')\n            return ByteUtils.toHex(this.buffer);\n        if (encoding === 'base64')\n            return ByteUtils.toBase64(this.buffer);\n        if (encoding === 'utf8' || encoding === 'utf-8')\n            return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength);\n        return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength);\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        const base64String = ByteUtils.toBase64(this.buffer);\n        const subType = Number(this.sub_type).toString(16);\n        if (options.legacy) {\n            return {\n                $binary: base64String,\n                $type: subType.length === 1 ? '0' + subType : subType\n            };\n        }\n        return {\n            $binary: {\n                base64: base64String,\n                subType: subType.length === 1 ? '0' + subType : subType\n            }\n        };\n    }\n    toUUID() {\n        if (this.sub_type === Binary.SUBTYPE_UUID) {\n            return new UUID(this.buffer.slice(0, this.position));\n        }\n        throw new BSONError(`Binary sub_type \"${this.sub_type}\" is not supported for converting to UUID. Only \"${Binary.SUBTYPE_UUID}\" is currently supported.`);\n    }\n    static createFromHexString(hex, subType) {\n        return new Binary(ByteUtils.fromHex(hex), subType);\n    }\n    static createFromBase64(base64, subType) {\n        return new Binary(ByteUtils.fromBase64(base64), subType);\n    }\n    static fromExtendedJSON(doc, options) {\n        options = options || {};\n        let data;\n        let type;\n        if ('$binary' in doc) {\n            if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {\n                type = doc.$type ? parseInt(doc.$type, 16) : 0;\n                data = ByteUtils.fromBase64(doc.$binary);\n            }\n            else {\n                if (typeof doc.$binary !== 'string') {\n                    type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n                    data = ByteUtils.fromBase64(doc.$binary.base64);\n                }\n            }\n        }\n        else if ('$uuid' in doc) {\n            type = 4;\n            data = UUID.bytesFromString(doc.$uuid);\n        }\n        if (!data) {\n            throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);\n        }\n        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n        return `Binary.createFromBase64(\"${base64}\", ${this.sub_type})`;\n    }\n}\nBinary.BSON_BINARY_SUBTYPE_DEFAULT = 0;\nBinary.BUFFER_SIZE = 256;\nBinary.SUBTYPE_DEFAULT = 0;\nBinary.SUBTYPE_FUNCTION = 1;\nBinary.SUBTYPE_BYTE_ARRAY = 2;\nBinary.SUBTYPE_UUID_OLD = 3;\nBinary.SUBTYPE_UUID = 4;\nBinary.SUBTYPE_MD5 = 5;\nBinary.SUBTYPE_ENCRYPTED = 6;\nBinary.SUBTYPE_COLUMN = 7;\nBinary.SUBTYPE_USER_DEFINED = 128;\nconst UUID_BYTE_LENGTH = 16;\nconst UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;\nconst UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;\nclass UUID extends Binary {\n    constructor(input) {\n        let bytes;\n        if (input == null) {\n            bytes = UUID.generate();\n        }\n        else if (input instanceof UUID) {\n            bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));\n        }\n        else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n            bytes = ByteUtils.toLocalBufferType(input);\n        }\n        else if (typeof input === 'string') {\n            bytes = UUID.bytesFromString(input);\n        }\n        else {\n            throw new BSONError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).');\n        }\n        super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);\n    }\n    get id() {\n        return this.buffer;\n    }\n    set id(value) {\n        this.buffer = value;\n    }\n    toHexString(includeDashes = true) {\n        if (includeDashes) {\n            return [\n                ByteUtils.toHex(this.buffer.subarray(0, 4)),\n                ByteUtils.toHex(this.buffer.subarray(4, 6)),\n                ByteUtils.toHex(this.buffer.subarray(6, 8)),\n                ByteUtils.toHex(this.buffer.subarray(8, 10)),\n                ByteUtils.toHex(this.buffer.subarray(10, 16))\n            ].join('-');\n        }\n        return ByteUtils.toHex(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === 'hex')\n            return ByteUtils.toHex(this.id);\n        if (encoding === 'base64')\n            return ByteUtils.toBase64(this.id);\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    equals(otherId) {\n        if (!otherId) {\n            return false;\n        }\n        if (otherId instanceof UUID) {\n            return ByteUtils.equals(otherId.id, this.id);\n        }\n        try {\n            return ByteUtils.equals(new UUID(otherId).id, this.id);\n        }\n        catch {\n            return false;\n        }\n    }\n    toBinary() {\n        return new Binary(this.id, Binary.SUBTYPE_UUID);\n    }\n    static generate() {\n        const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);\n        bytes[6] = (bytes[6] & 0x0f) | 0x40;\n        bytes[8] = (bytes[8] & 0x3f) | 0x80;\n        return bytes;\n    }\n    static isValid(input) {\n        if (!input) {\n            return false;\n        }\n        if (typeof input === 'string') {\n            return UUID.isValidUUIDString(input);\n        }\n        if (isUint8Array(input)) {\n            return input.byteLength === UUID_BYTE_LENGTH;\n        }\n        return (input._bsontype === 'Binary' &&\n            input.sub_type === this.SUBTYPE_UUID &&\n            input.buffer.byteLength === 16);\n    }\n    static createFromHexString(hexString) {\n        const buffer = UUID.bytesFromString(hexString);\n        return new UUID(buffer);\n    }\n    static createFromBase64(base64) {\n        return new UUID(ByteUtils.fromBase64(base64));\n    }\n    static bytesFromString(representation) {\n        if (!UUID.isValidUUIDString(representation)) {\n            throw new BSONError('UUID string representation must be 32 hex digits or canonical hyphenated representation');\n        }\n        return ByteUtils.fromHex(representation.replace(/-/g, ''));\n    }\n    static isValidUUIDString(representation) {\n        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new UUID(\"${this.toHexString()}\")`;\n    }\n}\nUUID.cacheHexString = false;\n\nclass Code extends BSONValue {\n    get _bsontype() {\n        return 'Code';\n    }\n    constructor(code, scope) {\n        super();\n        this.code = code.toString();\n        this.scope = scope ?? null;\n    }\n    toJSON() {\n        if (this.scope != null) {\n            return { code: this.code, scope: this.scope };\n        }\n        return { code: this.code };\n    }\n    toExtendedJSON() {\n        if (this.scope) {\n            return { $code: this.code, $scope: this.scope };\n        }\n        return { $code: this.code };\n    }\n    static fromExtendedJSON(doc) {\n        return new Code(doc.$code, doc.$scope);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        const codeJson = this.toJSON();\n        return `new Code(\"${String(codeJson.code)}\"${codeJson.scope != null ? `, ${JSON.stringify(codeJson.scope)}` : ''})`;\n    }\n}\n\nfunction isDBRefLike(value) {\n    return (value != null &&\n        typeof value === 'object' &&\n        '$id' in value &&\n        value.$id != null &&\n        '$ref' in value &&\n        typeof value.$ref === 'string' &&\n        (!('$db' in value) || ('$db' in value && typeof value.$db === 'string')));\n}\nclass DBRef extends BSONValue {\n    get _bsontype() {\n        return 'DBRef';\n    }\n    constructor(collection, oid, db, fields) {\n        super();\n        const parts = collection.split('.');\n        if (parts.length === 2) {\n            db = parts.shift();\n            collection = parts.shift();\n        }\n        this.collection = collection;\n        this.oid = oid;\n        this.db = db;\n        this.fields = fields || {};\n    }\n    get namespace() {\n        return this.collection;\n    }\n    set namespace(value) {\n        this.collection = value;\n    }\n    toJSON() {\n        const o = Object.assign({\n            $ref: this.collection,\n            $id: this.oid\n        }, this.fields);\n        if (this.db != null)\n            o.$db = this.db;\n        return o;\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        let o = {\n            $ref: this.collection,\n            $id: this.oid\n        };\n        if (options.legacy) {\n            return o;\n        }\n        if (this.db)\n            o.$db = this.db;\n        o = Object.assign(o, this.fields);\n        return o;\n    }\n    static fromExtendedJSON(doc) {\n        const copy = Object.assign({}, doc);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(doc.$ref, doc.$id, doc.$db, copy);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        const oid = this.oid === undefined || this.oid.toString === undefined ? this.oid : this.oid.toString();\n        return `new DBRef(\"${this.namespace}\", new ObjectId(\"${String(oid)}\")${this.db ? `, \"${this.db}\"` : ''})`;\n    }\n}\n\nlet wasm = undefined;\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n}\ncatch {\n}\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_24_DBL = 1 << 24;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nconst INT_CACHE = {};\nconst UINT_CACHE = {};\nconst MAX_INT64_STRING_LENGTH = 20;\nconst DECIMAL_REG_EX = /^(\\+?0|(\\+|-)?[1-9][0-9]*)$/;\nclass Long extends BSONValue {\n    get _bsontype() {\n        return 'Long';\n    }\n    get __isLong__() {\n        return true;\n    }\n    constructor(low = 0, high, unsigned) {\n        super();\n        if (typeof low === 'bigint') {\n            Object.assign(this, Long.fromBigInt(low, !!high));\n        }\n        else if (typeof low === 'string') {\n            Object.assign(this, Long.fromString(low, !!high));\n        }\n        else {\n            this.low = low | 0;\n            this.high = high | 0;\n            this.unsigned = !!unsigned;\n        }\n    }\n    static fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    static fromInt(value, unsigned) {\n        let obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if ((cache = 0 <= value && value < 256)) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj)\n                    return cachedObj;\n            }\n            obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n            if (cache)\n                UINT_CACHE[value] = obj;\n            return obj;\n        }\n        else {\n            value |= 0;\n            if ((cache = -128 <= value && value < 128)) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj)\n                    return cachedObj;\n            }\n            obj = Long.fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache)\n                INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    static fromNumber(value, unsigned) {\n        if (isNaN(value))\n            return unsigned ? Long.UZERO : Long.ZERO;\n        if (unsigned) {\n            if (value < 0)\n                return Long.UZERO;\n            if (value >= TWO_PWR_64_DBL)\n                return Long.MAX_UNSIGNED_VALUE;\n        }\n        else {\n            if (value <= -TWO_PWR_63_DBL)\n                return Long.MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL)\n                return Long.MAX_VALUE;\n        }\n        if (value < 0)\n            return Long.fromNumber(-value, unsigned).neg();\n        return Long.fromBits(value % TWO_PWR_32_DBL | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n    }\n    static fromBigInt(value, unsigned) {\n        return Long.fromString(value.toString(), unsigned);\n    }\n    static fromString(str, unsigned, radix) {\n        if (str.length === 0)\n            throw new BSONError('empty string');\n        if (str === 'NaN' || str === 'Infinity' || str === '+Infinity' || str === '-Infinity')\n            return Long.ZERO;\n        if (typeof unsigned === 'number') {\n            (radix = unsigned), (unsigned = false);\n        }\n        else {\n            unsigned = !!unsigned;\n        }\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix)\n            throw new BSONError('radix');\n        let p;\n        if ((p = str.indexOf('-')) > 0)\n            throw new BSONError('interior hyphen');\n        else if (p === 0) {\n            return Long.fromString(str.substring(1), unsigned, radix).neg();\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 8));\n        let result = Long.ZERO;\n        for (let i = 0; i < str.length; i += 8) {\n            const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                const power = Long.fromNumber(Math.pow(radix, size));\n                result = result.mul(power).add(Long.fromNumber(value));\n            }\n            else {\n                result = result.mul(radixToPower);\n                result = result.add(Long.fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    static fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    }\n    static fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24), bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24), unsigned);\n    }\n    static fromBytesBE(bytes, unsigned) {\n        return new Long((bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7], (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3], unsigned);\n    }\n    static isLong(value) {\n        return (value != null &&\n            typeof value === 'object' &&\n            '__isLong__' in value &&\n            value.__isLong__ === true);\n    }\n    static fromValue(val, unsigned) {\n        if (typeof val === 'number')\n            return Long.fromNumber(val, unsigned);\n        if (typeof val === 'string')\n            return Long.fromString(val, unsigned);\n        return Long.fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n    }\n    add(addend) {\n        if (!Long.isLong(addend))\n            addend = Long.fromValue(addend);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = addend.high >>> 16;\n        const b32 = addend.high & 0xffff;\n        const b16 = addend.low >>> 16;\n        const b00 = addend.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 + b48;\n        c48 &= 0xffff;\n        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n    }\n    and(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    }\n    compare(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        if (this.eq(other))\n            return 0;\n        const thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg)\n            return -1;\n        if (!thisNeg && otherNeg)\n            return 1;\n        if (!this.unsigned)\n            return this.sub(other).isNegative() ? -1 : 1;\n        return other.high >>> 0 > this.high >>> 0 ||\n            (other.high === this.high && other.low >>> 0 > this.low >>> 0)\n            ? -1\n            : 1;\n    }\n    comp(other) {\n        return this.compare(other);\n    }\n    divide(divisor) {\n        if (!Long.isLong(divisor))\n            divisor = Long.fromValue(divisor);\n        if (divisor.isZero())\n            throw new BSONError('division by zero');\n        if (wasm) {\n            if (!this.unsigned &&\n                this.high === -0x80000000 &&\n                divisor.low === -1 &&\n                divisor.high === -1) {\n                return this;\n            }\n            const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (this.isZero())\n            return this.unsigned ? Long.UZERO : Long.ZERO;\n        let approx, rem, res;\n        if (!this.unsigned) {\n            if (this.eq(Long.MIN_VALUE)) {\n                if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE))\n                    return Long.MIN_VALUE;\n                else if (divisor.eq(Long.MIN_VALUE))\n                    return Long.ONE;\n                else {\n                    const halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(Long.ZERO)) {\n                        return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\n                    }\n                    else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            }\n            else if (divisor.eq(Long.MIN_VALUE))\n                return this.unsigned ? Long.UZERO : Long.ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative())\n                    return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            }\n            else if (divisor.isNegative())\n                return this.div(divisor.neg()).neg();\n            res = Long.ZERO;\n        }\n        else {\n            if (!divisor.unsigned)\n                divisor = divisor.toUnsigned();\n            if (divisor.gt(this))\n                return Long.UZERO;\n            if (divisor.gt(this.shru(1)))\n                return Long.UONE;\n            res = Long.UZERO;\n        }\n        rem = this;\n        while (rem.gte(divisor)) {\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n            const log2 = Math.ceil(Math.log(approx) / Math.LN2);\n            const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n            let approxRes = Long.fromNumber(approx);\n            let approxRem = approxRes.mul(divisor);\n            while (approxRem.isNegative() || approxRem.gt(rem)) {\n                approx -= delta;\n                approxRes = Long.fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            }\n            if (approxRes.isZero())\n                approxRes = Long.ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    }\n    div(divisor) {\n        return this.divide(divisor);\n    }\n    equals(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)\n            return false;\n        return this.high === other.high && this.low === other.low;\n    }\n    eq(other) {\n        return this.equals(other);\n    }\n    getHighBits() {\n        return this.high;\n    }\n    getHighBitsUnsigned() {\n        return this.high >>> 0;\n    }\n    getLowBits() {\n        return this.low;\n    }\n    getLowBitsUnsigned() {\n        return this.low >>> 0;\n    }\n    getNumBitsAbs() {\n        if (this.isNegative()) {\n            return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        }\n        const val = this.high !== 0 ? this.high : this.low;\n        let bit;\n        for (bit = 31; bit > 0; bit--)\n            if ((val & (1 << bit)) !== 0)\n                break;\n        return this.high !== 0 ? bit + 33 : bit + 1;\n    }\n    greaterThan(other) {\n        return this.comp(other) > 0;\n    }\n    gt(other) {\n        return this.greaterThan(other);\n    }\n    greaterThanOrEqual(other) {\n        return this.comp(other) >= 0;\n    }\n    gte(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    ge(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    isEven() {\n        return (this.low & 1) === 0;\n    }\n    isNegative() {\n        return !this.unsigned && this.high < 0;\n    }\n    isOdd() {\n        return (this.low & 1) === 1;\n    }\n    isPositive() {\n        return this.unsigned || this.high >= 0;\n    }\n    isZero() {\n        return this.high === 0 && this.low === 0;\n    }\n    lessThan(other) {\n        return this.comp(other) < 0;\n    }\n    lt(other) {\n        return this.lessThan(other);\n    }\n    lessThanOrEqual(other) {\n        return this.comp(other) <= 0;\n    }\n    lte(other) {\n        return this.lessThanOrEqual(other);\n    }\n    modulo(divisor) {\n        if (!Long.isLong(divisor))\n            divisor = Long.fromValue(divisor);\n        if (wasm) {\n            const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    }\n    mod(divisor) {\n        return this.modulo(divisor);\n    }\n    rem(divisor) {\n        return this.modulo(divisor);\n    }\n    multiply(multiplier) {\n        if (this.isZero())\n            return Long.ZERO;\n        if (!Long.isLong(multiplier))\n            multiplier = Long.fromValue(multiplier);\n        if (wasm) {\n            const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (multiplier.isZero())\n            return Long.ZERO;\n        if (this.eq(Long.MIN_VALUE))\n            return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (multiplier.eq(Long.MIN_VALUE))\n            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative())\n                return this.neg().mul(multiplier.neg());\n            else\n                return this.neg().mul(multiplier).neg();\n        }\n        else if (multiplier.isNegative())\n            return this.mul(multiplier.neg()).neg();\n        if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24))\n            return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = multiplier.high >>> 16;\n        const b32 = multiplier.high & 0xffff;\n        const b16 = multiplier.low >>> 16;\n        const b00 = multiplier.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xffff;\n        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n    }\n    mul(multiplier) {\n        return this.multiply(multiplier);\n    }\n    negate() {\n        if (!this.unsigned && this.eq(Long.MIN_VALUE))\n            return Long.MIN_VALUE;\n        return this.not().add(Long.ONE);\n    }\n    neg() {\n        return this.negate();\n    }\n    not() {\n        return Long.fromBits(~this.low, ~this.high, this.unsigned);\n    }\n    notEquals(other) {\n        return !this.equals(other);\n    }\n    neq(other) {\n        return this.notEquals(other);\n    }\n    ne(other) {\n        return this.notEquals(other);\n    }\n    or(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    }\n    shiftLeft(numBits) {\n        if (Long.isLong(numBits))\n            numBits = numBits.toInt();\n        if ((numBits &= 63) === 0)\n            return this;\n        else if (numBits < 32)\n            return Long.fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\n        else\n            return Long.fromBits(0, this.low << (numBits - 32), this.unsigned);\n    }\n    shl(numBits) {\n        return this.shiftLeft(numBits);\n    }\n    shiftRight(numBits) {\n        if (Long.isLong(numBits))\n            numBits = numBits.toInt();\n        if ((numBits &= 63) === 0)\n            return this;\n        else if (numBits < 32)\n            return Long.fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\n        else\n            return Long.fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\n    }\n    shr(numBits) {\n        return this.shiftRight(numBits);\n    }\n    shiftRightUnsigned(numBits) {\n        if (Long.isLong(numBits))\n            numBits = numBits.toInt();\n        numBits &= 63;\n        if (numBits === 0)\n            return this;\n        else {\n            const high = this.high;\n            if (numBits < 32) {\n                const low = this.low;\n                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\n            }\n            else if (numBits === 32)\n                return Long.fromBits(high, 0, this.unsigned);\n            else\n                return Long.fromBits(high >>> (numBits - 32), 0, this.unsigned);\n        }\n    }\n    shr_u(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    shru(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    subtract(subtrahend) {\n        if (!Long.isLong(subtrahend))\n            subtrahend = Long.fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    }\n    sub(subtrahend) {\n        return this.subtract(subtrahend);\n    }\n    toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    }\n    toNumber() {\n        if (this.unsigned)\n            return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    }\n    toBigInt() {\n        return BigInt(this.toString());\n    }\n    toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    }\n    toBytesLE() {\n        const hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            (lo >>> 8) & 0xff,\n            (lo >>> 16) & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            (hi >>> 8) & 0xff,\n            (hi >>> 16) & 0xff,\n            hi >>> 24\n        ];\n    }\n    toBytesBE() {\n        const hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            (hi >>> 16) & 0xff,\n            (hi >>> 8) & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            (lo >>> 16) & 0xff,\n            (lo >>> 8) & 0xff,\n            lo & 0xff\n        ];\n    }\n    toSigned() {\n        if (!this.unsigned)\n            return this;\n        return Long.fromBits(this.low, this.high, false);\n    }\n    toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix)\n            throw new BSONError('radix');\n        if (this.isZero())\n            return '0';\n        if (this.isNegative()) {\n            if (this.eq(Long.MIN_VALUE)) {\n                const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            }\n            else\n                return '-' + this.neg().toString(radix);\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);\n        let rem = this;\n        let result = '';\n        while (true) {\n            const remDiv = rem.div(radixToPower);\n            const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;\n            let digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) {\n                return digits + result;\n            }\n            else {\n                while (digits.length < 6)\n                    digits = '0' + digits;\n                result = '' + digits + result;\n            }\n        }\n    }\n    toUnsigned() {\n        if (this.unsigned)\n            return this;\n        return Long.fromBits(this.low, this.high, true);\n    }\n    xor(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    }\n    eqz() {\n        return this.isZero();\n    }\n    le(other) {\n        return this.lessThanOrEqual(other);\n    }\n    toExtendedJSON(options) {\n        if (options && options.relaxed)\n            return this.toNumber();\n        return { $numberLong: this.toString() };\n    }\n    static fromExtendedJSON(doc, options) {\n        const { useBigInt64 = false, relaxed = true } = { ...options };\n        if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {\n            throw new BSONError('$numberLong string is too long');\n        }\n        if (!DECIMAL_REG_EX.test(doc.$numberLong)) {\n            throw new BSONError(`$numberLong string \"${doc.$numberLong}\" is in an invalid format`);\n        }\n        if (useBigInt64) {\n            const bigIntResult = BigInt(doc.$numberLong);\n            return BigInt.asIntN(64, bigIntResult);\n        }\n        const longResult = Long.fromString(doc.$numberLong);\n        if (relaxed) {\n            return longResult.toNumber();\n        }\n        return longResult;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new Long(\"${this.toString()}\"${this.unsigned ? ', true' : ''})`;\n    }\n}\nLong.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);\nLong.MAX_UNSIGNED_VALUE = Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);\nLong.ZERO = Long.fromInt(0);\nLong.UZERO = Long.fromInt(0, true);\nLong.ONE = Long.fromInt(1);\nLong.UONE = Long.fromInt(1, true);\nLong.NEG_ONE = Long.fromInt(-1);\nLong.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\nLong.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);\n\nconst PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\nconst PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\nconst PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\nconst EXPONENT_MAX = 6111;\nconst EXPONENT_MIN = -6176;\nconst EXPONENT_BIAS = 6176;\nconst MAX_DIGITS = 34;\nconst NAN_BUFFER = ByteUtils.fromNumberArray([\n    0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n].reverse());\nconst INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([\n    0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n].reverse());\nconst INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([\n    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n].reverse());\nconst EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\nconst COMBINATION_MASK = 0x1f;\nconst EXPONENT_MASK = 0x3fff;\nconst COMBINATION_INFINITY = 30;\nconst COMBINATION_NAN = 31;\nfunction isDigit(value) {\n    return !isNaN(parseInt(value, 10));\n}\nfunction divideu128(value) {\n    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);\n    let _rem = Long.fromNumber(0);\n    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\n        return { quotient: value, rem: _rem };\n    }\n    for (let i = 0; i <= 3; i++) {\n        _rem = _rem.shiftLeft(32);\n        _rem = _rem.add(new Long(value.parts[i], 0));\n        value.parts[i] = _rem.div(DIVISOR).low;\n        _rem = _rem.modulo(DIVISOR);\n    }\n    return { quotient: value, rem: _rem };\n}\nfunction multiply64x2(left, right) {\n    if (!left && !right) {\n        return { high: Long.fromNumber(0), low: Long.fromNumber(0) };\n    }\n    const leftHigh = left.shiftRightUnsigned(32);\n    const leftLow = new Long(left.getLowBits(), 0);\n    const rightHigh = right.shiftRightUnsigned(32);\n    const rightLow = new Long(right.getLowBits(), 0);\n    let productHigh = leftHigh.multiply(rightHigh);\n    let productMid = leftHigh.multiply(rightLow);\n    const productMid2 = leftLow.multiply(rightHigh);\n    let productLow = leftLow.multiply(rightLow);\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productMid = new Long(productMid.getLowBits(), 0)\n        .add(productMid2)\n        .add(productLow.shiftRightUnsigned(32));\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));\n    return { high: productHigh, low: productLow };\n}\nfunction lessThan(left, right) {\n    const uhleft = left.high >>> 0;\n    const uhright = right.high >>> 0;\n    if (uhleft < uhright) {\n        return true;\n    }\n    else if (uhleft === uhright) {\n        const ulleft = left.low >>> 0;\n        const ulright = right.low >>> 0;\n        if (ulleft < ulright)\n            return true;\n    }\n    return false;\n}\nfunction invalidErr(string, message) {\n    throw new BSONError(`\"${string}\" is not a valid Decimal128 string - ${message}`);\n}\nclass Decimal128 extends BSONValue {\n    get _bsontype() {\n        return 'Decimal128';\n    }\n    constructor(bytes) {\n        super();\n        if (typeof bytes === 'string') {\n            this.bytes = Decimal128.fromString(bytes).bytes;\n        }\n        else if (isUint8Array(bytes)) {\n            if (bytes.byteLength !== 16) {\n                throw new BSONError('Decimal128 must take a Buffer of 16 bytes');\n            }\n            this.bytes = bytes;\n        }\n        else {\n            throw new BSONError('Decimal128 must take a Buffer or string');\n        }\n    }\n    static fromString(representation) {\n        return Decimal128._fromString(representation, { allowRounding: false });\n    }\n    static fromStringWithRounding(representation) {\n        return Decimal128._fromString(representation, { allowRounding: true });\n    }\n    static _fromString(representation, options) {\n        let isNegative = false;\n        let sawSign = false;\n        let sawRadix = false;\n        let foundNonZero = false;\n        let significantDigits = 0;\n        let nDigitsRead = 0;\n        let nDigits = 0;\n        let radixPosition = 0;\n        let firstNonZero = 0;\n        const digits = [0];\n        let nDigitsStored = 0;\n        let digitsInsert = 0;\n        let lastDigit = 0;\n        let exponent = 0;\n        let significandHigh = new Long(0, 0);\n        let significandLow = new Long(0, 0);\n        let biasedExponent = 0;\n        let index = 0;\n        if (representation.length >= 7000) {\n            throw new BSONError('' + representation + ' not a valid Decimal128 string');\n        }\n        const stringMatch = representation.match(PARSE_STRING_REGEXP);\n        const infMatch = representation.match(PARSE_INF_REGEXP);\n        const nanMatch = representation.match(PARSE_NAN_REGEXP);\n        if ((!stringMatch && !infMatch && !nanMatch) || representation.length === 0) {\n            throw new BSONError('' + representation + ' not a valid Decimal128 string');\n        }\n        if (stringMatch) {\n            const unsignedNumber = stringMatch[2];\n            const e = stringMatch[4];\n            const expSign = stringMatch[5];\n            const expNumber = stringMatch[6];\n            if (e && expNumber === undefined)\n                invalidErr(representation, 'missing exponent power');\n            if (e && unsignedNumber === undefined)\n                invalidErr(representation, 'missing exponent base');\n            if (e === undefined && (expSign || expNumber)) {\n                invalidErr(representation, 'missing e before exponent');\n            }\n        }\n        if (representation[index] === '+' || representation[index] === '-') {\n            sawSign = true;\n            isNegative = representation[index++] === '-';\n        }\n        if (!isDigit(representation[index]) && representation[index] !== '.') {\n            if (representation[index] === 'i' || representation[index] === 'I') {\n                return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n            }\n            else if (representation[index] === 'N') {\n                return new Decimal128(NAN_BUFFER);\n            }\n        }\n        while (isDigit(representation[index]) || representation[index] === '.') {\n            if (representation[index] === '.') {\n                if (sawRadix)\n                    invalidErr(representation, 'contains multiple periods');\n                sawRadix = true;\n                index = index + 1;\n                continue;\n            }\n            if (nDigitsStored < MAX_DIGITS) {\n                if (representation[index] !== '0' || foundNonZero) {\n                    if (!foundNonZero) {\n                        firstNonZero = nDigitsRead;\n                    }\n                    foundNonZero = true;\n                    digits[digitsInsert++] = parseInt(representation[index], 10);\n                    nDigitsStored = nDigitsStored + 1;\n                }\n            }\n            if (foundNonZero)\n                nDigits = nDigits + 1;\n            if (sawRadix)\n                radixPosition = radixPosition + 1;\n            nDigitsRead = nDigitsRead + 1;\n            index = index + 1;\n        }\n        if (sawRadix && !nDigitsRead)\n            throw new BSONError('' + representation + ' not a valid Decimal128 string');\n        if (representation[index] === 'e' || representation[index] === 'E') {\n            const match = representation.substr(++index).match(EXPONENT_REGEX);\n            if (!match || !match[2])\n                return new Decimal128(NAN_BUFFER);\n            exponent = parseInt(match[0], 10);\n            index = index + match[0].length;\n        }\n        if (representation[index])\n            return new Decimal128(NAN_BUFFER);\n        if (!nDigitsStored) {\n            digits[0] = 0;\n            nDigits = 1;\n            nDigitsStored = 1;\n            significantDigits = 0;\n        }\n        else {\n            lastDigit = nDigitsStored - 1;\n            significantDigits = nDigits;\n            if (significantDigits !== 1) {\n                while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === '0') {\n                    significantDigits = significantDigits - 1;\n                }\n            }\n        }\n        if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {\n            exponent = EXPONENT_MIN;\n        }\n        else {\n            exponent = exponent - radixPosition;\n        }\n        while (exponent > EXPONENT_MAX) {\n            lastDigit = lastDigit + 1;\n            if (lastDigit >= MAX_DIGITS) {\n                if (significantDigits === 0) {\n                    exponent = EXPONENT_MAX;\n                    break;\n                }\n                invalidErr(representation, 'overflow');\n            }\n            exponent = exponent - 1;\n        }\n        if (options.allowRounding) {\n            while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {\n                if (lastDigit === 0 && significantDigits < nDigitsStored) {\n                    exponent = EXPONENT_MIN;\n                    significantDigits = 0;\n                    break;\n                }\n                if (nDigitsStored < nDigits) {\n                    nDigits = nDigits - 1;\n                }\n                else {\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                }\n                else {\n                    const digitsString = digits.join('');\n                    if (digitsString.match(/^0+$/)) {\n                        exponent = EXPONENT_MAX;\n                        break;\n                    }\n                    invalidErr(representation, 'overflow');\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                let endOfString = nDigitsRead;\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                let roundBit = 0;\n                if (roundDigit >= 5) {\n                    roundBit = 1;\n                    if (roundDigit === 5) {\n                        roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\n                        for (let i = firstNonZero + lastDigit + 2; i < endOfString; i++) {\n                            if (parseInt(representation[i], 10)) {\n                                roundBit = 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (roundBit) {\n                    let dIdx = lastDigit;\n                    for (; dIdx >= 0; dIdx--) {\n                        if (++digits[dIdx] > 9) {\n                            digits[dIdx] = 0;\n                            if (dIdx === 0) {\n                                if (exponent < EXPONENT_MAX) {\n                                    exponent = exponent + 1;\n                                    digits[dIdx] = 1;\n                                }\n                                else {\n                                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n                                }\n                            }\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {\n                if (lastDigit === 0) {\n                    if (significantDigits === 0) {\n                        exponent = EXPONENT_MIN;\n                        break;\n                    }\n                    invalidErr(representation, 'exponent underflow');\n                }\n                if (nDigitsStored < nDigits) {\n                    if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== '0' &&\n                        significantDigits !== 0) {\n                        invalidErr(representation, 'inexact rounding');\n                    }\n                    nDigits = nDigits - 1;\n                }\n                else {\n                    if (digits[lastDigit] !== 0) {\n                        invalidErr(representation, 'inexact rounding');\n                    }\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                }\n                else {\n                    invalidErr(representation, 'overflow');\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                if (roundDigit !== 0) {\n                    invalidErr(representation, 'inexact rounding');\n                }\n            }\n        }\n        significandHigh = Long.fromNumber(0);\n        significandLow = Long.fromNumber(0);\n        if (significantDigits === 0) {\n            significandHigh = Long.fromNumber(0);\n            significandLow = Long.fromNumber(0);\n        }\n        else if (lastDigit < 17) {\n            let dIdx = 0;\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            significandHigh = new Long(0, 0);\n            for (; dIdx <= lastDigit; dIdx++) {\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        }\n        else {\n            let dIdx = 0;\n            significandHigh = Long.fromNumber(digits[dIdx++]);\n            for (; dIdx <= lastDigit - 17; dIdx++) {\n                significandHigh = significandHigh.multiply(Long.fromNumber(10));\n                significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));\n            }\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            for (; dIdx <= lastDigit; dIdx++) {\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        }\n        const significand = multiply64x2(significandHigh, Long.fromString('100000000000000000'));\n        significand.low = significand.low.add(significandLow);\n        if (lessThan(significand.low, significandLow)) {\n            significand.high = significand.high.add(Long.fromNumber(1));\n        }\n        biasedExponent = exponent + EXPONENT_BIAS;\n        const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };\n        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {\n            dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));\n        }\n        else {\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));\n        }\n        dec.low = significand.low;\n        if (isNegative) {\n            dec.high = dec.high.or(Long.fromString('9223372036854775808'));\n        }\n        const buffer = ByteUtils.allocate(16);\n        index = 0;\n        buffer[index++] = dec.low.low & 0xff;\n        buffer[index++] = (dec.low.low >> 8) & 0xff;\n        buffer[index++] = (dec.low.low >> 16) & 0xff;\n        buffer[index++] = (dec.low.low >> 24) & 0xff;\n        buffer[index++] = dec.low.high & 0xff;\n        buffer[index++] = (dec.low.high >> 8) & 0xff;\n        buffer[index++] = (dec.low.high >> 16) & 0xff;\n        buffer[index++] = (dec.low.high >> 24) & 0xff;\n        buffer[index++] = dec.high.low & 0xff;\n        buffer[index++] = (dec.high.low >> 8) & 0xff;\n        buffer[index++] = (dec.high.low >> 16) & 0xff;\n        buffer[index++] = (dec.high.low >> 24) & 0xff;\n        buffer[index++] = dec.high.high & 0xff;\n        buffer[index++] = (dec.high.high >> 8) & 0xff;\n        buffer[index++] = (dec.high.high >> 16) & 0xff;\n        buffer[index++] = (dec.high.high >> 24) & 0xff;\n        return new Decimal128(buffer);\n    }\n    toString() {\n        let biased_exponent;\n        let significand_digits = 0;\n        const significand = new Array(36);\n        for (let i = 0; i < significand.length; i++)\n            significand[i] = 0;\n        let index = 0;\n        let is_zero = false;\n        let significand_msb;\n        let significand128 = { parts: [0, 0, 0, 0] };\n        let j, k;\n        const string = [];\n        index = 0;\n        const buffer = this.bytes;\n        const low = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        const midl = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        const midh = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        const high = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        index = 0;\n        const dec = {\n            low: new Long(low, midl),\n            high: new Long(midh, high)\n        };\n        if (dec.high.lessThan(Long.ZERO)) {\n            string.push('-');\n        }\n        const combination = (high >> 26) & COMBINATION_MASK;\n        if (combination >> 3 === 3) {\n            if (combination === COMBINATION_INFINITY) {\n                return string.join('') + 'Infinity';\n            }\n            else if (combination === COMBINATION_NAN) {\n                return 'NaN';\n            }\n            else {\n                biased_exponent = (high >> 15) & EXPONENT_MASK;\n                significand_msb = 0x08 + ((high >> 14) & 0x01);\n            }\n        }\n        else {\n            significand_msb = (high >> 14) & 0x07;\n            biased_exponent = (high >> 17) & EXPONENT_MASK;\n        }\n        const exponent = biased_exponent - EXPONENT_BIAS;\n        significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);\n        significand128.parts[1] = midh;\n        significand128.parts[2] = midl;\n        significand128.parts[3] = low;\n        if (significand128.parts[0] === 0 &&\n            significand128.parts[1] === 0 &&\n            significand128.parts[2] === 0 &&\n            significand128.parts[3] === 0) {\n            is_zero = true;\n        }\n        else {\n            for (k = 3; k >= 0; k--) {\n                let least_digits = 0;\n                const result = divideu128(significand128);\n                significand128 = result.quotient;\n                least_digits = result.rem.low;\n                if (!least_digits)\n                    continue;\n                for (j = 8; j >= 0; j--) {\n                    significand[k * 9 + j] = least_digits % 10;\n                    least_digits = Math.floor(least_digits / 10);\n                }\n            }\n        }\n        if (is_zero) {\n            significand_digits = 1;\n            significand[index] = 0;\n        }\n        else {\n            significand_digits = 36;\n            while (!significand[index]) {\n                significand_digits = significand_digits - 1;\n                index = index + 1;\n            }\n        }\n        const scientific_exponent = significand_digits - 1 + exponent;\n        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\n            if (significand_digits > 34) {\n                string.push(`${0}`);\n                if (exponent > 0)\n                    string.push(`E+${exponent}`);\n                else if (exponent < 0)\n                    string.push(`E${exponent}`);\n                return string.join('');\n            }\n            string.push(`${significand[index++]}`);\n            significand_digits = significand_digits - 1;\n            if (significand_digits) {\n                string.push('.');\n            }\n            for (let i = 0; i < significand_digits; i++) {\n                string.push(`${significand[index++]}`);\n            }\n            string.push('E');\n            if (scientific_exponent > 0) {\n                string.push(`+${scientific_exponent}`);\n            }\n            else {\n                string.push(`${scientific_exponent}`);\n            }\n        }\n        else {\n            if (exponent >= 0) {\n                for (let i = 0; i < significand_digits; i++) {\n                    string.push(`${significand[index++]}`);\n                }\n            }\n            else {\n                let radix_position = significand_digits + exponent;\n                if (radix_position > 0) {\n                    for (let i = 0; i < radix_position; i++) {\n                        string.push(`${significand[index++]}`);\n                    }\n                }\n                else {\n                    string.push('0');\n                }\n                string.push('.');\n                while (radix_position++ < 0) {\n                    string.push('0');\n                }\n                for (let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {\n                    string.push(`${significand[index++]}`);\n                }\n            }\n        }\n        return string.join('');\n    }\n    toJSON() {\n        return { $numberDecimal: this.toString() };\n    }\n    toExtendedJSON() {\n        return { $numberDecimal: this.toString() };\n    }\n    static fromExtendedJSON(doc) {\n        return Decimal128.fromString(doc.$numberDecimal);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new Decimal128(\"${this.toString()}\")`;\n    }\n}\n\nclass Double extends BSONValue {\n    get _bsontype() {\n        return 'Double';\n    }\n    constructor(value) {\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toExtendedJSON(options) {\n        if (options && (options.legacy || (options.relaxed && isFinite(this.value)))) {\n            return this.value;\n        }\n        if (Object.is(Math.sign(this.value), -0)) {\n            return { $numberDouble: '-0.0' };\n        }\n        return {\n            $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        const doubleValue = parseFloat(doc.$numberDouble);\n        return options && options.relaxed ? doubleValue : new Double(doubleValue);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        const eJSON = this.toExtendedJSON();\n        return `new Double(${eJSON.$numberDouble})`;\n    }\n}\n\nclass Int32 extends BSONValue {\n    get _bsontype() {\n        return 'Int32';\n    }\n    constructor(value) {\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value | 0;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON(options) {\n        if (options && (options.relaxed || options.legacy))\n            return this.value;\n        return { $numberInt: this.value.toString() };\n    }\n    static fromExtendedJSON(doc, options) {\n        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new Int32(${this.valueOf()})`;\n    }\n}\n\nclass MaxKey extends BSONValue {\n    get _bsontype() {\n        return 'MaxKey';\n    }\n    toExtendedJSON() {\n        return { $maxKey: 1 };\n    }\n    static fromExtendedJSON() {\n        return new MaxKey();\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return 'new MaxKey()';\n    }\n}\n\nclass MinKey extends BSONValue {\n    get _bsontype() {\n        return 'MinKey';\n    }\n    toExtendedJSON() {\n        return { $minKey: 1 };\n    }\n    static fromExtendedJSON() {\n        return new MinKey();\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return 'new MinKey()';\n    }\n}\n\nconst checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');\nlet PROCESS_UNIQUE = null;\nconst kId = Symbol('id');\nclass ObjectId extends BSONValue {\n    get _bsontype() {\n        return 'ObjectId';\n    }\n    constructor(inputId) {\n        super();\n        let workingId;\n        if (typeof inputId === 'object' && inputId && 'id' in inputId) {\n            if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) {\n                throw new BSONError('Argument passed in must have an id that is of type string or Buffer');\n            }\n            if ('toHexString' in inputId && typeof inputId.toHexString === 'function') {\n                workingId = ByteUtils.fromHex(inputId.toHexString());\n            }\n            else {\n                workingId = inputId.id;\n            }\n        }\n        else {\n            workingId = inputId;\n        }\n        if (workingId == null || typeof workingId === 'number') {\n            this[kId] = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined);\n        }\n        else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n            this[kId] = ByteUtils.toLocalBufferType(workingId);\n        }\n        else if (typeof workingId === 'string') {\n            if (workingId.length === 12) {\n                const bytes = ByteUtils.fromUTF8(workingId);\n                if (bytes.byteLength === 12) {\n                    this[kId] = bytes;\n                }\n                else {\n                    throw new BSONError('Argument passed in must be a string of 12 bytes');\n                }\n            }\n            else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {\n                this[kId] = ByteUtils.fromHex(workingId);\n            }\n            else {\n                throw new BSONError('Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer');\n            }\n        }\n        else {\n            throw new BSONError('Argument passed in does not match the accepted types');\n        }\n        if (ObjectId.cacheHexString) {\n            this.__id = ByteUtils.toHex(this.id);\n        }\n    }\n    get id() {\n        return this[kId];\n    }\n    set id(value) {\n        this[kId] = value;\n        if (ObjectId.cacheHexString) {\n            this.__id = ByteUtils.toHex(value);\n        }\n    }\n    toHexString() {\n        if (ObjectId.cacheHexString && this.__id) {\n            return this.__id;\n        }\n        const hexString = ByteUtils.toHex(this.id);\n        if (ObjectId.cacheHexString && !this.__id) {\n            this.__id = hexString;\n        }\n        return hexString;\n    }\n    static getInc() {\n        return (ObjectId.index = (ObjectId.index + 1) % 0xffffff);\n    }\n    static generate(time) {\n        if ('number' !== typeof time) {\n            time = Math.floor(Date.now() / 1000);\n        }\n        const inc = ObjectId.getInc();\n        const buffer = ByteUtils.allocate(12);\n        BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);\n        if (PROCESS_UNIQUE === null) {\n            PROCESS_UNIQUE = ByteUtils.randomBytes(5);\n        }\n        buffer[4] = PROCESS_UNIQUE[0];\n        buffer[5] = PROCESS_UNIQUE[1];\n        buffer[6] = PROCESS_UNIQUE[2];\n        buffer[7] = PROCESS_UNIQUE[3];\n        buffer[8] = PROCESS_UNIQUE[4];\n        buffer[11] = inc & 0xff;\n        buffer[10] = (inc >> 8) & 0xff;\n        buffer[9] = (inc >> 16) & 0xff;\n        return buffer;\n    }\n    toString(encoding) {\n        if (encoding === 'base64')\n            return ByteUtils.toBase64(this.id);\n        if (encoding === 'hex')\n            return this.toHexString();\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    equals(otherId) {\n        if (otherId === undefined || otherId === null) {\n            return false;\n        }\n        if (otherId instanceof ObjectId) {\n            return this[kId][11] === otherId[kId][11] && ByteUtils.equals(this[kId], otherId[kId]);\n        }\n        if (typeof otherId === 'string' &&\n            ObjectId.isValid(otherId) &&\n            otherId.length === 12 &&\n            isUint8Array(this.id)) {\n            return ByteUtils.equals(this.id, ByteUtils.fromISO88591(otherId));\n        }\n        if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 24) {\n            return otherId.toLowerCase() === this.toHexString();\n        }\n        if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 12) {\n            return ByteUtils.equals(ByteUtils.fromUTF8(otherId), this.id);\n        }\n        if (typeof otherId === 'object' &&\n            'toHexString' in otherId &&\n            typeof otherId.toHexString === 'function') {\n            const otherIdString = otherId.toHexString();\n            const thisIdString = this.toHexString().toLowerCase();\n            return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString;\n        }\n        return false;\n    }\n    getTimestamp() {\n        const timestamp = new Date();\n        const time = BSONDataView.fromUint8Array(this.id).getUint32(0, false);\n        timestamp.setTime(Math.floor(time) * 1000);\n        return timestamp;\n    }\n    static createPk() {\n        return new ObjectId();\n    }\n    static createFromTime(time) {\n        const buffer = ByteUtils.fromNumberArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n        BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);\n        return new ObjectId(buffer);\n    }\n    static createFromHexString(hexString) {\n        if (hexString?.length !== 24) {\n            throw new BSONError('hex string must be 24 characters');\n        }\n        return new ObjectId(ByteUtils.fromHex(hexString));\n    }\n    static createFromBase64(base64) {\n        if (base64?.length !== 16) {\n            throw new BSONError('base64 string must be 16 characters');\n        }\n        return new ObjectId(ByteUtils.fromBase64(base64));\n    }\n    static isValid(id) {\n        if (id == null)\n            return false;\n        try {\n            new ObjectId(id);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    toExtendedJSON() {\n        if (this.toHexString)\n            return { $oid: this.toHexString() };\n        return { $oid: this.toString('hex') };\n    }\n    static fromExtendedJSON(doc) {\n        return new ObjectId(doc.$oid);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new ObjectId(\"${this.toHexString()}\")`;\n    }\n}\nObjectId.index = Math.floor(Math.random() * 0xffffff);\n\nfunction internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {\n    let totalLength = 4 + 1;\n    if (Array.isArray(object)) {\n        for (let i = 0; i < object.length; i++) {\n            totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);\n        }\n    }\n    else {\n        if (typeof object?.toBSON === 'function') {\n            object = object.toBSON();\n        }\n        for (const key of Object.keys(object)) {\n            totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);\n        }\n    }\n    return totalLength;\n}\nfunction calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {\n    if (typeof value?.toBSON === 'function') {\n        value = value.toBSON();\n    }\n    switch (typeof value) {\n        case 'string':\n            return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;\n        case 'number':\n            if (Math.floor(value) === value &&\n                value >= JS_INT_MIN &&\n                value <= JS_INT_MAX) {\n                if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);\n                }\n                else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n                }\n            }\n            else {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n        case 'undefined':\n            if (isArray || !ignoreUndefined)\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            return 0;\n        case 'boolean':\n            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);\n        case 'object':\n            if (value != null &&\n                typeof value._bsontype === 'string' &&\n                value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            }\n            else if (value == null || value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            }\n            else if (value._bsontype === 'ObjectId') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);\n            }\n            else if (value instanceof Date || isDate(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n            else if (ArrayBuffer.isView(value) ||\n                value instanceof ArrayBuffer ||\n                isAnyArrayBuffer(value)) {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength);\n            }\n            else if (value._bsontype === 'Long' ||\n                value._bsontype === 'Double' ||\n                value._bsontype === 'Timestamp') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n            else if (value._bsontype === 'Decimal128') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);\n            }\n            else if (value._bsontype === 'Code') {\n                if (value.scope != null && Object.keys(value.scope).length > 0) {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                        1 +\n                        4 +\n                        4 +\n                        ByteUtils.utf8ByteLength(value.code.toString()) +\n                        1 +\n                        internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined));\n                }\n                else {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                        1 +\n                        4 +\n                        ByteUtils.utf8ByteLength(value.code.toString()) +\n                        1);\n                }\n            }\n            else if (value._bsontype === 'Binary') {\n                const binary = value;\n                if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                        (binary.position + 1 + 4 + 1 + 4));\n                }\n                else {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1));\n                }\n            }\n            else if (value._bsontype === 'Symbol') {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    ByteUtils.utf8ByteLength(value.value) +\n                    4 +\n                    1 +\n                    1);\n            }\n            else if (value._bsontype === 'DBRef') {\n                const ordered_values = Object.assign({\n                    $ref: value.collection,\n                    $id: value.oid\n                }, value.fields);\n                if (value.db != null) {\n                    ordered_values['$db'] = value.db;\n                }\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined));\n            }\n            else if (value instanceof RegExp || isRegExp(value)) {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    ByteUtils.utf8ByteLength(value.source) +\n                    1 +\n                    (value.global ? 1 : 0) +\n                    (value.ignoreCase ? 1 : 0) +\n                    (value.multiline ? 1 : 0) +\n                    1);\n            }\n            else if (value._bsontype === 'BSONRegExp') {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    ByteUtils.utf8ByteLength(value.pattern) +\n                    1 +\n                    ByteUtils.utf8ByteLength(value.options) +\n                    1);\n            }\n            else {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) +\n                    1);\n            }\n        case 'function':\n            if (serializeFunctions) {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    4 +\n                    ByteUtils.utf8ByteLength(value.toString()) +\n                    1);\n            }\n    }\n    return 0;\n}\n\nfunction alphabetize(str) {\n    return str.split('').sort().join('');\n}\nclass BSONRegExp extends BSONValue {\n    get _bsontype() {\n        return 'BSONRegExp';\n    }\n    constructor(pattern, options) {\n        super();\n        this.pattern = pattern;\n        this.options = alphabetize(options ?? '');\n        if (this.pattern.indexOf('\\x00') !== -1) {\n            throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);\n        }\n        if (this.options.indexOf('\\x00') !== -1) {\n            throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);\n        }\n        for (let i = 0; i < this.options.length; i++) {\n            if (!(this.options[i] === 'i' ||\n                this.options[i] === 'm' ||\n                this.options[i] === 'x' ||\n                this.options[i] === 'l' ||\n                this.options[i] === 's' ||\n                this.options[i] === 'u')) {\n                throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);\n            }\n        }\n    }\n    static parseOptions(options) {\n        return options ? options.split('').sort().join('') : '';\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        if (options.legacy) {\n            return { $regex: this.pattern, $options: this.options };\n        }\n        return { $regularExpression: { pattern: this.pattern, options: this.options } };\n    }\n    static fromExtendedJSON(doc) {\n        if ('$regex' in doc) {\n            if (typeof doc.$regex !== 'string') {\n                if (doc.$regex._bsontype === 'BSONRegExp') {\n                    return doc;\n                }\n            }\n            else {\n                return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));\n            }\n        }\n        if ('$regularExpression' in doc) {\n            return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));\n        }\n        throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new BSONRegExp(${JSON.stringify(this.pattern)}, ${JSON.stringify(this.options)})`;\n    }\n}\n\nclass BSONSymbol extends BSONValue {\n    get _bsontype() {\n        return 'BSONSymbol';\n    }\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString() {\n        return this.value;\n    }\n    inspect() {\n        return `new BSONSymbol(\"${this.value}\")`;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON() {\n        return { $symbol: this.value };\n    }\n    static fromExtendedJSON(doc) {\n        return new BSONSymbol(doc.$symbol);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n}\n\nconst LongWithoutOverridesClass = Long;\nclass Timestamp extends LongWithoutOverridesClass {\n    get _bsontype() {\n        return 'Timestamp';\n    }\n    constructor(low) {\n        if (low == null) {\n            super(0, 0, true);\n        }\n        else if (typeof low === 'bigint') {\n            super(low, true);\n        }\n        else if (Long.isLong(low)) {\n            super(low.low, low.high, true);\n        }\n        else if (typeof low === 'object' && 't' in low && 'i' in low) {\n            if (typeof low.t !== 'number' && (typeof low.t !== 'object' || low.t._bsontype !== 'Int32')) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide t as a number');\n            }\n            if (typeof low.i !== 'number' && (typeof low.i !== 'object' || low.i._bsontype !== 'Int32')) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide i as a number');\n            }\n            const t = Number(low.t);\n            const i = Number(low.i);\n            if (t < 0 || Number.isNaN(t)) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide a positive t');\n            }\n            if (i < 0 || Number.isNaN(i)) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide a positive i');\n            }\n            if (t > 4294967295) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide t equal or less than uint32 max');\n            }\n            if (i > 4294967295) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide i equal or less than uint32 max');\n            }\n            super(i, t, true);\n        }\n        else {\n            throw new BSONError('A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }');\n        }\n    }\n    toJSON() {\n        return {\n            $timestamp: this.toString()\n        };\n    }\n    static fromInt(value) {\n        return new Timestamp(Long.fromInt(value, true));\n    }\n    static fromNumber(value) {\n        return new Timestamp(Long.fromNumber(value, true));\n    }\n    static fromBits(lowBits, highBits) {\n        return new Timestamp({ i: lowBits, t: highBits });\n    }\n    static fromString(str, optRadix) {\n        return new Timestamp(Long.fromString(str, true, optRadix));\n    }\n    toExtendedJSON() {\n        return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };\n    }\n    static fromExtendedJSON(doc) {\n        const i = Long.isLong(doc.$timestamp.i)\n            ? doc.$timestamp.i.getLowBitsUnsigned()\n            : doc.$timestamp.i;\n        const t = Long.isLong(doc.$timestamp.t)\n            ? doc.$timestamp.t.getLowBitsUnsigned()\n            : doc.$timestamp.t;\n        return new Timestamp({ t, i });\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new Timestamp({ t: ${this.getHighBits()}, i: ${this.getLowBits()} })`;\n    }\n}\nTimestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;\n\nconst FIRST_BIT = 0x80;\nconst FIRST_TWO_BITS = 0xc0;\nconst FIRST_THREE_BITS = 0xe0;\nconst FIRST_FOUR_BITS = 0xf0;\nconst FIRST_FIVE_BITS = 0xf8;\nconst TWO_BIT_CHAR = 0xc0;\nconst THREE_BIT_CHAR = 0xe0;\nconst FOUR_BIT_CHAR = 0xf0;\nconst CONTINUING_CHAR = 0x80;\nfunction validateUtf8(bytes, start, end) {\n    let continuation = 0;\n    for (let i = start; i < end; i += 1) {\n        const byte = bytes[i];\n        if (continuation) {\n            if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {\n                return false;\n            }\n            continuation -= 1;\n        }\n        else if (byte & FIRST_BIT) {\n            if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {\n                continuation = 1;\n            }\n            else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {\n                continuation = 2;\n            }\n            else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {\n                continuation = 3;\n            }\n            else {\n                return false;\n            }\n        }\n    }\n    return !continuation;\n}\n\nconst JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);\nconst JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);\nfunction internalDeserialize(buffer, options, isArray) {\n    options = options == null ? {} : options;\n    const index = options && options.index ? options.index : 0;\n    const size = buffer[index] |\n        (buffer[index + 1] << 8) |\n        (buffer[index + 2] << 16) |\n        (buffer[index + 3] << 24);\n    if (size < 5) {\n        throw new BSONError(`bson size must be >= 5, is ${size}`);\n    }\n    if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {\n        throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);\n    }\n    if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {\n        throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`);\n    }\n    if (size + index > buffer.byteLength) {\n        throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`);\n    }\n    if (buffer[index + size - 1] !== 0) {\n        throw new BSONError(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n    }\n    return deserializeObject(buffer, index, options, isArray);\n}\nconst allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\nfunction deserializeObject(buffer, index, options, isArray = false) {\n    const fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];\n    const raw = options['raw'] == null ? false : options['raw'];\n    const bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;\n    const promoteBuffers = options.promoteBuffers ?? false;\n    const promoteLongs = options.promoteLongs ?? true;\n    const promoteValues = options.promoteValues ?? true;\n    const useBigInt64 = options.useBigInt64 ?? false;\n    if (useBigInt64 && !promoteValues) {\n        throw new BSONError('Must either request bigint or Long for int64 deserialization');\n    }\n    if (useBigInt64 && !promoteLongs) {\n        throw new BSONError('Must either request bigint or Long for int64 deserialization');\n    }\n    const validation = options.validation == null ? { utf8: true } : options.validation;\n    let globalUTFValidation = true;\n    let validationSetting;\n    const utf8KeysSet = new Set();\n    const utf8ValidatedKeys = validation.utf8;\n    if (typeof utf8ValidatedKeys === 'boolean') {\n        validationSetting = utf8ValidatedKeys;\n    }\n    else {\n        globalUTFValidation = false;\n        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {\n            return utf8ValidatedKeys[key];\n        });\n        if (utf8ValidationValues.length === 0) {\n            throw new BSONError('UTF-8 validation setting cannot be empty');\n        }\n        if (typeof utf8ValidationValues[0] !== 'boolean') {\n            throw new BSONError('Invalid UTF-8 validation option, must specify boolean values');\n        }\n        validationSetting = utf8ValidationValues[0];\n        if (!utf8ValidationValues.every(item => item === validationSetting)) {\n            throw new BSONError('Invalid UTF-8 validation option - keys must be all true or all false');\n        }\n    }\n    if (!globalUTFValidation) {\n        for (const key of Object.keys(utf8ValidatedKeys)) {\n            utf8KeysSet.add(key);\n        }\n    }\n    const startIndex = index;\n    if (buffer.length < 5)\n        throw new BSONError('corrupt bson message < 5 bytes long');\n    const size = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n    if (size < 5 || size > buffer.length)\n        throw new BSONError('corrupt bson message');\n    const object = isArray ? [] : {};\n    let arrayIndex = 0;\n    const done = false;\n    let isPossibleDBRef = isArray ? false : null;\n    const dataview = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    while (!done) {\n        const elementType = buffer[index++];\n        if (elementType === 0)\n            break;\n        let i = index;\n        while (buffer[i] !== 0x00 && i < buffer.length) {\n            i++;\n        }\n        if (i >= buffer.byteLength)\n            throw new BSONError('Bad BSON Document: illegal CString');\n        const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer, index, i);\n        let shouldValidateKey = true;\n        if (globalUTFValidation || utf8KeysSet.has(name)) {\n            shouldValidateKey = validationSetting;\n        }\n        else {\n            shouldValidateKey = !validationSetting;\n        }\n        if (isPossibleDBRef !== false && name[0] === '$') {\n            isPossibleDBRef = allowedDBRefKeys.test(name);\n        }\n        let value;\n        index = i + 1;\n        if (elementType === BSON_DATA_STRING) {\n            const stringSize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            value = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n        }\n        else if (elementType === BSON_DATA_OID) {\n            const oid = ByteUtils.allocate(12);\n            oid.set(buffer.subarray(index, index + 12));\n            value = new ObjectId(oid);\n            index = index + 12;\n        }\n        else if (elementType === BSON_DATA_INT && promoteValues === false) {\n            value = new Int32(buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24));\n        }\n        else if (elementType === BSON_DATA_INT) {\n            value =\n                buffer[index++] |\n                    (buffer[index++] << 8) |\n                    (buffer[index++] << 16) |\n                    (buffer[index++] << 24);\n        }\n        else if (elementType === BSON_DATA_NUMBER && promoteValues === false) {\n            value = new Double(dataview.getFloat64(index, true));\n            index = index + 8;\n        }\n        else if (elementType === BSON_DATA_NUMBER) {\n            value = dataview.getFloat64(index, true);\n            index = index + 8;\n        }\n        else if (elementType === BSON_DATA_DATE) {\n            const lowBits = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            const highBits = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            value = new Date(new Long(lowBits, highBits).toNumber());\n        }\n        else if (elementType === BSON_DATA_BOOLEAN) {\n            if (buffer[index] !== 0 && buffer[index] !== 1)\n                throw new BSONError('illegal boolean type value');\n            value = buffer[index++] === 1;\n        }\n        else if (elementType === BSON_DATA_OBJECT) {\n            const _index = index;\n            const objectSize = buffer[index] |\n                (buffer[index + 1] << 8) |\n                (buffer[index + 2] << 16) |\n                (buffer[index + 3] << 24);\n            if (objectSize <= 0 || objectSize > buffer.length - index)\n                throw new BSONError('bad embedded document length in bson');\n            if (raw) {\n                value = buffer.slice(index, index + objectSize);\n            }\n            else {\n                let objectOptions = options;\n                if (!globalUTFValidation) {\n                    objectOptions = { ...options, validation: { utf8: shouldValidateKey } };\n                }\n                value = deserializeObject(buffer, _index, objectOptions, false);\n            }\n            index = index + objectSize;\n        }\n        else if (elementType === BSON_DATA_ARRAY) {\n            const _index = index;\n            const objectSize = buffer[index] |\n                (buffer[index + 1] << 8) |\n                (buffer[index + 2] << 16) |\n                (buffer[index + 3] << 24);\n            let arrayOptions = options;\n            const stopIndex = index + objectSize;\n            if (fieldsAsRaw && fieldsAsRaw[name]) {\n                arrayOptions = { ...options, raw: true };\n            }\n            if (!globalUTFValidation) {\n                arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };\n            }\n            value = deserializeObject(buffer, _index, arrayOptions, true);\n            index = index + objectSize;\n            if (buffer[index - 1] !== 0)\n                throw new BSONError('invalid array terminator byte');\n            if (index !== stopIndex)\n                throw new BSONError('corrupted array bson');\n        }\n        else if (elementType === BSON_DATA_UNDEFINED) {\n            value = undefined;\n        }\n        else if (elementType === BSON_DATA_NULL) {\n            value = null;\n        }\n        else if (elementType === BSON_DATA_LONG) {\n            const dataview = BSONDataView.fromUint8Array(buffer.subarray(index, index + 8));\n            const lowBits = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            const highBits = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            const long = new Long(lowBits, highBits);\n            if (useBigInt64) {\n                value = dataview.getBigInt64(0, true);\n            }\n            else if (promoteLongs && promoteValues === true) {\n                value =\n                    long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG)\n                        ? long.toNumber()\n                        : long;\n            }\n            else {\n                value = long;\n            }\n        }\n        else if (elementType === BSON_DATA_DECIMAL128) {\n            const bytes = ByteUtils.allocate(16);\n            bytes.set(buffer.subarray(index, index + 16), 0);\n            index = index + 16;\n            value = new Decimal128(bytes);\n        }\n        else if (elementType === BSON_DATA_BINARY) {\n            let binarySize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            const totalBinarySize = binarySize;\n            const subType = buffer[index++];\n            if (binarySize < 0)\n                throw new BSONError('Negative binary type element size found');\n            if (binarySize > buffer.byteLength)\n                throw new BSONError('Binary type size larger than document size');\n            if (buffer['slice'] != null) {\n                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                    binarySize =\n                        buffer[index++] |\n                            (buffer[index++] << 8) |\n                            (buffer[index++] << 16) |\n                            (buffer[index++] << 24);\n                    if (binarySize < 0)\n                        throw new BSONError('Negative binary type element size found for subtype 0x02');\n                    if (binarySize > totalBinarySize - 4)\n                        throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\n                    if (binarySize < totalBinarySize - 4)\n                        throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\n                }\n                if (promoteBuffers && promoteValues) {\n                    value = ByteUtils.toLocalBufferType(buffer.slice(index, index + binarySize));\n                }\n                else {\n                    value = new Binary(buffer.slice(index, index + binarySize), subType);\n                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                        value = value.toUUID();\n                    }\n                }\n            }\n            else {\n                const _buffer = ByteUtils.allocate(binarySize);\n                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                    binarySize =\n                        buffer[index++] |\n                            (buffer[index++] << 8) |\n                            (buffer[index++] << 16) |\n                            (buffer[index++] << 24);\n                    if (binarySize < 0)\n                        throw new BSONError('Negative binary type element size found for subtype 0x02');\n                    if (binarySize > totalBinarySize - 4)\n                        throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\n                    if (binarySize < totalBinarySize - 4)\n                        throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\n                }\n                for (i = 0; i < binarySize; i++) {\n                    _buffer[i] = buffer[index + i];\n                }\n                if (promoteBuffers && promoteValues) {\n                    value = _buffer;\n                }\n                else {\n                    value = new Binary(buffer.slice(index, index + binarySize), subType);\n                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                        value = value.toUUID();\n                    }\n                }\n            }\n            index = index + binarySize;\n        }\n        else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const source = ByteUtils.toUTF8(buffer, index, i);\n            index = i + 1;\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i);\n            index = i + 1;\n            const optionsArray = new Array(regExpOptions.length);\n            for (i = 0; i < regExpOptions.length; i++) {\n                switch (regExpOptions[i]) {\n                    case 'm':\n                        optionsArray[i] = 'm';\n                        break;\n                    case 's':\n                        optionsArray[i] = 'g';\n                        break;\n                    case 'i':\n                        optionsArray[i] = 'i';\n                        break;\n                }\n            }\n            value = new RegExp(source, optionsArray.join(''));\n        }\n        else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const source = ByteUtils.toUTF8(buffer, index, i);\n            index = i + 1;\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i);\n            index = i + 1;\n            value = new BSONRegExp(source, regExpOptions);\n        }\n        else if (elementType === BSON_DATA_SYMBOL) {\n            const stringSize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            const symbol = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = promoteValues ? symbol : new BSONSymbol(symbol);\n            index = index + stringSize;\n        }\n        else if (elementType === BSON_DATA_TIMESTAMP) {\n            const i = buffer[index++] +\n                buffer[index++] * (1 << 8) +\n                buffer[index++] * (1 << 16) +\n                buffer[index++] * (1 << 24);\n            const t = buffer[index++] +\n                buffer[index++] * (1 << 8) +\n                buffer[index++] * (1 << 16) +\n                buffer[index++] * (1 << 24);\n            value = new Timestamp({ i, t });\n        }\n        else if (elementType === BSON_DATA_MIN_KEY) {\n            value = new MinKey();\n        }\n        else if (elementType === BSON_DATA_MAX_KEY) {\n            value = new MaxKey();\n        }\n        else if (elementType === BSON_DATA_CODE) {\n            const stringSize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            const functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = new Code(functionString);\n            index = index + stringSize;\n        }\n        else if (elementType === BSON_DATA_CODE_W_SCOPE) {\n            const totalSize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            if (totalSize < 4 + 4 + 4 + 1) {\n                throw new BSONError('code_w_scope total size shorter minimum expected length');\n            }\n            const stringSize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            const functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n            const _index = index;\n            const objectSize = buffer[index] |\n                (buffer[index + 1] << 8) |\n                (buffer[index + 2] << 16) |\n                (buffer[index + 3] << 24);\n            const scopeObject = deserializeObject(buffer, _index, options, false);\n            index = index + objectSize;\n            if (totalSize < 4 + 4 + objectSize + stringSize) {\n                throw new BSONError('code_w_scope total size is too short, truncating scope');\n            }\n            if (totalSize > 4 + 4 + objectSize + stringSize) {\n                throw new BSONError('code_w_scope total size is too long, clips outer document');\n            }\n            value = new Code(functionString, scopeObject);\n        }\n        else if (elementType === BSON_DATA_DBPOINTER) {\n            const stringSize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0)\n                throw new BSONError('bad string length in bson');\n            if (validation != null && validation.utf8) {\n                if (!validateUtf8(buffer, index, index + stringSize - 1)) {\n                    throw new BSONError('Invalid UTF-8 string in BSON document');\n                }\n            }\n            const namespace = ByteUtils.toUTF8(buffer, index, index + stringSize - 1);\n            index = index + stringSize;\n            const oidBuffer = ByteUtils.allocate(12);\n            oidBuffer.set(buffer.subarray(index, index + 12), 0);\n            const oid = new ObjectId(oidBuffer);\n            index = index + 12;\n            value = new DBRef(namespace, oid);\n        }\n        else {\n            throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname \"${name}\"`);\n        }\n        if (name === '__proto__') {\n            Object.defineProperty(object, name, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n        else {\n            object[name] = value;\n        }\n    }\n    if (size !== index - startIndex) {\n        if (isArray)\n            throw new BSONError('corrupt array bson');\n        throw new BSONError('corrupt object bson');\n    }\n    if (!isPossibleDBRef)\n        return object;\n    if (isDBRefLike(object)) {\n        const copy = Object.assign({}, object);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(object.$ref, object.$id, object.$db, copy);\n    }\n    return object;\n}\nfunction getValidatedString(buffer, start, end, shouldValidateUtf8) {\n    const value = ByteUtils.toUTF8(buffer, start, end);\n    if (shouldValidateUtf8) {\n        for (let i = 0; i < value.length; i++) {\n            if (value.charCodeAt(i) === 0xfffd) {\n                if (!validateUtf8(buffer, start, end)) {\n                    throw new BSONError('Invalid UTF-8 string in BSON document');\n                }\n                break;\n            }\n        }\n    }\n    return value;\n}\n\nconst regexp = /\\x00/;\nconst ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);\nfunction serializeString(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_STRING;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes + 1;\n    buffer[index - 1] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);\n    buffer[index + 3] = ((size + 1) >> 24) & 0xff;\n    buffer[index + 2] = ((size + 1) >> 16) & 0xff;\n    buffer[index + 1] = ((size + 1) >> 8) & 0xff;\n    buffer[index] = (size + 1) & 0xff;\n    index = index + 4 + size;\n    buffer[index++] = 0;\n    return index;\n}\nconst NUMBER_SPACE = new DataView(new ArrayBuffer(8), 0, 8);\nconst FOUR_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 4);\nconst EIGHT_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 8);\nfunction serializeNumber(buffer, key, value, index) {\n    const isNegativeZero = Object.is(value, -0);\n    const type = !isNegativeZero &&\n        Number.isSafeInteger(value) &&\n        value <= BSON_INT32_MAX &&\n        value >= BSON_INT32_MIN\n        ? BSON_DATA_INT\n        : BSON_DATA_NUMBER;\n    if (type === BSON_DATA_INT) {\n        NUMBER_SPACE.setInt32(0, value, true);\n    }\n    else {\n        NUMBER_SPACE.setFloat64(0, value, true);\n    }\n    const bytes = type === BSON_DATA_INT ? FOUR_BYTE_VIEW_ON_NUMBER : EIGHT_BYTE_VIEW_ON_NUMBER;\n    buffer[index++] = type;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0x00;\n    buffer.set(bytes, index);\n    index += bytes.byteLength;\n    return index;\n}\nfunction serializeBigInt(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_LONG;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index += numberOfWrittenBytes;\n    buffer[index++] = 0;\n    NUMBER_SPACE.setBigInt64(0, value, true);\n    buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);\n    index += EIGHT_BYTE_VIEW_ON_NUMBER.byteLength;\n    return index;\n}\nfunction serializeNull(buffer, key, _, index) {\n    buffer[index++] = BSON_DATA_NULL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeBoolean(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BOOLEAN;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value ? 1 : 0;\n    return index;\n}\nfunction serializeDate(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DATE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const dateInMilis = Long.fromNumber(value.getTime());\n    const lowBits = dateInMilis.getLowBits();\n    const highBits = dateInMilis.getHighBits();\n    buffer[index++] = lowBits & 0xff;\n    buffer[index++] = (lowBits >> 8) & 0xff;\n    buffer[index++] = (lowBits >> 16) & 0xff;\n    buffer[index++] = (lowBits >> 24) & 0xff;\n    buffer[index++] = highBits & 0xff;\n    buffer[index++] = (highBits >> 8) & 0xff;\n    buffer[index++] = (highBits >> 16) & 0xff;\n    buffer[index++] = (highBits >> 24) & 0xff;\n    return index;\n}\nfunction serializeRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.source && value.source.match(regexp) != null) {\n        throw new BSONError('value ' + value.source + ' must not contain null bytes');\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);\n    buffer[index++] = 0x00;\n    if (value.ignoreCase)\n        buffer[index++] = 0x69;\n    if (value.global)\n        buffer[index++] = 0x73;\n    if (value.multiline)\n        buffer[index++] = 0x6d;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeBSONRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.pattern.match(regexp) != null) {\n        throw new BSONError('pattern ' + value.pattern + ' must not contain null bytes');\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);\n    buffer[index++] = 0x00;\n    const sortedOptions = value.options.split('').sort().join('');\n    index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeMinMax(buffer, key, value, index) {\n    if (value === null) {\n        buffer[index++] = BSON_DATA_NULL;\n    }\n    else if (value._bsontype === 'MinKey') {\n        buffer[index++] = BSON_DATA_MIN_KEY;\n    }\n    else {\n        buffer[index++] = BSON_DATA_MAX_KEY;\n    }\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeObjectId(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_OID;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (isUint8Array(value.id)) {\n        buffer.set(value.id.subarray(0, 12), index);\n    }\n    else {\n        throw new BSONError('object [' + JSON.stringify(value) + '] is not a valid ObjectId');\n    }\n    return index + 12;\n}\nfunction serializeBuffer(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = value.length;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = (size >> 8) & 0xff;\n    buffer[index++] = (size >> 16) & 0xff;\n    buffer[index++] = (size >> 24) & 0xff;\n    buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT;\n    buffer.set(value, index);\n    index = index + size;\n    return index;\n}\nfunction serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path.has(value)) {\n        throw new BSONError('Cannot convert circular structure to BSON');\n    }\n    path.add(value);\n    buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n    path.delete(value);\n    return endIndex;\n}\nfunction serializeDecimal128(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DECIMAL128;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer.set(value.bytes.subarray(0, 16), index);\n    return index + 16;\n}\nfunction serializeLong(buffer, key, value, index) {\n    buffer[index++] =\n        value._bsontype === 'Long' ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const lowBits = value.getLowBits();\n    const highBits = value.getHighBits();\n    buffer[index++] = lowBits & 0xff;\n    buffer[index++] = (lowBits >> 8) & 0xff;\n    buffer[index++] = (lowBits >> 16) & 0xff;\n    buffer[index++] = (lowBits >> 24) & 0xff;\n    buffer[index++] = highBits & 0xff;\n    buffer[index++] = (highBits >> 8) & 0xff;\n    buffer[index++] = (highBits >> 16) & 0xff;\n    buffer[index++] = (highBits >> 24) & 0xff;\n    return index;\n}\nfunction serializeInt32(buffer, key, value, index) {\n    value = value.valueOf();\n    buffer[index++] = BSON_DATA_INT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value & 0xff;\n    buffer[index++] = (value >> 8) & 0xff;\n    buffer[index++] = (value >> 16) & 0xff;\n    buffer[index++] = (value >> 24) & 0xff;\n    return index;\n}\nfunction serializeDouble(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_NUMBER;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    NUMBER_SPACE.setFloat64(0, value.value, true);\n    buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);\n    index = index + 8;\n    return index;\n}\nfunction serializeFunction(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_CODE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const functionString = value.toString();\n    const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = (size >> 8) & 0xff;\n    buffer[index + 2] = (size >> 16) & 0xff;\n    buffer[index + 3] = (size >> 24) & 0xff;\n    index = index + 4 + size - 1;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeCode(buffer, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {\n    if (value.scope && typeof value.scope === 'object') {\n        buffer[index++] = BSON_DATA_CODE_W_SCOPE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        let startIndex = index;\n        const functionString = value.code;\n        index = index + 4;\n        const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        buffer[index] = codeSize & 0xff;\n        buffer[index + 1] = (codeSize >> 8) & 0xff;\n        buffer[index + 2] = (codeSize >> 16) & 0xff;\n        buffer[index + 3] = (codeSize >> 24) & 0xff;\n        buffer[index + 4 + codeSize - 1] = 0;\n        index = index + codeSize + 4;\n        const endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n        index = endIndex - 1;\n        const totalSize = endIndex - startIndex;\n        buffer[startIndex++] = totalSize & 0xff;\n        buffer[startIndex++] = (totalSize >> 8) & 0xff;\n        buffer[startIndex++] = (totalSize >> 16) & 0xff;\n        buffer[startIndex++] = (totalSize >> 24) & 0xff;\n        buffer[index++] = 0;\n    }\n    else {\n        buffer[index++] = BSON_DATA_CODE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        const functionString = value.code.toString();\n        const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        buffer[index] = size & 0xff;\n        buffer[index + 1] = (size >> 8) & 0xff;\n        buffer[index + 2] = (size >> 16) & 0xff;\n        buffer[index + 3] = (size >> 24) & 0xff;\n        index = index + 4 + size - 1;\n        buffer[index++] = 0;\n    }\n    return index;\n}\nfunction serializeBinary(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const data = value.buffer;\n    let size = value.position;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)\n        size = size + 4;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = (size >> 8) & 0xff;\n    buffer[index++] = (size >> 16) & 0xff;\n    buffer[index++] = (size >> 24) & 0xff;\n    buffer[index++] = value.sub_type;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n        size = size - 4;\n        buffer[index++] = size & 0xff;\n        buffer[index++] = (size >> 8) & 0xff;\n        buffer[index++] = (size >> 16) & 0xff;\n        buffer[index++] = (size >> 24) & 0xff;\n    }\n    buffer.set(data, index);\n    index = index + value.position;\n    return index;\n}\nfunction serializeSymbol(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_SYMBOL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = (size >> 8) & 0xff;\n    buffer[index + 2] = (size >> 16) & 0xff;\n    buffer[index + 3] = (size >> 24) & 0xff;\n    index = index + 4 + size - 1;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) {\n    buffer[index++] = BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    let startIndex = index;\n    let output = {\n        $ref: value.collection || value.namespace,\n        $id: value.oid\n    };\n    if (value.db != null) {\n        output.$db = value.db;\n    }\n    output = Object.assign(output, value.fields);\n    const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path);\n    const size = endIndex - startIndex;\n    buffer[startIndex++] = size & 0xff;\n    buffer[startIndex++] = (size >> 8) & 0xff;\n    buffer[startIndex++] = (size >> 16) & 0xff;\n    buffer[startIndex++] = (size >> 24) & 0xff;\n    return endIndex;\n}\nfunction serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path == null) {\n        if (object == null) {\n            buffer[0] = 0x05;\n            buffer[1] = 0x00;\n            buffer[2] = 0x00;\n            buffer[3] = 0x00;\n            buffer[4] = 0x00;\n            return 5;\n        }\n        if (Array.isArray(object)) {\n            throw new BSONError('serialize does not support an array as the root input');\n        }\n        if (typeof object !== 'object') {\n            throw new BSONError('serialize does not support non-object as the root input');\n        }\n        else if ('_bsontype' in object && typeof object._bsontype === 'string') {\n            throw new BSONError(`BSON types cannot be serialized as a document`);\n        }\n        else if (isDate(object) ||\n            isRegExp(object) ||\n            isUint8Array(object) ||\n            isAnyArrayBuffer(object)) {\n            throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);\n        }\n        path = new Set();\n    }\n    path.add(object);\n    let index = startingIndex + 4;\n    if (Array.isArray(object)) {\n        for (let i = 0; i < object.length; i++) {\n            const key = `${i}`;\n            let value = object[i];\n            if (typeof value?.toBSON === 'function') {\n                value = value.toBSON();\n            }\n            if (typeof value === 'string') {\n                index = serializeString(buffer, key, value, index);\n            }\n            else if (typeof value === 'number') {\n                index = serializeNumber(buffer, key, value, index);\n            }\n            else if (typeof value === 'bigint') {\n                index = serializeBigInt(buffer, key, value, index);\n            }\n            else if (typeof value === 'boolean') {\n                index = serializeBoolean(buffer, key, value, index);\n            }\n            else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            }\n            else if (value === undefined) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            }\n            else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            }\n            else if (typeof value === 'object' && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            }\n            else if (typeof value === 'object' &&\n                value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            }\n            else if (value._bsontype === 'ObjectId') {\n                index = serializeObjectId(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Decimal128') {\n                index = serializeDecimal128(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n                index = serializeLong(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Double') {\n                index = serializeDouble(buffer, key, value, index);\n            }\n            else if (typeof value === 'function' && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Code') {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            }\n            else if (value._bsontype === 'Binary') {\n                index = serializeBinary(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'BSONSymbol') {\n                index = serializeSymbol(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'DBRef') {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            }\n            else if (value._bsontype === 'BSONRegExp') {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Int32') {\n                index = serializeInt32(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                index = serializeMinMax(buffer, key, value, index);\n            }\n            else if (typeof value._bsontype !== 'undefined') {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    }\n    else if (object instanceof Map || isMap(object)) {\n        const iterator = object.entries();\n        let done = false;\n        while (!done) {\n            const entry = iterator.next();\n            done = !!entry.done;\n            if (done)\n                continue;\n            const key = entry.value[0];\n            let value = entry.value[1];\n            if (typeof value?.toBSON === 'function') {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === 'string' && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError('key ' + key + ' must not contain null bytes');\n                }\n                if (checkKeys) {\n                    if ('$' === key[0]) {\n                        throw new BSONError('key ' + key + \" must not start with '$'\");\n                    }\n                    else if (~key.indexOf('.')) {\n                        throw new BSONError('key ' + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (type === 'string') {\n                index = serializeString(buffer, key, value, index);\n            }\n            else if (type === 'number') {\n                index = serializeNumber(buffer, key, value, index);\n            }\n            else if (type === 'bigint') {\n                index = serializeBigInt(buffer, key, value, index);\n            }\n            else if (type === 'boolean') {\n                index = serializeBoolean(buffer, key, value, index);\n            }\n            else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            }\n            else if (value === null || (value === undefined && ignoreUndefined === false)) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            }\n            else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            }\n            else if (typeof value === 'object' &&\n                value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            }\n            else if (value._bsontype === 'ObjectId') {\n                index = serializeObjectId(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype === 'Decimal128') {\n                index = serializeDecimal128(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n                index = serializeLong(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Double') {\n                index = serializeDouble(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Code') {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            }\n            else if (typeof value === 'function' && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Binary') {\n                index = serializeBinary(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'BSONSymbol') {\n                index = serializeSymbol(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'DBRef') {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            }\n            else if (value._bsontype === 'BSONRegExp') {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Int32') {\n                index = serializeInt32(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                index = serializeMinMax(buffer, key, value, index);\n            }\n            else if (typeof value._bsontype !== 'undefined') {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    }\n    else {\n        if (typeof object?.toBSON === 'function') {\n            object = object.toBSON();\n            if (object != null && typeof object !== 'object') {\n                throw new BSONError('toBSON function did not return an object');\n            }\n        }\n        for (const key of Object.keys(object)) {\n            let value = object[key];\n            if (typeof value?.toBSON === 'function') {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === 'string' && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError('key ' + key + ' must not contain null bytes');\n                }\n                if (checkKeys) {\n                    if ('$' === key[0]) {\n                        throw new BSONError('key ' + key + \" must not start with '$'\");\n                    }\n                    else if (~key.indexOf('.')) {\n                        throw new BSONError('key ' + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (type === 'string') {\n                index = serializeString(buffer, key, value, index);\n            }\n            else if (type === 'number') {\n                index = serializeNumber(buffer, key, value, index);\n            }\n            else if (type === 'bigint') {\n                index = serializeBigInt(buffer, key, value, index);\n            }\n            else if (type === 'boolean') {\n                index = serializeBoolean(buffer, key, value, index);\n            }\n            else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            }\n            else if (value === undefined) {\n                if (ignoreUndefined === false)\n                    index = serializeNull(buffer, key, value, index);\n            }\n            else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            }\n            else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            }\n            else if (typeof value === 'object' &&\n                value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            }\n            else if (value._bsontype === 'ObjectId') {\n                index = serializeObjectId(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype === 'Decimal128') {\n                index = serializeDecimal128(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n                index = serializeLong(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Double') {\n                index = serializeDouble(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Code') {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            }\n            else if (typeof value === 'function' && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Binary') {\n                index = serializeBinary(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'BSONSymbol') {\n                index = serializeSymbol(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'DBRef') {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            }\n            else if (value._bsontype === 'BSONRegExp') {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Int32') {\n                index = serializeInt32(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                index = serializeMinMax(buffer, key, value, index);\n            }\n            else if (typeof value._bsontype !== 'undefined') {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    }\n    path.delete(object);\n    buffer[index++] = 0x00;\n    const size = index - startingIndex;\n    buffer[startingIndex++] = size & 0xff;\n    buffer[startingIndex++] = (size >> 8) & 0xff;\n    buffer[startingIndex++] = (size >> 16) & 0xff;\n    buffer[startingIndex++] = (size >> 24) & 0xff;\n    return index;\n}\n\nfunction isBSONType(value) {\n    return (value != null &&\n        typeof value === 'object' &&\n        '_bsontype' in value &&\n        typeof value._bsontype === 'string');\n}\nconst keysToCodecs = {\n    $oid: ObjectId,\n    $binary: Binary,\n    $uuid: Binary,\n    $symbol: BSONSymbol,\n    $numberInt: Int32,\n    $numberDecimal: Decimal128,\n    $numberDouble: Double,\n    $numberLong: Long,\n    $minKey: MinKey,\n    $maxKey: MaxKey,\n    $regex: BSONRegExp,\n    $regularExpression: BSONRegExp,\n    $timestamp: Timestamp\n};\nfunction deserializeValue(value, options = {}) {\n    if (typeof value === 'number') {\n        const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;\n        const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;\n        if (options.relaxed || options.legacy) {\n            return value;\n        }\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (in32BitRange) {\n                return new Int32(value);\n            }\n            if (in64BitRange) {\n                if (options.useBigInt64) {\n                    return BigInt(value);\n                }\n                return Long.fromNumber(value);\n            }\n        }\n        return new Double(value);\n    }\n    if (value == null || typeof value !== 'object')\n        return value;\n    if (value.$undefined)\n        return null;\n    const keys = Object.keys(value).filter(k => k.startsWith('$') && value[k] != null);\n    for (let i = 0; i < keys.length; i++) {\n        const c = keysToCodecs[keys[i]];\n        if (c)\n            return c.fromExtendedJSON(value, options);\n    }\n    if (value.$date != null) {\n        const d = value.$date;\n        const date = new Date();\n        if (options.legacy) {\n            if (typeof d === 'number')\n                date.setTime(d);\n            else if (typeof d === 'string')\n                date.setTime(Date.parse(d));\n            else if (typeof d === 'bigint')\n                date.setTime(Number(d));\n            else\n                throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        }\n        else {\n            if (typeof d === 'string')\n                date.setTime(Date.parse(d));\n            else if (Long.isLong(d))\n                date.setTime(d.toNumber());\n            else if (typeof d === 'number' && options.relaxed)\n                date.setTime(d);\n            else if (typeof d === 'bigint')\n                date.setTime(Number(d));\n            else\n                throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        }\n        return date;\n    }\n    if (value.$code != null) {\n        const copy = Object.assign({}, value);\n        if (value.$scope) {\n            copy.$scope = deserializeValue(value.$scope);\n        }\n        return Code.fromExtendedJSON(value);\n    }\n    if (isDBRefLike(value) || value.$dbPointer) {\n        const v = value.$ref ? value : value.$dbPointer;\n        if (v instanceof DBRef)\n            return v;\n        const dollarKeys = Object.keys(v).filter(k => k.startsWith('$'));\n        let valid = true;\n        dollarKeys.forEach(k => {\n            if (['$ref', '$id', '$db'].indexOf(k) === -1)\n                valid = false;\n        });\n        if (valid)\n            return DBRef.fromExtendedJSON(v);\n    }\n    return value;\n}\nfunction serializeArray(array, options) {\n    return array.map((v, index) => {\n        options.seenObjects.push({ propertyName: `index ${index}`, obj: null });\n        try {\n            return serializeValue(v, options);\n        }\n        finally {\n            options.seenObjects.pop();\n        }\n    });\n}\nfunction getISOString(date) {\n    const isoStr = date.toISOString();\n    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';\n}\nfunction serializeValue(value, options) {\n    if (value instanceof Map || isMap(value)) {\n        const obj = Object.create(null);\n        for (const [k, v] of value) {\n            if (typeof k !== 'string') {\n                throw new BSONError('Can only serialize maps with string keys');\n            }\n            obj[k] = v;\n        }\n        return serializeValue(obj, options);\n    }\n    if ((typeof value === 'object' || typeof value === 'function') && value !== null) {\n        const index = options.seenObjects.findIndex(entry => entry.obj === value);\n        if (index !== -1) {\n            const props = options.seenObjects.map(entry => entry.propertyName);\n            const leadingPart = props\n                .slice(0, index)\n                .map(prop => `${prop} -> `)\n                .join('');\n            const alreadySeen = props[index];\n            const circularPart = ' -> ' +\n                props\n                    .slice(index + 1, props.length - 1)\n                    .map(prop => `${prop} -> `)\n                    .join('');\n            const current = props[props.length - 1];\n            const leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2);\n            const dashes = '-'.repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);\n            throw new BSONError('Converting circular structure to EJSON:\\n' +\n                `    ${leadingPart}${alreadySeen}${circularPart}${current}\\n` +\n                `    ${leadingSpace}\\\\${dashes}/`);\n        }\n        options.seenObjects[options.seenObjects.length - 1].obj = value;\n    }\n    if (Array.isArray(value))\n        return serializeArray(value, options);\n    if (value === undefined)\n        return null;\n    if (value instanceof Date || isDate(value)) {\n        const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;\n        if (options.legacy) {\n            return options.relaxed && inRange\n                ? { $date: value.getTime() }\n                : { $date: getISOString(value) };\n        }\n        return options.relaxed && inRange\n            ? { $date: getISOString(value) }\n            : { $date: { $numberLong: value.getTime().toString() } };\n    }\n    if (typeof value === 'number' && (!options.relaxed || !isFinite(value))) {\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                return { $numberInt: value.toString() };\n            }\n            if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {\n                return { $numberLong: value.toString() };\n            }\n        }\n        return { $numberDouble: Object.is(value, -0) ? '-0.0' : value.toString() };\n    }\n    if (typeof value === 'bigint') {\n        if (!options.relaxed) {\n            return { $numberLong: BigInt.asIntN(64, value).toString() };\n        }\n        return Number(BigInt.asIntN(64, value));\n    }\n    if (value instanceof RegExp || isRegExp(value)) {\n        let flags = value.flags;\n        if (flags === undefined) {\n            const match = value.toString().match(/[gimuy]*$/);\n            if (match) {\n                flags = match[0];\n            }\n        }\n        const rx = new BSONRegExp(value.source, flags);\n        return rx.toExtendedJSON(options);\n    }\n    if (value != null && typeof value === 'object')\n        return serializeDocument(value, options);\n    return value;\n}\nconst BSON_TYPE_MAPPINGS = {\n    Binary: (o) => new Binary(o.value(), o.sub_type),\n    Code: (o) => new Code(o.code, o.scope),\n    DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),\n    Decimal128: (o) => new Decimal128(o.bytes),\n    Double: (o) => new Double(o.value),\n    Int32: (o) => new Int32(o.value),\n    Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),\n    MaxKey: () => new MaxKey(),\n    MinKey: () => new MinKey(),\n    ObjectId: (o) => new ObjectId(o),\n    BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),\n    BSONSymbol: (o) => new BSONSymbol(o.value),\n    Timestamp: (o) => Timestamp.fromBits(o.low, o.high)\n};\nfunction serializeDocument(doc, options) {\n    if (doc == null || typeof doc !== 'object')\n        throw new BSONError('not an object instance');\n    const bsontype = doc._bsontype;\n    if (typeof bsontype === 'undefined') {\n        const _doc = {};\n        for (const name of Object.keys(doc)) {\n            options.seenObjects.push({ propertyName: name, obj: null });\n            try {\n                const value = serializeValue(doc[name], options);\n                if (name === '__proto__') {\n                    Object.defineProperty(_doc, name, {\n                        value,\n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                }\n                else {\n                    _doc[name] = value;\n                }\n            }\n            finally {\n                options.seenObjects.pop();\n            }\n        }\n        return _doc;\n    }\n    else if (doc != null &&\n        typeof doc === 'object' &&\n        typeof doc._bsontype === 'string' &&\n        doc[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n        throw new BSONVersionError();\n    }\n    else if (isBSONType(doc)) {\n        let outDoc = doc;\n        if (typeof outDoc.toExtendedJSON !== 'function') {\n            const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\n            if (!mapper) {\n                throw new BSONError('Unrecognized or invalid _bsontype: ' + doc._bsontype);\n            }\n            outDoc = mapper(outDoc);\n        }\n        if (bsontype === 'Code' && outDoc.scope) {\n            outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));\n        }\n        else if (bsontype === 'DBRef' && outDoc.oid) {\n            outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));\n        }\n        return outDoc.toExtendedJSON(options);\n    }\n    else {\n        throw new BSONError('_bsontype must be a string, but was: ' + typeof bsontype);\n    }\n}\nfunction parse(text, options) {\n    const ejsonOptions = {\n        useBigInt64: options?.useBigInt64 ?? false,\n        relaxed: options?.relaxed ?? true,\n        legacy: options?.legacy ?? false\n    };\n    return JSON.parse(text, (key, value) => {\n        if (key.indexOf('\\x00') !== -1) {\n            throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);\n        }\n        return deserializeValue(value, ejsonOptions);\n    });\n}\nfunction stringify(value, replacer, space, options) {\n    if (space != null && typeof space === 'object') {\n        options = space;\n        space = 0;\n    }\n    if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) {\n        options = replacer;\n        replacer = undefined;\n        space = 0;\n    }\n    const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {\n        seenObjects: [{ propertyName: '(root)', obj: null }]\n    });\n    const doc = serializeValue(value, serializeOptions);\n    return JSON.stringify(doc, replacer, space);\n}\nfunction EJSONserialize(value, options) {\n    options = options || {};\n    return JSON.parse(stringify(value, options));\n}\nfunction EJSONdeserialize(ejson, options) {\n    options = options || {};\n    return parse(JSON.stringify(ejson), options);\n}\nconst EJSON = Object.create(null);\nEJSON.parse = parse;\nEJSON.stringify = stringify;\nEJSON.serialize = EJSONserialize;\nEJSON.deserialize = EJSONdeserialize;\nObject.freeze(EJSON);\n\nconst MAXSIZE = 1024 * 1024 * 17;\nlet buffer = ByteUtils.allocate(MAXSIZE);\nfunction setInternalBufferSize(size) {\n    if (buffer.length < size) {\n        buffer = ByteUtils.allocate(size);\n    }\n}\nfunction serialize(object, options = {}) {\n    const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n    const minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE;\n    if (buffer.length < minInternalBufferSize) {\n        buffer = ByteUtils.allocate(minInternalBufferSize);\n    }\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    const finishedBuffer = ByteUtils.allocate(serializationIndex);\n    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);\n    return finishedBuffer;\n}\nfunction serializeWithBufferAndIndex(object, finalBuffer, options = {}) {\n    const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n    const startIndex = typeof options.index === 'number' ? options.index : 0;\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);\n    return startIndex + serializationIndex - 1;\n}\nfunction deserialize(buffer, options = {}) {\n    return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);\n}\nfunction calculateObjectSize(object, options = {}) {\n    options = options || {};\n    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);\n}\nfunction deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {\n    const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);\n    const bufferData = ByteUtils.toLocalBufferType(data);\n    let index = startIndex;\n    for (let i = 0; i < numberOfDocuments; i++) {\n        const size = bufferData[index] |\n            (bufferData[index + 1] << 8) |\n            (bufferData[index + 2] << 16) |\n            (bufferData[index + 3] << 24);\n        internalOptions.index = index;\n        documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);\n        index = index + size;\n    }\n    return index;\n}\n\nvar bson = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BSONError: BSONError,\n    BSONRegExp: BSONRegExp,\n    BSONRuntimeError: BSONRuntimeError,\n    BSONSymbol: BSONSymbol,\n    BSONType: BSONType,\n    BSONValue: BSONValue,\n    BSONVersionError: BSONVersionError,\n    Binary: Binary,\n    Code: Code,\n    DBRef: DBRef,\n    Decimal128: Decimal128,\n    Double: Double,\n    EJSON: EJSON,\n    Int32: Int32,\n    Long: Long,\n    MaxKey: MaxKey,\n    MinKey: MinKey,\n    ObjectId: ObjectId,\n    Timestamp: Timestamp,\n    UUID: UUID,\n    calculateObjectSize: calculateObjectSize,\n    deserialize: deserialize,\n    deserializeStream: deserializeStream,\n    serialize: serialize,\n    serializeWithBufferAndIndex: serializeWithBufferAndIndex,\n    setInternalBufferSize: setInternalBufferSize\n});\n\nexports.BSON = bson;\nexports.BSONError = BSONError;\nexports.BSONRegExp = BSONRegExp;\nexports.BSONRuntimeError = BSONRuntimeError;\nexports.BSONSymbol = BSONSymbol;\nexports.BSONType = BSONType;\nexports.BSONValue = BSONValue;\nexports.BSONVersionError = BSONVersionError;\nexports.Binary = Binary;\nexports.Code = Code;\nexports.DBRef = DBRef;\nexports.Decimal128 = Decimal128;\nexports.Double = Double;\nexports.EJSON = EJSON;\nexports.Int32 = Int32;\nexports.Long = Long;\nexports.MaxKey = MaxKey;\nexports.MinKey = MinKey;\nexports.ObjectId = ObjectId;\nexports.Timestamp = Timestamp;\nexports.UUID = UUID;\nexports.calculateObjectSize = calculateObjectSize;\nexports.deserialize = deserialize;\nexports.deserializeStream = deserializeStream;\nexports.serialize = serialize;\nexports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;\nexports.setInternalBufferSize = setInternalBufferSize;\n//# sourceMappingURL=bson.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9ic29uL2xpYi9ic29uLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLG1CQUFtQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxvQkFBb0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdCQUF3QjtBQUNqRixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFdBQVc7QUFDMUY7QUFDQSxxREFBcUQsb0JBQW9CO0FBQ3pFO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDRCQUE0QjtBQUN6RixLQUFLO0FBQ0w7QUFDQTtBQUNBLHdGQUF3RixhQUFhO0FBQ3JHO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLEVBQUUsWUFBWTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjLG1EQUFtRCxvQkFBb0I7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsb0JBQW9CO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTyxLQUFLLGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxHQUFHO0FBQzFDLG9DQUFvQyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsR0FBRztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCLEdBQUcsOEJBQThCLCtCQUErQixPQUFPO0FBQ3pIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlLG1CQUFtQixZQUFZLElBQUksZ0JBQWdCLFFBQVEsUUFBUTtBQUMvRztBQUNBOztBQUVBO0FBQ0E7QUFDQSw4c0NBQThzQztBQUM5c0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFzQyxJQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCLEdBQUcsOEJBQThCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyx1Q0FBdUMsUUFBUTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsc0JBQXNCO0FBQzlFO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGlCQUFpQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RCxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hELHVDQUF1QyxxQkFBcUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBEQUEwRDtBQUMxRixtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELEdBQUc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsNkJBQTZCO0FBQ3RIO0FBQ0E7QUFDQSx3RkFBd0YsNkJBQTZCO0FBQ3JIO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZ0JBQWdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLG9CQUFvQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDZCQUE2QixJQUFJLDZCQUE2QjtBQUMvRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLE9BQU87QUFDekU7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLE9BQU87QUFDekU7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQSxrRUFBa0UsT0FBTztBQUN6RTtBQUNBO0FBQ0Esa0VBQWtFLE9BQU87QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsV0FBVyxXQUFXO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseUJBQXlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLLG1CQUFtQixPQUFPLG9CQUFvQjtBQUNuRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBLDZDQUE2QyxlQUFlLHVCQUF1QixLQUFLO0FBQ3hGO0FBQ0E7QUFDQSw2Q0FBNkMsZUFBZSxxQkFBcUIsS0FBSztBQUN0RjtBQUNBO0FBQ0EsMENBQTBDLE1BQU0sa0JBQWtCLE9BQU8sMkJBQTJCLGtCQUFrQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQkFBMEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsaUNBQWlDLCtCQUErQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwwQkFBMEIsaUJBQWlCLEtBQUs7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQywyQkFBMkIsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsd0JBQXdCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsd0JBQXdCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsd0JBQXdCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsU0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLFNBQVM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1QkFBdUIsTUFBTSxjQUFjO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLFFBQVE7QUFDMUUsdUJBQXVCLGFBQWEsSUFBSSxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrQkFBK0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixvQkFBb0I7QUFDbkg7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDhCQUE4QjtBQUMzRSx3QkFBd0IsbUNBQW1DO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtEQUFrRDtBQUM5RjtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsd0JBQXdCO0FBQ3hCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLHdCQUF3QjtBQUN4QixjQUFjO0FBQ2QsWUFBWTtBQUNaLGFBQWE7QUFDYixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLGFBQWE7QUFDYixhQUFhO0FBQ2IsWUFBWTtBQUNaLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixZQUFZO0FBQ1osMkJBQTJCO0FBQzNCLG1CQUFtQjtBQUNuQix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLG1DQUFtQztBQUNuQyw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxic29uXFxsaWJcXGJzb24uY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiBbJ1tvYmplY3QgQXJyYXlCdWZmZXJdJywgJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJ10uaW5jbHVkZXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgVWludDhBcnJheV0nO1xufVxuZnVuY3Rpb24gaXNSZWdFeHAoZCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZnVuY3Rpb24gaXNNYXAoZCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZCkgPT09ICdbb2JqZWN0IE1hcF0nO1xufVxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmNvbnN0IEJTT05fTUFKT1JfVkVSU0lPTiA9IDU7XG5jb25zdCBCU09OX0lOVDMyX01BWCA9IDB4N2ZmZmZmZmY7XG5jb25zdCBCU09OX0lOVDMyX01JTiA9IC0weDgwMDAwMDAwO1xuY29uc3QgQlNPTl9JTlQ2NF9NQVggPSBNYXRoLnBvdygyLCA2MykgLSAxO1xuY29uc3QgQlNPTl9JTlQ2NF9NSU4gPSAtTWF0aC5wb3coMiwgNjMpO1xuY29uc3QgSlNfSU5UX01BWCA9IE1hdGgucG93KDIsIDUzKTtcbmNvbnN0IEpTX0lOVF9NSU4gPSAtTWF0aC5wb3coMiwgNTMpO1xuY29uc3QgQlNPTl9EQVRBX05VTUJFUiA9IDE7XG5jb25zdCBCU09OX0RBVEFfU1RSSU5HID0gMjtcbmNvbnN0IEJTT05fREFUQV9PQkpFQ1QgPSAzO1xuY29uc3QgQlNPTl9EQVRBX0FSUkFZID0gNDtcbmNvbnN0IEJTT05fREFUQV9CSU5BUlkgPSA1O1xuY29uc3QgQlNPTl9EQVRBX1VOREVGSU5FRCA9IDY7XG5jb25zdCBCU09OX0RBVEFfT0lEID0gNztcbmNvbnN0IEJTT05fREFUQV9CT09MRUFOID0gODtcbmNvbnN0IEJTT05fREFUQV9EQVRFID0gOTtcbmNvbnN0IEJTT05fREFUQV9OVUxMID0gMTA7XG5jb25zdCBCU09OX0RBVEFfUkVHRVhQID0gMTE7XG5jb25zdCBCU09OX0RBVEFfREJQT0lOVEVSID0gMTI7XG5jb25zdCBCU09OX0RBVEFfQ09ERSA9IDEzO1xuY29uc3QgQlNPTl9EQVRBX1NZTUJPTCA9IDE0O1xuY29uc3QgQlNPTl9EQVRBX0NPREVfV19TQ09QRSA9IDE1O1xuY29uc3QgQlNPTl9EQVRBX0lOVCA9IDE2O1xuY29uc3QgQlNPTl9EQVRBX1RJTUVTVEFNUCA9IDE3O1xuY29uc3QgQlNPTl9EQVRBX0xPTkcgPSAxODtcbmNvbnN0IEJTT05fREFUQV9ERUNJTUFMMTI4ID0gMTk7XG5jb25zdCBCU09OX0RBVEFfTUlOX0tFWSA9IDB4ZmY7XG5jb25zdCBCU09OX0RBVEFfTUFYX0tFWSA9IDB4N2Y7XG5jb25zdCBCU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFQgPSAwO1xuY29uc3QgQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEX05FVyA9IDQ7XG5jb25zdCBCU09OVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIGRvdWJsZTogMSxcbiAgICBzdHJpbmc6IDIsXG4gICAgb2JqZWN0OiAzLFxuICAgIGFycmF5OiA0LFxuICAgIGJpbkRhdGE6IDUsXG4gICAgdW5kZWZpbmVkOiA2LFxuICAgIG9iamVjdElkOiA3LFxuICAgIGJvb2w6IDgsXG4gICAgZGF0ZTogOSxcbiAgICBudWxsOiAxMCxcbiAgICByZWdleDogMTEsXG4gICAgZGJQb2ludGVyOiAxMixcbiAgICBqYXZhc2NyaXB0OiAxMyxcbiAgICBzeW1ib2w6IDE0LFxuICAgIGphdmFzY3JpcHRXaXRoU2NvcGU6IDE1LFxuICAgIGludDogMTYsXG4gICAgdGltZXN0YW1wOiAxNyxcbiAgICBsb25nOiAxOCxcbiAgICBkZWNpbWFsOiAxOSxcbiAgICBtaW5LZXk6IC0xLFxuICAgIG1heEtleTogMTI3XG59KTtcblxuY2xhc3MgQlNPTkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGdldCBic29uRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdCU09ORXJyb3InO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNCU09ORXJyb3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAnYnNvbkVycm9yJyBpbiB2YWx1ZSAmJlxuICAgICAgICAgICAgdmFsdWUuYnNvbkVycm9yID09PSB0cnVlICYmXG4gICAgICAgICAgICAnbmFtZScgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgICdtZXNzYWdlJyBpbiB2YWx1ZSAmJlxuICAgICAgICAgICAgJ3N0YWNrJyBpbiB2YWx1ZSk7XG4gICAgfVxufVxuY2xhc3MgQlNPTlZlcnNpb25FcnJvciBleHRlbmRzIEJTT05FcnJvciB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQlNPTlZlcnNpb25FcnJvcic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihgVW5zdXBwb3J0ZWQgQlNPTiB2ZXJzaW9uLCBic29uIHR5cGVzIG11c3QgYmUgZnJvbSBic29uICR7QlNPTl9NQUpPUl9WRVJTSU9OfS54LnhgKTtcbiAgICB9XG59XG5jbGFzcyBCU09OUnVudGltZUVycm9yIGV4dGVuZHMgQlNPTkVycm9yIHtcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdCU09OUnVudGltZUVycm9yJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vZGVqc01hdGhSYW5kb21CeXRlcyhieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoQXJyYXkuZnJvbSh7IGxlbmd0aDogYnl0ZUxlbmd0aCB9LCAoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpKSk7XG59XG5jb25zdCBub2RlanNSYW5kb21CeXRlcyA9ICgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJ2NyeXB0bycpLnJhbmRvbUJ5dGVzO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBub2RlanNNYXRoUmFuZG9tQnl0ZXM7XG4gICAgfVxufSkoKTtcbmNvbnN0IG5vZGVKc0J5dGVVdGlscyA9IHtcbiAgICB0b0xvY2FsQnVmZmVyVHlwZShwb3RlbnRpYWxCdWZmZXIpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwb3RlbnRpYWxCdWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcG90ZW50aWFsQnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocG90ZW50aWFsQnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBvdGVudGlhbEJ1ZmZlci5idWZmZXIsIHBvdGVudGlhbEJ1ZmZlci5ieXRlT2Zmc2V0LCBwb3RlbnRpYWxCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyaW5nVGFnID0gcG90ZW50aWFsQnVmZmVyPy5bU3ltYm9sLnRvU3RyaW5nVGFnXSA/PyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocG90ZW50aWFsQnVmZmVyKTtcbiAgICAgICAgaWYgKHN0cmluZ1RhZyA9PT0gJ0FycmF5QnVmZmVyJyB8fFxuICAgICAgICAgICAgc3RyaW5nVGFnID09PSAnU2hhcmVkQXJyYXlCdWZmZXInIHx8XG4gICAgICAgICAgICBzdHJpbmdUYWcgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScgfHxcbiAgICAgICAgICAgIHN0cmluZ1RhZyA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJykge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBvdGVudGlhbEJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQ2Fubm90IGNyZWF0ZSBCdWZmZXIgZnJvbSAke1N0cmluZyhwb3RlbnRpYWxCdWZmZXIpfWApO1xuICAgIH0sXG4gICAgYWxsb2NhdGUoc2l6ZSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUpO1xuICAgIH0sXG4gICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShhKS5lcXVhbHMoYik7XG4gICAgfSxcbiAgICBmcm9tTnVtYmVyQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycmF5KTtcbiAgICB9LFxuICAgIGZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShiYXNlNjQsICdiYXNlNjQnKTtcbiAgICB9LFxuICAgIHRvQmFzZTY0KGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlcikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH0sXG4gICAgZnJvbUlTTzg4NTkxKGNvZGVQb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNvZGVQb2ludHMsICdiaW5hcnknKTtcbiAgICB9LFxuICAgIHRvSVNPODg1OTEoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBub2RlSnNCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgfSxcbiAgICBmcm9tSGV4KGhleCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4LCAnaGV4Jyk7XG4gICAgfSxcbiAgICB0b0hleChidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9LFxuICAgIGZyb21VVEY4KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRleHQsICd1dGY4Jyk7XG4gICAgfSxcbiAgICB0b1VURjgoYnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBub2RlSnNCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKS50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBlbmQpO1xuICAgIH0sXG4gICAgdXRmOEJ5dGVMZW5ndGgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKGlucHV0LCAndXRmOCcpO1xuICAgIH0sXG4gICAgZW5jb2RlVVRGOEludG8oYnVmZmVyLCBzb3VyY2UsIGJ5dGVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLndyaXRlKHNvdXJjZSwgYnl0ZU9mZnNldCwgdW5kZWZpbmVkLCAndXRmOCcpO1xuICAgIH0sXG4gICAgcmFuZG9tQnl0ZXM6IG5vZGVqc1JhbmRvbUJ5dGVzXG59O1xuXG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xuICAgIGNvbnN0IHsgbmF2aWdhdG9yIH0gPSBnbG9iYWxUaGlzO1xuICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJztcbn1cbmZ1bmN0aW9uIHdlYk1hdGhSYW5kb21CeXRlcyhieXRlTGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGUgYXJndW1lbnQgJ2J5dGVMZW5ndGgnIGlzIGludmFsaWQuIFJlY2VpdmVkICR7Ynl0ZUxlbmd0aH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHdlYkJ5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoQXJyYXkuZnJvbSh7IGxlbmd0aDogYnl0ZUxlbmd0aCB9LCAoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpKSk7XG59XG5jb25zdCB3ZWJSYW5kb21CeXRlcyA9ICgoKSA9PiB7XG4gICAgY29uc3QgeyBjcnlwdG8gfSA9IGdsb2JhbFRoaXM7XG4gICAgaWYgKGNyeXB0byAhPSBudWxsICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiAoYnl0ZUxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMod2ViQnl0ZVV0aWxzLmFsbG9jYXRlKGJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29uc29sZSB9ID0gZ2xvYmFsVGhpcztcbiAgICAgICAgICAgIGNvbnNvbGU/Lndhcm4/LignQlNPTjogRm9yIFJlYWN0IE5hdGl2ZSBwbGVhc2UgcG9seWZpbGwgY3J5cHRvLmdldFJhbmRvbVZhbHVlcywgZS5nLiB1c2luZzogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtbmF0aXZlLWdldC1yYW5kb20tdmFsdWVzLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWJNYXRoUmFuZG9tQnl0ZXM7XG4gICAgfVxufSkoKTtcbmNvbnN0IEhFWF9ESUdJVCA9IC8oXFxkfFthLWZdKS9pO1xuY29uc3Qgd2ViQnl0ZVV0aWxzID0ge1xuICAgIHRvTG9jYWxCdWZmZXJUeXBlKHBvdGVudGlhbFVpbnQ4YXJyYXkpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5nVGFnID0gcG90ZW50aWFsVWludDhhcnJheT8uW1N5bWJvbC50b1N0cmluZ1RhZ10gPz9cbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwb3RlbnRpYWxVaW50OGFycmF5KTtcbiAgICAgICAgaWYgKHN0cmluZ1RhZyA9PT0gJ1VpbnQ4QXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gcG90ZW50aWFsVWludDhhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBvdGVudGlhbFVpbnQ4YXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocG90ZW50aWFsVWludDhhcnJheS5idWZmZXIuc2xpY2UocG90ZW50aWFsVWludDhhcnJheS5ieXRlT2Zmc2V0LCBwb3RlbnRpYWxVaW50OGFycmF5LmJ5dGVPZmZzZXQgKyBwb3RlbnRpYWxVaW50OGFycmF5LmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nVGFnID09PSAnQXJyYXlCdWZmZXInIHx8XG4gICAgICAgICAgICBzdHJpbmdUYWcgPT09ICdTaGFyZWRBcnJheUJ1ZmZlcicgfHxcbiAgICAgICAgICAgIHN0cmluZ1RhZyA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyB8fFxuICAgICAgICAgICAgc3RyaW5nVGFnID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocG90ZW50aWFsVWludDhhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQ2Fubm90IG1ha2UgYSBVaW50OEFycmF5IGZyb20gJHtTdHJpbmcocG90ZW50aWFsVWludDhhcnJheSl9YCk7XG4gICAgfSxcbiAgICBhbGxvY2F0ZShzaXplKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCAke1N0cmluZyhzaXplKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgfSxcbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGZyb21OdW1iZXJBcnJheShhcnJheSkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGFycmF5KTtcbiAgICB9LFxuICAgIGZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYXRvYihiYXNlNjQpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XG4gICAgfSxcbiAgICB0b0Jhc2U2NCh1aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBidG9hKHdlYkJ5dGVVdGlscy50b0lTTzg4NTkxKHVpbnQ4YXJyYXkpKTtcbiAgICB9LFxuICAgIGZyb21JU084ODU5MShjb2RlUG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29kZVBvaW50cywgYyA9PiBjLmNoYXJDb2RlQXQoMCkgJiAweGZmKTtcbiAgICB9LFxuICAgIHRvSVNPODg1OTEodWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShVaW50MTZBcnJheS5mcm9tKHVpbnQ4YXJyYXkpLCBiID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYikpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgZnJvbUhleChoZXgpIHtcbiAgICAgICAgY29uc3QgZXZlbkxlbmd0aEhleCA9IGhleC5sZW5ndGggJSAyID09PSAwID8gaGV4IDogaGV4LnNsaWNlKDAsIGhleC5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbkxlbmd0aEhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgZmlyc3REaWdpdCA9IGV2ZW5MZW5ndGhIZXhbaV07XG4gICAgICAgICAgICBjb25zdCBzZWNvbmREaWdpdCA9IGV2ZW5MZW5ndGhIZXhbaSArIDFdO1xuICAgICAgICAgICAgaWYgKCFIRVhfRElHSVQudGVzdChmaXJzdERpZ2l0KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFIRVhfRElHSVQudGVzdChzZWNvbmREaWdpdCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhleERpZ2l0ID0gTnVtYmVyLnBhcnNlSW50KGAke2ZpcnN0RGlnaXR9JHtzZWNvbmREaWdpdH1gLCAxNik7XG4gICAgICAgICAgICBidWZmZXIucHVzaChoZXhEaWdpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpO1xuICAgIH0sXG4gICAgdG9IZXgodWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh1aW50OGFycmF5LCBieXRlID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgZnJvbVVURjgodGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRleHQpO1xuICAgIH0sXG4gICAgdG9VVEY4KHVpbnQ4YXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigndXRmOCcsIHsgZmF0YWw6IGZhbHNlIH0pLmRlY29kZSh1aW50OGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICB9LFxuICAgIHV0ZjhCeXRlTGVuZ3RoKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB3ZWJCeXRlVXRpbHMuZnJvbVVURjgoaW5wdXQpLmJ5dGVMZW5ndGg7XG4gICAgfSxcbiAgICBlbmNvZGVVVEY4SW50byhidWZmZXIsIHNvdXJjZSwgYnl0ZU9mZnNldCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IHdlYkJ5dGVVdGlscy5mcm9tVVRGOChzb3VyY2UpO1xuICAgICAgICBidWZmZXIuc2V0KGJ5dGVzLCBieXRlT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgfSxcbiAgICByYW5kb21CeXRlczogd2ViUmFuZG9tQnl0ZXNcbn07XG5cbmNvbnN0IGhhc0dsb2JhbEJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLnByb3RvdHlwZT8uX2lzQnVmZmVyICE9PSB0cnVlO1xuY29uc3QgQnl0ZVV0aWxzID0gaGFzR2xvYmFsQnVmZmVyID8gbm9kZUpzQnl0ZVV0aWxzIDogd2ViQnl0ZVV0aWxzO1xuY2xhc3MgQlNPTkRhdGFWaWV3IGV4dGVuZHMgRGF0YVZpZXcge1xuICAgIHN0YXRpYyBmcm9tVWludDhBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGlucHV0LmJ1ZmZlciwgaW5wdXQuYnl0ZU9mZnNldCwgaW5wdXQuYnl0ZUxlbmd0aCk7XG4gICAgfVxufVxuXG5jbGFzcyBCU09OVmFsdWUge1xuICAgIGdldCBbU3ltYm9sLmZvcignQEBtZGIuYnNvbi52ZXJzaW9uJyldKCkge1xuICAgICAgICByZXR1cm4gQlNPTl9NQUpPUl9WRVJTSU9OO1xuICAgIH1cbn1cblxuY2xhc3MgQmluYXJ5IGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0JpbmFyeSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgc3ViVHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIShidWZmZXIgPT0gbnVsbCkgJiZcbiAgICAgICAgICAgICEodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgICAgICAhQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcikgJiZcbiAgICAgICAgICAgICEoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheShidWZmZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgY2FuIG9ubHkgYmUgY29uc3RydWN0ZWQgZnJvbSBzdHJpbmcsIEJ1ZmZlciwgVHlwZWRBcnJheSwgb3IgQXJyYXk8bnVtYmVyPicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViX3R5cGUgPSBzdWJUeXBlID8/IEJpbmFyeS5CU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFQ7XG4gICAgICAgIGlmIChidWZmZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGUoQmluYXJ5LkJVRkZFUl9TSVpFKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBCeXRlVXRpbHMuZnJvbUlTTzg4NTkxKGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXQoYnl0ZVZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYnl0ZVZhbHVlID09PSAnc3RyaW5nJyAmJiBieXRlVmFsdWUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdvbmx5IGFjY2VwdHMgc2luZ2xlIGNoYXJhY3RlciBTdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYnl0ZVZhbHVlICE9PSAnbnVtYmVyJyAmJiBieXRlVmFsdWUubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignb25seSBhY2NlcHRzIHNpbmdsZSBjaGFyYWN0ZXIgVWludDhBcnJheSBvciBBcnJheScpO1xuICAgICAgICBsZXQgZGVjb2RlZEJ5dGU7XG4gICAgICAgIGlmICh0eXBlb2YgYnl0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGVjb2RlZEJ5dGUgPSBieXRlVmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYnl0ZVZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZGVjb2RlZEJ5dGUgPSBieXRlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWNvZGVkQnl0ZSA9IGJ5dGVWYWx1ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjb2RlZEJ5dGUgPCAwIHx8IGRlY29kZWRCeXRlID4gMjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdvbmx5IGFjY2VwdHMgbnVtYmVyIGluIGEgdmFsaWQgdW5zaWduZWQgYnl0ZSByYW5nZSAwLTI1NScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoID4gdGhpcy5wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IGRlY29kZWRCeXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3U3BhY2UgPSBCeXRlVXRpbHMuYWxsb2NhdGUoQmluYXJ5LkJVRkZFUl9TSVpFICsgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld1NwYWNlLnNldCh0aGlzLmJ1ZmZlciwgMCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld1NwYWNlO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IGRlY29kZWRCeXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlKHNlcXVlbmNlLCBvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCA8IG9mZnNldCArIHNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U3BhY2UgPSBCeXRlVXRpbHMuYWxsb2NhdGUodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCArIHNlcXVlbmNlLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdTcGFjZS5zZXQodGhpcy5idWZmZXIsIDApO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdTcGFjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNlcXVlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuc2V0KEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShzZXF1ZW5jZSksIG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKyBzZXF1ZW5jZS5ieXRlTGVuZ3RoID4gdGhpcy5wb3NpdGlvbiA/IG9mZnNldCArIHNlcXVlbmNlLmxlbmd0aCA6IHRoaXMucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNlcXVlbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBCeXRlVXRpbHMuZnJvbUlTTzg4NTkxKHNlcXVlbmNlKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnNldChieXRlcywgb2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPVxuICAgICAgICAgICAgICAgIG9mZnNldCArIHNlcXVlbmNlLmxlbmd0aCA+IHRoaXMucG9zaXRpb24gPyBvZmZzZXQgKyBzZXF1ZW5jZS5sZW5ndGggOiB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWQocG9zaXRpb24sIGxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSBsZW5ndGggJiYgbGVuZ3RoID4gMCA/IGxlbmd0aCA6IHRoaXMucG9zaXRpb247XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgIH1cbiAgICB2YWx1ZShhc1Jhdykge1xuICAgICAgICBhc1JhdyA9ICEhYXNSYXc7XG4gICAgICAgIGlmIChhc1JhdyAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXNSYXcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZSgwLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvSVNPODg1OTEodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3NpdGlvbikpO1xuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB0b1N0cmluZyhlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlcik7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvQmFzZTY0KHRoaXMuYnVmZmVyKTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpXG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvVVRGOCh0aGlzLmJ1ZmZlciwgMCwgdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9VVEY4KHRoaXMuYnVmZmVyLCAwLCB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgYmFzZTY0U3RyaW5nID0gQnl0ZVV0aWxzLnRvQmFzZTY0KHRoaXMuYnVmZmVyKTtcbiAgICAgICAgY29uc3Qgc3ViVHlwZSA9IE51bWJlcih0aGlzLnN1Yl90eXBlKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAkYmluYXJ5OiBiYXNlNjRTdHJpbmcsXG4gICAgICAgICAgICAgICAgJHR5cGU6IHN1YlR5cGUubGVuZ3RoID09PSAxID8gJzAnICsgc3ViVHlwZSA6IHN1YlR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRiaW5hcnk6IHtcbiAgICAgICAgICAgICAgICBiYXNlNjQ6IGJhc2U2NFN0cmluZyxcbiAgICAgICAgICAgICAgICBzdWJUeXBlOiBzdWJUeXBlLmxlbmd0aCA9PT0gMSA/ICcwJyArIHN1YlR5cGUgOiBzdWJUeXBlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvVVVJRCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ViX3R5cGUgPT09IEJpbmFyeS5TVUJUWVBFX1VVSUQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVVJRCh0aGlzLmJ1ZmZlci5zbGljZSgwLCB0aGlzLnBvc2l0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQmluYXJ5IHN1Yl90eXBlIFwiJHt0aGlzLnN1Yl90eXBlfVwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGNvbnZlcnRpbmcgdG8gVVVJRC4gT25seSBcIiR7QmluYXJ5LlNVQlRZUEVfVVVJRH1cIiBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLmApO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUhleFN0cmluZyhoZXgsIHN1YlR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnkoQnl0ZVV0aWxzLmZyb21IZXgoaGV4KSwgc3ViVHlwZSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tQmFzZTY0KGJhc2U2NCwgc3ViVHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShCeXRlVXRpbHMuZnJvbUJhc2U2NChiYXNlNjQpLCBzdWJUeXBlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgIGlmICgnJGJpbmFyeScgaW4gZG9jKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZWdhY3kgJiYgdHlwZW9mIGRvYy4kYmluYXJ5ID09PSAnc3RyaW5nJyAmJiAnJHR5cGUnIGluIGRvYykge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBkb2MuJHR5cGUgPyBwYXJzZUludChkb2MuJHR5cGUsIDE2KSA6IDA7XG4gICAgICAgICAgICAgICAgZGF0YSA9IEJ5dGVVdGlscy5mcm9tQmFzZTY0KGRvYy4kYmluYXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jLiRiaW5hcnkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBkb2MuJGJpbmFyeS5zdWJUeXBlID8gcGFyc2VJbnQoZG9jLiRiaW5hcnkuc3ViVHlwZSwgMTYpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEJ5dGVVdGlscy5mcm9tQmFzZTY0KGRvYy4kYmluYXJ5LmJhc2U2NCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCckdXVpZCcgaW4gZG9jKSB7XG4gICAgICAgICAgICB0eXBlID0gNDtcbiAgICAgICAgICAgIGRhdGEgPSBVVUlELmJ5dGVzRnJvbVN0cmluZyhkb2MuJHV1aWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgVW5leHBlY3RlZCBCaW5hcnkgRXh0ZW5kZWQgSlNPTiBmb3JtYXQgJHtKU09OLnN0cmluZ2lmeShkb2MpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlID09PSBCU09OX0JJTkFSWV9TVUJUWVBFX1VVSURfTkVXID8gbmV3IFVVSUQoZGF0YSkgOiBuZXcgQmluYXJ5KGRhdGEsIHR5cGUpO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3BlY3QoKTtcbiAgICB9XG4gICAgaW5zcGVjdCgpIHtcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gQnl0ZVV0aWxzLnRvQmFzZTY0KHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMucG9zaXRpb24pKTtcbiAgICAgICAgcmV0dXJuIGBCaW5hcnkuY3JlYXRlRnJvbUJhc2U2NChcIiR7YmFzZTY0fVwiLCAke3RoaXMuc3ViX3R5cGV9KWA7XG4gICAgfVxufVxuQmluYXJ5LkJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVCA9IDA7XG5CaW5hcnkuQlVGRkVSX1NJWkUgPSAyNTY7XG5CaW5hcnkuU1VCVFlQRV9ERUZBVUxUID0gMDtcbkJpbmFyeS5TVUJUWVBFX0ZVTkNUSU9OID0gMTtcbkJpbmFyeS5TVUJUWVBFX0JZVEVfQVJSQVkgPSAyO1xuQmluYXJ5LlNVQlRZUEVfVVVJRF9PTEQgPSAzO1xuQmluYXJ5LlNVQlRZUEVfVVVJRCA9IDQ7XG5CaW5hcnkuU1VCVFlQRV9NRDUgPSA1O1xuQmluYXJ5LlNVQlRZUEVfRU5DUllQVEVEID0gNjtcbkJpbmFyeS5TVUJUWVBFX0NPTFVNTiA9IDc7XG5CaW5hcnkuU1VCVFlQRV9VU0VSX0RFRklORUQgPSAxMjg7XG5jb25zdCBVVUlEX0JZVEVfTEVOR1RIID0gMTY7XG5jb25zdCBVVUlEX1dJVEhPVVRfREFTSEVTID0gL15bMC05QS1GXXszMn0kL2k7XG5jb25zdCBVVUlEX1dJVEhfREFTSEVTID0gL15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXsxMn0kL2k7XG5jbGFzcyBVVUlEIGV4dGVuZHMgQmluYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBsZXQgYnl0ZXM7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBieXRlcyA9IFVVSUQuZ2VuZXJhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIFVVSUQpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKG5ldyBVaW50OEFycmF5KGlucHV0LmJ1ZmZlcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhpbnB1dCkgJiYgaW5wdXQuYnl0ZUxlbmd0aCA9PT0gVVVJRF9CWVRFX0xFTkdUSCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gVVVJRC5ieXRlc0Zyb21TdHJpbmcoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQXJndW1lbnQgcGFzc2VkIGluIFVVSUQgY29uc3RydWN0b3IgbXVzdCBiZSBhIFVVSUQsIGEgMTYgYnl0ZSBCdWZmZXIgb3IgYSAzMi8zNiBjaGFyYWN0ZXIgaGV4IHN0cmluZyAoZGFzaGVzIGV4Y2x1ZGVkL2luY2x1ZGVkLCBmb3JtYXQ6IHh4eHh4eHh4LXh4eHgteHh4eC14eHh4LXh4eHh4eHh4eHh4eCkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoYnl0ZXMsIEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcpO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgICB9XG4gICAgc2V0IGlkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSGV4U3RyaW5nKGluY2x1ZGVEYXNoZXMgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpbmNsdWRlRGFzaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCA0KSksXG4gICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnRvSGV4KHRoaXMuYnVmZmVyLnN1YmFycmF5KDQsIDYpKSxcbiAgICAgICAgICAgICAgICBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIuc3ViYXJyYXkoNiwgOCkpLFxuICAgICAgICAgICAgICAgIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlci5zdWJhcnJheSg4LCAxMCkpLFxuICAgICAgICAgICAgICAgIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgxMCwgMTYpKVxuICAgICAgICAgICAgXS5qb2luKCctJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHRvU3RyaW5nKGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2hleCcpXG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvSGV4KHRoaXMuaWQpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0Jhc2U2NCh0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXJJZCkge1xuICAgICAgICBpZiAoIW90aGVySWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXJJZCBpbnN0YW5jZW9mIFVVSUQpIHtcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMuZXF1YWxzKG90aGVySWQuaWQsIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLmVxdWFscyhuZXcgVVVJRChvdGhlcklkKS5pZCwgdGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvQmluYXJ5KCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeSh0aGlzLmlkLCBCaW5hcnkuU1VCVFlQRV9VVUlEKTtcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlKCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IEJ5dGVVdGlscy5yYW5kb21CeXRlcyhVVUlEX0JZVEVfTEVOR1RIKTtcbiAgICAgICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkKGlucHV0KSB7XG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFVVSUQuaXNWYWxpZFVVSURTdHJpbmcoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1VpbnQ4QXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuYnl0ZUxlbmd0aCA9PT0gVVVJRF9CWVRFX0xFTkdUSDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGlucHV0Ll9ic29udHlwZSA9PT0gJ0JpbmFyeScgJiZcbiAgICAgICAgICAgIGlucHV0LnN1Yl90eXBlID09PSB0aGlzLlNVQlRZUEVfVVVJRCAmJlxuICAgICAgICAgICAgaW5wdXQuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDE2KTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21IZXhTdHJpbmcoaGV4U3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFVVSUQuYnl0ZXNGcm9tU3RyaW5nKGhleFN0cmluZyk7XG4gICAgICAgIHJldHVybiBuZXcgVVVJRChidWZmZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUJhc2U2NChiYXNlNjQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVVUlEKEJ5dGVVdGlscy5mcm9tQmFzZTY0KGJhc2U2NCkpO1xuICAgIH1cbiAgICBzdGF0aWMgYnl0ZXNGcm9tU3RyaW5nKHJlcHJlc2VudGF0aW9uKSB7XG4gICAgICAgIGlmICghVVVJRC5pc1ZhbGlkVVVJRFN0cmluZyhyZXByZXNlbnRhdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1VVSUQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG11c3QgYmUgMzIgaGV4IGRpZ2l0cyBvciBjYW5vbmljYWwgaHlwaGVuYXRlZCByZXByZXNlbnRhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCeXRlVXRpbHMuZnJvbUhleChyZXByZXNlbnRhdGlvbi5yZXBsYWNlKC8tL2csICcnKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkVVVJRFN0cmluZyhyZXByZXNlbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gVVVJRF9XSVRIT1VUX0RBU0hFUy50ZXN0KHJlcHJlc2VudGF0aW9uKSB8fCBVVUlEX1dJVEhfREFTSEVTLnRlc3QocmVwcmVzZW50YXRpb24pO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3BlY3QoKTtcbiAgICB9XG4gICAgaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIGBuZXcgVVVJRChcIiR7dGhpcy50b0hleFN0cmluZygpfVwiKWA7XG4gICAgfVxufVxuVVVJRC5jYWNoZUhleFN0cmluZyA9IGZhbHNlO1xuXG5jbGFzcyBDb2RlIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0NvZGUnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBzY29wZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZSA/PyBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvZGU6IHRoaXMuY29kZSwgc2NvcGU6IHRoaXMuc2NvcGUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjb2RlOiB0aGlzLmNvZGUgfTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlKSB7XG4gICAgICAgICAgICByZXR1cm4geyAkY29kZTogdGhpcy5jb2RlLCAkc2NvcGU6IHRoaXMuc2NvcGUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAkY29kZTogdGhpcy5jb2RlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IENvZGUoZG9jLiRjb2RlLCBkb2MuJHNjb3BlKTtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIGNvbnN0IGNvZGVKc29uID0gdGhpcy50b0pTT04oKTtcbiAgICAgICAgcmV0dXJuIGBuZXcgQ29kZShcIiR7U3RyaW5nKGNvZGVKc29uLmNvZGUpfVwiJHtjb2RlSnNvbi5zY29wZSAhPSBudWxsID8gYCwgJHtKU09OLnN0cmluZ2lmeShjb2RlSnNvbi5zY29wZSl9YCA6ICcnfSlgO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNEQlJlZkxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnJGlkJyBpbiB2YWx1ZSAmJlxuICAgICAgICB2YWx1ZS4kaWQgIT0gbnVsbCAmJlxuICAgICAgICAnJHJlZicgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLiRyZWYgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICghKCckZGInIGluIHZhbHVlKSB8fCAoJyRkYicgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLiRkYiA9PT0gJ3N0cmluZycpKSk7XG59XG5jbGFzcyBEQlJlZiBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdEQlJlZic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb24sIG9pZCwgZGIsIGZpZWxkcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGNvbGxlY3Rpb24uc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgZGIgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgY29sbGVjdGlvbiA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgICAgdGhpcy5vaWQgPSBvaWQ7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHMgfHwge307XG4gICAgfVxuICAgIGdldCBuYW1lc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb247XG4gICAgfVxuICAgIHNldCBuYW1lc3BhY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgbyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgJHJlZjogdGhpcy5jb2xsZWN0aW9uLFxuICAgICAgICAgICAgJGlkOiB0aGlzLm9pZFxuICAgICAgICB9LCB0aGlzLmZpZWxkcyk7XG4gICAgICAgIGlmICh0aGlzLmRiICE9IG51bGwpXG4gICAgICAgICAgICBvLiRkYiA9IHRoaXMuZGI7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBsZXQgbyA9IHtcbiAgICAgICAgICAgICRyZWY6IHRoaXMuY29sbGVjdGlvbixcbiAgICAgICAgICAgICRpZDogdGhpcy5vaWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVnYWN5KSB7XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYilcbiAgICAgICAgICAgIG8uJGRiID0gdGhpcy5kYjtcbiAgICAgICAgbyA9IE9iamVjdC5hc3NpZ24obywgdGhpcy5maWVsZHMpO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBkb2MpO1xuICAgICAgICBkZWxldGUgY29weS4kcmVmO1xuICAgICAgICBkZWxldGUgY29weS4kaWQ7XG4gICAgICAgIGRlbGV0ZSBjb3B5LiRkYjtcbiAgICAgICAgcmV0dXJuIG5ldyBEQlJlZihkb2MuJHJlZiwgZG9jLiRpZCwgZG9jLiRkYiwgY29weSk7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICBjb25zdCBvaWQgPSB0aGlzLm9pZCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub2lkLnRvU3RyaW5nID09PSB1bmRlZmluZWQgPyB0aGlzLm9pZCA6IHRoaXMub2lkLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBgbmV3IERCUmVmKFwiJHt0aGlzLm5hbWVzcGFjZX1cIiwgbmV3IE9iamVjdElkKFwiJHtTdHJpbmcob2lkKX1cIikke3RoaXMuZGIgPyBgLCBcIiR7dGhpcy5kYn1cImAgOiAnJ30pYDtcbiAgICB9XG59XG5cbmxldCB3YXNtID0gdW5kZWZpbmVkO1xudHJ5IHtcbiAgICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoWzAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgMTMsIDIsIDk2LCAwLCAxLCAxMjcsIDk2LCA0LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEsIDEyNywgMywgNywgNiwgMCwgMSwgMSwgMSwgMSwgMSwgNiwgNiwgMSwgMTI3LCAxLCA2NSwgMCwgMTEsIDcsIDUwLCA2LCAzLCAxMDksIDExNywgMTA4LCAwLCAxLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE1LCAwLCAyLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE3LCAwLCAzLCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE1LCAwLCA0LCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE3LCAwLCA1LCA4LCAxMDMsIDEwMSwgMTE2LCA5NSwgMTA0LCAxMDUsIDEwMywgMTA0LCAwLCAwLCAxMCwgMTkxLCAxLCA2LCA0LCAwLCAzNSwgMCwgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNiwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI3LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjgsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOSwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTMwLCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExXSkpLCB7fSkuZXhwb3J0cztcbn1cbmNhdGNoIHtcbn1cbmNvbnN0IFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcbmNvbnN0IFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcbmNvbnN0IFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcbmNvbnN0IFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcbmNvbnN0IFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xuY29uc3QgSU5UX0NBQ0hFID0ge307XG5jb25zdCBVSU5UX0NBQ0hFID0ge307XG5jb25zdCBNQVhfSU5UNjRfU1RSSU5HX0xFTkdUSCA9IDIwO1xuY29uc3QgREVDSU1BTF9SRUdfRVggPSAvXihcXCs/MHwoXFwrfC0pP1sxLTldWzAtOV0qKSQvO1xuY2xhc3MgTG9uZyBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdMb25nJztcbiAgICB9XG4gICAgZ2V0IF9faXNMb25nX18oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihsb3cgPSAwLCBoaWdoLCB1bnNpZ25lZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAodHlwZW9mIGxvdyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgTG9uZy5mcm9tQmlnSW50KGxvdywgISFoaWdoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgTG9uZy5mcm9tU3RyaW5nKGxvdywgISFoaWdoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvdyA9IGxvdyB8IDA7XG4gICAgICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcbiAgICAgICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICBsZXQgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xuICAgICAgICBpZiAodW5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPSAwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBMb25nLmZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGNhY2hlKVxuICAgICAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgICAgICBpZiAoKGNhY2hlID0gLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBMb25nLmZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjYWNoZSlcbiAgICAgICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IExvbmcuVVpFUk8gOiBMb25nLlpFUk87XG4gICAgICAgIGlmICh1bnNpZ25lZCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5VWkVSTztcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTClcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5NQVhfVU5TSUdORURfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLk1JTl9WQUxVRTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IDApXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh2YWx1ZSAlIFRXT19QV1JfMzJfREJMIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJpZ0ludCh2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbVN0cmluZyh2YWx1ZS50b1N0cmluZygpLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIGlmIChzdHIgPT09ICdOYU4nIHx8IHN0ciA9PT0gJ0luZmluaXR5JyB8fCBzdHIgPT09ICcrSW5maW5pdHknIHx8IHN0ciA9PT0gJy1JbmZpbml0eScpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5aRVJPO1xuICAgICAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgKHJhZGl4ID0gdW5zaWduZWQpLCAodW5zaWduZWQgPSBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigncmFkaXgnKTtcbiAgICAgICAgbGV0IHA7XG4gICAgICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2ludGVyaW9yIGh5cGhlbicpO1xuICAgICAgICBlbHNlIGlmIChwID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFkaXhUb1Bvd2VyID0gTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCA4KSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBMb25nLlpFUk87XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLCB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3dlciA9IExvbmcuZnJvbU51bWJlcihNYXRoLnBvdyhyYWRpeCwgc2l6ZSkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChMb25nLmZyb21OdW1iZXIodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKExvbmcuZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHtcbiAgICAgICAgcmV0dXJuIGxlID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9uZyhieXRlc1swXSB8IChieXRlc1sxXSA8PCA4KSB8IChieXRlc1syXSA8PCAxNikgfCAoYnl0ZXNbM10gPDwgMjQpLCBieXRlc1s0XSB8IChieXRlc1s1XSA8PCA4KSB8IChieXRlc1s2XSA8PCAxNikgfCAoYnl0ZXNbN10gPDwgMjQpLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb25nKChieXRlc1s0XSA8PCAyNCkgfCAoYnl0ZXNbNV0gPDwgMTYpIHwgKGJ5dGVzWzZdIDw8IDgpIHwgYnl0ZXNbN10sIChieXRlc1swXSA8PCAyNCkgfCAoYnl0ZXNbMV0gPDwgMTYpIHwgKGJ5dGVzWzJdIDw8IDgpIHwgYnl0ZXNbM10sIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGlzTG9uZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICdfX2lzTG9uZ19fJyBpbiB2YWx1ZSAmJlxuICAgICAgICAgICAgdmFsdWUuX19pc0xvbmdfXyA9PT0gdHJ1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVmFsdWUodmFsLCB1bnNpZ25lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tTnVtYmVyKHZhbCwgdW5zaWduZWQpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tU3RyaW5nKHZhbCwgdW5zaWduZWQpO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAnYm9vbGVhbicgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCk7XG4gICAgfVxuICAgIGFkZChhZGRlbmQpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhhZGRlbmQpKVxuICAgICAgICAgICAgYWRkZW5kID0gTG9uZy5mcm9tVmFsdWUoYWRkZW5kKTtcbiAgICAgICAgY29uc3QgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgICAgICAgY29uc3QgYTMyID0gdGhpcy5oaWdoICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGEwMCA9IHRoaXMubG93ICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGIzMiA9IGFkZGVuZC5oaWdoICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcbiAgICAgICAgY29uc3QgYjAwID0gYWRkZW5kLmxvdyAmIDB4ZmZmZjtcbiAgICAgICAgbGV0IGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XG4gICAgICAgIGMwMCArPSBhMDAgKyBiMDA7XG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgICAgICBjMDAgJj0gMHhmZmZmO1xuICAgICAgICBjMTYgKz0gYTE2ICsgYjE2O1xuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgICAgYzE2ICY9IDB4ZmZmZjtcbiAgICAgICAgYzMyICs9IGEzMiArIGIzMjtcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICAgIGM0OCArPSBhNDggKyBiNDg7XG4gICAgICAgIGM0OCAmPSAweGZmZmY7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIGFuZChvdGhlcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSlcbiAgICAgICAgICAgIG90aGVyID0gTG9uZy5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhvdGhlcikpXG4gICAgICAgICAgICBvdGhlciA9IExvbmcuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSwgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XG4gICAgICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZylcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xuICAgICAgICByZXR1cm4gb3RoZXIuaGlnaCA+Pj4gMCA+IHRoaXMuaGlnaCA+Pj4gMCB8fFxuICAgICAgICAgICAgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiBvdGhlci5sb3cgPj4+IDAgPiB0aGlzLmxvdyA+Pj4gMClcbiAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgIDogMTtcbiAgICB9XG4gICAgY29tcChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKG90aGVyKTtcbiAgICB9XG4gICAgZGl2aWRlKGRpdmlzb3IpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhkaXZpc29yKSlcbiAgICAgICAgICAgIGRpdmlzb3IgPSBMb25nLmZyb21WYWx1ZShkaXZpc29yKTtcbiAgICAgICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XG4gICAgICAgIGlmICh3YXNtKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmXG4gICAgICAgICAgICAgICAgZGl2aXNvci5sb3cgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgZGl2aXNvci5oaWdoID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLmRpdl91IDogd2FzbS5kaXZfcykodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7XG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IExvbmcuVVpFUk8gOiBMb25nLlpFUk87XG4gICAgICAgIGxldCBhcHByb3gsIHJlbSwgcmVzO1xuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKExvbmcuTUlOX1ZBTFVFKSkge1xuICAgICAgICAgICAgICAgIGlmIChkaXZpc29yLmVxKExvbmcuT05FKSB8fCBkaXZpc29yLmVxKExvbmcuTkVHX09ORSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMb25nLk1JTl9WQUxVRTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKExvbmcuTUlOX1ZBTFVFKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuT05FO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpO1xuICAgICAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXBwcm94LmVxKExvbmcuWkVSTykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IExvbmcuT05FIDogTG9uZy5ORUdfT05FO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTG9uZy5NSU5fVkFMVUUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gTG9uZy5VWkVSTyA6IExvbmcuWkVSTztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTtcbiAgICAgICAgICAgIHJlcyA9IExvbmcuWkVSTztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZClcbiAgICAgICAgICAgICAgICBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7XG4gICAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5VWkVSTztcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuVU9ORTtcbiAgICAgICAgICAgIHJlcyA9IExvbmcuVVpFUk87XG4gICAgICAgIH1cbiAgICAgICAgcmVtID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHtcbiAgICAgICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcbiAgICAgICAgICAgIGNvbnN0IGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gbG9nMiA8PSA0OCA/IDEgOiBNYXRoLnBvdygyLCBsb2cyIC0gNDgpO1xuICAgICAgICAgICAgbGV0IGFwcHJveFJlcyA9IExvbmcuZnJvbU51bWJlcihhcHByb3gpO1xuICAgICAgICAgICAgbGV0IGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkge1xuICAgICAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBhcHByb3hSZXMgPSBMb25nLmZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcbiAgICAgICAgICAgICAgICBhcHByb3hSZXMgPSBMb25nLk9ORTtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcbiAgICAgICAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBkaXYoZGl2aXNvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGUoZGl2aXNvcik7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSlcbiAgICAgICAgICAgIG90aGVyID0gTG9uZy5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgdGhpcy5oaWdoID4+PiAzMSA9PT0gMSAmJiBvdGhlci5oaWdoID4+PiAzMSA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMob3RoZXIpO1xuICAgIH1cbiAgICBnZXRIaWdoQml0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaDtcbiAgICB9XG4gICAgZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcbiAgICB9XG4gICAgZ2V0TG93Qml0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG93O1xuICAgIH1cbiAgICBnZXRMb3dCaXRzVW5zaWduZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcbiAgICB9XG4gICAgZ2V0TnVtQml0c0FicygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcShMb25nLk1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuaGlnaCAhPT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xuICAgICAgICBsZXQgYml0O1xuICAgICAgICBmb3IgKGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSlcbiAgICAgICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT09IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggIT09IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XG4gICAgfVxuICAgIGdyZWF0ZXJUaGFuKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpID4gMDtcbiAgICB9XG4gICAgZ3Qob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JlYXRlclRoYW4ob3RoZXIpO1xuICAgIH1cbiAgICBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPj0gMDtcbiAgICB9XG4gICAgZ3RlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcik7XG4gICAgfVxuICAgIGdlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcik7XG4gICAgfVxuICAgIGlzRXZlbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xuICAgIH1cbiAgICBpc05lZ2F0aXZlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcbiAgICB9XG4gICAgaXNPZGQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcbiAgICB9XG4gICAgaXNQb3NpdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XG4gICAgfVxuICAgIGlzWmVybygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDtcbiAgICB9XG4gICAgbGVzc1RoYW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPCAwO1xuICAgIH1cbiAgICBsdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXNzVGhhbihvdGhlcik7XG4gICAgfVxuICAgIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA8PSAwO1xuICAgIH1cbiAgICBsdGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVzc1RoYW5PckVxdWFsKG90aGVyKTtcbiAgICB9XG4gICAgbW9kdWxvKGRpdmlzb3IpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhkaXZpc29yKSlcbiAgICAgICAgICAgIGRpdmlzb3IgPSBMb25nLmZyb21WYWx1ZShkaXZpc29yKTtcbiAgICAgICAgaWYgKHdhc20pIHtcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5yZW1fdSA6IHdhc20ucmVtX3MpKHRoaXMubG93LCB0aGlzLmhpZ2gsIGRpdmlzb3IubG93LCBkaXZpc29yLmhpZ2gpO1xuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpO1xuICAgIH1cbiAgICBtb2QoZGl2aXNvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bG8oZGl2aXNvcik7XG4gICAgfVxuICAgIHJlbShkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsbyhkaXZpc29yKTtcbiAgICB9XG4gICAgbXVsdGlwbHkobXVsdGlwbGllcikge1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICAgICAgICAgIHJldHVybiBMb25nLlpFUk87XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcobXVsdGlwbGllcikpXG4gICAgICAgICAgICBtdWx0aXBsaWVyID0gTG9uZy5mcm9tVmFsdWUobXVsdGlwbGllcik7XG4gICAgICAgIGlmICh3YXNtKSB7XG4gICAgICAgICAgICBjb25zdCBsb3cgPSB3YXNtLm11bCh0aGlzLmxvdywgdGhpcy5oaWdoLCBtdWx0aXBsaWVyLmxvdywgbXVsdGlwbGllci5oaWdoKTtcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcbiAgICAgICAgICAgIHJldHVybiBMb25nLlpFUk87XG4gICAgICAgIGlmICh0aGlzLmVxKExvbmcuTUlOX1ZBTFVFKSlcbiAgICAgICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBMb25nLk1JTl9WQUxVRSA6IExvbmcuWkVSTztcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuZXEoTG9uZy5NSU5fVkFMVUUpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IExvbmcuTUlOX1ZBTFVFIDogTG9uZy5aRVJPO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xuICAgICAgICBpZiAodGhpcy5sdChMb25nLlRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoTG9uZy5UV09fUFdSXzI0KSlcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgY29uc3QgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgICAgICAgY29uc3QgYTMyID0gdGhpcy5oaWdoICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGEwMCA9IHRoaXMubG93ICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xuICAgICAgICBjb25zdCBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGIxNiA9IG11bHRpcGxpZXIubG93ID4+PiAxNjtcbiAgICAgICAgY29uc3QgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweGZmZmY7XG4gICAgICAgIGxldCBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xuICAgICAgICBjMDAgKz0gYTAwICogYjAwO1xuICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjtcbiAgICAgICAgYzAwICY9IDB4ZmZmZjtcbiAgICAgICAgYzE2ICs9IGExNiAqIGIwMDtcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgICAgIGMxNiAmPSAweGZmZmY7XG4gICAgICAgIGMxNiArPSBhMDAgKiBiMTY7XG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgICAgICBjMTYgJj0gMHhmZmZmO1xuICAgICAgICBjMzIgKz0gYTMyICogYjAwO1xuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgICAgYzMyICs9IGExNiAqIGIxNjtcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICAgIGMzMiArPSBhMDAgKiBiMzI7XG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xuICAgICAgICBjNDggJj0gMHhmZmZmO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBtdWwobXVsdGlwbGllcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShtdWx0aXBsaWVyKTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShMb25nLk1JTl9WQUxVRSkpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5NSU5fVkFMVUU7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChMb25nLk9ORSk7XG4gICAgfVxuICAgIG5lZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCk7XG4gICAgfVxuICAgIG5vdCgpIHtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgbm90RXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5lcXVhbHMob3RoZXIpO1xuICAgIH1cbiAgICBuZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm90RXF1YWxzKG90aGVyKTtcbiAgICB9XG4gICAgbmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm90RXF1YWxzKG90aGVyKTtcbiAgICB9XG4gICAgb3Iob3RoZXIpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhvdGhlcikpXG4gICAgICAgICAgICBvdGhlciA9IExvbmcuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBzaGlmdExlZnQobnVtQml0cykge1xuICAgICAgICBpZiAoTG9uZy5pc0xvbmcobnVtQml0cykpXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKDAsIHRoaXMubG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgc2hsKG51bUJpdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpZnRMZWZ0KG51bUJpdHMpO1xuICAgIH1cbiAgICBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcbiAgICAgICAgaWYgKExvbmcuaXNMb25nKG51bUJpdHMpKVxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5oaWdoID4+IChudW1CaXRzIC0gMzIpLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIHNocihudW1CaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0UmlnaHQobnVtQml0cyk7XG4gICAgfVxuICAgIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKSB7XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyhudW1CaXRzKSlcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgICAgIG51bUJpdHMgJj0gNjM7XG4gICAgICAgIGlmIChudW1CaXRzID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGlnaCA9IHRoaXMuaGlnaDtcbiAgICAgICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb3cgPSB0aGlzLmxvdztcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cygobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChudW1CaXRzID09PSAzMilcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hyX3UobnVtQml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cyk7XG4gICAgfVxuICAgIHNocnUobnVtQml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cyk7XG4gICAgfVxuICAgIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhzdWJ0cmFoZW5kKSlcbiAgICAgICAgICAgIHN1YnRyYWhlbmQgPSBMb25nLmZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xuICAgIH1cbiAgICBzdWIoc3VidHJhaGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChzdWJ0cmFoZW5kKTtcbiAgICB9XG4gICAgdG9JbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xuICAgIH1cbiAgICB0b0JpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICB0b0J5dGVzKGxlKSB7XG4gICAgICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xuICAgIH1cbiAgICB0b0J5dGVzTEUoKSB7XG4gICAgICAgIGNvbnN0IGhpID0gdGhpcy5oaWdoLCBsbyA9IHRoaXMubG93O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbG8gJiAweGZmLFxuICAgICAgICAgICAgKGxvID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICAobG8gPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgICBsbyA+Pj4gMjQsXG4gICAgICAgICAgICBoaSAmIDB4ZmYsXG4gICAgICAgICAgICAoaGkgPj4+IDgpICYgMHhmZixcbiAgICAgICAgICAgIChoaSA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIGhpID4+PiAyNFxuICAgICAgICBdO1xuICAgIH1cbiAgICB0b0J5dGVzQkUoKSB7XG4gICAgICAgIGNvbnN0IGhpID0gdGhpcy5oaWdoLCBsbyA9IHRoaXMubG93O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgaGkgPj4+IDI0LFxuICAgICAgICAgICAgKGhpID4+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgKGhpID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICBoaSAmIDB4ZmYsXG4gICAgICAgICAgICBsbyA+Pj4gMjQsXG4gICAgICAgICAgICAobG8gPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgICAobG8gPj4+IDgpICYgMHhmZixcbiAgICAgICAgICAgIGxvICYgMHhmZlxuICAgICAgICBdO1xuICAgIH1cbiAgICB0b1NpZ25lZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigncmFkaXgnKTtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXG4gICAgICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKExvbmcuTUlOX1ZBTFVFKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGl4TG9uZyA9IExvbmcuZnJvbU51bWJlcihyYWRpeCksIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFkaXhUb1Bvd2VyID0gTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIGxldCByZW0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlcik7XG4gICAgICAgICAgICBjb25zdCBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMDtcbiAgICAgICAgICAgIGxldCBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICAgICAgcmVtID0gcmVtRGl2O1xuICAgICAgICAgICAgaWYgKHJlbS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICAgICAgICAgIGRpZ2l0cyA9ICcwJyArIGRpZ2l0cztcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1Vuc2lnbmVkKCkge1xuICAgICAgICBpZiAodGhpcy51bnNpZ25lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcbiAgICB9XG4gICAgeG9yKG90aGVyKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgZXF6KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1plcm8oKTtcbiAgICB9XG4gICAgbGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVzc1RoYW5PckVxdWFsKG90aGVyKTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlbGF4ZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b051bWJlcigpO1xuICAgICAgICByZXR1cm4geyAkbnVtYmVyTG9uZzogdGhpcy50b1N0cmluZygpIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHVzZUJpZ0ludDY0ID0gZmFsc2UsIHJlbGF4ZWQgPSB0cnVlIH0gPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgaWYgKGRvYy4kbnVtYmVyTG9uZy5sZW5ndGggPiBNQVhfSU5UNjRfU1RSSU5HX0xFTkdUSCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignJG51bWJlckxvbmcgc3RyaW5nIGlzIHRvbyBsb25nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFERUNJTUFMX1JFR19FWC50ZXN0KGRvYy4kbnVtYmVyTG9uZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYCRudW1iZXJMb25nIHN0cmluZyBcIiR7ZG9jLiRudW1iZXJMb25nfVwiIGlzIGluIGFuIGludmFsaWQgZm9ybWF0YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZUJpZ0ludDY0KSB7XG4gICAgICAgICAgICBjb25zdCBiaWdJbnRSZXN1bHQgPSBCaWdJbnQoZG9jLiRudW1iZXJMb25nKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQuYXNJbnROKDY0LCBiaWdJbnRSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvbmdSZXN1bHQgPSBMb25nLmZyb21TdHJpbmcoZG9jLiRudW1iZXJMb25nKTtcbiAgICAgICAgaWYgKHJlbGF4ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb25nUmVzdWx0LnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvbmdSZXN1bHQ7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gYG5ldyBMb25nKFwiJHt0aGlzLnRvU3RyaW5nKCl9XCIke3RoaXMudW5zaWduZWQgPyAnLCB0cnVlJyA6ICcnfSlgO1xuICAgIH1cbn1cbkxvbmcuVFdPX1BXUl8yNCA9IExvbmcuZnJvbUludChUV09fUFdSXzI0X0RCTCk7XG5Mb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMHhmZmZmZmZmZiB8IDAsIDB4ZmZmZmZmZmYgfCAwLCB0cnVlKTtcbkxvbmcuWkVSTyA9IExvbmcuZnJvbUludCgwKTtcbkxvbmcuVVpFUk8gPSBMb25nLmZyb21JbnQoMCwgdHJ1ZSk7XG5Mb25nLk9ORSA9IExvbmcuZnJvbUludCgxKTtcbkxvbmcuVU9ORSA9IExvbmcuZnJvbUludCgxLCB0cnVlKTtcbkxvbmcuTkVHX09ORSA9IExvbmcuZnJvbUludCgtMSk7XG5Mb25nLk1BWF9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMHhmZmZmZmZmZiB8IDAsIDB4N2ZmZmZmZmYgfCAwLCBmYWxzZSk7XG5Mb25nLk1JTl9WQUxVRSA9IExvbmcuZnJvbUJpdHMoMCwgMHg4MDAwMDAwMCB8IDAsIGZhbHNlKTtcblxuY29uc3QgUEFSU0VfU1RSSU5HX1JFR0VYUCA9IC9eKFxcK3wtKT8oXFxkK3woXFxkKlxcLlxcZCopKT8oRXxlKT8oWy0rXSk/KFxcZCspPyQvO1xuY29uc3QgUEFSU0VfSU5GX1JFR0VYUCA9IC9eKFxcK3wtKT8oSW5maW5pdHl8aW5mKSQvaTtcbmNvbnN0IFBBUlNFX05BTl9SRUdFWFAgPSAvXihcXCt8LSk/TmFOJC9pO1xuY29uc3QgRVhQT05FTlRfTUFYID0gNjExMTtcbmNvbnN0IEVYUE9ORU5UX01JTiA9IC02MTc2O1xuY29uc3QgRVhQT05FTlRfQklBUyA9IDYxNzY7XG5jb25zdCBNQVhfRElHSVRTID0gMzQ7XG5jb25zdCBOQU5fQlVGRkVSID0gQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShbXG4gICAgMHg3YywgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMFxuXS5yZXZlcnNlKCkpO1xuY29uc3QgSU5GX05FR0FUSVZFX0JVRkZFUiA9IEJ5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoW1xuICAgIDB4ZjgsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBcbl0ucmV2ZXJzZSgpKTtcbmNvbnN0IElORl9QT1NJVElWRV9CVUZGRVIgPSBCeXRlVXRpbHMuZnJvbU51bWJlckFycmF5KFtcbiAgICAweDc4LCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXG5dLnJldmVyc2UoKSk7XG5jb25zdCBFWFBPTkVOVF9SRUdFWCA9IC9eKFstK10pPyhcXGQrKT8kLztcbmNvbnN0IENPTUJJTkFUSU9OX01BU0sgPSAweDFmO1xuY29uc3QgRVhQT05FTlRfTUFTSyA9IDB4M2ZmZjtcbmNvbnN0IENPTUJJTkFUSU9OX0lORklOSVRZID0gMzA7XG5jb25zdCBDT01CSU5BVElPTl9OQU4gPSAzMTtcbmZ1bmN0aW9uIGlzRGlnaXQodmFsdWUpIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xufVxuZnVuY3Rpb24gZGl2aWRldTEyOCh2YWx1ZSkge1xuICAgIGNvbnN0IERJVklTT1IgPSBMb25nLmZyb21OdW1iZXIoMTAwMCAqIDEwMDAgKiAxMDAwKTtcbiAgICBsZXQgX3JlbSA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICBpZiAoIXZhbHVlLnBhcnRzWzBdICYmICF2YWx1ZS5wYXJ0c1sxXSAmJiAhdmFsdWUucGFydHNbMl0gJiYgIXZhbHVlLnBhcnRzWzNdKSB7XG4gICAgICAgIHJldHVybiB7IHF1b3RpZW50OiB2YWx1ZSwgcmVtOiBfcmVtIH07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDM7IGkrKykge1xuICAgICAgICBfcmVtID0gX3JlbS5zaGlmdExlZnQoMzIpO1xuICAgICAgICBfcmVtID0gX3JlbS5hZGQobmV3IExvbmcodmFsdWUucGFydHNbaV0sIDApKTtcbiAgICAgICAgdmFsdWUucGFydHNbaV0gPSBfcmVtLmRpdihESVZJU09SKS5sb3c7XG4gICAgICAgIF9yZW0gPSBfcmVtLm1vZHVsbyhESVZJU09SKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcXVvdGllbnQ6IHZhbHVlLCByZW06IF9yZW0gfTtcbn1cbmZ1bmN0aW9uIG11bHRpcGx5NjR4MihsZWZ0LCByaWdodCkge1xuICAgIGlmICghbGVmdCAmJiAhcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHsgaGlnaDogTG9uZy5mcm9tTnVtYmVyKDApLCBsb3c6IExvbmcuZnJvbU51bWJlcigwKSB9O1xuICAgIH1cbiAgICBjb25zdCBsZWZ0SGlnaCA9IGxlZnQuc2hpZnRSaWdodFVuc2lnbmVkKDMyKTtcbiAgICBjb25zdCBsZWZ0TG93ID0gbmV3IExvbmcobGVmdC5nZXRMb3dCaXRzKCksIDApO1xuICAgIGNvbnN0IHJpZ2h0SGlnaCA9IHJpZ2h0LnNoaWZ0UmlnaHRVbnNpZ25lZCgzMik7XG4gICAgY29uc3QgcmlnaHRMb3cgPSBuZXcgTG9uZyhyaWdodC5nZXRMb3dCaXRzKCksIDApO1xuICAgIGxldCBwcm9kdWN0SGlnaCA9IGxlZnRIaWdoLm11bHRpcGx5KHJpZ2h0SGlnaCk7XG4gICAgbGV0IHByb2R1Y3RNaWQgPSBsZWZ0SGlnaC5tdWx0aXBseShyaWdodExvdyk7XG4gICAgY29uc3QgcHJvZHVjdE1pZDIgPSBsZWZ0TG93Lm11bHRpcGx5KHJpZ2h0SGlnaCk7XG4gICAgbGV0IHByb2R1Y3RMb3cgPSBsZWZ0TG93Lm11bHRpcGx5KHJpZ2h0TG93KTtcbiAgICBwcm9kdWN0SGlnaCA9IHByb2R1Y3RIaWdoLmFkZChwcm9kdWN0TWlkLnNoaWZ0UmlnaHRVbnNpZ25lZCgzMikpO1xuICAgIHByb2R1Y3RNaWQgPSBuZXcgTG9uZyhwcm9kdWN0TWlkLmdldExvd0JpdHMoKSwgMClcbiAgICAgICAgLmFkZChwcm9kdWN0TWlkMilcbiAgICAgICAgLmFkZChwcm9kdWN0TG93LnNoaWZ0UmlnaHRVbnNpZ25lZCgzMikpO1xuICAgIHByb2R1Y3RIaWdoID0gcHJvZHVjdEhpZ2guYWRkKHByb2R1Y3RNaWQuc2hpZnRSaWdodFVuc2lnbmVkKDMyKSk7XG4gICAgcHJvZHVjdExvdyA9IHByb2R1Y3RNaWQuc2hpZnRMZWZ0KDMyKS5hZGQobmV3IExvbmcocHJvZHVjdExvdy5nZXRMb3dCaXRzKCksIDApKTtcbiAgICByZXR1cm4geyBoaWdoOiBwcm9kdWN0SGlnaCwgbG93OiBwcm9kdWN0TG93IH07XG59XG5mdW5jdGlvbiBsZXNzVGhhbihsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IHVobGVmdCA9IGxlZnQuaGlnaCA+Pj4gMDtcbiAgICBjb25zdCB1aHJpZ2h0ID0gcmlnaHQuaGlnaCA+Pj4gMDtcbiAgICBpZiAodWhsZWZ0IDwgdWhyaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodWhsZWZ0ID09PSB1aHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHVsbGVmdCA9IGxlZnQubG93ID4+PiAwO1xuICAgICAgICBjb25zdCB1bHJpZ2h0ID0gcmlnaHQubG93ID4+PiAwO1xuICAgICAgICBpZiAodWxsZWZ0IDwgdWxyaWdodClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpbnZhbGlkRXJyKHN0cmluZywgbWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFwiJHtzdHJpbmd9XCIgaXMgbm90IGEgdmFsaWQgRGVjaW1hbDEyOCBzdHJpbmcgLSAke21lc3NhZ2V9YCk7XG59XG5jbGFzcyBEZWNpbWFsMTI4IGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0RlY2ltYWwxMjgnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihieXRlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5ieXRlcyA9IERlY2ltYWwxMjguZnJvbVN0cmluZyhieXRlcykuYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNVaW50OEFycmF5KGJ5dGVzKSkge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignRGVjaW1hbDEyOCBtdXN0IHRha2UgYSBCdWZmZXIgb2YgMTYgYnl0ZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0RlY2ltYWwxMjggbXVzdCB0YWtlIGEgQnVmZmVyIG9yIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHJlcHJlc2VudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBEZWNpbWFsMTI4Ll9mcm9tU3RyaW5nKHJlcHJlc2VudGF0aW9uLCB7IGFsbG93Um91bmRpbmc6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZ1dpdGhSb3VuZGluZyhyZXByZXNlbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gRGVjaW1hbDEyOC5fZnJvbVN0cmluZyhyZXByZXNlbnRhdGlvbiwgeyBhbGxvd1JvdW5kaW5nOiB0cnVlIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgX2Zyb21TdHJpbmcocmVwcmVzZW50YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGlzTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNhd1NpZ24gPSBmYWxzZTtcbiAgICAgICAgbGV0IHNhd1JhZGl4ID0gZmFsc2U7XG4gICAgICAgIGxldCBmb3VuZE5vblplcm8gPSBmYWxzZTtcbiAgICAgICAgbGV0IHNpZ25pZmljYW50RGlnaXRzID0gMDtcbiAgICAgICAgbGV0IG5EaWdpdHNSZWFkID0gMDtcbiAgICAgICAgbGV0IG5EaWdpdHMgPSAwO1xuICAgICAgICBsZXQgcmFkaXhQb3NpdGlvbiA9IDA7XG4gICAgICAgIGxldCBmaXJzdE5vblplcm8gPSAwO1xuICAgICAgICBjb25zdCBkaWdpdHMgPSBbMF07XG4gICAgICAgIGxldCBuRGlnaXRzU3RvcmVkID0gMDtcbiAgICAgICAgbGV0IGRpZ2l0c0luc2VydCA9IDA7XG4gICAgICAgIGxldCBsYXN0RGlnaXQgPSAwO1xuICAgICAgICBsZXQgZXhwb25lbnQgPSAwO1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmRIaWdoID0gbmV3IExvbmcoMCwgMCk7XG4gICAgICAgIGxldCBzaWduaWZpY2FuZExvdyA9IG5ldyBMb25nKDAsIDApO1xuICAgICAgICBsZXQgYmlhc2VkRXhwb25lbnQgPSAwO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBpZiAocmVwcmVzZW50YXRpb24ubGVuZ3RoID49IDcwMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJycgKyByZXByZXNlbnRhdGlvbiArICcgbm90IGEgdmFsaWQgRGVjaW1hbDEyOCBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpbmdNYXRjaCA9IHJlcHJlc2VudGF0aW9uLm1hdGNoKFBBUlNFX1NUUklOR19SRUdFWFApO1xuICAgICAgICBjb25zdCBpbmZNYXRjaCA9IHJlcHJlc2VudGF0aW9uLm1hdGNoKFBBUlNFX0lORl9SRUdFWFApO1xuICAgICAgICBjb25zdCBuYW5NYXRjaCA9IHJlcHJlc2VudGF0aW9uLm1hdGNoKFBBUlNFX05BTl9SRUdFWFApO1xuICAgICAgICBpZiAoKCFzdHJpbmdNYXRjaCAmJiAhaW5mTWF0Y2ggJiYgIW5hbk1hdGNoKSB8fCByZXByZXNlbnRhdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJycgKyByZXByZXNlbnRhdGlvbiArICcgbm90IGEgdmFsaWQgRGVjaW1hbDEyOCBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nTWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkTnVtYmVyID0gc3RyaW5nTWF0Y2hbMl07XG4gICAgICAgICAgICBjb25zdCBlID0gc3RyaW5nTWF0Y2hbNF07XG4gICAgICAgICAgICBjb25zdCBleHBTaWduID0gc3RyaW5nTWF0Y2hbNV07XG4gICAgICAgICAgICBjb25zdCBleHBOdW1iZXIgPSBzdHJpbmdNYXRjaFs2XTtcbiAgICAgICAgICAgIGlmIChlICYmIGV4cE51bWJlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdtaXNzaW5nIGV4cG9uZW50IHBvd2VyJyk7XG4gICAgICAgICAgICBpZiAoZSAmJiB1bnNpZ25lZE51bWJlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdtaXNzaW5nIGV4cG9uZW50IGJhc2UnKTtcbiAgICAgICAgICAgIGlmIChlID09PSB1bmRlZmluZWQgJiYgKGV4cFNpZ24gfHwgZXhwTnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdtaXNzaW5nIGUgYmVmb3JlIGV4cG9uZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJysnIHx8IHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzYXdTaWduID0gdHJ1ZTtcbiAgICAgICAgICAgIGlzTmVnYXRpdmUgPSByZXByZXNlbnRhdGlvbltpbmRleCsrXSA9PT0gJy0nO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNEaWdpdChyZXByZXNlbnRhdGlvbltpbmRleF0pICYmIHJlcHJlc2VudGF0aW9uW2luZGV4XSAhPT0gJy4nKSB7XG4gICAgICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnaScgfHwgcmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnSScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwxMjgoaXNOZWdhdGl2ZSA/IElORl9ORUdBVElWRV9CVUZGRVIgOiBJTkZfUE9TSVRJVkVfQlVGRkVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJ04nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KE5BTl9CVUZGRVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpc0RpZ2l0KHJlcHJlc2VudGF0aW9uW2luZGV4XSkgfHwgcmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnLicpIHtcbiAgICAgICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICcuJykge1xuICAgICAgICAgICAgICAgIGlmIChzYXdSYWRpeClcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ2NvbnRhaW5zIG11bHRpcGxlIHBlcmlvZHMnKTtcbiAgICAgICAgICAgICAgICBzYXdSYWRpeCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobkRpZ2l0c1N0b3JlZCA8IE1BWF9ESUdJVFMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdICE9PSAnMCcgfHwgZm91bmROb25aZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmROb25aZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8gPSBuRGlnaXRzUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3VuZE5vblplcm8gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkaWdpdHNbZGlnaXRzSW5zZXJ0KytdID0gcGFyc2VJbnQocmVwcmVzZW50YXRpb25baW5kZXhdLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIG5EaWdpdHNTdG9yZWQgPSBuRGlnaXRzU3RvcmVkICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmROb25aZXJvKVxuICAgICAgICAgICAgICAgIG5EaWdpdHMgPSBuRGlnaXRzICsgMTtcbiAgICAgICAgICAgIGlmIChzYXdSYWRpeClcbiAgICAgICAgICAgICAgICByYWRpeFBvc2l0aW9uID0gcmFkaXhQb3NpdGlvbiArIDE7XG4gICAgICAgICAgICBuRGlnaXRzUmVhZCA9IG5EaWdpdHNSZWFkICsgMTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYXdSYWRpeCAmJiAhbkRpZ2l0c1JlYWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCcnICsgcmVwcmVzZW50YXRpb24gKyAnIG5vdCBhIHZhbGlkIERlY2ltYWwxMjggc3RyaW5nJyk7XG4gICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICdlJyB8fCByZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICdFJykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByZXByZXNlbnRhdGlvbi5zdWJzdHIoKytpbmRleCkubWF0Y2goRVhQT05FTlRfUkVHRVgpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCB8fCAhbWF0Y2hbMl0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KE5BTl9CVUZGRVIpO1xuICAgICAgICAgICAgZXhwb25lbnQgPSBwYXJzZUludChtYXRjaFswXSwgMTApO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KE5BTl9CVUZGRVIpO1xuICAgICAgICBpZiAoIW5EaWdpdHNTdG9yZWQpIHtcbiAgICAgICAgICAgIGRpZ2l0c1swXSA9IDA7XG4gICAgICAgICAgICBuRGlnaXRzID0gMTtcbiAgICAgICAgICAgIG5EaWdpdHNTdG9yZWQgPSAxO1xuICAgICAgICAgICAgc2lnbmlmaWNhbnREaWdpdHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFzdERpZ2l0ID0gbkRpZ2l0c1N0b3JlZCAtIDE7XG4gICAgICAgICAgICBzaWduaWZpY2FudERpZ2l0cyA9IG5EaWdpdHM7XG4gICAgICAgICAgICBpZiAoc2lnbmlmaWNhbnREaWdpdHMgIT09IDEpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVwcmVzZW50YXRpb25bZmlyc3ROb25aZXJvICsgc2lnbmlmaWNhbnREaWdpdHMgLSAxICsgTnVtYmVyKHNhd1NpZ24pICsgTnVtYmVyKHNhd1JhZGl4KV0gPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FudERpZ2l0cyA9IHNpZ25pZmljYW50RGlnaXRzIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9uZW50IDw9IHJhZGl4UG9zaXRpb24gJiYgcmFkaXhQb3NpdGlvbiA+IGV4cG9uZW50ICsgKDEgPDwgMTQpKSB7XG4gICAgICAgICAgICBleHBvbmVudCA9IEVYUE9ORU5UX01JTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSByYWRpeFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChleHBvbmVudCA+IEVYUE9ORU5UX01BWCkge1xuICAgICAgICAgICAgbGFzdERpZ2l0ID0gbGFzdERpZ2l0ICsgMTtcbiAgICAgICAgICAgIGlmIChsYXN0RGlnaXQgPj0gTUFYX0RJR0lUUykge1xuICAgICAgICAgICAgICAgIGlmIChzaWduaWZpY2FudERpZ2l0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IEVYUE9ORU5UX01BWDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwb25lbnQgPSBleHBvbmVudCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dSb3VuZGluZykge1xuICAgICAgICAgICAgd2hpbGUgKGV4cG9uZW50IDwgRVhQT05FTlRfTUlOIHx8IG5EaWdpdHNTdG9yZWQgPCBuRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3REaWdpdCA9PT0gMCAmJiBzaWduaWZpY2FudERpZ2l0cyA8IG5EaWdpdHNTdG9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NSU47XG4gICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50RGlnaXRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRGlnaXRzU3RvcmVkIDwgbkRpZ2l0cykge1xuICAgICAgICAgICAgICAgICAgICBuRGlnaXRzID0gbkRpZ2l0cyAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RGlnaXQgPSBsYXN0RGlnaXQgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPCBFWFBPTkVOVF9NQVgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBleHBvbmVudCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWdpdHNTdHJpbmcgPSBkaWdpdHMuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWdpdHNTdHJpbmcubWF0Y2goL14wKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NQVg7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdERpZ2l0ICsgMSA8IHNpZ25pZmljYW50RGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZE9mU3RyaW5nID0gbkRpZ2l0c1JlYWQ7XG4gICAgICAgICAgICAgICAgaWYgKHNhd1JhZGl4KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uWmVybyA9IGZpcnN0Tm9uWmVybyArIDE7XG4gICAgICAgICAgICAgICAgICAgIGVuZE9mU3RyaW5nID0gZW5kT2ZTdHJpbmcgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2F3U2lnbikge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8gPSBmaXJzdE5vblplcm8gKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbmRPZlN0cmluZyA9IGVuZE9mU3RyaW5nICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91bmREaWdpdCA9IHBhcnNlSW50KHJlcHJlc2VudGF0aW9uW2ZpcnN0Tm9uWmVybyArIGxhc3REaWdpdCArIDFdLCAxMCk7XG4gICAgICAgICAgICAgICAgbGV0IHJvdW5kQml0ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAocm91bmREaWdpdCA+PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdW5kQml0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdW5kRGlnaXQgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kQml0ID0gZGlnaXRzW2xhc3REaWdpdF0gJSAyID09PSAxID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZmlyc3ROb25aZXJvICsgbGFzdERpZ2l0ICsgMjsgaSA8IGVuZE9mU3RyaW5nOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQocmVwcmVzZW50YXRpb25baV0sIDEwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZEJpdCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm91bmRCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRJZHggPSBsYXN0RGlnaXQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBkSWR4ID49IDA7IGRJZHgtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrZGlnaXRzW2RJZHhdID4gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0c1tkSWR4XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRJZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50IDwgRVhQT05FTlRfTUFYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IGV4cG9uZW50ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0c1tkSWR4XSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwxMjgoaXNOZWdhdGl2ZSA/IElORl9ORUdBVElWRV9CVUZGRVIgOiBJTkZfUE9TSVRJVkVfQlVGRkVSKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGV4cG9uZW50IDwgRVhQT05FTlRfTUlOIHx8IG5EaWdpdHNTdG9yZWQgPCBuRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3REaWdpdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmlmaWNhbnREaWdpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gRVhQT05FTlRfTUlOO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ2V4cG9uZW50IHVuZGVyZmxvdycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobkRpZ2l0c1N0b3JlZCA8IG5EaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW25EaWdpdHMgLSAxICsgTnVtYmVyKHNhd1NpZ24pICsgTnVtYmVyKHNhd1JhZGl4KV0gIT09ICcwJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnREaWdpdHMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdpbmV4YWN0IHJvdW5kaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbkRpZ2l0cyA9IG5EaWdpdHMgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZ2l0c1tsYXN0RGlnaXRdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnaW5leGFjdCByb3VuZGluZycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3REaWdpdCA9IGxhc3REaWdpdCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA8IEVYUE9ORU5UX01BWCkge1xuICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IGV4cG9uZW50ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdvdmVyZmxvdycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0RGlnaXQgKyAxIDwgc2lnbmlmaWNhbnREaWdpdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2F3UmFkaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvID0gZmlyc3ROb25aZXJvICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNhd1NpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvID0gZmlyc3ROb25aZXJvICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91bmREaWdpdCA9IHBhcnNlSW50KHJlcHJlc2VudGF0aW9uW2ZpcnN0Tm9uWmVybyArIGxhc3REaWdpdCArIDFdLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvdW5kRGlnaXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ2luZXhhY3Qgcm91bmRpbmcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gTG9uZy5mcm9tTnVtYmVyKDApO1xuICAgICAgICBzaWduaWZpY2FuZExvdyA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICAgICAgaWYgKHNpZ25pZmljYW50RGlnaXRzID09PSAwKSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuZEhpZ2ggPSBMb25nLmZyb21OdW1iZXIoMCk7XG4gICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXN0RGlnaXQgPCAxNykge1xuICAgICAgICAgICAgbGV0IGRJZHggPSAwO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBMb25nLmZyb21OdW1iZXIoZGlnaXRzW2RJZHgrK10pO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gbmV3IExvbmcoMCwgMCk7XG4gICAgICAgICAgICBmb3IgKDsgZElkeCA8PSBsYXN0RGlnaXQ7IGRJZHgrKykge1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gc2lnbmlmaWNhbmRMb3cubXVsdGlwbHkoTG9uZy5mcm9tTnVtYmVyKDEwKSk7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBzaWduaWZpY2FuZExvdy5hZGQoTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRJZHggPSAwO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4KytdKTtcbiAgICAgICAgICAgIGZvciAoOyBkSWR4IDw9IGxhc3REaWdpdCAtIDE3OyBkSWR4KyspIHtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZEhpZ2ggPSBzaWduaWZpY2FuZEhpZ2gubXVsdGlwbHkoTG9uZy5mcm9tTnVtYmVyKDEwKSk7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gc2lnbmlmaWNhbmRIaWdoLmFkZChMb25nLmZyb21OdW1iZXIoZGlnaXRzW2RJZHhdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeCsrXSk7XG4gICAgICAgICAgICBmb3IgKDsgZElkeCA8PSBsYXN0RGlnaXQ7IGRJZHgrKykge1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gc2lnbmlmaWNhbmRMb3cubXVsdGlwbHkoTG9uZy5mcm9tTnVtYmVyKDEwKSk7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBzaWduaWZpY2FuZExvdy5hZGQoTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25pZmljYW5kID0gbXVsdGlwbHk2NHgyKHNpZ25pZmljYW5kSGlnaCwgTG9uZy5mcm9tU3RyaW5nKCcxMDAwMDAwMDAwMDAwMDAwMDAnKSk7XG4gICAgICAgIHNpZ25pZmljYW5kLmxvdyA9IHNpZ25pZmljYW5kLmxvdy5hZGQoc2lnbmlmaWNhbmRMb3cpO1xuICAgICAgICBpZiAobGVzc1RoYW4oc2lnbmlmaWNhbmQubG93LCBzaWduaWZpY2FuZExvdykpIHtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kLmhpZ2ggPSBzaWduaWZpY2FuZC5oaWdoLmFkZChMb25nLmZyb21OdW1iZXIoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGJpYXNlZEV4cG9uZW50ID0gZXhwb25lbnQgKyBFWFBPTkVOVF9CSUFTO1xuICAgICAgICBjb25zdCBkZWMgPSB7IGxvdzogTG9uZy5mcm9tTnVtYmVyKDApLCBoaWdoOiBMb25nLmZyb21OdW1iZXIoMCkgfTtcbiAgICAgICAgaWYgKHNpZ25pZmljYW5kLmhpZ2guc2hpZnRSaWdodFVuc2lnbmVkKDQ5KS5hbmQoTG9uZy5mcm9tTnVtYmVyKDEpKS5lcXVhbHMoTG9uZy5mcm9tTnVtYmVyKDEpKSkge1xuICAgICAgICAgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihMb25nLmZyb21OdW1iZXIoMHgzKS5zaGlmdExlZnQoNjEpKTtcbiAgICAgICAgICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3IoTG9uZy5mcm9tTnVtYmVyKGJpYXNlZEV4cG9uZW50KS5hbmQoTG9uZy5mcm9tTnVtYmVyKDB4M2ZmZikuc2hpZnRMZWZ0KDQ3KSkpO1xuICAgICAgICAgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihzaWduaWZpY2FuZC5oaWdoLmFuZChMb25nLmZyb21OdW1iZXIoMHg3ZmZmZmZmZmZmZmYpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKExvbmcuZnJvbU51bWJlcihiaWFzZWRFeHBvbmVudCAmIDB4M2ZmZikuc2hpZnRMZWZ0KDQ5KSk7XG4gICAgICAgICAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKHNpZ25pZmljYW5kLmhpZ2guYW5kKExvbmcuZnJvbU51bWJlcigweDFmZmZmZmZmZmZmZmYpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjLmxvdyA9IHNpZ25pZmljYW5kLmxvdztcbiAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3IoTG9uZy5mcm9tU3RyaW5nKCc5MjIzMzcyMDM2ODU0Nzc1ODA4JykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZSgxNik7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gZGVjLmxvdy5sb3cgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5sb3cgPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5sb3cgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cubG93ID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IGRlYy5sb3cuaGlnaCAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMubG93LmhpZ2ggPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5oaWdoID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMubG93LmhpZ2ggPj4gMjQpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gZGVjLmhpZ2gubG93ICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmxvdyA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5sb3cgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmxvdyA+PiAyNCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBkZWMuaGlnaC5oaWdoICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmhpZ2ggPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmhpZ2guaGlnaCA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmhpZ2guaGlnaCA+PiAyNCkgJiAweGZmO1xuICAgICAgICByZXR1cm4gbmV3IERlY2ltYWwxMjgoYnVmZmVyKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBiaWFzZWRfZXhwb25lbnQ7XG4gICAgICAgIGxldCBzaWduaWZpY2FuZF9kaWdpdHMgPSAwO1xuICAgICAgICBjb25zdCBzaWduaWZpY2FuZCA9IG5ldyBBcnJheSgzNik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmlmaWNhbmQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzaWduaWZpY2FuZFtpXSA9IDA7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGxldCBpc196ZXJvID0gZmFsc2U7XG4gICAgICAgIGxldCBzaWduaWZpY2FuZF9tc2I7XG4gICAgICAgIGxldCBzaWduaWZpY2FuZDEyOCA9IHsgcGFydHM6IFswLCAwLCAwLCAwXSB9O1xuICAgICAgICBsZXQgaiwgaztcbiAgICAgICAgY29uc3Qgc3RyaW5nID0gW107XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5ieXRlcztcbiAgICAgICAgY29uc3QgbG93ID0gYnVmZmVyW2luZGV4KytdIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgIGNvbnN0IG1pZGwgPSBidWZmZXJbaW5kZXgrK10gfCAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfCAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgY29uc3QgbWlkaCA9IGJ1ZmZlcltpbmRleCsrXSB8IChidWZmZXJbaW5kZXgrK10gPDwgOCkgfCAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICBjb25zdCBoaWdoID0gYnVmZmVyW2luZGV4KytdIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgZGVjID0ge1xuICAgICAgICAgICAgbG93OiBuZXcgTG9uZyhsb3csIG1pZGwpLFxuICAgICAgICAgICAgaGlnaDogbmV3IExvbmcobWlkaCwgaGlnaClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlYy5oaWdoLmxlc3NUaGFuKExvbmcuWkVSTykpIHtcbiAgICAgICAgICAgIHN0cmluZy5wdXNoKCctJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tYmluYXRpb24gPSAoaGlnaCA+PiAyNikgJiBDT01CSU5BVElPTl9NQVNLO1xuICAgICAgICBpZiAoY29tYmluYXRpb24gPj4gMyA9PT0gMykge1xuICAgICAgICAgICAgaWYgKGNvbWJpbmF0aW9uID09PSBDT01CSU5BVElPTl9JTkZJTklUWSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuam9pbignJykgKyAnSW5maW5pdHknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tYmluYXRpb24gPT09IENPTUJJTkFUSU9OX05BTikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnTmFOJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJpYXNlZF9leHBvbmVudCA9IChoaWdoID4+IDE1KSAmIEVYUE9ORU5UX01BU0s7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRfbXNiID0gMHgwOCArICgoaGlnaCA+PiAxNCkgJiAweDAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kX21zYiA9IChoaWdoID4+IDE0KSAmIDB4MDc7XG4gICAgICAgICAgICBiaWFzZWRfZXhwb25lbnQgPSAoaGlnaCA+PiAxNykgJiBFWFBPTkVOVF9NQVNLO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cG9uZW50ID0gYmlhc2VkX2V4cG9uZW50IC0gRVhQT05FTlRfQklBUztcbiAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbMF0gPSAoaGlnaCAmIDB4M2ZmZikgKyAoKHNpZ25pZmljYW5kX21zYiAmIDB4ZikgPDwgMTQpO1xuICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1sxXSA9IG1pZGg7XG4gICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzJdID0gbWlkbDtcbiAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbM10gPSBsb3c7XG4gICAgICAgIGlmIChzaWduaWZpY2FuZDEyOC5wYXJ0c1swXSA9PT0gMCAmJlxuICAgICAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbMV0gPT09IDAgJiZcbiAgICAgICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzJdID09PSAwICYmXG4gICAgICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1szXSA9PT0gMCkge1xuICAgICAgICAgICAgaXNfemVybyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAzOyBrID49IDA7IGstLSkge1xuICAgICAgICAgICAgICAgIGxldCBsZWFzdF9kaWdpdHMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRpdmlkZXUxMjgoc2lnbmlmaWNhbmQxMjgpO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kMTI4ID0gcmVzdWx0LnF1b3RpZW50O1xuICAgICAgICAgICAgICAgIGxlYXN0X2RpZ2l0cyA9IHJlc3VsdC5yZW0ubG93O1xuICAgICAgICAgICAgICAgIGlmICghbGVhc3RfZGlnaXRzKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSA4OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FuZFtrICogOSArIGpdID0gbGVhc3RfZGlnaXRzICUgMTA7XG4gICAgICAgICAgICAgICAgICAgIGxlYXN0X2RpZ2l0cyA9IE1hdGguZmxvb3IobGVhc3RfZGlnaXRzIC8gMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfemVybykge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRfZGlnaXRzID0gMTtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kW2luZGV4XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuZF9kaWdpdHMgPSAzNjtcbiAgICAgICAgICAgIHdoaWxlICghc2lnbmlmaWNhbmRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRfZGlnaXRzID0gc2lnbmlmaWNhbmRfZGlnaXRzIC0gMTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2llbnRpZmljX2V4cG9uZW50ID0gc2lnbmlmaWNhbmRfZGlnaXRzIC0gMSArIGV4cG9uZW50O1xuICAgICAgICBpZiAoc2NpZW50aWZpY19leHBvbmVudCA+PSAzNCB8fCBzY2llbnRpZmljX2V4cG9uZW50IDw9IC03IHx8IGV4cG9uZW50ID4gMCkge1xuICAgICAgICAgICAgaWYgKHNpZ25pZmljYW5kX2RpZ2l0cyA+IDM0KSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7MH1gKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPiAwKVxuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgRSske2V4cG9uZW50fWApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4cG9uZW50IDwgMClcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYEUke2V4cG9uZW50fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzaWduaWZpY2FuZFtpbmRleCsrXX1gKTtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kX2RpZ2l0cyA9IHNpZ25pZmljYW5kX2RpZ2l0cyAtIDE7XG4gICAgICAgICAgICBpZiAoc2lnbmlmaWNhbmRfZGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goJy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmlmaWNhbmRfZGlnaXRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzaWduaWZpY2FuZFtpbmRleCsrXX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZy5wdXNoKCdFJyk7XG4gICAgICAgICAgICBpZiAoc2NpZW50aWZpY19leHBvbmVudCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgKyR7c2NpZW50aWZpY19leHBvbmVudH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGAke3NjaWVudGlmaWNfZXhwb25lbnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXhwb25lbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmlmaWNhbmRfZGlnaXRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2lnbmlmaWNhbmRbaW5kZXgrK119YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhZGl4X3Bvc2l0aW9uID0gc2lnbmlmaWNhbmRfZGlnaXRzICsgZXhwb25lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHJhZGl4X3Bvc2l0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhZGl4X3Bvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGAke3NpZ25pZmljYW5kW2luZGV4KytdfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaCgnMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcucHVzaCgnLicpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyYWRpeF9wb3NpdGlvbisrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaCgnMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25pZmljYW5kX2RpZ2l0cyAtIE1hdGgubWF4KHJhZGl4X3Bvc2l0aW9uIC0gMSwgMCk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzaWduaWZpY2FuZFtpbmRleCsrXX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZy5qb2luKCcnKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyAkbnVtYmVyRGVjaW1hbDogdGhpcy50b1N0cmluZygpIH07XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4geyAkbnVtYmVyRGVjaW1hbDogdGhpcy50b1N0cmluZygpIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICByZXR1cm4gRGVjaW1hbDEyOC5mcm9tU3RyaW5nKGRvYy4kbnVtYmVyRGVjaW1hbCk7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gYG5ldyBEZWNpbWFsMTI4KFwiJHt0aGlzLnRvU3RyaW5nKCl9XCIpYDtcbiAgICB9XG59XG5cbmNsYXNzIERvdWJsZSBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdEb3VibGUnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSArdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZyhyYWRpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMubGVnYWN5IHx8IChvcHRpb25zLnJlbGF4ZWQgJiYgaXNGaW5pdGUodGhpcy52YWx1ZSkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5pcyhNYXRoLnNpZ24odGhpcy52YWx1ZSksIC0wKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJG51bWJlckRvdWJsZTogJy0wLjAnIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRudW1iZXJEb3VibGU6IE51bWJlci5pc0ludGVnZXIodGhpcy52YWx1ZSkgPyB0aGlzLnZhbHVlLnRvRml4ZWQoMSkgOiB0aGlzLnZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRvdWJsZVZhbHVlID0gcGFyc2VGbG9hdChkb2MuJG51bWJlckRvdWJsZSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMucmVsYXhlZCA/IGRvdWJsZVZhbHVlIDogbmV3IERvdWJsZShkb3VibGVWYWx1ZSk7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICBjb25zdCBlSlNPTiA9IHRoaXMudG9FeHRlbmRlZEpTT04oKTtcbiAgICAgICAgcmV0dXJuIGBuZXcgRG91YmxlKCR7ZUpTT04uJG51bWJlckRvdWJsZX0pYDtcbiAgICB9XG59XG5cbmNsYXNzIEludDMyIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0ludDMyJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gK3ZhbHVlIHwgMDtcbiAgICB9XG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKHJhZGl4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy5yZWxheGVkIHx8IG9wdGlvbnMubGVnYWN5KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyAkbnVtYmVySW50OiB0aGlzLnZhbHVlLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMucmVsYXhlZCA/IHBhcnNlSW50KGRvYy4kbnVtYmVySW50LCAxMCkgOiBuZXcgSW50MzIoZG9jLiRudW1iZXJJbnQpO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3BlY3QoKTtcbiAgICB9XG4gICAgaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIGBuZXcgSW50MzIoJHt0aGlzLnZhbHVlT2YoKX0pYDtcbiAgICB9XG59XG5cbmNsYXNzIE1heEtleSBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdNYXhLZXknO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgJG1heEtleTogMSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXhLZXkoKTtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiAnbmV3IE1heEtleSgpJztcbiAgICB9XG59XG5cbmNsYXNzIE1pbktleSBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdNaW5LZXknO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgJG1pbktleTogMSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNaW5LZXkoKTtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiAnbmV3IE1pbktleSgpJztcbiAgICB9XG59XG5cbmNvbnN0IGNoZWNrRm9ySGV4UmVnRXhwID0gbmV3IFJlZ0V4cCgnXlswLTlhLWZBLUZdezI0fSQnKTtcbmxldCBQUk9DRVNTX1VOSVFVRSA9IG51bGw7XG5jb25zdCBrSWQgPSBTeW1ib2woJ2lkJyk7XG5jbGFzcyBPYmplY3RJZCBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdPYmplY3RJZCc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0SWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgbGV0IHdvcmtpbmdJZDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dElkID09PSAnb2JqZWN0JyAmJiBpbnB1dElkICYmICdpZCcgaW4gaW5wdXRJZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dElkLmlkICE9PSAnc3RyaW5nJyAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KGlucHV0SWQuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQXJndW1lbnQgcGFzc2VkIGluIG11c3QgaGF2ZSBhbiBpZCB0aGF0IGlzIG9mIHR5cGUgc3RyaW5nIG9yIEJ1ZmZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCd0b0hleFN0cmluZycgaW4gaW5wdXRJZCAmJiB0eXBlb2YgaW5wdXRJZC50b0hleFN0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHdvcmtpbmdJZCA9IEJ5dGVVdGlscy5mcm9tSGV4KGlucHV0SWQudG9IZXhTdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3b3JraW5nSWQgPSBpbnB1dElkLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd29ya2luZ0lkID0gaW5wdXRJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya2luZ0lkID09IG51bGwgfHwgdHlwZW9mIHdvcmtpbmdJZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXNba0lkXSA9IE9iamVjdElkLmdlbmVyYXRlKHR5cGVvZiB3b3JraW5nSWQgPT09ICdudW1iZXInID8gd29ya2luZ0lkIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcod29ya2luZ0lkKSAmJiB3b3JraW5nSWQuYnl0ZUxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgICAgIHRoaXNba0lkXSA9IEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZSh3b3JraW5nSWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3b3JraW5nSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAod29ya2luZ0lkLmxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IEJ5dGVVdGlscy5mcm9tVVRGOCh3b3JraW5nSWQpO1xuICAgICAgICAgICAgICAgIGlmIChieXRlcy5ieXRlTGVuZ3RoID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2tJZF0gPSBieXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0FyZ3VtZW50IHBhc3NlZCBpbiBtdXN0IGJlIGEgc3RyaW5nIG9mIDEyIGJ5dGVzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod29ya2luZ0lkLmxlbmd0aCA9PT0gMjQgJiYgY2hlY2tGb3JIZXhSZWdFeHAudGVzdCh3b3JraW5nSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trSWRdID0gQnl0ZVV0aWxzLmZyb21IZXgod29ya2luZ0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0FyZ3VtZW50IHBhc3NlZCBpbiBtdXN0IGJlIGEgc3RyaW5nIG9mIDEyIGJ5dGVzIG9yIGEgc3RyaW5nIG9mIDI0IGhleCBjaGFyYWN0ZXJzIG9yIGFuIGludGVnZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0FyZ3VtZW50IHBhc3NlZCBpbiBkb2VzIG5vdCBtYXRjaCB0aGUgYWNjZXB0ZWQgdHlwZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0SWQuY2FjaGVIZXhTdHJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX19pZCA9IEJ5dGVVdGlscy50b0hleCh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tJZF07XG4gICAgfVxuICAgIHNldCBpZCh2YWx1ZSkge1xuICAgICAgICB0aGlzW2tJZF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKE9iamVjdElkLmNhY2hlSGV4U3RyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9faWQgPSBCeXRlVXRpbHMudG9IZXgodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSGV4U3RyaW5nKCkge1xuICAgICAgICBpZiAoT2JqZWN0SWQuY2FjaGVIZXhTdHJpbmcgJiYgdGhpcy5fX2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2lkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleFN0cmluZyA9IEJ5dGVVdGlscy50b0hleCh0aGlzLmlkKTtcbiAgICAgICAgaWYgKE9iamVjdElkLmNhY2hlSGV4U3RyaW5nICYmICF0aGlzLl9faWQpIHtcbiAgICAgICAgICAgIHRoaXMuX19pZCA9IGhleFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4U3RyaW5nO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW5jKCkge1xuICAgICAgICByZXR1cm4gKE9iamVjdElkLmluZGV4ID0gKE9iamVjdElkLmluZGV4ICsgMSkgJSAweGZmZmZmZik7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZSh0aW1lKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRpbWUpIHtcbiAgICAgICAgICAgIHRpbWUgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmMgPSBPYmplY3RJZC5nZXRJbmMoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKDEyKTtcbiAgICAgICAgQlNPTkRhdGFWaWV3LmZyb21VaW50OEFycmF5KGJ1ZmZlcikuc2V0VWludDMyKDAsIHRpbWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKFBST0NFU1NfVU5JUVVFID09PSBudWxsKSB7XG4gICAgICAgICAgICBQUk9DRVNTX1VOSVFVRSA9IEJ5dGVVdGlscy5yYW5kb21CeXRlcyg1KTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJbNF0gPSBQUk9DRVNTX1VOSVFVRVswXTtcbiAgICAgICAgYnVmZmVyWzVdID0gUFJPQ0VTU19VTklRVUVbMV07XG4gICAgICAgIGJ1ZmZlcls2XSA9IFBST0NFU1NfVU5JUVVFWzJdO1xuICAgICAgICBidWZmZXJbN10gPSBQUk9DRVNTX1VOSVFVRVszXTtcbiAgICAgICAgYnVmZmVyWzhdID0gUFJPQ0VTU19VTklRVUVbNF07XG4gICAgICAgIGJ1ZmZlclsxMV0gPSBpbmMgJiAweGZmO1xuICAgICAgICBidWZmZXJbMTBdID0gKGluYyA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcls5XSA9IChpbmMgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgdG9TdHJpbmcoZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JylcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5pZCk7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2hleCcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0hleFN0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcklkKSB7XG4gICAgICAgIGlmIChvdGhlcklkID09PSB1bmRlZmluZWQgfHwgb3RoZXJJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlcklkIGluc3RhbmNlb2YgT2JqZWN0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2tJZF1bMTFdID09PSBvdGhlcklkW2tJZF1bMTFdICYmIEJ5dGVVdGlscy5lcXVhbHModGhpc1trSWRdLCBvdGhlcklkW2tJZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3RoZXJJZCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIE9iamVjdElkLmlzVmFsaWQob3RoZXJJZCkgJiZcbiAgICAgICAgICAgIG90aGVySWQubGVuZ3RoID09PSAxMiAmJlxuICAgICAgICAgICAgaXNVaW50OEFycmF5KHRoaXMuaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLmVxdWFscyh0aGlzLmlkLCBCeXRlVXRpbHMuZnJvbUlTTzg4NTkxKG90aGVySWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90aGVySWQgPT09ICdzdHJpbmcnICYmIE9iamVjdElkLmlzVmFsaWQob3RoZXJJZCkgJiYgb3RoZXJJZC5sZW5ndGggPT09IDI0KSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXJJZC50b0xvd2VyQ2FzZSgpID09PSB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdGhlcklkID09PSAnc3RyaW5nJyAmJiBPYmplY3RJZC5pc1ZhbGlkKG90aGVySWQpICYmIG90aGVySWQubGVuZ3RoID09PSAxMikge1xuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy5lcXVhbHMoQnl0ZVV0aWxzLmZyb21VVEY4KG90aGVySWQpLCB0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90aGVySWQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAndG9IZXhTdHJpbmcnIGluIG90aGVySWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvdGhlcklkLnRvSGV4U3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcklkU3RyaW5nID0gb3RoZXJJZC50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdGhpc0lkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG90aGVySWRTdHJpbmcgPT09ICdzdHJpbmcnICYmIG90aGVySWRTdHJpbmcudG9Mb3dlckNhc2UoKSA9PT0gdGhpc0lkU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0VGltZXN0YW1wKCkge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB0aW1lID0gQlNPTkRhdGFWaWV3LmZyb21VaW50OEFycmF5KHRoaXMuaWQpLmdldFVpbnQzMigwLCBmYWxzZSk7XG4gICAgICAgIHRpbWVzdGFtcC5zZXRUaW1lKE1hdGguZmxvb3IodGltZSkgKiAxMDAwKTtcbiAgICAgICAgcmV0dXJuIHRpbWVzdGFtcDtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZVBrKCkge1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdElkKCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tVGltZSh0aW1lKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgQlNPTkRhdGFWaWV3LmZyb21VaW50OEFycmF5KGJ1ZmZlcikuc2V0VWludDMyKDAsIHRpbWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChidWZmZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUhleFN0cmluZyhoZXhTdHJpbmcpIHtcbiAgICAgICAgaWYgKGhleFN0cmluZz8ubGVuZ3RoICE9PSAyNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignaGV4IHN0cmluZyBtdXN0IGJlIDI0IGNoYXJhY3RlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE9iamVjdElkKEJ5dGVVdGlscy5mcm9tSGV4KGhleFN0cmluZykpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUJhc2U2NChiYXNlNjQpIHtcbiAgICAgICAgaWYgKGJhc2U2ND8ubGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFzZTY0IHN0cmluZyBtdXN0IGJlIDE2IGNoYXJhY3RlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE9iamVjdElkKEJ5dGVVdGlscy5mcm9tQmFzZTY0KGJhc2U2NCkpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZChpZCkge1xuICAgICAgICBpZiAoaWQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBPYmplY3RJZChpZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIGlmICh0aGlzLnRvSGV4U3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHsgJG9pZDogdGhpcy50b0hleFN0cmluZygpIH07XG4gICAgICAgIHJldHVybiB7ICRvaWQ6IHRoaXMudG9TdHJpbmcoJ2hleCcpIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdElkKGRvYy4kb2lkKTtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiBgbmV3IE9iamVjdElkKFwiJHt0aGlzLnRvSGV4U3RyaW5nKCl9XCIpYDtcbiAgICB9XG59XG5PYmplY3RJZC5pbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmKTtcblxuZnVuY3Rpb24gaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKG9iamVjdCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQpIHtcbiAgICBsZXQgdG90YWxMZW5ndGggPSA0ICsgMTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjYWxjdWxhdGVFbGVtZW50KGkudG9TdHJpbmcoKSwgb2JqZWN0W2ldLCBzZXJpYWxpemVGdW5jdGlvbnMsIHRydWUsIGlnbm9yZVVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Py50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC50b0JTT04oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjYWxjdWxhdGVFbGVtZW50KGtleSwgb2JqZWN0W2tleV0sIHNlcmlhbGl6ZUZ1bmN0aW9ucywgZmFsc2UsIGlnbm9yZVVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsTGVuZ3RoO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRWxlbWVudChuYW1lLCB2YWx1ZSwgc2VyaWFsaXplRnVuY3Rpb25zID0gZmFsc2UsIGlzQXJyYXkgPSBmYWxzZSwgaWdub3JlVW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlPy50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0JTT04oKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiAxICsgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSArIDQgKyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgodmFsdWUpICsgMTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSA+PSBKU19JTlRfTUlOICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgPD0gSlNfSU5UX01BWCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBCU09OX0lOVDMyX01JTiAmJiB2YWx1ZSA8PSBCU09OX0lOVDMyX01BWCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg0ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoOCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgaWYgKGlzQXJyYXkgfHwgIWlnbm9yZVVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICgxICsgMSk7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS5fYnNvbnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgdmFsdWVbU3ltYm9sLmZvcignQEBtZGIuYnNvbi52ZXJzaW9uJyldICE9PSBCU09OX01BSk9SX1ZFUlNJT04pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTlZlcnNpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdNaW5LZXknIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ01heEtleScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdPYmplY3RJZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICgxMiArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICAgICAgICAgICAgIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDEgKyA0ICsgMSkgKyB2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0xvbmcnIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUuX2Jzb250eXBlID09PSAnRG91YmxlJyB8fFxuICAgICAgICAgICAgICAgIHZhbHVlLl9ic29udHlwZSA9PT0gJ1RpbWVzdGFtcCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEZWNpbWFsMTI4Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDE2ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdDb2RlJykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zY29wZSAhPSBudWxsICYmIE9iamVjdC5rZXlzKHZhbHVlLnNjb3BlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgNCArXG4gICAgICAgICAgICAgICAgICAgICAgICBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgodmFsdWUuY29kZS50b1N0cmluZygpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsQ2FsY3VsYXRlT2JqZWN0U2l6ZSh2YWx1ZS5zY29wZSwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLmNvZGUudG9TdHJpbmcoKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQmluYXJ5Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpbmFyeSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChiaW5hcnkuc3ViX3R5cGUgPT09IEJpbmFyeS5TVUJUWVBFX0JZVEVfQVJSQVkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChiaW5hcnkucG9zaXRpb24gKyAxICsgNCArIDEgKyA0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoYmluYXJ5LnBvc2l0aW9uICsgMSArIDQgKyAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnU3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS52YWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgICA0ICtcbiAgICAgICAgICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnREJSZWYnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJlZF92YWx1ZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgJHJlZjogdmFsdWUuY29sbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgJGlkOiB2YWx1ZS5vaWRcbiAgICAgICAgICAgICAgICB9LCB2YWx1ZS5maWVsZHMpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5kYiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyZWRfdmFsdWVzWyckZGInXSA9IHZhbHVlLmRiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKG9yZGVyZWRfdmFsdWVzLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS5zb3VyY2UpICtcbiAgICAgICAgICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZS5nbG9iYWwgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAodmFsdWUuaWdub3JlQ2FzZSA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZS5tdWx0aWxpbmUgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05SZWdFeHAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS5wYXR0ZXJuKSArXG4gICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgodmFsdWUub3B0aW9ucykgK1xuICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsQ2FsY3VsYXRlT2JqZWN0U2l6ZSh2YWx1ZSwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQpICtcbiAgICAgICAgICAgICAgICAgICAgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIGlmIChzZXJpYWxpemVGdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgNCArXG4gICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS50b1N0cmluZygpKSArXG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYWxwaGFiZXRpemUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnJykuc29ydCgpLmpvaW4oJycpO1xufVxuY2xhc3MgQlNPTlJlZ0V4cCBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdCU09OUmVnRXhwJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IocGF0dGVybiwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBhbHBoYWJldGl6ZShvcHRpb25zID8/ICcnKTtcbiAgICAgICAgaWYgKHRoaXMucGF0dGVybi5pbmRleE9mKCdcXHgwMCcpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQlNPTiBSZWdleCBwYXR0ZXJucyBjYW5ub3QgY29udGFpbiBudWxsIGJ5dGVzLCBmb3VuZDogJHtKU09OLnN0cmluZ2lmeSh0aGlzLnBhdHRlcm4pfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5kZXhPZignXFx4MDAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYEJTT04gUmVnZXggb3B0aW9ucyBjYW5ub3QgY29udGFpbiBudWxsIGJ5dGVzLCBmb3VuZDogJHtKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMpfWApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnNbaV0gPT09ICdpJyB8fFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9PT0gJ20nIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID09PSAneCcgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPT09ICdsJyB8fFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9PT0gJ3MnIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID09PSAndScpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBvcHRpb24gWyR7dGhpcy5vcHRpb25zW2ldfV0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucyA/IG9wdGlvbnMuc3BsaXQoJycpLnNvcnQoKS5qb2luKCcnKSA6ICcnO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy5sZWdhY3kpIHtcbiAgICAgICAgICAgIHJldHVybiB7ICRyZWdleDogdGhpcy5wYXR0ZXJuLCAkb3B0aW9uczogdGhpcy5vcHRpb25zIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJHJlZ3VsYXJFeHByZXNzaW9uOiB7IHBhdHRlcm46IHRoaXMucGF0dGVybiwgb3B0aW9uczogdGhpcy5vcHRpb25zIH0gfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIGlmICgnJHJlZ2V4JyBpbiBkb2MpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jLiRyZWdleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jLiRyZWdleC5fYnNvbnR5cGUgPT09ICdCU09OUmVnRXhwJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQlNPTlJlZ0V4cChkb2MuJHJlZ2V4LCBCU09OUmVnRXhwLnBhcnNlT3B0aW9ucyhkb2MuJG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJyRyZWd1bGFyRXhwcmVzc2lvbicgaW4gZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJTT05SZWdFeHAoZG9jLiRyZWd1bGFyRXhwcmVzc2lvbi5wYXR0ZXJuLCBCU09OUmVnRXhwLnBhcnNlT3B0aW9ucyhkb2MuJHJlZ3VsYXJFeHByZXNzaW9uLm9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBVbmV4cGVjdGVkIEJTT05SZWdFeHAgRUpTT04gb2JqZWN0IGZvcm06ICR7SlNPTi5zdHJpbmdpZnkoZG9jKX1gKTtcbiAgICB9XG4gICAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiBgbmV3IEJTT05SZWdFeHAoJHtKU09OLnN0cmluZ2lmeSh0aGlzLnBhdHRlcm4pfSwgJHtKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMpfSlgO1xuICAgIH1cbn1cblxuY2xhc3MgQlNPTlN5bWJvbCBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdCU09OU3ltYm9sJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gYG5ldyBCU09OU3ltYm9sKFwiJHt0aGlzLnZhbHVlfVwiKWA7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4geyAkc3ltYm9sOiB0aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IEJTT05TeW1ib2woZG9jLiRzeW1ib2wpO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3BlY3QoKTtcbiAgICB9XG59XG5cbmNvbnN0IExvbmdXaXRob3V0T3ZlcnJpZGVzQ2xhc3MgPSBMb25nO1xuY2xhc3MgVGltZXN0YW1wIGV4dGVuZHMgTG9uZ1dpdGhvdXRPdmVycmlkZXNDbGFzcyB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdUaW1lc3RhbXAnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihsb3cpIHtcbiAgICAgICAgaWYgKGxvdyA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdXBlcigwLCAwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgc3VwZXIobG93LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChMb25nLmlzTG9uZyhsb3cpKSB7XG4gICAgICAgICAgICBzdXBlcihsb3cubG93LCBsb3cuaGlnaCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvdyA9PT0gJ29iamVjdCcgJiYgJ3QnIGluIGxvdyAmJiAnaScgaW4gbG93KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvdy50ICE9PSAnbnVtYmVyJyAmJiAodHlwZW9mIGxvdy50ICE9PSAnb2JqZWN0JyB8fCBsb3cudC5fYnNvbnR5cGUgIT09ICdJbnQzMicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIHQgYXMgYSBudW1iZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG93LmkgIT09ICdudW1iZXInICYmICh0eXBlb2YgbG93LmkgIT09ICdvYmplY3QnIHx8IGxvdy5pLl9ic29udHlwZSAhPT0gJ0ludDMyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdUaW1lc3RhbXAgY29uc3RydWN0ZWQgZnJvbSB7IHQsIGkgfSBtdXN0IHByb3ZpZGUgaSBhcyBhIG51bWJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdCA9IE51bWJlcihsb3cudCk7XG4gICAgICAgICAgICBjb25zdCBpID0gTnVtYmVyKGxvdy5pKTtcbiAgICAgICAgICAgIGlmICh0IDwgMCB8fCBOdW1iZXIuaXNOYU4odCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdUaW1lc3RhbXAgY29uc3RydWN0ZWQgZnJvbSB7IHQsIGkgfSBtdXN0IHByb3ZpZGUgYSBwb3NpdGl2ZSB0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgTnVtYmVyLmlzTmFOKGkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIGEgcG9zaXRpdmUgaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIHQgZXF1YWwgb3IgbGVzcyB0aGFuIHVpbnQzMiBtYXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1RpbWVzdGFtcCBjb25zdHJ1Y3RlZCBmcm9tIHsgdCwgaSB9IG11c3QgcHJvdmlkZSBpIGVxdWFsIG9yIGxlc3MgdGhhbiB1aW50MzIgbWF4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdXBlcihpLCB0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0EgVGltZXN0YW1wIGNhbiBvbmx5IGJlIGNvbnN0cnVjdGVkIHdpdGg6IGJpZ2ludCwgTG9uZywgb3IgeyB0OiBudW1iZXI7IGk6IG51bWJlciB9Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJHRpbWVzdGFtcDogdGhpcy50b1N0cmluZygpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKExvbmcuZnJvbUludCh2YWx1ZSwgdHJ1ZSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU51bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChMb25nLmZyb21OdW1iZXIodmFsdWUsIHRydWUpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHsgaTogbG93Qml0cywgdDogaGlnaEJpdHMgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHN0ciwgb3B0UmFkaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoTG9uZy5mcm9tU3RyaW5nKHN0ciwgdHJ1ZSwgb3B0UmFkaXgpKTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiB7ICR0aW1lc3RhbXA6IHsgdDogdGhpcy5oaWdoID4+PiAwLCBpOiB0aGlzLmxvdyA+Pj4gMCB9IH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICBjb25zdCBpID0gTG9uZy5pc0xvbmcoZG9jLiR0aW1lc3RhbXAuaSlcbiAgICAgICAgICAgID8gZG9jLiR0aW1lc3RhbXAuaS5nZXRMb3dCaXRzVW5zaWduZWQoKVxuICAgICAgICAgICAgOiBkb2MuJHRpbWVzdGFtcC5pO1xuICAgICAgICBjb25zdCB0ID0gTG9uZy5pc0xvbmcoZG9jLiR0aW1lc3RhbXAudClcbiAgICAgICAgICAgID8gZG9jLiR0aW1lc3RhbXAudC5nZXRMb3dCaXRzVW5zaWduZWQoKVxuICAgICAgICAgICAgOiBkb2MuJHRpbWVzdGFtcC50O1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh7IHQsIGkgfSk7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gYG5ldyBUaW1lc3RhbXAoeyB0OiAke3RoaXMuZ2V0SGlnaEJpdHMoKX0sIGk6ICR7dGhpcy5nZXRMb3dCaXRzKCl9IH0pYDtcbiAgICB9XG59XG5UaW1lc3RhbXAuTUFYX1ZBTFVFID0gTG9uZy5NQVhfVU5TSUdORURfVkFMVUU7XG5cbmNvbnN0IEZJUlNUX0JJVCA9IDB4ODA7XG5jb25zdCBGSVJTVF9UV09fQklUUyA9IDB4YzA7XG5jb25zdCBGSVJTVF9USFJFRV9CSVRTID0gMHhlMDtcbmNvbnN0IEZJUlNUX0ZPVVJfQklUUyA9IDB4ZjA7XG5jb25zdCBGSVJTVF9GSVZFX0JJVFMgPSAweGY4O1xuY29uc3QgVFdPX0JJVF9DSEFSID0gMHhjMDtcbmNvbnN0IFRIUkVFX0JJVF9DSEFSID0gMHhlMDtcbmNvbnN0IEZPVVJfQklUX0NIQVIgPSAweGYwO1xuY29uc3QgQ09OVElOVUlOR19DSEFSID0gMHg4MDtcbmZ1bmN0aW9uIHZhbGlkYXRlVXRmOChieXRlcywgc3RhcnQsIGVuZCkge1xuICAgIGxldCBjb250aW51YXRpb24gPSAwO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBieXRlc1tpXTtcbiAgICAgICAgaWYgKGNvbnRpbnVhdGlvbikge1xuICAgICAgICAgICAgaWYgKChieXRlICYgRklSU1RfVFdPX0JJVFMpICE9PSBDT05USU5VSU5HX0NIQVIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51YXRpb24gLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlICYgRklSU1RfQklUKSB7XG4gICAgICAgICAgICBpZiAoKGJ5dGUgJiBGSVJTVF9USFJFRV9CSVRTKSA9PT0gVFdPX0JJVF9DSEFSKSB7XG4gICAgICAgICAgICAgICAgY29udGludWF0aW9uID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChieXRlICYgRklSU1RfRk9VUl9CSVRTKSA9PT0gVEhSRUVfQklUX0NIQVIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51YXRpb24gPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGJ5dGUgJiBGSVJTVF9GSVZFX0JJVFMpID09PSBGT1VSX0JJVF9DSEFSKSB7XG4gICAgICAgICAgICAgICAgY29udGludWF0aW9uID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIWNvbnRpbnVhdGlvbjtcbn1cblxuY29uc3QgSlNfSU5UX01BWF9MT05HID0gTG9uZy5mcm9tTnVtYmVyKEpTX0lOVF9NQVgpO1xuY29uc3QgSlNfSU5UX01JTl9MT05HID0gTG9uZy5mcm9tTnVtYmVyKEpTX0lOVF9NSU4pO1xuZnVuY3Rpb24gaW50ZXJuYWxEZXNlcmlhbGl6ZShidWZmZXIsIG9wdGlvbnMsIGlzQXJyYXkpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA9PSBudWxsID8ge30gOiBvcHRpb25zO1xuICAgIGNvbnN0IGluZGV4ID0gb3B0aW9ucyAmJiBvcHRpb25zLmluZGV4ID8gb3B0aW9ucy5pbmRleCA6IDA7XG4gICAgY29uc3Qgc2l6ZSA9IGJ1ZmZlcltpbmRleF0gfFxuICAgICAgICAoYnVmZmVyW2luZGV4ICsgMV0gPDwgOCkgfFxuICAgICAgICAoYnVmZmVyW2luZGV4ICsgMl0gPDwgMTYpIHxcbiAgICAgICAgKGJ1ZmZlcltpbmRleCArIDNdIDw8IDI0KTtcbiAgICBpZiAoc2l6ZSA8IDUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgYnNvbiBzaXplIG11c3QgYmUgPj0gNSwgaXMgJHtzaXplfWApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGxvd09iamVjdFNtYWxsZXJUaGFuQnVmZmVyU2l6ZSAmJiBidWZmZXIubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBidWZmZXIgbGVuZ3RoICR7YnVmZmVyLmxlbmd0aH0gbXVzdCBiZSA+PSBic29uIHNpemUgJHtzaXplfWApO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dPYmplY3RTbWFsbGVyVGhhbkJ1ZmZlclNpemUgJiYgYnVmZmVyLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBidWZmZXIgbGVuZ3RoICR7YnVmZmVyLmxlbmd0aH0gbXVzdCA9PT0gYnNvbiBzaXplICR7c2l6ZX1gKTtcbiAgICB9XG4gICAgaWYgKHNpemUgKyBpbmRleCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYChic29uIHNpemUgJHtzaXplfSArIG9wdGlvbnMuaW5kZXggJHtpbmRleH0gbXVzdCBiZSA8PSBidWZmZXIgbGVuZ3RoICR7YnVmZmVyLmJ5dGVMZW5ndGh9KWApO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyW2luZGV4ICsgc2l6ZSAtIDFdICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoXCJPbmUgb2JqZWN0LCBzaXplZCBjb3JyZWN0bHksIHdpdGggYSBzcG90IGZvciBhbiBFT08sIGJ1dCB0aGUgRU9PIGlzbid0IDB4MDBcIik7XG4gICAgfVxuICAgIHJldHVybiBkZXNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGluZGV4LCBvcHRpb25zLCBpc0FycmF5KTtcbn1cbmNvbnN0IGFsbG93ZWREQlJlZktleXMgPSAvXlxcJHJlZiR8XlxcJGlkJHxeXFwkZGIkLztcbmZ1bmN0aW9uIGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgaW5kZXgsIG9wdGlvbnMsIGlzQXJyYXkgPSBmYWxzZSkge1xuICAgIGNvbnN0IGZpZWxkc0FzUmF3ID0gb3B0aW9uc1snZmllbGRzQXNSYXcnXSA9PSBudWxsID8gbnVsbCA6IG9wdGlvbnNbJ2ZpZWxkc0FzUmF3J107XG4gICAgY29uc3QgcmF3ID0gb3B0aW9uc1sncmF3J10gPT0gbnVsbCA/IGZhbHNlIDogb3B0aW9uc1sncmF3J107XG4gICAgY29uc3QgYnNvblJlZ0V4cCA9IHR5cGVvZiBvcHRpb25zWydic29uUmVnRXhwJ10gPT09ICdib29sZWFuJyA/IG9wdGlvbnNbJ2Jzb25SZWdFeHAnXSA6IGZhbHNlO1xuICAgIGNvbnN0IHByb21vdGVCdWZmZXJzID0gb3B0aW9ucy5wcm9tb3RlQnVmZmVycyA/PyBmYWxzZTtcbiAgICBjb25zdCBwcm9tb3RlTG9uZ3MgPSBvcHRpb25zLnByb21vdGVMb25ncyA/PyB0cnVlO1xuICAgIGNvbnN0IHByb21vdGVWYWx1ZXMgPSBvcHRpb25zLnByb21vdGVWYWx1ZXMgPz8gdHJ1ZTtcbiAgICBjb25zdCB1c2VCaWdJbnQ2NCA9IG9wdGlvbnMudXNlQmlnSW50NjQgPz8gZmFsc2U7XG4gICAgaWYgKHVzZUJpZ0ludDY0ICYmICFwcm9tb3RlVmFsdWVzKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ011c3QgZWl0aGVyIHJlcXVlc3QgYmlnaW50IG9yIExvbmcgZm9yIGludDY0IGRlc2VyaWFsaXphdGlvbicpO1xuICAgIH1cbiAgICBpZiAodXNlQmlnSW50NjQgJiYgIXByb21vdGVMb25ncykge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdNdXN0IGVpdGhlciByZXF1ZXN0IGJpZ2ludCBvciBMb25nIGZvciBpbnQ2NCBkZXNlcmlhbGl6YXRpb24nKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IG9wdGlvbnMudmFsaWRhdGlvbiA9PSBudWxsID8geyB1dGY4OiB0cnVlIH0gOiBvcHRpb25zLnZhbGlkYXRpb247XG4gICAgbGV0IGdsb2JhbFVURlZhbGlkYXRpb24gPSB0cnVlO1xuICAgIGxldCB2YWxpZGF0aW9uU2V0dGluZztcbiAgICBjb25zdCB1dGY4S2V5c1NldCA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1dGY4VmFsaWRhdGVkS2V5cyA9IHZhbGlkYXRpb24udXRmODtcbiAgICBpZiAodHlwZW9mIHV0ZjhWYWxpZGF0ZWRLZXlzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdmFsaWRhdGlvblNldHRpbmcgPSB1dGY4VmFsaWRhdGVkS2V5cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsb2JhbFVURlZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdXRmOFZhbGlkYXRpb25WYWx1ZXMgPSBPYmplY3Qua2V5cyh1dGY4VmFsaWRhdGVkS2V5cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGY4VmFsaWRhdGVkS2V5c1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHV0ZjhWYWxpZGF0aW9uVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVVRGLTggdmFsaWRhdGlvbiBzZXR0aW5nIGNhbm5vdCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdXRmOFZhbGlkYXRpb25WYWx1ZXNbMF0gIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignSW52YWxpZCBVVEYtOCB2YWxpZGF0aW9uIG9wdGlvbiwgbXVzdCBzcGVjaWZ5IGJvb2xlYW4gdmFsdWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGlvblNldHRpbmcgPSB1dGY4VmFsaWRhdGlvblZhbHVlc1swXTtcbiAgICAgICAgaWYgKCF1dGY4VmFsaWRhdGlvblZhbHVlcy5ldmVyeShpdGVtID0+IGl0ZW0gPT09IHZhbGlkYXRpb25TZXR0aW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignSW52YWxpZCBVVEYtOCB2YWxpZGF0aW9uIG9wdGlvbiAtIGtleXMgbXVzdCBiZSBhbGwgdHJ1ZSBvciBhbGwgZmFsc2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWdsb2JhbFVURlZhbGlkYXRpb24pIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModXRmOFZhbGlkYXRlZEtleXMpKSB7XG4gICAgICAgICAgICB1dGY4S2V5c1NldC5hZGQoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCA1KVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb3JydXB0IGJzb24gbWVzc2FnZSA8IDUgYnl0ZXMgbG9uZycpO1xuICAgIGNvbnN0IHNpemUgPSBidWZmZXJbaW5kZXgrK10gfCAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfCAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICBpZiAoc2l6ZSA8IDUgfHwgc2l6ZSA+IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvcnJ1cHQgYnNvbiBtZXNzYWdlJyk7XG4gICAgY29uc3Qgb2JqZWN0ID0gaXNBcnJheSA/IFtdIDoge307XG4gICAgbGV0IGFycmF5SW5kZXggPSAwO1xuICAgIGNvbnN0IGRvbmUgPSBmYWxzZTtcbiAgICBsZXQgaXNQb3NzaWJsZURCUmVmID0gaXNBcnJheSA/IGZhbHNlIDogbnVsbDtcbiAgICBjb25zdCBkYXRhdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9IGJ1ZmZlcltpbmRleCsrXTtcbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBpID0gaW5kZXg7XG4gICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGlzQXJyYXkgPyBhcnJheUluZGV4KysgOiBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGkpO1xuICAgICAgICBsZXQgc2hvdWxkVmFsaWRhdGVLZXkgPSB0cnVlO1xuICAgICAgICBpZiAoZ2xvYmFsVVRGVmFsaWRhdGlvbiB8fCB1dGY4S2V5c1NldC5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHNob3VsZFZhbGlkYXRlS2V5ID0gdmFsaWRhdGlvblNldHRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaG91bGRWYWxpZGF0ZUtleSA9ICF2YWxpZGF0aW9uU2V0dGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQb3NzaWJsZURCUmVmICE9PSBmYWxzZSAmJiBuYW1lWzBdID09PSAnJCcpIHtcbiAgICAgICAgICAgIGlzUG9zc2libGVEQlJlZiA9IGFsbG93ZWREQlJlZktleXMudGVzdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGluZGV4ID0gaSArIDE7XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX1NUUklORykge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nU2l6ZSA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgaWYgKHN0cmluZ1NpemUgPD0gMCB8fFxuICAgICAgICAgICAgICAgIHN0cmluZ1NpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXggfHxcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXggKyBzdHJpbmdTaXplIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGdldFZhbGlkYXRlZFN0cmluZyhidWZmZXIsIGluZGV4LCBpbmRleCArIHN0cmluZ1NpemUgLSAxLCBzaG91bGRWYWxpZGF0ZUtleSk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgc3RyaW5nU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX09JRCkge1xuICAgICAgICAgICAgY29uc3Qgb2lkID0gQnl0ZVV0aWxzLmFsbG9jYXRlKDEyKTtcbiAgICAgICAgICAgIG9pZC5zZXQoYnVmZmVyLnN1YmFycmF5KGluZGV4LCBpbmRleCArIDEyKSk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBPYmplY3RJZChvaWQpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDEyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfSU5UICYmIHByb21vdGVWYWx1ZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbnQzMihidWZmZXJbaW5kZXgrK10gfCAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfCAoYnVmZmVyW2luZGV4KytdIDw8IDI0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9JTlQpIHtcbiAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX05VTUJFUiAmJiBwcm9tb3RlVmFsdWVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgRG91YmxlKGRhdGF2aWV3LmdldEZsb2F0NjQoaW5kZXgsIHRydWUpKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyA4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfTlVNQkVSKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGRhdGF2aWV3LmdldEZsb2F0NjQoaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9EQVRFKSB7XG4gICAgICAgICAgICBjb25zdCBsb3dCaXRzID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBjb25zdCBoaWdoQml0cyA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cykudG9OdW1iZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9CT09MRUFOKSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2luZGV4XSAhPT0gMCAmJiBidWZmZXJbaW5kZXhdICE9PSAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2lsbGVnYWwgYm9vbGVhbiB0eXBlIHZhbHVlJyk7XG4gICAgICAgICAgICB2YWx1ZSA9IGJ1ZmZlcltpbmRleCsrXSA9PT0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX09CSkVDVCkge1xuICAgICAgICAgICAgY29uc3QgX2luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RTaXplID0gYnVmZmVyW2luZGV4XSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4ICsgMl0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4ICsgM10gPDwgMjQpO1xuICAgICAgICAgICAgaWYgKG9iamVjdFNpemUgPD0gMCB8fCBvYmplY3RTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2JhZCBlbWJlZGRlZCBkb2N1bWVudCBsZW5ndGggaW4gYnNvbicpO1xuICAgICAgICAgICAgaWYgKHJhdykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYnVmZmVyLnNsaWNlKGluZGV4LCBpbmRleCArIG9iamVjdFNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG9iamVjdE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmICghZ2xvYmFsVVRGVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RPcHRpb25zID0geyAuLi5vcHRpb25zLCB2YWxpZGF0aW9uOiB7IHV0Zjg6IHNob3VsZFZhbGlkYXRlS2V5IH0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZXNlcmlhbGl6ZU9iamVjdChidWZmZXIsIF9pbmRleCwgb2JqZWN0T3B0aW9ucywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIG9iamVjdFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9BUlJBWSkge1xuICAgICAgICAgICAgY29uc3QgX2luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RTaXplID0gYnVmZmVyW2luZGV4XSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4ICsgMl0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4ICsgM10gPDwgMjQpO1xuICAgICAgICAgICAgbGV0IGFycmF5T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBzdG9wSW5kZXggPSBpbmRleCArIG9iamVjdFNpemU7XG4gICAgICAgICAgICBpZiAoZmllbGRzQXNSYXcgJiYgZmllbGRzQXNSYXdbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheU9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHJhdzogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnbG9iYWxVVEZWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlPcHRpb25zID0geyAuLi5hcnJheU9wdGlvbnMsIHZhbGlkYXRpb246IHsgdXRmODogc2hvdWxkVmFsaWRhdGVLZXkgfSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBkZXNlcmlhbGl6ZU9iamVjdChidWZmZXIsIF9pbmRleCwgYXJyYXlPcHRpb25zLCB0cnVlKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBvYmplY3RTaXplO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcltpbmRleCAtIDFdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2ludmFsaWQgYXJyYXkgdGVybWluYXRvciBieXRlJyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHN0b3BJbmRleClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb3JydXB0ZWQgYXJyYXkgYnNvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX05VTEwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0xPTkcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGF2aWV3ID0gQlNPTkRhdGFWaWV3LmZyb21VaW50OEFycmF5KGJ1ZmZlci5zdWJhcnJheShpbmRleCwgaW5kZXggKyA4KSk7XG4gICAgICAgICAgICBjb25zdCBsb3dCaXRzID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBjb25zdCBoaWdoQml0cyA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgY29uc3QgbG9uZyA9IG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbiAgICAgICAgICAgIGlmICh1c2VCaWdJbnQ2NCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZGF0YXZpZXcuZ2V0QmlnSW50NjQoMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9tb3RlTG9uZ3MgJiYgcHJvbW90ZVZhbHVlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgbG9uZy5sZXNzVGhhbk9yRXF1YWwoSlNfSU5UX01BWF9MT05HKSAmJiBsb25nLmdyZWF0ZXJUaGFuT3JFcXVhbChKU19JTlRfTUlOX0xPTkcpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGxvbmcudG9OdW1iZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBsb25nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsb25nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfREVDSU1BTDEyOCkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBCeXRlVXRpbHMuYWxsb2NhdGUoMTYpO1xuICAgICAgICAgICAgYnl0ZXMuc2V0KGJ1ZmZlci5zdWJhcnJheShpbmRleCwgaW5kZXggKyAxNiksIDApO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDE2O1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGVjaW1hbDEyOChieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9CSU5BUlkpIHtcbiAgICAgICAgICAgIGxldCBiaW5hcnlTaXplID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBjb25zdCB0b3RhbEJpbmFyeVNpemUgPSBiaW5hcnlTaXplO1xuICAgICAgICAgICAgY29uc3Qgc3ViVHlwZSA9IGJ1ZmZlcltpbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdOZWdhdGl2ZSBiaW5hcnkgdHlwZSBlbGVtZW50IHNpemUgZm91bmQnKTtcbiAgICAgICAgICAgIGlmIChiaW5hcnlTaXplID4gYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmluYXJ5IHR5cGUgc2l6ZSBsYXJnZXIgdGhhbiBkb2N1bWVudCBzaXplJyk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyWydzbGljZSddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ViVHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSkge1xuICAgICAgICAgICAgICAgICAgICBiaW5hcnlTaXplID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdOZWdhdGl2ZSBiaW5hcnkgdHlwZSBlbGVtZW50IHNpemUgZm91bmQgZm9yIHN1YnR5cGUgMHgwMicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA+IHRvdGFsQmluYXJ5U2l6ZSAtIDQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgdHlwZSB3aXRoIHN1YnR5cGUgMHgwMiBjb250YWlucyB0b28gbG9uZyBiaW5hcnkgc2l6ZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA8IHRvdGFsQmluYXJ5U2l6ZSAtIDQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgdHlwZSB3aXRoIHN1YnR5cGUgMHgwMiBjb250YWlucyB0b28gc2hvcnQgYmluYXJ5IHNpemUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb21vdGVCdWZmZXJzICYmIHByb21vdGVWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyLnNsaWNlKGluZGV4LCBpbmRleCArIGJpbmFyeVNpemUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEJpbmFyeShidWZmZXIuc2xpY2UoaW5kZXgsIGluZGV4ICsgYmluYXJ5U2l6ZSksIHN1YlR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViVHlwZSA9PT0gQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEX05FVyAmJiBVVUlELmlzVmFsaWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvVVVJRCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2J1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShiaW5hcnlTaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViVHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSkge1xuICAgICAgICAgICAgICAgICAgICBiaW5hcnlTaXplID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdOZWdhdGl2ZSBiaW5hcnkgdHlwZSBlbGVtZW50IHNpemUgZm91bmQgZm9yIHN1YnR5cGUgMHgwMicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA+IHRvdGFsQmluYXJ5U2l6ZSAtIDQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgdHlwZSB3aXRoIHN1YnR5cGUgMHgwMiBjb250YWlucyB0b28gbG9uZyBiaW5hcnkgc2l6ZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA8IHRvdGFsQmluYXJ5U2l6ZSAtIDQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgdHlwZSB3aXRoIHN1YnR5cGUgMHgwMiBjb250YWlucyB0b28gc2hvcnQgYmluYXJ5IHNpemUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJpbmFyeVNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBfYnVmZmVyW2ldID0gYnVmZmVyW2luZGV4ICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9tb3RlQnVmZmVycyAmJiBwcm9tb3RlVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2J1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEJpbmFyeShidWZmZXIuc2xpY2UoaW5kZXgsIGluZGV4ICsgYmluYXJ5U2l6ZSksIHN1YlR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViVHlwZSA9PT0gQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEX05FVyAmJiBVVUlELmlzVmFsaWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvVVVJRCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIGJpbmFyeVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9SRUdFWFAgJiYgYnNvblJlZ0V4cCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaSk7XG4gICAgICAgICAgICBpbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgaSA9IGluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlcltpXSAhPT0gMHgwMCAmJiBpIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmFkIEJTT04gRG9jdW1lbnQ6IGlsbGVnYWwgQ1N0cmluZycpO1xuICAgICAgICAgICAgY29uc3QgcmVnRXhwT3B0aW9ucyA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaSk7XG4gICAgICAgICAgICBpbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uc0FycmF5ID0gbmV3IEFycmF5KHJlZ0V4cE9wdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByZWdFeHBPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChyZWdFeHBPcHRpb25zW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc0FycmF5W2ldID0gJ20nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc0FycmF5W2ldID0gJ2cnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2knOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc0FycmF5W2ldID0gJ2knO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgUmVnRXhwKHNvdXJjZSwgb3B0aW9uc0FycmF5LmpvaW4oJycpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX1JFR0VYUCAmJiBic29uUmVnRXhwID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpID0gaW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoYnVmZmVyW2ldICE9PSAweDAwICYmIGkgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj0gYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCYWQgQlNPTiBEb2N1bWVudDogaWxsZWdhbCBDU3RyaW5nJyk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGkpO1xuICAgICAgICAgICAgaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZ0V4cE9wdGlvbnMgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGkpO1xuICAgICAgICAgICAgaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEJTT05SZWdFeHAoc291cmNlLCByZWdFeHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX1NZTUJPTCkge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nU2l6ZSA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgaWYgKHN0cmluZ1NpemUgPD0gMCB8fFxuICAgICAgICAgICAgICAgIHN0cmluZ1NpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXggfHxcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXggKyBzdHJpbmdTaXplIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzeW1ib2wgPSBnZXRWYWxpZGF0ZWRTdHJpbmcoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSwgc2hvdWxkVmFsaWRhdGVLZXkpO1xuICAgICAgICAgICAgdmFsdWUgPSBwcm9tb3RlVmFsdWVzID8gc3ltYm9sIDogbmV3IEJTT05TeW1ib2woc3ltYm9sKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBzdHJpbmdTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfVElNRVNUQU1QKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gYnVmZmVyW2luZGV4KytdICtcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXgrK10gKiAoMSA8PCA4KSArXG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdICogKDEgPDwgMTYpICtcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXgrK10gKiAoMSA8PCAyNCk7XG4gICAgICAgICAgICBjb25zdCB0ID0gYnVmZmVyW2luZGV4KytdICtcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXgrK10gKiAoMSA8PCA4KSArXG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdICogKDEgPDwgMTYpICtcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXgrK10gKiAoMSA8PCAyNCk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBUaW1lc3RhbXAoeyBpLCB0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfTUlOX0tFWSkge1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgTWluS2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9NQVhfS0VZKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBNYXhLZXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0NPREUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1NpemUgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdTaXplIDw9IDAgfHxcbiAgICAgICAgICAgICAgICBzdHJpbmdTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4IHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIHN0cmluZyBsZW5ndGggaW4gYnNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25TdHJpbmcgPSBnZXRWYWxpZGF0ZWRTdHJpbmcoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSwgc2hvdWxkVmFsaWRhdGVLZXkpO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQ29kZShmdW5jdGlvblN0cmluZyk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgc3RyaW5nU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0NPREVfV19TQ09QRSkge1xuICAgICAgICAgICAgY29uc3QgdG90YWxTaXplID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBpZiAodG90YWxTaXplIDwgNCArIDQgKyA0ICsgMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvZGVfd19zY29wZSB0b3RhbCBzaXplIHNob3J0ZXIgbWluaW11bSBleHBlY3RlZCBsZW5ndGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1NpemUgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdTaXplIDw9IDAgfHxcbiAgICAgICAgICAgICAgICBzdHJpbmdTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4IHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIHN0cmluZyBsZW5ndGggaW4gYnNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25TdHJpbmcgPSBnZXRWYWxpZGF0ZWRTdHJpbmcoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSwgc2hvdWxkVmFsaWRhdGVLZXkpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIHN0cmluZ1NpemU7XG4gICAgICAgICAgICBjb25zdCBfaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFNpemUgPSBidWZmZXJbaW5kZXhdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4ICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAyXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAzXSA8PCAyNCk7XG4gICAgICAgICAgICBjb25zdCBzY29wZU9iamVjdCA9IGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgX2luZGV4LCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgb2JqZWN0U2l6ZTtcbiAgICAgICAgICAgIGlmICh0b3RhbFNpemUgPCA0ICsgNCArIG9iamVjdFNpemUgKyBzdHJpbmdTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29kZV93X3Njb3BlIHRvdGFsIHNpemUgaXMgdG9vIHNob3J0LCB0cnVuY2F0aW5nIHNjb3BlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG90YWxTaXplID4gNCArIDQgKyBvYmplY3RTaXplICsgc3RyaW5nU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvZGVfd19zY29wZSB0b3RhbCBzaXplIGlzIHRvbyBsb25nLCBjbGlwcyBvdXRlciBkb2N1bWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQ29kZShmdW5jdGlvblN0cmluZywgc2NvcGVPYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfREJQT0lOVEVSKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdTaXplID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nU2l6ZSA8PSAwIHx8XG4gICAgICAgICAgICAgICAgc3RyaW5nU2l6ZSA+IGJ1ZmZlci5sZW5ndGggLSBpbmRleCB8fFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCArIHN0cmluZ1NpemUgLSAxXSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbiAhPSBudWxsICYmIHZhbGlkYXRpb24udXRmOCkge1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVVdGY4KGJ1ZmZlciwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0ludmFsaWQgVVRGLTggc3RyaW5nIGluIEJTT04gZG9jdW1lbnQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIHN0cmluZ1NpemU7XG4gICAgICAgICAgICBjb25zdCBvaWRCdWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGUoMTIpO1xuICAgICAgICAgICAgb2lkQnVmZmVyLnNldChidWZmZXIuc3ViYXJyYXkoaW5kZXgsIGluZGV4ICsgMTIpLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IG9pZCA9IG5ldyBPYmplY3RJZChvaWRCdWZmZXIpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDEyO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgREJSZWYobmFtZXNwYWNlLCBvaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgRGV0ZWN0ZWQgdW5rbm93biBCU09OIHR5cGUgJHtlbGVtZW50VHlwZS50b1N0cmluZygxNil9IGZvciBmaWVsZG5hbWUgXCIke25hbWV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmplY3RbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2l6ZSAhPT0gaW5kZXggLSBzdGFydEluZGV4KSB7XG4gICAgICAgIGlmIChpc0FycmF5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29ycnVwdCBhcnJheSBic29uJyk7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvcnJ1cHQgb2JqZWN0IGJzb24nKTtcbiAgICB9XG4gICAgaWYgKCFpc1Bvc3NpYmxlREJSZWYpXG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgaWYgKGlzREJSZWZMaWtlKG9iamVjdCkpIHtcbiAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIG9iamVjdCk7XG4gICAgICAgIGRlbGV0ZSBjb3B5LiRyZWY7XG4gICAgICAgIGRlbGV0ZSBjb3B5LiRpZDtcbiAgICAgICAgZGVsZXRlIGNvcHkuJGRiO1xuICAgICAgICByZXR1cm4gbmV3IERCUmVmKG9iamVjdC4kcmVmLCBvYmplY3QuJGlkLCBvYmplY3QuJGRiLCBjb3B5KTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGdldFZhbGlkYXRlZFN0cmluZyhidWZmZXIsIHN0YXJ0LCBlbmQsIHNob3VsZFZhbGlkYXRlVXRmOCkge1xuICAgIGNvbnN0IHZhbHVlID0gQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzaG91bGRWYWxpZGF0ZVV0ZjgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmNoYXJDb2RlQXQoaSkgPT09IDB4ZmZmZCkge1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVVdGY4KGJ1ZmZlciwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignSW52YWxpZCBVVEYtOCBzdHJpbmcgaW4gQlNPTiBkb2N1bWVudCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmNvbnN0IHJlZ2V4cCA9IC9cXHgwMC87XG5jb25zdCBpZ25vcmVLZXlzID0gbmV3IFNldChbJyRkYicsICckcmVmJywgJyRpZCcsICckY2x1c3RlclRpbWUnXSk7XG5mdW5jdGlvbiBzZXJpYWxpemVTdHJpbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9TVFJJTkc7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgKyAxO1xuICAgIGJ1ZmZlcltpbmRleCAtIDFdID0gMDtcbiAgICBjb25zdCBzaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgdmFsdWUsIGluZGV4ICsgNCk7XG4gICAgYnVmZmVyW2luZGV4ICsgM10gPSAoKHNpemUgKyAxKSA+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCArIDJdID0gKChzaXplICsgMSkgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAxXSA9ICgoc2l6ZSArIDEpID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXhdID0gKHNpemUgKyAxKSAmIDB4ZmY7XG4gICAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuY29uc3QgTlVNQkVSX1NQQUNFID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig4KSwgMCwgOCk7XG5jb25zdCBGT1VSX0JZVEVfVklFV19PTl9OVU1CRVIgPSBuZXcgVWludDhBcnJheShOVU1CRVJfU1BBQ0UuYnVmZmVyLCAwLCA0KTtcbmNvbnN0IEVJR0hUX0JZVEVfVklFV19PTl9OVU1CRVIgPSBuZXcgVWludDhBcnJheShOVU1CRVJfU1BBQ0UuYnVmZmVyLCAwLCA4KTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZU51bWJlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgY29uc3QgaXNOZWdhdGl2ZVplcm8gPSBPYmplY3QuaXModmFsdWUsIC0wKTtcbiAgICBjb25zdCB0eXBlID0gIWlzTmVnYXRpdmVaZXJvICYmXG4gICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSAmJlxuICAgICAgICB2YWx1ZSA8PSBCU09OX0lOVDMyX01BWCAmJlxuICAgICAgICB2YWx1ZSA+PSBCU09OX0lOVDMyX01JTlxuICAgICAgICA/IEJTT05fREFUQV9JTlRcbiAgICAgICAgOiBCU09OX0RBVEFfTlVNQkVSO1xuICAgIGlmICh0eXBlID09PSBCU09OX0RBVEFfSU5UKSB7XG4gICAgICAgIE5VTUJFUl9TUEFDRS5zZXRJbnQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBOVU1CRVJfU1BBQ0Uuc2V0RmxvYXQ2NCgwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gdHlwZSA9PT0gQlNPTl9EQVRBX0lOVCA/IEZPVVJfQllURV9WSUVXX09OX05VTUJFUiA6IEVJR0hUX0JZVEVfVklFV19PTl9OVU1CRVI7XG4gICAgYnVmZmVyW2luZGV4KytdID0gdHlwZTtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAweDAwO1xuICAgIGJ1ZmZlci5zZXQoYnl0ZXMsIGluZGV4KTtcbiAgICBpbmRleCArPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJpZ0ludChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0xPTkc7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCArPSBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIE5VTUJFUl9TUEFDRS5zZXRCaWdJbnQ2NCgwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgYnVmZmVyLnNldChFSUdIVF9CWVRFX1ZJRVdfT05fTlVNQkVSLCBpbmRleCk7XG4gICAgaW5kZXggKz0gRUlHSFRfQllURV9WSUVXX09OX05VTUJFUi5ieXRlTGVuZ3RoO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIF8sIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX05VTEw7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVCb29sZWFuKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQk9PTEVBTjtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IHZhbHVlID8gMSA6IDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRGF0ZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0RBVEU7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBjb25zdCBkYXRlSW5NaWxpcyA9IExvbmcuZnJvbU51bWJlcih2YWx1ZS5nZXRUaW1lKCkpO1xuICAgIGNvbnN0IGxvd0JpdHMgPSBkYXRlSW5NaWxpcy5nZXRMb3dCaXRzKCk7XG4gICAgY29uc3QgaGlnaEJpdHMgPSBkYXRlSW5NaWxpcy5nZXRIaWdoQml0cygpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IGxvd0JpdHMgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChsb3dCaXRzID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAobG93Qml0cyA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChsb3dCaXRzID4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gaGlnaEJpdHMgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChoaWdoQml0cyA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGhpZ2hCaXRzID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGhpZ2hCaXRzID4+IDI0KSAmIDB4ZmY7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfUkVHRVhQO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgaWYgKHZhbHVlLnNvdXJjZSAmJiB2YWx1ZS5zb3VyY2UubWF0Y2gocmVnZXhwKSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3ZhbHVlICcgKyB2YWx1ZS5zb3VyY2UgKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgIH1cbiAgICBpbmRleCA9IGluZGV4ICsgQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgdmFsdWUuc291cmNlLCBpbmRleCk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICBpZiAodmFsdWUuaWdub3JlQ2FzZSlcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gMHg2OTtcbiAgICBpZiAodmFsdWUuZ2xvYmFsKVxuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAweDczO1xuICAgIGlmICh2YWx1ZS5tdWx0aWxpbmUpXG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4NmQ7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVCU09OUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfUkVHRVhQO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgaWYgKHZhbHVlLnBhdHRlcm4ubWF0Y2gocmVnZXhwKSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3BhdHRlcm4gJyArIHZhbHVlLnBhdHRlcm4gKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgIH1cbiAgICBpbmRleCA9IGluZGV4ICsgQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgdmFsdWUucGF0dGVybiwgaW5kZXgpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgY29uc3Qgc29ydGVkT3B0aW9ucyA9IHZhbHVlLm9wdGlvbnMuc3BsaXQoJycpLnNvcnQoKS5qb2luKCcnKTtcbiAgICBpbmRleCA9IGluZGV4ICsgQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgc29ydGVkT3B0aW9ucywgaW5kZXgpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTWluTWF4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX05VTEw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScpIHtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX01JTl9LRVk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfTUFYX0tFWTtcbiAgICB9XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3RJZChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX09JRDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGlmIChpc1VpbnQ4QXJyYXkodmFsdWUuaWQpKSB7XG4gICAgICAgIGJ1ZmZlci5zZXQodmFsdWUuaWQuc3ViYXJyYXkoMCwgMTIpLCBpbmRleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdvYmplY3QgWycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnXSBpcyBub3QgYSB2YWxpZCBPYmplY3RJZCcpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXggKyAxMjtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0JJTkFSWTtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IHNpemUgPSB2YWx1ZS5sZW5ndGg7XG4gICAgYnVmZmVyW2luZGV4KytdID0gc2l6ZSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFQ7XG4gICAgYnVmZmVyLnNldCh2YWx1ZSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBzaXplO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCkge1xuICAgIGlmIChwYXRoLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQ2Fubm90IGNvbnZlcnQgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEJTT04nKTtcbiAgICB9XG4gICAgcGF0aC5hZGQodmFsdWUpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gQlNPTl9EQVRBX0FSUkFZIDogQlNPTl9EQVRBX09CSkVDVDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIHZhbHVlLCBjaGVja0tleXMsIGluZGV4LCBkZXB0aCArIDEsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICBwYXRoLmRlbGV0ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIGVuZEluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0RFQ0lNQUwxMjg7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBidWZmZXIuc2V0KHZhbHVlLmJ5dGVzLnN1YmFycmF5KDAsIDE2KSwgaW5kZXgpO1xuICAgIHJldHVybiBpbmRleCArIDE2O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTG9uZyhidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID1cbiAgICAgICAgdmFsdWUuX2Jzb250eXBlID09PSAnTG9uZycgPyBCU09OX0RBVEFfTE9ORyA6IEJTT05fREFUQV9USU1FU1RBTVA7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBjb25zdCBsb3dCaXRzID0gdmFsdWUuZ2V0TG93Qml0cygpO1xuICAgIGNvbnN0IGhpZ2hCaXRzID0gdmFsdWUuZ2V0SGlnaEJpdHMoKTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBsb3dCaXRzICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAobG93Qml0cyA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGxvd0JpdHMgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAobG93Qml0cyA+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IGhpZ2hCaXRzICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoaGlnaEJpdHMgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChoaWdoQml0cyA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChoaWdoQml0cyA+PiAyNCkgJiAweGZmO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUludDMyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfSU5UO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgYnVmZmVyW2luZGV4KytdID0gdmFsdWUgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9ICh2YWx1ZSA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHZhbHVlID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHZhbHVlID4+IDI0KSAmIDB4ZmY7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRG91YmxlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfTlVNQkVSO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgTlVNQkVSX1NQQUNFLnNldEZsb2F0NjQoMCwgdmFsdWUudmFsdWUsIHRydWUpO1xuICAgIGJ1ZmZlci5zZXQoRUlHSFRfQllURV9WSUVXX09OX05VTUJFUiwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyA4O1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZ1bmN0aW9uKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQ09ERTtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICBjb25zdCBzaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgZnVuY3Rpb25TdHJpbmcsIGluZGV4ICsgNCkgKyAxO1xuICAgIGJ1ZmZlcltpbmRleF0gPSBzaXplICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAxXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAyXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4ICsgM10gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIGluZGV4ID0gaW5kZXggKyA0ICsgc2l6ZSAtIDE7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVDb2RlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cyA9IGZhbHNlLCBkZXB0aCA9IDAsIHNlcmlhbGl6ZUZ1bmN0aW9ucyA9IGZhbHNlLCBpZ25vcmVVbmRlZmluZWQgPSB0cnVlLCBwYXRoKSB7XG4gICAgaWYgKHZhbHVlLnNjb3BlICYmIHR5cGVvZiB2YWx1ZS5zY29wZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0NPREVfV19TQ09QRTtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBjb25zdCBmdW5jdGlvblN0cmluZyA9IHZhbHVlLmNvZGU7XG4gICAgICAgIGluZGV4ID0gaW5kZXggKyA0O1xuICAgICAgICBjb25zdCBjb2RlU2l6ZSA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGZ1bmN0aW9uU3RyaW5nLCBpbmRleCArIDQpICsgMTtcbiAgICAgICAgYnVmZmVyW2luZGV4XSA9IGNvZGVTaXplICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4ICsgMV0gPSAoY29kZVNpemUgPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyAyXSA9IChjb2RlU2l6ZSA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyAzXSA9IChjb2RlU2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyA0ICsgY29kZVNpemUgLSAxXSA9IDA7XG4gICAgICAgIGluZGV4ID0gaW5kZXggKyBjb2RlU2l6ZSArIDQ7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIHZhbHVlLnNjb3BlLCBjaGVja0tleXMsIGluZGV4LCBkZXB0aCArIDEsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgaW5kZXggPSBlbmRJbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IGVuZEluZGV4IC0gc3RhcnRJbmRleDtcbiAgICAgICAgYnVmZmVyW3N0YXJ0SW5kZXgrK10gPSB0b3RhbFNpemUgJiAweGZmO1xuICAgICAgICBidWZmZXJbc3RhcnRJbmRleCsrXSA9ICh0b3RhbFNpemUgPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbc3RhcnRJbmRleCsrXSA9ICh0b3RhbFNpemUgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW3N0YXJ0SW5kZXgrK10gPSAodG90YWxTaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQ09ERTtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgICAgICBjb25zdCBmdW5jdGlvblN0cmluZyA9IHZhbHVlLmNvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGZ1bmN0aW9uU3RyaW5nLCBpbmRleCArIDQpICsgMTtcbiAgICAgICAgYnVmZmVyW2luZGV4XSA9IHNpemUgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyAxXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4ICsgMl0gPSAoc2l6ZSA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyAzXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGluZGV4ID0gaW5kZXggKyA0ICsgc2l6ZSAtIDE7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJpbmFyeShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0JJTkFSWTtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGRhdGEgPSB2YWx1ZS5idWZmZXI7XG4gICAgbGV0IHNpemUgPSB2YWx1ZS5wb3NpdGlvbjtcbiAgICBpZiAodmFsdWUuc3ViX3R5cGUgPT09IEJpbmFyeS5TVUJUWVBFX0JZVEVfQVJSQVkpXG4gICAgICAgIHNpemUgPSBzaXplICsgNDtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBzaXplICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IHZhbHVlLnN1Yl90eXBlO1xuICAgIGlmICh2YWx1ZS5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSkge1xuICAgICAgICBzaXplID0gc2l6ZSAtIDQ7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IHNpemUgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgfVxuICAgIGJ1ZmZlci5zZXQoZGF0YSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyB2YWx1ZS5wb3NpdGlvbjtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVTeW1ib2woYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9TWU1CT0w7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBjb25zdCBzaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgdmFsdWUudmFsdWUsIGluZGV4ICsgNCkgKyAxO1xuICAgIGJ1ZmZlcltpbmRleF0gPSBzaXplICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAxXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAyXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4ICsgM10gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIGluZGV4ID0gaW5kZXggKyA0ICsgc2l6ZSAtIDE7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVEQlJlZihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBwYXRoKSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX09CSkVDVDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgbGV0IG91dHB1dCA9IHtcbiAgICAgICAgJHJlZjogdmFsdWUuY29sbGVjdGlvbiB8fCB2YWx1ZS5uYW1lc3BhY2UsXG4gICAgICAgICRpZDogdmFsdWUub2lkXG4gICAgfTtcbiAgICBpZiAodmFsdWUuZGIgIT0gbnVsbCkge1xuICAgICAgICBvdXRwdXQuJGRiID0gdmFsdWUuZGI7XG4gICAgfVxuICAgIG91dHB1dCA9IE9iamVjdC5hc3NpZ24ob3V0cHV0LCB2YWx1ZS5maWVsZHMpO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIG91dHB1dCwgZmFsc2UsIGluZGV4LCBkZXB0aCArIDEsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgdHJ1ZSwgcGF0aCk7XG4gICAgY29uc3Qgc2l6ZSA9IGVuZEluZGV4IC0gc3RhcnRJbmRleDtcbiAgICBidWZmZXJbc3RhcnRJbmRleCsrXSA9IHNpemUgJiAweGZmO1xuICAgIGJ1ZmZlcltzdGFydEluZGV4KytdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltzdGFydEluZGV4KytdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbc3RhcnRJbmRleCsrXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgcmV0dXJuIGVuZEluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplSW50byhidWZmZXIsIG9iamVjdCwgY2hlY2tLZXlzLCBzdGFydGluZ0luZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgYnVmZmVyWzBdID0gMHgwNTtcbiAgICAgICAgICAgIGJ1ZmZlclsxXSA9IDB4MDA7XG4gICAgICAgICAgICBidWZmZXJbMl0gPSAweDAwO1xuICAgICAgICAgICAgYnVmZmVyWzNdID0gMHgwMDtcbiAgICAgICAgICAgIGJ1ZmZlcls0XSA9IDB4MDA7XG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdzZXJpYWxpemUgZG9lcyBub3Qgc3VwcG9ydCBhbiBhcnJheSBhcyB0aGUgcm9vdCBpbnB1dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignc2VyaWFsaXplIGRvZXMgbm90IHN1cHBvcnQgbm9uLW9iamVjdCBhcyB0aGUgcm9vdCBpbnB1dCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdfYnNvbnR5cGUnIGluIG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0Ll9ic29udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYEJTT04gdHlwZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYXMgYSBkb2N1bWVudGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0ZShvYmplY3QpIHx8XG4gICAgICAgICAgICBpc1JlZ0V4cChvYmplY3QpIHx8XG4gICAgICAgICAgICBpc1VpbnQ4QXJyYXkob2JqZWN0KSB8fFxuICAgICAgICAgICAgaXNBbnlBcnJheUJ1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBkYXRlLCByZWdleHAsIHR5cGVkYXJyYXksIGFuZCBhcnJheWJ1ZmZlciBjYW5ub3QgYmUgQlNPTiBkb2N1bWVudHNgKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBwYXRoLmFkZChvYmplY3QpO1xuICAgIGxldCBpbmRleCA9IHN0YXJ0aW5nSW5kZXggKyA0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2l9YDtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWU/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9CU09OKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3RyaW5nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVtYmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQmlnSW50KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJvb2xlYW4oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGF0ZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVsbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJ1ZmZlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5fYnNvbnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZVtTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OVmVyc2lvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdPYmplY3RJZCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdElkKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnRGVjaW1hbDEyOCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURlY2ltYWwxMjgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdMb25nJyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdUaW1lc3RhbXAnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVMb25nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnRG91YmxlJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRG91YmxlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHNlcmlhbGl6ZUZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRnVuY3Rpb24oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdDb2RlJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQ29kZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCaW5hcnknKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaW5hcnkoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCU09OU3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3ltYm9sKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnREJSZWYnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEQlJlZihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05SZWdFeHAnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCU09OUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnSW50MzInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVJbnQzMihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnTWF4S2V5Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTWluTWF4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlLl9ic29udHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBVbnJlY29nbml6ZWQgb3IgaW52YWxpZCBfYnNvbnR5cGU6ICR7U3RyaW5nKHZhbHVlLl9ic29udHlwZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWFwIHx8IGlzTWFwKG9iamVjdCkpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBvYmplY3QuZW50cmllcygpO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgZG9uZSA9ICEhZW50cnkuZG9uZTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZW50cnkudmFsdWVbMF07XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBlbnRyeS52YWx1ZVsxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWU/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9CU09OKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICFpZ25vcmVLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5tYXRjaChyZWdleHApICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnJCcgPT09IGtleVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyBcIiBtdXN0IG5vdCBzdGFydCB3aXRoICckJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh+a2V5LmluZGV4T2YoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyBcIiBtdXN0IG5vdCBjb250YWluICcuJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3RyaW5nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bWJlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaWdJbnQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJvb2xlYW4oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGF0ZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBudWxsIHx8ICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGlnbm9yZVVuZGVmaW5lZCA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdWxsKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNVaW50OEFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQnVmZmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVSZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5fYnNvbnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZVtTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OVmVyc2lvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdPYmplY3RJZCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdElkKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX2Jzb250eXBlID09PSAnRGVjaW1hbDEyOCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURlY2ltYWwxMjgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdMb25nJyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdUaW1lc3RhbXAnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVMb25nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnRG91YmxlJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRG91YmxlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQ29kZScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUNvZGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHNlcmlhbGl6ZUZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRnVuY3Rpb24oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCaW5hcnknKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaW5hcnkoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCU09OU3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3ltYm9sKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnREJSZWYnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEQlJlZihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05SZWdFeHAnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCU09OUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnSW50MzInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVJbnQzMihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnTWF4S2V5Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTWluTWF4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlLl9ic29udHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBVbnJlY29nbml6ZWQgb3IgaW52YWxpZCBfYnNvbnR5cGU6ICR7U3RyaW5nKHZhbHVlLl9ic29udHlwZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Py50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC50b0JTT04oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3RvQlNPTiBmdW5jdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWU/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9CU09OKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICFpZ25vcmVLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5tYXRjaChyZWdleHApICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnJCcgPT09IGtleVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyBcIiBtdXN0IG5vdCBzdGFydCB3aXRoICckJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh+a2V5LmluZGV4T2YoJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigna2V5ICcgKyBrZXkgKyBcIiBtdXN0IG5vdCBjb250YWluICcuJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3RyaW5nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bWJlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaWdJbnQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJvb2xlYW4oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGF0ZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlVW5kZWZpbmVkID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdWxsKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCdWZmZXIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlLl9ic29udHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlW1N5bWJvbC5mb3IoJ0BAbWRiLmJzb24udmVyc2lvbicpXSAhPT0gQlNPTl9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05WZXJzaW9uRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0SWQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5fYnNvbnR5cGUgPT09ICdEZWNpbWFsMTI4Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0xvbmcnIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ1RpbWVzdGFtcCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUxvbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEb3VibGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEb3VibGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdDb2RlJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQ29kZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgc2VyaWFsaXplRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVGdW5jdGlvbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JpbmFyeScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpbmFyeShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05TeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTeW1ib2woYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEQlJlZicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURCUmVmKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlJlZ0V4cCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJTT05SZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdJbnQzMicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUludDMyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTWluS2V5JyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdNYXhLZXknKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVNaW5NYXgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUuX2Jzb250eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFVucmVjb2duaXplZCBvciBpbnZhbGlkIF9ic29udHlwZTogJHtTdHJpbmcodmFsdWUuX2Jzb250eXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXRoLmRlbGV0ZShvYmplY3QpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgY29uc3Qgc2l6ZSA9IGluZGV4IC0gc3RhcnRpbmdJbmRleDtcbiAgICBidWZmZXJbc3RhcnRpbmdJbmRleCsrXSA9IHNpemUgJiAweGZmO1xuICAgIGJ1ZmZlcltzdGFydGluZ0luZGV4KytdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltzdGFydGluZ0luZGV4KytdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbc3RhcnRpbmdJbmRleCsrXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG5mdW5jdGlvbiBpc0JTT05UeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ19ic29udHlwZScgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLl9ic29udHlwZSA9PT0gJ3N0cmluZycpO1xufVxuY29uc3Qga2V5c1RvQ29kZWNzID0ge1xuICAgICRvaWQ6IE9iamVjdElkLFxuICAgICRiaW5hcnk6IEJpbmFyeSxcbiAgICAkdXVpZDogQmluYXJ5LFxuICAgICRzeW1ib2w6IEJTT05TeW1ib2wsXG4gICAgJG51bWJlckludDogSW50MzIsXG4gICAgJG51bWJlckRlY2ltYWw6IERlY2ltYWwxMjgsXG4gICAgJG51bWJlckRvdWJsZTogRG91YmxlLFxuICAgICRudW1iZXJMb25nOiBMb25nLFxuICAgICRtaW5LZXk6IE1pbktleSxcbiAgICAkbWF4S2V5OiBNYXhLZXksXG4gICAgJHJlZ2V4OiBCU09OUmVnRXhwLFxuICAgICRyZWd1bGFyRXhwcmVzc2lvbjogQlNPTlJlZ0V4cCxcbiAgICAkdGltZXN0YW1wOiBUaW1lc3RhbXBcbn07XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBpbjMyQml0UmFuZ2UgPSB2YWx1ZSA8PSBCU09OX0lOVDMyX01BWCAmJiB2YWx1ZSA+PSBCU09OX0lOVDMyX01JTjtcbiAgICAgICAgY29uc3QgaW42NEJpdFJhbmdlID0gdmFsdWUgPD0gQlNPTl9JTlQ2NF9NQVggJiYgdmFsdWUgPj0gQlNPTl9JTlQ2NF9NSU47XG4gICAgICAgIGlmIChvcHRpb25zLnJlbGF4ZWQgfHwgb3B0aW9ucy5sZWdhY3kpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgIU9iamVjdC5pcyh2YWx1ZSwgLTApKSB7XG4gICAgICAgICAgICBpZiAoaW4zMkJpdFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW42NEJpdFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNlQmlnSW50NjQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRG91YmxlKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh2YWx1ZS4kdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihrID0+IGsuc3RhcnRzV2l0aCgnJCcpICYmIHZhbHVlW2tdICE9IG51bGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0ga2V5c1RvQ29kZWNzW2tleXNbaV1dO1xuICAgICAgICBpZiAoYylcbiAgICAgICAgICAgIHJldHVybiBjLmZyb21FeHRlbmRlZEpTT04odmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUuJGRhdGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkID0gdmFsdWUuJGRhdGU7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5sZWdhY3kpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZCA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGQpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShEYXRlLnBhcnNlKGQpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkID09PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoTnVtYmVyKGQpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTlJ1bnRpbWVFcnJvcihgVW5yZWNvZ25pemVkIHR5cGUgZm9yIEVKU09OIGRhdGU6ICR7dHlwZW9mIGR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShEYXRlLnBhcnNlKGQpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKExvbmcuaXNMb25nKGQpKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkLnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQgPT09ICdudW1iZXInICYmIG9wdGlvbnMucmVsYXhlZClcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZCA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKE51bWJlcihkKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05SdW50aW1lRXJyb3IoYFVucmVjb2duaXplZCB0eXBlIGZvciBFSlNPTiBkYXRlOiAke3R5cGVvZiBkfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBpZiAodmFsdWUuJGNvZGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUuJHNjb3BlKSB7XG4gICAgICAgICAgICBjb3B5LiRzY29wZSA9IGRlc2VyaWFsaXplVmFsdWUodmFsdWUuJHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29kZS5mcm9tRXh0ZW5kZWRKU09OKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzREJSZWZMaWtlKHZhbHVlKSB8fCB2YWx1ZS4kZGJQb2ludGVyKSB7XG4gICAgICAgIGNvbnN0IHYgPSB2YWx1ZS4kcmVmID8gdmFsdWUgOiB2YWx1ZS4kZGJQb2ludGVyO1xuICAgICAgICBpZiAodiBpbnN0YW5jZW9mIERCUmVmKVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNvbnN0IGRvbGxhcktleXMgPSBPYmplY3Qua2V5cyh2KS5maWx0ZXIoayA9PiBrLnN0YXJ0c1dpdGgoJyQnKSk7XG4gICAgICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgICAgIGRvbGxhcktleXMuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgIGlmIChbJyRyZWYnLCAnJGlkJywgJyRkYiddLmluZGV4T2YoaykgPT09IC0xKVxuICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsaWQpXG4gICAgICAgICAgICByZXR1cm4gREJSZWYuZnJvbUV4dGVuZGVkSlNPTih2KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQXJyYXkoYXJyYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXJyYXkubWFwKCh2LCBpbmRleCkgPT4ge1xuICAgICAgICBvcHRpb25zLnNlZW5PYmplY3RzLnB1c2goeyBwcm9wZXJ0eU5hbWU6IGBpbmRleCAke2luZGV4fWAsIG9iajogbnVsbCB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVWYWx1ZSh2LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2Vlbk9iamVjdHMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldElTT1N0cmluZyhkYXRlKSB7XG4gICAgY29uc3QgaXNvU3RyID0gZGF0ZS50b0lTT1N0cmluZygpO1xuICAgIHJldHVybiBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpICE9PSAwID8gaXNvU3RyIDogaXNvU3RyLnNsaWNlKDAsIC01KSArICdaJztcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVZhbHVlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IGlzTWFwKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0NhbiBvbmx5IHNlcmlhbGl6ZSBtYXBzIHdpdGggc3RyaW5nIGtleXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ialtrXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVZhbHVlKG9iaiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gb3B0aW9ucy5zZWVuT2JqZWN0cy5maW5kSW5kZXgoZW50cnkgPT4gZW50cnkub2JqID09PSB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gb3B0aW9ucy5zZWVuT2JqZWN0cy5tYXAoZW50cnkgPT4gZW50cnkucHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdQYXJ0ID0gcHJvcHNcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXgpXG4gICAgICAgICAgICAgICAgLm1hcChwcm9wID0+IGAke3Byb3B9IC0+IGApXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICAgICAgY29uc3QgYWxyZWFkeVNlZW4gPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCBjaXJjdWxhclBhcnQgPSAnIC0+ICcgK1xuICAgICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZShpbmRleCArIDEsIHByb3BzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAocHJvcCA9PiBgJHtwcm9wfSAtPiBgKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcHJvcHNbcHJvcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBsZWFkaW5nU3BhY2UgPSAnICcucmVwZWF0KGxlYWRpbmdQYXJ0Lmxlbmd0aCArIGFscmVhZHlTZWVuLmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgY29uc3QgZGFzaGVzID0gJy0nLnJlcGVhdChjaXJjdWxhclBhcnQubGVuZ3RoICsgKGFscmVhZHlTZWVuLmxlbmd0aCArIGN1cnJlbnQubGVuZ3RoKSAvIDIgLSAxKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEVKU09OOlxcbicgK1xuICAgICAgICAgICAgICAgIGAgICAgJHtsZWFkaW5nUGFydH0ke2FscmVhZHlTZWVufSR7Y2lyY3VsYXJQYXJ0fSR7Y3VycmVudH1cXG5gICtcbiAgICAgICAgICAgICAgICBgICAgICR7bGVhZGluZ1NwYWNlfVxcXFwke2Rhc2hlc30vYCk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5zZWVuT2JqZWN0c1tvcHRpb25zLnNlZW5PYmplY3RzLmxlbmd0aCAtIDFdLm9iaiA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVBcnJheSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBkYXRlTnVtID0gdmFsdWUuZ2V0VGltZSgpLCBpblJhbmdlID0gZGF0ZU51bSA+IC0xICYmIGRhdGVOdW0gPCAyNTM0MDIzMTg4MDAwMDA7XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVsYXhlZCAmJiBpblJhbmdlXG4gICAgICAgICAgICAgICAgPyB7ICRkYXRlOiB2YWx1ZS5nZXRUaW1lKCkgfVxuICAgICAgICAgICAgICAgIDogeyAkZGF0ZTogZ2V0SVNPU3RyaW5nKHZhbHVlKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLnJlbGF4ZWQgJiYgaW5SYW5nZVxuICAgICAgICAgICAgPyB7ICRkYXRlOiBnZXRJU09TdHJpbmcodmFsdWUpIH1cbiAgICAgICAgICAgIDogeyAkZGF0ZTogeyAkbnVtYmVyTG9uZzogdmFsdWUuZ2V0VGltZSgpLnRvU3RyaW5nKCkgfSB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAoIW9wdGlvbnMucmVsYXhlZCB8fCAhaXNGaW5pdGUodmFsdWUpKSkge1xuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgIU9iamVjdC5pcyh2YWx1ZSwgLTApKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gQlNPTl9JTlQzMl9NSU4gJiYgdmFsdWUgPD0gQlNPTl9JTlQzMl9NQVgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAkbnVtYmVySW50OiB2YWx1ZS50b1N0cmluZygpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gQlNPTl9JTlQ2NF9NSU4gJiYgdmFsdWUgPD0gQlNPTl9JTlQ2NF9NQVgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAkbnVtYmVyTG9uZzogdmFsdWUudG9TdHJpbmcoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICRudW1iZXJEb3VibGU6IE9iamVjdC5pcyh2YWx1ZSwgLTApID8gJy0wLjAnIDogdmFsdWUudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICBpZiAoIW9wdGlvbnMucmVsYXhlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJG51bWJlckxvbmc6IEJpZ0ludC5hc0ludE4oNjQsIHZhbHVlKS50b1N0cmluZygpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlcihCaWdJbnQuYXNJbnROKDY0LCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgIGxldCBmbGFncyA9IHZhbHVlLmZsYWdzO1xuICAgICAgICBpZiAoZmxhZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS50b1N0cmluZygpLm1hdGNoKC9bZ2ltdXldKiQvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGZsYWdzID0gbWF0Y2hbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnggPSBuZXcgQlNPTlJlZ0V4cCh2YWx1ZS5zb3VyY2UsIGZsYWdzKTtcbiAgICAgICAgcmV0dXJuIHJ4LnRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplRG9jdW1lbnQodmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IEJTT05fVFlQRV9NQVBQSU5HUyA9IHtcbiAgICBCaW5hcnk6IChvKSA9PiBuZXcgQmluYXJ5KG8udmFsdWUoKSwgby5zdWJfdHlwZSksXG4gICAgQ29kZTogKG8pID0+IG5ldyBDb2RlKG8uY29kZSwgby5zY29wZSksXG4gICAgREJSZWY6IChvKSA9PiBuZXcgREJSZWYoby5jb2xsZWN0aW9uIHx8IG8ubmFtZXNwYWNlLCBvLm9pZCwgby5kYiwgby5maWVsZHMpLFxuICAgIERlY2ltYWwxMjg6IChvKSA9PiBuZXcgRGVjaW1hbDEyOChvLmJ5dGVzKSxcbiAgICBEb3VibGU6IChvKSA9PiBuZXcgRG91YmxlKG8udmFsdWUpLFxuICAgIEludDMyOiAobykgPT4gbmV3IEludDMyKG8udmFsdWUpLFxuICAgIExvbmc6IChvKSA9PiBMb25nLmZyb21CaXRzKG8ubG93ICE9IG51bGwgPyBvLmxvdyA6IG8ubG93Xywgby5sb3cgIT0gbnVsbCA/IG8uaGlnaCA6IG8uaGlnaF8sIG8ubG93ICE9IG51bGwgPyBvLnVuc2lnbmVkIDogby51bnNpZ25lZF8pLFxuICAgIE1heEtleTogKCkgPT4gbmV3IE1heEtleSgpLFxuICAgIE1pbktleTogKCkgPT4gbmV3IE1pbktleSgpLFxuICAgIE9iamVjdElkOiAobykgPT4gbmV3IE9iamVjdElkKG8pLFxuICAgIEJTT05SZWdFeHA6IChvKSA9PiBuZXcgQlNPTlJlZ0V4cChvLnBhdHRlcm4sIG8ub3B0aW9ucyksXG4gICAgQlNPTlN5bWJvbDogKG8pID0+IG5ldyBCU09OU3ltYm9sKG8udmFsdWUpLFxuICAgIFRpbWVzdGFtcDogKG8pID0+IFRpbWVzdGFtcC5mcm9tQml0cyhvLmxvdywgby5oaWdoKVxufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgIGlmIChkb2MgPT0gbnVsbCB8fCB0eXBlb2YgZG9jICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignbm90IGFuIG9iamVjdCBpbnN0YW5jZScpO1xuICAgIGNvbnN0IGJzb250eXBlID0gZG9jLl9ic29udHlwZTtcbiAgICBpZiAodHlwZW9mIGJzb250eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBfZG9jID0ge307XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkb2MpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlZW5PYmplY3RzLnB1c2goeyBwcm9wZXJ0eU5hbWU6IG5hbWUsIG9iajogbnVsbCB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzZXJpYWxpemVWYWx1ZShkb2NbbmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2RvYywgbmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfZG9jW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZWVuT2JqZWN0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RvYztcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIGRvYyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIGRvYy5fYnNvbnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGRvY1tTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTlZlcnNpb25FcnJvcigpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0JTT05UeXBlKGRvYykpIHtcbiAgICAgICAgbGV0IG91dERvYyA9IGRvYztcbiAgICAgICAgaWYgKHR5cGVvZiBvdXREb2MudG9FeHRlbmRlZEpTT04gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlciA9IEJTT05fVFlQRV9NQVBQSU5HU1tkb2MuX2Jzb250eXBlXTtcbiAgICAgICAgICAgIGlmICghbWFwcGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVW5yZWNvZ25pemVkIG9yIGludmFsaWQgX2Jzb250eXBlOiAnICsgZG9jLl9ic29udHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXREb2MgPSBtYXBwZXIob3V0RG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnNvbnR5cGUgPT09ICdDb2RlJyAmJiBvdXREb2Muc2NvcGUpIHtcbiAgICAgICAgICAgIG91dERvYyA9IG5ldyBDb2RlKG91dERvYy5jb2RlLCBzZXJpYWxpemVWYWx1ZShvdXREb2Muc2NvcGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChic29udHlwZSA9PT0gJ0RCUmVmJyAmJiBvdXREb2Mub2lkKSB7XG4gICAgICAgICAgICBvdXREb2MgPSBuZXcgREJSZWYoc2VyaWFsaXplVmFsdWUob3V0RG9jLmNvbGxlY3Rpb24sIG9wdGlvbnMpLCBzZXJpYWxpemVWYWx1ZShvdXREb2Mub2lkLCBvcHRpb25zKSwgc2VyaWFsaXplVmFsdWUob3V0RG9jLmRiLCBvcHRpb25zKSwgc2VyaWFsaXplVmFsdWUob3V0RG9jLmZpZWxkcywgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXREb2MudG9FeHRlbmRlZEpTT04ob3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdfYnNvbnR5cGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHdhczogJyArIHR5cGVvZiBic29udHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2UodGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVqc29uT3B0aW9ucyA9IHtcbiAgICAgICAgdXNlQmlnSW50NjQ6IG9wdGlvbnM/LnVzZUJpZ0ludDY0ID8/IGZhbHNlLFxuICAgICAgICByZWxheGVkOiBvcHRpb25zPy5yZWxheGVkID8/IHRydWUsXG4gICAgICAgIGxlZ2FjeTogb3B0aW9ucz8ubGVnYWN5ID8/IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0LCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ1xceDAwJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCU09OIERvY3VtZW50IGZpZWxkIG5hbWVzIGNhbm5vdCBjb250YWluIG51bGwgYnl0ZXMsIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KGtleSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplVmFsdWUodmFsdWUsIGVqc29uT3B0aW9ucyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgb3B0aW9ucykge1xuICAgIGlmIChzcGFjZSAhPSBudWxsICYmIHR5cGVvZiBzcGFjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNwYWNlO1xuICAgICAgICBzcGFjZSA9IDA7XG4gICAgfVxuICAgIGlmIChyZXBsYWNlciAhPSBudWxsICYmIHR5cGVvZiByZXBsYWNlciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICAgICAgcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNwYWNlID0gMDtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyByZWxheGVkOiB0cnVlLCBsZWdhY3k6IGZhbHNlIH0sIG9wdGlvbnMsIHtcbiAgICAgICAgc2Vlbk9iamVjdHM6IFt7IHByb3BlcnR5TmFtZTogJyhyb290KScsIG9iajogbnVsbCB9XVxuICAgIH0pO1xuICAgIGNvbnN0IGRvYyA9IHNlcmlhbGl6ZVZhbHVlKHZhbHVlLCBzZXJpYWxpemVPcHRpb25zKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZG9jLCByZXBsYWNlciwgc3BhY2UpO1xufVxuZnVuY3Rpb24gRUpTT05zZXJpYWxpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIEVKU09OZGVzZXJpYWxpemUoZWpzb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gcGFyc2UoSlNPTi5zdHJpbmdpZnkoZWpzb24pLCBvcHRpb25zKTtcbn1cbmNvbnN0IEVKU09OID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbkVKU09OLnBhcnNlID0gcGFyc2U7XG5FSlNPTi5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5FSlNPTi5zZXJpYWxpemUgPSBFSlNPTnNlcmlhbGl6ZTtcbkVKU09OLmRlc2VyaWFsaXplID0gRUpTT05kZXNlcmlhbGl6ZTtcbk9iamVjdC5mcmVlemUoRUpTT04pO1xuXG5jb25zdCBNQVhTSVpFID0gMTAyNCAqIDEwMjQgKiAxNztcbmxldCBidWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGUoTUFYU0laRSk7XG5mdW5jdGlvbiBzZXRJbnRlcm5hbEJ1ZmZlclNpemUoc2l6ZSkge1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBidWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGUoc2l6ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VyaWFsaXplKG9iamVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tLZXlzID0gdHlwZW9mIG9wdGlvbnMuY2hlY2tLZXlzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNoZWNrS2V5cyA6IGZhbHNlO1xuICAgIGNvbnN0IHNlcmlhbGl6ZUZ1bmN0aW9ucyA9IHR5cGVvZiBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgOiBmYWxzZTtcbiAgICBjb25zdCBpZ25vcmVVbmRlZmluZWQgPSB0eXBlb2Ygb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkIDogdHJ1ZTtcbiAgICBjb25zdCBtaW5JbnRlcm5hbEJ1ZmZlclNpemUgPSB0eXBlb2Ygb3B0aW9ucy5taW5JbnRlcm5hbEJ1ZmZlclNpemUgPT09ICdudW1iZXInID8gb3B0aW9ucy5taW5JbnRlcm5hbEJ1ZmZlclNpemUgOiBNQVhTSVpFO1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgbWluSW50ZXJuYWxCdWZmZXJTaXplKSB7XG4gICAgICAgIGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShtaW5JbnRlcm5hbEJ1ZmZlclNpemUpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemF0aW9uSW5kZXggPSBzZXJpYWxpemVJbnRvKGJ1ZmZlciwgb2JqZWN0LCBjaGVja0tleXMsIDAsIDAsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBudWxsKTtcbiAgICBjb25zdCBmaW5pc2hlZEJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShzZXJpYWxpemF0aW9uSW5kZXgpO1xuICAgIGZpbmlzaGVkQnVmZmVyLnNldChidWZmZXIuc3ViYXJyYXkoMCwgc2VyaWFsaXphdGlvbkluZGV4KSwgMCk7XG4gICAgcmV0dXJuIGZpbmlzaGVkQnVmZmVyO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplV2l0aEJ1ZmZlckFuZEluZGV4KG9iamVjdCwgZmluYWxCdWZmZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrS2V5cyA9IHR5cGVvZiBvcHRpb25zLmNoZWNrS2V5cyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5jaGVja0tleXMgOiBmYWxzZTtcbiAgICBjb25zdCBzZXJpYWxpemVGdW5jdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zIDogZmFsc2U7XG4gICAgY29uc3QgaWdub3JlVW5kZWZpbmVkID0gdHlwZW9mIG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA6IHRydWU7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IHR5cGVvZiBvcHRpb25zLmluZGV4ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuaW5kZXggOiAwO1xuICAgIGNvbnN0IHNlcmlhbGl6YXRpb25JbmRleCA9IHNlcmlhbGl6ZUludG8oYnVmZmVyLCBvYmplY3QsIGNoZWNrS2V5cywgMCwgMCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIG51bGwpO1xuICAgIGZpbmFsQnVmZmVyLnNldChidWZmZXIuc3ViYXJyYXkoMCwgc2VyaWFsaXphdGlvbkluZGV4KSwgc3RhcnRJbmRleCk7XG4gICAgcmV0dXJuIHN0YXJ0SW5kZXggKyBzZXJpYWxpemF0aW9uSW5kZXggLSAxO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoYnVmZmVyLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gaW50ZXJuYWxEZXNlcmlhbGl6ZShCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVPYmplY3RTaXplKG9iamVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc2VyaWFsaXplRnVuY3Rpb25zID0gdHlwZW9mIG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA6IGZhbHNlO1xuICAgIGNvbnN0IGlnbm9yZVVuZGVmaW5lZCA9IHR5cGVvZiBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgOiB0cnVlO1xuICAgIHJldHVybiBpbnRlcm5hbENhbGN1bGF0ZU9iamVjdFNpemUob2JqZWN0LCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVN0cmVhbShkYXRhLCBzdGFydEluZGV4LCBudW1iZXJPZkRvY3VtZW50cywgZG9jdW1lbnRzLCBkb2NTdGFydEluZGV4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgaW50ZXJuYWxPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGFsbG93T2JqZWN0U21hbGxlclRoYW5CdWZmZXJTaXplOiB0cnVlLCBpbmRleDogMCB9LCBvcHRpb25zKTtcbiAgICBjb25zdCBidWZmZXJEYXRhID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGRhdGEpO1xuICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkRvY3VtZW50czsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBidWZmZXJEYXRhW2luZGV4XSB8XG4gICAgICAgICAgICAoYnVmZmVyRGF0YVtpbmRleCArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgIChidWZmZXJEYXRhW2luZGV4ICsgMl0gPDwgMTYpIHxcbiAgICAgICAgICAgIChidWZmZXJEYXRhW2luZGV4ICsgM10gPDwgMjQpO1xuICAgICAgICBpbnRlcm5hbE9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgZG9jdW1lbnRzW2RvY1N0YXJ0SW5kZXggKyBpXSA9IGludGVybmFsRGVzZXJpYWxpemUoYnVmZmVyRGF0YSwgaW50ZXJuYWxPcHRpb25zKTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIHNpemU7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cblxudmFyIGJzb24gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIEJTT05FcnJvcjogQlNPTkVycm9yLFxuICAgIEJTT05SZWdFeHA6IEJTT05SZWdFeHAsXG4gICAgQlNPTlJ1bnRpbWVFcnJvcjogQlNPTlJ1bnRpbWVFcnJvcixcbiAgICBCU09OU3ltYm9sOiBCU09OU3ltYm9sLFxuICAgIEJTT05UeXBlOiBCU09OVHlwZSxcbiAgICBCU09OVmFsdWU6IEJTT05WYWx1ZSxcbiAgICBCU09OVmVyc2lvbkVycm9yOiBCU09OVmVyc2lvbkVycm9yLFxuICAgIEJpbmFyeTogQmluYXJ5LFxuICAgIENvZGU6IENvZGUsXG4gICAgREJSZWY6IERCUmVmLFxuICAgIERlY2ltYWwxMjg6IERlY2ltYWwxMjgsXG4gICAgRG91YmxlOiBEb3VibGUsXG4gICAgRUpTT046IEVKU09OLFxuICAgIEludDMyOiBJbnQzMixcbiAgICBMb25nOiBMb25nLFxuICAgIE1heEtleTogTWF4S2V5LFxuICAgIE1pbktleTogTWluS2V5LFxuICAgIE9iamVjdElkOiBPYmplY3RJZCxcbiAgICBUaW1lc3RhbXA6IFRpbWVzdGFtcCxcbiAgICBVVUlEOiBVVUlELFxuICAgIGNhbGN1bGF0ZU9iamVjdFNpemU6IGNhbGN1bGF0ZU9iamVjdFNpemUsXG4gICAgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgIGRlc2VyaWFsaXplU3RyZWFtOiBkZXNlcmlhbGl6ZVN0cmVhbSxcbiAgICBzZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXg6IHNlcmlhbGl6ZVdpdGhCdWZmZXJBbmRJbmRleCxcbiAgICBzZXRJbnRlcm5hbEJ1ZmZlclNpemU6IHNldEludGVybmFsQnVmZmVyU2l6ZVxufSk7XG5cbmV4cG9ydHMuQlNPTiA9IGJzb247XG5leHBvcnRzLkJTT05FcnJvciA9IEJTT05FcnJvcjtcbmV4cG9ydHMuQlNPTlJlZ0V4cCA9IEJTT05SZWdFeHA7XG5leHBvcnRzLkJTT05SdW50aW1lRXJyb3IgPSBCU09OUnVudGltZUVycm9yO1xuZXhwb3J0cy5CU09OU3ltYm9sID0gQlNPTlN5bWJvbDtcbmV4cG9ydHMuQlNPTlR5cGUgPSBCU09OVHlwZTtcbmV4cG9ydHMuQlNPTlZhbHVlID0gQlNPTlZhbHVlO1xuZXhwb3J0cy5CU09OVmVyc2lvbkVycm9yID0gQlNPTlZlcnNpb25FcnJvcjtcbmV4cG9ydHMuQmluYXJ5ID0gQmluYXJ5O1xuZXhwb3J0cy5Db2RlID0gQ29kZTtcbmV4cG9ydHMuREJSZWYgPSBEQlJlZjtcbmV4cG9ydHMuRGVjaW1hbDEyOCA9IERlY2ltYWwxMjg7XG5leHBvcnRzLkRvdWJsZSA9IERvdWJsZTtcbmV4cG9ydHMuRUpTT04gPSBFSlNPTjtcbmV4cG9ydHMuSW50MzIgPSBJbnQzMjtcbmV4cG9ydHMuTG9uZyA9IExvbmc7XG5leHBvcnRzLk1heEtleSA9IE1heEtleTtcbmV4cG9ydHMuTWluS2V5ID0gTWluS2V5O1xuZXhwb3J0cy5PYmplY3RJZCA9IE9iamVjdElkO1xuZXhwb3J0cy5UaW1lc3RhbXAgPSBUaW1lc3RhbXA7XG5leHBvcnRzLlVVSUQgPSBVVUlEO1xuZXhwb3J0cy5jYWxjdWxhdGVPYmplY3RTaXplID0gY2FsY3VsYXRlT2JqZWN0U2l6ZTtcbmV4cG9ydHMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbmV4cG9ydHMuZGVzZXJpYWxpemVTdHJlYW0gPSBkZXNlcmlhbGl6ZVN0cmVhbTtcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuZXhwb3J0cy5zZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXggPSBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXg7XG5leHBvcnRzLnNldEludGVybmFsQnVmZmVyU2l6ZSA9IHNldEludGVybmFsQnVmZmVyU2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJzb24uY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/bson/lib/bson.cjs\n");

/***/ })

};
;