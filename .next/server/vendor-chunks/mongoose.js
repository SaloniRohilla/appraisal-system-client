/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mongoose";
exports.ids = ["vendor-chunks/mongoose"];
exports.modules = {

/***/ "(api)/../server/node_modules/mongoose/index.js":
/*!************************************************!*\
  !*** ../server/node_modules/mongoose/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Export lib/mongoose\n *\n */\n\n\n\nconst mongoose = __webpack_require__(/*! ./lib/ */ \"(api)/../server/node_modules/mongoose/lib/index.js\");\n\nmodule.exports = mongoose;\nmodule.exports[\"default\"] = mongoose;\nmodule.exports.mongoose = mongoose;\n\n// Re-export for ESM support\nmodule.exports.cast = mongoose.cast;\nmodule.exports.STATES = mongoose.STATES;\nmodule.exports.setDriver = mongoose.setDriver;\nmodule.exports.set = mongoose.set;\nmodule.exports.get = mongoose.get;\nmodule.exports.createConnection = mongoose.createConnection;\nmodule.exports.connect = mongoose.connect;\nmodule.exports.disconnect = mongoose.disconnect;\nmodule.exports.startSession = mongoose.startSession;\nmodule.exports.pluralize = mongoose.pluralize;\nmodule.exports.model = mongoose.model;\nmodule.exports.deleteModel = mongoose.deleteModel;\nmodule.exports.modelNames = mongoose.modelNames;\nmodule.exports.plugin = mongoose.plugin;\nmodule.exports.connections = mongoose.connections;\nmodule.exports.version = mongoose.version;\nmodule.exports.Mongoose = mongoose.Mongoose;\nmodule.exports.Schema = mongoose.Schema;\nmodule.exports.SchemaType = mongoose.SchemaType;\nmodule.exports.SchemaTypes = mongoose.SchemaTypes;\nmodule.exports.VirtualType = mongoose.VirtualType;\nmodule.exports.Types = mongoose.Types;\nmodule.exports.Query = mongoose.Query;\nmodule.exports.Model = mongoose.Model;\nmodule.exports.Document = mongoose.Document;\nmodule.exports.ObjectId = mongoose.ObjectId;\nmodule.exports.isValidObjectId = mongoose.isValidObjectId;\nmodule.exports.isObjectIdOrHexString = mongoose.isObjectIdOrHexString;\nmodule.exports.syncIndexes = mongoose.syncIndexes;\nmodule.exports.Decimal128 = mongoose.Decimal128;\nmodule.exports.Mixed = mongoose.Mixed;\nmodule.exports.Date = mongoose.Date;\nmodule.exports.Number = mongoose.Number;\nmodule.exports.Error = mongoose.Error;\nmodule.exports.MongooseError = mongoose.MongooseError;\nmodule.exports.now = mongoose.now;\nmodule.exports.CastError = mongoose.CastError;\nmodule.exports.SchemaTypeOptions = mongoose.SchemaTypeOptions;\nmodule.exports.mongo = mongoose.mongo;\nmodule.exports.mquery = mongoose.mquery;\nmodule.exports.sanitizeFilter = mongoose.sanitizeFilter;\nmodule.exports.trusted = mongoose.trusted;\nmodule.exports.skipMiddlewareFunction = mongoose.skipMiddlewareFunction;\nmodule.exports.overwriteMiddlewareResult = mongoose.overwriteMiddlewareResult;\n\n// The following properties are not exported using ESM because `setDriver()` can mutate these\n// module.exports.connection = mongoose.connection;\n// module.exports.Collection = mongoose.Collection;\n// module.exports.Connection = mongoose.Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyxrRUFBUTs7QUFFakM7QUFDQSx5QkFBc0I7QUFDdEIsdUJBQXVCOztBQUV2QjtBQUNBLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsK0JBQStCO0FBQy9CLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QixvQkFBb0I7QUFDcEIsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLG9DQUFvQztBQUNwQywwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQiw0QkFBNEI7QUFDNUIsa0JBQWtCO0FBQ2xCLHdCQUF3QjtBQUN4QixnQ0FBZ0M7QUFDaEMsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQiw2QkFBNkI7QUFDN0Isc0JBQXNCO0FBQ3RCLHFDQUFxQztBQUNyQyx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXhwb3J0IGxpYi9tb25nb29zZVxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnLi9saWIvJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbW9uZ29vc2U7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9uZ29vc2U7XG5tb2R1bGUuZXhwb3J0cy5tb25nb29zZSA9IG1vbmdvb3NlO1xuXG4vLyBSZS1leHBvcnQgZm9yIEVTTSBzdXBwb3J0XG5tb2R1bGUuZXhwb3J0cy5jYXN0ID0gbW9uZ29vc2UuY2FzdDtcbm1vZHVsZS5leHBvcnRzLlNUQVRFUyA9IG1vbmdvb3NlLlNUQVRFUztcbm1vZHVsZS5leHBvcnRzLnNldERyaXZlciA9IG1vbmdvb3NlLnNldERyaXZlcjtcbm1vZHVsZS5leHBvcnRzLnNldCA9IG1vbmdvb3NlLnNldDtcbm1vZHVsZS5leHBvcnRzLmdldCA9IG1vbmdvb3NlLmdldDtcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZUNvbm5lY3Rpb24gPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uO1xubW9kdWxlLmV4cG9ydHMuY29ubmVjdCA9IG1vbmdvb3NlLmNvbm5lY3Q7XG5tb2R1bGUuZXhwb3J0cy5kaXNjb25uZWN0ID0gbW9uZ29vc2UuZGlzY29ubmVjdDtcbm1vZHVsZS5leHBvcnRzLnN0YXJ0U2Vzc2lvbiA9IG1vbmdvb3NlLnN0YXJ0U2Vzc2lvbjtcbm1vZHVsZS5leHBvcnRzLnBsdXJhbGl6ZSA9IG1vbmdvb3NlLnBsdXJhbGl6ZTtcbm1vZHVsZS5leHBvcnRzLm1vZGVsID0gbW9uZ29vc2UubW9kZWw7XG5tb2R1bGUuZXhwb3J0cy5kZWxldGVNb2RlbCA9IG1vbmdvb3NlLmRlbGV0ZU1vZGVsO1xubW9kdWxlLmV4cG9ydHMubW9kZWxOYW1lcyA9IG1vbmdvb3NlLm1vZGVsTmFtZXM7XG5tb2R1bGUuZXhwb3J0cy5wbHVnaW4gPSBtb25nb29zZS5wbHVnaW47XG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0aW9ucyA9IG1vbmdvb3NlLmNvbm5lY3Rpb25zO1xubW9kdWxlLmV4cG9ydHMudmVyc2lvbiA9IG1vbmdvb3NlLnZlcnNpb247XG5tb2R1bGUuZXhwb3J0cy5Nb25nb29zZSA9IG1vbmdvb3NlLk1vbmdvb3NlO1xubW9kdWxlLmV4cG9ydHMuU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xubW9kdWxlLmV4cG9ydHMuU2NoZW1hVHlwZSA9IG1vbmdvb3NlLlNjaGVtYVR5cGU7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWFUeXBlcyA9IG1vbmdvb3NlLlNjaGVtYVR5cGVzO1xubW9kdWxlLmV4cG9ydHMuVmlydHVhbFR5cGUgPSBtb25nb29zZS5WaXJ0dWFsVHlwZTtcbm1vZHVsZS5leHBvcnRzLlR5cGVzID0gbW9uZ29vc2UuVHlwZXM7XG5tb2R1bGUuZXhwb3J0cy5RdWVyeSA9IG1vbmdvb3NlLlF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuTW9kZWwgPSBtb25nb29zZS5Nb2RlbDtcbm1vZHVsZS5leHBvcnRzLkRvY3VtZW50ID0gbW9uZ29vc2UuRG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cy5PYmplY3RJZCA9IG1vbmdvb3NlLk9iamVjdElkO1xubW9kdWxlLmV4cG9ydHMuaXNWYWxpZE9iamVjdElkID0gbW9uZ29vc2UuaXNWYWxpZE9iamVjdElkO1xubW9kdWxlLmV4cG9ydHMuaXNPYmplY3RJZE9ySGV4U3RyaW5nID0gbW9uZ29vc2UuaXNPYmplY3RJZE9ySGV4U3RyaW5nO1xubW9kdWxlLmV4cG9ydHMuc3luY0luZGV4ZXMgPSBtb25nb29zZS5zeW5jSW5kZXhlcztcbm1vZHVsZS5leHBvcnRzLkRlY2ltYWwxMjggPSBtb25nb29zZS5EZWNpbWFsMTI4O1xubW9kdWxlLmV4cG9ydHMuTWl4ZWQgPSBtb25nb29zZS5NaXhlZDtcbm1vZHVsZS5leHBvcnRzLkRhdGUgPSBtb25nb29zZS5EYXRlO1xubW9kdWxlLmV4cG9ydHMuTnVtYmVyID0gbW9uZ29vc2UuTnVtYmVyO1xubW9kdWxlLmV4cG9ydHMuRXJyb3IgPSBtb25nb29zZS5FcnJvcjtcbm1vZHVsZS5leHBvcnRzLk1vbmdvb3NlRXJyb3IgPSBtb25nb29zZS5Nb25nb29zZUVycm9yO1xubW9kdWxlLmV4cG9ydHMubm93ID0gbW9uZ29vc2Uubm93O1xubW9kdWxlLmV4cG9ydHMuQ2FzdEVycm9yID0gbW9uZ29vc2UuQ2FzdEVycm9yO1xubW9kdWxlLmV4cG9ydHMuU2NoZW1hVHlwZU9wdGlvbnMgPSBtb25nb29zZS5TY2hlbWFUeXBlT3B0aW9ucztcbm1vZHVsZS5leHBvcnRzLm1vbmdvID0gbW9uZ29vc2UubW9uZ287XG5tb2R1bGUuZXhwb3J0cy5tcXVlcnkgPSBtb25nb29zZS5tcXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5zYW5pdGl6ZUZpbHRlciA9IG1vbmdvb3NlLnNhbml0aXplRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMudHJ1c3RlZCA9IG1vbmdvb3NlLnRydXN0ZWQ7XG5tb2R1bGUuZXhwb3J0cy5za2lwTWlkZGxld2FyZUZ1bmN0aW9uID0gbW9uZ29vc2Uuc2tpcE1pZGRsZXdhcmVGdW5jdGlvbjtcbm1vZHVsZS5leHBvcnRzLm92ZXJ3cml0ZU1pZGRsZXdhcmVSZXN1bHQgPSBtb25nb29zZS5vdmVyd3JpdGVNaWRkbGV3YXJlUmVzdWx0O1xuXG4vLyBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIG5vdCBleHBvcnRlZCB1c2luZyBFU00gYmVjYXVzZSBgc2V0RHJpdmVyKClgIGNhbiBtdXRhdGUgdGhlc2Vcbi8vIG1vZHVsZS5leHBvcnRzLmNvbm5lY3Rpb24gPSBtb25nb29zZS5jb25uZWN0aW9uO1xuLy8gbW9kdWxlLmV4cG9ydHMuQ29sbGVjdGlvbiA9IG1vbmdvb3NlLkNvbGxlY3Rpb247XG4vLyBtb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uID0gbW9uZ29vc2UuQ29ubmVjdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/index.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/aggregate.js":
/*!********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/aggregate.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies\n */\n\nconst AggregationCursor = __webpack_require__(/*! ./cursor/AggregationCursor */ \"(api)/../server/node_modules/mongoose/lib/cursor/AggregationCursor.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(api)/../server/node_modules/mongoose/lib/query.js\");\nconst { applyGlobalMaxTimeMS, applyGlobalDiskUse } = __webpack_require__(/*! ./helpers/query/applyGlobalOption */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst getConstructorName = __webpack_require__(/*! ./helpers/getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst prepareDiscriminatorPipeline = __webpack_require__(/*! ./helpers/aggregate/prepareDiscriminatorPipeline */ \"(api)/../server/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js\");\nconst stringifyFunctionOperators = __webpack_require__(/*! ./helpers/aggregate/stringifyFunctionOperators */ \"(api)/../server/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst read = Query.prototype.read;\nconst readConcern = Query.prototype.readConcern;\n\nconst validRedactStringValues = new Set(['$$DESCEND', '$$PRUNE', '$$KEEP']);\n\n/**\n * Aggregate constructor used for building aggregation pipelines. Do not\n * instantiate this class directly, use [Model.aggregate()](https://mongoosejs.com/docs/api/model.html#Model.aggregate()) instead.\n *\n * #### Example:\n *\n *     const aggregate = Model.aggregate([\n *       { $project: { a: 1, b: 1 } },\n *       { $skip: 5 }\n *     ]);\n *\n *     Model.\n *       aggregate([{ $match: { age: { $gte: 21 }}}]).\n *       unwind('tags').\n *       exec();\n *\n * #### Note:\n *\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n * - Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database\n *\n *     new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\n *     // Do this instead to cast to an ObjectId\n *     new Aggregate([{ $match: { _id: new mongoose.Types.ObjectId('00000000000000000000000a') } }]);\n *\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @see driver https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#aggregate\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Model} [model] the model to use with this aggregate.\n * @api public\n */\n\nfunction Aggregate(pipeline, model) {\n  this._pipeline = [];\n  this._model = model;\n  this.options = {};\n\n  if (arguments.length === 1 && Array.isArray(pipeline)) {\n    this.append.apply(this, pipeline);\n  }\n}\n\n/**\n * Contains options passed down to the [aggregate command](https://www.mongodb.com/docs/manual/reference/command/aggregate/).\n * Supported options are:\n *\n * - [`allowDiskUse`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.allowDiskUse())\n * - `bypassDocumentValidation`\n * - [`collation`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.collation())\n * - `comment`\n * - [`cursor`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.cursor())\n * - [`explain`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.explain())\n * - `fieldsAsRaw`\n * - [`hint`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.hint())\n * - `let`\n * - `maxTimeMS`\n * - `raw`\n * - [`readConcern`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.readConcern())\n * - `readPreference`\n * - [`session`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.session())\n * - `writeConcern`\n *\n * @property options\n * @memberOf Aggregate\n * @api public\n */\n\nAggregate.prototype.options;\n\n/**\n * Get/set the model that this aggregation will execute on.\n *\n * #### Example:\n *\n *     const aggregate = MyModel.aggregate([{ $match: { answer: 42 } }]);\n *     aggregate.model() === MyModel; // true\n *\n *     // Change the model. There's rarely any reason to do this.\n *     aggregate.model(SomeOtherModel);\n *     aggregate.model() === SomeOtherModel; // true\n *\n * @param {Model} [model] Set the model associated with this aggregate. If not provided, returns the already stored model.\n * @return {Model}\n * @api public\n */\n\nAggregate.prototype.model = function(model) {\n  if (arguments.length === 0) {\n    return this._model;\n  }\n\n  this._model = model;\n  if (model.schema != null) {\n    if (this.options.readPreference == null &&\n      model.schema.options.read != null) {\n      this.options.readPreference = model.schema.options.read;\n    }\n    if (this.options.collation == null &&\n      model.schema.options.collation != null) {\n      this.options.collation = model.schema.options.collation;\n    }\n  }\n\n  return model;\n};\n\n/**\n * Appends new operators to this aggregate pipeline\n *\n * #### Example:\n *\n *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });\n *\n *     // or pass an array\n *     const pipeline = [{ $match: { daw: 'Logic Audio X' }} ];\n *     aggregate.append(pipeline);\n *\n * @param {...Object|Object[]} ops operator(s) to append. Can either be a spread of objects or a single parameter of a object array.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.append = function() {\n  const args = (arguments.length === 1 && Array.isArray(arguments[0]))\n    ? arguments[0]\n    : [...arguments];\n\n  if (!args.every(isOperator)) {\n    throw new Error('Arguments must be aggregate pipeline operators');\n  }\n\n  this._pipeline = this._pipeline.concat(args);\n\n  return this;\n};\n\n/**\n * Appends a new $addFields operator to this aggregate pipeline.\n * Requires MongoDB v3.4+ to work\n *\n * #### Example:\n *\n *     // adding new fields based on existing fields\n *     aggregate.addFields({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.addFields({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object} arg field specification\n * @see $addFields https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/\n * @return {Aggregate}\n * @api public\n */\nAggregate.prototype.addFields = function(arg) {\n  if (typeof arg !== 'object' || arg === null || Array.isArray(arg)) {\n    throw new Error('Invalid addFields() argument. Must be an object');\n  }\n  return this.append({ $addFields: Object.assign({}, arg) });\n};\n\n/**\n * Appends a new $project operator to this aggregate pipeline.\n *\n * Mongoose query [selection syntax](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()) is also supported.\n *\n * #### Example:\n *\n *     // include a, include b, exclude _id\n *     aggregate.project(\"a b -_id\");\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     aggregate.project({a: 1, b: 1, _id: 0});\n *\n *     // reshaping documents\n *     aggregate.project({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.project({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object|String} arg field specification\n * @see projection https://www.mongodb.com/docs/manual/reference/aggregation/project/\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.project = function(arg) {\n  const fields = {};\n\n  if (typeof arg === 'object' && !Array.isArray(arg)) {\n    Object.keys(arg).forEach(function(field) {\n      fields[field] = arg[field];\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      const include = field[0] === '-' ? 0 : 1;\n      if (include === 0) {\n        field = field.substring(1);\n      }\n      fields[field] = include;\n    });\n  } else {\n    throw new Error('Invalid project() argument. Must be string or object');\n  }\n\n  return this.append({ $project: fields });\n};\n\n/**\n * Appends a new custom $group operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.group({ _id: \"$department\" });\n *\n * @see $group https://www.mongodb.com/docs/manual/reference/aggregation/group/\n * @method group\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $group operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new custom $match operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.match({ department: { $in: [ \"sales\", \"engineering\" ] } });\n *\n * @see $match https://www.mongodb.com/docs/manual/reference/aggregation/match/\n * @method match\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $match operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $skip operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.skip(10);\n *\n * @see $skip https://www.mongodb.com/docs/manual/reference/aggregation/skip/\n * @method skip\n * @memberOf Aggregate\n * @instance\n * @param {Number} num number of records to skip before next stage\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $limit operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.limit(10);\n *\n * @see $limit https://www.mongodb.com/docs/manual/reference/aggregation/limit/\n * @method limit\n * @memberOf Aggregate\n * @instance\n * @param {Number} num maximum number of records to pass to the next stage\n * @return {Aggregate}\n * @api public\n */\n\n\n/**\n * Appends a new $densify operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *      aggregate.densify({\n *        field: 'timestamp',\n *        range: {\n *          step: 1,\n *          unit: 'hour',\n *          bounds: [new Date('2021-05-18T00:00:00.000Z'), new Date('2021-05-18T08:00:00.000Z')]\n *        }\n *      });\n *\n * @see $densify https://www.mongodb.com/docs/manual/reference/operator/aggregation/densify/\n * @method densify\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $densify operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $fill operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *      aggregate.fill({\n *        output: {\n *          bootsSold: { value: 0 },\n *          sandalsSold: { value: 0 },\n *          sneakersSold: { value: 0 }\n *        }\n *      });\n *\n * @see $fill https://www.mongodb.com/docs/manual/reference/operator/aggregation/fill/\n * @method fill\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $fill operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $geoNear operator to this aggregate pipeline.\n *\n * #### Note:\n *\n * **MUST** be used as the first operator in the pipeline.\n *\n * #### Example:\n *\n *     aggregate.near({\n *       near: { type: 'Point', coordinates: [40.724, -73.997] },\n *       distanceField: \"dist.calculated\", // required\n *       maxDistance: 0.008,\n *       query: { type: \"public\" },\n *       includeLocs: \"dist.location\",\n *       spherical: true,\n *     });\n *\n * @see $geoNear https://www.mongodb.com/docs/manual/reference/aggregation/geoNear/\n * @method near\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.near = function(arg) {\n  const op = {};\n  op.$geoNear = arg;\n  return this.append(op);\n};\n\n/*!\n * define methods\n */\n\n'group match skip limit out densify fill'.split(' ').forEach(function($operator) {\n  Aggregate.prototype[$operator] = function(arg) {\n    const op = {};\n    op['$' + $operator] = arg;\n    return this.append(op);\n  };\n});\n\n/**\n * Appends new custom $unwind operator(s) to this aggregate pipeline.\n *\n * Note that the `$unwind` operator requires the path name to start with '$'.\n * Mongoose will prepend '$' if the specified field doesn't start '$'.\n *\n * #### Example:\n *\n *     aggregate.unwind(\"tags\");\n *     aggregate.unwind(\"a\", \"b\", \"c\");\n *     aggregate.unwind({ path: '$tags', preserveNullAndEmptyArrays: true });\n *\n * @see $unwind https://www.mongodb.com/docs/manual/reference/aggregation/unwind/\n * @param {String|Object|String[]|Object[]} fields the field(s) to unwind, either as field names or as [objects with options](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/#document-operand-with-options). If passing a string, prefixing the field name with '$' is optional. If passing an object, `path` must start with '$'.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.unwind = function() {\n  const args = [...arguments];\n\n  const res = [];\n  for (const arg of args) {\n    if (arg && typeof arg === 'object') {\n      res.push({ $unwind: arg });\n    } else if (typeof arg === 'string') {\n      res.push({\n        $unwind: (arg[0] === '$') ? arg : '$' + arg\n      });\n    } else {\n      throw new Error('Invalid arg \"' + arg + '\" to unwind(), ' +\n        'must be string or object');\n    }\n  }\n\n  return this.append.apply(this, res);\n};\n\n/**\n * Appends a new $replaceRoot operator to this aggregate pipeline.\n *\n * Note that the `$replaceRoot` operator requires field strings to start with '$'.\n * If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'.\n * If you are passing in an object the strings in your expression will not be altered.\n *\n * #### Example:\n *\n *     aggregate.replaceRoot(\"user\");\n *\n *     aggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });\n *\n * @see $replaceRoot https://www.mongodb.com/docs/manual/reference/operator/aggregation/replaceRoot\n * @param {String|Object} newRoot the field or document which will become the new root document\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.replaceRoot = function(newRoot) {\n  let ret;\n\n  if (typeof newRoot === 'string') {\n    ret = newRoot.startsWith('$') ? newRoot : '$' + newRoot;\n  } else {\n    ret = newRoot;\n  }\n\n  return this.append({\n    $replaceRoot: {\n      newRoot: ret\n    }\n  });\n};\n\n/**\n * Appends a new $count operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.count(\"userCount\");\n *\n * @see $count https://www.mongodb.com/docs/manual/reference/operator/aggregation/count\n * @param {String} fieldName The name of the output field which has the count as its value. It must be a non-empty string, must not start with $ and must not contain the . character.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.count = function(fieldName) {\n  return this.append({ $count: fieldName });\n};\n\n/**\n * Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name\n * or a pipeline object.\n *\n * Note that the `$sortByCount` operator requires the new root to start with '$'.\n * Mongoose will prepend '$' if the specified field name doesn't start with '$'.\n *\n * #### Example:\n *\n *     aggregate.sortByCount('users');\n *     aggregate.sortByCount({ $mergeObjects: [ \"$employee\", \"$business\" ] })\n *\n * @see $sortByCount https://www.mongodb.com/docs/manual/reference/operator/aggregation/sortByCount/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sortByCount = function(arg) {\n  if (arg && typeof arg === 'object') {\n    return this.append({ $sortByCount: arg });\n  } else if (typeof arg === 'string') {\n    return this.append({\n      $sortByCount: (arg[0] === '$') ? arg : '$' + arg\n    });\n  } else {\n    throw new TypeError('Invalid arg \"' + arg + '\" to sortByCount(), ' +\n      'must be string or object');\n  }\n};\n\n/**\n * Appends new custom $lookup operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });\n *\n * @see $lookup https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/#pipe._S_lookup\n * @param {Object} options to $lookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.lookup = function(options) {\n  return this.append({ $lookup: options });\n};\n\n/**\n * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\n *\n * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.\n *\n * #### Example:\n *\n *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`\n *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites\n *\n * @see $graphLookup https://www.mongodb.com/docs/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup\n * @param {Object} options to $graphLookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.graphLookup = function(options) {\n  const cloneOptions = {};\n  if (options) {\n    if (!utils.isObject(options)) {\n      throw new TypeError('Invalid graphLookup() argument. Must be an object.');\n    }\n\n    utils.mergeClone(cloneOptions, options);\n    const startWith = cloneOptions.startWith;\n\n    if (startWith && typeof startWith === 'string') {\n      cloneOptions.startWith = cloneOptions.startWith.startsWith('$') ?\n        cloneOptions.startWith :\n        '$' + cloneOptions.startWith;\n    }\n\n  }\n  return this.append({ $graphLookup: cloneOptions });\n};\n\n/**\n * Appends new custom $sample operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.sample(3); // Add a pipeline that picks 3 random documents\n *\n * @see $sample https://www.mongodb.com/docs/manual/reference/operator/aggregation/sample/#pipe._S_sample\n * @param {Number} size number of random documents to pick\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.sample = function(size) {\n  return this.append({ $sample: { size: size } });\n};\n\n/**\n * Appends a new $sort operator to this aggregate pipeline.\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * #### Example:\n *\n *     // these are equivalent\n *     aggregate.sort({ field: 'asc', test: -1 });\n *     aggregate.sort('field -test');\n *\n * @see $sort https://www.mongodb.com/docs/manual/reference/aggregation/sort/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sort = function(arg) {\n  // TODO refactor to reuse the query builder logic\n\n  const sort = {};\n\n  if (getConstructorName(arg) === 'Object') {\n    const desc = ['desc', 'descending', -1];\n    Object.keys(arg).forEach(function(field) {\n      // If sorting by text score, skip coercing into 1/-1\n      if (arg[field] instanceof Object && arg[field].$meta) {\n        sort[field] = arg[field];\n        return;\n      }\n      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      const ascend = field[0] === '-' ? -1 : 1;\n      if (ascend === -1) {\n        field = field.substring(1);\n      }\n      sort[field] = ascend;\n    });\n  } else {\n    throw new TypeError('Invalid sort() argument. Must be a string or object.');\n  }\n\n  return this.append({ $sort: sort });\n};\n\n/**\n * Appends new $unionWith operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.unionWith({ coll: 'users', pipeline: [ { $match: { _id: 1 } } ] });\n *\n * @see $unionWith https://www.mongodb.com/docs/manual/reference/operator/aggregation/unionWith\n * @param {Object} options to $unionWith query as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.unionWith = function(options) {\n  return this.append({ $unionWith: options });\n};\n\n\n/**\n * Sets the readPreference option for the aggregation query.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).read('primaryPreferred');\n *\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\n * @param {Array} [tags] optional tags for this query.\n * @return {Aggregate} this\n * @api public\n * @see mongodb https://www.mongodb.com/docs/manual/applications/replication/#read-preference\n */\n\nAggregate.prototype.read = function(pref, tags) {\n  read.call(this, pref, tags);\n  return this;\n};\n\n/**\n * Sets the readConcern level for the aggregation query.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).readConcern('majority');\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://www.mongodb.com/docs/manual/reference/read-concern/\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.readConcern = function(level) {\n  readConcern.call(this, level);\n  return this;\n};\n\n/**\n * Appends a new $redact operator to this aggregate pipeline.\n *\n * If 3 arguments are supplied, Mongoose will wrap them with if-then-else of $cond operator respectively\n * If `thenExpr` or `elseExpr` is string, make sure it starts with $$, like `$$DESCEND`, `$$PRUNE` or `$$KEEP`.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).redact({\n *       $cond: {\n *         if: { $eq: [ '$level', 5 ] },\n *         then: '$$PRUNE',\n *         else: '$$DESCEND'\n *       }\n *     });\n *\n *     // $redact often comes with $cond operator, you can also use the following syntax provided by mongoose\n *     await Model.aggregate(pipeline).redact({ $eq: [ '$level', 5 ] }, '$$PRUNE', '$$DESCEND');\n *\n * @param {Object} expression redact options or conditional expression\n * @param {String|Object} [thenExpr] true case for the condition\n * @param {String|Object} [elseExpr] false case for the condition\n * @return {Aggregate} this\n * @see $redact https://www.mongodb.com/docs/manual/reference/operator/aggregation/redact/\n * @api public\n */\n\nAggregate.prototype.redact = function(expression, thenExpr, elseExpr) {\n  if (arguments.length === 3) {\n    if ((typeof thenExpr === 'string' && !validRedactStringValues.has(thenExpr)) ||\n      (typeof elseExpr === 'string' && !validRedactStringValues.has(elseExpr))) {\n      throw new Error('If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP');\n    }\n\n    expression = {\n      $cond: {\n        if: expression,\n        then: thenExpr,\n        else: elseExpr\n      }\n    };\n  } else if (arguments.length !== 1) {\n    throw new TypeError('Invalid arguments');\n  }\n\n  return this.append({ $redact: expression });\n};\n\n/**\n * Execute the aggregation with explain\n *\n * #### Example:\n *\n *     Model.aggregate(..).explain()\n *\n * @param {String} [verbosity]\n * @return {Promise}\n */\n\nAggregate.prototype.explain = async function explain(verbosity) {\n  if (typeof verbosity === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Aggregate.prototype.explain() no longer accepts a callback');\n  }\n  const model = this._model;\n\n  if (!this._pipeline.length) {\n    throw new Error('Aggregate has empty pipeline');\n  }\n\n  prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n\n  await new Promise((resolve, reject) => {\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = { error: error };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          reject(error);\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n\n  const cursor = model.collection.aggregate(this._pipeline, this.options);\n\n  if (verbosity == null) {\n    verbosity = true;\n  }\n\n  let result = null;\n  try {\n    result = await cursor.explain(verbosity);\n  } catch (error) {\n    await new Promise((resolve, reject) => {\n      const _opts = { error: error };\n      model.hooks.execPost('aggregate', this, [null], _opts, error => {\n        if (error) {\n          return reject(error);\n        }\n        return resolve();\n      });\n    });\n  }\n\n  const _opts = { error: null };\n  await new Promise((resolve, reject) => {\n    model.hooks.execPost('aggregate', this, [result], _opts, error => {\n      if (error) {\n        return reject(error);\n      }\n      return resolve();\n    });\n  });\n\n  return result;\n};\n\n/**\n * Sets the allowDiskUse option for the aggregation query\n *\n * #### Example:\n *\n *     await Model.aggregate([{ $match: { foo: 'bar' } }]).allowDiskUse(true);\n *\n * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.\n * @return {Aggregate} this\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.allowDiskUse = function(value) {\n  this.options.allowDiskUse = value;\n  return this;\n};\n\n/**\n * Sets the hint option for the aggregation query\n *\n * #### Example:\n *\n *     Model.aggregate(..).hint({ qty: 1, category: 1 }).exec();\n *\n * @param {Object|String} value a hint object or the index name\n * @return {Aggregate} this\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.hint = function(value) {\n  this.options.hint = value;\n  return this;\n};\n\n/**\n * Sets the session for this aggregation. Useful for [transactions](https://mongoosejs.com/docs/transactions.html).\n *\n * #### Example:\n *\n *     const session = await Model.startSession();\n *     await Model.aggregate(..).session(session);\n *\n * @param {ClientSession} session\n * @return {Aggregate} this\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.session = function(session) {\n  if (session == null) {\n    delete this.options.session;\n  } else {\n    this.options.session = session;\n  }\n  return this;\n};\n\n/**\n * Lets you set arbitrary options, for middleware or plugins.\n *\n * #### Example:\n *\n *     const agg = Model.aggregate(..).option({ allowDiskUse: true }); // Set the `allowDiskUse` option\n *     agg.options; // `{ allowDiskUse: true }`\n *\n * @param {Object} options keys to merge into current options\n * @param {Number} [options.maxTimeMS] number limits the time this aggregation will run, see [MongoDB docs on `maxTimeMS`](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/)\n * @param {Boolean} [options.allowDiskUse] boolean if true, the MongoDB server will use the hard drive to store data during this aggregation\n * @param {Object} [options.collation] object see [`Aggregate.prototype.collation()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.collation())\n * @param {ClientSession} [options.session] ClientSession see [`Aggregate.prototype.session()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.session())\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.option = function(value) {\n  for (const key in value) {\n    this.options[key] = value[key];\n  }\n  return this;\n};\n\n/**\n * Sets the `cursor` option and executes this aggregation, returning an aggregation cursor.\n * Cursors are useful if you want to process the results of the aggregation one-at-a-time\n * because the aggregation result is too big to fit into memory.\n *\n * #### Example:\n *\n *     const cursor = Model.aggregate(..).cursor({ batchSize: 1000 });\n *     cursor.eachAsync(function(doc, i) {\n *       // use doc\n *     });\n *\n * @param {Object} options\n * @param {Number} [options.batchSize] set the cursor batch size\n * @param {Boolean} [options.useMongooseAggCursor] use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)\n * @return {AggregationCursor} cursor representing this aggregation\n * @api public\n * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html\n */\n\nAggregate.prototype.cursor = function(options) {\n  this.options.cursor = options || {};\n  return new AggregationCursor(this); // return this;\n};\n\n/**\n * Adds a collation\n *\n * #### Example:\n *\n *     const res = await Model.aggregate(pipeline).collation({ locale: 'en_US', strength: 1 });\n *\n * @param {Object} collation options\n * @return {Aggregate} this\n * @api public\n * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/interfaces/CollationOptions.html\n */\n\nAggregate.prototype.collation = function(collation) {\n  this.options.collation = collation;\n  return this;\n};\n\n/**\n * Combines multiple aggregation pipelines.\n *\n * #### Example:\n *\n *     const res = await Model.aggregate().facet({\n *       books: [{ groupBy: '$author' }],\n *       price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]\n *     });\n *\n *     // Output: { books: [...], price: [{...}, {...}] }\n *\n * @param {Object} facet options\n * @return {Aggregate} this\n * @see $facet https://www.mongodb.com/docs/manual/reference/operator/aggregation/facet/\n * @api public\n */\n\nAggregate.prototype.facet = function(options) {\n  return this.append({ $facet: options });\n};\n\n/**\n * Helper for [Atlas Text Search](https://www.mongodb.com/docs/atlas/atlas-search/tutorial/)'s\n * `$search` stage.\n *\n * #### Example:\n *\n *     const res = await Model.aggregate().\n *      search({\n *        text: {\n *          query: 'baseball',\n *          path: 'plot'\n *        }\n *      });\n *\n *     // Output: [{ plot: '...', title: '...' }]\n *\n * @param {Object} $search options\n * @return {Aggregate} this\n * @see $search https://www.mongodb.com/docs/atlas/atlas-search/tutorial/\n * @api public\n */\n\nAggregate.prototype.search = function(options) {\n  return this.append({ $search: options });\n};\n\n/**\n * Returns the current pipeline\n *\n * #### Example:\n *\n *     MyModel.aggregate().match({ test: 1 }).pipeline(); // [{ $match: { test: 1 } }]\n *\n * @return {Array} The current pipeline similar to the operation that will be executed\n * @api public\n */\n\nAggregate.prototype.pipeline = function() {\n  return this._pipeline;\n};\n\n/**\n * Executes the aggregate pipeline on the currently bound Model.\n *\n * #### Example:\n *     const result = await aggregate.exec();\n *\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.exec = async function exec() {\n  if (!this._model) {\n    throw new Error('Aggregate not bound to any Model');\n  }\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Aggregate.prototype.exec() no longer accepts a callback');\n  }\n  const model = this._model;\n  const collection = this._model.collection;\n\n  applyGlobalMaxTimeMS(this.options, model);\n  applyGlobalDiskUse(this.options, model);\n\n  const asyncLocalStorage = this.model()?.db?.base.transactionAsyncLocalStorage?.getStore();\n  if (!this.options.hasOwnProperty('session') && asyncLocalStorage?.session != null) {\n    this.options.session = asyncLocalStorage.session;\n  }\n\n  if (this.options && this.options.cursor) {\n    return new AggregationCursor(this);\n  }\n\n  prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n  stringifyFunctionOperators(this._pipeline);\n\n  await new Promise((resolve, reject) => {\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = { error: error };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          reject(error);\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n\n  if (!this._pipeline.length) {\n    throw new MongooseError('Aggregate has empty pipeline');\n  }\n\n  const options = clone(this.options || {});\n  let result;\n  try {\n    const cursor = await collection.aggregate(this._pipeline, options);\n    result = await cursor.toArray();\n  } catch (error) {\n    await new Promise((resolve, reject) => {\n      const _opts = { error: error };\n      model.hooks.execPost('aggregate', this, [null], _opts, (error) => {\n        if (error) {\n          return reject(error);\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  const _opts = { error: null };\n  await new Promise((resolve, reject) => {\n    model.hooks.execPost('aggregate', this, [result], _opts, error => {\n      if (error) {\n        return reject(error);\n      }\n      return resolve();\n    });\n  });\n\n  return result;\n};\n\n/**\n * Provides a Promise-like `then` function, which will call `.exec` without a callback\n * Compatible with `await`.\n *\n * #### Example:\n *\n *     Model.aggregate(..).then(successCallback, errorCallback);\n *\n * @param {Function} [resolve] successCallback\n * @param {Function} [reject]  errorCallback\n * @return {Promise}\n */\nAggregate.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\n * Executes the aggregation returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n * Like [`.then()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.then), but only takes a rejection handler.\n * Compatible with `await`.\n *\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.catch = function(reject) {\n  return this.exec().then(null, reject);\n};\n\n/**\n * Executes the aggregate returning a `Promise` which will be\n * resolved with `.finally()` chained.\n *\n * More about [Promise `finally()` in JavaScript](https://thecodebarbarian.com/using-promise-finally-in-node-js.html).\n *\n * @param {Function} [onFinally]\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.finally = function(onFinally) {\n  return this.exec().finally(onFinally);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf Aggregate\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  Aggregate.prototype[Symbol.asyncIterator] = function() {\n    return this.cursor({ useMongooseAggCursor: true }).transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * Helpers\n */\n\n/**\n * Checks whether an object is likely a pipeline operator\n *\n * @param {Object} obj object to check\n * @return {Boolean}\n * @api private\n */\n\nfunction isOperator(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const k = Object.keys(obj);\n\n  return k.length === 1 && k[0][0] === '$';\n}\n\n/**\n * Adds the appropriate `$match` pipeline step to the top of an aggregate's\n * pipeline, should it's model is a non-root discriminator type. This is\n * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.\n *\n * @param {Aggregate} aggregate Aggregate to prepare\n * @api private\n */\n\nAggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;\n\n/*!\n * Exports\n */\n\nmodule.exports = Aggregate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvYWdncmVnYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsbUJBQU8sQ0FBQyx5R0FBNEI7QUFDOUQsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQXVCO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyxtRUFBUztBQUMvQixRQUFRLDJDQUEyQyxFQUFFLG1CQUFPLENBQUMsdUhBQW1DO0FBQ2hHLGNBQWMsbUJBQU8sQ0FBQyxtRkFBaUI7QUFDdkMsMkJBQTJCLG1CQUFPLENBQUMsNkdBQThCO0FBQ2pFLHFDQUFxQyxtQkFBTyxDQUFDLHFKQUFrRDtBQUMvRixtQ0FBbUMsbUJBQU8sQ0FBQyxpSkFBZ0Q7QUFDM0YsY0FBYyxtQkFBTyxDQUFDLG1FQUFTO0FBQy9CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVksY0FBYztBQUNyQyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsT0FBTyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVSxtQ0FBbUM7QUFDckU7QUFDQSx3QkFBd0IsVUFBVSxnRUFBZ0U7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVUsY0FBYztBQUN0RSxzQ0FBc0M7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S0FBSztBQUNMOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxPQUFPLGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGFnZ3JlZ2F0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbmNvbnN0IEFnZ3JlZ2F0aW9uQ3Vyc29yID0gcmVxdWlyZSgnLi9jdXJzb3IvQWdncmVnYXRpb25DdXJzb3InKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpO1xuY29uc3QgeyBhcHBseUdsb2JhbE1heFRpbWVNUywgYXBwbHlHbG9iYWxEaXNrVXNlIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvYXBwbHlHbG9iYWxPcHRpb24nKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2FnZ3JlZ2F0ZS9wcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lJyk7XG5jb25zdCBzdHJpbmdpZnlGdW5jdGlvbk9wZXJhdG9ycyA9IHJlcXVpcmUoJy4vaGVscGVycy9hZ2dyZWdhdGUvc3RyaW5naWZ5RnVuY3Rpb25PcGVyYXRvcnMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgcmVhZCA9IFF1ZXJ5LnByb3RvdHlwZS5yZWFkO1xuY29uc3QgcmVhZENvbmNlcm4gPSBRdWVyeS5wcm90b3R5cGUucmVhZENvbmNlcm47XG5cbmNvbnN0IHZhbGlkUmVkYWN0U3RyaW5nVmFsdWVzID0gbmV3IFNldChbJyQkREVTQ0VORCcsICckJFBSVU5FJywgJyQkS0VFUCddKTtcblxuLyoqXG4gKiBBZ2dyZWdhdGUgY29uc3RydWN0b3IgdXNlZCBmb3IgYnVpbGRpbmcgYWdncmVnYXRpb24gcGlwZWxpbmVzLiBEbyBub3RcbiAqIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBbTW9kZWwuYWdncmVnYXRlKCldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5hZ2dyZWdhdGUoKSkgaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGFnZ3JlZ2F0ZSA9IE1vZGVsLmFnZ3JlZ2F0ZShbXG4gKiAgICAgICB7ICRwcm9qZWN0OiB7IGE6IDEsIGI6IDEgfSB9LFxuICogICAgICAgeyAkc2tpcDogNSB9XG4gKiAgICAgXSk7XG4gKlxuICogICAgIE1vZGVsLlxuICogICAgICAgYWdncmVnYXRlKFt7ICRtYXRjaDogeyBhZ2U6IHsgJGd0ZTogMjEgfX19XSkuXG4gKiAgICAgICB1bndpbmQoJ3RhZ3MnKS5cbiAqICAgICAgIGV4ZWMoKTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogLSBUaGUgZG9jdW1lbnRzIHJldHVybmVkIGFyZSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdHMsIG5vdCBtb25nb29zZSBkb2N1bWVudHMgKHNpbmNlIGFueSBzaGFwZSBvZiBkb2N1bWVudCBjYW4gYmUgcmV0dXJuZWQpLlxuICogLSBNb25nb29zZSBkb2VzICoqbm90KiogY2FzdCBwaXBlbGluZSBzdGFnZXMuIFRoZSBiZWxvdyB3aWxsICoqbm90Kiogd29yayB1bmxlc3MgYF9pZGAgaXMgYSBzdHJpbmcgaW4gdGhlIGRhdGFiYXNlXG4gKlxuICogICAgIG5ldyBBZ2dyZWdhdGUoW3sgJG1hdGNoOiB7IF9pZDogJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYScgfSB9XSk7XG4gKiAgICAgLy8gRG8gdGhpcyBpbnN0ZWFkIHRvIGNhc3QgdG8gYW4gT2JqZWN0SWRcbiAqICAgICBuZXcgQWdncmVnYXRlKFt7ICRtYXRjaDogeyBfaWQ6IG5ldyBtb25nb29zZS5UeXBlcy5PYmplY3RJZCgnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhJykgfSB9XSk7XG4gKlxuICogQHNlZSBNb25nb0RCIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2FwcGxpY2F0aW9ucy9hZ2dyZWdhdGlvbi9cbiAqIEBzZWUgZHJpdmVyIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjYWdncmVnYXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbcGlwZWxpbmVdIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lIGFzIGFuIGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7TW9kZWx9IFttb2RlbF0gdGhlIG1vZGVsIHRvIHVzZSB3aXRoIHRoaXMgYWdncmVnYXRlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBBZ2dyZWdhdGUocGlwZWxpbmUsIG1vZGVsKSB7XG4gIHRoaXMuX3BpcGVsaW5lID0gW107XG4gIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkocGlwZWxpbmUpKSB7XG4gICAgdGhpcy5hcHBlbmQuYXBwbHkodGhpcywgcGlwZWxpbmUpO1xuICB9XG59XG5cbi8qKlxuICogQ29udGFpbnMgb3B0aW9ucyBwYXNzZWQgZG93biB0byB0aGUgW2FnZ3JlZ2F0ZSBjb21tYW5kXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9hZ2dyZWdhdGUvKS5cbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIFtgYWxsb3dEaXNrVXNlYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUucHJvdG90eXBlLmFsbG93RGlza1VzZSgpKVxuICogLSBgYnlwYXNzRG9jdW1lbnRWYWxpZGF0aW9uYFxuICogLSBbYGNvbGxhdGlvbmBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlLnByb3RvdHlwZS5jb2xsYXRpb24oKSlcbiAqIC0gYGNvbW1lbnRgXG4gKiAtIFtgY3Vyc29yYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUucHJvdG90eXBlLmN1cnNvcigpKVxuICogLSBbYGV4cGxhaW5gXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuZXhwbGFpbigpKVxuICogLSBgZmllbGRzQXNSYXdgXG4gKiAtIFtgaGludGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlLnByb3RvdHlwZS5oaW50KCkpXG4gKiAtIGBsZXRgXG4gKiAtIGBtYXhUaW1lTVNgXG4gKiAtIGByYXdgXG4gKiAtIFtgcmVhZENvbmNlcm5gXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUucmVhZENvbmNlcm4oKSlcbiAqIC0gYHJlYWRQcmVmZXJlbmNlYFxuICogLSBbYHNlc3Npb25gXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuc2Vzc2lvbigpKVxuICogLSBgd3JpdGVDb25jZXJuYFxuICpcbiAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUub3B0aW9ucztcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBtb2RlbCB0aGF0IHRoaXMgYWdncmVnYXRpb24gd2lsbCBleGVjdXRlIG9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgYWdncmVnYXRlID0gTXlNb2RlbC5hZ2dyZWdhdGUoW3sgJG1hdGNoOiB7IGFuc3dlcjogNDIgfSB9XSk7XG4gKiAgICAgYWdncmVnYXRlLm1vZGVsKCkgPT09IE15TW9kZWw7IC8vIHRydWVcbiAqXG4gKiAgICAgLy8gQ2hhbmdlIHRoZSBtb2RlbC4gVGhlcmUncyByYXJlbHkgYW55IHJlYXNvbiB0byBkbyB0aGlzLlxuICogICAgIGFnZ3JlZ2F0ZS5tb2RlbChTb21lT3RoZXJNb2RlbCk7XG4gKiAgICAgYWdncmVnYXRlLm1vZGVsKCkgPT09IFNvbWVPdGhlck1vZGVsOyAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gW21vZGVsXSBTZXQgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFnZ3JlZ2F0ZS4gSWYgbm90IHByb3ZpZGVkLCByZXR1cm5zIHRoZSBhbHJlYWR5IHN0b3JlZCBtb2RlbC5cbiAqIEByZXR1cm4ge01vZGVsfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIH1cblxuICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICBpZiAobW9kZWwuc2NoZW1hICE9IG51bGwpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlID09IG51bGwgJiZcbiAgICAgIG1vZGVsLnNjaGVtYS5vcHRpb25zLnJlYWQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gbW9kZWwuc2NoZW1hLm9wdGlvbnMucmVhZDtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPT0gbnVsbCAmJlxuICAgICAgbW9kZWwuc2NoZW1hLm9wdGlvbnMuY29sbGF0aW9uICE9IG51bGwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPSBtb2RlbC5zY2hlbWEub3B0aW9ucy5jb2xsYXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIG5ldyBvcGVyYXRvcnMgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmVcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5hcHBlbmQoeyAkcHJvamVjdDogeyBmaWVsZDogMSB9fSwgeyAkbGltaXQ6IDIgfSk7XG4gKlxuICogICAgIC8vIG9yIHBhc3MgYW4gYXJyYXlcbiAqICAgICBjb25zdCBwaXBlbGluZSA9IFt7ICRtYXRjaDogeyBkYXc6ICdMb2dpYyBBdWRpbyBYJyB9fSBdO1xuICogICAgIGFnZ3JlZ2F0ZS5hcHBlbmQocGlwZWxpbmUpO1xuICpcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fE9iamVjdFtdfSBvcHMgb3BlcmF0b3IocykgdG8gYXBwZW5kLiBDYW4gZWl0aGVyIGJlIGEgc3ByZWFkIG9mIG9iamVjdHMgb3IgYSBzaW5nbGUgcGFyYW1ldGVyIG9mIGEgb2JqZWN0IGFycmF5LlxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBhcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKVxuICAgID8gYXJndW1lbnRzWzBdXG4gICAgOiBbLi4uYXJndW1lbnRzXTtcblxuICBpZiAoIWFyZ3MuZXZlcnkoaXNPcGVyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIGFnZ3JlZ2F0ZSBwaXBlbGluZSBvcGVyYXRvcnMnKTtcbiAgfVxuXG4gIHRoaXMuX3BpcGVsaW5lID0gdGhpcy5fcGlwZWxpbmUuY29uY2F0KGFyZ3MpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRhZGRGaWVsZHMgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKiBSZXF1aXJlcyBNb25nb0RCIHYzLjQrIHRvIHdvcmtcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGFkZGluZyBuZXcgZmllbGRzIGJhc2VkIG9uIGV4aXN0aW5nIGZpZWxkc1xuICogICAgIGFnZ3JlZ2F0ZS5hZGRGaWVsZHMoe1xuICogICAgICAgICBuZXdGaWVsZDogJyRiLm5lc3RlZCdcbiAqICAgICAgICwgcGx1c1RlbjogeyAkYWRkOiBbJyR2YWwnLCAxMF19XG4gKiAgICAgICAsIHN1Yjoge1xuICogICAgICAgICAgICBuYW1lOiAnJGEnXG4gKiAgICAgICAgIH1cbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBldGNcbiAqICAgICBhZ2dyZWdhdGUuYWRkRmllbGRzKHsgc2FsYXJ5X2s6IHsgJGRpdmlkZTogWyBcIiRzYWxhcnlcIiwgMTAwMCBdIH0gfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZyBmaWVsZCBzcGVjaWZpY2F0aW9uXG4gKiBAc2VlICRhZGRGaWVsZHMgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2FkZEZpZWxkcy9cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuYWRkRmllbGRzID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmICh0eXBlb2YgYXJnICE9PSAnb2JqZWN0JyB8fCBhcmcgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZEZpZWxkcygpIGFyZ3VtZW50LiBNdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRhZGRGaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGFyZykgfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJHByb2plY3Qgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogTW9uZ29vc2UgcXVlcnkgW3NlbGVjdGlvbiBzeW50YXhdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpIGlzIGFsc28gc3VwcG9ydGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gaW5jbHVkZSBhLCBpbmNsdWRlIGIsIGV4Y2x1ZGUgX2lkXG4gKiAgICAgYWdncmVnYXRlLnByb2plY3QoXCJhIGIgLV9pZFwiKTtcbiAqXG4gKiAgICAgLy8gb3IgeW91IG1heSB1c2Ugb2JqZWN0IG5vdGF0aW9uLCB1c2VmdWwgd2hlblxuICogICAgIC8vIHlvdSBoYXZlIGtleXMgYWxyZWFkeSBwcmVmaXhlZCB3aXRoIGEgXCItXCJcbiAqICAgICBhZ2dyZWdhdGUucHJvamVjdCh7YTogMSwgYjogMSwgX2lkOiAwfSk7XG4gKlxuICogICAgIC8vIHJlc2hhcGluZyBkb2N1bWVudHNcbiAqICAgICBhZ2dyZWdhdGUucHJvamVjdCh7XG4gKiAgICAgICAgIG5ld0ZpZWxkOiAnJGIubmVzdGVkJ1xuICogICAgICAgLCBwbHVzVGVuOiB7ICRhZGQ6IFsnJHZhbCcsIDEwXX1cbiAqICAgICAgICwgc3ViOiB7XG4gKiAgICAgICAgICAgIG5hbWU6ICckYSdcbiAqICAgICAgICAgfVxuICogICAgIH0pXG4gKlxuICogICAgIC8vIGV0Y1xuICogICAgIGFnZ3JlZ2F0ZS5wcm9qZWN0KHsgc2FsYXJ5X2s6IHsgJGRpdmlkZTogWyBcIiRzYWxhcnlcIiwgMTAwMCBdIH0gfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBhcmcgZmllbGQgc3BlY2lmaWNhdGlvblxuICogQHNlZSBwcm9qZWN0aW9uIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9hZ2dyZWdhdGlvbi9wcm9qZWN0L1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbihhcmcpIHtcbiAgY29uc3QgZmllbGRzID0ge307XG5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBPYmplY3Qua2V5cyhhcmcpLmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgIGZpZWxkc1tmaWVsZF0gPSBhcmdbZmllbGRdO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICBhcmcuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluY2x1ZGUgPSBmaWVsZFswXSA9PT0gJy0nID8gMCA6IDE7XG4gICAgICBpZiAoaW5jbHVkZSA9PT0gMCkge1xuICAgICAgICBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICAgIH1cbiAgICAgIGZpZWxkc1tmaWVsZF0gPSBpbmNsdWRlO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9qZWN0KCkgYXJndW1lbnQuIE11c3QgYmUgc3RyaW5nIG9yIG9iamVjdCcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJHByb2plY3Q6IGZpZWxkcyB9KTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyBjdXN0b20gJGdyb3VwIG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLmdyb3VwKHsgX2lkOiBcIiRkZXBhcnRtZW50XCIgfSk7XG4gKlxuICogQHNlZSAkZ3JvdXAgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL2dyb3VwL1xuICogQG1ldGhvZCBncm91cFxuICogQG1lbWJlck9mIEFnZ3JlZ2F0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnICRncm91cCBvcGVyYXRvciBjb250ZW50c1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgY3VzdG9tICRtYXRjaCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5tYXRjaCh7IGRlcGFydG1lbnQ6IHsgJGluOiBbIFwic2FsZXNcIiwgXCJlbmdpbmVlcmluZ1wiIF0gfSB9KTtcbiAqXG4gKiBAc2VlICRtYXRjaCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvYWdncmVnYXRpb24vbWF0Y2gvXG4gKiBAbWV0aG9kIG1hdGNoXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgJG1hdGNoIG9wZXJhdG9yIGNvbnRlbnRzXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyAkc2tpcCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5za2lwKDEwKTtcbiAqXG4gKiBAc2VlICRza2lwIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9hZ2dyZWdhdGlvbi9za2lwL1xuICogQG1ldGhvZCBza2lwXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gbnVtYmVyIG9mIHJlY29yZHMgdG8gc2tpcCBiZWZvcmUgbmV4dCBzdGFnZVxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJGxpbWl0IG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLmxpbWl0KDEwKTtcbiAqXG4gKiBAc2VlICRsaW1pdCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvYWdncmVnYXRpb24vbGltaXQvXG4gKiBAbWV0aG9kIGxpbWl0XG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gbWF4aW11bSBudW1iZXIgb2YgcmVjb3JkcyB0byBwYXNzIHRvIHRoZSBuZXh0IHN0YWdlXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRkZW5zaWZ5IG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgIGFnZ3JlZ2F0ZS5kZW5zaWZ5KHtcbiAqICAgICAgICBmaWVsZDogJ3RpbWVzdGFtcCcsXG4gKiAgICAgICAgcmFuZ2U6IHtcbiAqICAgICAgICAgIHN0ZXA6IDEsXG4gKiAgICAgICAgICB1bml0OiAnaG91cicsXG4gKiAgICAgICAgICBib3VuZHM6IFtuZXcgRGF0ZSgnMjAyMS0wNS0xOFQwMDowMDowMC4wMDBaJyksIG5ldyBEYXRlKCcyMDIxLTA1LTE4VDA4OjAwOjAwLjAwMFonKV1cbiAqICAgICAgICB9XG4gKiAgICAgIH0pO1xuICpcbiAqIEBzZWUgJGRlbnNpZnkgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2RlbnNpZnkvXG4gKiBAbWV0aG9kIGRlbnNpZnlcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGFyZyAkZGVuc2lmeSBvcGVyYXRvciBjb250ZW50c1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJGZpbGwgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAgYWdncmVnYXRlLmZpbGwoe1xuICogICAgICAgIG91dHB1dDoge1xuICogICAgICAgICAgYm9vdHNTb2xkOiB7IHZhbHVlOiAwIH0sXG4gKiAgICAgICAgICBzYW5kYWxzU29sZDogeyB2YWx1ZTogMCB9LFxuICogICAgICAgICAgc25lYWtlcnNTb2xkOiB7IHZhbHVlOiAwIH1cbiAqICAgICAgICB9XG4gKiAgICAgIH0pO1xuICpcbiAqIEBzZWUgJGZpbGwgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2ZpbGwvXG4gKiBAbWV0aG9kIGZpbGxcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGFyZyAkZmlsbCBvcGVyYXRvciBjb250ZW50c1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJGdlb05lYXIgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqICoqTVVTVCoqIGJlIHVzZWQgYXMgdGhlIGZpcnN0IG9wZXJhdG9yIGluIHRoZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5uZWFyKHtcbiAqICAgICAgIG5lYXI6IHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFs0MC43MjQsIC03My45OTddIH0sXG4gKiAgICAgICBkaXN0YW5jZUZpZWxkOiBcImRpc3QuY2FsY3VsYXRlZFwiLCAvLyByZXF1aXJlZFxuICogICAgICAgbWF4RGlzdGFuY2U6IDAuMDA4LFxuICogICAgICAgcXVlcnk6IHsgdHlwZTogXCJwdWJsaWNcIiB9LFxuICogICAgICAgaW5jbHVkZUxvY3M6IFwiZGlzdC5sb2NhdGlvblwiLFxuICogICAgICAgc3BoZXJpY2FsOiB0cnVlLFxuICogICAgIH0pO1xuICpcbiAqIEBzZWUgJGdlb05lYXIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL2dlb05lYXIvXG4gKiBAbWV0aG9kIG5lYXJcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGFyZ1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLm5lYXIgPSBmdW5jdGlvbihhcmcpIHtcbiAgY29uc3Qgb3AgPSB7fTtcbiAgb3AuJGdlb05lYXIgPSBhcmc7XG4gIHJldHVybiB0aGlzLmFwcGVuZChvcCk7XG59O1xuXG4vKiFcbiAqIGRlZmluZSBtZXRob2RzXG4gKi9cblxuJ2dyb3VwIG1hdGNoIHNraXAgbGltaXQgb3V0IGRlbnNpZnkgZmlsbCcuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKCRvcGVyYXRvcikge1xuICBBZ2dyZWdhdGUucHJvdG90eXBlWyRvcGVyYXRvcl0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICBjb25zdCBvcCA9IHt9O1xuICAgIG9wWyckJyArICRvcGVyYXRvcl0gPSBhcmc7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kKG9wKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEFwcGVuZHMgbmV3IGN1c3RvbSAkdW53aW5kIG9wZXJhdG9yKHMpIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgYCR1bndpbmRgIG9wZXJhdG9yIHJlcXVpcmVzIHRoZSBwYXRoIG5hbWUgdG8gc3RhcnQgd2l0aCAnJCcuXG4gKiBNb25nb29zZSB3aWxsIHByZXBlbmQgJyQnIGlmIHRoZSBzcGVjaWZpZWQgZmllbGQgZG9lc24ndCBzdGFydCAnJCcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUudW53aW5kKFwidGFnc1wiKTtcbiAqICAgICBhZ2dyZWdhdGUudW53aW5kKFwiYVwiLCBcImJcIiwgXCJjXCIpO1xuICogICAgIGFnZ3JlZ2F0ZS51bndpbmQoeyBwYXRoOiAnJHRhZ3MnLCBwcmVzZXJ2ZU51bGxBbmRFbXB0eUFycmF5czogdHJ1ZSB9KTtcbiAqXG4gKiBAc2VlICR1bndpbmQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL3Vud2luZC9cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxTdHJpbmdbXXxPYmplY3RbXX0gZmllbGRzIHRoZSBmaWVsZChzKSB0byB1bndpbmQsIGVpdGhlciBhcyBmaWVsZCBuYW1lcyBvciBhcyBbb2JqZWN0cyB3aXRoIG9wdGlvbnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi91bndpbmQvI2RvY3VtZW50LW9wZXJhbmQtd2l0aC1vcHRpb25zKS4gSWYgcGFzc2luZyBhIHN0cmluZywgcHJlZml4aW5nIHRoZSBmaWVsZCBuYW1lIHdpdGggJyQnIGlzIG9wdGlvbmFsLiBJZiBwYXNzaW5nIGFuIG9iamVjdCwgYHBhdGhgIG11c3Qgc3RhcnQgd2l0aCAnJCcuXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUudW53aW5kID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGFyZ3MgPSBbLi4uYXJndW1lbnRzXTtcblxuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGlmIChhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlcy5wdXNoKHsgJHVud2luZDogYXJnIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgJHVud2luZDogKGFyZ1swXSA9PT0gJyQnKSA/IGFyZyA6ICckJyArIGFyZ1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmcgXCInICsgYXJnICsgJ1wiIHRvIHVud2luZCgpLCAnICtcbiAgICAgICAgJ211c3QgYmUgc3RyaW5nIG9yIG9iamVjdCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLmFwcGVuZC5hcHBseSh0aGlzLCByZXMpO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRyZXBsYWNlUm9vdCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGAkcmVwbGFjZVJvb3RgIG9wZXJhdG9yIHJlcXVpcmVzIGZpZWxkIHN0cmluZ3MgdG8gc3RhcnQgd2l0aCAnJCcuXG4gKiBJZiB5b3UgYXJlIHBhc3NpbmcgaW4gYSBzdHJpbmcgTW9uZ29vc2Ugd2lsbCBwcmVwZW5kICckJyBpZiB0aGUgc3BlY2lmaWVkIGZpZWxkIGRvZXNuJ3Qgc3RhcnQgJyQnLlxuICogSWYgeW91IGFyZSBwYXNzaW5nIGluIGFuIG9iamVjdCB0aGUgc3RyaW5ncyBpbiB5b3VyIGV4cHJlc3Npb24gd2lsbCBub3QgYmUgYWx0ZXJlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5yZXBsYWNlUm9vdChcInVzZXJcIik7XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5yZXBsYWNlUm9vdCh7IHg6IHsgJGNvbmNhdDogWyckdGhpcycsICckdGhhdCddIH0gfSk7XG4gKlxuICogQHNlZSAkcmVwbGFjZVJvb3QgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL3JlcGxhY2VSb290XG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG5ld1Jvb3QgdGhlIGZpZWxkIG9yIGRvY3VtZW50IHdoaWNoIHdpbGwgYmVjb21lIHRoZSBuZXcgcm9vdCBkb2N1bWVudFxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnJlcGxhY2VSb290ID0gZnVuY3Rpb24obmV3Um9vdCkge1xuICBsZXQgcmV0O1xuXG4gIGlmICh0eXBlb2YgbmV3Um9vdCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXdSb290LnN0YXJ0c1dpdGgoJyQnKSA/IG5ld1Jvb3QgOiAnJCcgKyBuZXdSb290O1xuICB9IGVsc2Uge1xuICAgIHJldCA9IG5ld1Jvb3Q7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcHBlbmQoe1xuICAgICRyZXBsYWNlUm9vdDoge1xuICAgICAgbmV3Um9vdDogcmV0XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyAkY291bnQgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUuY291bnQoXCJ1c2VyQ291bnRcIik7XG4gKlxuICogQHNlZSAkY291bnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2NvdW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lIFRoZSBuYW1lIG9mIHRoZSBvdXRwdXQgZmllbGQgd2hpY2ggaGFzIHRoZSBjb3VudCBhcyBpdHMgdmFsdWUuIEl0IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLCBtdXN0IG5vdCBzdGFydCB3aXRoICQgYW5kIG11c3Qgbm90IGNvbnRhaW4gdGhlIC4gY2hhcmFjdGVyLlxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oZmllbGROYW1lKSB7XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRjb3VudDogZmllbGROYW1lIH0pO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRzb3J0QnlDb3VudCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS4gQWNjZXB0cyBlaXRoZXIgYSBzdHJpbmcgZmllbGQgbmFtZVxuICogb3IgYSBwaXBlbGluZSBvYmplY3QuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBgJHNvcnRCeUNvdW50YCBvcGVyYXRvciByZXF1aXJlcyB0aGUgbmV3IHJvb3QgdG8gc3RhcnQgd2l0aCAnJCcuXG4gKiBNb25nb29zZSB3aWxsIHByZXBlbmQgJyQnIGlmIHRoZSBzcGVjaWZpZWQgZmllbGQgbmFtZSBkb2Vzbid0IHN0YXJ0IHdpdGggJyQnLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLnNvcnRCeUNvdW50KCd1c2VycycpO1xuICogICAgIGFnZ3JlZ2F0ZS5zb3J0QnlDb3VudCh7ICRtZXJnZU9iamVjdHM6IFsgXCIkZW1wbG95ZWVcIiwgXCIkYnVzaW5lc3NcIiBdIH0pXG4gKlxuICogQHNlZSAkc29ydEJ5Q291bnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL3NvcnRCeUNvdW50L1xuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBhcmdcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnNvcnRCeUNvdW50ID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmIChhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkc29ydEJ5Q291bnQ6IGFyZyB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZCh7XG4gICAgICAkc29ydEJ5Q291bnQ6IChhcmdbMF0gPT09ICckJykgPyBhcmcgOiAnJCcgKyBhcmdcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZyBcIicgKyBhcmcgKyAnXCIgdG8gc29ydEJ5Q291bnQoKSwgJyArXG4gICAgICAnbXVzdCBiZSBzdHJpbmcgb3Igb2JqZWN0Jyk7XG4gIH1cbn07XG5cbi8qKlxuICogQXBwZW5kcyBuZXcgY3VzdG9tICRsb29rdXAgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUubG9va3VwKHsgZnJvbTogJ3VzZXJzJywgbG9jYWxGaWVsZDogJ3VzZXJJZCcsIGZvcmVpZ25GaWVsZDogJ19pZCcsIGFzOiAndXNlcnMnIH0pO1xuICpcbiAqIEBzZWUgJGxvb2t1cCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vbG9va3VwLyNwaXBlLl9TX2xvb2t1cFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gJGxvb2t1cCBhcyBkZXNjcmliZWQgaW4gdGhlIGFib3ZlIGxpbmtcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRsb29rdXA6IG9wdGlvbnMgfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgbmV3IGN1c3RvbSAkZ3JhcGhMb29rdXAgb3BlcmF0b3IocykgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUsIHBlcmZvcm1pbmcgYSByZWN1cnNpdmUgc2VhcmNoIG9uIGEgY29sbGVjdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgZ3JhcGhMb29rdXAgY2FuIG9ubHkgY29uc3VtZSBhdCBtb3N0IDEwME1CIG9mIG1lbW9yeSwgYW5kIGRvZXMgbm90IGFsbG93IGRpc2sgdXNlIGV2ZW4gaWYgYHsgYWxsb3dEaXNrVXNlOiB0cnVlIH1gIGlzIHNwZWNpZmllZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgICAvLyBTdXBwb3NlIHdlIGhhdmUgYSBjb2xsZWN0aW9uIG9mIGNvdXJzZXMsIHdoZXJlIGEgZG9jdW1lbnQgbWlnaHQgbG9vayBsaWtlIGB7IF9pZDogMCwgbmFtZTogJ0NhbGN1bHVzJywgcHJlcmVxdWlzaXRlOiAnVHJpZ29ub21ldHJ5J31gIGFuZCBgeyBfaWQ6IDAsIG5hbWU6ICdUcmlnb25vbWV0cnknLCBwcmVyZXF1aXNpdGU6ICdBbGdlYnJhJyB9YFxuICogICAgICBhZ2dyZWdhdGUuZ3JhcGhMb29rdXAoeyBmcm9tOiAnY291cnNlcycsIHN0YXJ0V2l0aDogJyRwcmVyZXF1aXNpdGUnLCBjb25uZWN0RnJvbUZpZWxkOiAncHJlcmVxdWlzaXRlJywgY29ubmVjdFRvRmllbGQ6ICduYW1lJywgYXM6ICdwcmVyZXF1aXNpdGVzJywgbWF4RGVwdGg6IDMgfSkgLy8gdGhpcyB3aWxsIHJlY3Vyc2l2ZWx5IHNlYXJjaCB0aGUgJ2NvdXJzZXMnIGNvbGxlY3Rpb24gdXAgdG8gMyBwcmVyZXF1aXNpdGVzXG4gKlxuICogQHNlZSAkZ3JhcGhMb29rdXAgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2dyYXBoTG9va3VwLyNwaXBlLl9TX2dyYXBoTG9va3VwXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0byAkZ3JhcGhMb29rdXAgYXMgZGVzY3JpYmVkIGluIHRoZSBhYm92ZSBsaW5rXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuZ3JhcGhMb29rdXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IGNsb25lT3B0aW9ucyA9IHt9O1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmICghdXRpbHMuaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZ3JhcGhMb29rdXAoKSBhcmd1bWVudC4gTXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgdXRpbHMubWVyZ2VDbG9uZShjbG9uZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHN0YXJ0V2l0aCA9IGNsb25lT3B0aW9ucy5zdGFydFdpdGg7XG5cbiAgICBpZiAoc3RhcnRXaXRoICYmIHR5cGVvZiBzdGFydFdpdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICBjbG9uZU9wdGlvbnMuc3RhcnRXaXRoID0gY2xvbmVPcHRpb25zLnN0YXJ0V2l0aC5zdGFydHNXaXRoKCckJykgP1xuICAgICAgICBjbG9uZU9wdGlvbnMuc3RhcnRXaXRoIDpcbiAgICAgICAgJyQnICsgY2xvbmVPcHRpb25zLnN0YXJ0V2l0aDtcbiAgICB9XG5cbiAgfVxuICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkZ3JhcGhMb29rdXA6IGNsb25lT3B0aW9ucyB9KTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBuZXcgY3VzdG9tICRzYW1wbGUgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUuc2FtcGxlKDMpOyAvLyBBZGQgYSBwaXBlbGluZSB0aGF0IHBpY2tzIDMgcmFuZG9tIGRvY3VtZW50c1xuICpcbiAqIEBzZWUgJHNhbXBsZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vc2FtcGxlLyNwaXBlLl9TX3NhbXBsZVxuICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgbnVtYmVyIG9mIHJhbmRvbSBkb2N1bWVudHMgdG8gcGlja1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnNhbXBsZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJHNhbXBsZTogeyBzaXplOiBzaXplIH0gfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJHNvcnQgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCwgdmFsdWVzIGFsbG93ZWQgYXJlIGBhc2NgLCBgZGVzY2AsIGBhc2NlbmRpbmdgLCBgZGVzY2VuZGluZ2AsIGAxYCwgYW5kIGAtMWAuXG4gKlxuICogSWYgYSBzdHJpbmcgaXMgcGFzc2VkLCBpdCBtdXN0IGJlIGEgc3BhY2UgZGVsaW1pdGVkIGxpc3Qgb2YgcGF0aCBuYW1lcy4gVGhlIHNvcnQgb3JkZXIgb2YgZWFjaCBwYXRoIGlzIGFzY2VuZGluZyB1bmxlc3MgdGhlIHBhdGggbmFtZSBpcyBwcmVmaXhlZCB3aXRoIGAtYCB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgYXMgZGVzY2VuZGluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHRoZXNlIGFyZSBlcXVpdmFsZW50XG4gKiAgICAgYWdncmVnYXRlLnNvcnQoeyBmaWVsZDogJ2FzYycsIHRlc3Q6IC0xIH0pO1xuICogICAgIGFnZ3JlZ2F0ZS5zb3J0KCdmaWVsZCAtdGVzdCcpO1xuICpcbiAqIEBzZWUgJHNvcnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL3NvcnQvXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGFyZ1xuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGFyZykge1xuICAvLyBUT0RPIHJlZmFjdG9yIHRvIHJldXNlIHRoZSBxdWVyeSBidWlsZGVyIGxvZ2ljXG5cbiAgY29uc3Qgc29ydCA9IHt9O1xuXG4gIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUoYXJnKSA9PT0gJ09iamVjdCcpIHtcbiAgICBjb25zdCBkZXNjID0gWydkZXNjJywgJ2Rlc2NlbmRpbmcnLCAtMV07XG4gICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAvLyBJZiBzb3J0aW5nIGJ5IHRleHQgc2NvcmUsIHNraXAgY29lcmNpbmcgaW50byAxLy0xXG4gICAgICBpZiAoYXJnW2ZpZWxkXSBpbnN0YW5jZW9mIE9iamVjdCAmJiBhcmdbZmllbGRdLiRtZXRhKSB7XG4gICAgICAgIHNvcnRbZmllbGRdID0gYXJnW2ZpZWxkXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc29ydFtmaWVsZF0gPSBkZXNjLmluZGV4T2YoYXJnW2ZpZWxkXSkgPT09IC0xID8gMSA6IC0xO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICBhcmcuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFzY2VuZCA9IGZpZWxkWzBdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICBpZiAoYXNjZW5kID09PSAtMSkge1xuICAgICAgICBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICAgIH1cbiAgICAgIHNvcnRbZmllbGRdID0gYXNjZW5kO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCgpIGFyZ3VtZW50LiBNdXN0IGJlIGEgc3RyaW5nIG9yIG9iamVjdC4nKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRzb3J0OiBzb3J0IH0pO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIG5ldyAkdW5pb25XaXRoIG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLnVuaW9uV2l0aCh7IGNvbGw6ICd1c2VycycsIHBpcGVsaW5lOiBbIHsgJG1hdGNoOiB7IF9pZDogMSB9IH0gXSB9KTtcbiAqXG4gKiBAc2VlICR1bmlvbldpdGggaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL3VuaW9uV2l0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gJHVuaW9uV2l0aCBxdWVyeSBhcyBkZXNjcmliZWQgaW4gdGhlIGFib3ZlIGxpbmtcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS51bmlvbldpdGggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICR1bmlvbldpdGg6IG9wdGlvbnMgfSk7XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgcmVhZFByZWZlcmVuY2Ugb3B0aW9uIGZvciB0aGUgYWdncmVnYXRpb24gcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUocGlwZWxpbmUpLnJlYWQoJ3ByaW1hcnlQcmVmZXJyZWQnKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWFkUHJlZmVyZW5jZX0gcHJlZiBvbmUgb2YgdGhlIGxpc3RlZCBwcmVmZXJlbmNlIG9wdGlvbnMgb3IgdGhlaXIgYWxpYXNlc1xuICogQHBhcmFtIHtBcnJheX0gW3RhZ3NdIG9wdGlvbmFsIHRhZ3MgZm9yIHRoaXMgcXVlcnkuXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2VcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihwcmVmLCB0YWdzKSB7XG4gIHJlYWQuY2FsbCh0aGlzLCBwcmVmLCB0YWdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlYWRDb25jZXJuIGxldmVsIGZvciB0aGUgYWdncmVnYXRpb24gcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUocGlwZWxpbmUpLnJlYWRDb25jZXJuKCdtYWpvcml0eScpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbCBvbmUgb2YgdGhlIGxpc3RlZCByZWFkIGNvbmNlcm4gbGV2ZWwgb3IgdGhlaXIgYWxpYXNlc1xuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9yZWFkLWNvbmNlcm4vXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5yZWFkQ29uY2VybiA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gIHJlYWRDb25jZXJuLmNhbGwodGhpcywgbGV2ZWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyAkcmVkYWN0IG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqIElmIDMgYXJndW1lbnRzIGFyZSBzdXBwbGllZCwgTW9uZ29vc2Ugd2lsbCB3cmFwIHRoZW0gd2l0aCBpZi10aGVuLWVsc2Ugb2YgJGNvbmQgb3BlcmF0b3IgcmVzcGVjdGl2ZWx5XG4gKiBJZiBgdGhlbkV4cHJgIG9yIGBlbHNlRXhwcmAgaXMgc3RyaW5nLCBtYWtlIHN1cmUgaXQgc3RhcnRzIHdpdGggJCQsIGxpa2UgYCQkREVTQ0VORGAsIGAkJFBSVU5FYCBvciBgJCRLRUVQYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IE1vZGVsLmFnZ3JlZ2F0ZShwaXBlbGluZSkucmVkYWN0KHtcbiAqICAgICAgICRjb25kOiB7XG4gKiAgICAgICAgIGlmOiB7ICRlcTogWyAnJGxldmVsJywgNSBdIH0sXG4gKiAgICAgICAgIHRoZW46ICckJFBSVU5FJyxcbiAqICAgICAgICAgZWxzZTogJyQkREVTQ0VORCdcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gJHJlZGFjdCBvZnRlbiBjb21lcyB3aXRoICRjb25kIG9wZXJhdG9yLCB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgc3ludGF4IHByb3ZpZGVkIGJ5IG1vbmdvb3NlXG4gKiAgICAgYXdhaXQgTW9kZWwuYWdncmVnYXRlKHBpcGVsaW5lKS5yZWRhY3QoeyAkZXE6IFsgJyRsZXZlbCcsIDUgXSB9LCAnJCRQUlVORScsICckJERFU0NFTkQnKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXhwcmVzc2lvbiByZWRhY3Qgb3B0aW9ucyBvciBjb25kaXRpb25hbCBleHByZXNzaW9uXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IFt0aGVuRXhwcl0gdHJ1ZSBjYXNlIGZvciB0aGUgY29uZGl0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IFtlbHNlRXhwcl0gZmFsc2UgY2FzZSBmb3IgdGhlIGNvbmRpdGlvblxuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAc2VlICRyZWRhY3QgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL3JlZGFjdC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5yZWRhY3QgPSBmdW5jdGlvbihleHByZXNzaW9uLCB0aGVuRXhwciwgZWxzZUV4cHIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAoKHR5cGVvZiB0aGVuRXhwciA9PT0gJ3N0cmluZycgJiYgIXZhbGlkUmVkYWN0U3RyaW5nVmFsdWVzLmhhcyh0aGVuRXhwcikpIHx8XG4gICAgICAodHlwZW9mIGVsc2VFeHByID09PSAnc3RyaW5nJyAmJiAhdmFsaWRSZWRhY3RTdHJpbmdWYWx1ZXMuaGFzKGVsc2VFeHByKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWYgdGhlbkV4cHIgb3IgZWxzZUV4cHIgaXMgc3RyaW5nLCBpdCBtdXN0IGJlIGVpdGhlciAkJERFU0NFTkQsICQkUFJVTkUgb3IgJCRLRUVQJyk7XG4gICAgfVxuXG4gICAgZXhwcmVzc2lvbiA9IHtcbiAgICAgICRjb25kOiB7XG4gICAgICAgIGlmOiBleHByZXNzaW9uLFxuICAgICAgICB0aGVuOiB0aGVuRXhwcixcbiAgICAgICAgZWxzZTogZWxzZUV4cHJcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJHJlZGFjdDogZXhwcmVzc2lvbiB9KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgYWdncmVnYXRpb24gd2l0aCBleHBsYWluXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBNb2RlbC5hZ2dyZWdhdGUoLi4pLmV4cGxhaW4oKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdmVyYm9zaXR5XVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmV4cGxhaW4gPSBhc3luYyBmdW5jdGlvbiBleHBsYWluKHZlcmJvc2l0eSkge1xuICBpZiAodHlwZW9mIHZlcmJvc2l0eSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0FnZ3JlZ2F0ZS5wcm90b3R5cGUuZXhwbGFpbigpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICBjb25zdCBtb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gIGlmICghdGhpcy5fcGlwZWxpbmUubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZ2dyZWdhdGUgaGFzIGVtcHR5IHBpcGVsaW5lJyk7XG4gIH1cblxuICBwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lKHRoaXMuX3BpcGVsaW5lLCB0aGlzLl9tb2RlbC5zY2hlbWEpO1xuXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBtb2RlbC5ob29rcy5leGVjUHJlKCdhZ2dyZWdhdGUnLCB0aGlzLCBlcnJvciA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgX29wdHMgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgICAgICByZXR1cm4gbW9kZWwuaG9va3MuZXhlY1Bvc3QoJ2FnZ3JlZ2F0ZScsIHRoaXMsIFtudWxsXSwgX29wdHMsIGVycm9yID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgY29uc3QgY3Vyc29yID0gbW9kZWwuY29sbGVjdGlvbi5hZ2dyZWdhdGUodGhpcy5fcGlwZWxpbmUsIHRoaXMub3B0aW9ucyk7XG5cbiAgaWYgKHZlcmJvc2l0eSA9PSBudWxsKSB7XG4gICAgdmVyYm9zaXR5ID0gdHJ1ZTtcbiAgfVxuXG4gIGxldCByZXN1bHQgPSBudWxsO1xuICB0cnkge1xuICAgIHJlc3VsdCA9IGF3YWl0IGN1cnNvci5leHBsYWluKHZlcmJvc2l0eSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgX29wdHMgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgICAgbW9kZWwuaG9va3MuZXhlY1Bvc3QoJ2FnZ3JlZ2F0ZScsIHRoaXMsIFtudWxsXSwgX29wdHMsIGVycm9yID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgX29wdHMgPSB7IGVycm9yOiBudWxsIH07XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBtb2RlbC5ob29rcy5leGVjUG9zdCgnYWdncmVnYXRlJywgdGhpcywgW3Jlc3VsdF0sIF9vcHRzLCBlcnJvciA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBhbGxvd0Rpc2tVc2Ugb3B0aW9uIGZvciB0aGUgYWdncmVnYXRpb24gcXVlcnlcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IE1vZGVsLmFnZ3JlZ2F0ZShbeyAkbWF0Y2g6IHsgZm9vOiAnYmFyJyB9IH1dKS5hbGxvd0Rpc2tVc2UodHJ1ZSk7XG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBTaG91bGQgdGVsbCBzZXJ2ZXIgaXQgY2FuIHVzZSBoYXJkIGRyaXZlIHRvIHN0b3JlIGRhdGEgZHVyaW5nIGFnZ3JlZ2F0aW9uLlxuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvYWdncmVnYXRlL1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuYWxsb3dEaXNrVXNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5vcHRpb25zLmFsbG93RGlza1VzZSA9IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgaGludCBvcHRpb24gZm9yIHRoZSBhZ2dyZWdhdGlvbiBxdWVyeVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTW9kZWwuYWdncmVnYXRlKC4uKS5oaW50KHsgcXR5OiAxLCBjYXRlZ29yeTogMSB9KS5leGVjKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWx1ZSBhIGhpbnQgb2JqZWN0IG9yIHRoZSBpbmRleCBuYW1lXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9hZ2dyZWdhdGUvXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5oaW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5vcHRpb25zLmhpbnQgPSB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNlc3Npb24gZm9yIHRoaXMgYWdncmVnYXRpb24uIFVzZWZ1bCBmb3IgW3RyYW5zYWN0aW9uc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBNb2RlbC5zdGFydFNlc3Npb24oKTtcbiAqICAgICBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUoLi4pLnNlc3Npb24oc2Vzc2lvbik7XG4gKlxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBzZXNzaW9uXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9hZ2dyZWdhdGUvXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5zZXNzaW9uID0gZnVuY3Rpb24oc2Vzc2lvbikge1xuICBpZiAoc2Vzc2lvbiA9PSBudWxsKSB7XG4gICAgZGVsZXRlIHRoaXMub3B0aW9ucy5zZXNzaW9uO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTGV0cyB5b3Ugc2V0IGFyYml0cmFyeSBvcHRpb25zLCBmb3IgbWlkZGxld2FyZSBvciBwbHVnaW5zLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgYWdnID0gTW9kZWwuYWdncmVnYXRlKC4uKS5vcHRpb24oeyBhbGxvd0Rpc2tVc2U6IHRydWUgfSk7IC8vIFNldCB0aGUgYGFsbG93RGlza1VzZWAgb3B0aW9uXG4gKiAgICAgYWdnLm9wdGlvbnM7IC8vIGB7IGFsbG93RGlza1VzZTogdHJ1ZSB9YFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGtleXMgdG8gbWVyZ2UgaW50byBjdXJyZW50IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhUaW1lTVNdIG51bWJlciBsaW1pdHMgdGhlIHRpbWUgdGhpcyBhZ2dyZWdhdGlvbiB3aWxsIHJ1biwgc2VlIFtNb25nb0RCIGRvY3Mgb24gYG1heFRpbWVNU2BdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9tZXRhL21heFRpbWVNUy8pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93RGlza1VzZV0gYm9vbGVhbiBpZiB0cnVlLCB0aGUgTW9uZ29EQiBzZXJ2ZXIgd2lsbCB1c2UgdGhlIGhhcmQgZHJpdmUgdG8gc3RvcmUgZGF0YSBkdXJpbmcgdGhpcyBhZ2dyZWdhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNvbGxhdGlvbl0gb2JqZWN0IHNlZSBbYEFnZ3JlZ2F0ZS5wcm90b3R5cGUuY29sbGF0aW9uKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuY29sbGF0aW9uKCkpXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb25dIENsaWVudFNlc3Npb24gc2VlIFtgQWdncmVnYXRlLnByb3RvdHlwZS5zZXNzaW9uKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuc2Vzc2lvbigpKVxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2FnZ3JlZ2F0ZS9cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLm9wdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZVtrZXldO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgY3Vyc29yYCBvcHRpb24gYW5kIGV4ZWN1dGVzIHRoaXMgYWdncmVnYXRpb24sIHJldHVybmluZyBhbiBhZ2dyZWdhdGlvbiBjdXJzb3IuXG4gKiBDdXJzb3JzIGFyZSB1c2VmdWwgaWYgeW91IHdhbnQgdG8gcHJvY2VzcyB0aGUgcmVzdWx0cyBvZiB0aGUgYWdncmVnYXRpb24gb25lLWF0LWEtdGltZVxuICogYmVjYXVzZSB0aGUgYWdncmVnYXRpb24gcmVzdWx0IGlzIHRvbyBiaWcgdG8gZml0IGludG8gbWVtb3J5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY3Vyc29yID0gTW9kZWwuYWdncmVnYXRlKC4uKS5jdXJzb3IoeyBiYXRjaFNpemU6IDEwMDAgfSk7XG4gKiAgICAgY3Vyc29yLmVhY2hBc3luYyhmdW5jdGlvbihkb2MsIGkpIHtcbiAqICAgICAgIC8vIHVzZSBkb2NcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhdGNoU2l6ZV0gc2V0IHRoZSBjdXJzb3IgYmF0Y2ggc2l6ZVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VNb25nb29zZUFnZ0N1cnNvcl0gdXNlIGV4cGVyaW1lbnRhbCBtb25nb29zZS1zcGVjaWZpYyBhZ2dyZWdhdGlvbiBjdXJzb3IgKGZvciBgZWFjaEFzeW5jKClgIGFuZCBvdGhlciBxdWVyeSBjdXJzb3Igc2VtYW50aWNzKVxuICogQHJldHVybiB7QWdncmVnYXRpb25DdXJzb3J9IGN1cnNvciByZXByZXNlbnRpbmcgdGhpcyBhZ2dyZWdhdGlvblxuICogQGFwaSBwdWJsaWNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQWdncmVnYXRpb25DdXJzb3IuaHRtbFxuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuY3Vyc29yID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMuY3Vyc29yID0gb3B0aW9ucyB8fCB7fTtcbiAgcmV0dXJuIG5ldyBBZ2dyZWdhdGlvbkN1cnNvcih0aGlzKTsgLy8gcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjb2xsYXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IE1vZGVsLmFnZ3JlZ2F0ZShwaXBlbGluZSkuY29sbGF0aW9uKHsgbG9jYWxlOiAnZW5fVVMnLCBzdHJlbmd0aDogMSB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29sbGF0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvQ29sbGF0aW9uT3B0aW9ucy5odG1sXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5jb2xsYXRpb24gPSBmdW5jdGlvbihjb2xsYXRpb24pIHtcbiAgdGhpcy5vcHRpb25zLmNvbGxhdGlvbiA9IGNvbGxhdGlvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IE1vZGVsLmFnZ3JlZ2F0ZSgpLmZhY2V0KHtcbiAqICAgICAgIGJvb2tzOiBbeyBncm91cEJ5OiAnJGF1dGhvcicgfV0sXG4gKiAgICAgICBwcmljZTogW3sgJGJ1Y2tldEF1dG86IHsgZ3JvdXBCeTogJyRwcmljZScsIGJ1Y2tldHM6IDIgfSB9XVxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBPdXRwdXQ6IHsgYm9va3M6IFsuLi5dLCBwcmljZTogW3suLi59LCB7Li4ufV0gfVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmYWNldCBvcHRpb25zXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBzZWUgJGZhY2V0IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi9mYWNldC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5mYWNldCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJGZhY2V0OiBvcHRpb25zIH0pO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIFtBdGxhcyBUZXh0IFNlYXJjaF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9hdGxhcy9hdGxhcy1zZWFyY2gvdHV0b3JpYWwvKSdzXG4gKiBgJHNlYXJjaGAgc3RhZ2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUoKS5cbiAqICAgICAgc2VhcmNoKHtcbiAqICAgICAgICB0ZXh0OiB7XG4gKiAgICAgICAgICBxdWVyeTogJ2Jhc2ViYWxsJyxcbiAqICAgICAgICAgIHBhdGg6ICdwbG90J1xuICogICAgICAgIH1cbiAqICAgICAgfSk7XG4gKlxuICogICAgIC8vIE91dHB1dDogW3sgcGxvdDogJy4uLicsIHRpdGxlOiAnLi4uJyB9XVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAkc2VhcmNoIG9wdGlvbnNcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQHNlZSAkc2VhcmNoIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvYXRsYXMvYXRsYXMtc2VhcmNoL3R1dG9yaWFsL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJHNlYXJjaDogb3B0aW9ucyB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBwaXBlbGluZVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTXlNb2RlbC5hZ2dyZWdhdGUoKS5tYXRjaCh7IHRlc3Q6IDEgfSkucGlwZWxpbmUoKTsgLy8gW3sgJG1hdGNoOiB7IHRlc3Q6IDEgfSB9XVxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgY3VycmVudCBwaXBlbGluZSBzaW1pbGFyIHRvIHRoZSBvcGVyYXRpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUucGlwZWxpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3BpcGVsaW5lO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgYWdncmVnYXRlIHBpcGVsaW5lIG9uIHRoZSBjdXJyZW50bHkgYm91bmQgTW9kZWwuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFnZ3JlZ2F0ZS5leGVjKCk7XG4gKlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5leGVjID0gYXN5bmMgZnVuY3Rpb24gZXhlYygpIHtcbiAgaWYgKCF0aGlzLl9tb2RlbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWdncmVnYXRlIG5vdCBib3VuZCB0byBhbnkgTW9kZWwnKTtcbiAgfVxuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdBZ2dyZWdhdGUucHJvdG90eXBlLmV4ZWMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgY29uc3QgbW9kZWwgPSB0aGlzLl9tb2RlbDtcbiAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMuX21vZGVsLmNvbGxlY3Rpb247XG5cbiAgYXBwbHlHbG9iYWxNYXhUaW1lTVModGhpcy5vcHRpb25zLCBtb2RlbCk7XG4gIGFwcGx5R2xvYmFsRGlza1VzZSh0aGlzLm9wdGlvbnMsIG1vZGVsKTtcblxuICBjb25zdCBhc3luY0xvY2FsU3RvcmFnZSA9IHRoaXMubW9kZWwoKT8uZGI/LmJhc2UudHJhbnNhY3Rpb25Bc3luY0xvY2FsU3RvcmFnZT8uZ2V0U3RvcmUoKTtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3Nlc3Npb24nKSAmJiBhc3luY0xvY2FsU3RvcmFnZT8uc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgdGhpcy5vcHRpb25zLnNlc3Npb24gPSBhc3luY0xvY2FsU3RvcmFnZS5zZXNzaW9uO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuY3Vyc29yKSB7XG4gICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGlvbkN1cnNvcih0aGlzKTtcbiAgfVxuXG4gIHByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUodGhpcy5fcGlwZWxpbmUsIHRoaXMuX21vZGVsLnNjaGVtYSk7XG4gIHN0cmluZ2lmeUZ1bmN0aW9uT3BlcmF0b3JzKHRoaXMuX3BpcGVsaW5lKTtcblxuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbW9kZWwuaG9va3MuZXhlY1ByZSgnYWdncmVnYXRlJywgdGhpcywgZXJyb3IgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IF9vcHRzID0geyBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmhvb2tzLmV4ZWNQb3N0KCdhZ2dyZWdhdGUnLCB0aGlzLCBbbnVsbF0sIF9vcHRzLCBlcnJvciA9PiB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmICghdGhpcy5fcGlwZWxpbmUubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0FnZ3JlZ2F0ZSBoYXMgZW1wdHkgcGlwZWxpbmUnKTtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBjbG9uZSh0aGlzLm9wdGlvbnMgfHwge30pO1xuICBsZXQgcmVzdWx0O1xuICB0cnkge1xuICAgIGNvbnN0IGN1cnNvciA9IGF3YWl0IGNvbGxlY3Rpb24uYWdncmVnYXRlKHRoaXMuX3BpcGVsaW5lLCBvcHRpb25zKTtcbiAgICByZXN1bHQgPSBhd2FpdCBjdXJzb3IudG9BcnJheSgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IF9vcHRzID0geyBlcnJvcjogZXJyb3IgfTtcbiAgICAgIG1vZGVsLmhvb2tzLmV4ZWNQb3N0KCdhZ2dyZWdhdGUnLCB0aGlzLCBbbnVsbF0sIF9vcHRzLCAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IF9vcHRzID0geyBlcnJvcjogbnVsbCB9O1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbW9kZWwuaG9va3MuZXhlY1Bvc3QoJ2FnZ3JlZ2F0ZScsIHRoaXMsIFtyZXN1bHRdLCBfb3B0cywgZXJyb3IgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgYSBQcm9taXNlLWxpa2UgYHRoZW5gIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGNhbGwgYC5leGVjYCB3aXRob3V0IGEgY2FsbGJhY2tcbiAqIENvbXBhdGlibGUgd2l0aCBgYXdhaXRgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTW9kZWwuYWdncmVnYXRlKC4uKS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVdIHN1Y2Nlc3NDYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF0gIGVycm9yQ2FsbGJhY2tcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICByZXR1cm4gdGhpcy5leGVjKCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgYWdncmVnYXRpb24gcmV0dXJuaW5nIGEgYFByb21pc2VgIHdoaWNoIHdpbGwgYmVcbiAqIHJlc29sdmVkIHdpdGggZWl0aGVyIHRoZSBkb2Mocykgb3IgcmVqZWN0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBMaWtlIFtgLnRoZW4oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUudGhlbiksIGJ1dCBvbmx5IHRha2VzIGEgcmVqZWN0aW9uIGhhbmRsZXIuXG4gKiBDb21wYXRpYmxlIHdpdGggYGF3YWl0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVqZWN0XVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKHJlamVjdCkge1xuICByZXR1cm4gdGhpcy5leGVjKCkudGhlbihudWxsLCByZWplY3QpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgYWdncmVnYXRlIHJldHVybmluZyBhIGBQcm9taXNlYCB3aGljaCB3aWxsIGJlXG4gKiByZXNvbHZlZCB3aXRoIGAuZmluYWxseSgpYCBjaGFpbmVkLlxuICpcbiAqIE1vcmUgYWJvdXQgW1Byb21pc2UgYGZpbmFsbHkoKWAgaW4gSmF2YVNjcmlwdF0oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS91c2luZy1wcm9taXNlLWZpbmFsbHktaW4tbm9kZS1qcy5odG1sKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GaW5hbGx5XVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24ob25GaW5hbGx5KSB7XG4gIHJldHVybiB0aGlzLmV4ZWMoKS5maW5hbGx5KG9uRmluYWxseSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXN5bmNJdGVyYXRvciBmb3IgdXNlIHdpdGggW2Bmb3IvYXdhaXQvb2ZgIGxvb3BzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2dldHRpbmctc3RhcnRlZC13aXRoLWFzeW5jLWl0ZXJhdG9ycy1pbi1ub2RlLWpzKVxuICogWW91IGRvIG5vdCBuZWVkIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiBleHBsaWNpdGx5LCB0aGUgSmF2YVNjcmlwdCBydW50aW1lXG4gKiB3aWxsIGNhbGwgaXQgZm9yIHlvdS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGFnZyA9IE1vZGVsLmFnZ3JlZ2F0ZShbeyAkbWF0Y2g6IHsgYWdlOiB7ICRndGU6IDI1IH0gfSB9XSk7XG4gKiAgICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2YgYWdnKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MubmFtZSk7XG4gKiAgICAgfVxuICpcbiAqIE5vZGUuanMgMTAueCBzdXBwb3J0cyBhc3luYyBpdGVyYXRvcnMgbmF0aXZlbHkgd2l0aG91dCBhbnkgZmxhZ3MuIFlvdSBjYW5cbiAqIGVuYWJsZSBhc3luYyBpdGVyYXRvcnMgaW4gTm9kZS5qcyA4LnggdXNpbmcgdGhlIFtgLS1oYXJtb255X2FzeW5jX2l0ZXJhdGlvbmAgZmxhZ10oaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXN5bmMtaXRlcmF0aW9uL2lzc3Vlcy8xMTcjaXNzdWVjb21tZW50LTM0NjY5NTE4NykuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgbm90IHNldCBpZiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIHVuZGVmaW5lZC4gSWZcbiAqIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgaXMgdW5kZWZpbmVkLCB0aGF0IG1lYW5zIHlvdXIgTm9kZS5qcyB2ZXJzaW9uIGRvZXMgbm90XG4gKiBzdXBwb3J0IGFzeW5jIGl0ZXJhdG9ycy5cbiAqXG4gKiBAbWV0aG9kIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl1cbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgIT0gbnVsbCkge1xuICBBZ2dyZWdhdGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnNvcih7IHVzZU1vbmdvb3NlQWdnQ3Vyc29yOiB0cnVlIH0pLnRyYW5zZm9ybU51bGwoKS5fdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcigpO1xuICB9O1xufVxuXG4vKiFcbiAqIEhlbHBlcnNcbiAqL1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGFuIG9iamVjdCBpcyBsaWtlbHkgYSBwaXBlbGluZSBvcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogb2JqZWN0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNPcGVyYXRvcihvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGsgPSBPYmplY3Qua2V5cyhvYmopO1xuXG4gIHJldHVybiBrLmxlbmd0aCA9PT0gMSAmJiBrWzBdWzBdID09PSAnJCc7XG59XG5cbi8qKlxuICogQWRkcyB0aGUgYXBwcm9wcmlhdGUgYCRtYXRjaGAgcGlwZWxpbmUgc3RlcCB0byB0aGUgdG9wIG9mIGFuIGFnZ3JlZ2F0ZSdzXG4gKiBwaXBlbGluZSwgc2hvdWxkIGl0J3MgbW9kZWwgaXMgYSBub24tcm9vdCBkaXNjcmltaW5hdG9yIHR5cGUuIFRoaXMgaXNcbiAqIGFuYWxvZ291cyB0byB0aGUgYHByZXBhcmVEaXNjcmltaW5hdG9yQ3JpdGVyaWFgIGZ1bmN0aW9uIGluIGBsaWIvcXVlcnkuanNgLlxuICpcbiAqIEBwYXJhbSB7QWdncmVnYXRlfSBhZ2dyZWdhdGUgQWdncmVnYXRlIHRvIHByZXBhcmVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkFnZ3JlZ2F0ZS5fcHJlcGFyZURpc2NyaW1pbmF0b3JQaXBlbGluZSA9IHByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmU7XG5cbi8qIVxuICogRXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQWdncmVnYXRlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/aggregate.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/browserDocument.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/browserDocument.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst NodeJSDocument = __webpack_require__(/*! ./document */ \"(api)/../server/node_modules/mongoose/lib/document.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"(api)/../server/node_modules/mongoose/lib/schema.js\");\nconst ObjectId = __webpack_require__(/*! ./types/objectid */ \"(api)/../server/node_modules/mongoose/lib/types/objectid.js\");\nconst ValidationError = MongooseError.ValidationError;\nconst applyHooks = __webpack_require__(/*! ./helpers/model/applyHooks */ \"(api)/../server/node_modules/mongoose/lib/helpers/model/applyHooks.js\");\nconst isObject = __webpack_require__(/*! ./helpers/isObject */ \"(api)/../server/node_modules/mongoose/lib/helpers/isObject.js\");\n\n/**\n * Document constructor.\n *\n * @param {Object} obj the values to set\n * @param {Object} schema\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, schema, fields, skipId, skipInit) {\n  if (!(this instanceof Document)) {\n    return new Document(obj, schema, fields, skipId, skipInit);\n  }\n\n  if (isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n\n  // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id\n  schema = this.schema || schema;\n\n  // Generate ObjectId if it is missing, but it requires a scheme\n  if (!this.schema && schema.options._id) {\n    obj = obj || {};\n\n    if (obj._id === undefined) {\n      obj._id = new ObjectId();\n    }\n  }\n\n  if (!schema) {\n    throw new MongooseError.MissingSchemaError();\n  }\n\n  this.$__setSchema(schema);\n\n  NodeJSDocument.call(this, obj, fields, skipId, skipInit);\n\n  applyHooks(this, schema, { decorateDoc: true });\n\n  // apply methods\n  for (const m in schema.methods) {\n    this[m] = schema.methods[m];\n  }\n  // apply statics\n  for (const s in schema.statics) {\n    this[s] = schema.statics[s];\n  }\n}\n\n/*!\n * Inherit from the NodeJS document\n */\n\nDocument.prototype = Object.create(NodeJSDocument.prototype);\nDocument.prototype.constructor = Document;\n\n/*!\n * ignore\n */\n\nDocument.events = new EventEmitter();\n\n/*!\n * Browser doc exposes the event emitter API\n */\n\nDocument.$emitter = new EventEmitter();\n\n['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n  'removeAllListeners', 'addListener'].forEach(function(emitterFn) {\n  Document[emitterFn] = function() {\n    return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);\n  };\n});\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvYnJvd3NlckRvY3VtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYix1QkFBdUIsbUJBQU8sQ0FBQyx5RUFBWTtBQUMzQyxxQkFBcUIsMERBQThCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLCtFQUFlO0FBQzdDLGVBQWUsbUJBQU8sQ0FBQyxxRUFBVTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBa0I7QUFDM0M7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyx5R0FBNEI7QUFDdkQsaUJBQWlCLG1CQUFPLENBQUMseUZBQW9COztBQUU3QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcYnJvd3NlckRvY3VtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE5vZGVKU0RvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudCcpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IFNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hJyk7XG5jb25zdCBPYmplY3RJZCA9IHJlcXVpcmUoJy4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IE1vbmdvb3NlRXJyb3IuVmFsaWRhdGlvbkVycm9yO1xuY29uc3QgYXBwbHlIb29rcyA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9hcHBseUhvb2tzJyk7XG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc09iamVjdCcpO1xuXG4vKipcbiAqIERvY3VtZW50IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIHZhbHVlcyB0byBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmllbGRzXSBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyB0aGUgZmllbGRzIHdoaWNoIHdlcmUgc2VsZWN0ZWQgaW4gdGhlIHF1ZXJ5IHJldHVybmluZyB0aGlzIGRvY3VtZW50IGFuZCBhbnkgcG9wdWxhdGVkIHBhdGhzIGRhdGFcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBJZF0gYm9vbCwgc2hvdWxkIHdlIGF1dG8gY3JlYXRlIGFuIE9iamVjdElkIF9pZFxuICogQGluaGVyaXRzIE5vZGVKUyBFdmVudEVtaXR0ZXIgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNjbGFzcy1ldmVudGVtaXR0ZXJcbiAqIEBldmVudCBgaW5pdGA6IEVtaXR0ZWQgb24gYSBkb2N1bWVudCBhZnRlciBpdCBoYXMgd2FzIHJldHJpZXZlZCBmcm9tIHRoZSBkYiBhbmQgZnVsbHkgaHlkcmF0ZWQgYnkgTW9uZ29vc2UuXG4gKiBAZXZlbnQgYHNhdmVgOiBFbWl0dGVkIHdoZW4gdGhlIGRvY3VtZW50IGlzIHN1Y2Nlc3NmdWxseSBzYXZlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gRG9jdW1lbnQob2JqLCBzY2hlbWEsIGZpZWxkcywgc2tpcElkLCBza2lwSW5pdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudChvYmosIHNjaGVtYSwgZmllbGRzLCBza2lwSWQsIHNraXBJbml0KTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChzY2hlbWEpICYmICFzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgIHNjaGVtYSA9IG5ldyBTY2hlbWEoc2NoZW1hKTtcbiAgfVxuXG4gIC8vIFdoZW4gY3JlYXRpbmcgRW1iZWRkZWREb2N1bWVudCwgaXQgYWxyZWFkeSBoYXMgdGhlIHNjaGVtYSBhbmQgaGUgZG9lc24ndCBuZWVkIHRoZSBfaWRcbiAgc2NoZW1hID0gdGhpcy5zY2hlbWEgfHwgc2NoZW1hO1xuXG4gIC8vIEdlbmVyYXRlIE9iamVjdElkIGlmIGl0IGlzIG1pc3NpbmcsIGJ1dCBpdCByZXF1aXJlcyBhIHNjaGVtZVxuICBpZiAoIXRoaXMuc2NoZW1hICYmIHNjaGVtYS5vcHRpb25zLl9pZCkge1xuICAgIG9iaiA9IG9iaiB8fCB7fTtcblxuICAgIGlmIChvYmouX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9iai5faWQgPSBuZXcgT2JqZWN0SWQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNjaGVtYSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yLk1pc3NpbmdTY2hlbWFFcnJvcigpO1xuICB9XG5cbiAgdGhpcy4kX19zZXRTY2hlbWEoc2NoZW1hKTtcblxuICBOb2RlSlNEb2N1bWVudC5jYWxsKHRoaXMsIG9iaiwgZmllbGRzLCBza2lwSWQsIHNraXBJbml0KTtcblxuICBhcHBseUhvb2tzKHRoaXMsIHNjaGVtYSwgeyBkZWNvcmF0ZURvYzogdHJ1ZSB9KTtcblxuICAvLyBhcHBseSBtZXRob2RzXG4gIGZvciAoY29uc3QgbSBpbiBzY2hlbWEubWV0aG9kcykge1xuICAgIHRoaXNbbV0gPSBzY2hlbWEubWV0aG9kc1ttXTtcbiAgfVxuICAvLyBhcHBseSBzdGF0aWNzXG4gIGZvciAoY29uc3QgcyBpbiBzY2hlbWEuc3RhdGljcykge1xuICAgIHRoaXNbc10gPSBzY2hlbWEuc3RhdGljc1tzXTtcbiAgfVxufVxuXG4vKiFcbiAqIEluaGVyaXQgZnJvbSB0aGUgTm9kZUpTIGRvY3VtZW50XG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlSlNEb2N1bWVudC5wcm90b3R5cGUpO1xuRG9jdW1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9jdW1lbnQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRG9jdW1lbnQuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4vKiFcbiAqIEJyb3dzZXIgZG9jIGV4cG9zZXMgdGhlIGV2ZW50IGVtaXR0ZXIgQVBJXG4gKi9cblxuRG9jdW1lbnQuJGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblsnb24nLCAnb25jZScsICdlbWl0JywgJ2xpc3RlbmVycycsICdyZW1vdmVMaXN0ZW5lcicsICdzZXRNYXhMaXN0ZW5lcnMnLFxuICAncmVtb3ZlQWxsTGlzdGVuZXJzJywgJ2FkZExpc3RlbmVyJ10uZm9yRWFjaChmdW5jdGlvbihlbWl0dGVyRm4pIHtcbiAgRG9jdW1lbnRbZW1pdHRlckZuXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBEb2N1bWVudC4kZW1pdHRlcltlbWl0dGVyRm5dLmFwcGx5KERvY3VtZW50LiRlbWl0dGVyLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuRG9jdW1lbnQuVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gRG9jdW1lbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/browserDocument.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/cast.js":
/*!***************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ./error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\nconst StrictModeError = __webpack_require__(/*! ./error/strict */ \"(api)/../server/node_modules/mongoose/lib/error/strict.js\");\nconst Types = __webpack_require__(/*! ./schema/index */ \"(api)/../server/node_modules/mongoose/lib/schema/index.js\");\nconst cast$expr = __webpack_require__(/*! ./helpers/query/cast$expr */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/cast$expr.js\");\nconst castString = __webpack_require__(/*! ./cast/string */ \"(api)/../server/node_modules/mongoose/lib/cast/string.js\");\nconst castTextSearch = __webpack_require__(/*! ./schema/operators/text */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/text.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getSchemaDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getSchemaDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\");\nconst isOperator = __webpack_require__(/*! ./helpers/query/isOperator */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/isOperator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst isObject = __webpack_require__(/*! ./helpers/isObject */ \"(api)/../server/node_modules/mongoose/lib/helpers/isObject.js\");\nconst isMongooseObject = __webpack_require__(/*! ./helpers/isMongooseObject */ \"(api)/../server/node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} [options] the query options\n * @param {Boolean|\"throw\"} [options.strict] Wheter to enable all strict options\n * @param {Boolean|\"throw\"} [options.strictQuery] Enable strict Queries\n * @param {Boolean} [options.upsert]\n * @param {Query} [context] passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n\n  if (obj == null) {\n    return obj;\n  }\n\n  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n\n  options = options || {};\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = val.length - 1; k >= 0; k--) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        const beforeCastKeysLength = Object.keys(val[k]).length;\n        const discriminatorValue = val[k][schema.options.discriminatorKey];\n        if (discriminatorValue == null) {\n          val[k] = cast(schema, val[k], options, context);\n        } else {\n          const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);\n          val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);\n        }\n\n        if (Object.keys(val[k]).length === 0 && beforeCastKeysLength !== 0) {\n          val.splice(k, 1);\n        }\n      }\n\n      // delete empty: {$or: []} -> {}\n      if (val.length === 0) {\n        delete obj[path];\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$expr') {\n      val = cast$expr(val, schema);\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else if (path === '$comment' && !schema.paths.hasOwnProperty('$comment')) {\n      val = castString(val, path);\n      obj[path] = val;\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = _schematype &&\n            _schematype.schema &&\n            _schematype.schema.options &&\n            _schematype.schema.options.discriminatorKey;\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null &&\n            (_schematype.schema && _schematype.schema.discriminators) != null &&\n            discriminatorKey != null &&\n            pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            const discriminators = _schematype.schema.discriminators;\n            if (typeof discriminatorVal === 'string' && discriminators[discriminatorVal] != null) {\n\n              schematype = discriminators[discriminatorVal].path(pathLastHalf);\n            } else if (discriminatorVal != null &&\n              Object.keys(discriminatorVal).length === 1 &&\n              Array.isArray(discriminatorVal.$in) &&\n              discriminatorVal.$in.length === 1 &&\n              typeof discriminatorVal.$in[0] === 'string' &&\n              discriminators[discriminatorVal.$in[0]] != null) {\n              schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);\n            }\n          }\n        }\n      }\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n\n            const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n            if (ret === void 0) {\n              delete obj[path];\n            } else {\n              obj[path] = ret;\n            }\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(\n                null,\n                val.$maxDistance,\n                context\n              );\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(\n                null,\n                val.$minDistance,\n                context\n              );\n            }\n\n            if (geo === '$within') {\n              const withinType = value.$center\n                  || value.$centerSphere\n                  || value.$box\n                  || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' &&\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n                value.$geometry && typeof value.$geometry.type === 'string' &&\n                Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(\n                  null,\n                  value.$maxDistance,\n                  context\n                );\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(\n                  null,\n                  value.$minDistance,\n                  context\n                );\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center ||\n                  value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({ virtuals: false });\n                }\n              }\n            }\n\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n\n        if (schema.nested[path]) {\n          continue;\n        }\n\n        const strict = 'strict' in options ? options.strict : schema.options.strict;\n        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);\n        if (options.upsert && strict) {\n          if (strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema, strict mode is `true`, and upsert is `true`.');\n        } if (strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema and strictQuery is \\'throw\\'.');\n        } else if (strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (utils.isPOJO(val)) {\n        any$conditionals = Object.keys(val).some(isOperator);\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(\n            null,\n            val,\n            context\n          );\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n            if ($cond === '$elemMatch') {\n              if (nested && schematype != null && schematype.schema != null) {\n                cast(schematype.schema, nested, options, context);\n              } else if (nested && schematype != null && schematype.$isMongooseArray) {\n                if (utils.isPOJO(nested) && nested.$not != null) {\n                  cast(schema, nested, options, context);\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n              }\n            } else if ($cond === '$not') {\n              if (nested && schematype) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQuery(\n                      key,\n                      nested[key],\n                      context\n                    );\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n                continue;\n              }\n            } else {\n              val[$cond] = schematype.castForQuery(\n                $cond,\n                nested,\n                context\n              );\n            }\n\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        const valuesArray = val;\n\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQuery(\n            null,\n            _val,\n            context\n          ));\n        }\n\n        obj[path] = { $in: casted };\n      } else {\n        obj[path] = schematype.castForQuery(\n          null,\n          val,\n          context\n        );\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQuery(null, item, context);\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({ val: item, context: context });\n      }\n    }\n  }\n}\n\nfunction getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {\n  if ('strictQuery' in queryOptions) {\n    return queryOptions.strictQuery;\n  }\n  if ('strictQuery' in schemaUserProvidedOptions) {\n    return schemaUserProvidedOptions.strictQuery;\n  }\n  const mongooseOptions = context &&\n    context.mongooseCollection &&\n    context.mongooseCollection.conn &&\n    context.mongooseCollection.conn.base &&\n    context.mongooseCollection.conn.base.options;\n  if (mongooseOptions) {\n    if ('strictQuery' in mongooseOptions) {\n      return mongooseOptions.strictQuery;\n    }\n  }\n  return schemaOptions.strictQuery;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMsNkVBQWM7QUFDeEMsd0JBQXdCLG1CQUFPLENBQUMsaUZBQWdCO0FBQ2hELGNBQWMsbUJBQU8sQ0FBQyxpRkFBZ0I7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsdUdBQTJCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLCtFQUFlO0FBQzFDLHVCQUF1QixtQkFBTyxDQUFDLG1HQUF5QjtBQUN4RCxZQUFZLG1CQUFPLENBQUMsK0VBQWU7QUFDbkMsc0NBQXNDLG1CQUFPLENBQUMsK0pBQXVEO0FBQ3JHLG1CQUFtQixtQkFBTyxDQUFDLHlHQUE0QjtBQUN2RCxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMseUZBQW9CO0FBQzdDLHlCQUF5QixtQkFBTyxDQUFDLHlHQUE0QjtBQUM3RCxjQUFjLG1CQUFPLENBQUMsbUVBQVM7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLCtEQUErRCxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQjtBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhDQUE4Qyw2QkFBNkI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxjYXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvY2FzdCcpO1xuY29uc3QgU3RyaWN0TW9kZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9zdHJpY3QnKTtcbmNvbnN0IFR5cGVzID0gcmVxdWlyZSgnLi9zY2hlbWEvaW5kZXgnKTtcbmNvbnN0IGNhc3QkZXhwciA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9jYXN0JGV4cHInKTtcbmNvbnN0IGNhc3RTdHJpbmcgPSByZXF1aXJlKCcuL2Nhc3Qvc3RyaW5nJyk7XG5jb25zdCBjYXN0VGV4dFNlYXJjaCA9IHJlcXVpcmUoJy4vc2NoZW1hL29wZXJhdG9ycy90ZXh0Jyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Jyk7XG5jb25zdCBnZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBpc09wZXJhdG9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L2lzT3BlcmF0b3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc09iamVjdCcpO1xuY29uc3QgaXNNb25nb29zZU9iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc01vbmdvb3NlT2JqZWN0Jyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuY29uc3QgQUxMT1dFRF9HRU9XSVRISU5fR0VPSlNPTl9UWVBFUyA9IFsnUG9seWdvbicsICdNdWx0aVBvbHlnb24nXTtcblxuLyoqXG4gKiBIYW5kbGVzIGludGVybmFsIGNhc3RpbmcgZm9yIHF1ZXJ5IGZpbHRlcnMuXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gY2FzdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSB0aGUgcXVlcnkgb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufFwidGhyb3dcIn0gW29wdGlvbnMuc3RyaWN0XSBXaGV0ZXIgdG8gZW5hYmxlIGFsbCBzdHJpY3Qgb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufFwidGhyb3dcIn0gW29wdGlvbnMuc3RyaWN0UXVlcnldIEVuYWJsZSBzdHJpY3QgUXVlcmllc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51cHNlcnRdXG4gKiBAcGFyYW0ge1F1ZXJ5fSBbY29udGV4dF0gcGFzc2VkIHRvIHNldHRlcnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3Qoc2NoZW1hLCBvYmosIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkgZmlsdGVyIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgYW4gYXJyYXkgJywgdXRpbC5pbnNwZWN0KG9iaikpO1xuICB9XG5cbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChzY2hlbWEgIT0gbnVsbCAmJiBzY2hlbWEuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCAmJiBvYmpbc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0gIT0gbnVsbCkge1xuICAgIHNjaGVtYSA9IGdldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlKHNjaGVtYSwgb2JqW3NjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldKSB8fCBzY2hlbWE7XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGxldCBpID0gcGF0aHMubGVuZ3RoO1xuICBsZXQgX2tleXM7XG4gIGxldCBhbnkkY29uZGl0aW9uYWxzO1xuICBsZXQgc2NoZW1hdHlwZTtcbiAgbGV0IG5lc3RlZDtcbiAgbGV0IHBhdGg7XG4gIGxldCB0eXBlO1xuICBsZXQgdmFsO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBwYXRoID0gcGF0aHNbaV07XG4gICAgdmFsID0gb2JqW3BhdGhdO1xuXG4gICAgaWYgKHBhdGggPT09ICckb3InIHx8IHBhdGggPT09ICckbm9yJyB8fCBwYXRoID09PSAnJGFuZCcpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ0FycmF5JywgdmFsLCBwYXRoKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGsgPSB2YWwubGVuZ3RoIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgaWYgKHZhbFtrXSA9PSBudWxsIHx8IHR5cGVvZiB2YWxba10gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignT2JqZWN0JywgdmFsW2tdLCBwYXRoICsgJy4nICsgayk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmVmb3JlQ2FzdEtleXNMZW5ndGggPSBPYmplY3Qua2V5cyh2YWxba10pLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gdmFsW2tdW3NjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldO1xuICAgICAgICBpZiAoZGlzY3JpbWluYXRvclZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB2YWxba10gPSBjYXN0KHNjaGVtYSwgdmFsW2tdLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yU2NoZW1hID0gZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUoY29udGV4dC5zY2hlbWEsIGRpc2NyaW1pbmF0b3JWYWx1ZSk7XG4gICAgICAgICAgdmFsW2tdID0gY2FzdChkaXNjcmltaW5hdG9yU2NoZW1hID8gZGlzY3JpbWluYXRvclNjaGVtYSA6IHNjaGVtYSwgdmFsW2tdLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWxba10pLmxlbmd0aCA9PT0gMCAmJiBiZWZvcmVDYXN0S2V5c0xlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHZhbC5zcGxpY2UoaywgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGVsZXRlIGVtcHR5OiB7JG9yOiBbXX0gLT4ge31cbiAgICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBvYmpbcGF0aF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXRoID09PSAnJHdoZXJlJykge1xuICAgICAgdHlwZSA9IHR5cGVvZiB2YWw7XG5cbiAgICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBoYXZlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uIGZvciAkd2hlcmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqW3BhdGhdID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gJyRleHByJykge1xuICAgICAgdmFsID0gY2FzdCRleHByKHZhbCwgc2NoZW1hKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gJyRlbGVtTWF0Y2gnKSB7XG4gICAgICB2YWwgPSBjYXN0KHNjaGVtYSwgdmFsLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHBhdGggPT09ICckdGV4dCcpIHtcbiAgICAgIHZhbCA9IGNhc3RUZXh0U2VhcmNoKHZhbCwgcGF0aCk7XG4gICAgfSBlbHNlIGlmIChwYXRoID09PSAnJGNvbW1lbnQnICYmICFzY2hlbWEucGF0aHMuaGFzT3duUHJvcGVydHkoJyRjb21tZW50JykpIHtcbiAgICAgIHZhbCA9IGNhc3RTdHJpbmcodmFsLCBwYXRoKTtcbiAgICAgIG9ialtwYXRoXSA9IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzY2hlbWEpIHtcbiAgICAgICAgLy8gbm8gY2FzdGluZyBmb3IgTWl4ZWQgdHlwZXNcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNjaGVtYXR5cGUgPSBzY2hlbWEucGF0aChwYXRoKTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3IgcGF0aHNcbiAgICAgIGlmICghc2NoZW1hdHlwZSkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgbGV0IGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICBjb25zdCBwYXRoRmlyc3RIYWxmID0gc3BsaXQuc2xpY2UoMCwgaikuam9pbignLicpO1xuICAgICAgICAgIGNvbnN0IHBhdGhMYXN0SGFsZiA9IHNwbGl0LnNsaWNlKGopLmpvaW4oJy4nKTtcbiAgICAgICAgICBjb25zdCBfc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHBhdGhGaXJzdEhhbGYpO1xuICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBfc2NoZW1hdHlwZSAmJlxuICAgICAgICAgICAgX3NjaGVtYXR5cGUuc2NoZW1hICYmXG4gICAgICAgICAgICBfc2NoZW1hdHlwZS5zY2hlbWEub3B0aW9ucyAmJlxuICAgICAgICAgICAgX3NjaGVtYXR5cGUuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcblxuICAgICAgICAgIC8vIGdoLTYwMjc6IGlmIHdlIGhhdmVuJ3QgZm91bmQgdGhlIHNjaGVtYXR5cGUgYnV0IHRoaXMgcGF0aCBpc1xuICAgICAgICAgIC8vIHVuZGVybmVhdGggYW4gZW1iZWRkZWQgZGlzY3JpbWluYXRvciBhbmQgdGhlIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3JcbiAgICAgICAgICAvLyBrZXkgaXMgaW4gdGhlIHF1ZXJ5LCB1c2UgdGhlIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3Igc2NoZW1hXG4gICAgICAgICAgaWYgKF9zY2hlbWF0eXBlICE9IG51bGwgJiZcbiAgICAgICAgICAgIChfc2NoZW1hdHlwZS5zY2hlbWEgJiYgX3NjaGVtYXR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSAhPSBudWxsICYmXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yS2V5ICE9IG51bGwgJiZcbiAgICAgICAgICAgIHBhdGhMYXN0SGFsZiAhPT0gZGlzY3JpbWluYXRvcktleSkge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbCA9IGdldChvYmosIHBhdGhGaXJzdEhhbGYgKyAnLicgKyBkaXNjcmltaW5hdG9yS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JzID0gX3NjaGVtYXR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXNjcmltaW5hdG9yVmFsID09PSAnc3RyaW5nJyAmJiBkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yVmFsXSAhPSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgc2NoZW1hdHlwZSA9IGRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JWYWxdLnBhdGgocGF0aExhc3RIYWxmKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzY3JpbWluYXRvclZhbCAhPSBudWxsICYmXG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRpc2NyaW1pbmF0b3JWYWwpLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGRpc2NyaW1pbmF0b3JWYWwuJGluKSAmJlxuICAgICAgICAgICAgICBkaXNjcmltaW5hdG9yVmFsLiRpbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGRpc2NyaW1pbmF0b3JWYWwuJGluWzBdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICBkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yVmFsLiRpblswXV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzY2hlbWF0eXBlID0gZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvclZhbC4kaW5bMF1dLnBhdGgocGF0aExhc3RIYWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFzY2hlbWF0eXBlKSB7XG4gICAgICAgIC8vIEhhbmRsZSBwb3RlbnRpYWwgZW1iZWRkZWQgYXJyYXkgcXVlcmllc1xuICAgICAgICBjb25zdCBzcGxpdCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgbGV0IGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgIGxldCBwYXRoRmlyc3RIYWxmO1xuICAgICAgICBsZXQgcGF0aExhc3RIYWxmO1xuICAgICAgICBsZXQgcmVtYWluaW5nQ29uZHM7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgcGFydCBvZiB0aGUgdmFyIHBhdGggdGhhdCBpcyBhIHBhdGggb2YgdGhlIFNjaGVtYVxuICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgcGF0aEZpcnN0SGFsZiA9IHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy4nKTtcbiAgICAgICAgICBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGgocGF0aEZpcnN0SGFsZik7XG4gICAgICAgICAgaWYgKHNjaGVtYXR5cGUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgc3Vic3RyaW5nIG9mIHRoZSBpbnB1dCBwYXRoIHJlc29sdmVzIHRvIGFuIGFjdHVhbCByZWFsIHBhdGguLi5cbiAgICAgICAgaWYgKHNjaGVtYXR5cGUpIHtcbiAgICAgICAgICAvLyBBcHBseSB0aGUgY2FzdGluZzsgc2ltaWxhciBjb2RlIGZvciAkZWxlbU1hdGNoIGluIHNjaGVtYS9hcnJheS5qc1xuICAgICAgICAgIGlmIChzY2hlbWF0eXBlLmNhc3RlciAmJiBzY2hlbWF0eXBlLmNhc3Rlci5zY2hlbWEpIHtcbiAgICAgICAgICAgIHJlbWFpbmluZ0NvbmRzID0ge307XG4gICAgICAgICAgICBwYXRoTGFzdEhhbGYgPSBzcGxpdC5zbGljZShqKS5qb2luKCcuJyk7XG4gICAgICAgICAgICByZW1haW5pbmdDb25kc1twYXRoTGFzdEhhbGZdID0gdmFsO1xuXG4gICAgICAgICAgICBjb25zdCByZXQgPSBjYXN0KHNjaGVtYXR5cGUuY2FzdGVyLnNjaGVtYSwgcmVtYWluaW5nQ29uZHMsIG9wdGlvbnMsIGNvbnRleHQpW3BhdGhMYXN0SGFsZl07XG4gICAgICAgICAgICBpZiAocmV0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG9ialtwYXRoXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9ialtwYXRoXSA9IHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW3BhdGhdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICAgICAgLy8gaGFuZGxlIGdlbyBzY2hlbWFzIHRoYXQgdXNlIG9iamVjdCBub3RhdGlvblxuICAgICAgICAgIC8vIHsgbG9jOiB7IGxvbmc6IE51bWJlciwgbGF0OiBOdW1iZXIgfVxuXG4gICAgICAgICAgbGV0IGdlbyA9ICcnO1xuICAgICAgICAgIGlmICh2YWwuJG5lYXIpIHtcbiAgICAgICAgICAgIGdlbyA9ICckbmVhcic7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWwuJG5lYXJTcGhlcmUpIHtcbiAgICAgICAgICAgIGdlbyA9ICckbmVhclNwaGVyZSc7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWwuJHdpdGhpbikge1xuICAgICAgICAgICAgZ2VvID0gJyR3aXRoaW4nO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsLiRnZW9JbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICBnZW8gPSAnJGdlb0ludGVyc2VjdHMnO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsLiRnZW9XaXRoaW4pIHtcbiAgICAgICAgICAgIGdlbyA9ICckZ2VvV2l0aGluJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ2VvKSB7XG4gICAgICAgICAgICBjb25zdCBudW1iZXJ0eXBlID0gbmV3IFR5cGVzLk51bWJlcignX19RdWVyeUNhc3RpbmdfXycpO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFsW2dlb107XG5cbiAgICAgICAgICAgIGlmICh2YWwuJG1heERpc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFsLiRtYXhEaXN0YW5jZSA9IG51bWJlcnR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgdmFsLiRtYXhEaXN0YW5jZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsLiRtaW5EaXN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhbC4kbWluRGlzdGFuY2UgPSBudW1iZXJ0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHZhbC4kbWluRGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2VvID09PSAnJHdpdGhpbicpIHtcbiAgICAgICAgICAgICAgY29uc3Qgd2l0aGluVHlwZSA9IHZhbHVlLiRjZW50ZXJcbiAgICAgICAgICAgICAgICAgIHx8IHZhbHVlLiRjZW50ZXJTcGhlcmVcbiAgICAgICAgICAgICAgICAgIHx8IHZhbHVlLiRib3hcbiAgICAgICAgICAgICAgICAgIHx8IHZhbHVlLiRwb2x5Z29uO1xuXG4gICAgICAgICAgICAgIGlmICghd2l0aGluVHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkICR3aXRoaW4gcGFyYW1ldGVyOiAnICsgSlNPTi5zdHJpbmdpZnkodmFsKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YWx1ZSA9IHdpdGhpblR5cGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdlbyA9PT0gJyRuZWFyJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmNvb3JkaW5hdGVzKSkge1xuICAgICAgICAgICAgICAvLyBnZW9qc29uOyBjYXN0IHRoZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZ2VvID09PSAnJG5lYXInIHx8IGdlbyA9PT0gJyRuZWFyU3BoZXJlJyB8fCBnZW8gPT09ICckZ2VvSW50ZXJzZWN0cycpICYmXG4gICAgICAgICAgICAgICAgdmFsdWUuJGdlb21ldHJ5ICYmIHR5cGVvZiB2YWx1ZS4kZ2VvbWV0cnkudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlLiRnZW9tZXRyeS5jb29yZGluYXRlcykpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlLiRtYXhEaXN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuJG1heERpc3RhbmNlID0gbnVtYmVydHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgdmFsdWUuJG1heERpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHZhbHVlLiRtaW5EaXN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuJG1pbkRpc3RhbmNlID0gbnVtYmVydHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgdmFsdWUuJG1pbkRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzTW9uZ29vc2VPYmplY3QodmFsdWUuJGdlb21ldHJ5KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLiRnZW9tZXRyeSA9IHZhbHVlLiRnZW9tZXRyeS50b09iamVjdCh7XG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgdmlydHVhbHM6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS4kZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdlbyA9PT0gJyRnZW9XaXRoaW4nKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS4kZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNNb25nb29zZU9iamVjdCh2YWx1ZS4kZ2VvbWV0cnkpKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZS4kZ2VvbWV0cnkgPSB2YWx1ZS4kZ2VvbWV0cnkudG9PYmplY3QoeyB2aXJ0dWFsczogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGdlb1dpdGhpblR5cGUgPSB2YWx1ZS4kZ2VvbWV0cnkudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoQUxMT1dFRF9HRU9XSVRISU5fR0VPSlNPTl9UWVBFUy5pbmRleE9mKGdlb1dpdGhpblR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGdlb0pTT04gdHlwZSBmb3IgJGdlb1dpdGhpbiBcIicgK1xuICAgICAgICAgICAgICAgICAgICBnZW9XaXRoaW5UeXBlICsgJ1wiLCBtdXN0IGJlIFwiUG9seWdvblwiIG9yIFwiTXVsdGlQb2x5Z29uXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS4kZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS4kYm94IHx8IHZhbHVlLiRwb2x5Z29uIHx8IHZhbHVlLiRjZW50ZXIgfHxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLiRjZW50ZXJTcGhlcmU7XG4gICAgICAgICAgICAgICAgaWYgKGlzTW9uZ29vc2VPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvT2JqZWN0KHsgdmlydHVhbHM6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY2FzdCh2YWx1ZSwgbnVtYmVydHlwZSwgY29udGV4dCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NoZW1hLm5lc3RlZFtwYXRoXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RyaWN0ID0gJ3N0cmljdCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RyaWN0IDogc2NoZW1hLm9wdGlvbnMuc3RyaWN0O1xuICAgICAgICBjb25zdCBzdHJpY3RRdWVyeSA9IGdldFN0cmljdFF1ZXJ5KG9wdGlvbnMsIHNjaGVtYS5fdXNlclByb3ZpZGVkT3B0aW9ucywgc2NoZW1hLm9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICBpZiAob3B0aW9ucy51cHNlcnQgJiYgc3RyaWN0KSB7XG4gICAgICAgICAgaWYgKHN0cmljdCA9PT0gJ3Rocm93Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcihwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcihwYXRoLCAnUGF0aCBcIicgKyBwYXRoICsgJ1wiIGlzIG5vdCBpbiAnICtcbiAgICAgICAgICAgICdzY2hlbWEsIHN0cmljdCBtb2RlIGlzIGB0cnVlYCwgYW5kIHVwc2VydCBpcyBgdHJ1ZWAuJyk7XG4gICAgICAgIH0gaWYgKHN0cmljdFF1ZXJ5ID09PSAndGhyb3cnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcihwYXRoLCAnUGF0aCBcIicgKyBwYXRoICsgJ1wiIGlzIG5vdCBpbiAnICtcbiAgICAgICAgICAgICdzY2hlbWEgYW5kIHN0cmljdFF1ZXJ5IGlzIFxcJ3Rocm93XFwnLicpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdFF1ZXJ5KSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtwYXRoXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQT0pPKHZhbCkpIHtcbiAgICAgICAgYW55JGNvbmRpdGlvbmFscyA9IE9iamVjdC5rZXlzKHZhbCkuc29tZShpc09wZXJhdG9yKTtcblxuICAgICAgICBpZiAoIWFueSRjb25kaXRpb25hbHMpIHtcbiAgICAgICAgICBvYmpbcGF0aF0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBrcyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICAgICAgbGV0ICRjb25kO1xuICAgICAgICAgIGxldCBrID0ga3MubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKGstLSkge1xuICAgICAgICAgICAgJGNvbmQgPSBrc1trXTtcbiAgICAgICAgICAgIG5lc3RlZCA9IHZhbFskY29uZF07XG4gICAgICAgICAgICBpZiAoJGNvbmQgPT09ICckZWxlbU1hdGNoJykge1xuICAgICAgICAgICAgICBpZiAobmVzdGVkICYmIHNjaGVtYXR5cGUgIT0gbnVsbCAmJiBzY2hlbWF0eXBlLnNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2FzdChzY2hlbWF0eXBlLnNjaGVtYSwgbmVzdGVkLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXN0ZWQgJiYgc2NoZW1hdHlwZSAhPSBudWxsICYmIHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc1BPSk8obmVzdGVkKSAmJiBuZXN0ZWQuJG5vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjYXN0KHNjaGVtYSwgbmVzdGVkLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFsWyRjb25kXSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAkY29uZCxcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICgkY29uZCA9PT0gJyRub3QnKSB7XG4gICAgICAgICAgICAgIGlmIChuZXN0ZWQgJiYgc2NoZW1hdHlwZSkge1xuICAgICAgICAgICAgICAgIF9rZXlzID0gT2JqZWN0LmtleXMobmVzdGVkKTtcbiAgICAgICAgICAgICAgICBpZiAoX2tleXMubGVuZ3RoICYmIGlzT3BlcmF0b3IoX2tleXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkW2tleV0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgbmVzdGVkW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YWxbJGNvbmRdID0gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICAgICAgICAgICRjb25kLFxuICAgICAgICAgICAgICAgICAgICBuZXN0ZWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWxbJGNvbmRdID0gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICAgICAgJGNvbmQsXG4gICAgICAgICAgICAgICAgbmVzdGVkLFxuICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkgJiYgWydCdWZmZXInLCAnQXJyYXknXS5pbmRleE9mKHNjaGVtYXR5cGUuaW5zdGFuY2UpID09PSAtMSkge1xuICAgICAgICBjb25zdCBjYXN0ZWQgPSBbXTtcbiAgICAgICAgY29uc3QgdmFsdWVzQXJyYXkgPSB2YWw7XG5cbiAgICAgICAgZm9yIChjb25zdCBfdmFsIG9mIHZhbHVlc0FycmF5KSB7XG4gICAgICAgICAgY2FzdGVkLnB1c2goc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgX3ZhbCxcbiAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9ialtwYXRoXSA9IHsgJGluOiBjYXN0ZWQgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtwYXRoXSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdmFsLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuZnVuY3Rpb24gX2Nhc3QodmFsLCBudW1iZXJ0eXBlLCBjb250ZXh0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICB2YWwuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSB8fCBpc09iamVjdChpdGVtKSkge1xuICAgICAgICByZXR1cm4gX2Nhc3QoaXRlbSwgbnVtYmVydHlwZSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgICB2YWxbaV0gPSBudW1iZXJ0eXBlLmNhc3RGb3JRdWVyeShudWxsLCBpdGVtLCBjb250ZXh0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuZWFyS2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgbGV0IG5lYXJMZW4gPSBuZWFyS2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKG5lYXJMZW4tLSkge1xuICAgICAgY29uc3QgbmtleSA9IG5lYXJLZXlzW25lYXJMZW5dO1xuICAgICAgY29uc3QgaXRlbSA9IHZhbFtua2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pIHx8IGlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIF9jYXN0KGl0ZW0sIG51bWJlcnR5cGUsIGNvbnRleHQpO1xuICAgICAgICB2YWxbbmtleV0gPSBpdGVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsW25rZXldID0gbnVtYmVydHlwZS5jYXN0Rm9yUXVlcnkoeyB2YWw6IGl0ZW0sIGNvbnRleHQ6IGNvbnRleHQgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0cmljdFF1ZXJ5KHF1ZXJ5T3B0aW9ucywgc2NoZW1hVXNlclByb3ZpZGVkT3B0aW9ucywgc2NoZW1hT3B0aW9ucywgY29udGV4dCkge1xuICBpZiAoJ3N0cmljdFF1ZXJ5JyBpbiBxdWVyeU9wdGlvbnMpIHtcbiAgICByZXR1cm4gcXVlcnlPcHRpb25zLnN0cmljdFF1ZXJ5O1xuICB9XG4gIGlmICgnc3RyaWN0UXVlcnknIGluIHNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gc2NoZW1hVXNlclByb3ZpZGVkT3B0aW9ucy5zdHJpY3RRdWVyeTtcbiAgfVxuICBjb25zdCBtb25nb29zZU9wdGlvbnMgPSBjb250ZXh0ICYmXG4gICAgY29udGV4dC5tb25nb29zZUNvbGxlY3Rpb24gJiZcbiAgICBjb250ZXh0Lm1vbmdvb3NlQ29sbGVjdGlvbi5jb25uICYmXG4gICAgY29udGV4dC5tb25nb29zZUNvbGxlY3Rpb24uY29ubi5iYXNlICYmXG4gICAgY29udGV4dC5tb25nb29zZUNvbGxlY3Rpb24uY29ubi5iYXNlLm9wdGlvbnM7XG4gIGlmIChtb25nb29zZU9wdGlvbnMpIHtcbiAgICBpZiAoJ3N0cmljdFF1ZXJ5JyBpbiBtb25nb29zZU9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBtb25nb29zZU9wdGlvbnMuc3RyaWN0UXVlcnk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzY2hlbWFPcHRpb25zLnN0cmljdFF1ZXJ5O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/cast.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/cast/bigint.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/bigint.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { Long } = __webpack_require__(/*! bson */ \"(api)/../server/node_modules/bson/lib/bson.cjs\");\n\n/**\n * Given a value, cast it to a BigInt, or throw an `Error` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @return {Number}\n * @throws {Error} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castBigInt(val) {\n  if (val == null) {\n    return val;\n  }\n  if (val === '') {\n    return null;\n  }\n  if (typeof val === 'bigint') {\n    return val;\n  }\n\n  if (val instanceof Long) {\n    return val.toBigInt();\n  }\n\n  if (typeof val === 'string' || typeof val === 'number') {\n    return BigInt(val);\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9iaWdpbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsNERBQU07O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxjYXN0XFxiaWdpbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbmNvbnN0IHsgTG9uZyB9ID0gcmVxdWlyZSgnYnNvbicpO1xuXG4vKipcbiAqIEdpdmVuIGEgdmFsdWUsIGNhc3QgaXQgdG8gYSBCaWdJbnQsIG9yIHRocm93IGFuIGBFcnJvcmAgaWYgdGhlIHZhbHVlXG4gKiBjYW5ub3QgYmUgY2FzdGVkLiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHRocm93cyB7RXJyb3J9IGlmIGB2YWx1ZWAgaXMgbm90IG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdEJpZ0ludCh2YWwpIHtcbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodmFsID09PSAnJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnYmlnaW50Jykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodmFsIGluc3RhbmNlb2YgTG9uZykge1xuICAgIHJldHVybiB2YWwudG9CaWdJbnQoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBCaWdJbnQodmFsKTtcbiAgfVxuXG4gIGFzc2VydC5vayhmYWxzZSk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/cast/bigint.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/cast/boolean.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/boolean.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * Given a value, cast it to a boolean, or throw a `CastError` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @param {String} [path] optional the path to set on the CastError\n * @return {Boolean|null|undefined}\n * @throws {CastError} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castBoolean(value, path) {\n  if (module.exports.convertToTrue.has(value)) {\n    return true;\n  }\n  if (module.exports.convertToFalse.has(value)) {\n    return false;\n  }\n\n  if (value == null) {\n    return value;\n  }\n\n  throw new CastError('boolean', value, path);\n};\n\nmodule.exports.convertToTrue = new Set([true, 'true', 1, '1', 'yes']);\nmodule.exports.convertToFalse = new Set([false, 'false', 0, '0', 'no']);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaLFlBQVksV0FBVztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1Qiw2QkFBNkIiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxjYXN0XFxib29sZWFuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvY2FzdCcpO1xuXG4vKipcbiAqIEdpdmVuIGEgdmFsdWUsIGNhc3QgaXQgdG8gYSBib29sZWFuLCBvciB0aHJvdyBhIGBDYXN0RXJyb3JgIGlmIHRoZSB2YWx1ZVxuICogY2Fubm90IGJlIGNhc3RlZC4gYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gb3B0aW9uYWwgdGhlIHBhdGggdG8gc2V0IG9uIHRoZSBDYXN0RXJyb3JcbiAqIEByZXR1cm4ge0Jvb2xlYW58bnVsbHx1bmRlZmluZWR9XG4gKiBAdGhyb3dzIHtDYXN0RXJyb3J9IGlmIGB2YWx1ZWAgaXMgbm90IG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdEJvb2xlYW4odmFsdWUsIHBhdGgpIHtcbiAgaWYgKG1vZHVsZS5leHBvcnRzLmNvbnZlcnRUb1RydWUuaGFzKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChtb2R1bGUuZXhwb3J0cy5jb252ZXJ0VG9GYWxzZS5oYXModmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdib29sZWFuJywgdmFsdWUsIHBhdGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuY29udmVydFRvVHJ1ZSA9IG5ldyBTZXQoW3RydWUsICd0cnVlJywgMSwgJzEnLCAneWVzJ10pO1xubW9kdWxlLmV4cG9ydHMuY29udmVydFRvRmFsc2UgPSBuZXcgU2V0KFtmYWxzZSwgJ2ZhbHNlJywgMCwgJzAnLCAnbm8nXSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/cast/boolean.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/cast/date.js":
/*!********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/date.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\nmodule.exports = function castDate(value) {\n  // Support empty string because of empty form values. Originally introduced\n  // in https://github.com/Automattic/mongoose/commit/efc72a1898fc3c33a319d915b8c5463a22938dfe\n  if (value == null || value === '') {\n    return null;\n  }\n\n  if (value instanceof Date) {\n    assert.ok(!isNaN(value.valueOf()));\n\n    return value;\n  }\n\n  let date;\n\n  assert.ok(typeof value !== 'boolean');\n\n  if (value instanceof Number || typeof value === 'number') {\n    date = new Date(value);\n  } else if (typeof value === 'string' && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {\n    // string representation of milliseconds take this path\n    date = new Date(Number(value));\n  } else if (typeof value.valueOf === 'function') {\n    // support for moment.js. This is also the path strings will take because\n    // strings have a `valueOf()`\n    date = new Date(value.valueOf());\n  } else {\n    // fallback\n    date = new Date(value);\n  }\n\n  if (!isNaN(date.valueOf())) {\n    return date;\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9kYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGNhc3RcXGRhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0RGF0ZSh2YWx1ZSkge1xuICAvLyBTdXBwb3J0IGVtcHR5IHN0cmluZyBiZWNhdXNlIG9mIGVtcHR5IGZvcm0gdmFsdWVzLiBPcmlnaW5hbGx5IGludHJvZHVjZWRcbiAgLy8gaW4gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvY29tbWl0L2VmYzcyYTE4OThmYzNjMzNhMzE5ZDkxNWI4YzU0NjNhMjI5MzhkZmVcbiAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgYXNzZXJ0Lm9rKCFpc05hTih2YWx1ZS52YWx1ZU9mKCkpKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGxldCBkYXRlO1xuXG4gIGFzc2VydC5vayh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJyk7XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIWlzTmFOKE51bWJlcih2YWx1ZSkpICYmIChOdW1iZXIodmFsdWUpID49IDI3NTc2MSB8fCBOdW1iZXIodmFsdWUpIDwgLTI3MTgyMCkpIHtcbiAgICAvLyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgbWlsbGlzZWNvbmRzIHRha2UgdGhpcyBwYXRoXG4gICAgZGF0ZSA9IG5ldyBEYXRlKE51bWJlcih2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gc3VwcG9ydCBmb3IgbW9tZW50LmpzLiBUaGlzIGlzIGFsc28gdGhlIHBhdGggc3RyaW5ncyB3aWxsIHRha2UgYmVjYXVzZVxuICAgIC8vIHN0cmluZ3MgaGF2ZSBhIGB2YWx1ZU9mKClgXG4gICAgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlLnZhbHVlT2YoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2tcbiAgICBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICB9XG5cbiAgaWYgKCFpc05hTihkYXRlLnZhbHVlT2YoKSkpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIGFzc2VydC5vayhmYWxzZSk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/cast/date.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/cast/decimal128.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/decimal128.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Decimal128Type = __webpack_require__(/*! ../types/decimal128 */ \"(api)/../server/node_modules/mongoose/lib/types/decimal128.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\nmodule.exports = function castDecimal128(value) {\n  if (value == null) {\n    return value;\n  }\n\n  if (typeof value === 'object' && typeof value.$numberDecimal === 'string') {\n    return Decimal128Type.fromString(value.$numberDecimal);\n  }\n\n  if (value instanceof Decimal128Type) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return Decimal128Type.fromString(value);\n  }\n\n  if (typeof Buffer === 'function' && Buffer.isBuffer(value)) {\n    return new Decimal128Type(value);\n  }\n  if (typeof Uint8Array === 'function' && value instanceof Uint8Array) {\n    return new Decimal128Type(value);\n  }\n\n  if (typeof value === 'number') {\n    return Decimal128Type.fromString(String(value));\n  }\n\n  if (typeof value.valueOf === 'function' && typeof value.valueOf() === 'string') {\n    return Decimal128Type.fromString(value.valueOf());\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9kZWNpbWFsMTI4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHVCQUF1QixtQkFBTyxDQUFDLDBGQUFxQjtBQUNwRCxlQUFlLG1CQUFPLENBQUMsc0JBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxjYXN0XFxkZWNpbWFsMTI4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRGVjaW1hbDEyOFR5cGUgPSByZXF1aXJlKCcuLi90eXBlcy9kZWNpbWFsMTI4Jyk7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0RGVjaW1hbDEyOCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS4kbnVtYmVyRGVjaW1hbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gRGVjaW1hbDEyOFR5cGUuZnJvbVN0cmluZyh2YWx1ZS4kbnVtYmVyRGVjaW1hbCk7XG4gIH1cblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEZWNpbWFsMTI4VHlwZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIERlY2ltYWwxMjhUeXBlLmZyb21TdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOFR5cGUodmFsdWUpO1xuICB9XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IERlY2ltYWwxMjhUeXBlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIERlY2ltYWwxMjhUeXBlLmZyb21TdHJpbmcoU3RyaW5nKHZhbHVlKSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlLnZhbHVlT2YgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnZhbHVlT2YoKSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gRGVjaW1hbDEyOFR5cGUuZnJvbVN0cmluZyh2YWx1ZS52YWx1ZU9mKCkpO1xuICB9XG5cbiAgYXNzZXJ0Lm9rKGZhbHNlKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/cast/decimal128.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/cast/number.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/number.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\n/**\n * Given a value, cast it to a number, or throw an `Error` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @return {Number}\n * @throws {Error} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castNumber(val) {\n  if (val == null) {\n    return val;\n  }\n  if (val === '') {\n    return null;\n  }\n\n  if (typeof val === 'string' || typeof val === 'boolean') {\n    val = Number(val);\n  }\n\n  assert.ok(!isNaN(val));\n  if (val instanceof Number) {\n    return val.valueOf();\n  }\n  if (typeof val === 'number') {\n    return val;\n  }\n  if (!Array.isArray(val) && typeof val.valueOf === 'function') {\n    return Number(val.valueOf());\n  }\n  if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {\n    return Number(val);\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHNCQUFROztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1osWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxjYXN0XFxudW1iZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuLyoqXG4gKiBHaXZlbiBhIHZhbHVlLCBjYXN0IGl0IHRvIGEgbnVtYmVyLCBvciB0aHJvdyBhbiBgRXJyb3JgIGlmIHRoZSB2YWx1ZVxuICogY2Fubm90IGJlIGNhc3RlZC4gYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBgdmFsdWVgIGlzIG5vdCBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3ROdW1iZXIodmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHZhbCA9PT0gJycpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKTtcbiAgfVxuXG4gIGFzc2VydC5vayghaXNOYU4odmFsKSk7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICByZXR1cm4gdmFsLnZhbHVlT2YoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpICYmIHR5cGVvZiB2YWwudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBOdW1iZXIodmFsLnZhbHVlT2YoKSk7XG4gIH1cbiAgaWYgKHZhbC50b1N0cmluZyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbC50b1N0cmluZygpID09IE51bWJlcih2YWwpKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWwpO1xuICB9XG5cbiAgYXNzZXJ0Lm9rKGZhbHNlKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/cast/number.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/cast/objectid.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/objectid.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst ObjectId = __webpack_require__(/*! ../types/objectid */ \"(api)/../server/node_modules/mongoose/lib/types/objectid.js\");\n\nmodule.exports = function castObjectId(value) {\n  if (value == null) {\n    return value;\n  }\n\n  if (isBsonType(value, 'ObjectId')) {\n    return value;\n  }\n\n  if (value._id) {\n    if (isBsonType(value._id, 'ObjectId')) {\n      return value._id;\n    }\n    if (value._id.toString instanceof Function) {\n      return new ObjectId(value._id.toString());\n    }\n  }\n\n  if (value.toString instanceof Function) {\n    return new ObjectId(value.toString());\n  }\n\n  return new ObjectId(value);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9vYmplY3RpZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyw4RkFBdUI7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsc0ZBQW1COztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGNhc3RcXG9iamVjdGlkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuY29uc3QgT2JqZWN0SWQgPSByZXF1aXJlKCcuLi90eXBlcy9vYmplY3RpZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3RPYmplY3RJZCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0Jzb25UeXBlKHZhbHVlLCAnT2JqZWN0SWQnKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5faWQpIHtcbiAgICBpZiAoaXNCc29uVHlwZSh2YWx1ZS5faWQsICdPYmplY3RJZCcpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuX2lkO1xuICAgIH1cbiAgICBpZiAodmFsdWUuX2lkLnRvU3RyaW5nIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQodmFsdWUuX2lkLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YWx1ZS50b1N0cmluZyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RJZCh2YWx1ZS50b1N0cmluZygpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgT2JqZWN0SWQodmFsdWUpO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/cast/objectid.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/cast/string.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cast/string.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * Given a value, cast it to a string, or throw a `CastError` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @param {String} [path] optional the path to set on the CastError\n * @return {string|null|undefined}\n * @throws {CastError}\n * @api private\n */\n\nmodule.exports = function castString(value, path) {\n  // If null or undefined\n  if (value == null) {\n    return value;\n  }\n\n  // handle documents being passed\n  if (value._id && typeof value._id === 'string') {\n    return value._id;\n  }\n\n  // Re: gh-647 and gh-3030, we're ok with casting using `toString()`\n  // **unless** its the default Object.toString, because \"[object Object]\"\n  // doesn't really qualify as useful data\n  if (value.toString &&\n      value.toString !== Object.prototype.toString &&\n      !Array.isArray(value)) {\n    return value.toString();\n  }\n\n  throw new CastError('string', value, path);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsOEVBQWU7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxjYXN0XFxzdHJpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9jYXN0Jyk7XG5cbi8qKlxuICogR2l2ZW4gYSB2YWx1ZSwgY2FzdCBpdCB0byBhIHN0cmluZywgb3IgdGhyb3cgYSBgQ2FzdEVycm9yYCBpZiB0aGUgdmFsdWVcbiAqIGNhbm5vdCBiZSBjYXN0ZWQuIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIG9wdGlvbmFsIHRoZSBwYXRoIHRvIHNldCBvbiB0aGUgQ2FzdEVycm9yXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbHx1bmRlZmluZWR9XG4gKiBAdGhyb3dzIHtDYXN0RXJyb3J9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3RTdHJpbmcodmFsdWUsIHBhdGgpIHtcbiAgLy8gSWYgbnVsbCBvciB1bmRlZmluZWRcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBoYW5kbGUgZG9jdW1lbnRzIGJlaW5nIHBhc3NlZFxuICBpZiAodmFsdWUuX2lkICYmIHR5cGVvZiB2YWx1ZS5faWQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlLl9pZDtcbiAgfVxuXG4gIC8vIFJlOiBnaC02NDcgYW5kIGdoLTMwMzAsIHdlJ3JlIG9rIHdpdGggY2FzdGluZyB1c2luZyBgdG9TdHJpbmcoKWBcbiAgLy8gKip1bmxlc3MqKiBpdHMgdGhlIGRlZmF1bHQgT2JqZWN0LnRvU3RyaW5nLCBiZWNhdXNlIFwiW29iamVjdCBPYmplY3RdXCJcbiAgLy8gZG9lc24ndCByZWFsbHkgcXVhbGlmeSBhcyB1c2VmdWwgZGF0YVxuICBpZiAodmFsdWUudG9TdHJpbmcgJiZcbiAgICAgIHZhbHVlLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICYmXG4gICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHRocm93IG5ldyBDYXN0RXJyb3IoJ3N0cmluZycsIHZhbHVlLCBwYXRoKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/cast/string.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/collection.js":
/*!*********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/collection.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst STATES = __webpack_require__(/*! ./connectionstate */ \"(api)/../server/node_modules/mongoose/lib/connectionstate.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\");\n\n/**\n * Abstract Collection constructor\n *\n * This is the base class that drivers inherit from and implement.\n *\n * @param {String} name name of the collection\n * @param {Connection} conn A MongooseConnection instance\n * @param {Object} [opts] optional collection options\n * @api public\n */\n\nfunction Collection(name, conn, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  this.opts = opts;\n  this.name = name;\n  this.collectionName = name;\n  this.conn = conn;\n  this.queue = [];\n  this.buffer = true;\n  this.emitter = new EventEmitter();\n\n  if (STATES.connected === this.conn.readyState) {\n    this.onOpen();\n  }\n}\n\n/**\n * The collection name\n *\n * @api public\n * @property name\n */\n\nCollection.prototype.name;\n\n/**\n * The collection name\n *\n * @api public\n * @property collectionName\n */\n\nCollection.prototype.collectionName;\n\n/**\n * The Connection instance\n *\n * @api public\n * @property conn\n */\n\nCollection.prototype.conn;\n\n/**\n * Called when the database connects\n *\n * @api private\n */\n\nCollection.prototype.onOpen = function() {\n  this.buffer = false;\n  immediate(() => this.doQueue());\n};\n\n/**\n * Called when the database disconnects\n *\n * @api private\n */\n\nCollection.prototype.onClose = function() {};\n\n/**\n * Queues a method for later execution when its\n * database connection opens.\n *\n * @param {String} name name of the method to queue\n * @param {Array} args arguments to pass to the method when executed\n * @api private\n */\n\nCollection.prototype.addQueue = function(name, args) {\n  this.queue.push([name, args]);\n  return this;\n};\n\n/**\n * Removes a queued method\n *\n * @param {String} name name of the method to queue\n * @param {Array} args arguments to pass to the method when executed\n * @api private\n */\n\nCollection.prototype.removeQueue = function(name, args) {\n  const index = this.queue.findIndex(v => v[0] === name && v[1] === args);\n  if (index === -1) {\n    return false;\n  }\n  this.queue.splice(index, 1);\n  return true;\n};\n\n/**\n * Executes all queued methods and clears the queue.\n *\n * @api private\n */\n\nCollection.prototype.doQueue = function() {\n  for (const method of this.queue) {\n    if (typeof method[0] === 'function') {\n      method[0].apply(this, method[1]);\n    } else {\n      this[method[0]].apply(this, method[1]);\n    }\n  }\n  this.queue = [];\n  const _this = this;\n  immediate(function() {\n    _this.emitter.emit('queue');\n  });\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.ensureIndex = function() {\n  throw new Error('Collection#ensureIndex unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.createIndex = function() {\n  throw new Error('Collection#createIndex unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findAndModify = function() {\n  throw new Error('Collection#findAndModify unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndUpdate = function() {\n  throw new Error('Collection#findOneAndUpdate unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndDelete = function() {\n  throw new Error('Collection#findOneAndDelete unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndReplace = function() {\n  throw new Error('Collection#findOneAndReplace unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOne = function() {\n  throw new Error('Collection#findOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.find = function() {\n  throw new Error('Collection#find unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insert = function() {\n  throw new Error('Collection#insert unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insertOne = function() {\n  throw new Error('Collection#insertOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insertMany = function() {\n  throw new Error('Collection#insertMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.save = function() {\n  throw new Error('Collection#save unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.updateOne = function() {\n  throw new Error('Collection#updateOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.updateMany = function() {\n  throw new Error('Collection#updateMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.deleteOne = function() {\n  throw new Error('Collection#deleteOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.deleteMany = function() {\n  throw new Error('Collection#deleteMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.getIndexes = function() {\n  throw new Error('Collection#getIndexes unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.watch = function() {\n  throw new Error('Collection#watch unimplemented by driver');\n};\n\n/*!\n * ignore\n */\n\nCollection.prototype._shouldBufferCommands = function _shouldBufferCommands() {\n  const opts = this.opts;\n\n  if (opts.bufferCommands != null) {\n    return opts.bufferCommands;\n  }\n  if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {\n    return opts.schemaUserProvidedOptions.bufferCommands;\n  }\n\n  return this.conn._shouldBufferCommands();\n};\n\n/*!\n * ignore\n */\n\nCollection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {\n  const conn = this.conn;\n  const opts = this.opts;\n\n  if (opts.bufferTimeoutMS != null) {\n    return opts.bufferTimeoutMS;\n  }\n  if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {\n    return opts.schemaUserProvidedOptions.bufferTimeoutMS;\n  }\n  if (conn.config.bufferTimeoutMS != null) {\n    return conn.config.bufferTimeoutMS;\n  }\n  if (conn.base != null && conn.base.get('bufferTimeoutMS') != null) {\n    return conn.base.get('bufferTimeoutMS');\n  }\n  return 10000;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Collection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY29sbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDBEQUE4QjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsdUZBQW1CO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLDJGQUFxQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcY29sbGVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBTVEFURVMgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb25zdGF0ZScpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuXG4vKipcbiAqIEFic3RyYWN0IENvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIHRoYXQgZHJpdmVycyBpbmhlcml0IGZyb20gYW5kIGltcGxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gQSBNb25nb29zZUNvbm5lY3Rpb24gaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gb3B0aW9uYWwgY29sbGVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIENvbGxlY3Rpb24obmFtZSwgY29ubiwgb3B0cykge1xuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IG5hbWU7XG4gIHRoaXMuY29ubiA9IGNvbm47XG4gIHRoaXMucXVldWUgPSBbXTtcbiAgdGhpcy5idWZmZXIgPSB0cnVlO1xuICB0aGlzLmVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgaWYgKFNUQVRFUy5jb25uZWN0ZWQgPT09IHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5vbk9wZW4oKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjb2xsZWN0aW9uIG5hbWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG5hbWVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5uYW1lO1xuXG4vKipcbiAqIFRoZSBjb2xsZWN0aW9uIG5hbWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNvbGxlY3Rpb25OYW1lXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuY29sbGVjdGlvbk5hbWU7XG5cbi8qKlxuICogVGhlIENvbm5lY3Rpb24gaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNvbm5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5jb25uO1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBkYXRhYmFzZSBjb25uZWN0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJ1ZmZlciA9IGZhbHNlO1xuICBpbW1lZGlhdGUoKCkgPT4gdGhpcy5kb1F1ZXVlKCkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgZGF0YWJhc2UgZGlzY29ubmVjdHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBRdWV1ZXMgYSBtZXRob2QgZm9yIGxhdGVyIGV4ZWN1dGlvbiB3aGVuIGl0c1xuICogZGF0YWJhc2UgY29ubmVjdGlvbiBvcGVucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gcXVldWVcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZCB3aGVuIGV4ZWN1dGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5hZGRRdWV1ZSA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgdGhpcy5xdWV1ZS5wdXNoKFtuYW1lLCBhcmdzXSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgcXVldWVkIG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBxdWV1ZVxuICogQHBhcmFtIHtBcnJheX0gYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kIHdoZW4gZXhlY3V0ZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZVF1ZXVlID0gZnVuY3Rpb24obmFtZSwgYXJncykge1xuICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUuZmluZEluZGV4KHYgPT4gdlswXSA9PT0gbmFtZSAmJiB2WzFdID09PSBhcmdzKTtcbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0aGlzLnF1ZXVlLnNwbGljZShpbmRleCwgMSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhbGwgcXVldWVkIG1ldGhvZHMgYW5kIGNsZWFycyB0aGUgcXVldWUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZG9RdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiB0aGlzLnF1ZXVlKSB7XG4gICAgaWYgKHR5cGVvZiBtZXRob2RbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1ldGhvZFswXS5hcHBseSh0aGlzLCBtZXRob2RbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW21ldGhvZFswXV0uYXBwbHkodGhpcywgbWV0aG9kWzFdKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBfdGhpcy5lbWl0dGVyLmVtaXQoJ3F1ZXVlJyk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5lbnN1cmVJbmRleCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZW5zdXJlSW5kZXggdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVJbmRleCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jY3JlYXRlSW5kZXggdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5maW5kQW5kTW9kaWZ5ID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNmaW5kQW5kTW9kaWZ5IHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZE9uZUFuZFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZmluZE9uZUFuZFVwZGF0ZSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmZpbmRPbmVBbmREZWxldGUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2ZpbmRPbmVBbmREZWxldGUgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5maW5kT25lQW5kUmVwbGFjZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZmluZE9uZUFuZFJlcGxhY2UgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5maW5kT25lID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNmaW5kT25lIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZmluZCB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jaW5zZXJ0IHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuaW5zZXJ0T25lID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNpbnNlcnRPbmUgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5pbnNlcnRNYW55ID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNpbnNlcnRNYW55IHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jc2F2ZSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jdXBkYXRlT25lIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlTWFueSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jdXBkYXRlTWFueSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmRlbGV0ZU9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZGVsZXRlT25lIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZGVsZXRlTWFueSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZGVsZXRlTWFueSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmdldEluZGV4ZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2dldEluZGV4ZXMgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jd2F0Y2ggdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuX3Nob3VsZEJ1ZmZlckNvbW1hbmRzID0gZnVuY3Rpb24gX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkge1xuICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuXG4gIGlmIChvcHRzLmJ1ZmZlckNvbW1hbmRzICE9IG51bGwpIHtcbiAgICByZXR1cm4gb3B0cy5idWZmZXJDb21tYW5kcztcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMgIT0gbnVsbCAmJiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMuYnVmZmVyQ29tbWFuZHMgIT0gbnVsbCkge1xuICAgIHJldHVybiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMuYnVmZmVyQ29tbWFuZHM7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jb25uLl9zaG91bGRCdWZmZXJDb21tYW5kcygpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5fZ2V0QnVmZmVyVGltZW91dE1TID0gZnVuY3Rpb24gX2dldEJ1ZmZlclRpbWVvdXRNUygpIHtcbiAgY29uc3QgY29ubiA9IHRoaXMuY29ubjtcbiAgY29uc3Qgb3B0cyA9IHRoaXMub3B0cztcblxuICBpZiAob3B0cy5idWZmZXJUaW1lb3V0TVMgIT0gbnVsbCkge1xuICAgIHJldHVybiBvcHRzLmJ1ZmZlclRpbWVvdXRNUztcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMgIT0gbnVsbCAmJiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMuYnVmZmVyVGltZW91dE1TICE9IG51bGwpIHtcbiAgICByZXR1cm4gb3B0cy5zY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zLmJ1ZmZlclRpbWVvdXRNUztcbiAgfVxuICBpZiAoY29ubi5jb25maWcuYnVmZmVyVGltZW91dE1TICE9IG51bGwpIHtcbiAgICByZXR1cm4gY29ubi5jb25maWcuYnVmZmVyVGltZW91dE1TO1xuICB9XG4gIGlmIChjb25uLmJhc2UgIT0gbnVsbCAmJiBjb25uLmJhc2UuZ2V0KCdidWZmZXJUaW1lb3V0TVMnKSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGNvbm4uYmFzZS5nZXQoJ2J1ZmZlclRpbWVvdXRNUycpO1xuICB9XG4gIHJldHVybiAxMDAwMDtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/collection.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/connection.js":
/*!*********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/connection.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ChangeStream = __webpack_require__(/*! ./cursor/ChangeStream */ \"(api)/../server/node_modules/mongoose/lib/cursor/ChangeStream.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Schema = __webpack_require__(/*! ./schema */ \"(api)/../server/node_modules/mongoose/lib/schema.js\");\nconst STATES = __webpack_require__(/*! ./connectionstate */ \"(api)/../server/node_modules/mongoose/lib/connectionstate.js\");\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nconst ServerSelectionError = __webpack_require__(/*! ./error/serverSelection */ \"(api)/../server/node_modules/mongoose/lib/error/serverSelection.js\");\nconst SyncIndexesError = __webpack_require__(/*! ./error/syncIndexes */ \"(api)/../server/node_modules/mongoose/lib/error/syncIndexes.js\");\nconst applyPlugins = __webpack_require__(/*! ./helpers/schema/applyPlugins */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/applyPlugins.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst driver = __webpack_require__(/*! ./driver */ \"(api)/../server/node_modules/mongoose/lib/driver.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst CreateCollectionsError = __webpack_require__(/*! ./error/createCollectionsError */ \"(api)/../server/node_modules/mongoose/lib/error/createCollectionsError.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst sessionNewDocuments = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").sessionNewDocuments);\n\n/**\n * A list of authentication mechanisms that don't require a password for authentication.\n * This is used by the authMechanismDoesNotRequirePassword method.\n *\n * @api private\n */\nconst noPasswordAuthMechanisms = [\n  'MONGODB-X509'\n];\n\n/**\n * Connection constructor\n *\n * For practical reasons, a Connection equals a Db.\n *\n * @param {Mongoose} base a mongoose instance\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `connecting`: Emitted when `connection.openUri()` is executed on this connection.\n * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.\n * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connection's models.\n * @event `disconnecting`: Emitted when `connection.close()` was executed.\n * @event `disconnected`: Emitted after getting disconnected from the db.\n * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connection's models.\n * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successful connection.\n * @event `error`: Emitted when an error occurs on this connection.\n * @event `fullsetup`: Emitted after the driver has connected to primary and all secondaries if specified in the connection string.\n * @api public\n */\n\nfunction Connection(base) {\n  this.base = base;\n  this.collections = {};\n  this.models = {};\n  this.config = {};\n  this.replica = false;\n  this.options = null;\n  this.otherDbs = []; // FIXME: To be replaced with relatedDbs\n  this.relatedDbs = {}; // Hashmap of other dbs that share underlying connection\n  this.states = STATES;\n  this._readyState = STATES.disconnected;\n  this._closeCalled = false;\n  this._hasOpened = false;\n  this.plugins = [];\n  if (typeof base === 'undefined' || !base.connections.length) {\n    this.id = 0;\n  } else {\n    this.id = base.nextConnectionId;\n  }\n  this._queue = [];\n}\n\n/*!\n * Inherit from EventEmitter\n */\n\nObject.setPrototypeOf(Connection.prototype, EventEmitter.prototype);\n\n/**\n * Connection ready state\n *\n * - 0 = disconnected\n * - 1 = connected\n * - 2 = connecting\n * - 3 = disconnecting\n *\n * Each state change emits its associated event name.\n *\n * #### Example:\n *\n *     conn.on('connected', callback);\n *     conn.on('disconnected', callback);\n *\n * @property readyState\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'readyState', {\n  get: function() {\n    return this._readyState;\n  },\n  set: function(val) {\n    if (!(val in STATES)) {\n      throw new Error('Invalid connection state: ' + val);\n    }\n\n    if (this._readyState !== val) {\n      this._readyState = val;\n      // [legacy] loop over the otherDbs on this connection and change their state\n      for (const db of this.otherDbs) {\n        db.readyState = val;\n      }\n\n      if (STATES.connected === val) {\n        this._hasOpened = true;\n      }\n\n      this.emit(STATES[val]);\n    }\n  }\n});\n\n/**\n * Gets the value of the option `key`. Equivalent to `conn.options[key]`\n *\n * #### Example:\n *\n *     conn.get('test'); // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nConnection.prototype.get = function(key) {\n  if (this.config.hasOwnProperty(key)) {\n    return this.config[key];\n  }\n\n  return get(this.options, key);\n};\n\n/**\n * Sets the value of the option `key`. Equivalent to `conn.options[key] = val`\n *\n * Supported options include:\n *\n * - `maxTimeMS`: Set [`maxTimeMS`](https://mongoosejs.com/docs/api/query.html#Query.prototype.maxTimeMS()) for all queries on this connection.\n * - 'debug': If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arugments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n *\n * #### Example:\n *\n *     conn.set('test', 'foo');\n *     conn.get('test'); // 'foo'\n *     conn.options.test; // 'foo'\n *\n * @param {String} key\n * @param {Any} val\n * @method set\n * @api public\n */\n\nConnection.prototype.set = function(key, val) {\n  if (this.config.hasOwnProperty(key)) {\n    this.config[key] = val;\n    return val;\n  }\n\n  this.options = this.options || {};\n  this.options[key] = val;\n  return val;\n};\n\n/**\n * A hash of the collections associated with this connection\n *\n * @property collections\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.collections;\n\n/**\n * The name of the database this connection points to.\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').name; // \"mydb\"\n *\n * @property name\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.name;\n\n/**\n * A [POJO](https://masteringjs.io/tutorials/fundamentals/pojo) containing\n * a map from model names to models. Contains all models that have been\n * added to this connection using [`Connection#model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()).\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection();\n *     const Test = conn.model('Test', mongoose.Schema({ name: String }));\n *\n *     Object.keys(conn.models).length; // 1\n *     conn.models.Test === Test; // true\n *\n * @property models\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.models;\n\n/**\n * A number identifier for this connection. Used for debugging when\n * you have [multiple connections](https://mongoosejs.com/docs/connections.html#multiple_connections).\n *\n * #### Example:\n *\n *     // The default connection has `id = 0`\n *     mongoose.connection.id; // 0\n *\n *     // If you create a new connection, Mongoose increments id\n *     const conn = mongoose.createConnection();\n *     conn.id; // 1\n *\n * @property id\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.id;\n\n/**\n * The plugins that will be applied to all models created on this connection.\n *\n * #### Example:\n *\n *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     db.plugin(() => console.log('Applied'));\n *     db.plugins.length; // 1\n *\n *     db.model('Test', new Schema({})); // Prints \"Applied\"\n *\n * @property plugins\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'plugins', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The host name portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the first host name in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').host; // \"127.0.0.1\"\n *\n * @property host\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'host', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The port portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the port from the first host name in the URI.\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').port; // 27017\n *\n * @property port\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'port', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The username specified in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').user; // \"val\"\n *\n * @property user\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'user', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The password specified in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').pass; // \"psw\"\n *\n * @property pass\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'pass', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The mongodb.Db instance, set when the connection is opened\n *\n * @property db\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.db;\n\n/**\n * The MongoClient instance this connection uses to talk to MongoDB. Mongoose automatically sets this property\n * when the connection is opened.\n *\n * @property client\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.client;\n\n/**\n * A hash of the global options that are associated with this connection\n *\n * @property config\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.config;\n\n/**\n * Helper for `createCollection()`. Will explicitly create the given collection\n * with specified options. Used to create [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections/)\n * and [views](https://www.mongodb.com/docs/manual/core/views/) from mongoose.\n *\n * Options are passed down without modification to the [MongoDB driver's `createCollection()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n *\n * @method createCollection\n * @param {string} collection The collection to create\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.createCollection = async function createCollection(collection, options) {\n  if (typeof options === 'function' || (arguments.length >= 3 && typeof arguments[2] === 'function')) {\n    throw new MongooseError('Connection.prototype.createCollection() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  return this.db.createCollection(collection, options);\n};\n\n/**\n * Calls `createCollection()` on a models in a series.\n *\n * @method createCollections\n * @param {Boolean} continueOnError When true, will continue to create collections and create a new error class for the collections that errored.\n * @returns {Promise}\n * @api public\n */\n\nConnection.prototype.createCollections = async function createCollections(options = {}) {\n  const result = {};\n  const errorsMap = { };\n\n  const { continueOnError } = options;\n  delete options.continueOnError;\n  for (const model of Object.values(this.models)) {\n    try {\n      result[model.modelName] = await model.createCollection({});\n    } catch (err) {\n      if (!continueOnError) {\n        errorsMap[model.modelName] = err;\n        break;\n      } else {\n        result[model.modelName] = err;\n      }\n    }\n  }\n\n  if (!continueOnError && Object.keys(errorsMap).length) {\n    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');\n    const createCollectionsError = new CreateCollectionsError(message, errorsMap);\n    throw createCollectionsError;\n  }\n  return result;\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * #### Example:\n *\n *     const session = await conn.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.remove();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n *\n * @method startSession\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nConnection.prototype.startSession = async function startSession(options) {\n  if (arguments.length >= 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.startSession() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  const session = this.client.startSession(options);\n  return session;\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Executes the wrapped async function\n * in a transaction. Mongoose will commit the transaction if the\n * async function executes successfully and attempt to retry if\n * there was a retriable error.\n *\n * Calls the MongoDB driver's [`session.withTransaction()`](https://mongodb.github.io/node-mongodb-native/4.9/classes/ClientSession.html#withTransaction),\n * but also handles resetting Mongoose document state as shown below.\n *\n * #### Example:\n *\n *     const doc = new Person({ name: 'Will Riker' });\n *     await db.transaction(async function setRank(session) {\n *       doc.rank = 'Captain';\n *       await doc.save({ session });\n *       doc.isNew; // false\n *\n *       // Throw an error to abort the transaction\n *       throw new Error('Oops!');\n *     },{ readPreference: 'primary' }).catch(() => {});\n *\n *     // true, `transaction()` reset the document's state because the\n *     // transaction was aborted.\n *     doc.isNew;\n *\n * @method transaction\n * @param {Function} fn Function to execute in a transaction\n * @param {mongodb.TransactionOptions} [options] Optional settings for the transaction\n * @return {Promise<Any>} promise that is fulfilled if Mongoose successfully committed the transaction, or rejects if the transaction was aborted or if Mongoose failed to commit the transaction. If fulfilled, the promise resolves to a MongoDB command result.\n * @api public\n */\n\nConnection.prototype.transaction = function transaction(fn, options) {\n  return this.startSession().then(session => {\n    session[sessionNewDocuments] = new Map();\n    return session.withTransaction(() => _wrapUserTransaction(fn, session, this.base), options).\n      then(res => {\n        delete session[sessionNewDocuments];\n        return res;\n      }).\n      catch(err => {\n        delete session[sessionNewDocuments];\n        throw err;\n      }).\n      finally(() => {\n        session.endSession().catch(() => {});\n      });\n  });\n};\n\n/*!\n * Reset document state in between transaction retries re: gh-13698\n */\n\nasync function _wrapUserTransaction(fn, session, mongoose) {\n  try {\n    const res = mongoose.transactionAsyncLocalStorage == null\n      ? await fn(session)\n      : await new Promise(resolve => {\n        mongoose.transactionAsyncLocalStorage.run(\n          { session },\n          () => resolve(fn(session))\n        );\n      });\n    return res;\n  } catch (err) {\n    _resetSessionDocuments(session);\n    throw err;\n  }\n}\n\n/*!\n * If transaction was aborted, we need to reset newly inserted documents' `isNew`.\n */\nfunction _resetSessionDocuments(session) {\n  for (const doc of session[sessionNewDocuments].keys()) {\n    const state = session[sessionNewDocuments].get(doc);\n    if (state.hasOwnProperty('isNew')) {\n      doc.$isNew = state.isNew;\n    }\n    if (state.hasOwnProperty('versionKey')) {\n      doc.set(doc.schema.options.versionKey, state.versionKey);\n    }\n\n    if (state.modifiedPaths.length > 0 && doc.$__.activePaths.states.modify == null) {\n      doc.$__.activePaths.states.modify = {};\n    }\n    for (const path of state.modifiedPaths) {\n      const currentState = doc.$__.activePaths.paths[path];\n      if (currentState != null) {\n        delete doc.$__.activePaths[currentState][path];\n      }\n      doc.$__.activePaths.paths[path] = 'modify';\n      doc.$__.activePaths.states.modify[path] = true;\n    }\n\n    for (const path of state.atomics.keys()) {\n      const val = doc.$__getValue(path);\n      if (val == null) {\n        continue;\n      }\n      val[arrayAtomicsSymbol] = state.atomics.get(path);\n    }\n  }\n}\n\n/**\n * Helper for `dropCollection()`. Will delete the given collection, including\n * all documents and indexes.\n *\n * @method dropCollection\n * @param {string} collection The collection to delete\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropCollection = async function dropCollection(collection) {\n  if (arguments.length >= 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.dropCollection() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  return this.db.dropCollection(collection);\n};\n\n/**\n * Helper for `dropDatabase()`. Deletes the given database, including all\n * collections, documents, and indexes.\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     // Deletes the entire 'mydb' database\n *     await conn.dropDatabase();\n *\n * @method dropDatabase\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropDatabase = async function dropDatabase() {\n  if (arguments.length >= 1 && typeof arguments[0] === 'function') {\n    throw new MongooseError('Connection.prototype.dropDatabase() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  // If `dropDatabase()` is called, this model's collection will not be\n  // init-ed. It is sufficiently common to call `dropDatabase()` after\n  // `mongoose.connect()` but before creating models that we want to\n  // support this. See gh-6796\n  for (const model of Object.values(this.models)) {\n    delete model.$init;\n  }\n\n  return this.db.dropDatabase();\n};\n\n/*!\n * ignore\n */\n\nConnection.prototype._shouldBufferCommands = function _shouldBufferCommands() {\n  if (this.config.bufferCommands != null) {\n    return this.config.bufferCommands;\n  }\n  if (this.base.get('bufferCommands') != null) {\n    return this.base.get('bufferCommands');\n  }\n  return true;\n};\n\n/**\n * error\n *\n * Graceful error handling, passes error to callback\n * if available, else emits error on the connection.\n *\n * @param {Error} err\n * @param {Function} callback optional\n * @emits \"error\" Emits the `error` event with the given `err`, unless a callback is specified\n * @returns {Promise|null} Returns a rejected Promise if no `callback` is given.\n * @api private\n */\n\nConnection.prototype.error = function(err, callback) {\n  if (callback) {\n    callback(err);\n    return null;\n  }\n  if (this.listeners('error').length > 0) {\n    this.emit('error', err);\n  }\n  return Promise.reject(err);\n};\n\n/**\n * Called when the connection is opened\n *\n * @api private\n */\n\nConnection.prototype.onOpen = function() {\n  this.readyState = STATES.connected;\n\n  for (const d of this._queue) {\n    d.fn.apply(d.ctx, d.args);\n  }\n  this._queue = [];\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (utils.object.hasOwnProperty(this.collections, i)) {\n      this.collections[i].onOpen();\n    }\n  }\n\n  this.emit('open');\n};\n\n/**\n * Opens the connection with a URI using `MongoClient.connect()`.\n *\n * @param {String} uri The URI to connect with.\n * @param {Object} [options] Passed on to [`MongoClient.connect`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#connect-1)\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {Number} [options.bufferTimeoutMS=10000] Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.\n * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Number} [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.serverSelectionTimeoutMS] If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n * @param {Number} [options.heartbeatFrequencyMS] If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @param {Boolean} [options.autoCreate=false] Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.\n * @returns {Promise<Connection>}\n * @api public\n */\n\nConnection.prototype.openUri = async function openUri(uri, options) {\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString === uri) {\n      return this;\n    }\n  }\n\n  this._closeCalled = false;\n\n  // Internal option to skip `await this.$initialConnection` in\n  // this function for `createConnection()`. Because otherwise\n  // `createConnection()` would have an uncatchable error.\n  let _fireAndForget = false;\n  if (options && '_fireAndForget' in options) {\n    _fireAndForget = options._fireAndForget;\n    delete options._fireAndForget;\n  }\n\n  try {\n    _validateArgs.apply(arguments);\n  } catch (err) {\n    if (_fireAndForget) {\n      throw err;\n    }\n    this.$initialConnection = Promise.reject(err);\n    throw err;\n  }\n\n  this.$initialConnection = this.createClient(uri, options).\n    then(() => this).\n    catch(err => {\n      this.readyState = STATES.disconnected;\n      if (this.listeners('error').length > 0) {\n        immediate(() => this.emit('error', err));\n      }\n      throw err;\n    });\n\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  // `createConnection()` calls this `openUri()` function without\n  // awaiting on the result, so we set this option to rely on\n  // `asPromise()` to handle any errors.\n  if (_fireAndForget) {\n    return this;\n  }\n\n  try {\n    await this.$initialConnection;\n  } catch (err) {\n    throw _handleConnectionErrors(err);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _validateArgs(uri, options, callback) {\n  if (typeof options === 'function' && callback == null) {\n    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');\n  } else if (typeof callback === 'function') {\n    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _handleConnectionErrors(err) {\n  if (err?.name === 'MongoServerSelectionError') {\n    const originalError = err;\n    err = new ServerSelectionError();\n    err.assimilateError(originalError);\n  }\n\n  return err;\n}\n\n/**\n * Destroy the connection. Similar to [`.close`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.close()),\n * but also removes the connection from Mongoose's `connections` list and prevents the\n * connection from ever being re-opened.\n *\n * @param {Boolean} [force]\n * @returns {Promise}\n */\n\nConnection.prototype.destroy = async function destroy(force) {\n  if (typeof force === 'function' || (arguments.length === 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Connection.prototype.destroy() no longer accepts a callback');\n  }\n\n  if (force != null && typeof force === 'object') {\n    this.$wasForceClosed = !!force.force;\n  } else {\n    this.$wasForceClosed = !!force;\n  }\n\n  return this._close(force, true);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force] optional\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.close = async function close(force) {\n  if (typeof force === 'function' || (arguments.length === 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Connection.prototype.close() no longer accepts a callback');\n  }\n\n  if (force != null && typeof force === 'object') {\n    this.$wasForceClosed = !!force.force;\n  } else {\n    this.$wasForceClosed = !!force;\n  }\n\n  for (const model of Object.values(this.models)) {\n    // If manually disconnecting, make sure to clear each model's `$init`\n    // promise, so Mongoose knows to re-run `init()` in case the\n    // connection is re-opened. See gh-12047.\n    delete model.$init;\n  }\n\n  return this._close(force, false);\n};\n\n/**\n * Handles closing the connection\n *\n * @param {Boolean} force\n * @param {Boolean} destroy\n * @returns {Connection} this\n * @api private\n */\nConnection.prototype._close = async function _close(force, destroy) {\n  const _this = this;\n  const closeCalled = this._closeCalled;\n  this._closeCalled = true;\n  this._destroyCalled = destroy;\n  if (this.client != null) {\n    this.client._closeCalled = true;\n    this.client._destroyCalled = destroy;\n  }\n\n  const conn = this;\n  switch (this.readyState) {\n    case STATES.disconnected:\n      if (destroy && this.base.connections.indexOf(conn) !== -1) {\n        this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n      }\n      if (!closeCalled) {\n        await this.doClose(force);\n        this.onClose(force);\n      }\n      break;\n\n    case STATES.connected:\n      this.readyState = STATES.disconnecting;\n      await this.doClose(force);\n      if (destroy && _this.base.connections.indexOf(conn) !== -1) {\n        this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n      }\n      this.onClose(force);\n\n      break;\n    case STATES.connecting:\n      return new Promise((resolve, reject) => {\n        const _rerunClose = () => {\n          this.removeListener('open', _rerunClose);\n          this.removeListener('error', _rerunClose);\n          if (destroy) {\n            this.destroy(force).then(resolve, reject);\n          } else {\n            this.close(force).then(resolve, reject);\n          }\n        };\n\n        this.once('open', _rerunClose);\n        this.once('error', _rerunClose);\n      });\n\n    case STATES.disconnecting:\n      return new Promise(resolve => {\n        this.once('close', () => {\n          if (destroy && this.base.connections.indexOf(conn) !== -1) {\n            this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n          }\n          resolve();\n        });\n      });\n  }\n\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n *\n * @api private\n */\n\nConnection.prototype.doClose = function() {\n  throw new Error('Connection#doClose unimplemented by driver');\n};\n\n/**\n * Called when the connection closes\n *\n * @api private\n */\n\nConnection.prototype.onClose = function(force) {\n  this.readyState = STATES.disconnected;\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (utils.object.hasOwnProperty(this.collections, i)) {\n      this.collections[i].onClose(force);\n    }\n  }\n\n  this.emit('close', force);\n\n  for (const db of this.otherDbs) {\n    this._destroyCalled ? db.destroy({ force: force, skipCloseClient: true }) : db.close({ force: force, skipCloseClient: true });\n  }\n};\n\n/**\n * Retrieves a raw collection instance, creating it if not cached.\n * This method returns a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using a Collection bypasses Mongoose middleware, validation, and casting,\n * letting you use [MongoDB Node.js driver](https://mongodb.github.io/node-mongodb-native/) functionality directly.\n *\n * @param {String} name of the collection\n * @param {Object} [options] optional collection options\n * @return {Collection} collection instance\n * @api public\n */\n\nConnection.prototype.collection = function(name, options) {\n  const defaultOptions = {\n    autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,\n    autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate\n  };\n  options = Object.assign({}, defaultOptions, options ? clone(options) : {});\n  options.$wasForceClosed = this.$wasForceClosed;\n  const Collection = this.base && this.base.__driver && this.base.__driver.Collection || driver.get().Collection;\n  if (!(name in this.collections)) {\n    this.collections[name] = new Collection(name, this, options);\n  }\n  return this.collections[name];\n};\n\n/**\n * Declares a plugin executed on all schemas you pass to `conn.model()`\n *\n * Equivalent to calling `.plugin(fn)` on each schema you create.\n *\n * #### Example:\n *\n *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     db.plugin(() => console.log('Applied'));\n *     db.plugins.length; // 1\n *\n *     db.model('Test', new Schema({})); // Prints \"Applied\"\n *\n * @param {Function} fn plugin callback\n * @param {Object} [opts] optional options\n * @return {Connection} this\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nConnection.prototype.plugin = function(fn, opts) {\n  this.plugins.push([fn, opts]);\n  return this;\n};\n\n/**\n * Defines or retrieves a model.\n *\n *     const mongoose = require('mongoose');\n *     const db = mongoose.createConnection(..);\n *     db.model('Venue', new Schema(..));\n *     const Ticket = db.model('Ticket', new Schema(..));\n *     const Venue = db.model('Venue');\n *\n * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the `utils.toCollectionName` method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     const collectionName = 'actor'\n *     const M = conn.model('Actor', schema, collectionName)\n *\n * @param {String|Function} name the model name or class extending Model\n * @param {Schema} [schema] a schema. necessary when defining a model\n * @param {String} [collection] name of mongodb collection (optional) if not given it will be induced from model name\n * @param {Object} [options]\n * @param {Boolean} [options.overwriteModels=false] If true, overwrite existing models with the same name to avoid `OverwriteModelError`\n * @see Mongoose#model https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()\n * @return {Model} The compiled model\n * @api public\n */\n\nConnection.prototype.model = function(name, schema, collection, options) {\n  if (!(this instanceof Connection)) {\n    throw new MongooseError('`connection.model()` should not be run with ' +\n      '`new`. If you are doing `new db.model(foo)(bar)`, use ' +\n      '`db.model(foo)(bar)` instead');\n  }\n\n  let fn;\n  if (typeof name === 'function') {\n    fn = name;\n    name = fn.name;\n  }\n\n  // collection name discovery\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (utils.isObject(schema)) {\n    if (!schema.instanceOfSchema) {\n      schema = new Schema(schema);\n    } else if (!(schema instanceof this.base.Schema)) {\n      schema = schema._clone(this.base.Schema);\n    }\n  }\n  if (schema && !schema.instanceOfSchema) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };\n  const opts = Object.assign(defaultOptions, options, { connection: this });\n  if (this.models[name] && !collection && opts.overwriteModels !== true) {\n    // model exists but we are not subclassing with custom collection\n    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {\n      throw new MongooseError.OverwriteModelError(name);\n    }\n    return this.models[name];\n  }\n\n  let model;\n\n  if (schema && schema.instanceOfSchema) {\n    applyPlugins(schema, this.plugins, null, '$connectionPluginsApplied');\n\n    // compile a model\n    model = this.base._model(fn || name, schema, collection, opts);\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n\n    return model;\n  }\n\n  if (this.models[name] && collection) {\n    // subclassing current model with alternate collection\n    model = this.models[name];\n    schema = model.prototype.schema;\n    const sub = model.__subclass(this, schema, collection);\n    // do not cache the sub model\n    return sub;\n  }\n\n  if (arguments.length === 1) {\n    model = this.models[name];\n    if (!model) {\n      throw new MongooseError.MissingSchemaError(name);\n    }\n    return model;\n  }\n\n  if (!model) {\n    throw new MongooseError.MissingSchemaError(name);\n  }\n\n  if (this === model.prototype.db\n      && (!collection || collection === model.collection.name)) {\n    // model already uses this connection.\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    return model;\n  }\n  this.models[name] = model.__subclass(this, schema, collection);\n  return this.models[name];\n};\n\n/**\n * Removes the model named `name` from this connection, if it exists. You can\n * use this function to clean up any models you created in your tests to\n * prevent OverwriteModelErrors.\n *\n * #### Example:\n *\n *     conn.model('User', new Schema({ name: String }));\n *     console.log(conn.model('User')); // Model object\n *     conn.deleteModel('User');\n *     console.log(conn.model('User')); // undefined\n *\n *     // Usually useful in a Mocha `afterEach()` hook\n *     afterEach(function() {\n *       conn.deleteModel(/.+/); // Delete every model\n *     });\n *\n * @api public\n * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n * @return {Connection} this\n */\n\nConnection.prototype.deleteModel = function(name) {\n  if (typeof name === 'string') {\n    const model = this.model(name);\n    if (model == null) {\n      return this;\n    }\n    const collectionName = model.collection.name;\n    delete this.models[name];\n    delete this.collections[collectionName];\n\n    this.emit('deleteModel', model);\n  } else if (name instanceof RegExp) {\n    const pattern = name;\n    const names = this.modelNames();\n    for (const name of names) {\n      if (pattern.test(name)) {\n        this.deleteModel(name);\n      }\n    }\n  } else {\n    throw new Error('First parameter to `deleteModel()` must be a string ' +\n      'or regexp, got \"' + name + '\"');\n  }\n\n  return this;\n};\n\n/**\n * Watches the entire underlying database for changes. Similar to\n * [`Model.watch()`](https://mongoosejs.com/docs/api/model.html#Model.watch()).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const User = conn.model('User', new Schema({ name: String }));\n *\n *     const changeStream = conn.watch().on('change', data => console.log(data));\n *\n *     // Triggers a 'change' event on the change stream.\n *     await User.create({ name: 'test' });\n *\n * @api public\n * @param {Array} [pipeline]\n * @param {Object} [options] passed without changes to [the MongoDB driver's `Db#watch()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#watch)\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n */\n\nConnection.prototype.watch = function(pipeline, options) {\n  const changeStreamThunk = cb => {\n    immediate(() => {\n      if (this.readyState === STATES.connecting) {\n        this.once('open', function() {\n          const driverChangeStream = this.db.watch(pipeline, options);\n          cb(null, driverChangeStream);\n        });\n      } else {\n        const driverChangeStream = this.db.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      }\n    });\n  };\n\n  const changeStream = new ChangeStream(changeStreamThunk, pipeline, options);\n  return changeStream;\n};\n\n/**\n * Returns a promise that resolves when this connection\n * successfully connects to MongoDB, or rejects if this connection failed\n * to connect.\n *\n * #### Example:\n *\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n *       asPromise();\n *     conn.readyState; // 1, means Mongoose is connected\n *\n * @api public\n * @return {Promise}\n */\n\nConnection.prototype.asPromise = async function asPromise() {\n  try {\n    await this.$initialConnection;\n    return this;\n  } catch (err) {\n    throw _handleConnectionErrors(err);\n  }\n};\n\n/**\n * Returns an array of model names created on this connection.\n * @api public\n * @return {String[]}\n */\n\nConnection.prototype.modelNames = function() {\n  return Object.keys(this.models);\n};\n\n/**\n * Returns if the connection requires authentication after it is opened. Generally if a\n * username and password are both provided than authentication is needed, but in some cases a\n * password is not required.\n *\n * @api private\n * @return {Boolean} true if the connection should be authenticated after it is opened, otherwise false.\n */\nConnection.prototype.shouldAuthenticate = function() {\n  return this.user != null &&\n    (this.pass != null || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Returns a boolean value that specifies if the current authentication mechanism needs a\n * password to authenticate according to the auth objects passed into the openUri methods.\n *\n * @api private\n * @return {Boolean} true if the authentication mechanism specified in the options object requires\n *  a password, otherwise false.\n */\nConnection.prototype.authMechanismDoesNotRequirePassword = function() {\n  if (this.options && this.options.auth) {\n    return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;\n  }\n  return true;\n};\n\n/**\n * Returns a boolean value that specifies if the provided objects object provides enough\n * data to authenticate with. Generally this is true if the username and password are both specified\n * but in some authentication methods, a password is not required for authentication so only a username\n * is required.\n *\n * @param {Object} [options] the options object passed into the openUri methods.\n * @api private\n * @return {Boolean} true if the provided options object provides enough data to authenticate with,\n *   otherwise false.\n */\nConnection.prototype.optionsProvideAuthenticationData = function(options) {\n  return (options) &&\n      (options.user) &&\n      ((options.pass) || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Returns the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance\n * that this connection uses to talk to MongoDB.\n *\n * #### Example:\n *\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n *       asPromise();\n *\n *     conn.getClient(); // MongoClient { ... }\n *\n * @api public\n * @return {MongoClient}\n */\n\nConnection.prototype.getClient = function getClient() {\n  return this.client;\n};\n\n/**\n * Set the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance\n * that this connection uses to talk to MongoDB. This is useful if you already have a MongoClient instance, and want to\n * reuse it.\n *\n * #### Example:\n *\n *     const client = await mongodb.MongoClient.connect('mongodb://127.0.0.1:27017/test');\n *\n *     const conn = mongoose.createConnection().setClient(client);\n *\n *     conn.getClient(); // MongoClient { ... }\n *     conn.readyState; // 1, means 'CONNECTED'\n *\n * @api public\n * @param {MongClient} client The Client to set to be used.\n * @return {Connection} this\n */\n\nConnection.prototype.setClient = function setClient() {\n  throw new MongooseError('Connection#setClient not implemented by driver');\n};\n\n/*!\n * Called internally by `openUri()` to create a MongoClient instance.\n */\n\nConnection.prototype.createClient = function createClient() {\n  throw new MongooseError('Connection#createClient not implemented by driver');\n};\n\n/**\n * Syncs all the indexes for the models registered with this connection.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.continueOnError] `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n * @return {Promise<Object>} Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n */\nConnection.prototype.syncIndexes = async function syncIndexes(options = {}) {\n  const result = {};\n  const errorsMap = { };\n\n  const { continueOnError } = options;\n  delete options.continueOnError;\n\n  for (const model of Object.values(this.models)) {\n    try {\n      result[model.modelName] = await model.syncIndexes(options);\n    } catch (err) {\n      if (!continueOnError) {\n        errorsMap[model.modelName] = err;\n        break;\n      } else {\n        result[model.modelName] = err;\n      }\n    }\n  }\n\n  if (!continueOnError && Object.keys(errorsMap).length) {\n    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');\n    const syncIndexesError = new SyncIndexesError(message, errorsMap);\n    throw syncIndexesError;\n  }\n\n  return result;\n};\n\n/**\n * Switches to a different database using the same [connection pool](https://mongoosejs.com/docs/api/connectionshtml#connection_pools).\n *\n * Returns a new connection object, with the new db.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *     // Creates a cached connection to `mydb2`. All calls to `conn.useDb('mydb2', { useCache: true })` will return the same\n *     // connection instance as opposed to creating a new connection instance\n *     const db2 = conn.useDb('mydb2', { useCache: true });\n *\n * @method useDb\n * @memberOf Connection\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the connection object will not make the db listen to events on the original connection. See [issue #9961](https://github.com/Automattic/mongoose/issues/9961).\n * @return {Connection} New Connection Object\n * @api public\n */\n\n/**\n * Removes the database connection with the given name created with with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n * @api public\n */\n\n/*!\n * Module exports.\n */\n\nConnection.STATES = STATES;\nmodule.exports = Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMsK0ZBQXVCO0FBQ3BELHFCQUFxQiwwREFBOEI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLHFFQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyx1RkFBbUI7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMsK0VBQWU7QUFDN0MsNkJBQTZCLG1CQUFPLENBQUMsbUdBQXlCO0FBQzlELHlCQUF5QixtQkFBTyxDQUFDLDJGQUFxQjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQywrR0FBK0I7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLG1GQUFpQjtBQUN2QyxlQUFlLG1CQUFPLENBQUMscUVBQVU7QUFDakMsWUFBWSxtQkFBTyxDQUFDLCtFQUFlO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLDJGQUFxQjtBQUMvQyxjQUFjLG1CQUFPLENBQUMsbUVBQVM7QUFDL0IsK0JBQStCLG1CQUFPLENBQUMsaUhBQWdDOztBQUV2RSwyQkFBMkIsaUlBQStDO0FBQzFFLDRCQUE0QixrSUFBZ0Q7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUMsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsWUFBWSxZQUFZO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTs7QUFFQSxVQUFVLGtCQUFrQjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkVBQTJFLFVBQVUsSUFBSSxZQUFZO0FBQ3JHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixnQkFBZ0I7QUFDdEc7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxjb25uZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IENoYW5nZVN0cmVhbSA9IHJlcXVpcmUoJy4vY3Vyc29yL0NoYW5nZVN0cmVhbScpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgU2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEnKTtcbmNvbnN0IFNUQVRFUyA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbnN0YXRlJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU2VydmVyU2VsZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3NlcnZlclNlbGVjdGlvbicpO1xuY29uc3QgU3luY0luZGV4ZXNFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Ivc3luY0luZGV4ZXMnKTtcbmNvbnN0IGFwcGx5UGx1Z2lucyA9IHJlcXVpcmUoJy4vaGVscGVycy9zY2hlbWEvYXBwbHlQbHVnaW5zJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgZHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXInKTtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXQnKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgQ3JlYXRlQ29sbGVjdGlvbnNFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvY3JlYXRlQ29sbGVjdGlvbnNFcnJvcicpO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc1N5bWJvbDtcbmNvbnN0IHNlc3Npb25OZXdEb2N1bWVudHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnNlc3Npb25OZXdEb2N1bWVudHM7XG5cbi8qKlxuICogQSBsaXN0IG9mIGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbXMgdGhhdCBkb24ndCByZXF1aXJlIGEgcGFzc3dvcmQgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICogVGhpcyBpcyB1c2VkIGJ5IHRoZSBhdXRoTWVjaGFuaXNtRG9lc05vdFJlcXVpcmVQYXNzd29yZCBtZXRob2QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmNvbnN0IG5vUGFzc3dvcmRBdXRoTWVjaGFuaXNtcyA9IFtcbiAgJ01PTkdPREItWDUwOSdcbl07XG5cbi8qKlxuICogQ29ubmVjdGlvbiBjb25zdHJ1Y3RvclxuICpcbiAqIEZvciBwcmFjdGljYWwgcmVhc29ucywgYSBDb25uZWN0aW9uIGVxdWFscyBhIERiLlxuICpcbiAqIEBwYXJhbSB7TW9uZ29vc2V9IGJhc2UgYSBtb25nb29zZSBpbnN0YW5jZVxuICogQGluaGVyaXRzIE5vZGVKUyBFdmVudEVtaXR0ZXIgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNjbGFzcy1ldmVudGVtaXR0ZXJcbiAqIEBldmVudCBgY29ubmVjdGluZ2A6IEVtaXR0ZWQgd2hlbiBgY29ubmVjdGlvbi5vcGVuVXJpKClgIGlzIGV4ZWN1dGVkIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBldmVudCBgY29ubmVjdGVkYDogRW1pdHRlZCB3aGVuIHRoaXMgY29ubmVjdGlvbiBzdWNjZXNzZnVsbHkgY29ubmVjdHMgdG8gdGhlIGRiLiBNYXkgYmUgZW1pdHRlZCBfbXVsdGlwbGVfIHRpbWVzIGluIGByZWNvbm5lY3RlZGAgc2NlbmFyaW9zLlxuICogQGV2ZW50IGBvcGVuYDogRW1pdHRlZCBhZnRlciB3ZSBgY29ubmVjdGVkYCBhbmQgYG9uT3BlbmAgaXMgZXhlY3V0ZWQgb24gYWxsIG9mIHRoaXMgY29ubmVjdGlvbidzIG1vZGVscy5cbiAqIEBldmVudCBgZGlzY29ubmVjdGluZ2A6IEVtaXR0ZWQgd2hlbiBgY29ubmVjdGlvbi5jbG9zZSgpYCB3YXMgZXhlY3V0ZWQuXG4gKiBAZXZlbnQgYGRpc2Nvbm5lY3RlZGA6IEVtaXR0ZWQgYWZ0ZXIgZ2V0dGluZyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgZGIuXG4gKiBAZXZlbnQgYGNsb3NlYDogRW1pdHRlZCBhZnRlciB3ZSBgZGlzY29ubmVjdGVkYCBhbmQgYG9uQ2xvc2VgIGV4ZWN1dGVkIG9uIGFsbCBvZiB0aGlzIGNvbm5lY3Rpb24ncyBtb2RlbHMuXG4gKiBAZXZlbnQgYHJlY29ubmVjdGVkYDogRW1pdHRlZCBhZnRlciB3ZSBgY29ubmVjdGVkYCBhbmQgc3Vic2VxdWVudGx5IGBkaXNjb25uZWN0ZWRgLCBmb2xsb3dlZCBieSBzdWNjZXNzZnVsbHkgYW5vdGhlciBzdWNjZXNzZnVsIGNvbm5lY3Rpb24uXG4gKiBAZXZlbnQgYGVycm9yYDogRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBvbiB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAZXZlbnQgYGZ1bGxzZXR1cGA6IEVtaXR0ZWQgYWZ0ZXIgdGhlIGRyaXZlciBoYXMgY29ubmVjdGVkIHRvIHByaW1hcnkgYW5kIGFsbCBzZWNvbmRhcmllcyBpZiBzcGVjaWZpZWQgaW4gdGhlIGNvbm5lY3Rpb24gc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBDb25uZWN0aW9uKGJhc2UpIHtcbiAgdGhpcy5iYXNlID0gYmFzZTtcbiAgdGhpcy5jb2xsZWN0aW9ucyA9IHt9O1xuICB0aGlzLm1vZGVscyA9IHt9O1xuICB0aGlzLmNvbmZpZyA9IHt9O1xuICB0aGlzLnJlcGxpY2EgPSBmYWxzZTtcbiAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgdGhpcy5vdGhlckRicyA9IFtdOyAvLyBGSVhNRTogVG8gYmUgcmVwbGFjZWQgd2l0aCByZWxhdGVkRGJzXG4gIHRoaXMucmVsYXRlZERicyA9IHt9OyAvLyBIYXNobWFwIG9mIG90aGVyIGRicyB0aGF0IHNoYXJlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICB0aGlzLnN0YXRlcyA9IFNUQVRFUztcbiAgdGhpcy5fcmVhZHlTdGF0ZSA9IFNUQVRFUy5kaXNjb25uZWN0ZWQ7XG4gIHRoaXMuX2Nsb3NlQ2FsbGVkID0gZmFsc2U7XG4gIHRoaXMuX2hhc09wZW5lZCA9IGZhbHNlO1xuICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgaWYgKHR5cGVvZiBiYXNlID09PSAndW5kZWZpbmVkJyB8fCAhYmFzZS5jb25uZWN0aW9ucy5sZW5ndGgpIHtcbiAgICB0aGlzLmlkID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlkID0gYmFzZS5uZXh0Q29ubmVjdGlvbklkO1xuICB9XG4gIHRoaXMuX3F1ZXVlID0gW107XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEV2ZW50RW1pdHRlclxuICovXG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihDb25uZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ29ubmVjdGlvbiByZWFkeSBzdGF0ZVxuICpcbiAqIC0gMCA9IGRpc2Nvbm5lY3RlZFxuICogLSAxID0gY29ubmVjdGVkXG4gKiAtIDIgPSBjb25uZWN0aW5nXG4gKiAtIDMgPSBkaXNjb25uZWN0aW5nXG4gKlxuICogRWFjaCBzdGF0ZSBjaGFuZ2UgZW1pdHMgaXRzIGFzc29jaWF0ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbm4ub24oJ2Nvbm5lY3RlZCcsIGNhbGxiYWNrKTtcbiAqICAgICBjb25uLm9uKCdkaXNjb25uZWN0ZWQnLCBjYWxsYmFjayk7XG4gKlxuICogQHByb3BlcnR5IHJlYWR5U3RhdGVcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3Rpb24ucHJvdG90eXBlLCAncmVhZHlTdGF0ZScsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAoISh2YWwgaW4gU1RBVEVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbm5lY3Rpb24gc3RhdGU6ICcgKyB2YWwpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSB2YWw7XG4gICAgICAvLyBbbGVnYWN5XSBsb29wIG92ZXIgdGhlIG90aGVyRGJzIG9uIHRoaXMgY29ubmVjdGlvbiBhbmQgY2hhbmdlIHRoZWlyIHN0YXRlXG4gICAgICBmb3IgKGNvbnN0IGRiIG9mIHRoaXMub3RoZXJEYnMpIHtcbiAgICAgICAgZGIucmVhZHlTdGF0ZSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgaWYgKFNUQVRFUy5jb25uZWN0ZWQgPT09IHZhbCkge1xuICAgICAgICB0aGlzLl9oYXNPcGVuZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXQoU1RBVEVTW3ZhbF0pO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvbiBga2V5YC4gRXF1aXZhbGVudCB0byBgY29ubi5vcHRpb25zW2tleV1gXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25uLmdldCgndGVzdCcpOyAvLyByZXR1cm5zIHRoZSAndGVzdCcgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAbWV0aG9kIGdldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgaWYgKHRoaXMuY29uZmlnLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWdba2V5XTtcbiAgfVxuXG4gIHJldHVybiBnZXQodGhpcy5vcHRpb25zLCBrZXkpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIGBrZXlgLiBFcXVpdmFsZW50IHRvIGBjb25uLm9wdGlvbnNba2V5XSA9IHZhbGBcbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBpbmNsdWRlOlxuICpcbiAqIC0gYG1heFRpbWVNU2A6IFNldCBbYG1heFRpbWVNU2BdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubWF4VGltZU1TKCkpIGZvciBhbGwgcXVlcmllcyBvbiB0aGlzIGNvbm5lY3Rpb24uXG4gKiAtICdkZWJ1Zyc6IElmIGB0cnVlYCwgcHJpbnRzIHRoZSBvcGVyYXRpb25zIG1vbmdvb3NlIHNlbmRzIHRvIE1vbmdvREIgdG8gdGhlIGNvbnNvbGUuIElmIGEgd3JpdGFibGUgc3RyZWFtIGlzIHBhc3NlZCwgaXQgd2lsbCBsb2cgdG8gdGhhdCBzdHJlYW0sIHdpdGhvdXQgY29sb3JpemF0aW9uLiBJZiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHBhc3NlZCwgaXQgd2lsbCByZWNlaXZlIHRoZSBjb2xsZWN0aW9uIG5hbWUsIHRoZSBtZXRob2QgbmFtZSwgdGhlbiBhbGwgYXJ1Z21lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLiBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnRlZCB0byByZXBsaWNhdGUgdGhlIGRlZmF1bHQgbG9nZ2luZywgeW91IGNvdWxkIG91dHB1dCBmcm9tIHRoZSBjYWxsYmFjayBgTW9uZ29vc2U6ICR7Y29sbGVjdGlvbk5hbWV9LiR7bWV0aG9kTmFtZX0oJHttZXRob2RBcmdzLmpvaW4oJywgJyl9KWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25uLnNldCgndGVzdCcsICdmb28nKTtcbiAqICAgICBjb25uLmdldCgndGVzdCcpOyAvLyAnZm9vJ1xuICogICAgIGNvbm4ub3B0aW9ucy50ZXN0OyAvLyAnZm9vJ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7QW55fSB2YWxcbiAqIEBtZXRob2Qgc2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gIGlmICh0aGlzLmNvbmZpZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgdGhpcy5jb25maWdba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQSBoYXNoIG9mIHRoZSBjb2xsZWN0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25uZWN0aW9uXG4gKlxuICogQHByb3BlcnR5IGNvbGxlY3Rpb25zXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNvbGxlY3Rpb25zO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZSB0aGlzIGNvbm5lY3Rpb24gcG9pbnRzIHRvLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9teWRiJykubmFtZTsgLy8gXCJteWRiXCJcbiAqXG4gKiBAcHJvcGVydHkgbmFtZVxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5uYW1lO1xuXG4vKipcbiAqIEEgW1BPSk9dKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wb2pvKSBjb250YWluaW5nXG4gKiBhIG1hcCBmcm9tIG1vZGVsIG5hbWVzIHRvIG1vZGVscy4gQ29udGFpbnMgYWxsIG1vZGVscyB0aGF0IGhhdmUgYmVlblxuICogYWRkZWQgdG8gdGhpcyBjb25uZWN0aW9uIHVzaW5nIFtgQ29ubmVjdGlvbiNtb2RlbCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uLmh0bWwjQ29ubmVjdGlvbi5wcm90b3R5cGUubW9kZWwoKSkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjb25uID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpO1xuICogICAgIGNvbnN0IFRlc3QgPSBjb25uLm1vZGVsKCdUZXN0JywgbW9uZ29vc2UuU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqXG4gKiAgICAgT2JqZWN0LmtleXMoY29ubi5tb2RlbHMpLmxlbmd0aDsgLy8gMVxuICogICAgIGNvbm4ubW9kZWxzLlRlc3QgPT09IFRlc3Q7IC8vIHRydWVcbiAqXG4gKiBAcHJvcGVydHkgbW9kZWxzXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm1vZGVscztcblxuLyoqXG4gKiBBIG51bWJlciBpZGVudGlmaWVyIGZvciB0aGlzIGNvbm5lY3Rpb24uIFVzZWQgZm9yIGRlYnVnZ2luZyB3aGVuXG4gKiB5b3UgaGF2ZSBbbXVsdGlwbGUgY29ubmVjdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9jb25uZWN0aW9ucy5odG1sI211bHRpcGxlX2Nvbm5lY3Rpb25zKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRoZSBkZWZhdWx0IGNvbm5lY3Rpb24gaGFzIGBpZCA9IDBgXG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdGlvbi5pZDsgLy8gMFxuICpcbiAqICAgICAvLyBJZiB5b3UgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24sIE1vbmdvb3NlIGluY3JlbWVudHMgaWRcbiAqICAgICBjb25zdCBjb25uID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpO1xuICogICAgIGNvbm4uaWQ7IC8vIDFcbiAqXG4gKiBAcHJvcGVydHkgaWRcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuaWQ7XG5cbi8qKlxuICogVGhlIHBsdWdpbnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIG1vZGVscyBjcmVhdGVkIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9teWRiJyk7XG4gKiAgICAgZGIucGx1Z2luKCgpID0+IGNvbnNvbGUubG9nKCdBcHBsaWVkJykpO1xuICogICAgIGRiLnBsdWdpbnMubGVuZ3RoOyAvLyAxXG4gKlxuICogICAgIGRiLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7fSkpOyAvLyBQcmludHMgXCJBcHBsaWVkXCJcbiAqXG4gKiBAcHJvcGVydHkgcGx1Z2luc1xuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsICdwbHVnaW5zJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogVGhlIGhvc3QgbmFtZSBwb3J0aW9uIG9mIHRoZSBVUkkuIElmIG11bHRpcGxlIGhvc3RzLCBzdWNoIGFzIGEgcmVwbGljYSBzZXQsXG4gKiB0aGlzIHdpbGwgY29udGFpbiB0aGUgZmlyc3QgaG9zdCBuYW1lIGluIHRoZSBVUklcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvbXlkYicpLmhvc3Q7IC8vIFwiMTI3LjAuMC4xXCJcbiAqXG4gKiBAcHJvcGVydHkgaG9zdFxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsICdob3N0Jywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBUaGUgcG9ydCBwb3J0aW9uIG9mIHRoZSBVUkkuIElmIG11bHRpcGxlIGhvc3RzLCBzdWNoIGFzIGEgcmVwbGljYSBzZXQsXG4gKiB0aGlzIHdpbGwgY29udGFpbiB0aGUgcG9ydCBmcm9tIHRoZSBmaXJzdCBob3N0IG5hbWUgaW4gdGhlIFVSSS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvbXlkYicpLnBvcnQ7IC8vIDI3MDE3XG4gKlxuICogQHByb3BlcnR5IHBvcnRcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3Rpb24ucHJvdG90eXBlLCAncG9ydCcsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogVGhlIHVzZXJuYW1lIHNwZWNpZmllZCBpbiB0aGUgVVJJXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vdmFsOnBzd0AxMjcuMC4wLjE6MjcwMTcvbXlkYicpLnVzZXI7IC8vIFwidmFsXCJcbiAqXG4gKiBAcHJvcGVydHkgdXNlclxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsICd1c2VyJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBUaGUgcGFzc3dvcmQgc3BlY2lmaWVkIGluIHRoZSBVUklcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly92YWw6cHN3QDEyNy4wLjAuMToyNzAxNy9teWRiJykucGFzczsgLy8gXCJwc3dcIlxuICpcbiAqIEBwcm9wZXJ0eSBwYXNzXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3Bhc3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIFRoZSBtb25nb2RiLkRiIGluc3RhbmNlLCBzZXQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuZWRcbiAqXG4gKiBAcHJvcGVydHkgZGJcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZGI7XG5cbi8qKlxuICogVGhlIE1vbmdvQ2xpZW50IGluc3RhbmNlIHRoaXMgY29ubmVjdGlvbiB1c2VzIHRvIHRhbGsgdG8gTW9uZ29EQi4gTW9uZ29vc2UgYXV0b21hdGljYWxseSBzZXRzIHRoaXMgcHJvcGVydHlcbiAqIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgb3BlbmVkLlxuICpcbiAqIEBwcm9wZXJ0eSBjbGllbnRcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xpZW50O1xuXG4vKipcbiAqIEEgaGFzaCBvZiB0aGUgZ2xvYmFsIG9wdGlvbnMgdGhhdCBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29ubmVjdGlvblxuICpcbiAqIEBwcm9wZXJ0eSBjb25maWdcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY29uZmlnO1xuXG4vKipcbiAqIEhlbHBlciBmb3IgYGNyZWF0ZUNvbGxlY3Rpb24oKWAuIFdpbGwgZXhwbGljaXRseSBjcmVhdGUgdGhlIGdpdmVuIGNvbGxlY3Rpb25cbiAqIHdpdGggc3BlY2lmaWVkIG9wdGlvbnMuIFVzZWQgdG8gY3JlYXRlIFtjYXBwZWQgY29sbGVjdGlvbnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvY2FwcGVkLWNvbGxlY3Rpb25zLylcbiAqIGFuZCBbdmlld3NdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvdmlld3MvKSBmcm9tIG1vbmdvb3NlLlxuICpcbiAqIE9wdGlvbnMgYXJlIHBhc3NlZCBkb3duIHdpdGhvdXQgbW9kaWZpY2F0aW9uIHRvIHRoZSBbTW9uZ29EQiBkcml2ZXIncyBgY3JlYXRlQ29sbGVjdGlvbigpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0RiLmh0bWwjY3JlYXRlQ29sbGVjdGlvbilcbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgW01vbmdvREIgZHJpdmVyIGRvY3NdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9EYi5odG1sI2NyZWF0ZUNvbGxlY3Rpb24pXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVDb2xsZWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbihjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCAoYXJndW1lbnRzLmxlbmd0aCA+PSAzICYmIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUNvbGxlY3Rpb24oKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoKHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RpbmcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuZGlzY29ubmVjdGVkKSAmJiB0aGlzLl9zaG91bGRCdWZmZXJDb21tYW5kcygpKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgZm46IHJlc29sdmUgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5kYi5jcmVhdGVDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDYWxscyBgY3JlYXRlQ29sbGVjdGlvbigpYCBvbiBhIG1vZGVscyBpbiBhIHNlcmllcy5cbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbGxlY3Rpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbnRpbnVlT25FcnJvciBXaGVuIHRydWUsIHdpbGwgY29udGludWUgdG8gY3JlYXRlIGNvbGxlY3Rpb25zIGFuZCBjcmVhdGUgYSBuZXcgZXJyb3IgY2xhc3MgZm9yIHRoZSBjb2xsZWN0aW9ucyB0aGF0IGVycm9yZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQ29sbGVjdGlvbnMgPSBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGVycm9yc01hcCA9IHsgfTtcblxuICBjb25zdCB7IGNvbnRpbnVlT25FcnJvciB9ID0gb3B0aW9ucztcbiAgZGVsZXRlIG9wdGlvbnMuY29udGludWVPbkVycm9yO1xuICBmb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC52YWx1ZXModGhpcy5tb2RlbHMpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdFttb2RlbC5tb2RlbE5hbWVdID0gYXdhaXQgbW9kZWwuY3JlYXRlQ29sbGVjdGlvbih7fSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWNvbnRpbnVlT25FcnJvcikge1xuICAgICAgICBlcnJvcnNNYXBbbW9kZWwubW9kZWxOYW1lXSA9IGVycjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbW9kZWwubW9kZWxOYW1lXSA9IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRpbnVlT25FcnJvciAmJiBPYmplY3Qua2V5cyhlcnJvcnNNYXApLmxlbmd0aCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuZW50cmllcyhlcnJvcnNNYXApLm1hcCgoW21vZGVsTmFtZSwgZXJyXSkgPT4gYCR7bW9kZWxOYW1lfTogJHtlcnIubWVzc2FnZX1gKS5qb2luKCcsICcpO1xuICAgIGNvbnN0IGNyZWF0ZUNvbGxlY3Rpb25zRXJyb3IgPSBuZXcgQ3JlYXRlQ29sbGVjdGlvbnNFcnJvcihtZXNzYWdlLCBlcnJvcnNNYXApO1xuICAgIHRocm93IGNyZWF0ZUNvbGxlY3Rpb25zRXJyb3I7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogX1JlcXVpcmVzIE1vbmdvREIgPj0gMy42LjAuXyBTdGFydHMgYSBbTW9uZ29EQiBzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWxlYXNlLW5vdGVzLzMuNi8jY2xpZW50LXNlc3Npb25zKVxuICogZm9yIGJlbmVmaXRzIGxpa2UgY2F1c2FsIGNvbnNpc3RlbmN5LCBbcmV0cnlhYmxlIHdyaXRlc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9yZXRyeWFibGUtd3JpdGVzLyksXG4gKiBhbmQgW3RyYW5zYWN0aW9uc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGUtanMtcGVyc3BlY3RpdmUtb24tbW9uZ29kYi00LXRyYW5zYWN0aW9ucy5odG1sKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBjb25uLnN0YXJ0U2Vzc2lvbigpO1xuICogICAgIGxldCBkb2MgPSBhd2FpdCBQZXJzb24uZmluZE9uZSh7IG5hbWU6ICdOZWQgU3RhcmsnIH0sIG51bGwsIHsgc2Vzc2lvbiB9KTtcbiAqICAgICBhd2FpdCBkb2MucmVtb3ZlKCk7XG4gKiAgICAgLy8gYGRvY2Agd2lsbCBhbHdheXMgYmUgbnVsbCwgZXZlbiBpZiByZWFkaW5nIGZyb20gYSByZXBsaWNhIHNldFxuICogICAgIC8vIHNlY29uZGFyeS4gV2l0aG91dCBjYXVzYWwgY29uc2lzdGVuY3ksIGl0IGlzIHBvc3NpYmxlIHRvXG4gKiAgICAgLy8gZ2V0IGEgZG9jIGJhY2sgZnJvbSB0aGUgYmVsb3cgcXVlcnkgaWYgdGhlIHF1ZXJ5IHJlYWRzIGZyb20gYVxuICogICAgIC8vIHNlY29uZGFyeSB0aGF0IGlzIGV4cGVyaWVuY2luZyByZXBsaWNhdGlvbiBsYWcuXG4gKiAgICAgZG9jID0gYXdhaXQgUGVyc29uLmZpbmRPbmUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9LCBudWxsLCB7IHNlc3Npb24sIHJlYWRQcmVmZXJlbmNlOiAnc2Vjb25kYXJ5JyB9KTtcbiAqXG4gKlxuICogQG1ldGhvZCBzdGFydFNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gc2VlIHRoZSBbbW9uZ29kYiBkcml2ZXIgb3B0aW9uc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL01vbmdvQ2xpZW50Lmh0bWwjc3RhcnRTZXNzaW9uKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYXVzYWxDb25zaXN0ZW5jeT10cnVlXSBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBjYXVzYWwgY29uc2lzdGVuY3lcbiAqIEByZXR1cm4ge1Byb21pc2U8Q2xpZW50U2Vzc2lvbj59IHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIE1vbmdvREIgZHJpdmVyIGBDbGllbnRTZXNzaW9uYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zdGFydFNlc3Npb24gPSBhc3luYyBmdW5jdGlvbiBzdGFydFNlc3Npb24ob3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnRTZXNzaW9uKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgaWYgKCh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmRpc2Nvbm5lY3RlZCkgJiYgdGhpcy5fc2hvdWxkQnVmZmVyQ29tbWFuZHMoKSkge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcXVldWUucHVzaCh7IGZuOiByZXNvbHZlIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuY2xpZW50LnN0YXJ0U2Vzc2lvbihvcHRpb25zKTtcbiAgcmV0dXJuIHNlc3Npb247XG59O1xuXG4vKipcbiAqIF9SZXF1aXJlcyBNb25nb0RCID49IDMuNi4wLl8gRXhlY3V0ZXMgdGhlIHdyYXBwZWQgYXN5bmMgZnVuY3Rpb25cbiAqIGluIGEgdHJhbnNhY3Rpb24uIE1vbmdvb3NlIHdpbGwgY29tbWl0IHRoZSB0cmFuc2FjdGlvbiBpZiB0aGVcbiAqIGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVzIHN1Y2Nlc3NmdWxseSBhbmQgYXR0ZW1wdCB0byByZXRyeSBpZlxuICogdGhlcmUgd2FzIGEgcmV0cmlhYmxlIGVycm9yLlxuICpcbiAqIENhbGxzIHRoZSBNb25nb0RCIGRyaXZlcidzIFtgc2Vzc2lvbi53aXRoVHJhbnNhY3Rpb24oKWBdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9DbGllbnRTZXNzaW9uLmh0bWwjd2l0aFRyYW5zYWN0aW9uKSxcbiAqIGJ1dCBhbHNvIGhhbmRsZXMgcmVzZXR0aW5nIE1vbmdvb3NlIGRvY3VtZW50IHN0YXRlIGFzIHNob3duIGJlbG93LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gbmV3IFBlcnNvbih7IG5hbWU6ICdXaWxsIFJpa2VyJyB9KTtcbiAqICAgICBhd2FpdCBkYi50cmFuc2FjdGlvbihhc3luYyBmdW5jdGlvbiBzZXRSYW5rKHNlc3Npb24pIHtcbiAqICAgICAgIGRvYy5yYW5rID0gJ0NhcHRhaW4nO1xuICogICAgICAgYXdhaXQgZG9jLnNhdmUoeyBzZXNzaW9uIH0pO1xuICogICAgICAgZG9jLmlzTmV3OyAvLyBmYWxzZVxuICpcbiAqICAgICAgIC8vIFRocm93IGFuIGVycm9yIHRvIGFib3J0IHRoZSB0cmFuc2FjdGlvblxuICogICAgICAgdGhyb3cgbmV3IEVycm9yKCdPb3BzIScpO1xuICogICAgIH0seyByZWFkUHJlZmVyZW5jZTogJ3ByaW1hcnknIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAqXG4gKiAgICAgLy8gdHJ1ZSwgYHRyYW5zYWN0aW9uKClgIHJlc2V0IHRoZSBkb2N1bWVudCdzIHN0YXRlIGJlY2F1c2UgdGhlXG4gKiAgICAgLy8gdHJhbnNhY3Rpb24gd2FzIGFib3J0ZWQuXG4gKiAgICAgZG9jLmlzTmV3O1xuICpcbiAqIEBtZXRob2QgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaW4gYSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHttb25nb2RiLlRyYW5zYWN0aW9uT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbmFsIHNldHRpbmdzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIEByZXR1cm4ge1Byb21pc2U8QW55Pn0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCBpZiBNb25nb29zZSBzdWNjZXNzZnVsbHkgY29tbWl0dGVkIHRoZSB0cmFuc2FjdGlvbiwgb3IgcmVqZWN0cyBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIGFib3J0ZWQgb3IgaWYgTW9uZ29vc2UgZmFpbGVkIHRvIGNvbW1pdCB0aGUgdHJhbnNhY3Rpb24uIElmIGZ1bGZpbGxlZCwgdGhlIHByb21pc2UgcmVzb2x2ZXMgdG8gYSBNb25nb0RCIGNvbW1hbmQgcmVzdWx0LlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS50cmFuc2FjdGlvbiA9IGZ1bmN0aW9uIHRyYW5zYWN0aW9uKGZuLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLnN0YXJ0U2Vzc2lvbigpLnRoZW4oc2Vzc2lvbiA9PiB7XG4gICAgc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXSA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gc2Vzc2lvbi53aXRoVHJhbnNhY3Rpb24oKCkgPT4gX3dyYXBVc2VyVHJhbnNhY3Rpb24oZm4sIHNlc3Npb24sIHRoaXMuYmFzZSksIG9wdGlvbnMpLlxuICAgICAgdGhlbihyZXMgPT4ge1xuICAgICAgICBkZWxldGUgc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0pLlxuICAgICAgY2F0Y2goZXJyID0+IHtcbiAgICAgICAgZGVsZXRlIHNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c107XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pLlxuICAgICAgZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHNlc3Npb24uZW5kU2Vzc2lvbigpLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgIH0pO1xuICB9KTtcbn07XG5cbi8qIVxuICogUmVzZXQgZG9jdW1lbnQgc3RhdGUgaW4gYmV0d2VlbiB0cmFuc2FjdGlvbiByZXRyaWVzIHJlOiBnaC0xMzY5OFxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIF93cmFwVXNlclRyYW5zYWN0aW9uKGZuLCBzZXNzaW9uLCBtb25nb29zZSkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IG1vbmdvb3NlLnRyYW5zYWN0aW9uQXN5bmNMb2NhbFN0b3JhZ2UgPT0gbnVsbFxuICAgICAgPyBhd2FpdCBmbihzZXNzaW9uKVxuICAgICAgOiBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgbW9uZ29vc2UudHJhbnNhY3Rpb25Bc3luY0xvY2FsU3RvcmFnZS5ydW4oXG4gICAgICAgICAgeyBzZXNzaW9uIH0sXG4gICAgICAgICAgKCkgPT4gcmVzb2x2ZShmbihzZXNzaW9uKSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9yZXNldFNlc3Npb25Eb2N1bWVudHMoc2Vzc2lvbik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbi8qIVxuICogSWYgdHJhbnNhY3Rpb24gd2FzIGFib3J0ZWQsIHdlIG5lZWQgdG8gcmVzZXQgbmV3bHkgaW5zZXJ0ZWQgZG9jdW1lbnRzJyBgaXNOZXdgLlxuICovXG5mdW5jdGlvbiBfcmVzZXRTZXNzaW9uRG9jdW1lbnRzKHNlc3Npb24pIHtcbiAgZm9yIChjb25zdCBkb2Mgb2Ygc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXS5rZXlzKCkpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10uZ2V0KGRvYyk7XG4gICAgaWYgKHN0YXRlLmhhc093blByb3BlcnR5KCdpc05ldycpKSB7XG4gICAgICBkb2MuJGlzTmV3ID0gc3RhdGUuaXNOZXc7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5oYXNPd25Qcm9wZXJ0eSgndmVyc2lvbktleScpKSB7XG4gICAgICBkb2Muc2V0KGRvYy5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5LCBzdGF0ZS52ZXJzaW9uS2V5KTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubW9kaWZpZWRQYXRocy5sZW5ndGggPiAwICYmIGRvYy4kX18uYWN0aXZlUGF0aHMuc3RhdGVzLm1vZGlmeSA9PSBudWxsKSB7XG4gICAgICBkb2MuJF9fLmFjdGl2ZVBhdGhzLnN0YXRlcy5tb2RpZnkgPSB7fTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHN0YXRlLm1vZGlmaWVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGRvYy4kX18uYWN0aXZlUGF0aHMucGF0aHNbcGF0aF07XG4gICAgICBpZiAoY3VycmVudFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGRvYy4kX18uYWN0aXZlUGF0aHNbY3VycmVudFN0YXRlXVtwYXRoXTtcbiAgICAgIH1cbiAgICAgIGRvYy4kX18uYWN0aXZlUGF0aHMucGF0aHNbcGF0aF0gPSAnbW9kaWZ5JztcbiAgICAgIGRvYy4kX18uYWN0aXZlUGF0aHMuc3RhdGVzLm1vZGlmeVtwYXRoXSA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHN0YXRlLmF0b21pY3Mua2V5cygpKSB7XG4gICAgICBjb25zdCB2YWwgPSBkb2MuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSA9IHN0YXRlLmF0b21pY3MuZ2V0KHBhdGgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgYGRyb3BDb2xsZWN0aW9uKClgLiBXaWxsIGRlbGV0ZSB0aGUgZ2l2ZW4gY29sbGVjdGlvbiwgaW5jbHVkaW5nXG4gKiBhbGwgZG9jdW1lbnRzIGFuZCBpbmRleGVzLlxuICpcbiAqIEBtZXRob2QgZHJvcENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGRlbGV0ZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZHJvcENvbGxlY3Rpb24gPSBhc3luYyBmdW5jdGlvbiBkcm9wQ29sbGVjdGlvbihjb2xsZWN0aW9uKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uLnByb3RvdHlwZS5kcm9wQ29sbGVjdGlvbigpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICgodGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGluZyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5kaXNjb25uZWN0ZWQpICYmIHRoaXMuX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyBmbjogcmVzb2x2ZSB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmRiLmRyb3BDb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGBkcm9wRGF0YWJhc2UoKWAuIERlbGV0ZXMgdGhlIGdpdmVuIGRhdGFiYXNlLCBpbmNsdWRpbmcgYWxsXG4gKiBjb2xsZWN0aW9ucywgZG9jdW1lbnRzLCBhbmQgaW5kZXhlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNvbm4gPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L215ZGInKTtcbiAqICAgICAvLyBEZWxldGVzIHRoZSBlbnRpcmUgJ215ZGInIGRhdGFiYXNlXG4gKiAgICAgYXdhaXQgY29ubi5kcm9wRGF0YWJhc2UoKTtcbiAqXG4gKiBAbWV0aG9kIGRyb3BEYXRhYmFzZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZHJvcERhdGFiYXNlID0gYXN5bmMgZnVuY3Rpb24gZHJvcERhdGFiYXNlKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuZHJvcERhdGFiYXNlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgaWYgKCh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmRpc2Nvbm5lY3RlZCkgJiYgdGhpcy5fc2hvdWxkQnVmZmVyQ29tbWFuZHMoKSkge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcXVldWUucHVzaCh7IGZuOiByZXNvbHZlIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gSWYgYGRyb3BEYXRhYmFzZSgpYCBpcyBjYWxsZWQsIHRoaXMgbW9kZWwncyBjb2xsZWN0aW9uIHdpbGwgbm90IGJlXG4gIC8vIGluaXQtZWQuIEl0IGlzIHN1ZmZpY2llbnRseSBjb21tb24gdG8gY2FsbCBgZHJvcERhdGFiYXNlKClgIGFmdGVyXG4gIC8vIGBtb25nb29zZS5jb25uZWN0KClgIGJ1dCBiZWZvcmUgY3JlYXRpbmcgbW9kZWxzIHRoYXQgd2Ugd2FudCB0b1xuICAvLyBzdXBwb3J0IHRoaXMuIFNlZSBnaC02Nzk2XG4gIGZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1vZGVscykpIHtcbiAgICBkZWxldGUgbW9kZWwuJGluaXQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5kYi5kcm9wRGF0YWJhc2UoKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX3Nob3VsZEJ1ZmZlckNvbW1hbmRzID0gZnVuY3Rpb24gX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkge1xuICBpZiAodGhpcy5jb25maWcuYnVmZmVyQ29tbWFuZHMgIT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5idWZmZXJDb21tYW5kcztcbiAgfVxuICBpZiAodGhpcy5iYXNlLmdldCgnYnVmZmVyQ29tbWFuZHMnKSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZS5nZXQoJ2J1ZmZlckNvbW1hbmRzJyk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIGVycm9yXG4gKlxuICogR3JhY2VmdWwgZXJyb3IgaGFuZGxpbmcsIHBhc3NlcyBlcnJvciB0byBjYWxsYmFja1xuICogaWYgYXZhaWxhYmxlLCBlbHNlIGVtaXRzIGVycm9yIG9uIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgb3B0aW9uYWxcbiAqIEBlbWl0cyBcImVycm9yXCIgRW1pdHMgdGhlIGBlcnJvcmAgZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gYGVycmAsIHVubGVzcyBhIGNhbGxiYWNrIGlzIHNwZWNpZmllZFxuICogQHJldHVybnMge1Byb21pc2V8bnVsbH0gUmV0dXJucyBhIHJlamVjdGVkIFByb21pc2UgaWYgbm8gYGNhbGxiYWNrYCBpcyBnaXZlbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZXJyLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayhlcnIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0aGlzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5lZFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSBTVEFURVMuY29ubmVjdGVkO1xuXG4gIGZvciAoY29uc3QgZCBvZiB0aGlzLl9xdWV1ZSkge1xuICAgIGQuZm4uYXBwbHkoZC5jdHgsIGQuYXJncyk7XG4gIH1cbiAgdGhpcy5fcXVldWUgPSBbXTtcblxuICAvLyBhdm9pZCBoYXZpbmcgdGhlIGNvbGxlY3Rpb24gc3Vic2NyaWJlIHRvIG91ciBldmVudCBlbWl0dGVyXG4gIC8vIHRvIHByZXZlbnQgMC4zIHdhcm5pbmdcbiAgZm9yIChjb25zdCBpIGluIHRoaXMuY29sbGVjdGlvbnMpIHtcbiAgICBpZiAodXRpbHMub2JqZWN0Lmhhc093blByb3BlcnR5KHRoaXMuY29sbGVjdGlvbnMsIGkpKSB7XG4gICAgICB0aGlzLmNvbGxlY3Rpb25zW2ldLm9uT3BlbigpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBPcGVucyB0aGUgY29ubmVjdGlvbiB3aXRoIGEgVVJJIHVzaW5nIGBNb25nb0NsaWVudC5jb25uZWN0KClgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmkgVGhlIFVSSSB0byBjb25uZWN0IHdpdGguXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFBhc3NlZCBvbiB0byBbYE1vbmdvQ2xpZW50LmNvbm5lY3RgXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvTW9uZ29DbGllbnQuaHRtbCNjb25uZWN0LTEpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJ1ZmZlckNvbW1hbmRzPXRydWVdIE1vbmdvb3NlIHNwZWNpZmljIG9wdGlvbi4gU2V0IHRvIGZhbHNlIHRvIFtkaXNhYmxlIGJ1ZmZlcmluZ10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2ZhcS5odG1sI2NhbGxiYWNrX25ldmVyX2V4ZWN1dGVzKSBvbiBhbGwgbW9kZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVmZmVyVGltZW91dE1TPTEwMDAwXSBNb25nb29zZSBzcGVjaWZpYyBvcHRpb24uIElmIGBidWZmZXJDb21tYW5kc2AgaXMgdHJ1ZSwgTW9uZ29vc2Ugd2lsbCB0aHJvdyBhbiBlcnJvciBhZnRlciBgYnVmZmVyVGltZW91dE1TYCBpZiB0aGUgb3BlcmF0aW9uIGlzIHN0aWxsIGJ1ZmZlcmVkLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmRiTmFtZV0gVGhlIG5hbWUgb2YgdGhlIGRhdGFiYXNlIHdlIHdhbnQgdG8gdXNlLiBJZiBub3QgcHJvdmlkZWQsIHVzZSBkYXRhYmFzZSBuYW1lIGZyb20gY29ubmVjdGlvbiBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudXNlcl0gdXNlcm5hbWUgZm9yIGF1dGhlbnRpY2F0aW9uLCBlcXVpdmFsZW50IHRvIGBvcHRpb25zLmF1dGgudXNlcmAuIE1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhc3NdIHBhc3N3b3JkIGZvciBhdXRoZW50aWNhdGlvbiwgZXF1aXZhbGVudCB0byBgb3B0aW9ucy5hdXRoLnBhc3N3b3JkYC4gTWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UG9vbFNpemU9MTAwXSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc29ja2V0cyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCBrZWVwIG9wZW4gZm9yIHRoaXMgY29ubmVjdGlvbi4gS2VlcCBpbiBtaW5kIHRoYXQgTW9uZ29EQiBvbmx5IGFsbG93cyBvbmUgb3BlcmF0aW9uIHBlciBzb2NrZXQgYXQgYSB0aW1lLCBzbyB5b3UgbWF5IHdhbnQgdG8gaW5jcmVhc2UgdGhpcyBpZiB5b3UgZmluZCB5b3UgaGF2ZSBhIGZldyBzbG93IHF1ZXJpZXMgdGhhdCBhcmUgYmxvY2tpbmcgZmFzdGVyIHF1ZXJpZXMgZnJvbSBwcm9jZWVkaW5nLiBTZWUgW1Nsb3cgVHJhaW5zIGluIE1vbmdvREIgYW5kIE5vZGUuanNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vc2xvdy10cmFpbnMtaW4tbW9uZ29kYi1hbmQtbm9kZWpzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5Qb29sU2l6ZT0wXSBUaGUgbWluaW11bSBudW1iZXIgb2Ygc29ja2V0cyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCBrZWVwIG9wZW4gZm9yIHRoaXMgY29ubmVjdGlvbi4gS2VlcCBpbiBtaW5kIHRoYXQgTW9uZ29EQiBvbmx5IGFsbG93cyBvbmUgb3BlcmF0aW9uIHBlciBzb2NrZXQgYXQgYSB0aW1lLCBzbyB5b3UgbWF5IHdhbnQgdG8gaW5jcmVhc2UgdGhpcyBpZiB5b3UgZmluZCB5b3UgaGF2ZSBhIGZldyBzbG93IHF1ZXJpZXMgdGhhdCBhcmUgYmxvY2tpbmcgZmFzdGVyIHF1ZXJpZXMgZnJvbSBwcm9jZWVkaW5nLiBTZWUgW1Nsb3cgVHJhaW5zIGluIE1vbmdvREIgYW5kIE5vZGUuanNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vc2xvdy10cmFpbnMtaW4tbW9uZ29kYi1hbmQtbm9kZWpzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVNdIElmIGB1c2VVbmlmaWVkVG9wb2xvZ3kgPSB0cnVlYCwgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwgdHJ5IHRvIGZpbmQgYSBzZXJ2ZXIgdG8gc2VuZCBhbnkgZ2l2ZW4gb3BlcmF0aW9uIHRvLCBhbmQga2VlcCByZXRyeWluZyBmb3IgYHNlcnZlclNlbGVjdGlvblRpbWVvdXRNU2AgbWlsbGlzZWNvbmRzIGJlZm9yZSBlcnJvcmluZyBvdXQuIElmIG5vdCBzZXQsIHRoZSBNb25nb0RCIGRyaXZlciBkZWZhdWx0cyB0byB1c2luZyBgMzAwMDBgICgzMCBzZWNvbmRzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWFydGJlYXRGcmVxdWVuY3lNU10gSWYgYHVzZVVuaWZpZWRUb3BvbG9neSA9IHRydWVgLCB0aGUgTW9uZ29EQiBkcml2ZXIgc2VuZHMgYSBoZWFydGJlYXQgZXZlcnkgYGhlYXJ0YmVhdEZyZXF1ZW5jeU1TYCB0byBjaGVjayBvbiB0aGUgc3RhdHVzIG9mIHRoZSBjb25uZWN0aW9uLiBBIGhlYXJ0YmVhdCBpcyBzdWJqZWN0IHRvIGBzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVNgLCBzbyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCByZXRyeSBmYWlsZWQgaGVhcnRiZWF0cyBmb3IgdXAgdG8gMzAgc2Vjb25kcyBieSBkZWZhdWx0LiBNb25nb29zZSBvbmx5IGVtaXRzIGEgYCdkaXNjb25uZWN0ZWQnYCBldmVudCBhZnRlciBhIGhlYXJ0YmVhdCBoYXMgZmFpbGVkLCBzbyB5b3UgbWF5IHdhbnQgdG8gZGVjcmVhc2UgdGhpcyBzZXR0aW5nIHRvIHJlZHVjZSB0aGUgdGltZSBiZXR3ZWVuIHdoZW4geW91ciBzZXJ2ZXIgZ29lcyBkb3duIGFuZCB3aGVuIE1vbmdvb3NlIGVtaXRzIGAnZGlzY29ubmVjdGVkJ2AuIFdlIHJlY29tbWVuZCB5b3UgZG8gKipub3QqKiBzZXQgdGhpcyBzZXR0aW5nIGJlbG93IDEwMDAsIHRvbyBtYW55IGhlYXJ0YmVhdHMgY2FuIGxlYWQgdG8gcGVyZm9ybWFuY2UgZGVncmFkYXRpb24uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9JbmRleD10cnVlXSBNb25nb29zZS1zcGVjaWZpYyBvcHRpb24uIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIGF1dG9tYXRpYyBpbmRleCBjcmVhdGlvbiBmb3IgYWxsIG1vZGVscyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25uZWN0aW9uLlxuICogQHBhcmFtIHtDbGFzc30gW29wdGlvbnMucHJvbWlzZUxpYnJhcnldIFNldHMgdGhlIFt1bmRlcmx5aW5nIGRyaXZlcidzIHByb21pc2UgbGlicmFyeV0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vbmdvQ2xpZW50T3B0aW9ucy5odG1sI3Byb21pc2VMaWJyYXJ5KS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zb2NrZXRUaW1lb3V0TVM9MF0gSG93IGxvbmcgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwgd2FpdCBiZWZvcmUga2lsbGluZyBhIHNvY2tldCBkdWUgdG8gaW5hY3Rpdml0eSBfYWZ0ZXIgaW5pdGlhbCBjb25uZWN0aW9uXy4gQSBzb2NrZXQgbWF5IGJlIGluYWN0aXZlIGJlY2F1c2Ugb2YgZWl0aGVyIG5vIGFjdGl2aXR5IG9yIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi4gYHNvY2tldFRpbWVvdXRNU2AgZGVmYXVsdHMgdG8gMCwgd2hpY2ggbWVhbnMgTm9kZS5qcyB3aWxsIG5vdCB0aW1lIG91dCB0aGUgc29ja2V0IGR1ZSB0byBpbmFjdGl2aXR5LiBUaGlzIG9wdGlvbiBpcyBwYXNzZWQgdG8gW05vZGUuanMgYHNvY2tldCNzZXRUaW1lb3V0KClgIGZ1bmN0aW9uXShodHRwczovL25vZGVqcy5vcmcvYXBpL25ldC5odG1sI25ldF9zb2NrZXRfc2V0dGltZW91dF90aW1lb3V0X2NhbGxiYWNrKSBhZnRlciB0aGUgTW9uZ29EQiBkcml2ZXIgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mYW1pbHk9MF0gUGFzc2VkIHRyYW5zcGFyZW50bHkgdG8gW05vZGUuanMnIGBkbnMubG9va3VwKClgXShodHRwczovL25vZGVqcy5vcmcvYXBpL2Rucy5odG1sI2Ruc19kbnNfbG9va3VwX2hvc3RuYW1lX29wdGlvbnNfY2FsbGJhY2spIGZ1bmN0aW9uLiBNYXkgYmUgZWl0aGVyIGAwLCBgNGAsIG9yIGA2YC4gYDRgIG1lYW5zIHVzZSBJUHY0IG9ubHksIGA2YCBtZWFucyB1c2UgSVB2NiBvbmx5LCBgMGAgbWVhbnMgdHJ5IGJvdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9DcmVhdGU9ZmFsc2VdIFNldCB0byBgdHJ1ZWAgdG8gbWFrZSBNb25nb29zZSBhdXRvbWF0aWNhbGx5IGNhbGwgYGNyZWF0ZUNvbGxlY3Rpb24oKWAgb24gZXZlcnkgbW9kZWwgY3JlYXRlZCBvbiB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxDb25uZWN0aW9uPn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUub3BlblVyaSA9IGFzeW5jIGZ1bmN0aW9uIG9wZW5VcmkodXJpLCBvcHRpb25zKSB7XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RlZCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0aW9uU3RyaW5nID09PSB1cmkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2Nsb3NlQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gSW50ZXJuYWwgb3B0aW9uIHRvIHNraXAgYGF3YWl0IHRoaXMuJGluaXRpYWxDb25uZWN0aW9uYCBpblxuICAvLyB0aGlzIGZ1bmN0aW9uIGZvciBgY3JlYXRlQ29ubmVjdGlvbigpYC4gQmVjYXVzZSBvdGhlcndpc2VcbiAgLy8gYGNyZWF0ZUNvbm5lY3Rpb24oKWAgd291bGQgaGF2ZSBhbiB1bmNhdGNoYWJsZSBlcnJvci5cbiAgbGV0IF9maXJlQW5kRm9yZ2V0ID0gZmFsc2U7XG4gIGlmIChvcHRpb25zICYmICdfZmlyZUFuZEZvcmdldCcgaW4gb3B0aW9ucykge1xuICAgIF9maXJlQW5kRm9yZ2V0ID0gb3B0aW9ucy5fZmlyZUFuZEZvcmdldDtcbiAgICBkZWxldGUgb3B0aW9ucy5fZmlyZUFuZEZvcmdldDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgX3ZhbGlkYXRlQXJncy5hcHBseShhcmd1bWVudHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoX2ZpcmVBbmRGb3JnZXQpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgdGhpcy4kaW5pdGlhbENvbm5lY3Rpb24gPSBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHRoaXMuJGluaXRpYWxDb25uZWN0aW9uID0gdGhpcy5jcmVhdGVDbGllbnQodXJpLCBvcHRpb25zKS5cbiAgICB0aGVuKCgpID0+IHRoaXMpLlxuICAgIGNhdGNoKGVyciA9PiB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTVEFURVMuZGlzY29ubmVjdGVkO1xuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW1tZWRpYXRlKCgpID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcblxuICBmb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC52YWx1ZXModGhpcy5tb2RlbHMpKSB7XG4gICAgLy8gRXJyb3JzIGhhbmRsZWQgaW50ZXJuYWxseSwgc28gc2FmZSB0byBpZ25vcmUgZXJyb3JcbiAgICBtb2RlbC5pbml0KCkuY2F0Y2goZnVuY3Rpb24gJG1vZGVsSW5pdE5vb3AoKSB7fSk7XG4gIH1cblxuICAvLyBgY3JlYXRlQ29ubmVjdGlvbigpYCBjYWxscyB0aGlzIGBvcGVuVXJpKClgIGZ1bmN0aW9uIHdpdGhvdXRcbiAgLy8gYXdhaXRpbmcgb24gdGhlIHJlc3VsdCwgc28gd2Ugc2V0IHRoaXMgb3B0aW9uIHRvIHJlbHkgb25cbiAgLy8gYGFzUHJvbWlzZSgpYCB0byBoYW5kbGUgYW55IGVycm9ycy5cbiAgaWYgKF9maXJlQW5kRm9yZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuJGluaXRpYWxDb25uZWN0aW9uO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBfaGFuZGxlQ29ubmVjdGlvbkVycm9ycyhlcnIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF92YWxpZGF0ZUFyZ3ModXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgJiYgY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uLnByb3RvdHlwZS5vcGVuVXJpKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uLnByb3RvdHlwZS5vcGVuVXJpKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2hhbmRsZUNvbm5lY3Rpb25FcnJvcnMoZXJyKSB7XG4gIGlmIChlcnI/Lm5hbWUgPT09ICdNb25nb1NlcnZlclNlbGVjdGlvbkVycm9yJykge1xuICAgIGNvbnN0IG9yaWdpbmFsRXJyb3IgPSBlcnI7XG4gICAgZXJyID0gbmV3IFNlcnZlclNlbGVjdGlvbkVycm9yKCk7XG4gICAgZXJyLmFzc2ltaWxhdGVFcnJvcihvcmlnaW5hbEVycm9yKTtcbiAgfVxuXG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogRGVzdHJveSB0aGUgY29ubmVjdGlvbi4gU2ltaWxhciB0byBbYC5jbG9zZWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvY29ubmVjdGlvbi5odG1sI0Nvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlKCkpLFxuICogYnV0IGFsc28gcmVtb3ZlcyB0aGUgY29ubmVjdGlvbiBmcm9tIE1vbmdvb3NlJ3MgYGNvbm5lY3Rpb25zYCBsaXN0IGFuZCBwcmV2ZW50cyB0aGVcbiAqIGNvbm5lY3Rpb24gZnJvbSBldmVyIGJlaW5nIHJlLW9wZW5lZC5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBhc3luYyBmdW5jdGlvbiBkZXN0cm95KGZvcmNlKSB7XG4gIGlmICh0eXBlb2YgZm9yY2UgPT09ICdmdW5jdGlvbicgfHwgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuZGVzdHJveSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmIChmb3JjZSAhPSBudWxsICYmIHR5cGVvZiBmb3JjZSA9PT0gJ29iamVjdCcpIHtcbiAgICB0aGlzLiR3YXNGb3JjZUNsb3NlZCA9ICEhZm9yY2UuZm9yY2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy4kd2FzRm9yY2VDbG9zZWQgPSAhIWZvcmNlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2Nsb3NlKGZvcmNlLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdIG9wdGlvbmFsXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGFzeW5jIGZ1bmN0aW9uIGNsb3NlKGZvcmNlKSB7XG4gIGlmICh0eXBlb2YgZm9yY2UgPT09ICdmdW5jdGlvbicgfHwgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoZm9yY2UgIT0gbnVsbCAmJiB0eXBlb2YgZm9yY2UgPT09ICdvYmplY3QnKSB7XG4gICAgdGhpcy4kd2FzRm9yY2VDbG9zZWQgPSAhIWZvcmNlLmZvcmNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuJHdhc0ZvcmNlQ2xvc2VkID0gISFmb3JjZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1vZGVscykpIHtcbiAgICAvLyBJZiBtYW51YWxseSBkaXNjb25uZWN0aW5nLCBtYWtlIHN1cmUgdG8gY2xlYXIgZWFjaCBtb2RlbCdzIGAkaW5pdGBcbiAgICAvLyBwcm9taXNlLCBzbyBNb25nb29zZSBrbm93cyB0byByZS1ydW4gYGluaXQoKWAgaW4gY2FzZSB0aGVcbiAgICAvLyBjb25uZWN0aW9uIGlzIHJlLW9wZW5lZC4gU2VlIGdoLTEyMDQ3LlxuICAgIGRlbGV0ZSBtb2RlbC4kaW5pdDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jbG9zZShmb3JjZSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGNsb3NpbmcgdGhlIGNvbm5lY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRlc3Ryb3lcbiAqIEByZXR1cm5zIHtDb25uZWN0aW9ufSB0aGlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Nsb3NlID0gYXN5bmMgZnVuY3Rpb24gX2Nsb3NlKGZvcmNlLCBkZXN0cm95KSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgY29uc3QgY2xvc2VDYWxsZWQgPSB0aGlzLl9jbG9zZUNhbGxlZDtcbiAgdGhpcy5fY2xvc2VDYWxsZWQgPSB0cnVlO1xuICB0aGlzLl9kZXN0cm95Q2FsbGVkID0gZGVzdHJveTtcbiAgaWYgKHRoaXMuY2xpZW50ICE9IG51bGwpIHtcbiAgICB0aGlzLmNsaWVudC5fY2xvc2VDYWxsZWQgPSB0cnVlO1xuICAgIHRoaXMuY2xpZW50Ll9kZXN0cm95Q2FsbGVkID0gZGVzdHJveTtcbiAgfVxuXG4gIGNvbnN0IGNvbm4gPSB0aGlzO1xuICBzd2l0Y2ggKHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGNhc2UgU1RBVEVTLmRpc2Nvbm5lY3RlZDpcbiAgICAgIGlmIChkZXN0cm95ICYmIHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pICE9PSAtMSkge1xuICAgICAgICB0aGlzLmJhc2UuY29ubmVjdGlvbnMuc3BsaWNlKHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pLCAxKTtcbiAgICAgIH1cbiAgICAgIGlmICghY2xvc2VDYWxsZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kb0Nsb3NlKGZvcmNlKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlKGZvcmNlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTVEFURVMuY29ubmVjdGVkOlxuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3Rpbmc7XG4gICAgICBhd2FpdCB0aGlzLmRvQ2xvc2UoZm9yY2UpO1xuICAgICAgaWYgKGRlc3Ryb3kgJiYgX3RoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pICE9PSAtMSkge1xuICAgICAgICB0aGlzLmJhc2UuY29ubmVjdGlvbnMuc3BsaWNlKHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pLCAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub25DbG9zZShmb3JjZSk7XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU1RBVEVTLmNvbm5lY3Rpbmc6XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBfcmVydW5DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgX3JlcnVuQ2xvc2UpO1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgX3JlcnVuQ2xvc2UpO1xuICAgICAgICAgIGlmIChkZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koZm9yY2UpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZShmb3JjZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9uY2UoJ29wZW4nLCBfcmVydW5DbG9zZSk7XG4gICAgICAgIHRoaXMub25jZSgnZXJyb3InLCBfcmVydW5DbG9zZSk7XG4gICAgICB9KTtcblxuICAgIGNhc2UgU1RBVEVTLmRpc2Nvbm5lY3Rpbmc6XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKGRlc3Ryb3kgJiYgdGhpcy5iYXNlLmNvbm5lY3Rpb25zLmluZGV4T2YoY29ubikgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UuY29ubmVjdGlvbnMuc3BsaWNlKHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24jZG9DbG9zZSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBjbG9zZXNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3RlZDtcblxuICAvLyBhdm9pZCBoYXZpbmcgdGhlIGNvbGxlY3Rpb24gc3Vic2NyaWJlIHRvIG91ciBldmVudCBlbWl0dGVyXG4gIC8vIHRvIHByZXZlbnQgMC4zIHdhcm5pbmdcbiAgZm9yIChjb25zdCBpIGluIHRoaXMuY29sbGVjdGlvbnMpIHtcbiAgICBpZiAodXRpbHMub2JqZWN0Lmhhc093blByb3BlcnR5KHRoaXMuY29sbGVjdGlvbnMsIGkpKSB7XG4gICAgICB0aGlzLmNvbGxlY3Rpb25zW2ldLm9uQ2xvc2UoZm9yY2UpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBmb3JjZSk7XG5cbiAgZm9yIChjb25zdCBkYiBvZiB0aGlzLm90aGVyRGJzKSB7XG4gICAgdGhpcy5fZGVzdHJveUNhbGxlZCA/IGRiLmRlc3Ryb3koeyBmb3JjZTogZm9yY2UsIHNraXBDbG9zZUNsaWVudDogdHJ1ZSB9KSA6IGRiLmNsb3NlKHsgZm9yY2U6IGZvcmNlLCBza2lwQ2xvc2VDbGllbnQ6IHRydWUgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgcmF3IGNvbGxlY3Rpb24gaW5zdGFuY2UsIGNyZWF0aW5nIGl0IGlmIG5vdCBjYWNoZWQuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgdGhpbiB3cmFwcGVyIGFyb3VuZCBhIFtNb25nb0RCIE5vZGUuanMgZHJpdmVyIGNvbGxlY3Rpb25dKFtNb25nb0RCIE5vZGUuanMgZHJpdmVyIGNvbGxlY3Rpb25dKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS9OZXh0L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sKSkuXG4gKiBVc2luZyBhIENvbGxlY3Rpb24gYnlwYXNzZXMgTW9uZ29vc2UgbWlkZGxld2FyZSwgdmFsaWRhdGlvbiwgYW5kIGNhc3RpbmcsXG4gKiBsZXR0aW5nIHlvdSB1c2UgW01vbmdvREIgTm9kZS5qcyBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS8pIGZ1bmN0aW9uYWxpdHkgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgY29sbGVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtDb2xsZWN0aW9ufSBjb2xsZWN0aW9uIGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNvbGxlY3Rpb24gPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGF1dG9JbmRleDogdGhpcy5jb25maWcuYXV0b0luZGV4ICE9IG51bGwgPyB0aGlzLmNvbmZpZy5hdXRvSW5kZXggOiB0aGlzLmJhc2Uub3B0aW9ucy5hdXRvSW5kZXgsXG4gICAgYXV0b0NyZWF0ZTogdGhpcy5jb25maWcuYXV0b0NyZWF0ZSAhPSBudWxsID8gdGhpcy5jb25maWcuYXV0b0NyZWF0ZSA6IHRoaXMuYmFzZS5vcHRpb25zLmF1dG9DcmVhdGVcbiAgfTtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zID8gY2xvbmUob3B0aW9ucykgOiB7fSk7XG4gIG9wdGlvbnMuJHdhc0ZvcmNlQ2xvc2VkID0gdGhpcy4kd2FzRm9yY2VDbG9zZWQ7XG4gIGNvbnN0IENvbGxlY3Rpb24gPSB0aGlzLmJhc2UgJiYgdGhpcy5iYXNlLl9fZHJpdmVyICYmIHRoaXMuYmFzZS5fX2RyaXZlci5Db2xsZWN0aW9uIHx8IGRyaXZlci5nZXQoKS5Db2xsZWN0aW9uO1xuICBpZiAoIShuYW1lIGluIHRoaXMuY29sbGVjdGlvbnMpKSB7XG4gICAgdGhpcy5jb2xsZWN0aW9uc1tuYW1lXSA9IG5ldyBDb2xsZWN0aW9uKG5hbWUsIHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB0aGlzLmNvbGxlY3Rpb25zW25hbWVdO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhIHBsdWdpbiBleGVjdXRlZCBvbiBhbGwgc2NoZW1hcyB5b3UgcGFzcyB0byBgY29ubi5tb2RlbCgpYFxuICpcbiAqIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgLnBsdWdpbihmbilgIG9uIGVhY2ggc2NoZW1hIHlvdSBjcmVhdGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkYiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvbXlkYicpO1xuICogICAgIGRiLnBsdWdpbigoKSA9PiBjb25zb2xlLmxvZygnQXBwbGllZCcpKTtcbiAqICAgICBkYi5wbHVnaW5zLmxlbmd0aDsgLy8gMVxuICpcbiAqICAgICBkYi5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoe30pKTsgLy8gUHJpbnRzIFwiQXBwbGllZFwiXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gcGx1Z2luIGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IHRoaXNcbiAqIEBzZWUgcGx1Z2lucyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcGx1Z2lucy5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnBsdWdpbiA9IGZ1bmN0aW9uKGZuLCBvcHRzKSB7XG4gIHRoaXMucGx1Z2lucy5wdXNoKFtmbiwgb3B0c10pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyBvciByZXRyaWV2ZXMgYSBtb2RlbC5cbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIGNvbnN0IGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbiguLik7XG4gKiAgICAgZGIubW9kZWwoJ1ZlbnVlJywgbmV3IFNjaGVtYSguLikpO1xuICogICAgIGNvbnN0IFRpY2tldCA9IGRiLm1vZGVsKCdUaWNrZXQnLCBuZXcgU2NoZW1hKC4uKSk7XG4gKiAgICAgY29uc3QgVmVudWUgPSBkYi5tb2RlbCgnVmVudWUnKTtcbiAqXG4gKiBfV2hlbiBubyBgY29sbGVjdGlvbmAgYXJndW1lbnQgaXMgcGFzc2VkLCBNb25nb29zZSBwcm9kdWNlcyBhIGNvbGxlY3Rpb24gbmFtZSBieSBwYXNzaW5nIHRoZSBtb2RlbCBgbmFtZWAgdG8gdGhlIGB1dGlscy50b0NvbGxlY3Rpb25OYW1lYCBtZXRob2QuIFRoaXMgbWV0aG9kIHBsdXJhbGl6ZXMgdGhlIG5hbWUuIElmIHlvdSBkb24ndCBsaWtlIHRoaXMgYmVoYXZpb3IsIGVpdGhlciBwYXNzIGEgY29sbGVjdGlvbiBuYW1lIG9yIHNldCB5b3VyIHNjaGVtYXMgY29sbGVjdGlvbiBuYW1lIG9wdGlvbi5fXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgY29sbGVjdGlvbjogJ2FjdG9yJyB9KTtcbiAqXG4gKiAgICAgLy8gb3JcbiAqXG4gKiAgICAgc2NoZW1hLnNldCgnY29sbGVjdGlvbicsICdhY3RvcicpO1xuICpcbiAqICAgICAvLyBvclxuICpcbiAqICAgICBjb25zdCBjb2xsZWN0aW9uTmFtZSA9ICdhY3RvcidcbiAqICAgICBjb25zdCBNID0gY29ubi5tb2RlbCgnQWN0b3InLCBzY2hlbWEsIGNvbGxlY3Rpb25OYW1lKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBuYW1lIHRoZSBtb2RlbCBuYW1lIG9yIGNsYXNzIGV4dGVuZGluZyBNb2RlbFxuICogQHBhcmFtIHtTY2hlbWF9IFtzY2hlbWFdIGEgc2NoZW1hLiBuZWNlc3Nhcnkgd2hlbiBkZWZpbmluZyBhIG1vZGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NvbGxlY3Rpb25dIG5hbWUgb2YgbW9uZ29kYiBjb2xsZWN0aW9uIChvcHRpb25hbCkgaWYgbm90IGdpdmVuIGl0IHdpbGwgYmUgaW5kdWNlZCBmcm9tIG1vZGVsIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlTW9kZWxzPWZhbHNlXSBJZiB0cnVlLCBvdmVyd3JpdGUgZXhpc3RpbmcgbW9kZWxzIHdpdGggdGhlIHNhbWUgbmFtZSB0byBhdm9pZCBgT3ZlcndyaXRlTW9kZWxFcnJvcmBcbiAqIEBzZWUgTW9uZ29vc2UjbW9kZWwgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5tb2RlbCgpXG4gKiBAcmV0dXJuIHtNb2RlbH0gVGhlIGNvbXBpbGVkIG1vZGVsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb25uZWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdgY29ubmVjdGlvbi5tb2RlbCgpYCBzaG91bGQgbm90IGJlIHJ1biB3aXRoICcgK1xuICAgICAgJ2BuZXdgLiBJZiB5b3UgYXJlIGRvaW5nIGBuZXcgZGIubW9kZWwoZm9vKShiYXIpYCwgdXNlICcgK1xuICAgICAgJ2BkYi5tb2RlbChmb28pKGJhcilgIGluc3RlYWQnKTtcbiAgfVxuXG4gIGxldCBmbjtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBuYW1lO1xuICAgIG5hbWUgPSBmbi5uYW1lO1xuICB9XG5cbiAgLy8gY29sbGVjdGlvbiBuYW1lIGRpc2NvdmVyeVxuICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb2xsZWN0aW9uID0gc2NoZW1hO1xuICAgIHNjaGVtYSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KHNjaGVtYSkpIHtcbiAgICBpZiAoIXNjaGVtYS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICBzY2hlbWEgPSBuZXcgU2NoZW1hKHNjaGVtYSk7XG4gICAgfSBlbHNlIGlmICghKHNjaGVtYSBpbnN0YW5jZW9mIHRoaXMuYmFzZS5TY2hlbWEpKSB7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuX2Nsb25lKHRoaXMuYmFzZS5TY2hlbWEpO1xuICAgIH1cbiAgfVxuICBpZiAoc2NoZW1hICYmICFzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIDJuZCBwYXJhbWV0ZXIgdG8gYG1vbmdvb3NlLm1vZGVsKClgIHNob3VsZCBiZSBhICcgK1xuICAgICAgJ3NjaGVtYSBvciBhIFBPSk8nKTtcbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0geyBjYWNoZTogZmFsc2UsIG92ZXJ3cml0ZU1vZGVsczogdGhpcy5iYXNlLm9wdGlvbnMub3ZlcndyaXRlTW9kZWxzIH07XG4gIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zLCB7IGNvbm5lY3Rpb246IHRoaXMgfSk7XG4gIGlmICh0aGlzLm1vZGVsc1tuYW1lXSAmJiAhY29sbGVjdGlvbiAmJiBvcHRzLm92ZXJ3cml0ZU1vZGVscyAhPT0gdHJ1ZSkge1xuICAgIC8vIG1vZGVsIGV4aXN0cyBidXQgd2UgYXJlIG5vdCBzdWJjbGFzc2luZyB3aXRoIGN1c3RvbSBjb2xsZWN0aW9uXG4gICAgaWYgKHNjaGVtYSAmJiBzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSAmJiBzY2hlbWEgIT09IHRoaXMubW9kZWxzW25hbWVdLnNjaGVtYSkge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IuT3ZlcndyaXRlTW9kZWxFcnJvcihuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubW9kZWxzW25hbWVdO1xuICB9XG5cbiAgbGV0IG1vZGVsO1xuXG4gIGlmIChzY2hlbWEgJiYgc2NoZW1hLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICBhcHBseVBsdWdpbnMoc2NoZW1hLCB0aGlzLnBsdWdpbnMsIG51bGwsICckY29ubmVjdGlvblBsdWdpbnNBcHBsaWVkJyk7XG5cbiAgICAvLyBjb21waWxlIGEgbW9kZWxcbiAgICBtb2RlbCA9IHRoaXMuYmFzZS5fbW9kZWwoZm4gfHwgbmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uLCBvcHRzKTtcblxuICAgIC8vIG9ubHkgdGhlIGZpcnN0IG1vZGVsIHdpdGggdGhpcyBuYW1lIGlzIGNhY2hlZCB0byBhbGxvd1xuICAgIC8vIGZvciBvbmUtb2ZmcyB3aXRoIGN1c3RvbSBjb2xsZWN0aW9uIG5hbWVzIGV0Yy5cbiAgICBpZiAoIXRoaXMubW9kZWxzW25hbWVdKSB7XG4gICAgICB0aGlzLm1vZGVsc1tuYW1lXSA9IG1vZGVsO1xuICAgIH1cblxuICAgIC8vIEVycm9ycyBoYW5kbGVkIGludGVybmFsbHksIHNvIHNhZmUgdG8gaWdub3JlIGVycm9yXG4gICAgbW9kZWwuaW5pdCgpLmNhdGNoKGZ1bmN0aW9uICRtb2RlbEluaXROb29wKCkge30pO1xuXG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgaWYgKHRoaXMubW9kZWxzW25hbWVdICYmIGNvbGxlY3Rpb24pIHtcbiAgICAvLyBzdWJjbGFzc2luZyBjdXJyZW50IG1vZGVsIHdpdGggYWx0ZXJuYXRlIGNvbGxlY3Rpb25cbiAgICBtb2RlbCA9IHRoaXMubW9kZWxzW25hbWVdO1xuICAgIHNjaGVtYSA9IG1vZGVsLnByb3RvdHlwZS5zY2hlbWE7XG4gICAgY29uc3Qgc3ViID0gbW9kZWwuX19zdWJjbGFzcyh0aGlzLCBzY2hlbWEsIGNvbGxlY3Rpb24pO1xuICAgIC8vIGRvIG5vdCBjYWNoZSB0aGUgc3ViIG1vZGVsXG4gICAgcmV0dXJuIHN1YjtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgbW9kZWwgPSB0aGlzLm1vZGVsc1tuYW1lXTtcbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvci5NaXNzaW5nU2NoZW1hRXJyb3IobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuXG4gIGlmICghbW9kZWwpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvci5NaXNzaW5nU2NoZW1hRXJyb3IobmFtZSk7XG4gIH1cblxuICBpZiAodGhpcyA9PT0gbW9kZWwucHJvdG90eXBlLmRiXG4gICAgICAmJiAoIWNvbGxlY3Rpb24gfHwgY29sbGVjdGlvbiA9PT0gbW9kZWwuY29sbGVjdGlvbi5uYW1lKSkge1xuICAgIC8vIG1vZGVsIGFscmVhZHkgdXNlcyB0aGlzIGNvbm5lY3Rpb24uXG5cbiAgICAvLyBvbmx5IHRoZSBmaXJzdCBtb2RlbCB3aXRoIHRoaXMgbmFtZSBpcyBjYWNoZWQgdG8gYWxsb3dcbiAgICAvLyBmb3Igb25lLW9mZnMgd2l0aCBjdXN0b20gY29sbGVjdGlvbiBuYW1lcyBldGMuXG4gICAgaWYgKCF0aGlzLm1vZGVsc1tuYW1lXSkge1xuICAgICAgdGhpcy5tb2RlbHNbbmFtZV0gPSBtb2RlbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgdGhpcy5tb2RlbHNbbmFtZV0gPSBtb2RlbC5fX3N1YmNsYXNzKHRoaXMsIHNjaGVtYSwgY29sbGVjdGlvbik7XG4gIHJldHVybiB0aGlzLm1vZGVsc1tuYW1lXTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbW9kZWwgbmFtZWQgYG5hbWVgIGZyb20gdGhpcyBjb25uZWN0aW9uLCBpZiBpdCBleGlzdHMuIFlvdSBjYW5cbiAqIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNsZWFuIHVwIGFueSBtb2RlbHMgeW91IGNyZWF0ZWQgaW4geW91ciB0ZXN0cyB0b1xuICogcHJldmVudCBPdmVyd3JpdGVNb2RlbEVycm9ycy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbm4ubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqICAgICBjb25zb2xlLmxvZyhjb25uLm1vZGVsKCdVc2VyJykpOyAvLyBNb2RlbCBvYmplY3RcbiAqICAgICBjb25uLmRlbGV0ZU1vZGVsKCdVc2VyJyk7XG4gKiAgICAgY29uc29sZS5sb2coY29ubi5tb2RlbCgnVXNlcicpKTsgLy8gdW5kZWZpbmVkXG4gKlxuICogICAgIC8vIFVzdWFsbHkgdXNlZnVsIGluIGEgTW9jaGEgYGFmdGVyRWFjaCgpYCBob29rXG4gKiAgICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uKCkge1xuICogICAgICAgY29ubi5kZWxldGVNb2RlbCgvLisvKTsgLy8gRGVsZXRlIGV2ZXJ5IG1vZGVsXG4gKiAgICAgfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gbmFtZSBpZiBzdHJpbmcsIHRoZSBuYW1lIG9mIHRoZSBtb2RlbCB0byByZW1vdmUuIElmIHJlZ2V4cCwgcmVtb3ZlcyBhbGwgbW9kZWxzIHdob3NlIG5hbWUgbWF0Y2hlcyB0aGUgcmVnZXhwLlxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gdGhpc1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRlbGV0ZU1vZGVsID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVsKG5hbWUpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgY29sbGVjdGlvbk5hbWUgPSBtb2RlbC5jb2xsZWN0aW9uLm5hbWU7XG4gICAgZGVsZXRlIHRoaXMubW9kZWxzW25hbWVdO1xuICAgIGRlbGV0ZSB0aGlzLmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25OYW1lXTtcblxuICAgIHRoaXMuZW1pdCgnZGVsZXRlTW9kZWwnLCBtb2RlbCk7XG4gIH0gZWxzZSBpZiAobmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBuYW1lO1xuICAgIGNvbnN0IG5hbWVzID0gdGhpcy5tb2RlbE5hbWVzKCk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XG4gICAgICBpZiAocGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlTW9kZWwobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIHRvIGBkZWxldGVNb2RlbCgpYCBtdXN0IGJlIGEgc3RyaW5nICcgK1xuICAgICAgJ29yIHJlZ2V4cCwgZ290IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYXRjaGVzIHRoZSBlbnRpcmUgdW5kZXJseWluZyBkYXRhYmFzZSBmb3IgY2hhbmdlcy4gU2ltaWxhciB0b1xuICogW2BNb2RlbC53YXRjaCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLndhdGNoKCkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyAqKm5vdCoqIHRyaWdnZXIgYW55IG1pZGRsZXdhcmUuIEluIHBhcnRpY3VsYXIsIGl0XG4gKiBkb2VzICoqbm90KiogdHJpZ2dlciBhZ2dyZWdhdGUgbWlkZGxld2FyZS5cbiAqXG4gKiBUaGUgQ2hhbmdlU3RyZWFtIG9iamVjdCBpcyBhbiBldmVudCBlbWl0dGVyIHRoYXQgZW1pdHMgdGhlIGZvbGxvd2luZyBldmVudHM6XG4gKlxuICogLSAnY2hhbmdlJzogQSBjaGFuZ2Ugb2NjdXJyZWQsIHNlZSBiZWxvdyBleGFtcGxlXG4gKiAtICdlcnJvcic6IEFuIHVucmVjb3ZlcmFibGUgZXJyb3Igb2NjdXJyZWQuIEluIHBhcnRpY3VsYXIsIGNoYW5nZSBzdHJlYW1zIGN1cnJlbnRseSBlcnJvciBvdXQgaWYgdGhleSBsb3NlIGNvbm5lY3Rpb24gdG8gdGhlIHJlcGxpY2Egc2V0IHByaW1hcnkuIEZvbGxvdyBbdGhpcyBHaXRIdWIgaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL21vbmdvb3NlL2lzc3Vlcy82Nzk5KSBmb3IgdXBkYXRlcy5cbiAqIC0gJ2VuZCc6IEVtaXR0ZWQgaWYgdGhlIHVuZGVybHlpbmcgc3RyZWFtIGlzIGNsb3NlZFxuICogLSAnY2xvc2UnOiBFbWl0dGVkIGlmIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBpcyBjbG9zZWRcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFVzZXIgPSBjb25uLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KSk7XG4gKlxuICogICAgIGNvbnN0IGNoYW5nZVN0cmVhbSA9IGNvbm4ud2F0Y2goKS5vbignY2hhbmdlJywgZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKSk7XG4gKlxuICogICAgIC8vIFRyaWdnZXJzIGEgJ2NoYW5nZScgZXZlbnQgb24gdGhlIGNoYW5nZSBzdHJlYW0uXG4gKiAgICAgYXdhaXQgVXNlci5jcmVhdGUoeyBuYW1lOiAndGVzdCcgfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwYXJhbSB7QXJyYXl9IFtwaXBlbGluZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gcGFzc2VkIHdpdGhvdXQgY2hhbmdlcyB0byBbdGhlIE1vbmdvREIgZHJpdmVyJ3MgYERiI3dhdGNoKClgIGZ1bmN0aW9uXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvRGIuaHRtbCN3YXRjaClcbiAqIEByZXR1cm4ge0NoYW5nZVN0cmVhbX0gbW9uZ29vc2Utc3BlY2lmaWMgY2hhbmdlIHN0cmVhbSB3cmFwcGVyLCBpbmhlcml0cyBmcm9tIEV2ZW50RW1pdHRlclxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24ocGlwZWxpbmUsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhbmdlU3RyZWFtVGh1bmsgPSBjYiA9PiB7XG4gICAgaW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nKSB7XG4gICAgICAgIHRoaXMub25jZSgnb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnN0IGRyaXZlckNoYW5nZVN0cmVhbSA9IHRoaXMuZGIud2F0Y2gocGlwZWxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgIGNiKG51bGwsIGRyaXZlckNoYW5nZVN0cmVhbSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZHJpdmVyQ2hhbmdlU3RyZWFtID0gdGhpcy5kYi53YXRjaChwaXBlbGluZSwgb3B0aW9ucyk7XG4gICAgICAgIGNiKG51bGwsIGRyaXZlckNoYW5nZVN0cmVhbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgY2hhbmdlU3RyZWFtID0gbmV3IENoYW5nZVN0cmVhbShjaGFuZ2VTdHJlYW1UaHVuaywgcGlwZWxpbmUsIG9wdGlvbnMpO1xuICByZXR1cm4gY2hhbmdlU3RyZWFtO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhpcyBjb25uZWN0aW9uXG4gKiBzdWNjZXNzZnVsbHkgY29ubmVjdHMgdG8gTW9uZ29EQiwgb3IgcmVqZWN0cyBpZiB0aGlzIGNvbm5lY3Rpb24gZmFpbGVkXG4gKiB0byBjb25uZWN0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY29ubiA9IGF3YWl0IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvdGVzdCcpLlxuICogICAgICAgYXNQcm9taXNlKCk7XG4gKiAgICAgY29ubi5yZWFkeVN0YXRlOyAvLyAxLCBtZWFucyBNb25nb29zZSBpcyBjb25uZWN0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5hc1Byb21pc2UgPSBhc3luYyBmdW5jdGlvbiBhc1Byb21pc2UoKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy4kaW5pdGlhbENvbm5lY3Rpb247XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IF9oYW5kbGVDb25uZWN0aW9uRXJyb3JzKGVycik7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBtb2RlbCBuYW1lcyBjcmVhdGVkIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5tb2RlbE5hbWVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm1vZGVscyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgaWYgdGhlIGNvbm5lY3Rpb24gcmVxdWlyZXMgYXV0aGVudGljYXRpb24gYWZ0ZXIgaXQgaXMgb3BlbmVkLiBHZW5lcmFsbHkgaWYgYVxuICogdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGFyZSBib3RoIHByb3ZpZGVkIHRoYW4gYXV0aGVudGljYXRpb24gaXMgbmVlZGVkLCBidXQgaW4gc29tZSBjYXNlcyBhXG4gKiBwYXNzd29yZCBpcyBub3QgcmVxdWlyZWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIHNob3VsZCBiZSBhdXRoZW50aWNhdGVkIGFmdGVyIGl0IGlzIG9wZW5lZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zaG91bGRBdXRoZW50aWNhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudXNlciAhPSBudWxsICYmXG4gICAgKHRoaXMucGFzcyAhPSBudWxsIHx8IHRoaXMuYXV0aE1lY2hhbmlzbURvZXNOb3RSZXF1aXJlUGFzc3dvcmQoKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBib29sZWFuIHZhbHVlIHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSBuZWVkcyBhXG4gKiBwYXNzd29yZCB0byBhdXRoZW50aWNhdGUgYWNjb3JkaW5nIHRvIHRoZSBhdXRoIG9iamVjdHMgcGFzc2VkIGludG8gdGhlIG9wZW5VcmkgbWV0aG9kcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHJlcXVpcmVzXG4gKiAgYSBwYXNzd29yZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5hdXRoTWVjaGFuaXNtRG9lc05vdFJlcXVpcmVQYXNzd29yZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5hdXRoKSB7XG4gICAgcmV0dXJuIG5vUGFzc3dvcmRBdXRoTWVjaGFuaXNtcy5pbmRleE9mKHRoaXMub3B0aW9ucy5hdXRoLmF1dGhNZWNoYW5pc20pID49IDA7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBib29sZWFuIHZhbHVlIHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBwcm92aWRlZCBvYmplY3RzIG9iamVjdCBwcm92aWRlcyBlbm91Z2hcbiAqIGRhdGEgdG8gYXV0aGVudGljYXRlIHdpdGguIEdlbmVyYWxseSB0aGlzIGlzIHRydWUgaWYgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZCBhcmUgYm90aCBzcGVjaWZpZWRcbiAqIGJ1dCBpbiBzb21lIGF1dGhlbnRpY2F0aW9uIG1ldGhvZHMsIGEgcGFzc3dvcmQgaXMgbm90IHJlcXVpcmVkIGZvciBhdXRoZW50aWNhdGlvbiBzbyBvbmx5IGEgdXNlcm5hbWVcbiAqIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCBpbnRvIHRoZSBvcGVuVXJpIG1ldGhvZHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHByb3ZpZGVkIG9wdGlvbnMgb2JqZWN0IHByb3ZpZGVzIGVub3VnaCBkYXRhIHRvIGF1dGhlbnRpY2F0ZSB3aXRoLFxuICogICBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm9wdGlvbnNQcm92aWRlQXV0aGVudGljYXRpb25EYXRhID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gKG9wdGlvbnMpICYmXG4gICAgICAob3B0aW9ucy51c2VyKSAmJlxuICAgICAgKChvcHRpb25zLnBhc3MpIHx8IHRoaXMuYXV0aE1lY2hhbmlzbURvZXNOb3RSZXF1aXJlUGFzc3dvcmQoKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIFtNb25nb0RCIGRyaXZlciBgTW9uZ29DbGllbnRgXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvTW9uZ29DbGllbnQuaHRtbCkgaW5zdGFuY2VcbiAqIHRoYXQgdGhpcyBjb25uZWN0aW9uIHVzZXMgdG8gdGFsayB0byBNb25nb0RCLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY29ubiA9IGF3YWl0IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvdGVzdCcpLlxuICogICAgICAgYXNQcm9taXNlKCk7XG4gKlxuICogICAgIGNvbm4uZ2V0Q2xpZW50KCk7IC8vIE1vbmdvQ2xpZW50IHsgLi4uIH1cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7TW9uZ29DbGllbnR9XG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0Q2xpZW50ID0gZnVuY3Rpb24gZ2V0Q2xpZW50KCkge1xuICByZXR1cm4gdGhpcy5jbGllbnQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgW01vbmdvREIgZHJpdmVyIGBNb25nb0NsaWVudGBdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Nb25nb0NsaWVudC5odG1sKSBpbnN0YW5jZVxuICogdGhhdCB0aGlzIGNvbm5lY3Rpb24gdXNlcyB0byB0YWxrIHRvIE1vbmdvREIuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBhbHJlYWR5IGhhdmUgYSBNb25nb0NsaWVudCBpbnN0YW5jZSwgYW5kIHdhbnQgdG9cbiAqIHJldXNlIGl0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgbW9uZ29kYi5Nb25nb0NsaWVudC5jb25uZWN0KCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L3Rlc3QnKTtcbiAqXG4gKiAgICAgY29uc3QgY29ubiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oKS5zZXRDbGllbnQoY2xpZW50KTtcbiAqXG4gKiAgICAgY29ubi5nZXRDbGllbnQoKTsgLy8gTW9uZ29DbGllbnQgeyAuLi4gfVxuICogICAgIGNvbm4ucmVhZHlTdGF0ZTsgLy8gMSwgbWVhbnMgJ0NPTk5FQ1RFRCdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHBhcmFtIHtNb25nQ2xpZW50fSBjbGllbnQgVGhlIENsaWVudCB0byBzZXQgdG8gYmUgdXNlZC5cbiAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IHRoaXNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zZXRDbGllbnQgPSBmdW5jdGlvbiBzZXRDbGllbnQoKSB7XG4gIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uI3NldENsaWVudCBub3QgaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKiFcbiAqIENhbGxlZCBpbnRlcm5hbGx5IGJ5IGBvcGVuVXJpKClgIHRvIGNyZWF0ZSBhIE1vbmdvQ2xpZW50IGluc3RhbmNlLlxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUNsaWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudCgpIHtcbiAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nvbm5lY3Rpb24jY3JlYXRlQ2xpZW50IG5vdCBpbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogU3luY3MgYWxsIHRoZSBpbmRleGVzIGZvciB0aGUgbW9kZWxzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb250aW51ZU9uRXJyb3JdIGBmYWxzZWAgYnkgZGVmYXVsdC4gSWYgc2V0IHRvIGB0cnVlYCwgbW9uZ29vc2Ugd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IgaWYgb25lIG1vZGVsIHN5bmNpbmcgZmFpbGVkLCBhbmQgd2lsbCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIHRoZSBrZXlzIGFyZSB0aGUgbmFtZXMgb2YgdGhlIG1vZGVscywgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZSByZXN1bHRzL2Vycm9ycyBmb3IgZWFjaCBtb2RlbC5cbiAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gUmV0dXJucyBhIFByb21pc2UsIHdoZW4gdGhlIFByb21pc2UgcmVzb2x2ZXMgdGhlIHZhbHVlIGlzIGEgbGlzdCBvZiB0aGUgZHJvcHBlZCBpbmRleGVzLlxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zeW5jSW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIHN5bmNJbmRleGVzKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgZXJyb3JzTWFwID0geyB9O1xuXG4gIGNvbnN0IHsgY29udGludWVPbkVycm9yIH0gPSBvcHRpb25zO1xuICBkZWxldGUgb3B0aW9ucy5jb250aW51ZU9uRXJyb3I7XG5cbiAgZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3QudmFsdWVzKHRoaXMubW9kZWxzKSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHRbbW9kZWwubW9kZWxOYW1lXSA9IGF3YWl0IG1vZGVsLnN5bmNJbmRleGVzKG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFjb250aW51ZU9uRXJyb3IpIHtcbiAgICAgICAgZXJyb3JzTWFwW21vZGVsLm1vZGVsTmFtZV0gPSBlcnI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W21vZGVsLm1vZGVsTmFtZV0gPSBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250aW51ZU9uRXJyb3IgJiYgT2JqZWN0LmtleXMoZXJyb3JzTWFwKS5sZW5ndGgpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzTWFwKS5tYXAoKFttb2RlbE5hbWUsIGVycl0pID0+IGAke21vZGVsTmFtZX06ICR7ZXJyLm1lc3NhZ2V9YCkuam9pbignLCAnKTtcbiAgICBjb25zdCBzeW5jSW5kZXhlc0Vycm9yID0gbmV3IFN5bmNJbmRleGVzRXJyb3IobWVzc2FnZSwgZXJyb3JzTWFwKTtcbiAgICB0aHJvdyBzeW5jSW5kZXhlc0Vycm9yO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU3dpdGNoZXMgdG8gYSBkaWZmZXJlbnQgZGF0YWJhc2UgdXNpbmcgdGhlIHNhbWUgW2Nvbm5lY3Rpb24gcG9vbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uc2h0bWwjY29ubmVjdGlvbl9wb29scykuXG4gKlxuICogUmV0dXJucyBhIG5ldyBjb25uZWN0aW9uIG9iamVjdCwgd2l0aCB0aGUgbmV3IGRiLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQ29ubmVjdCB0byBgaW5pdGlhbGRiYCBmaXJzdFxuICogICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L2luaXRpYWxkYicpLmFzUHJvbWlzZSgpO1xuICpcbiAqICAgICAvLyBDcmVhdGVzIGFuIHVuLWNhY2hlZCBjb25uZWN0aW9uIHRvIGBteWRiYFxuICogICAgIGNvbnN0IGRiID0gY29ubi51c2VEYignbXlkYicpO1xuICogICAgIC8vIENyZWF0ZXMgYSBjYWNoZWQgY29ubmVjdGlvbiB0byBgbXlkYjJgLiBBbGwgY2FsbHMgdG8gYGNvbm4udXNlRGIoJ215ZGIyJywgeyB1c2VDYWNoZTogdHJ1ZSB9KWAgd2lsbCByZXR1cm4gdGhlIHNhbWVcbiAqICAgICAvLyBjb25uZWN0aW9uIGluc3RhbmNlIGFzIG9wcG9zZWQgdG8gY3JlYXRpbmcgYSBuZXcgY29ubmVjdGlvbiBpbnN0YW5jZVxuICogICAgIGNvbnN0IGRiMiA9IGNvbm4udXNlRGIoJ215ZGIyJywgeyB1c2VDYWNoZTogdHJ1ZSB9KTtcbiAqXG4gKiBAbWV0aG9kIHVzZURiXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGRhdGFiYXNlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQ2FjaGU9ZmFsc2VdIElmIHRydWUsIGNhY2hlIHJlc3VsdHMgc28gY2FsbGluZyBgdXNlRGIoKWAgbXVsdGlwbGUgdGltZXMgd2l0aCB0aGUgc2FtZSBuYW1lIG9ubHkgY3JlYXRlcyAxIGNvbm5lY3Rpb24gb2JqZWN0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub0xpc3RlbmVyPWZhbHNlXSBJZiB0cnVlLCB0aGUgY29ubmVjdGlvbiBvYmplY3Qgd2lsbCBub3QgbWFrZSB0aGUgZGIgbGlzdGVuIHRvIGV2ZW50cyBvbiB0aGUgb3JpZ2luYWwgY29ubmVjdGlvbi4gU2VlIFtpc3N1ZSAjOTk2MV0oaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvaXNzdWVzLzk5NjEpLlxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gTmV3IENvbm5lY3Rpb24gT2JqZWN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lIGNyZWF0ZWQgd2l0aCB3aXRoIGB1c2VEYigpYC5cbiAqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gd2FzIG5vdCBmb3VuZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIENvbm5lY3QgdG8gYGluaXRpYWxkYmAgZmlyc3RcbiAqICAgICBjb25zdCBjb25uID0gYXdhaXQgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9pbml0aWFsZGInKS5hc1Byb21pc2UoKTtcbiAqXG4gKiAgICAgLy8gQ3JlYXRlcyBhbiB1bi1jYWNoZWQgY29ubmVjdGlvbiB0byBgbXlkYmBcbiAqICAgICBjb25zdCBkYiA9IGNvbm4udXNlRGIoJ215ZGInKTtcbiAqXG4gKiAgICAgLy8gQ2xvc2VzIGBkYmAsIGFuZCByZW1vdmVzIGBkYmAgZnJvbSBgY29ubi5yZWxhdGVkRGJzYCBhbmQgYGNvbm4ub3RoZXJEYnNgXG4gKiAgICAgYXdhaXQgY29ubi5yZW1vdmVEYignbXlkYicpO1xuICpcbiAqIEBtZXRob2QgcmVtb3ZlRGJcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZGF0YWJhc2UgbmFtZVxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbkNvbm5lY3Rpb24uU1RBVEVTID0gU1RBVEVTO1xubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/connection.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/connectionstate.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/connectionstate.js ***!
  \**************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n/*!\n * Connection states\n */\n\n\n\nconst STATES = module.exports = exports = Object.create(null);\n\nconst disconnected = 'disconnected';\nconst connected = 'connected';\nconst connecting = 'connecting';\nconst disconnecting = 'disconnecting';\nconst uninitialized = 'uninitialized';\n\nSTATES[0] = disconnected;\nSTATES[1] = connected;\nSTATES[2] = connecting;\nSTATES[3] = disconnecting;\nSTATES[99] = uninitialized;\n\nSTATES[disconnected] = 0;\nSTATES[connected] = 1;\nSTATES[connecting] = 2;\nSTATES[disconnecting] = 3;\nSTATES[uninitialized] = 99;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY29ubmVjdGlvbnN0YXRlLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxjb25uZWN0aW9uc3RhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiFcbiAqIENvbm5lY3Rpb24gc3RhdGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTVEFURVMgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5jb25zdCBkaXNjb25uZWN0ZWQgPSAnZGlzY29ubmVjdGVkJztcbmNvbnN0IGNvbm5lY3RlZCA9ICdjb25uZWN0ZWQnO1xuY29uc3QgY29ubmVjdGluZyA9ICdjb25uZWN0aW5nJztcbmNvbnN0IGRpc2Nvbm5lY3RpbmcgPSAnZGlzY29ubmVjdGluZyc7XG5jb25zdCB1bmluaXRpYWxpemVkID0gJ3VuaW5pdGlhbGl6ZWQnO1xuXG5TVEFURVNbMF0gPSBkaXNjb25uZWN0ZWQ7XG5TVEFURVNbMV0gPSBjb25uZWN0ZWQ7XG5TVEFURVNbMl0gPSBjb25uZWN0aW5nO1xuU1RBVEVTWzNdID0gZGlzY29ubmVjdGluZztcblNUQVRFU1s5OV0gPSB1bmluaXRpYWxpemVkO1xuXG5TVEFURVNbZGlzY29ubmVjdGVkXSA9IDA7XG5TVEFURVNbY29ubmVjdGVkXSA9IDE7XG5TVEFURVNbY29ubmVjdGluZ10gPSAyO1xuU1RBVEVTW2Rpc2Nvbm5lY3RpbmddID0gMztcblNUQVRFU1t1bmluaXRpYWxpemVkXSA9IDk5O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/connectionstate.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/cursor/AggregationCursor.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cursor/AggregationCursor.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst Readable = (__webpack_require__(/*! stream */ \"stream\").Readable);\nconst eachAsync = __webpack_require__(/*! ../helpers/cursor/eachAsync */ \"(api)/../server/node_modules/mongoose/lib/helpers/cursor/eachAsync.js\");\nconst immediate = __webpack_require__(/*! ../helpers/immediate */ \"(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * An AggregationCursor is a concurrency primitive for processing aggregation\n * results one document at a time. It is analogous to QueryCursor.\n *\n * An AggregationCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * Creating an AggregationCursor executes the model's pre aggregate hooks,\n * but **not** the model's post aggregate hooks.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Aggregate#cursor()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.cursor()) instead.\n *\n * @param {Aggregate} agg\n * @inherits Readable https://nodejs.org/api/stream.html#class-streamreadable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction AggregationCursor(agg) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, { autoDestroy: true, objectMode: true });\n\n  this.cursor = null;\n  this.agg = agg;\n  this._transforms = [];\n  const model = agg._model;\n  delete agg.options.cursor.useMongooseAggCursor;\n  this._mongooseOptions = {};\n\n  _init(model, this, agg);\n}\n\nutil.inherits(AggregationCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _init(model, c, agg) {\n  if (!model.collection.buffer) {\n    model.hooks.execPre('aggregate', agg, function() {\n      c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n      c.emit('cursor', c.cursor);\n    });\n  } else {\n    model.collection.emitter.once('queue', function() {\n      model.hooks.execPre('aggregate', agg, function() {\n        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n        c.emit('cursor', c.cursor);\n      });\n    });\n  }\n}\n\n/**\n * Necessary to satisfy the Readable API\n * @method _read\n * @memberOf AggregationCursor\n * @instance\n * @api private\n */\n\nAggregationCursor.prototype._read = function() {\n  const _this = this;\n  _next(this, function(error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function(error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\n\nif (Symbol.asyncIterator != null) {\n  const msg = 'Mongoose does not support using async iterators with an ' +\n    'existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation';\n\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\n    throw new MongooseError(msg);\n  };\n}\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example:\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {AggregationCursor}\n * @memberOf AggregationCursor\n * @api public\n * @method map\n */\n\nObject.defineProperty(AggregationCursor.prototype, 'map', {\n  value: function(fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\n * Marks this cursor as errored\n * @method _markError\n * @instance\n * @memberOf AggregationCursor\n * @api private\n */\n\nAggregationCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\n */\n\nAggregationCursor.prototype.close = async function close() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.close() no longer accepts a callback');\n  }\n  try {\n    await this.cursor.close();\n  } catch (error) {\n    this.listeners('error').length > 0 && this.emit('error', error);\n    throw error;\n  }\n  this.emit('close');\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @return {Promise}\n * @api public\n * @method next\n */\n\nAggregationCursor.prototype.next = async function next() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.next() no longer accepts a callback');\n  }\n  return new Promise((resolve, reject) => {\n    _next(this, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nAggregationCursor.prototype.eachAsync = function(fn, opts, callback) {\n  const _this = this;\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts, callback);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     // Async iterator without explicitly calling `cursor()`. Mongoose still\n *     // creates an AggregationCursor instance internally.\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n *     // You can also use an AggregationCursor instance for async iteration\n *     const cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();\n *     for await (const doc of cursor) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf AggregationCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype._transformForAsyncIterator = function() {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? { done: true } : { value: doc, done: false };\n}\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nAggregationCursor.prototype.addCursorFlag = function(flag, value) {\n  const _this = this;\n  _waitForCursor(this, function() {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function() {\n    cb();\n  });\n}\n\n/**\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n * @param {Any} ctx\n * @param {Function} cb\n * @api private\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn(doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function() {\n      callback(ctx._error);\n    });\n  }\n\n  if (ctx.cursor) {\n    return ctx.cursor.next().then(\n      doc => {\n        if (!doc) {\n          return callback(null, null);\n        }\n\n        callback(null, doc);\n      },\n      err => callback(err)\n    );\n  } else {\n    ctx.once('cursor', function() {\n      _next(ctx, cb);\n    });\n  }\n}\n\nmodule.exports = AggregationCursor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY3Vyc29yL0FnZ3JlZ2F0aW9uQ3Vyc29yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBd0I7QUFDdEQsaUJBQWlCLHNEQUEwQjtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQywwR0FBNkI7QUFDdkQsa0JBQWtCLG1CQUFPLENBQUMsNEZBQXNCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUNBQXFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG9DQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsMEJBQTBCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLE9BQU8sY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVUsT0FBTyxjQUFjO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGFBQWEsSUFBSTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGN1cnNvclxcQWdncmVnYXRpb25DdXJzb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgnc3RyZWFtJykuUmVhZGFibGU7XG5jb25zdCBlYWNoQXN5bmMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2N1cnNvci9lYWNoQXN5bmMnKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaW1tZWRpYXRlJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIEFuIEFnZ3JlZ2F0aW9uQ3Vyc29yIGlzIGEgY29uY3VycmVuY3kgcHJpbWl0aXZlIGZvciBwcm9jZXNzaW5nIGFnZ3JlZ2F0aW9uXG4gKiByZXN1bHRzIG9uZSBkb2N1bWVudCBhdCBhIHRpbWUuIEl0IGlzIGFuYWxvZ291cyB0byBRdWVyeUN1cnNvci5cbiAqXG4gKiBBbiBBZ2dyZWdhdGlvbkN1cnNvciBmdWxmaWxscyB0aGUgTm9kZS5qcyBzdHJlYW1zMyBBUEksXG4gKiBpbiBhZGRpdGlvbiB0byBzZXZlcmFsIG90aGVyIG1lY2hhbmlzbXMgZm9yIGxvYWRpbmcgZG9jdW1lbnRzIGZyb20gTW9uZ29EQlxuICogb25lIGF0IGEgdGltZS5cbiAqXG4gKiBDcmVhdGluZyBhbiBBZ2dyZWdhdGlvbkN1cnNvciBleGVjdXRlcyB0aGUgbW9kZWwncyBwcmUgYWdncmVnYXRlIGhvb2tzLFxuICogYnV0ICoqbm90KiogdGhlIG1vZGVsJ3MgcG9zdCBhZ2dyZWdhdGUgaG9va3MuXG4gKlxuICogVW5sZXNzIHlvdSdyZSBhbiBhZHZhbmNlZCB1c2VyLCBkbyAqKm5vdCoqIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MgZGlyZWN0bHkuXG4gKiBVc2UgW2BBZ2dyZWdhdGUjY3Vyc29yKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuY3Vyc29yKCkpIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtBZ2dyZWdhdGV9IGFnZ1xuICogQGluaGVyaXRzIFJlYWRhYmxlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjY2xhc3Mtc3RyZWFtcmVhZGFibGVcbiAqIEBldmVudCBgY3Vyc29yYDogRW1pdHRlZCB3aGVuIHRoZSBjdXJzb3IgaXMgY3JlYXRlZFxuICogQGV2ZW50IGBlcnJvcmA6IEVtaXR0ZWQgd2hlbiBhbiBlcnJvciBvY2N1cnJlZFxuICogQGV2ZW50IGBkYXRhYDogRW1pdHRlZCB3aGVuIHRoZSBzdHJlYW0gaXMgZmxvd2luZyBhbmQgdGhlIG5leHQgZG9jIGlzIHJlYWR5XG4gKiBAZXZlbnQgYGVuZGA6IEVtaXR0ZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGV4aGF1c3RlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBBZ2dyZWdhdGlvbkN1cnNvcihhZ2cpIHtcbiAgLy8gc2V0IGF1dG9EZXN0cm95PXRydWUgYmVjYXVzZSBvbiBub2RlIDEyIGl0J3MgYnkgZGVmYXVsdCBmYWxzZVxuICAvLyBnaC0xMDkwMiBuZWVkIGF1dG9EZXN0cm95IHRvIGRlc3Ryb3kgY29ycmVjdGx5IGFuZCBlbWl0ICdjbG9zZScgZXZlbnRcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCB7IGF1dG9EZXN0cm95OiB0cnVlLCBvYmplY3RNb2RlOiB0cnVlIH0pO1xuXG4gIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgdGhpcy5hZ2cgPSBhZ2c7XG4gIHRoaXMuX3RyYW5zZm9ybXMgPSBbXTtcbiAgY29uc3QgbW9kZWwgPSBhZ2cuX21vZGVsO1xuICBkZWxldGUgYWdnLm9wdGlvbnMuY3Vyc29yLnVzZU1vbmdvb3NlQWdnQ3Vyc29yO1xuICB0aGlzLl9tb25nb29zZU9wdGlvbnMgPSB7fTtcblxuICBfaW5pdChtb2RlbCwgdGhpcywgYWdnKTtcbn1cblxudXRpbC5pbmhlcml0cyhBZ2dyZWdhdGlvbkN1cnNvciwgUmVhZGFibGUpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9pbml0KG1vZGVsLCBjLCBhZ2cpIHtcbiAgaWYgKCFtb2RlbC5jb2xsZWN0aW9uLmJ1ZmZlcikge1xuICAgIG1vZGVsLmhvb2tzLmV4ZWNQcmUoJ2FnZ3JlZ2F0ZScsIGFnZywgZnVuY3Rpb24oKSB7XG4gICAgICBjLmN1cnNvciA9IG1vZGVsLmNvbGxlY3Rpb24uYWdncmVnYXRlKGFnZy5fcGlwZWxpbmUsIGFnZy5vcHRpb25zIHx8IHt9KTtcbiAgICAgIGMuZW1pdCgnY3Vyc29yJywgYy5jdXJzb3IpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1vZGVsLmNvbGxlY3Rpb24uZW1pdHRlci5vbmNlKCdxdWV1ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgbW9kZWwuaG9va3MuZXhlY1ByZSgnYWdncmVnYXRlJywgYWdnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYy5jdXJzb3IgPSBtb2RlbC5jb2xsZWN0aW9uLmFnZ3JlZ2F0ZShhZ2cuX3BpcGVsaW5lLCBhZ2cub3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGMuZW1pdCgnY3Vyc29yJywgYy5jdXJzb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBOZWNlc3NhcnkgdG8gc2F0aXNmeSB0aGUgUmVhZGFibGUgQVBJXG4gKiBAbWV0aG9kIF9yZWFkXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRpb25DdXJzb3JcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgX25leHQodGhpcywgZnVuY3Rpb24oZXJyb3IsIGRvYykge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoIWRvYykge1xuICAgICAgX3RoaXMucHVzaChudWxsKTtcbiAgICAgIF90aGlzLmN1cnNvci5jbG9zZShmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfdGhpcy5wdXNoKGRvYyk7XG4gIH0pO1xufTtcblxuaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yICE9IG51bGwpIHtcbiAgY29uc3QgbXNnID0gJ01vbmdvb3NlIGRvZXMgbm90IHN1cHBvcnQgdXNpbmcgYXN5bmMgaXRlcmF0b3JzIHdpdGggYW4gJyArXG4gICAgJ2V4aXN0aW5nIGFnZ3JlZ2F0aW9uIGN1cnNvci4gU2VlIGh0dHBzOi8vYml0Lmx5L21vbmdvb3NlLWFzeW5jLWl0ZXJhdGUtYWdncmVnYXRpb24nO1xuXG4gIEFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihtc2cpO1xuICB9O1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3aGljaCBzdWJzZXF1ZW50bHkgbWFwcyBkb2N1bWVudHMgcmV0cmlldmVkXG4gKiB2aWEgdGhlIHN0cmVhbXMgaW50ZXJmYWNlIG9yIGAubmV4dCgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFwIGRvY3VtZW50cyByZXR1cm5lZCBieSBgZGF0YWAgZXZlbnRzXG4gKiAgICAgVGhpbmcuXG4gKiAgICAgICBmaW5kKHsgbmFtZTogL15oZWxsby8gfSkuXG4gKiAgICAgICBjdXJzb3IoKS5cbiAqICAgICAgIG1hcChmdW5jdGlvbiAoZG9jKSB7XG4gKiAgICAgICAgZG9jLmZvbyA9IFwiYmFyXCI7XG4gKiAgICAgICAgcmV0dXJuIGRvYztcbiAqICAgICAgIH0pXG4gKiAgICAgICBvbignZGF0YScsIGZ1bmN0aW9uKGRvYykgeyBjb25zb2xlLmxvZyhkb2MuZm9vKTsgfSk7XG4gKlxuICogICAgIC8vIE9yIG1hcCBkb2N1bWVudHMgcmV0dXJuZWQgYnkgYC5uZXh0KClgXG4gKiAgICAgY29uc3QgY3Vyc29yID0gVGhpbmcuZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLlxuICogICAgICAgY3Vyc29yKCkuXG4gKiAgICAgICBtYXAoZnVuY3Rpb24gKGRvYykge1xuICogICAgICAgICBkb2MuZm9vID0gXCJiYXJcIjtcbiAqICAgICAgICAgcmV0dXJuIGRvYztcbiAqICAgICAgIH0pO1xuICogICAgIGN1cnNvci5uZXh0KGZ1bmN0aW9uKGVycm9yLCBkb2MpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5mb28pO1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGlvbkN1cnNvcn1cbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGlvbkN1cnNvclxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgbWFwXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZSwgJ21hcCcsIHtcbiAgdmFsdWU6IGZ1bmN0aW9uKGZuKSB7XG4gICAgdGhpcy5fdHJhbnNmb3Jtcy5wdXNoKGZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogTWFya3MgdGhpcyBjdXJzb3IgYXMgZXJyb3JlZFxuICogQG1ldGhvZCBfbWFya0Vycm9yXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGlvbkN1cnNvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLl9tYXJrRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWFya3MgdGhpcyBjdXJzb3IgYXMgY2xvc2VkLiBXaWxsIHN0b3Agc3RyZWFtaW5nIGFuZCBzdWJzZXF1ZW50IGNhbGxzIHRvXG4gKiBgbmV4dCgpYCB3aWxsIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgY2xvc2VcbiAqIEBlbWl0cyBjbG9zZVxuICogQHNlZSBBZ2dyZWdhdGlvbkN1cnNvci5jbG9zZSBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQWdncmVnYXRpb25DdXJzb3IuaHRtbCNjbG9zZVxuICovXG5cbkFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5jbG9zZSA9IGFzeW5jIGZ1bmN0aW9uIGNsb3NlKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdBZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUuY2xvc2UoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLmN1cnNvci5jbG9zZSgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDAgJiYgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBkb2N1bWVudCBmcm9tIHRoaXMgY3Vyc29yLiBXaWxsIHJldHVybiBgbnVsbGAgd2hlbiB0aGVyZSBhcmVcbiAqIG5vIGRvY3VtZW50cyBsZWZ0LlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBuZXh0XG4gKi9cblxuQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLm5leHQgPSBhc3luYyBmdW5jdGlvbiBuZXh0KCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdBZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUubmV4dCgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIF9uZXh0KHRoaXMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYGZuYCBmb3IgZXZlcnkgZG9jdW1lbnQgaW4gdGhlIGN1cnNvci4gSWYgYGZuYCByZXR1cm5zIGEgcHJvbWlzZSxcbiAqIHdpbGwgd2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBiZWZvcmUgaXRlcmF0aW5nIG9uIHRvIHRoZSBuZXh0IG9uZS5cbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBkb25lLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGFyYWxsZWxdIHRoZSBudW1iZXIgb2YgcHJvbWlzZXMgdG8gZXhlY3V0ZSBpbiBwYXJhbGxlbC4gRGVmYXVsdHMgdG8gMS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gZXhlY3V0ZWQgd2hlbiBhbGwgZG9jcyBoYXZlIGJlZW4gcHJvY2Vzc2VkXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgZWFjaEFzeW5jXG4gKi9cblxuQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLmVhY2hBc3luYyA9IGZ1bmN0aW9uKGZuLCBvcHRzLCBjYWxsYmFjaykge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgcmV0dXJuIGVhY2hBc3luYyhmdW5jdGlvbihjYikgeyByZXR1cm4gX25leHQoX3RoaXMsIGNiKTsgfSwgZm4sIG9wdHMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhc3luY0l0ZXJhdG9yIGZvciB1c2Ugd2l0aCBbYGZvci9hd2FpdC9vZmAgbG9vcHNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vZ2V0dGluZy1zdGFydGVkLXdpdGgtYXN5bmMtaXRlcmF0b3JzLWluLW5vZGUtanMpXG4gKiBZb3UgZG8gbm90IG5lZWQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIGV4cGxpY2l0bHksIHRoZSBKYXZhU2NyaXB0IHJ1bnRpbWVcbiAqIHdpbGwgY2FsbCBpdCBmb3IgeW91LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQXN5bmMgaXRlcmF0b3Igd2l0aG91dCBleHBsaWNpdGx5IGNhbGxpbmcgYGN1cnNvcigpYC4gTW9uZ29vc2Ugc3RpbGxcbiAqICAgICAvLyBjcmVhdGVzIGFuIEFnZ3JlZ2F0aW9uQ3Vyc29yIGluc3RhbmNlIGludGVybmFsbHkuXG4gKiAgICAgY29uc3QgYWdnID0gTW9kZWwuYWdncmVnYXRlKFt7ICRtYXRjaDogeyBhZ2U6IHsgJGd0ZTogMjUgfSB9IH1dKTtcbiAqICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBhZ2cpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5uYW1lKTtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIFlvdSBjYW4gYWxzbyB1c2UgYW4gQWdncmVnYXRpb25DdXJzb3IgaW5zdGFuY2UgZm9yIGFzeW5jIGl0ZXJhdGlvblxuICogICAgIGNvbnN0IGN1cnNvciA9IE1vZGVsLmFnZ3JlZ2F0ZShbeyAkbWF0Y2g6IHsgYWdlOiB7ICRndGU6IDI1IH0gfSB9XSkuY3Vyc29yKCk7XG4gKiAgICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2YgY3Vyc29yKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MubmFtZSk7XG4gKiAgICAgfVxuICpcbiAqIE5vZGUuanMgMTAueCBzdXBwb3J0cyBhc3luYyBpdGVyYXRvcnMgbmF0aXZlbHkgd2l0aG91dCBhbnkgZmxhZ3MuIFlvdSBjYW5cbiAqIGVuYWJsZSBhc3luYyBpdGVyYXRvcnMgaW4gTm9kZS5qcyA4LnggdXNpbmcgdGhlIFtgLS1oYXJtb255X2FzeW5jX2l0ZXJhdGlvbmAgZmxhZ10oaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXN5bmMtaXRlcmF0aW9uL2lzc3Vlcy8xMTcjaXNzdWVjb21tZW50LTM0NjY5NTE4NykuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgbm90IHNldCBpZiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIHVuZGVmaW5lZC4gSWZcbiAqIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgaXMgdW5kZWZpbmVkLCB0aGF0IG1lYW5zIHlvdXIgTm9kZS5qcyB2ZXJzaW9uIGRvZXMgbm90XG4gKiBzdXBwb3J0IGFzeW5jIGl0ZXJhdG9ycy5cbiAqXG4gKiBAbWV0aG9kIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl1cbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGlvbkN1cnNvclxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciAhPSBudWxsKSB7XG4gIEFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1OdWxsKCkuX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IoKTtcbiAgfTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5BZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUuX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3RyYW5zZm9ybXMuaW5kZXhPZihfdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcikgPT09IC0xKSB7XG4gICAgdGhpcy5tYXAoX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5BZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUudHJhbnNmb3JtTnVsbCA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhbCA9IHRydWU7XG4gIH1cbiAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnRyYW5zZm9ybU51bGwgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcihkb2MpIHtcbiAgcmV0dXJuIGRvYyA9PSBudWxsID8geyBkb25lOiB0cnVlIH0gOiB7IHZhbHVlOiBkb2MsIGRvbmU6IGZhbHNlIH07XG59XG5cbi8qKlxuICogQWRkcyBhIFtjdXJzb3IgZmxhZ10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0FnZ3JlZ2F0aW9uQ3Vyc29yLmh0bWwjYWRkQ3Vyc29yRmxhZykuXG4gKiBVc2VmdWwgZm9yIHNldHRpbmcgdGhlIGBub0N1cnNvclRpbWVvdXRgIGFuZCBgdGFpbGFibGVgIGZsYWdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGlvbkN1cnNvcn0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgYWRkQ3Vyc29yRmxhZ1xuICovXG5cbkFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5hZGRDdXJzb3JGbGFnID0gZnVuY3Rpb24oZmxhZywgdmFsdWUpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBfd2FpdEZvckN1cnNvcih0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBfdGhpcy5jdXJzb3IuYWRkQ3Vyc29yRmxhZyhmbGFnLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3dhaXRGb3JDdXJzb3IoY3R4LCBjYikge1xuICBpZiAoY3R4LmN1cnNvcikge1xuICAgIHJldHVybiBjYigpO1xuICB9XG4gIGN0eC5vbmNlKCdjdXJzb3InLCBmdW5jdGlvbigpIHtcbiAgICBjYigpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgZG9jIGZyb20gdGhlIHVuZGVybHlpbmcgY3Vyc29yIGFuZCBtb25nb29zZWlmeSBpdFxuICogKHBvcHVsYXRlLCBldGMuKVxuICogQHBhcmFtIHtBbnl9IGN0eFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9uZXh0KGN0eCwgY2IpIHtcbiAgbGV0IGNhbGxiYWNrID0gY2I7XG4gIGlmIChjdHguX3RyYW5zZm9ybXMubGVuZ3RoKSB7XG4gICAgY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIGRvYykge1xuICAgICAgaWYgKGVyciB8fCAoZG9jID09PSBudWxsICYmICFjdHguX21vbmdvb3NlT3B0aW9ucy50cmFuc2Zvcm1OdWxsKSkge1xuICAgICAgICByZXR1cm4gY2IoZXJyLCBkb2MpO1xuICAgICAgfVxuICAgICAgY2IoZXJyLCBjdHguX3RyYW5zZm9ybXMucmVkdWNlKGZ1bmN0aW9uKGRvYywgZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKGRvYyk7XG4gICAgICB9LCBkb2MpKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGN0eC5fZXJyb3IpIHtcbiAgICByZXR1cm4gaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbGJhY2soY3R4Ll9lcnJvcik7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoY3R4LmN1cnNvcikge1xuICAgIHJldHVybiBjdHguY3Vyc29yLm5leHQoKS50aGVuKFxuICAgICAgZG9jID0+IHtcbiAgICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCBkb2MpO1xuICAgICAgfSxcbiAgICAgIGVyciA9PiBjYWxsYmFjayhlcnIpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjdHgub25jZSgnY3Vyc29yJywgZnVuY3Rpb24oKSB7XG4gICAgICBfbmV4dChjdHgsIGNiKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0aW9uQ3Vyc29yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/cursor/AggregationCursor.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/cursor/ChangeStream.js":
/*!******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cursor/ChangeStream.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\n/*!\n * ignore\n */\n\nconst driverChangeStreamEvents = ['close', 'change', 'end', 'error', 'resumeTokenChanged'];\n\n/*!\n * ignore\n */\n\nclass ChangeStream extends EventEmitter {\n  constructor(changeStreamThunk, pipeline, options) {\n    super();\n\n    this.driverChangeStream = null;\n    this.closed = false;\n    this.bindedEvents = false;\n    this.pipeline = pipeline;\n    this.options = options;\n\n    if (options && options.hydrate && !options.model) {\n      throw new Error(\n        'Cannot create change stream with `hydrate: true` ' +\n        'unless calling `Model.watch()`'\n      );\n    }\n\n    // This wrapper is necessary because of buffering.\n    changeStreamThunk((err, driverChangeStream) => {\n      if (err != null) {\n        this.emit('error', err);\n        return;\n      }\n\n      this.driverChangeStream = driverChangeStream;\n      this.emit('ready');\n    });\n  }\n\n  _bindEvents() {\n    if (this.bindedEvents) {\n      return;\n    }\n\n    this.bindedEvents = true;\n\n    if (this.driverChangeStream == null) {\n      this.once('ready', () => {\n        this.driverChangeStream.on('close', () => {\n          this.closed = true;\n        });\n\n        driverChangeStreamEvents.forEach(ev => {\n          this.driverChangeStream.on(ev, data => {\n            if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {\n              data.fullDocument = this.options.model.hydrate(data.fullDocument);\n            }\n            this.emit(ev, data);\n          });\n        });\n      });\n\n      return;\n    }\n\n    this.driverChangeStream.on('close', () => {\n      this.closed = true;\n    });\n\n    driverChangeStreamEvents.forEach(ev => {\n      this.driverChangeStream.on(ev, data => {\n        if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {\n          data.fullDocument = this.options.model.hydrate(data.fullDocument);\n        }\n        this.emit(ev, data);\n      });\n    });\n  }\n\n  hasNext(cb) {\n    return this.driverChangeStream.hasNext(cb);\n  }\n\n  next(cb) {\n    if (this.options && this.options.hydrate) {\n      if (cb != null) {\n        const originalCb = cb;\n        cb = (err, data) => {\n          if (err != null) {\n            return originalCb(err);\n          }\n          if (data.fullDocument != null) {\n            data.fullDocument = this.options.model.hydrate(data.fullDocument);\n          }\n          return originalCb(null, data);\n        };\n      }\n\n      let maybePromise = this.driverChangeStream.next(cb);\n      if (maybePromise && typeof maybePromise.then === 'function') {\n        maybePromise = maybePromise.then(data => {\n          if (data.fullDocument != null) {\n            data.fullDocument = this.options.model.hydrate(data.fullDocument);\n          }\n          return data;\n        });\n      }\n      return maybePromise;\n    }\n\n    return this.driverChangeStream.next(cb);\n  }\n\n  addListener(event, handler) {\n    this._bindEvents();\n    return super.addListener(event, handler);\n  }\n\n  on(event, handler) {\n    this._bindEvents();\n    return super.on(event, handler);\n  }\n\n  once(event, handler) {\n    this._bindEvents();\n    return super.once(event, handler);\n  }\n\n  _queue(cb) {\n    this.once('ready', () => cb());\n  }\n\n  close() {\n    this.closed = true;\n    if (this.driverChangeStream) {\n      this.driverChangeStream.close();\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports = ChangeStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY3Vyc29yL0NoYW5nZVN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDBEQUE4Qjs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGN1cnNvclxcQ2hhbmdlU3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBkcml2ZXJDaGFuZ2VTdHJlYW1FdmVudHMgPSBbJ2Nsb3NlJywgJ2NoYW5nZScsICdlbmQnLCAnZXJyb3InLCAncmVzdW1lVG9rZW5DaGFuZ2VkJ107XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY2xhc3MgQ2hhbmdlU3RyZWFtIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoY2hhbmdlU3RyZWFtVGh1bmssIHBpcGVsaW5lLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuYmluZGVkRXZlbnRzID0gZmFsc2U7XG4gICAgdGhpcy5waXBlbGluZSA9IHBpcGVsaW5lO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmh5ZHJhdGUgJiYgIW9wdGlvbnMubW9kZWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBjcmVhdGUgY2hhbmdlIHN0cmVhbSB3aXRoIGBoeWRyYXRlOiB0cnVlYCAnICtcbiAgICAgICAgJ3VubGVzcyBjYWxsaW5nIGBNb2RlbC53YXRjaCgpYCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyB3cmFwcGVyIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIG9mIGJ1ZmZlcmluZy5cbiAgICBjaGFuZ2VTdHJlYW1UaHVuaygoZXJyLCBkcml2ZXJDaGFuZ2VTdHJlYW0pID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRyaXZlckNoYW5nZVN0cmVhbSA9IGRyaXZlckNoYW5nZVN0cmVhbTtcbiAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIGlmICh0aGlzLmJpbmRlZEV2ZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYmluZGVkRXZlbnRzID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLmRyaXZlckNoYW5nZVN0cmVhbSA9PSBudWxsKSB7XG4gICAgICB0aGlzLm9uY2UoJ3JlYWR5JywgKCkgPT4ge1xuICAgICAgICB0aGlzLmRyaXZlckNoYW5nZVN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBkcml2ZXJDaGFuZ2VTdHJlYW1FdmVudHMuZm9yRWFjaChldiA9PiB7XG4gICAgICAgICAgdGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0ub24oZXYsIGRhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCAmJiBkYXRhLmZ1bGxEb2N1bWVudCAhPSBudWxsICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICAgICAgICBkYXRhLmZ1bGxEb2N1bWVudCA9IHRoaXMub3B0aW9ucy5tb2RlbC5oeWRyYXRlKGRhdGEuZnVsbERvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChldiwgZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRyaXZlckNoYW5nZVN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBkcml2ZXJDaGFuZ2VTdHJlYW1FdmVudHMuZm9yRWFjaChldiA9PiB7XG4gICAgICB0aGlzLmRyaXZlckNoYW5nZVN0cmVhbS5vbihldiwgZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhICE9IG51bGwgJiYgZGF0YS5mdWxsRG9jdW1lbnQgIT0gbnVsbCAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmh5ZHJhdGUpIHtcbiAgICAgICAgICBkYXRhLmZ1bGxEb2N1bWVudCA9IHRoaXMub3B0aW9ucy5tb2RlbC5oeWRyYXRlKGRhdGEuZnVsbERvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoZXYsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBoYXNOZXh0KGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtLmhhc05leHQoY2IpO1xuICB9XG5cbiAgbmV4dChjYikge1xuICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmh5ZHJhdGUpIHtcbiAgICAgIGlmIChjYiAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQ2IgPSBjYjtcbiAgICAgICAgY2IgPSAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxDYihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YS5mdWxsRG9jdW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YS5mdWxsRG9jdW1lbnQgPSB0aGlzLm9wdGlvbnMubW9kZWwuaHlkcmF0ZShkYXRhLmZ1bGxEb2N1bWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbENiKG51bGwsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBsZXQgbWF5YmVQcm9taXNlID0gdGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0ubmV4dChjYik7XG4gICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UudGhlbihkYXRhID0+IHtcbiAgICAgICAgICBpZiAoZGF0YS5mdWxsRG9jdW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YS5mdWxsRG9jdW1lbnQgPSB0aGlzLm9wdGlvbnMubW9kZWwuaHlkcmF0ZShkYXRhLmZ1bGxEb2N1bWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXliZVByb21pc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtLm5leHQoY2IpO1xuICB9XG5cbiAgYWRkTGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgcmV0dXJuIHN1cGVyLmFkZExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuXG4gIG9uKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIHJldHVybiBzdXBlci5vbihldmVudCwgaGFuZGxlcik7XG4gIH1cblxuICBvbmNlKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIHJldHVybiBzdXBlci5vbmNlKGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuXG4gIF9xdWV1ZShjYikge1xuICAgIHRoaXMub25jZSgncmVhZHknLCAoKSA9PiBjYigpKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0pIHtcbiAgICAgIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtLmNsb3NlKCk7XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDaGFuZ2VTdHJlYW07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/cursor/ChangeStream.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/cursor/QueryCursor.js":
/*!*****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/cursor/QueryCursor.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst Readable = (__webpack_require__(/*! stream */ \"stream\").Readable);\nconst eachAsync = __webpack_require__(/*! ../helpers/cursor/eachAsync */ \"(api)/../server/node_modules/mongoose/lib/helpers/cursor/eachAsync.js\");\nconst helpers = __webpack_require__(/*! ../queryhelpers */ \"(api)/../server/node_modules/mongoose/lib/queryhelpers.js\");\nconst kareem = __webpack_require__(/*! kareem */ \"(api)/../server/node_modules/kareem/index.js\");\nconst immediate = __webpack_require__(/*! ../helpers/immediate */ \"(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * A QueryCursor is a concurrency primitive for processing query results\n * one document at a time. A QueryCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * QueryCursors execute the model's pre `find` hooks before loading any documents\n * from MongoDB, and the model's post `find` hooks after loading each document.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Query#cursor()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.cursor()) instead.\n *\n * @param {Query} query\n * @param {Object} options query options passed to `.find()`\n * @inherits Readable https://nodejs.org/api/stream.html#class-streamreadable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction QueryCursor(query) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, { autoDestroy: true, objectMode: true });\n\n  this.cursor = null;\n  this.skipped = false;\n  this.query = query;\n  const model = query.model;\n  this._mongooseOptions = {};\n  this._transforms = [];\n  this.model = model;\n  this.options = {};\n  model.hooks.execPre('find', query, (err) => {\n    if (err != null) {\n      if (err instanceof kareem.skipWrappedFunction) {\n        const resultValue = err.args[0];\n        if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {\n          const err = new MongooseError(\n            'Cannot `skipMiddlewareFunction()` with a value when using ' +\n            '`.find().cursor()`, value must be nullish or empty array, got \"' +\n            util.inspect(resultValue) +\n            '\".'\n          );\n          this._markError(err);\n          this.listeners('error').length > 0 && this.emit('error', err);\n          return;\n        }\n        this.skipped = true;\n        this.emit('cursor', null);\n        return;\n      }\n      this._markError(err);\n      this.listeners('error').length > 0 && this.emit('error', err);\n      return;\n    }\n    Object.assign(this.options, query._optionsForExec());\n    this._transforms = this._transforms.concat(query._transforms.slice());\n    if (this.options.transform) {\n      this._transforms.push(this.options.transform);\n    }\n    // Re: gh-8039, you need to set the `cursor.batchSize` option, top-level\n    // `batchSize` option doesn't work.\n    if (this.options.batchSize) {\n      // Max out the number of documents we'll populate in parallel at 5000.\n      this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);\n    }\n\n    if (model.collection._shouldBufferCommands() && model.collection.buffer) {\n      model.collection.queue.push([\n        () => _getRawCursor(query, this)\n      ]);\n    } else {\n      _getRawCursor(query, this);\n    }\n  });\n}\n\nutil.inherits(QueryCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _getRawCursor(query, queryCursor) {\n  try {\n    const cursor = query.model.collection.find(query._conditions, queryCursor.options);\n    queryCursor.cursor = cursor;\n    queryCursor.emit('cursor', cursor);\n  } catch (err) {\n    queryCursor._markError(err);\n    queryCursor.listeners('error').length > 0 && queryCursor.emit('error', queryCursor._error);\n  }\n}\n\n/**\n * Necessary to satisfy the Readable API\n * @method _read\n * @memberOf QueryCursor\n * @instance\n * @api private\n */\n\nQueryCursor.prototype._read = function() {\n  _next(this, (error, doc) => {\n    if (error) {\n      return this.emit('error', error);\n    }\n    if (!doc) {\n      this.push(null);\n      this.cursor.close(function(error) {\n        if (error) {\n          return this.emit('error', error);\n        }\n      });\n      return;\n    }\n    this.push(doc);\n  });\n};\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example:\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {QueryCursor}\n * @memberOf QueryCursor\n * @api public\n * @method map\n */\n\nObject.defineProperty(QueryCursor.prototype, 'map', {\n  value: function(fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\n * Marks this cursor as errored\n * @method _markError\n * @memberOf QueryCursor\n * @instance\n * @api private\n */\n\nQueryCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\n */\n\nQueryCursor.prototype.close = async function close() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.close() no longer accepts a callback');\n  }\n  try {\n    await this.cursor.close();\n    this.emit('close');\n  } catch (error) {\n    this.listeners('error').length > 0 && this.emit('error', error);\n    throw error;\n  }\n};\n\n/**\n * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n * if the resultant data has already been retrieved by this cursor.\n *\n * @return {AggregationCursor} this\n * @api public\n * @method rewind\n */\n\nQueryCursor.prototype.rewind = function() {\n  _waitForCursor(this, () => {\n    this.cursor.rewind();\n  });\n  return this;\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @return {Promise}\n * @api public\n * @method next\n */\n\nQueryCursor.prototype.next = async function next() {\n  if (arguments[0] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.next() no longer accepts a callback');\n  }\n  return new Promise((resolve, reject) => {\n    _next(this, function(error, doc) {\n      if (error) {\n        return reject(error);\n      }\n      resolve(doc);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * #### Example:\n *\n *     // Iterate over documents asynchronously\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       eachAsync(async function (doc, i) {\n *         doc.foo = doc.bar + i;\n *         await doc.save();\n *       })\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Number} [options.batchSize] if set, will call `fn()` with arrays of documents with length at most `batchSize`\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nQueryCursor.prototype.eachAsync = function(fn, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync((cb) => _next(this, cb), fn, opts, callback);\n};\n\n/**\n * The `options` passed in to the `QueryCursor` constructor.\n *\n * @api public\n * @property options\n */\n\nQueryCursor.prototype.options;\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nQueryCursor.prototype.addCursorFlag = function(flag, value) {\n  _waitForCursor(this, () => {\n    this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQueryCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQueryCursor.prototype._transformForAsyncIterator = function() {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js).\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     // Works without using `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n *     // Can also use `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf QueryCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  QueryCursor.prototype[Symbol.asyncIterator] = function() {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * ignore\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? { done: true } : { value: doc, done: false };\n}\n\n/**\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n * @param {Any} ctx\n * @param {Function} cb\n * @api private\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn.call(ctx, doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function() {\n      callback(ctx._error);\n    });\n  }\n  if (ctx.skipped) {\n    return immediate(() => callback(null, null));\n  }\n\n  if (ctx.cursor) {\n    if (ctx.query._mongooseOptions.populate && !ctx._pop) {\n      ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query,\n        ctx.query._mongooseOptions);\n      ctx._pop.__noPromise = true;\n    }\n    if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {\n      if (ctx._batchDocs && ctx._batchDocs.length) {\n        // Return a cached populated doc\n        return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);\n      } else if (ctx._batchExhausted) {\n        // Internal cursor reported no more docs. Act the same here\n        return callback(null, null);\n      } else {\n        // Request as many docs as batchSize, to populate them also in batch\n        ctx._batchDocs = [];\n        ctx.cursor.next().then(\n          res => { _onNext.call({ ctx, callback }, null, res); },\n          err => { _onNext.call({ ctx, callback }, err); }\n        );\n        return;\n      }\n    } else {\n      return ctx.cursor.next().then(\n        doc => {\n          if (!doc) {\n            callback(null, null);\n            return;\n          }\n\n          if (!ctx.query._mongooseOptions.populate) {\n            return _nextDoc(ctx, doc, null, callback);\n          }\n\n          ctx.query.model.populate(doc, ctx._pop).then(\n            doc => {\n              _nextDoc(ctx, doc, ctx._pop, callback);\n            },\n            err => {\n              callback(err);\n            }\n          );\n        },\n        error => {\n          callback(error);\n        }\n      );\n    }\n  } else {\n    ctx.once('error', cb);\n\n    ctx.once('cursor', function(cursor) {\n      ctx.removeListener('error', cb);\n      if (cursor == null) {\n        if (ctx.skipped) {\n          return cb(null, null);\n        }\n        return;\n      }\n      _next(ctx, cb);\n    });\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _onNext(error, doc) {\n  if (error) {\n    return this.callback(error);\n  }\n  if (!doc) {\n    this.ctx._batchExhausted = true;\n    return _populateBatch.call(this);\n  }\n\n  this.ctx._batchDocs.push(doc);\n\n  if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {\n    // If both `batchSize` and `_populateBatchSize` are huge, calling `next()` repeatedly may\n    // cause a stack overflow. So make sure we clear the stack regularly.\n    if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1000 === 0) {\n      return immediate(() => this.ctx.cursor.next().then(\n        res => { _onNext.call(this, null, res); },\n        err => { _onNext.call(this, err); }\n      ));\n    }\n    this.ctx.cursor.next().then(\n      res => { _onNext.call(this, null, res); },\n      err => { _onNext.call(this, err); }\n    );\n  } else {\n    _populateBatch.call(this);\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _populateBatch() {\n  if (!this.ctx._batchDocs.length) {\n    return this.callback(null, null);\n  }\n  this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop).then(\n    () => {\n      _nextDoc(this.ctx, this.ctx._batchDocs.shift(), this.ctx._pop, this.callback);\n    },\n    err => {\n      this.callback(err);\n    }\n  );\n}\n\n/*!\n * ignore\n */\n\nfunction _nextDoc(ctx, doc, pop, callback) {\n  if (ctx.query._mongooseOptions.lean) {\n    return ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n      callback(null, doc);\n    });\n  }\n\n  const { model, _fields, _userProvidedFields, options } = ctx.query;\n  helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n    ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n      callback(null, doc);\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function(cursor) {\n    if (cursor == null) {\n      return;\n    }\n    cb();\n  });\n}\n\nmodule.exports = QueryCursor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY3Vyc29yL1F1ZXJ5Q3Vyc29yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBd0I7QUFDdEQsaUJBQWlCLHNEQUEwQjtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQywwR0FBNkI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQWlCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyw0REFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBc0I7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG9DQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVMsV0FBVztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTLFdBQVc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGFBQWEsSUFBSTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWUsZUFBZSxlQUFlO0FBQ2hFLG1CQUFtQixlQUFlLGVBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DLGVBQWU7QUFDZjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLFVBQVUsK0NBQStDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGN1cnNvclxcUXVlcnlDdXJzb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgnc3RyZWFtJykuUmVhZGFibGU7XG5jb25zdCBlYWNoQXN5bmMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2N1cnNvci9lYWNoQXN5bmMnKTtcbmNvbnN0IGhlbHBlcnMgPSByZXF1aXJlKCcuLi9xdWVyeWhlbHBlcnMnKTtcbmNvbnN0IGthcmVlbSA9IHJlcXVpcmUoJ2thcmVlbScpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogQSBRdWVyeUN1cnNvciBpcyBhIGNvbmN1cnJlbmN5IHByaW1pdGl2ZSBmb3IgcHJvY2Vzc2luZyBxdWVyeSByZXN1bHRzXG4gKiBvbmUgZG9jdW1lbnQgYXQgYSB0aW1lLiBBIFF1ZXJ5Q3Vyc29yIGZ1bGZpbGxzIHRoZSBOb2RlLmpzIHN0cmVhbXMzIEFQSSxcbiAqIGluIGFkZGl0aW9uIHRvIHNldmVyYWwgb3RoZXIgbWVjaGFuaXNtcyBmb3IgbG9hZGluZyBkb2N1bWVudHMgZnJvbSBNb25nb0RCXG4gKiBvbmUgYXQgYSB0aW1lLlxuICpcbiAqIFF1ZXJ5Q3Vyc29ycyBleGVjdXRlIHRoZSBtb2RlbCdzIHByZSBgZmluZGAgaG9va3MgYmVmb3JlIGxvYWRpbmcgYW55IGRvY3VtZW50c1xuICogZnJvbSBNb25nb0RCLCBhbmQgdGhlIG1vZGVsJ3MgcG9zdCBgZmluZGAgaG9va3MgYWZ0ZXIgbG9hZGluZyBlYWNoIGRvY3VtZW50LlxuICpcbiAqIFVubGVzcyB5b3UncmUgYW4gYWR2YW5jZWQgdXNlciwgZG8gKipub3QqKiBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzIGRpcmVjdGx5LlxuICogVXNlIFtgUXVlcnkjY3Vyc29yKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmN1cnNvcigpKSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBxdWVyeSBvcHRpb25zIHBhc3NlZCB0byBgLmZpbmQoKWBcbiAqIEBpbmhlcml0cyBSZWFkYWJsZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI2NsYXNzLXN0cmVhbXJlYWRhYmxlXG4gKiBAZXZlbnQgYGN1cnNvcmA6IEVtaXR0ZWQgd2hlbiB0aGUgY3Vyc29yIGlzIGNyZWF0ZWRcbiAqIEBldmVudCBgZXJyb3JgOiBFbWl0dGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJyZWRcbiAqIEBldmVudCBgZGF0YWA6IEVtaXR0ZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGZsb3dpbmcgYW5kIHRoZSBuZXh0IGRvYyBpcyByZWFkeVxuICogQGV2ZW50IGBlbmRgOiBFbWl0dGVkIHdoZW4gdGhlIHN0cmVhbSBpcyBleGhhdXN0ZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUXVlcnlDdXJzb3IocXVlcnkpIHtcbiAgLy8gc2V0IGF1dG9EZXN0cm95PXRydWUgYmVjYXVzZSBvbiBub2RlIDEyIGl0J3MgYnkgZGVmYXVsdCBmYWxzZVxuICAvLyBnaC0xMDkwMiBuZWVkIGF1dG9EZXN0cm95IHRvIGRlc3Ryb3kgY29ycmVjdGx5IGFuZCBlbWl0ICdjbG9zZScgZXZlbnRcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCB7IGF1dG9EZXN0cm95OiB0cnVlLCBvYmplY3RNb2RlOiB0cnVlIH0pO1xuXG4gIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgdGhpcy5za2lwcGVkID0gZmFsc2U7XG4gIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgY29uc3QgbW9kZWwgPSBxdWVyeS5tb2RlbDtcbiAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0ge307XG4gIHRoaXMuX3RyYW5zZm9ybXMgPSBbXTtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgbW9kZWwuaG9va3MuZXhlY1ByZSgnZmluZCcsIHF1ZXJ5LCAoZXJyKSA9PiB7XG4gICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2Yga2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0VmFsdWUgPSBlcnIuYXJnc1swXTtcbiAgICAgICAgaWYgKHJlc3VsdFZhbHVlICE9IG51bGwgJiYgKCFBcnJheS5pc0FycmF5KHJlc3VsdFZhbHVlKSB8fCByZXN1bHRWYWx1ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IE1vbmdvb3NlRXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IGBza2lwTWlkZGxld2FyZUZ1bmN0aW9uKClgIHdpdGggYSB2YWx1ZSB3aGVuIHVzaW5nICcgK1xuICAgICAgICAgICAgJ2AuZmluZCgpLmN1cnNvcigpYCwgdmFsdWUgbXVzdCBiZSBudWxsaXNoIG9yIGVtcHR5IGFycmF5LCBnb3QgXCInICtcbiAgICAgICAgICAgIHV0aWwuaW5zcGVjdChyZXN1bHRWYWx1ZSkgK1xuICAgICAgICAgICAgJ1wiLidcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuX21hcmtFcnJvcihlcnIpO1xuICAgICAgICAgIHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDAgJiYgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2tpcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnY3Vyc29yJywgbnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcmtFcnJvcihlcnIpO1xuICAgICAgdGhpcy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoID4gMCAmJiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIHF1ZXJ5Ll9vcHRpb25zRm9yRXhlYygpKTtcbiAgICB0aGlzLl90cmFuc2Zvcm1zID0gdGhpcy5fdHJhbnNmb3Jtcy5jb25jYXQocXVlcnkuX3RyYW5zZm9ybXMuc2xpY2UoKSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybXMucHVzaCh0aGlzLm9wdGlvbnMudHJhbnNmb3JtKTtcbiAgICB9XG4gICAgLy8gUmU6IGdoLTgwMzksIHlvdSBuZWVkIHRvIHNldCB0aGUgYGN1cnNvci5iYXRjaFNpemVgIG9wdGlvbiwgdG9wLWxldmVsXG4gICAgLy8gYGJhdGNoU2l6ZWAgb3B0aW9uIGRvZXNuJ3Qgd29yay5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJhdGNoU2l6ZSkge1xuICAgICAgLy8gTWF4IG91dCB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyB3ZSdsbCBwb3B1bGF0ZSBpbiBwYXJhbGxlbCBhdCA1MDAwLlxuICAgICAgdGhpcy5vcHRpb25zLl9wb3B1bGF0ZUJhdGNoU2l6ZSA9IE1hdGgubWluKHRoaXMub3B0aW9ucy5iYXRjaFNpemUsIDUwMDApO1xuICAgIH1cblxuICAgIGlmIChtb2RlbC5jb2xsZWN0aW9uLl9zaG91bGRCdWZmZXJDb21tYW5kcygpICYmIG1vZGVsLmNvbGxlY3Rpb24uYnVmZmVyKSB7XG4gICAgICBtb2RlbC5jb2xsZWN0aW9uLnF1ZXVlLnB1c2goW1xuICAgICAgICAoKSA9PiBfZ2V0UmF3Q3Vyc29yKHF1ZXJ5LCB0aGlzKVxuICAgICAgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9nZXRSYXdDdXJzb3IocXVlcnksIHRoaXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbnV0aWwuaW5oZXJpdHMoUXVlcnlDdXJzb3IsIFJlYWRhYmxlKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZ2V0UmF3Q3Vyc29yKHF1ZXJ5LCBxdWVyeUN1cnNvcikge1xuICB0cnkge1xuICAgIGNvbnN0IGN1cnNvciA9IHF1ZXJ5Lm1vZGVsLmNvbGxlY3Rpb24uZmluZChxdWVyeS5fY29uZGl0aW9ucywgcXVlcnlDdXJzb3Iub3B0aW9ucyk7XG4gICAgcXVlcnlDdXJzb3IuY3Vyc29yID0gY3Vyc29yO1xuICAgIHF1ZXJ5Q3Vyc29yLmVtaXQoJ2N1cnNvcicsIGN1cnNvcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHF1ZXJ5Q3Vyc29yLl9tYXJrRXJyb3IoZXJyKTtcbiAgICBxdWVyeUN1cnNvci5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoID4gMCAmJiBxdWVyeUN1cnNvci5lbWl0KCdlcnJvcicsIHF1ZXJ5Q3Vyc29yLl9lcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBOZWNlc3NhcnkgdG8gc2F0aXNmeSB0aGUgUmVhZGFibGUgQVBJXG4gKiBAbWV0aG9kIF9yZWFkXG4gKiBAbWVtYmVyT2YgUXVlcnlDdXJzb3JcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oKSB7XG4gIF9uZXh0KHRoaXMsIChlcnJvciwgZG9jKSA9PiB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9XG4gICAgaWYgKCFkb2MpIHtcbiAgICAgIHRoaXMucHVzaChudWxsKTtcbiAgICAgIHRoaXMuY3Vyc29yLmNsb3NlKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wdXNoKGRvYyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2hpY2ggc3Vic2VxdWVudGx5IG1hcHMgZG9jdW1lbnRzIHJldHJpZXZlZFxuICogdmlhIHRoZSBzdHJlYW1zIGludGVyZmFjZSBvciBgLm5leHQoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1hcCBkb2N1bWVudHMgcmV0dXJuZWQgYnkgYGRhdGFgIGV2ZW50c1xuICogICAgIFRoaW5nLlxuICogICAgICAgZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLlxuICogICAgICAgY3Vyc29yKCkuXG4gKiAgICAgICBtYXAoZnVuY3Rpb24gKGRvYykge1xuICogICAgICAgIGRvYy5mb28gPSBcImJhclwiO1xuICogICAgICAgIHJldHVybiBkb2M7XG4gKiAgICAgICB9KVxuICogICAgICAgb24oJ2RhdGEnLCBmdW5jdGlvbihkb2MpIHsgY29uc29sZS5sb2coZG9jLmZvbyk7IH0pO1xuICpcbiAqICAgICAvLyBPciBtYXAgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGAubmV4dCgpYFxuICogICAgIGNvbnN0IGN1cnNvciA9IFRoaW5nLmZpbmQoeyBuYW1lOiAvXmhlbGxvLyB9KS5cbiAqICAgICAgIGN1cnNvcigpLlxuICogICAgICAgbWFwKGZ1bmN0aW9uIChkb2MpIHtcbiAqICAgICAgICAgZG9jLmZvbyA9IFwiYmFyXCI7XG4gKiAgICAgICAgIHJldHVybiBkb2M7XG4gKiAgICAgICB9KTtcbiAqICAgICBjdXJzb3IubmV4dChmdW5jdGlvbihlcnJvciwgZG9jKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MuZm9vKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UXVlcnlDdXJzb3J9XG4gKiBAbWVtYmVyT2YgUXVlcnlDdXJzb3JcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIG1hcFxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUN1cnNvci5wcm90b3R5cGUsICdtYXAnLCB7XG4gIHZhbHVlOiBmdW5jdGlvbihmbikge1xuICAgIHRoaXMuX3RyYW5zZm9ybXMucHVzaChmbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIE1hcmtzIHRoaXMgY3Vyc29yIGFzIGVycm9yZWRcbiAqIEBtZXRob2QgX21hcmtFcnJvclxuICogQG1lbWJlck9mIFF1ZXJ5Q3Vyc29yXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5fbWFya0Vycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1hcmtzIHRoaXMgY3Vyc29yIGFzIGNsb3NlZC4gV2lsbCBzdG9wIHN0cmVhbWluZyBhbmQgc3Vic2VxdWVudCBjYWxscyB0b1xuICogYG5leHQoKWAgd2lsbCBlcnJvci5cbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgY2xvc2VcbiAqIEBlbWl0cyBjbG9zZVxuICogQHNlZSBBZ2dyZWdhdGlvbkN1cnNvci5jbG9zZSBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQWdncmVnYXRpb25DdXJzb3IuaHRtbCNjbG9zZVxuICovXG5cblF1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5jbG9zZSA9IGFzeW5jIGZ1bmN0aW9uIGNsb3NlKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeUN1cnNvci5wcm90b3R5cGUuY2xvc2UoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLmN1cnNvci5jbG9zZSgpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogUmV3aW5kIHRoaXMgY3Vyc29yIHRvIGl0cyB1bmluaXRpYWxpemVkIHN0YXRlLiBBbnkgb3B0aW9ucyB0aGF0IGFyZSBwcmVzZW50IG9uIHRoZSBjdXJzb3Igd2lsbFxuICogcmVtYWluIGluIGVmZmVjdC4gSXRlcmF0aW5nIHRoaXMgY3Vyc29yIHdpbGwgY2F1c2UgbmV3IHF1ZXJpZXMgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLCBldmVuXG4gKiBpZiB0aGUgcmVzdWx0YW50IGRhdGEgaGFzIGFscmVhZHkgYmVlbiByZXRyaWV2ZWQgYnkgdGhpcyBjdXJzb3IuXG4gKlxuICogQHJldHVybiB7QWdncmVnYXRpb25DdXJzb3J9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHJld2luZFxuICovXG5cblF1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5yZXdpbmQgPSBmdW5jdGlvbigpIHtcbiAgX3dhaXRGb3JDdXJzb3IodGhpcywgKCkgPT4ge1xuICAgIHRoaXMuY3Vyc29yLnJld2luZCgpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBkb2N1bWVudCBmcm9tIHRoaXMgY3Vyc29yLiBXaWxsIHJldHVybiBgbnVsbGAgd2hlbiB0aGVyZSBhcmVcbiAqIG5vIGRvY3VtZW50cyBsZWZ0LlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBuZXh0XG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLm5leHQgPSBhc3luYyBmdW5jdGlvbiBuZXh0KCkge1xuICBpZiAoYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5uZXh0KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgX25leHQodGhpcywgZnVuY3Rpb24oZXJyb3IsIGRvYykge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShkb2MpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBgZm5gIGZvciBldmVyeSBkb2N1bWVudCBpbiB0aGUgY3Vyc29yLiBJZiBgZm5gIHJldHVybnMgYSBwcm9taXNlLFxuICogd2lsbCB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBpdGVyYXRpbmcgb24gdG8gdGhlIG5leHQgb25lLlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGRvbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBJdGVyYXRlIG92ZXIgZG9jdW1lbnRzIGFzeW5jaHJvbm91c2x5XG4gKiAgICAgVGhpbmcuXG4gKiAgICAgICBmaW5kKHsgbmFtZTogL15oZWxsby8gfSkuXG4gKiAgICAgICBjdXJzb3IoKS5cbiAqICAgICAgIGVhY2hBc3luYyhhc3luYyBmdW5jdGlvbiAoZG9jLCBpKSB7XG4gKiAgICAgICAgIGRvYy5mb28gPSBkb2MuYmFyICsgaTtcbiAqICAgICAgICAgYXdhaXQgZG9jLnNhdmUoKTtcbiAqICAgICAgIH0pXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYXJhbGxlbF0gdGhlIG51bWJlciBvZiBwcm9taXNlcyB0byBleGVjdXRlIGluIHBhcmFsbGVsLiBEZWZhdWx0cyB0byAxLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhdGNoU2l6ZV0gaWYgc2V0LCB3aWxsIGNhbGwgYGZuKClgIHdpdGggYXJyYXlzIG9mIGRvY3VtZW50cyB3aXRoIGxlbmd0aCBhdCBtb3N0IGBiYXRjaFNpemVgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbnRpbnVlT25FcnJvcj1mYWxzZV0gaWYgdHJ1ZSwgYGVhY2hBc3luYygpYCBpdGVyYXRlcyB0aHJvdWdoIGFsbCBkb2NzIGV2ZW4gaWYgYGZuYCB0aHJvd3MgYW4gZXJyb3IuIElmIGZhbHNlLCBgZWFjaEFzeW5jKClgIHRocm93cyBhbiBlcnJvciBpbW1lZGlhdGVseSBpZiB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuKClgIHRocm93cyBhbiBlcnJvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gZXhlY3V0ZWQgd2hlbiBhbGwgZG9jcyBoYXZlIGJlZW4gcHJvY2Vzc2VkXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgZWFjaEFzeW5jXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLmVhY2hBc3luYyA9IGZ1bmN0aW9uKGZuLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHJldHVybiBlYWNoQXN5bmMoKGNiKSA9PiBfbmV4dCh0aGlzLCBjYiksIGZuLCBvcHRzLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFRoZSBgb3B0aW9uc2AgcGFzc2VkIGluIHRvIHRoZSBgUXVlcnlDdXJzb3JgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgb3B0aW9uc1xuICovXG5cblF1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5vcHRpb25zO1xuXG4vKipcbiAqIEFkZHMgYSBbY3Vyc29yIGZsYWddKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9GaW5kQ3Vyc29yLmh0bWwjYWRkQ3Vyc29yRmxhZykuXG4gKiBVc2VmdWwgZm9yIHNldHRpbmcgdGhlIGBub0N1cnNvclRpbWVvdXRgIGFuZCBgdGFpbGFibGVgIGZsYWdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGlvbkN1cnNvcn0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgYWRkQ3Vyc29yRmxhZ1xuICovXG5cblF1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5hZGRDdXJzb3JGbGFnID0gZnVuY3Rpb24oZmxhZywgdmFsdWUpIHtcbiAgX3dhaXRGb3JDdXJzb3IodGhpcywgKCkgPT4ge1xuICAgIHRoaXMuY3Vyc29yLmFkZEN1cnNvckZsYWcoZmxhZywgdmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblF1ZXJ5Q3Vyc29yLnByb3RvdHlwZS50cmFuc2Zvcm1OdWxsID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFsID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9tb25nb29zZU9wdGlvbnMudHJhbnNmb3JtTnVsbCA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblF1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5fdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fdHJhbnNmb3Jtcy5pbmRleE9mKF90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yKSA9PT0gLTEpIHtcbiAgICB0aGlzLm1hcChfdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXN5bmNJdGVyYXRvciBmb3IgdXNlIHdpdGggW2Bmb3IvYXdhaXQvb2ZgIGxvb3BzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2dldHRpbmctc3RhcnRlZC13aXRoLWFzeW5jLWl0ZXJhdG9ycy1pbi1ub2RlLWpzKS5cbiAqIFlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gZXhwbGljaXRseSwgdGhlIEphdmFTY3JpcHQgcnVudGltZVxuICogd2lsbCBjYWxsIGl0IGZvciB5b3UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBXb3JrcyB3aXRob3V0IHVzaW5nIGBjdXJzb3IoKWBcbiAqICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBNb2RlbC5maW5kKFt7ICRzb3J0OiB7IG5hbWU6IDEgfSB9XSkpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5uYW1lKTtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIENhbiBhbHNvIHVzZSBgY3Vyc29yKClgXG4gKiAgICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2YgTW9kZWwuZmluZChbeyAkc29ydDogeyBuYW1lOiAxIH0gfV0pLmN1cnNvcigpKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MubmFtZSk7XG4gKiAgICAgfVxuICpcbiAqIE5vZGUuanMgMTAueCBzdXBwb3J0cyBhc3luYyBpdGVyYXRvcnMgbmF0aXZlbHkgd2l0aG91dCBhbnkgZmxhZ3MuIFlvdSBjYW5cbiAqIGVuYWJsZSBhc3luYyBpdGVyYXRvcnMgaW4gTm9kZS5qcyA4LnggdXNpbmcgdGhlIFtgLS1oYXJtb255X2FzeW5jX2l0ZXJhdGlvbmAgZmxhZ10oaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXN5bmMtaXRlcmF0aW9uL2lzc3Vlcy8xMTcjaXNzdWVjb21tZW50LTM0NjY5NTE4NykuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgbm90IGlmIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgaXMgdW5kZWZpbmVkLiBJZlxuICogYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCBpcyB1bmRlZmluZWQsIHRoYXQgbWVhbnMgeW91ciBOb2RlLmpzIHZlcnNpb24gZG9lcyBub3RcbiAqIHN1cHBvcnQgYXN5bmMgaXRlcmF0b3JzLlxuICpcbiAqIEBtZXRob2QgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXVxuICogQG1lbWJlck9mIFF1ZXJ5Q3Vyc29yXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yICE9IG51bGwpIHtcbiAgUXVlcnlDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybU51bGwoKS5fdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcigpO1xuICB9O1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yKGRvYykge1xuICByZXR1cm4gZG9jID09IG51bGwgPyB7IGRvbmU6IHRydWUgfSA6IHsgdmFsdWU6IGRvYywgZG9uZTogZmFsc2UgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgZG9jIGZyb20gdGhlIHVuZGVybHlpbmcgY3Vyc29yIGFuZCBtb25nb29zZWlmeSBpdFxuICogKHBvcHVsYXRlLCBldGMuKVxuICogQHBhcmFtIHtBbnl9IGN0eFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9uZXh0KGN0eCwgY2IpIHtcbiAgbGV0IGNhbGxiYWNrID0gY2I7XG4gIGlmIChjdHguX3RyYW5zZm9ybXMubGVuZ3RoKSB7XG4gICAgY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIGRvYykge1xuICAgICAgaWYgKGVyciB8fCAoZG9jID09PSBudWxsICYmICFjdHguX21vbmdvb3NlT3B0aW9ucy50cmFuc2Zvcm1OdWxsKSkge1xuICAgICAgICByZXR1cm4gY2IoZXJyLCBkb2MpO1xuICAgICAgfVxuICAgICAgY2IoZXJyLCBjdHguX3RyYW5zZm9ybXMucmVkdWNlKGZ1bmN0aW9uKGRvYywgZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwoY3R4LCBkb2MpO1xuICAgICAgfSwgZG9jKSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChjdHguX2Vycm9yKSB7XG4gICAgcmV0dXJuIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGNhbGxiYWNrKGN0eC5fZXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIGlmIChjdHguc2tpcHBlZCkge1xuICAgIHJldHVybiBpbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgbnVsbCkpO1xuICB9XG5cbiAgaWYgKGN0eC5jdXJzb3IpIHtcbiAgICBpZiAoY3R4LnF1ZXJ5Ll9tb25nb29zZU9wdGlvbnMucG9wdWxhdGUgJiYgIWN0eC5fcG9wKSB7XG4gICAgICBjdHguX3BvcCA9IGhlbHBlcnMucHJlcGFyZVBvcHVsYXRpb25PcHRpb25zTVEoY3R4LnF1ZXJ5LFxuICAgICAgICBjdHgucXVlcnkuX21vbmdvb3NlT3B0aW9ucyk7XG4gICAgICBjdHguX3BvcC5fX25vUHJvbWlzZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjdHgucXVlcnkuX21vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZSAmJiBjdHgub3B0aW9ucy5fcG9wdWxhdGVCYXRjaFNpemUgPiAxKSB7XG4gICAgICBpZiAoY3R4Ll9iYXRjaERvY3MgJiYgY3R4Ll9iYXRjaERvY3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIFJldHVybiBhIGNhY2hlZCBwb3B1bGF0ZWQgZG9jXG4gICAgICAgIHJldHVybiBfbmV4dERvYyhjdHgsIGN0eC5fYmF0Y2hEb2NzLnNoaWZ0KCksIGN0eC5fcG9wLCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2UgaWYgKGN0eC5fYmF0Y2hFeGhhdXN0ZWQpIHtcbiAgICAgICAgLy8gSW50ZXJuYWwgY3Vyc29yIHJlcG9ydGVkIG5vIG1vcmUgZG9jcy4gQWN0IHRoZSBzYW1lIGhlcmVcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVxdWVzdCBhcyBtYW55IGRvY3MgYXMgYmF0Y2hTaXplLCB0byBwb3B1bGF0ZSB0aGVtIGFsc28gaW4gYmF0Y2hcbiAgICAgICAgY3R4Ll9iYXRjaERvY3MgPSBbXTtcbiAgICAgICAgY3R4LmN1cnNvci5uZXh0KCkudGhlbihcbiAgICAgICAgICByZXMgPT4geyBfb25OZXh0LmNhbGwoeyBjdHgsIGNhbGxiYWNrIH0sIG51bGwsIHJlcyk7IH0sXG4gICAgICAgICAgZXJyID0+IHsgX29uTmV4dC5jYWxsKHsgY3R4LCBjYWxsYmFjayB9LCBlcnIpOyB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5jdXJzb3IubmV4dCgpLnRoZW4oXG4gICAgICAgIGRvYyA9PiB7XG4gICAgICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY3R4LnF1ZXJ5Ll9tb25nb29zZU9wdGlvbnMucG9wdWxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfbmV4dERvYyhjdHgsIGRvYywgbnVsbCwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN0eC5xdWVyeS5tb2RlbC5wb3B1bGF0ZShkb2MsIGN0eC5fcG9wKS50aGVuKFxuICAgICAgICAgICAgZG9jID0+IHtcbiAgICAgICAgICAgICAgX25leHREb2MoY3R4LCBkb2MsIGN0eC5fcG9wLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjdHgub25jZSgnZXJyb3InLCBjYik7XG5cbiAgICBjdHgub25jZSgnY3Vyc29yJywgZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgICBjdHgucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgY2IpO1xuICAgICAgaWYgKGN1cnNvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChjdHguc2tpcHBlZCkge1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfbmV4dChjdHgsIGNiKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9vbk5leHQoZXJyb3IsIGRvYykge1xuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFjayhlcnJvcik7XG4gIH1cbiAgaWYgKCFkb2MpIHtcbiAgICB0aGlzLmN0eC5fYmF0Y2hFeGhhdXN0ZWQgPSB0cnVlO1xuICAgIHJldHVybiBfcG9wdWxhdGVCYXRjaC5jYWxsKHRoaXMpO1xuICB9XG5cbiAgdGhpcy5jdHguX2JhdGNoRG9jcy5wdXNoKGRvYyk7XG5cbiAgaWYgKHRoaXMuY3R4Ll9iYXRjaERvY3MubGVuZ3RoIDwgdGhpcy5jdHgub3B0aW9ucy5fcG9wdWxhdGVCYXRjaFNpemUpIHtcbiAgICAvLyBJZiBib3RoIGBiYXRjaFNpemVgIGFuZCBgX3BvcHVsYXRlQmF0Y2hTaXplYCBhcmUgaHVnZSwgY2FsbGluZyBgbmV4dCgpYCByZXBlYXRlZGx5IG1heVxuICAgIC8vIGNhdXNlIGEgc3RhY2sgb3ZlcmZsb3cuIFNvIG1ha2Ugc3VyZSB3ZSBjbGVhciB0aGUgc3RhY2sgcmVndWxhcmx5LlxuICAgIGlmICh0aGlzLmN0eC5fYmF0Y2hEb2NzLmxlbmd0aCA+IDAgJiYgdGhpcy5jdHguX2JhdGNoRG9jcy5sZW5ndGggJSAxMDAwID09PSAwKSB7XG4gICAgICByZXR1cm4gaW1tZWRpYXRlKCgpID0+IHRoaXMuY3R4LmN1cnNvci5uZXh0KCkudGhlbihcbiAgICAgICAgcmVzID0+IHsgX29uTmV4dC5jYWxsKHRoaXMsIG51bGwsIHJlcyk7IH0sXG4gICAgICAgIGVyciA9PiB7IF9vbk5leHQuY2FsbCh0aGlzLCBlcnIpOyB9XG4gICAgICApKTtcbiAgICB9XG4gICAgdGhpcy5jdHguY3Vyc29yLm5leHQoKS50aGVuKFxuICAgICAgcmVzID0+IHsgX29uTmV4dC5jYWxsKHRoaXMsIG51bGwsIHJlcyk7IH0sXG4gICAgICBlcnIgPT4geyBfb25OZXh0LmNhbGwodGhpcywgZXJyKTsgfVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgX3BvcHVsYXRlQmF0Y2guY2FsbCh0aGlzKTtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9wb3B1bGF0ZUJhdGNoKCkge1xuICBpZiAoIXRoaXMuY3R4Ll9iYXRjaERvY3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gIH1cbiAgdGhpcy5jdHgucXVlcnkubW9kZWwucG9wdWxhdGUodGhpcy5jdHguX2JhdGNoRG9jcywgdGhpcy5jdHguX3BvcCkudGhlbihcbiAgICAoKSA9PiB7XG4gICAgICBfbmV4dERvYyh0aGlzLmN0eCwgdGhpcy5jdHguX2JhdGNoRG9jcy5zaGlmdCgpLCB0aGlzLmN0eC5fcG9wLCB0aGlzLmNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGVyciA9PiB7XG4gICAgICB0aGlzLmNhbGxiYWNrKGVycik7XG4gICAgfVxuICApO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9uZXh0RG9jKGN0eCwgZG9jLCBwb3AsIGNhbGxiYWNrKSB7XG4gIGlmIChjdHgucXVlcnkuX21vbmdvb3NlT3B0aW9ucy5sZWFuKSB7XG4gICAgcmV0dXJuIGN0eC5tb2RlbC5ob29rcy5leGVjUG9zdCgnZmluZCcsIGN0eC5xdWVyeSwgW1tkb2NdXSwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRvYyk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCB7IG1vZGVsLCBfZmllbGRzLCBfdXNlclByb3ZpZGVkRmllbGRzLCBvcHRpb25zIH0gPSBjdHgucXVlcnk7XG4gIGhlbHBlcnMuY3JlYXRlTW9kZWxBbmRJbml0KG1vZGVsLCBkb2MsIF9maWVsZHMsIF91c2VyUHJvdmlkZWRGaWVsZHMsIG9wdGlvbnMsIHBvcCwgKGVyciwgZG9jKSA9PiB7XG4gICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgY3R4Lm1vZGVsLmhvb2tzLmV4ZWNQb3N0KCdmaW5kJywgY3R4LnF1ZXJ5LCBbW2RvY11dLCBlcnIgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgZG9jKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3dhaXRGb3JDdXJzb3IoY3R4LCBjYikge1xuICBpZiAoY3R4LmN1cnNvcikge1xuICAgIHJldHVybiBjYigpO1xuICB9XG4gIGN0eC5vbmNlKCdjdXJzb3InLCBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICBpZiAoY3Vyc29yID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2IoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnlDdXJzb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/cursor/QueryCursor.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/document.js":
/*!*******************************************************!*\
  !*** ../server/node_modules/mongoose/lib/document.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst InternalCache = __webpack_require__(/*! ./internal */ \"(api)/../server/node_modules/mongoose/lib/internal.js\");\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nconst MixedSchema = __webpack_require__(/*! ./schema/mixed */ \"(api)/../server/node_modules/mongoose/lib/schema/mixed.js\");\nconst ObjectExpectedError = __webpack_require__(/*! ./error/objectExpected */ \"(api)/../server/node_modules/mongoose/lib/error/objectExpected.js\");\nconst ObjectParameterError = __webpack_require__(/*! ./error/objectParameter */ \"(api)/../server/node_modules/mongoose/lib/error/objectParameter.js\");\nconst ParallelValidateError = __webpack_require__(/*! ./error/parallelValidate */ \"(api)/../server/node_modules/mongoose/lib/error/parallelValidate.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"(api)/../server/node_modules/mongoose/lib/schema.js\");\nconst StrictModeError = __webpack_require__(/*! ./error/strict */ \"(api)/../server/node_modules/mongoose/lib/error/strict.js\");\nconst ValidationError = __webpack_require__(/*! ./error/validation */ \"(api)/../server/node_modules/mongoose/lib/error/validation.js\");\nconst ValidatorError = __webpack_require__(/*! ./error/validator */ \"(api)/../server/node_modules/mongoose/lib/error/validator.js\");\nconst $__hasIncludedChildren = __webpack_require__(/*! ./helpers/projection/hasIncludedChildren */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js\");\nconst applyDefaults = __webpack_require__(/*! ./helpers/document/applyDefaults */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/applyDefaults.js\");\nconst cleanModifiedSubpaths = __webpack_require__(/*! ./helpers/document/cleanModifiedSubpaths */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst compile = (__webpack_require__(/*! ./helpers/document/compile */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/compile.js\").compile);\nconst defineKey = (__webpack_require__(/*! ./helpers/document/compile */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/compile.js\").defineKey);\nconst flatten = (__webpack_require__(/*! ./helpers/common */ \"(api)/../server/node_modules/mongoose/lib/helpers/common.js\").flatten);\nconst get = __webpack_require__(/*! ./helpers/get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getEmbeddedDiscriminatorPath = __webpack_require__(/*! ./helpers/document/getEmbeddedDiscriminatorPath */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js\");\nconst getKeysInSchemaOrder = __webpack_require__(/*! ./helpers/schema/getKeysInSchemaOrder */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js\");\nconst getSubdocumentStrictValue = __webpack_require__(/*! ./helpers/schema/getSubdocumentStrictValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js\");\nconst handleSpreadDoc = __webpack_require__(/*! ./helpers/document/handleSpreadDoc */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst isDefiningProjection = __webpack_require__(/*! ./helpers/projection/isDefiningProjection */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\nconst isExclusive = __webpack_require__(/*! ./helpers/projection/isExclusive */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst inspect = (__webpack_require__(/*! util */ \"util\").inspect);\nconst internalToObjectOptions = (__webpack_require__(/*! ./options */ \"(api)/../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst markArraySubdocsPopulated = __webpack_require__(/*! ./helpers/populate/markArraySubdocsPopulated */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(api)/../server/node_modules/mpath/index.js\");\nconst queryhelpers = __webpack_require__(/*! ./queryhelpers */ \"(api)/../server/node_modules/mongoose/lib/queryhelpers.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst isPromise = __webpack_require__(/*! ./helpers/isPromise */ \"(api)/../server/node_modules/mongoose/lib/helpers/isPromise.js\");\n\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsBackupSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsBackupSymbol);\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst documentArrayParent = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\nconst documentIsModified = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").documentIsModified);\nconst documentModifiedPaths = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").documentModifiedPaths);\nconst documentSchemaSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").documentSchemaSymbol);\nconst getSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").getSymbol);\nconst populateModelSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\nconst scopeSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").scopeSymbol);\nconst schemaMixedSymbol = (__webpack_require__(/*! ./schema/symbols */ \"(api)/../server/node_modules/mongoose/lib/schema/symbols.js\").schemaMixedSymbol);\nconst parentPaths = __webpack_require__(/*! ./helpers/path/parentPaths */ \"(api)/../server/node_modules/mongoose/lib/helpers/path/parentPaths.js\");\nconst getDeepestSubdocumentForPath = __webpack_require__(/*! ./helpers/document/getDeepestSubdocumentForPath */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js\");\nconst sessionNewDocuments = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").sessionNewDocuments);\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\n\nconst specialProperties = utils.specialProperties;\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api/model.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = Object.assign({}, options);\n\n  // Support `browserDocument.js` syntax\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?\n      new Schema(fields) :\n      fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache();\n\n  // Avoid setting `isNew` to `true`, because it is `true` by default\n  if (options.isNew != null && options.isNew !== true) {\n    this.$isNew = options.isNew;\n  }\n\n  if (options.priorDoc != null) {\n    this.$__.priorDoc = options.priorDoc;\n  }\n\n  if (skipId) {\n    this.$__.skipId = skipId;\n  }\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  let defaults = true;\n  if (options.defaults !== undefined) {\n    this.$__.defaults = options.defaults;\n    defaults = options.defaults;\n  }\n\n  const schema = this.$__schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    if (fields !== true) {\n      this.$__.strictMode = fields;\n    }\n    fields = undefined;\n  } else if (schema.options.strict !== true) {\n    this.$__.strictMode = schema.options.strict;\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {\n    exclude = isExclusive(fields);\n    this.$__.selected = fields;\n    this.$__.exclude = exclude;\n  }\n\n  const hasIncludedChildren = exclude === false && fields ?\n    $__hasIncludedChildren(fields) :\n    null;\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    if (defaults) {\n      applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);\n    }\n  }\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true, options);\n    } else {\n      this.$set(obj, undefined, true, options);\n    }\n\n    if (obj instanceof Document) {\n      this.$isNew = obj.$isNew;\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit && defaults) {\n    if (options.skipDefaults) {\n      this.$__.skipDefaults = options.skipDefaults;\n    }\n  } else if (defaults) {\n    applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);\n  }\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      // Avoid methods, virtuals, existing fields, and `$` keys. The latter is to avoid overwriting\n      // Mongoose internals.\n      if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith('$')) {\n        defineKey({ prop: key, subprops: null, prototype: _this });\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\nDocument.prototype.$isMongooseDocumentPrototype = true;\n\n/**\n * Boolean flag specifying if the document is new. If you create a document\n * using `new`, this document will be considered \"new\". `$isNew` is how\n * Mongoose determines whether `save()` should use `insertOne()` to create\n * a new document or `updateOne()` to update an existing document.\n *\n * #### Example:\n *\n *     const user = new User({ name: 'John Smith' });\n *     user.$isNew; // true\n *\n *     await user.save(); // Sends an `insertOne` to MongoDB\n *\n * On the other hand, if you load an existing document from the database\n * using `findOne()` or another [query operation](https://mongoosejs.com/docs/queries.html),\n * `$isNew` will be false.\n *\n * #### Example:\n *\n *     const user = await User.findOne({ name: 'John Smith' });\n *     user.$isNew; // false\n *\n * Mongoose sets `$isNew` to `false` immediately after `save()` succeeds.\n * That means Mongoose sets `$isNew` to false **before** `post('save')` hooks run.\n * In `post('save')` hooks, `$isNew` will be `false` if `save()` succeeded.\n *\n * #### Example:\n *\n *     userSchema.post('save', function() {\n *       this.$isNew; // false\n *     });\n *     await User.create({ name: 'John Smith' });\n *\n * For subdocuments, `$isNew` is true if either the parent has `$isNew` set,\n * or if you create a new subdocument.\n *\n * #### Example:\n *\n *     // Assume `Group` has a document array `users`\n *     const group = await Group.findOne();\n *     group.users[0].$isNew; // false\n *\n *     group.users.push({ name: 'John Smith' });\n *     group.users[1].$isNew; // true\n *\n * @api public\n * @property $isNew\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, 'isNew', {\n  get: function() {\n    return this.$isNew;\n  },\n  set: function(value) {\n    this.$isNew = value;\n  }\n});\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, 'errors', {\n  get: function() {\n    return this.$errors;\n  },\n  set: function(value) {\n    this.$errors = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nDocument.prototype.$isNew = true;\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document.prototype[emitterFn] = function() {\n      // Delay creating emitter until necessary because emitters take up a lot of memory,\n      // especially for subdocuments.\n      if (!this.$__.emitter) {\n        if (emitterFn === 'emit') {\n          return;\n        }\n        this.$__.emitter = new EventEmitter();\n        this.$__.emitter.setMaxListeners(0);\n      }\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n    };\n    Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];\n  });\n\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\n * The document's internal schema.\n *\n * @api private\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__schema;\n\n/**\n * The document's schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * #### Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    if (this.$__.locals == null) {\n      this.$__.locals = {};\n    }\n    return this.$__.locals;\n  },\n  set: function(v) {\n    this.$__.locals = v;\n  }\n});\n\n/**\n * Legacy alias for `$isNew`.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @see $isNew https://mongoosejs.com/docs/api/document.html#Document.prototype.$isNew\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n *\n * #### Example:\n *\n *     // Make sure `save()` never updates a soft deleted document.\n *     schema.pre('save', function() {\n *       this.$where = { isDeleted: false };\n *     });\n *\n * @api public\n * @property $where\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * The string version of this documents _id.\n *\n * #### Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](https://mongoosejs.com/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options https://mongoosejs.com/docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation $errors.\n *\n * @api public\n * @property $errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$errors;\n\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * #### Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$op', {\n  get: function() {\n    return this.$__.op || null;\n  },\n  set: function(value) {\n    this.$__.op = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nfunction $applyDefaultsToNested(val, path, doc) {\n  if (val == null) {\n    return;\n  }\n\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    if (!p.startsWith(path + '.')) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const pieces = type.splitPath().slice(pathPieces.length);\n    const len = pieces.length;\n\n    if (type.defaultValue === void 0) {\n      continue;\n    }\n\n    let cur = val;\n\n    for (let j = 0; j < len; ++j) {\n      if (cur == null) {\n        break;\n      }\n\n      const piece = pieces[j];\n\n      if (j === len - 1) {\n        if (cur[piece] !== void 0) {\n          break;\n        }\n\n        try {\n          const def = type.getDefault(doc, false);\n          if (def !== void 0) {\n            cur[piece] = def;\n          }\n        } catch (err) {\n          doc.invalidate(path + '.' + curPath, err);\n          break;\n        }\n\n        break;\n      }\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      cur[piece] = cur[piece] || {};\n      cur = cur[piece];\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @param {Boolean} [exclude]\n * @param {Object} [hasIncludedChildren]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n\n  const paths = Object.keys(this.$__schema.paths).\n    // Don't build up any paths that are underneath a map, we don't know\n    // what the keys will be\n    filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      if (!curPath.length) {\n        curPath = piece;\n      } else {\n        curPath += '.' + piece;\n      }\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](https://mongoosejs.com/docs/middleware.html).\n * Note that `init` hooks are [synchronous](https://mongoosejs.com/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @param {Object} [opts]\n * @param {Function} [fn]\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\n/**\n * Alias for [`.init`](https://mongoosejs.com/docs/api/document.html#Document.prototype.init())\n *\n * @api public\n */\n\nDocument.prototype.$init = function() {\n  return this.constructor.prototype.init.apply(this, arguments);\n};\n\n/**\n * Internal \"init\" function\n *\n * @param {Document} doc\n * @param {Object} [opts]\n * @returns {Document} this\n * @api private\n */\n\nDocument.prototype.$__init = function(doc, opts) {\n  this.$isNew = false;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.$populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.$populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n        child.$__.parent = this;\n      }\n      item._childDocs = [];\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n\n  markArraySubdocsPopulated(this, opts.populated);\n\n  this.$emit('init', this);\n  this.constructor.emit('init', this);\n\n  const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ?\n    $__hasIncludedChildren(this.$__.selected) :\n    null;\n\n  applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);\n\n  return this;\n};\n\n/**\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @param {Object} [opts] Optional Options\n * @param {Boolean} [opts.setters] Call `applySetters` instead of `cast`\n * @param {String} [prefix] Prefix to add to each path\n * @api private\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n\n  if (obj.$__ != null) {\n    obj = obj._doc;\n  }\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schemaType;\n  let path;\n  let i;\n  let index = 0;\n  const strict = self.$__.strictMode;\n  const docSchema = self.$__schema;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    // avoid prototype pollution\n    if (i === '__proto__' || i === 'constructor') {\n      return;\n    }\n    path = prefix ? prefix + i : i;\n    schemaType = docSchema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    const value = obj[i];\n    if (!schemaType && utils.isPOJO(value)) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\n          self[i] = doc[i];\n        }\n      }\n      init(self, value, doc[i], opts, path + '.');\n    } else if (!schemaType) {\n      doc[i] = value;\n      if (!strict && !prefix) {\n        self[i] = value;\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && value !== void 0) {\n        delete doc[i];\n      }\n      if (value === null) {\n        doc[i] = schemaType._castNullish(null);\n      } else if (value !== undefined) {\n        const wasPopulated = value.$__ == null ? null : value.$__.wasPopulated;\n\n        if (schemaType && !wasPopulated) {\n          try {\n            if (opts && opts.setters) {\n              // Call applySetters with `init = false` because otherwise setters are a noop\n              const overrideInit = false;\n              doc[i] = schemaType.applySetters(value, self, overrideInit);\n            } else {\n              doc[i] = schemaType.cast(value, self, true);\n            }\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = value;\n        }\n      }\n      // mark as hydrated\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * #### Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * #### Valid options:\n *\n *  - same as in [Model.updateOne](https://mongoosejs.com/docs/api/model.html#Model.updateOne)\n *\n * @see Model.updateOne https://mongoosejs.com/docs/api/model.html#Model.updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and the [Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({ _id: this._id }, doc, options);\n  const self = this;\n  query.pre(function queryPreUpdateOne(cb) {\n    self.constructor._middleware.execPre('updateOne', self, [self], cb);\n  });\n  query.post(function queryPostUpdateOne(cb) {\n    self.constructor._middleware.execPost('updateOne', self, [self], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * #### Valid options:\n *\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#Model.replaceOne())\n *\n * @see Model.replaceOne https://mongoosejs.com/docs/api/model.html#Model.replaceOne()\n * @param {Object} doc\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = [...arguments];\n  args.unshift({ _id: this._id });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * #### Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n    return this.$__.session;\n  }\n\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' +\n      'called `endSession()` on the session you are passing to `$session()`.');\n  }\n\n  if (session == null && this.$__.session == null) {\n    return;\n  }\n\n  this.$__.session = session;\n\n  if (!this.$isSubdocument) {\n    const subdocs = this.$getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n\n/**\n * Getter/setter around whether this document will apply timestamps by\n * default when using `save()` and `bulkSave()`.\n *\n * #### Example:\n *\n *     const TestModel = mongoose.model('Test', new Schema({ name: String }, { timestamps: true }));\n *     const doc = new TestModel({ name: 'John Smith' });\n *\n *     doc.$timestamps(); // true\n *\n *     doc.$timestamps(false);\n *     await doc.save(); // Does **not** apply timestamps\n *\n * @param {Boolean} [value] overwrite the current session\n * @return {Document|boolean|undefined} When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset \"undefined\" will be used, otherwise will return \"this\"\n * @method $timestamps\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$timestamps = function $timestamps(value) {\n  if (arguments.length === 0) {\n    if (this.$__.timestamps != null) {\n      return this.$__.timestamps;\n    }\n\n    if (this.$__schema) {\n      return this.$__schema.options.timestamps;\n    }\n\n    return undefined;\n  }\n\n  const currentValue = this.$timestamps();\n  if (value !== currentValue) {\n    this.$__.timestamps = value;\n  }\n\n  return this;\n};\n\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @memberOf Document\n * @instance\n * @api public\n * @return {Document} this\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @param {Boolean} [options.merge=false] if true, setting a [nested path](https://mongoosejs.com/docs/subdocs.html#subdocuments-versus-nested-paths) will merge existing values rather than overwrite the whole object. So `doc.set('nested', { a: 1, b: 2 })` becomes `doc.set('nested.a', 1); doc.set('nested.b', 2);`\n * @return {Document} this\n * @method $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  const merge = options && options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n\n  const userSpecifiedStrict = options && 'strict' in options;\n  let strict = userSpecifiedStrict\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  if (path == null) {\n    [path, val] = [val, path];\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        // This ternary is to support gh-7898 (copying virtuals if same schema)\n        // while not breaking gh-10819, which for some reason breaks if we use toObject()\n        path = path.$__schema === this.$__schema\n          ? applyVirtuals(path, { ...path._doc })\n          : path._doc;\n      }\n    }\n    if (path == null) {\n      [path, val] = [val, path];\n    }\n\n    prefix = val ? val + '.' : '';\n    keys = getKeysInSchemaOrder(this.$__schema, path);\n\n    const len = keys.length;\n\n    // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n    const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n      if (val) {\n        this.$set(val, {});\n      }\n      return this;\n    }\n\n    options = Object.assign({}, options, { _skipMinimizeTopLevel: false });\n\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix ? prefix + key : key;\n      pathtype = this.$__schema.pathType(pathName);\n      const valForKey = path[key];\n\n      // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n      if (type === true &&\n          !prefix &&\n          valForKey != null &&\n          pathtype === 'nested' &&\n          this._doc[key] != null) {\n        delete this._doc[key];\n      }\n\n      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {\n        this.$set(pathName, valForKey, constructing, Object.assign({}, options, { _skipMarkModified: true }));\n        $applyDefaultsToNested(this.$get(pathName), pathName, this);\n        continue;\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && valForKey === void 0 &&\n            this.$get(pathName) !== void 0) {\n          continue;\n        }\n\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\n        }\n\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          this.$set(pathName, valForKey, constructing, options);\n        } else if (pathtype === 'nested' && valForKey instanceof Document) {\n          this.$set(pathName,\n            valForKey.toObject({ transform: false }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, valForKey);\n          } else {\n            throw new StrictModeError(key);\n          }\n        } else if (pathtype === 'nested' && valForKey == null) {\n          this.$set(pathName, valForKey, constructing, options);\n        }\n      } else if (valForKey !== void 0) {\n        this.$set(pathName, valForKey, constructing, options);\n      }\n    }\n\n    // Ensure all properties are in correct order\n    const orderedDoc = {};\n    const orderedKeys = Object.keys(this.$__schema.tree);\n    for (let i = 0, len = orderedKeys.length; i < len; ++i) {\n      (key = orderedKeys[i]) &&\n      (this._doc.hasOwnProperty(key)) &&\n      (orderedDoc[key] = undefined);\n    }\n    this._doc = Object.assign(orderedDoc, this._doc);\n\n    return this;\n  }\n\n  let pathType = this.$__schema.pathType(path);\n  let parts = null;\n  if (pathType === 'adhocOrUndefined') {\n    parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n    pathType = getEmbeddedDiscriminatorPath(this, parts, { typeOnly: true });\n  }\n  if (pathType === 'adhocOrUndefined' && !userSpecifiedStrict) {\n    // May be path underneath non-strict schema\n    if (parts == null) {\n      parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n    }\n    const subdocStrict = getSubdocumentStrictValue(this.$__schema, parts);\n    if (subdocStrict !== undefined) {\n      strict = subdocStrict;\n    }\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  val = handleSpreadDoc(val);\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.priorDoc != null) {\n      return this.$__.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (val.$__ != null) {\n        val = val.toObject(internalToObjectOptions);\n      }\n      if (val == null) {\n        this.invalidate(path, new MongooseError.CastError('Object', val, path));\n        return this;\n      }\n      const wasModified = this.$isModified(path);\n      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const initialVal = this.$__getValue(path);\n        this.$__.savedState[path] = initialVal;\n\n        const keys = Object.keys(initialVal || {});\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = initialVal[key];\n        }\n      }\n\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing, options);\n      }\n\n      const keys = getKeysInSchemaOrder(this.$__schema, val, path);\n\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing, { ...options, _skipMarkModified: true });\n      }\n      if (priorVal != null &&\n          (!wasModified || hasInitialVal) &&\n          utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  if (parts == null) {\n    parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n  }\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[parts[0]] === 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.$__schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      } else if (schema.$isSchemaMap && schema.$__schemaType instanceof MixedSchema && i < parts.length - 1) {\n        // Map of mixed and not the last element in the path resolves to mixed\n        mixed = true;\n        schema = schema.$__schemaType;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length !== 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoServerError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    const len = parts.length;\n    for (i = 0; i < len; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.$get(subpath, null, { getters: false }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  if (!schema) {\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (pathType === 'nested' && val == null) {\n      cleanModifiedSubpaths(this, path);\n    }\n    return this;\n  }\n\n  // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (val != null && merge && schema.$isSingleNested) {\n    if (val instanceof Document) {\n      val = val.toObject({ virtuals: false, transform: false });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n    if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {\n      const unpopulatedValue = (schema && schema.$isSingleNested) ? schema.cast(val, this) : val._id;\n      this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });\n      val.$__.wasPopulated = { value: unpopulatedValue };\n      didPopulate = true;\n    }\n\n    let popOpts;\n    const typeKey = this.$__schema.options.typeKey;\n    if (schema.options &&\n        Array.isArray(schema.options[typeKey]) &&\n        schema.options[typeKey].length &&\n        schema.options[typeKey][0].ref &&\n        _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = { [populateModelSymbol]: val[0].constructor };\n      this.$populated(path, val.map(function(v) { return v._id; }), popOpts);\n\n      for (const doc of val) {\n        doc.$__.wasPopulated = { value: doc._id };\n      }\n      didPopulate = true;\n    }\n\n    if (!refMatches || !schema.$isSingleNested || !val.$__) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      let setterContext = this;\n      if (this.$__schema.singleNestedPaths[path] != null && parts.length > 1) {\n        setterContext = getDeepestSubdocumentForPath(this, parts, this.schema);\n      }\n      if (options != null && options.overwriteImmutable) {\n        val = schema.applySetters(val, setterContext, false, priorVal, { overwriteImmutable: true });\n      } else {\n        val = schema.applySetters(val, setterContext, false, priorVal);\n      }\n    }\n\n    if (Array.isArray(val) &&\n        !Array.isArray(schema) &&\n        schema.$isMongooseDocumentArray &&\n        val.length !== 0 &&\n        val[0] != null &&\n        val[0].$__ != null &&\n        val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.$populated(path + '.' + populatedPath,\n          val.map(v => v.$populated(populatedPath)),\n          val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val.set(i, val[i]._id, true);\n          }\n        }\n      }\n      delete this.$__.populated[path];\n    }\n\n    if (val != null && schema.$isSingleNested) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n      if (e.$originalErrorPath) {\n        this.invalidate(path,\n          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path,\n        new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    let savedState = null;\n    let savedStatePath = null;\n    if (!constructing) {\n      const doc = this.$isSubdocument ? this.ownerDocument() : this;\n      savedState = doc.$__.savedState;\n      savedStatePath = this.$isSubdocument ? this.$__.fullPath + '.' + path : path;\n      doc.$__saveInitialState(savedStatePath);\n    }\n\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    const isInTransaction = !!this.$__.session?.transaction;\n    const isModifiedWithinTransaction = this.$__.session &&\n      this.$__.session[sessionNewDocuments] &&\n      this.$__.session[sessionNewDocuments].has(this) &&\n      this.$__.session[sessionNewDocuments].get(this).modifiedPaths &&\n      !this.$__.session[sessionNewDocuments].get(this).modifiedPaths.has(savedStatePath);\n    if (savedState != null &&\n        savedState.hasOwnProperty(savedStatePath) &&\n        (!isInTransaction || isModifiedWithinTransaction) &&\n        utils.deepEqual(val, savedState[savedStatePath])) {\n      this.unmarkModified(path);\n    }\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n    const modelName = el.constructor.modelName;\n    if (modelName == null) {\n      return false;\n    }\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Sets the value of a path, or many paths.\n * Alias for [`.$set`](https://mongoosejs.com/docs/api/document.html#Document.prototype.$set()).\n *\n * #### Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @return {Document} this\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @param {never} pathToMark UNUSED\n * @param {String|Symbol} path\n * @param {Object} options\n * @param {Any} constructing\n * @param {never} parts UNUSED\n * @param {Schema} schema\n * @param {Any} val\n * @param {Any} priorVal\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  if (options && options._skipMarkModified) {\n    return false;\n  }\n  if (this.$isNew) {\n    return true;\n  }\n  // Is path already modified? If so, always modify. We may unmark modified later.\n  if (path in this.$__.activePaths.getStatePaths('modify')) {\n    return true;\n  }\n\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.getStatePaths('default')) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.$populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal !== undefined ? priorVal : utils.getValue(path, this))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.getStatePaths('default') &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @param {String} pathToMark\n * @param {String|Symbol} path\n * @param {Object} options\n * @param {Any} constructing\n * @param {Array} parts\n * @param {Schema} schema\n * @param {Any} val\n * @param {Any} priorVal\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || __webpack_require__(/*! ./types/ArraySubdocument */ \"(api)/../server/node_modules/mongoose/lib/types/ArraySubdocument.js\");\n\n  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts,\n    schema, val, priorVal);\n\n  if (shouldModify) {\n    if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {\n      delete this.$__.primitiveAtomics[path];\n      if (Object.keys(this.$__.primitiveAtomics).length === 0) {\n        delete this.$__.primitiveAtomics;\n      }\n    }\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = __webpack_require__(/*! ./types/array */ \"(api)/../server/node_modules/mongoose/lib/types/array/index.js\"));\n    if (val && utils.isMongooseArray(val)) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (utils.isMongooseDocumentArray(val)) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n    }\n  } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {\n    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];\n    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];\n    if (utils.isMongooseDocumentArray(val)) {\n      val.forEach(doc => {\n        if (doc != null) {\n          doc.$isNew = false;\n        }\n      });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else if (obj.$isSingleNested) {\n        if (!(parts[i] in obj)) {\n          obj[parts[i]] = val;\n          obj._doc[parts[i]] = val;\n        } else {\n          obj._doc[parts[i]] = val;\n        }\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      const isMap = obj instanceof Map;\n      let value = isMap ? obj.get(parts[i]) : obj[parts[i]];\n      if (utils.isPOJO(value)) {\n        obj = value;\n      } else if (value && value instanceof Embedded) {\n        obj = value;\n      } else if (value && !Array.isArray(value) && value.$isSingleNested) {\n        obj = value;\n      } else if (value && Array.isArray(value)) {\n        obj = value;\n      } else if (value == null) {\n        value = {};\n        if (isMap) {\n          obj.set(parts[i], value);\n        } else {\n          obj[parts[i]] = value;\n        }\n        obj = value;\n      } else {\n        obj = value;\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @return {Any} Returns the value from the given `path`.\n * @api private\n */\n\nDocument.prototype.$__getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Increments the numeric value at `path` by the given `val`.\n * When you call `save()` on this document, Mongoose will send a\n * [`$inc`](https://www.mongodb.com/docs/manual/reference/operator/update/inc/)\n * as opposed to a `$set`.\n *\n * #### Example:\n *\n *     const schema = new Schema({ counter: Number });\n *     const Test = db.model('Test', schema);\n *\n *     const doc = await Test.create({ counter: 0 });\n *     doc.$inc('counter', 2);\n *     await doc.save(); // Sends a `{ $inc: { counter: 2 } }` to MongoDB\n *     doc.counter; // 2\n *\n *     doc.counter += 2;\n *     await doc.save(); // Sends a `{ $set: { counter: 2 } }` to MongoDB\n *\n * @param {String|Array} path path or paths to update\n * @param {Number} val increment `path` by this value\n * @return {Document} this\n */\n\nDocument.prototype.$inc = function $inc(path, val) {\n  if (val == null) {\n    val = 1;\n  }\n\n  if (Array.isArray(path)) {\n    path.forEach((p) => this.$inc(p, val));\n    return this;\n  }\n\n  const schemaType = this.$__path(path);\n  if (schemaType == null) {\n    if (this.$__.strictMode === 'throw') {\n      throw new StrictModeError(path);\n    } else if (this.$__.strictMode === true) {\n      return this;\n    }\n  } else if (schemaType.instance !== 'Number') {\n    this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));\n    return this;\n  }\n\n  const currentValue = this.$__getValue(path) || 0;\n  let shouldSet = false;\n  let valToSet = null;\n  let valToInc = val;\n\n  try {\n    val = schemaType.cast(val);\n    valToSet = schemaType.applySetters(currentValue + val, this);\n    valToInc = valToSet - currentValue;\n    shouldSet = true;\n  } catch (err) {\n    this.invalidate(path, new MongooseError.CastError('number', val, path, err));\n  }\n\n  if (shouldSet) {\n    this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};\n    if (this.$__.primitiveAtomics[path] == null) {\n      this.$__.primitiveAtomics[path] = { $inc: valToInc };\n    } else {\n      this.$__.primitiveAtomics[path].$inc += valToInc;\n    }\n    this.markModified(path);\n    this.$__setValue(path, valToSet);\n  }\n\n  return this;\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @return {Document} this\n * @api private\n */\n\nDocument.prototype.$__setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * #### Example:\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @return {Any}\n * @api public\n */\n\nDocument.prototype.get = function(path, type, options) {\n  let adhoc;\n  if (options == null) {\n    options = {};\n  }\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n  const noDottedPath = options.noDottedPath;\n\n  // Fast path if we know we're just accessing top-level path on the document:\n  // just get the schema path, avoid `$__path()` because that does string manipulation\n  let schema = noDottedPath ? this.$__schema.paths[path] : this.$__path(path);\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n\n    if (schema != null) {\n      return schema.applyGetters(void 0, this);\n    }\n  }\n\n  if (noDottedPath) {\n    let obj = this._doc[path];\n    if (adhoc) {\n      obj = adhoc.cast(obj);\n    }\n    if (schema != null && options.getters !== false) {\n      return schema.applyGetters(obj, this);\n    }\n    return obj;\n  }\n\n  if (schema != null && schema.instance === 'Mixed') {\n    const virtual = this.$__schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n\n  const hasDot = path.indexOf('.') !== -1;\n  let obj = this._doc;\n\n  const pieces = hasDot ? path.split('.') : [path];\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[pieces[0]] === 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], { getters: false });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, clone(obj) || {}, { path: path });\n  }\n\n  return obj;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\nDocument.prototype.$get = Document.prototype.get;\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @return {SchemaPath}\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function(path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.$__schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed) types._\n *\n * #### Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function(path, scope) {\n  this.$__saveInitialState(path);\n\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.$isSubdocument) {\n    this.$__.pathsToScopes = this.$__pathsToScopes || {};\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__saveInitialState = function $__saveInitialState(path) {\n  const savedState = this.$__.savedState;\n  const savedStatePath = path;\n  if (savedState != null) {\n    const firstDot = savedStatePath.indexOf('.');\n    const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);\n    if (!savedState.hasOwnProperty(topLevelPath)) {\n      savedState[topLevelPath] = clone(this.$__getValue(topLevelPath));\n    }\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * #### Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n  if (this.$__.pathsToScopes != null) {\n    delete this.$__.pathsToScopes[path];\n  }\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * #### Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * #### Example:\n *\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {String[]}\n * @api public\n */\n\nDocument.prototype.directModifiedPaths = function() {\n  return Object.keys(this.$__.activePaths.getStatePaths('modify'));\n};\n\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](https://mongoosejs.com/docs/guide.html#minimize).\n *\n * #### Example:\n *\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @param {String} [path]\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\nDocument.prototype.$isEmpty = function(path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length !== 0) {\n    const v = this.$get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\n/*!\n * ignore\n */\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {String[]}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function(options) {\n  options = options || {};\n\n  const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths('modify'));\n  const result = new Set();\n\n  let i = 0;\n  let j = 0;\n  const len = directModifiedPaths.length;\n\n  for (i = 0; i < len; ++i) {\n    const path = directModifiedPaths[i];\n    const parts = parentPaths(path);\n    const pLen = parts.length;\n\n    for (j = 0; j < pLen; ++j) {\n      result.add(parts[j]);\n    }\n\n    if (!options.includeChildren) {\n      continue;\n    }\n\n    let ii = 0;\n    let cur = this.$get(path);\n    if (typeof cur === 'object' && cur !== null) {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      const len = cur.length;\n      if (Array.isArray(cur)) {\n        for (ii = 0; ii < len; ++ii) {\n          const subPath = path + '.' + ii;\n          if (!result.has(subPath)) {\n            result.add(subPath);\n            if (cur[ii] != null && cur[ii].$__) {\n              const modified = cur[ii].modifiedPaths();\n              let iii = 0;\n              const iiiLen = modified.length;\n              for (iii = 0; iii < iiiLen; ++iii) {\n                result.add(subPath + '.' + modified[iii]);\n              }\n            }\n          }\n        }\n      } else {\n        const keys = Object.keys(cur);\n        let ii = 0;\n        const len = keys.length;\n        for (ii = 0; ii < len; ++ii) {\n          result.add(path + '.' + keys[ii]);\n        }\n      }\n    }\n  }\n  return Array.from(result);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n\n/**\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n * in this document is modified.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * #### Example:\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @param {Object} [options]\n * @param {Boolean} [options.ignoreAtomics=false] If true, doesn't return true if path is underneath an array that was modified with atomic operations like `push()`\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths, options, modifiedPaths) {\n  if (paths) {\n    const ignoreAtomics = options && options.ignoreAtomics;\n    const directModifiedPathsObj = this.$__.activePaths.states.modify;\n    if (directModifiedPathsObj == null) {\n      return false;\n    }\n\n    if (typeof paths === 'string') {\n      paths = paths.indexOf(' ') === -1 ? [paths] : paths.split(' ');\n    }\n\n    for (const path of paths) {\n      if (directModifiedPathsObj[path] != null) {\n        return true;\n      }\n    }\n\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n\n    let directModifiedPaths = Object.keys(directModifiedPathsObj);\n    if (ignoreAtomics) {\n      directModifiedPaths = directModifiedPaths.filter(path => {\n        const value = this.$__getValue(path);\n        if (value != null && value[arrayAtomicsSymbol] != null && value[arrayAtomicsSymbol].$set === undefined) {\n          return false;\n        }\n        return true;\n      });\n    }\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\n/**\n * Alias of [`.isModified`](https://mongoosejs.com/docs/api/document.html#Document.prototype.isModified())\n *\n * @method $isModified\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$isModified = Document.prototype.isModified;\n\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n\n/**\n * Checks if a path is set to its default.\n *\n * #### Example:\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('default').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('default').hasOwnProperty(path));\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * #### Example:\n *\n *     const product = await product.remove();\n *     product.$isDeleted(); // true\n *     product.remove(); // no-op, doesn't send anything to the db\n *\n *     product.$isDeleted(false);\n *     product.$isDeleted(); // false\n *     product.remove(); // will execute a remove against the db\n *\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean|Document} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function(val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * #### Example:\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String|String[]} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    const res = this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path);\n    if (res || path.indexOf('.') === -1) {\n      return res;\n    }\n\n    const pieces = path.split('.');\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      const subpath = pieces.slice(0, i + 1).join('.');\n      const subdoc = this.$get(subpath);\n      if (subdoc != null && subdoc.$__ != null && subdoc.isDirectModified(pieces.slice(i + 1).join('.'))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  let paths = path;\n  if (typeof paths === 'string') {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.isDirectModified(path));\n};\n\n/**\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n *\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('init').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('init').hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * #### Example:\n *\n *     const doc = await Thing.findOne().select('name');\n *     doc.isSelected('name') // true\n *     doc.isSelected('age')  // false\n *\n * @param {String|String[]} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n  if (!path) {\n    return false;\n  }\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n\n  const pathDot = path + '.';\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n  return !inclusive;\n};\n\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * #### Example:\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n\n  return !inclusive;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * #### Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) is aborted and the error is thrown.\n *\n * #### Example:\n *\n *     await doc.validate({ validateModifiedOnly: false, pathsToSkip: ['name', 'email']});\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {Promise} Returns a Promise.\n * @api public\n */\n\nDocument.prototype.validate = async function validate(pathsToValidate, options) {\n  if (typeof pathsToValidate === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Document.prototype.validate() no longer accepts a callback');\n  }\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.$isSubdocument != null) {\n    // Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });\n  }\n\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      pathsToValidate = null;\n    }\n  }\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n\n  if (parallelValidate != null) {\n    throw parallelValidate;\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__validate(pathsToValidate, options, (error) => {\n      this.$op = null;\n      this.$__.validating = null;\n      if (error != null) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Alias of [`.validate`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate())\n *\n * @method $validate\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$validate = Document.prototype.validate;\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths('require'));\n  let i = 0;\n  const len = requiredFields.length;\n  for (i = 0; i < len; ++i) {\n    const path = requiredFields[i];\n\n    const p = doc.$__schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired = doc.$__.cachedRequired || {};\n      try {\n        doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n      } catch (err) {\n        doc.invalidate(path, err);\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc, pathsToValidate, pathsToSkip) {\n  const doValidateOptions = {};\n\n  _evaluateRequiredFunctions(doc);\n  // only validate required fields when necessary\n  let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths('require')).filter(function(path) {\n    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {\n      return false;\n    }\n    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  }));\n\n  Object.keys(doc.$__.activePaths.getStatePaths('init')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('modify')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('default')).forEach(addToPaths);\n  function addToPaths(p) { paths.add(p); }\n\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      const fullPathToSubdoc = subdoc.$isSingleNested ? subdoc.$__pathRelativeToParent() : subdoc.$__fullPathWithIndexes();\n\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc.\n      // The following is a faster take on looping through every path in `paths`\n      // and checking if the path starts with `fullPathToSubdoc` re: gh-13191\n      for (const modifiedPath of subdoc.modifiedPaths()) {\n        paths.delete(fullPathToSubdoc + '.' + modifiedPath);\n      }\n\n      if (doc.$isModified(fullPathToSubdoc, null, modifiedPaths) &&\n            !doc.isDirectModified(fullPathToSubdoc) &&\n            !doc.$isDefault(fullPathToSubdoc)) {\n        paths.add(fullPathToSubdoc);\n        if (doc.$__.pathsToScopes == null) {\n          doc.$__.pathsToScopes = {};\n        }\n        doc.$__.pathsToScopes[fullPathToSubdoc] = subdoc.$isDocumentArrayElement ?\n          subdoc.__parentArray :\n          subdoc.$parent();\n\n        doValidateOptions[fullPathToSubdoc] = { skipSchemaValidators: true };\n        if (subdoc.$isDocumentArrayElement && subdoc.__index != null) {\n          doValidateOptions[fullPathToSubdoc].index = subdoc.__index;\n        }\n      }\n    }\n  }\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (_pathType.$isMongooseDocumentArray) {\n      for (const p of paths) {\n        if (p == null || p.startsWith(_pathType.path + '.')) {\n          paths.delete(p);\n        }\n      }\n    }\n\n    // Optimization: if primitive path with no validators, or array of primitives\n    // with no validators, skip validating this path entirely.\n    if (!_pathType.caster && _pathType.validators.length === 0 && !_pathType.$parentSchemaDocArray) {\n      paths.delete(path);\n    } else if (_pathType.$isMongooseArray &&\n      !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n      !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n      _pathType.validators.length === 0 && // and arrays with top-level validators\n      _pathType.$embeddedSchemaType.validators.length === 0) {\n      paths.delete(path);\n    }\n  }\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n  }\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n\n  // from here on we're not removing items from paths\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (!_pathType.$isMongooseArray ||\n        // To avoid potential performance issues, skip doc arrays whose children\n        // are not required. `getPositionalPathType()` may be slow, so avoid\n        // it unless we have a case of #6364\n        (!Array.isArray(_pathType) &&\n          _pathType.$isMongooseDocumentArray &&\n          !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required))) {\n      continue;\n    }\n\n    // gh-11380: optimization. If the array isn't a document array and there's no validators\n    // on the array type, there's no need to run validation on the individual array elements.\n    if (_pathType.$isMongooseArray &&\n        !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n        _pathType.$embeddedSchemaType.validators.length === 0) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = { skipArrays: true };\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n\n    if (!_pathType) {\n      continue;\n    }\n\n    // If underneath a document array, may need to re-validate the parent\n    // array re: gh-6818. Do this _after_ adding subpaths, because\n    // we don't want to add every array subpath.\n    if (_pathType.$parentSchemaDocArray && typeof _pathType.$parentSchemaDocArray.path === 'string') {\n      paths.add(_pathType.$parentSchemaDocArray.path);\n    }\n\n    if (!_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, doValidateOptions];\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  const pathsToSkip = (options && options.pathsToSkip) || null;\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = null;\n    this.$__.validating = null;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n      for (const errPath of errors) {\n        if (!this.$isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.$emit('validate', _this);\n    this.constructor.emit('validate', _this);\n\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] &&\n            validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);\n  const paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const doValidateOptionsByPath = pathDetails[1];\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n\n  if (paths.length === 0) {\n    return immediate(function() {\n      const error = _complete();\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  for (const path of paths) {\n    validatePath(path);\n  }\n\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n\n    immediate(function() {\n      const schemaType = _this.$__schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if ((pop = _this.$populated(path))) {\n        val = pop;\n      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {\n        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,\n        // so in that case pull out the document's id\n        val = val._id;\n      }\n      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ?\n        _this.$__.pathsToScopes[path] :\n        _this;\n\n      const doValidateOptions = {\n        ...doValidateOptionsByPath[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly\n      };\n\n      schemaType.doValidate(val, function(err) {\n        if (err) {\n          const isSubdoc = schemaType.$isSingleNested ||\n              schemaType.$isArraySubdocument ||\n              schemaType.$isMongooseDocumentArray;\n          if (isSubdoc && err instanceof ValidationError) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n\n  function complete() {\n    const error = _complete();\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  }\n\n};\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n  const parentPaths = new Map([]);\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    const pieces = path.split('.');\n    let cur = pieces[0];\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = new Set();\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.add(path);\n    } else if (parentPaths.has(path)) {\n      ret.add(parentPaths.get(path));\n    }\n  }\n  return ret;\n}\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = Array.from(paths).filter(p => !pathsToSkip.has(p));\n  return new Set(paths);\n}\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * #### Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * #### Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} [pathsToValidate] only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate, options) {\n  const _this = this;\n\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  let pathsToSkip = options && options.pathsToSkip;\n\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);\n  const paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  const validating = {};\n\n  for (let i = 0, len = paths.length; i < len; ++i) {\n    const path = paths[i];\n\n    if (validating[path]) {\n      continue;\n    }\n\n    validating[path] = true;\n\n    const p = _this.$__schema.path(path);\n    if (!p) {\n      continue;\n    }\n    if (!_this.$isValid(path)) {\n      continue;\n    }\n\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly\n    });\n    if (err) {\n      const isSubdoc = p.$isSingleNested ||\n        p.$isArraySubdocument ||\n        p.$isMongooseDocumentArray;\n      if (isSubdoc && err instanceof ValidationError) {\n        continue;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  }\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.$emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n *\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} err the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} val optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.$session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://www.mongodb.com/docs/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String|String[]} [path] the field to check. If unset will always return \"false\"\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function(path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n  if (path == null) {\n    return false;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n\n  return this.$__.validationError.errors[path] == null;\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document} this\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n\n  // Skip for subdocuments\n  const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];\n  const resetArrays = new Set();\n  for (const subdoc of subdocs) {\n    const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();\n    subdoc.$__reset();\n    if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {\n      if (subdoc.$isDocumentArrayElement) {\n        resetArrays.add(subdoc.parentArray());\n      } else {\n        const parent = subdoc.$parent();\n        if (parent === this) {\n          this.$__.activePaths.clearPath(subdoc.$basePath);\n        } else if (parent != null && parent.$isSubdocument) {\n          // If map path underneath subdocument, may end up with a case where\n          // map path is modified but parent still needs to be reset. See gh-10295\n          parent.$__reset();\n        }\n      }\n    }\n  }\n\n  for (const array of resetArrays) {\n    this.$__.activePaths.clearPath(array.$path());\n    array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n    array[arrayAtomicsSymbol] = {};\n  }\n\n  function isParentInit(path) {\n    path = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = '';\n    for (let i = 0; i < path.length; ++i) {\n      cur += (cur.length ? '.' : '') + path[i];\n      if (_this.$__.activePaths[cur] === 'init') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.getStatePaths('modify')),\n    default: Object.assign({}, this.$__.activePaths.getStatePaths('default'))\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.$errors;\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.$errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n\n  this.$__.validationError = this.$__.backup.validationError;\n  this.$errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @return {Array}\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function() {\n  const _this = this;\n  let all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n\n    let top = null;\n\n    const array = parentPaths(item.path);\n    for (let i = 0; i < array.length - 1; i++) {\n      if (allPaths.has(array[i])) {\n        top = allPaths.get(array[i]);\n        break;\n      }\n    }\n    if (top == null) {\n      minimal.push(item);\n    } else if (top != null &&\n        top[arrayAtomicsSymbol] != null &&\n        top.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being set.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top[arrayAtomicsSymbol] = {};\n      top[arrayAtomicsSymbol].$set = top;\n    }\n  });\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @return {Array}\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/DocumentArray */ \"(api)/../server/node_modules/mongoose/lib/types/DocumentArray/index.js\"));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return this.$__getValue(i);\n    }.bind(this))\n    .filter(function(val) {\n      return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function(doc) {\n      return doc;\n    });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @return {Array}\n * @api public\n * @method $getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/DocumentArray */ \"(api)/../server/node_modules/mongoose/lib/types/DocumentArray/index.js\"));\n  Embedded = Embedded || __webpack_require__(/*! ./types/ArraySubdocument */ \"(api)/../server/node_modules/mongoose/lib/types/ArraySubdocument.js\");\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && !Array.isArray(val) && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\n        return docReducer(val, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && utils.isMongooseDocumentArray(val)) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n    return seed;\n  }\n\n  const subDocs = [];\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.$listeners('error').length) {\n    this.$emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @return {Object}\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = this.constructor &&\n    this.constructor.base &&\n    this.constructor.base.options &&\n    get(this.constructor.base.options, path) || {};\n  const schemaOptions = this.$__schema && this.$__schema.options || {};\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = { ...defaultOptions, ...baseOptions, ...schemaOptions[path] };\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? { ...options } : {};\n  options._calledWithOptions = options._calledWithOptions || { ...options };\n\n  let _minimize;\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  let flattenMaps;\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  }\n\n  let flattenObjectIds;\n  if (options._calledWithOptions.flattenObjectIds != null) {\n    flattenObjectIds = options.flattenObjectIds;\n  } else if (defaultOptions.flattenObjectIds != null) {\n    flattenObjectIds = defaultOptions.flattenObjectIds;\n  } else {\n    flattenObjectIds = schemaOptions.flattenObjectIds;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign({}, options, {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps,\n    flattenObjectIds: flattenObjectIds,\n    _seen: (options && options._seen) || new Map()\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate ||\n    (options._parentOptions && options._parentOptions.depopulate || false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate the top-level document\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    return clone(this.$__.wasPopulated.value || this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = { ...defaultOptions, ...options };\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = false;\n\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = true;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || (options.getters && options.virtuals !== false)) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || (schemaOptions.toObject && transform)) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n *\n * Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html) for proper storage.\n *\n * #### Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](https://mongoosejs.com/docs/api/schema.html#Schema()) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * #### Transform:\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * #### Example:\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](https://mongoosejs.com/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](https://mongoosejs.com/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean|Object} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals. An object of the form `{ pathsToSkip: ['someVirtual'] }` may also be used to omit specific virtuals.\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.flattenObjectIds=false] if true, convert any ObjectIds in the result to 24 character hex strings.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object (not a POJO)\n * @see mongodb.Binary https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/**\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n * @api private\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isPOJO(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === 'boolean'\n    ? toObjectOptions.aliases\n    : true;\n\n  options = options || {};\n  let virtualsToApply = null;\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  } else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n\n  if (!cur) {\n    return json;\n  }\n\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    }\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substring(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n\n\n/**\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @param {Object} [options]\n * @return {Object} `json`\n * @api private\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n\n    const parts = path.split('.');\n\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      // If we've reached a non-object part of the branch, continuing would\n      // cause \"Cannot create property 'foo' on string 'bar'\" error.\n      // Necessary for mongoose-intl plugin re: gh-14446\n      if (branch != null && typeof branch !== 'object') {\n        break;\n      } else if (ii === last) {\n        const val = self.$get(path);\n        branch[part] = clone(val, options);\n        if (Array.isArray(branch[part]) && schema.paths[path].$embeddedSchemaType) {\n          for (let i = 0; i < branch[part].length; ++i) {\n            branch[part][i] = schema.paths[path].$embeddedSchemaType.applyGetters(\n              branch[part][i],\n              self\n            );\n          }\n        }\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n\n  return json;\n}\n\n/**\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n * @api private\n */\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null &&\n        typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const vals = [].concat(val);\n      const transform = schematype.$embeddedSchemaType.options.transform;\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).\n *\n * This method accepts the same options as [Document#toObject](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()). To apply the options to every document of your schema by default, set your [schemas](https://mongoosejs.com/docs/api/schema.html#Schema()) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true });\n *\n * There is one difference between `toJSON()` and `toObject()` options.\n * When you call `toJSON()`, the [`flattenMaps` option](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default.\n * When you call `toObject()`, the `flattenMaps` option is `false` by default.\n *\n * See [schema options](https://mongoosejs.com/docs/guide.html#toJSON) for more information on setting `toJSON` option defaults.\n *\n * @param {Object} options\n * @param {Boolean} [options.flattenMaps=true] if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.\n * @param {Boolean} [options.flattenObjectIds=false] if true, convert any ObjectIds in the result to 24 character hex strings.\n * @return {Object}\n * @see Document#toObject https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.ownerDocument = function() {\n  return this;\n};\n\n\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns the original document if there is no parent.\n *\n * @return {Document}\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.parent = function() {\n  if (this.$isSubdocument || this.$__.wasPopulated) {\n    return this.$__.parent;\n  }\n  return this;\n};\n\n/**\n * Alias for [`parent()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.parent()). If this document is a subdocument or populated\n * document, returns the document's parent. Returns `undefined` otherwise.\n *\n * @return {Document}\n * @api public\n * @method $parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$parent = Document.prototype.parent;\n\n/**\n * Helper for console.log\n *\n * @return {String}\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function(options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @return {String}\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function() {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\n * Returns true if this document is equal to another document.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} [doc] a document to compare. If falsy, will always return \"false\".\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};\n\n/**\n * Populates paths on an existing document.\n *\n * #### Example:\n *\n *     // Given a document, `populate()` lets you pull in referenced docs\n *     await doc.populate([\n *       'stories',\n *       { path: 'fans', sort: { name: -1 } }\n *     ]);\n *     doc.populated('stories'); // Array of ObjectIds\n *     doc.stories[0].title; // 'Casino Royale'\n *     doc.populated('fans'); // Array of ObjectIds\n *\n *     // If the referenced doc has been deleted, `populate()` will\n *     // remove that entry from the array.\n *     await Story.delete({ title: 'Casino Royale' });\n *     await doc.populate('stories'); // Empty array\n *\n *     // You can also pass additional query options to `populate()`,\n *     // like projections:\n *     await doc.populate('fans', '-email');\n *     doc.fans[0].email // undefined because of 2nd param `select`\n *\n * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [callback] Callback\n * @see population https://mongoosejs.com/docs/populate.html\n * @see Query#select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see Model.populate https://mongoosejs.com/docs/api/model.html#Model.populate()\n * @memberOf Document\n * @instance\n * @return {Promise|null} Returns a Promise if no `callback` is given.\n * @api public\n */\n\nDocument.prototype.populate = async function populate() {\n  const pop = {};\n  const args = [...arguments];\n  if (typeof args[args.length - 1] === 'function') {\n    throw new MongooseError('Document.prototype.populate() no longer accepts a callback');\n  }\n\n  if (args.length !== 0) {\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  const paths = utils.object.vals(pop);\n  let topLevelModel = this.constructor;\n  if (this.$__isNested) {\n    topLevelModel = this.$__[scopeSymbol].constructor;\n    const nestedPath = this.$__.nestedPath;\n    paths.forEach(function(populateOptions) {\n      populateOptions.path = nestedPath + '.' + populateOptions.path;\n    });\n  }\n\n  // Use `$session()` by default if the document has an associated session\n  // See gh-6754\n  if (this.$session() != null) {\n    const session = this.$session();\n    paths.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  paths.forEach(p => {\n    p._localModel = topLevelModel;\n  });\n\n  return topLevelModel.populate(this, paths);\n};\n\n/**\n * Gets all populated documents associated with this document.\n *\n * @api public\n * @return {Document[]} array of populated documents. Empty array if there are no populated documents associated with this document.\n * @memberOf Document\n * @method $getPopulatedDocs\n * @instance\n */\n\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n  let result = [];\n  for (const key of keys) {\n    const value = this.$get(key);\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * #### Example:\n *\n *     const doc = await Model.findOne().populate('author');\n *\n *     console.log(doc.author.name); // Dr.Seuss\n *     console.log(doc.populated('author')); // '5144cf8050f071d979c118a7'\n *\n * If the path was not populated, returns `undefined`.\n *\n * @param {String} path\n * @param {Any} [val]\n * @param {Object} [options]\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    if (typeof path !== 'string') {\n      return undefined;\n    }\n\n    // Map paths can be populated with either `path.$*` or just `path`\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n\n    const v = this.$__.populated[_path];\n    if (v) {\n      return val === true ? v : v.value;\n    }\n    return undefined;\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = { value: val, options: options };\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.$get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.$populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n\n  return val;\n};\n\n/**\n * Alias of [`.populated`](https://mongoosejs.com/docs/api/document.html#Document.prototype.populated()).\n *\n * @method $populated\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$populated = Document.prototype.populated;\n\n/**\n * Throws an error if a given path is not populated\n *\n * #### Example:\n *\n *     const doc = await Model.findOne().populate('author');\n *\n *     doc.$assertPopulated('author'); // does not throw\n *     doc.$assertPopulated('other path'); // throws an error\n *\n *     // Manually populate and assert in one call. The following does\n *     // `doc.$set({ likes })` before asserting.\n *     doc.$assertPopulated('likes', { likes });\n *\n *\n * @param {String|String[]} path path or array of paths to check. `$assertPopulated` throws if any of the given paths is not populated.\n * @param {Object} [values] optional values to `$set()`. Convenient if you want to manually populate a path and assert that the path was populated in 1 call.\n * @return {Document} this\n * @memberOf Document\n * @method $assertPopulated\n * @instance\n * @api public\n */\n\nDocument.prototype.$assertPopulated = function $assertPopulated(path, values) {\n  if (Array.isArray(path)) {\n    path.forEach(p => this.$assertPopulated(p, values));\n    return this;\n  }\n\n  if (arguments.length > 1) {\n    this.$set(values);\n  }\n\n  if (!this.$populated(path)) {\n    throw new MongooseError(`Expected path \"${path}\" to be populated`);\n  }\n\n  return this;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * #### Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\n *\n * @param {String|String[]} [path] Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.\n * @return {Document} this\n * @see Document.populate https://mongoosejs.com/docs/api/document.html#Document.prototype.populate()\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function(path) {\n  if (typeof path === 'string') {\n    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = this.$__ && this.$__.populated || {};\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.$populated(key);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.$populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.getChanges = function() {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n\n/**\n * Returns a copy of this document with a deep clone of `_doc` and `$__`.\n *\n * @return {Document} a copy of this document\n * @api public\n * @method $clone\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$clone = function() {\n  const Model = this.constructor;\n  const clonedDoc = new Model();\n  clonedDoc.$isNew = this.$isNew;\n  if (this._doc) {\n    clonedDoc._doc = clone(this._doc);\n  }\n  if (this.$__) {\n    const Cache = this.$__.constructor;\n    const clonedCache = new Cache();\n    for (const key of Object.getOwnPropertyNames(this.$__)) {\n      if (key === 'activePaths') {\n        continue;\n      }\n      clonedCache[key] = clone(this.$__[key]);\n    }\n    Object.assign(clonedCache.activePaths, clone({ ...this.$__.activePaths }));\n    clonedDoc.$__ = clonedCache;\n  }\n  return clonedDoc;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZG9jdW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiwwREFBOEI7QUFDbkQsc0JBQXNCLG1CQUFPLENBQUMseUVBQVk7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMsK0VBQWU7QUFDN0Msb0JBQW9CLG1CQUFPLENBQUMsaUZBQWdCO0FBQzVDLDRCQUE0QixtQkFBTyxDQUFDLGlHQUF3QjtBQUM1RCw2QkFBNkIsbUJBQU8sQ0FBQyxtR0FBeUI7QUFDOUQsOEJBQThCLG1CQUFPLENBQUMscUdBQTBCO0FBQ2hFLGVBQWUsbUJBQU8sQ0FBQyxxRUFBVTtBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQyxpRkFBZ0I7QUFDaEQsd0JBQXdCLG1CQUFPLENBQUMseUZBQW9CO0FBQ3BELHVCQUF1QixtQkFBTyxDQUFDLHVGQUFtQjtBQUNsRCwrQkFBK0IsbUJBQU8sQ0FBQyxxSUFBMEM7QUFDakYsc0JBQXNCLG1CQUFPLENBQUMscUhBQWtDO0FBQ2hFLDhCQUE4QixtQkFBTyxDQUFDLHFJQUEwQztBQUNoRixjQUFjLG1CQUFPLENBQUMsbUZBQWlCO0FBQ3ZDLGdCQUFnQix3SUFBNkM7QUFDN0Qsa0JBQWtCLDBJQUErQztBQUNqRSxnQkFBZ0Isb0hBQW1DO0FBQ25ELFlBQVksbUJBQU8sQ0FBQywrRUFBZTtBQUNuQyxxQ0FBcUMsbUJBQU8sQ0FBQyxtSkFBaUQ7QUFDOUYsNkJBQTZCLG1CQUFPLENBQUMsK0hBQXVDO0FBQzVFLGtDQUFrQyxtQkFBTyxDQUFDLHlJQUE0QztBQUN0Rix3QkFBd0IsbUJBQU8sQ0FBQyx5SEFBb0M7QUFDcEUsa0JBQWtCLG1CQUFPLENBQUMsMkZBQXFCO0FBQy9DLDZCQUE2QixtQkFBTyxDQUFDLHVJQUEyQztBQUNoRixvQkFBb0IsbUJBQU8sQ0FBQyxxSEFBa0M7QUFDOUQsZ0JBQWdCLGlEQUF1QjtBQUN2QyxnQ0FBZ0Msc0hBQTRD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGNBQWM7QUFDbEc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLGNBQWM7QUFDaEc7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQseUJBQXlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcZG9jdW1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgSW50ZXJuYWxDYWNoZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2luZGV4Jyk7XG5jb25zdCBNaXhlZFNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL21peGVkJyk7XG5jb25zdCBPYmplY3RFeHBlY3RlZEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9vYmplY3RFeHBlY3RlZCcpO1xuY29uc3QgT2JqZWN0UGFyYW1ldGVyRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL29iamVjdFBhcmFtZXRlcicpO1xuY29uc3QgUGFyYWxsZWxWYWxpZGF0ZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9wYXJhbGxlbFZhbGlkYXRlJyk7XG5jb25zdCBTY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYScpO1xuY29uc3QgU3RyaWN0TW9kZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9zdHJpY3QnKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvdmFsaWRhdGlvbicpO1xuY29uc3QgVmFsaWRhdG9yRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3ZhbGlkYXRvcicpO1xuY29uc3QgJF9faGFzSW5jbHVkZWRDaGlsZHJlbiA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2hhc0luY2x1ZGVkQ2hpbGRyZW4nKTtcbmNvbnN0IGFwcGx5RGVmYXVsdHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvYXBwbHlEZWZhdWx0cycpO1xuY29uc3QgY2xlYW5Nb2RpZmllZFN1YnBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RvY3VtZW50L2NsZWFuTW9kaWZpZWRTdWJwYXRocycpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGNvbXBpbGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvY29tcGlsZScpLmNvbXBpbGU7XG5jb25zdCBkZWZpbmVLZXkgPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvY29tcGlsZScpLmRlZmluZUtleTtcbmNvbnN0IGZsYXR0ZW4gPSByZXF1aXJlKCcuL2hlbHBlcnMvY29tbW9uJykuZmxhdHRlbjtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXQnKTtcbmNvbnN0IGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGggPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aCcpO1xuY29uc3QgZ2V0S2V5c0luU2NoZW1hT3JkZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hL2dldEtleXNJblNjaGVtYU9yZGVyJyk7XG5jb25zdCBnZXRTdWJkb2N1bWVudFN0cmljdFZhbHVlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9nZXRTdWJkb2N1bWVudFN0cmljdFZhbHVlJyk7XG5jb25zdCBoYW5kbGVTcHJlYWREb2MgPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvaGFuZGxlU3ByZWFkRG9jJyk7XG5jb25zdCBpbW1lZGlhdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaW1tZWRpYXRlJyk7XG5jb25zdCBpc0RlZmluaW5nUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzRGVmaW5pbmdQcm9qZWN0aW9uJyk7XG5jb25zdCBpc0V4Y2x1c2l2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzRXhjbHVzaXZlJyk7XG5jb25zdCBpbnNwZWN0ID0gcmVxdWlyZSgndXRpbCcpLmluc3BlY3Q7XG5jb25zdCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9ucycpLmludGVybmFsVG9PYmplY3RPcHRpb25zO1xuY29uc3QgbWFya0FycmF5U3ViZG9jc1BvcHVsYXRlZCA9IHJlcXVpcmUoJy4vaGVscGVycy9wb3B1bGF0ZS9tYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkJyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5jb25zdCBxdWVyeWhlbHBlcnMgPSByZXF1aXJlKCcuL3F1ZXJ5aGVscGVycycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBpc1Byb21pc2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQcm9taXNlJyk7XG5cbmNvbnN0IGRlZXBFcXVhbCA9IHV0aWxzLmRlZXBFcXVhbDtcbmNvbnN0IGlzTW9uZ29vc2VPYmplY3QgPSB1dGlscy5pc01vbmdvb3NlT2JqZWN0O1xuXG5jb25zdCBhcnJheUF0b21pY3NCYWNrdXBTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc0JhY2t1cFN5bWJvbDtcbmNvbnN0IGFycmF5QXRvbWljc1N5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzU3ltYm9sO1xuY29uc3QgZG9jdW1lbnRBcnJheVBhcmVudCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRBcnJheVBhcmVudDtcbmNvbnN0IGRvY3VtZW50SXNNb2RpZmllZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRJc01vZGlmaWVkO1xuY29uc3QgZG9jdW1lbnRNb2RpZmllZFBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS5kb2N1bWVudE1vZGlmaWVkUGF0aHM7XG5jb25zdCBkb2N1bWVudFNjaGVtYVN5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRTY2hlbWFTeW1ib2w7XG5jb25zdCBnZXRTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmdldFN5bWJvbDtcbmNvbnN0IHBvcHVsYXRlTW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnBvcHVsYXRlTW9kZWxTeW1ib2w7XG5jb25zdCBzY29wZVN5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuc2NvcGVTeW1ib2w7XG5jb25zdCBzY2hlbWFNaXhlZFN5bWJvbCA9IHJlcXVpcmUoJy4vc2NoZW1hL3N5bWJvbHMnKS5zY2hlbWFNaXhlZFN5bWJvbDtcbmNvbnN0IHBhcmVudFBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BhdGgvcGFyZW50UGF0aHMnKTtcbmNvbnN0IGdldERlZXBlc3RTdWJkb2N1bWVudEZvclBhdGggPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvZ2V0RGVlcGVzdFN1YmRvY3VtZW50Rm9yUGF0aCcpO1xuY29uc3Qgc2Vzc2lvbk5ld0RvY3VtZW50cyA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuc2Vzc2lvbk5ld0RvY3VtZW50cztcblxubGV0IERvY3VtZW50QXJyYXk7XG5sZXQgTW9uZ29vc2VBcnJheTtcbmxldCBFbWJlZGRlZDtcblxuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSB1dGlscy5zcGVjaWFsUHJvcGVydGllcztcblxuLyoqXG4gKiBUaGUgY29yZSBNb25nb29zZSBkb2N1bWVudCBjb25zdHJ1Y3Rvci4gWW91IHNob3VsZCBub3QgY2FsbCB0aGlzIGRpcmVjdGx5LFxuICogdGhlIE1vbmdvb3NlIFtNb2RlbCBjb25zdHJ1Y3Rvcl0oLi9hcGkvbW9kZWwuaHRtbCNNb2RlbCkgY2FsbHMgdGhpcyBmb3IgeW91LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIHZhbHVlcyB0byBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmllbGRzXSBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyB0aGUgZmllbGRzIHdoaWNoIHdlcmUgc2VsZWN0ZWQgaW4gdGhlIHF1ZXJ5IHJldHVybmluZyB0aGlzIGRvY3VtZW50IGFuZCBhbnkgcG9wdWxhdGVkIHBhdGhzIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdmFyaW91cyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kZWZhdWx0cz10cnVlXSBpZiBgZmFsc2VgLCBza2lwIGFwcGx5aW5nIGRlZmF1bHQgdmFsdWVzIHRvIHRoaXMgZG9jdW1lbnQuXG4gKiBAaW5oZXJpdHMgTm9kZUpTIEV2ZW50RW1pdHRlciBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2NsYXNzLWV2ZW50ZW1pdHRlclxuICogQGV2ZW50IGBpbml0YDogRW1pdHRlZCBvbiBhIGRvY3VtZW50IGFmdGVyIGl0IGhhcyBiZWVuIHJldHJpZXZlZCBmcm9tIHRoZSBkYiBhbmQgZnVsbHkgaHlkcmF0ZWQgYnkgTW9uZ29vc2UuXG4gKiBAZXZlbnQgYHNhdmVgOiBFbWl0dGVkIHdoZW4gdGhlIGRvY3VtZW50IGlzIHN1Y2Nlc3NmdWxseSBzYXZlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gRG9jdW1lbnQob2JqLCBmaWVsZHMsIHNraXBJZCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHNraXBJZCA9PT0gJ29iamVjdCcgJiYgc2tpcElkICE9IG51bGwpIHtcbiAgICBvcHRpb25zID0gc2tpcElkO1xuICAgIHNraXBJZCA9IG9wdGlvbnMuc2tpcElkO1xuICB9XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAvLyBTdXBwb3J0IGBicm93c2VyRG9jdW1lbnQuanNgIHN5bnRheFxuICBpZiAodGhpcy4kX19zY2hlbWEgPT0gbnVsbCkge1xuICAgIGNvbnN0IF9zY2hlbWEgPSB1dGlscy5pc09iamVjdChmaWVsZHMpICYmICFmaWVsZHMuaW5zdGFuY2VPZlNjaGVtYSA/XG4gICAgICBuZXcgU2NoZW1hKGZpZWxkcykgOlxuICAgICAgZmllbGRzO1xuICAgIHRoaXMuJF9fc2V0U2NoZW1hKF9zY2hlbWEpO1xuICAgIGZpZWxkcyA9IHNraXBJZDtcbiAgICBza2lwSWQgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbNF0gfHwge307XG4gIH1cblxuICB0aGlzLiRfXyA9IG5ldyBJbnRlcm5hbENhY2hlKCk7XG5cbiAgLy8gQXZvaWQgc2V0dGluZyBgaXNOZXdgIHRvIGB0cnVlYCwgYmVjYXVzZSBpdCBpcyBgdHJ1ZWAgYnkgZGVmYXVsdFxuICBpZiAob3B0aW9ucy5pc05ldyAhPSBudWxsICYmIG9wdGlvbnMuaXNOZXcgIT09IHRydWUpIHtcbiAgICB0aGlzLiRpc05ldyA9IG9wdGlvbnMuaXNOZXc7XG4gIH1cblxuICBpZiAob3B0aW9ucy5wcmlvckRvYyAhPSBudWxsKSB7XG4gICAgdGhpcy4kX18ucHJpb3JEb2MgPSBvcHRpb25zLnByaW9yRG9jO1xuICB9XG5cbiAgaWYgKHNraXBJZCkge1xuICAgIHRoaXMuJF9fLnNraXBJZCA9IHNraXBJZDtcbiAgfVxuXG4gIGlmIChvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihvYmosICdvYmonLCAnRG9jdW1lbnQnKTtcbiAgfVxuXG4gIGxldCBkZWZhdWx0cyA9IHRydWU7XG4gIGlmIChvcHRpb25zLmRlZmF1bHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLiRfXy5kZWZhdWx0cyA9IG9wdGlvbnMuZGVmYXVsdHM7XG4gICAgZGVmYXVsdHMgPSBvcHRpb25zLmRlZmF1bHRzO1xuICB9XG5cbiAgY29uc3Qgc2NoZW1hID0gdGhpcy4kX19zY2hlbWE7XG5cbiAgaWYgKHR5cGVvZiBmaWVsZHMgPT09ICdib29sZWFuJyB8fCBmaWVsZHMgPT09ICd0aHJvdycpIHtcbiAgICBpZiAoZmllbGRzICE9PSB0cnVlKSB7XG4gICAgICB0aGlzLiRfXy5zdHJpY3RNb2RlID0gZmllbGRzO1xuICAgIH1cbiAgICBmaWVsZHMgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLm9wdGlvbnMuc3RyaWN0ICE9PSB0cnVlKSB7XG4gICAgdGhpcy4kX18uc3RyaWN0TW9kZSA9IHNjaGVtYS5vcHRpb25zLnN0cmljdDtcbiAgfVxuXG4gIGNvbnN0IHJlcXVpcmVkUGF0aHMgPSBzY2hlbWEucmVxdWlyZWRQYXRocyh0cnVlKTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIHJlcXVpcmVkUGF0aHMpIHtcbiAgICB0aGlzLiRfXy5hY3RpdmVQYXRocy5yZXF1aXJlKHBhdGgpO1xuICB9XG5cbiAgbGV0IGV4Y2x1ZGUgPSBudWxsO1xuXG4gIC8vIGRldGVybWluZSBpZiB0aGlzIGRvYyBpcyBhIHJlc3VsdCBvZiBhIHF1ZXJ5IHdpdGhcbiAgLy8gZXhjbHVkZWQgZmllbGRzXG4gIGlmICh1dGlscy5pc1BPSk8oZmllbGRzKSAmJiBPYmplY3Qua2V5cyhmaWVsZHMpLmxlbmd0aCA+IDApIHtcbiAgICBleGNsdWRlID0gaXNFeGNsdXNpdmUoZmllbGRzKTtcbiAgICB0aGlzLiRfXy5zZWxlY3RlZCA9IGZpZWxkcztcbiAgICB0aGlzLiRfXy5leGNsdWRlID0gZXhjbHVkZTtcbiAgfVxuXG4gIGNvbnN0IGhhc0luY2x1ZGVkQ2hpbGRyZW4gPSBleGNsdWRlID09PSBmYWxzZSAmJiBmaWVsZHMgP1xuICAgICRfX2hhc0luY2x1ZGVkQ2hpbGRyZW4oZmllbGRzKSA6XG4gICAgbnVsbDtcblxuICBpZiAodGhpcy5fZG9jID09IG51bGwpIHtcbiAgICB0aGlzLiRfX2J1aWxkRG9jKG9iaiwgZmllbGRzLCBza2lwSWQsIGV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIGZhbHNlKTtcblxuICAgIC8vIEJ5IGRlZmF1bHQsIGRlZmF1bHRzIGdldCBhcHBsaWVkICoqYmVmb3JlKiogc2V0dGluZyBpbml0aWFsIHZhbHVlc1xuICAgIC8vIFJlOiBnaC02MTU1XG4gICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICBhcHBseURlZmF1bHRzKHRoaXMsIGZpZWxkcywgZXhjbHVkZSwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgdHJ1ZSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGlmIChvYmopIHtcbiAgICAvLyBTa2lwIHNldCBob29rc1xuICAgIGlmICh0aGlzLiRfX29yaWdpbmFsX3NldCkge1xuICAgICAgdGhpcy4kX19vcmlnaW5hbF9zZXQob2JqLCB1bmRlZmluZWQsIHRydWUsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRzZXQob2JqLCB1bmRlZmluZWQsIHRydWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgdGhpcy4kaXNOZXcgPSBvYmouJGlzTmV3O1xuICAgIH1cbiAgfVxuXG4gIC8vIEZ1bmN0aW9uIGRlZmF1bHRzIGdldCBhcHBsaWVkICoqYWZ0ZXIqKiBzZXR0aW5nIGluaXRpYWwgdmFsdWVzIHNvIHRoZXlcbiAgLy8gc2VlIHRoZSBmdWxsIGRvYyByYXRoZXIgdGhhbiBhbiBlbXB0eSBvbmUsIHVubGVzcyB0aGV5IG9wdCBvdXQuXG4gIC8vIFJlOiBnaC0zNzgxLCBnaC02MTU1XG4gIGlmIChvcHRpb25zLndpbGxJbml0ICYmIGRlZmF1bHRzKSB7XG4gICAgaWYgKG9wdGlvbnMuc2tpcERlZmF1bHRzKSB7XG4gICAgICB0aGlzLiRfXy5za2lwRGVmYXVsdHMgPSBvcHRpb25zLnNraXBEZWZhdWx0cztcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMpIHtcbiAgICBhcHBseURlZmF1bHRzKHRoaXMsIGZpZWxkcywgZXhjbHVkZSwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgZmFsc2UsIG9wdGlvbnMuc2tpcERlZmF1bHRzKTtcbiAgfVxuXG4gIGlmICghdGhpcy4kX18uc3RyaWN0TW9kZSAmJiBvYmopIHtcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2RvYyk7XG5cbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAvLyBBdm9pZCBtZXRob2RzLCB2aXJ0dWFscywgZXhpc3RpbmcgZmllbGRzLCBhbmQgYCRgIGtleXMuIFRoZSBsYXR0ZXIgaXMgdG8gYXZvaWQgb3ZlcndyaXRpbmdcbiAgICAgIC8vIE1vbmdvb3NlIGludGVybmFscy5cbiAgICAgIGlmICghKGtleSBpbiBzY2hlbWEudHJlZSkgJiYgIShrZXkgaW4gc2NoZW1hLm1ldGhvZHMpICYmICEoa2V5IGluIHNjaGVtYS52aXJ0dWFscykgJiYgIWtleS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgZGVmaW5lS2V5KHsgcHJvcDoga2V5LCBzdWJwcm9wczogbnVsbCwgcHJvdG90eXBlOiBfdGhpcyB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFwcGx5UXVldWUodGhpcyk7XG59XG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNNb25nb29zZURvY3VtZW50UHJvdG90eXBlID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGZsYWcgc3BlY2lmeWluZyBpZiB0aGUgZG9jdW1lbnQgaXMgbmV3LiBJZiB5b3UgY3JlYXRlIGEgZG9jdW1lbnRcbiAqIHVzaW5nIGBuZXdgLCB0aGlzIGRvY3VtZW50IHdpbGwgYmUgY29uc2lkZXJlZCBcIm5ld1wiLiBgJGlzTmV3YCBpcyBob3dcbiAqIE1vbmdvb3NlIGRldGVybWluZXMgd2hldGhlciBgc2F2ZSgpYCBzaG91bGQgdXNlIGBpbnNlcnRPbmUoKWAgdG8gY3JlYXRlXG4gKiBhIG5ldyBkb2N1bWVudCBvciBgdXBkYXRlT25lKClgIHRvIHVwZGF0ZSBhbiBleGlzdGluZyBkb2N1bWVudC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcih7IG5hbWU6ICdKb2huIFNtaXRoJyB9KTtcbiAqICAgICB1c2VyLiRpc05ldzsgLy8gdHJ1ZVxuICpcbiAqICAgICBhd2FpdCB1c2VyLnNhdmUoKTsgLy8gU2VuZHMgYW4gYGluc2VydE9uZWAgdG8gTW9uZ29EQlxuICpcbiAqIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB5b3UgbG9hZCBhbiBleGlzdGluZyBkb2N1bWVudCBmcm9tIHRoZSBkYXRhYmFzZVxuICogdXNpbmcgYGZpbmRPbmUoKWAgb3IgYW5vdGhlciBbcXVlcnkgb3BlcmF0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sKSxcbiAqIGAkaXNOZXdgIHdpbGwgYmUgZmFsc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlci5maW5kT25lKHsgbmFtZTogJ0pvaG4gU21pdGgnIH0pO1xuICogICAgIHVzZXIuJGlzTmV3OyAvLyBmYWxzZVxuICpcbiAqIE1vbmdvb3NlIHNldHMgYCRpc05ld2AgdG8gYGZhbHNlYCBpbW1lZGlhdGVseSBhZnRlciBgc2F2ZSgpYCBzdWNjZWVkcy5cbiAqIFRoYXQgbWVhbnMgTW9uZ29vc2Ugc2V0cyBgJGlzTmV3YCB0byBmYWxzZSAqKmJlZm9yZSoqIGBwb3N0KCdzYXZlJylgIGhvb2tzIHJ1bi5cbiAqIEluIGBwb3N0KCdzYXZlJylgIGhvb2tzLCBgJGlzTmV3YCB3aWxsIGJlIGBmYWxzZWAgaWYgYHNhdmUoKWAgc3VjY2VlZGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgdXNlclNjaGVtYS5wb3N0KCdzYXZlJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLiRpc05ldzsgLy8gZmFsc2VcbiAqICAgICB9KTtcbiAqICAgICBhd2FpdCBVc2VyLmNyZWF0ZSh7IG5hbWU6ICdKb2huIFNtaXRoJyB9KTtcbiAqXG4gKiBGb3Igc3ViZG9jdW1lbnRzLCBgJGlzTmV3YCBpcyB0cnVlIGlmIGVpdGhlciB0aGUgcGFyZW50IGhhcyBgJGlzTmV3YCBzZXQsXG4gKiBvciBpZiB5b3UgY3JlYXRlIGEgbmV3IHN1YmRvY3VtZW50LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQXNzdW1lIGBHcm91cGAgaGFzIGEgZG9jdW1lbnQgYXJyYXkgYHVzZXJzYFxuICogICAgIGNvbnN0IGdyb3VwID0gYXdhaXQgR3JvdXAuZmluZE9uZSgpO1xuICogICAgIGdyb3VwLnVzZXJzWzBdLiRpc05ldzsgLy8gZmFsc2VcbiAqXG4gKiAgICAgZ3JvdXAudXNlcnMucHVzaCh7IG5hbWU6ICdKb2huIFNtaXRoJyB9KTtcbiAqICAgICBncm91cC51c2Vyc1sxXS4kaXNOZXc7IC8vIHRydWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5ICRpc05ld1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnQucHJvdG90eXBlLCAnaXNOZXcnLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGlzTmV3O1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy4kaXNOZXcgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbi8qKlxuICogSGFzaCBjb250YWluaW5nIGN1cnJlbnQgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBlcnJvcnNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY3VtZW50LnByb3RvdHlwZSwgJ2Vycm9ycycsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4kZXJyb3JzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy4kZXJyb3JzID0gdmFsdWU7XG4gIH1cbn0pO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNOZXcgPSB0cnVlO1xuXG4vKiFcbiAqIERvY3VtZW50IGV4cG9zZXMgdGhlIE5vZGVKUyBldmVudCBlbWl0dGVyIEFQSSwgc28geW91IGNhbiB1c2VcbiAqIGBvbmAsIGBvbmNlYCwgZXRjLlxuICovXG51dGlscy5lYWNoKFxuICBbJ29uJywgJ29uY2UnLCAnZW1pdCcsICdsaXN0ZW5lcnMnLCAncmVtb3ZlTGlzdGVuZXInLCAnc2V0TWF4TGlzdGVuZXJzJyxcbiAgICAncmVtb3ZlQWxsTGlzdGVuZXJzJywgJ2FkZExpc3RlbmVyJ10sXG4gIGZ1bmN0aW9uKGVtaXR0ZXJGbikge1xuICAgIERvY3VtZW50LnByb3RvdHlwZVtlbWl0dGVyRm5dID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEZWxheSBjcmVhdGluZyBlbWl0dGVyIHVudGlsIG5lY2Vzc2FyeSBiZWNhdXNlIGVtaXR0ZXJzIHRha2UgdXAgYSBsb3Qgb2YgbWVtb3J5LFxuICAgICAgLy8gZXNwZWNpYWxseSBmb3Igc3ViZG9jdW1lbnRzLlxuICAgICAgaWYgKCF0aGlzLiRfXy5lbWl0dGVyKSB7XG4gICAgICAgIGlmIChlbWl0dGVyRm4gPT09ICdlbWl0Jykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRfXy5lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLiRfXy5lbWl0dGVyLnNldE1heExpc3RlbmVycygwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiRfXy5lbWl0dGVyW2VtaXR0ZXJGbl0uYXBwbHkodGhpcy4kX18uZW1pdHRlciwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZVtgJCR7ZW1pdHRlckZufWBdID0gRG9jdW1lbnQucHJvdG90eXBlW2VtaXR0ZXJGbl07XG4gIH0pO1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEb2N1bWVudDtcblxuZm9yIChjb25zdCBpIGluIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpIHtcbiAgRG9jdW1lbnRbaV0gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlW2ldO1xufVxuXG4vKipcbiAqIFRoZSBkb2N1bWVudCdzIGludGVybmFsIHNjaGVtYS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBwcm9wZXJ0eSBzY2hlbWFcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3NjaGVtYTtcblxuLyoqXG4gKiBUaGUgZG9jdW1lbnQncyBzY2hlbWEuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBzY2hlbWFcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnNjaGVtYTtcblxuLyoqXG4gKiBFbXB0eSBvYmplY3QgdGhhdCB5b3UgY2FuIHVzZSBmb3Igc3RvcmluZyBwcm9wZXJ0aWVzIG9uIHRoZSBkb2N1bWVudC4gVGhpc1xuICogaXMgaGFuZHkgZm9yIHBhc3NpbmcgZGF0YSB0byBtaWRkbGV3YXJlIHdpdGhvdXQgY29uZmxpY3Rpbmcgd2l0aCBNb25nb29zZVxuICogaW50ZXJuYWxzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLnByZSgnc2F2ZScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgLy8gTW9uZ29vc2Ugd2lsbCBzZXQgYGlzTmV3YCB0byBgZmFsc2VgIGlmIGBzYXZlKClgIHN1Y2NlZWRzXG4gKiAgICAgICB0aGlzLiRsb2NhbHMud2FzTmV3ID0gdGhpcy5pc05ldztcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgc2NoZW1hLnBvc3QoJ3NhdmUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIC8vIFByaW50cyB0cnVlIGlmIGBpc05ld2Agd2FzIHNldCBiZWZvcmUgYHNhdmUoKWBcbiAqICAgICAgIGNvbnNvbGUubG9nKHRoaXMuJGxvY2Fscy53YXNOZXcpO1xuICogICAgIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJGxvY2Fsc1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnQucHJvdG90eXBlLCAnJGxvY2FscycsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuJF9fLmxvY2FscyA9PSBudWxsKSB7XG4gICAgICB0aGlzLiRfXy5sb2NhbHMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJF9fLmxvY2FscztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgdGhpcy4kX18ubG9jYWxzID0gdjtcbiAgfVxufSk7XG5cbi8qKlxuICogTGVnYWN5IGFsaWFzIGZvciBgJGlzTmV3YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGlzTmV3XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBzZWUgJGlzTmV3IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuJGlzTmV3XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaXNOZXc7XG5cbi8qKlxuICogU2V0IHRoaXMgcHJvcGVydHkgdG8gYWRkIGFkZGl0aW9uYWwgcXVlcnkgZmlsdGVycyB3aGVuIE1vbmdvb3NlIHNhdmVzIHRoaXMgZG9jdW1lbnQgYW5kIGBpc05ld2AgaXMgZmFsc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIHN1cmUgYHNhdmUoKWAgbmV2ZXIgdXBkYXRlcyBhIHNvZnQgZGVsZXRlZCBkb2N1bWVudC5cbiAqICAgICBzY2hlbWEucHJlKCdzYXZlJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLiR3aGVyZSA9IHsgaXNEZWxldGVkOiBmYWxzZSB9O1xuICogICAgIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJHdoZXJlXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2N1bWVudC5wcm90b3R5cGUsICckd2hlcmUnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogVGhlIHN0cmluZyB2ZXJzaW9uIG9mIHRoaXMgZG9jdW1lbnRzIF9pZC5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogVGhpcyBnZXR0ZXIgZXhpc3RzIG9uIGFsbCBkb2N1bWVudHMgYnkgZGVmYXVsdC4gVGhlIGdldHRlciBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyB0aGUgYGlkYCBbb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNpZCkgb2YgaXRzIGBTY2hlbWFgIHRvIGZhbHNlIGF0IGNvbnN0cnVjdGlvbiB0aW1lLlxuICpcbiAqICAgICBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgaWQ6IGZhbHNlIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIFNjaGVtYSBvcHRpb25zIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI29wdGlvbnNcbiAqIEBwcm9wZXJ0eSBpZFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaWQ7XG5cbi8qKlxuICogSGFzaCBjb250YWluaW5nIGN1cnJlbnQgdmFsaWRhdGlvbiAkZXJyb3JzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJGVycm9yc1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGVycm9ycztcblxuLyoqXG4gKiBBIHN0cmluZyBjb250YWluaW5nIHRoZSBjdXJyZW50IG9wZXJhdGlvbiB0aGF0IE1vbmdvb3NlIGlzIGV4ZWN1dGluZ1xuICogb24gdGhpcyBkb2N1bWVudC4gTWF5IGJlIGBudWxsYCwgYCdzYXZlJ2AsIGAndmFsaWRhdGUnYCwgb3IgYCdyZW1vdmUnYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7IG5hbWU6ICd0ZXN0JyB9KTtcbiAqICAgICBkb2MuJG9wOyAvLyBudWxsXG4gKlxuICogICAgIGNvbnN0IHByb21pc2UgPSBkb2Muc2F2ZSgpO1xuICogICAgIGRvYy4kb3A7IC8vICdzYXZlJ1xuICpcbiAqICAgICBhd2FpdCBwcm9taXNlO1xuICogICAgIGRvYy4kb3A7IC8vIG51bGxcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5ICRvcFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnQucHJvdG90eXBlLCAnJG9wJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiRfXy5vcCB8fCBudWxsO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy4kX18ub3AgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gJGFwcGx5RGVmYXVsdHNUb05lc3RlZCh2YWwsIHBhdGgsIGRvYykge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKGRvYy4kX19zY2hlbWEucGF0aHMpO1xuICBjb25zdCBwbGVuID0gcGF0aHMubGVuZ3RoO1xuXG4gIGNvbnN0IHBhdGhQaWVjZXMgPSBwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcuJyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGVuOyArK2kpIHtcbiAgICBsZXQgY3VyUGF0aCA9ICcnO1xuICAgIGNvbnN0IHAgPSBwYXRoc1tpXTtcblxuICAgIGlmICghcC5zdGFydHNXaXRoKHBhdGggKyAnLicpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gZG9jLiRfX3NjaGVtYS5wYXRoc1twXTtcbiAgICBjb25zdCBwaWVjZXMgPSB0eXBlLnNwbGl0UGF0aCgpLnNsaWNlKHBhdGhQaWVjZXMubGVuZ3RoKTtcbiAgICBjb25zdCBsZW4gPSBwaWVjZXMubGVuZ3RoO1xuXG4gICAgaWYgKHR5cGUuZGVmYXVsdFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBjdXIgPSB2YWw7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICBpZiAoY3VyID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBpZWNlID0gcGllY2VzW2pdO1xuXG4gICAgICBpZiAoaiA9PT0gbGVuIC0gMSkge1xuICAgICAgICBpZiAoY3VyW3BpZWNlXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRlZiA9IHR5cGUuZ2V0RGVmYXVsdChkb2MsIGZhbHNlKTtcbiAgICAgICAgICBpZiAoZGVmICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGN1cltwaWVjZV0gPSBkZWY7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBkb2MuaW52YWxpZGF0ZShwYXRoICsgJy4nICsgY3VyUGF0aCwgZXJyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjdXJQYXRoICs9ICghY3VyUGF0aC5sZW5ndGggPyAnJyA6ICcuJykgKyBwaWVjZTtcblxuICAgICAgY3VyW3BpZWNlXSA9IGN1cltwaWVjZV0gfHwge307XG4gICAgICBjdXIgPSBjdXJbcGllY2VdO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBkb2Mgc3RydWN0dXJlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtPYmplY3R9IFtmaWVsZHNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwSWRdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtleGNsdWRlXVxuICogQHBhcmFtIHtPYmplY3R9IFtoYXNJbmNsdWRlZENoaWxkcmVuXVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX2J1aWxkRG9jXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19idWlsZERvYyA9IGZ1bmN0aW9uKG9iaiwgZmllbGRzLCBza2lwSWQsIGV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4pIHtcbiAgY29uc3QgZG9jID0ge307XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLiRfX3NjaGVtYS5wYXRocykuXG4gICAgLy8gRG9uJ3QgYnVpbGQgdXAgYW55IHBhdGhzIHRoYXQgYXJlIHVuZGVybmVhdGggYSBtYXAsIHdlIGRvbid0IGtub3dcbiAgICAvLyB3aGF0IHRoZSBrZXlzIHdpbGwgYmVcbiAgICBmaWx0ZXIocCA9PiAhcC5pbmNsdWRlcygnJConKSk7XG4gIGNvbnN0IHBsZW4gPSBwYXRocy5sZW5ndGg7XG4gIGxldCBpaSA9IDA7XG5cbiAgZm9yICg7IGlpIDwgcGxlbjsgKytpaSkge1xuICAgIGNvbnN0IHAgPSBwYXRoc1tpaV07XG5cbiAgICBpZiAocCA9PT0gJ19pZCcpIHtcbiAgICAgIGlmIChza2lwSWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAob2JqICYmICdfaWQnIGluIG9iaikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYXRoID0gdGhpcy4kX19zY2hlbWEucGF0aHNbcF0uc3BsaXRQYXRoKCk7XG4gICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgY29uc3QgbGFzdCA9IGxlbiAtIDE7XG4gICAgbGV0IGN1clBhdGggPSAnJztcbiAgICBsZXQgZG9jXyA9IGRvYztcbiAgICBsZXQgaW5jbHVkZWQgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHBpZWNlID0gcGF0aFtpXTtcblxuICAgICAgaWYgKCFjdXJQYXRoLmxlbmd0aCkge1xuICAgICAgICBjdXJQYXRoID0gcGllY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJQYXRoICs9ICcuJyArIHBpZWNlO1xuICAgICAgfVxuXG4gICAgICAvLyBzdXBwb3J0IGV4Y2x1ZGluZyBpbnRlcm1lZGlhcnkgbGV2ZWxzXG4gICAgICBpZiAoZXhjbHVkZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoY3VyUGF0aCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGNsdWRlID09PSBmYWxzZSAmJiBmaWVsZHMgJiYgIWluY2x1ZGVkKSB7XG4gICAgICAgIGlmIChjdXJQYXRoIGluIGZpZWxkcykge1xuICAgICAgICAgIGluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghaGFzSW5jbHVkZWRDaGlsZHJlbltjdXJQYXRoXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgbGFzdCkge1xuICAgICAgICBkb2NfID0gZG9jX1twaWVjZV0gfHwgKGRvY19bcGllY2VdID0ge30pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2RvYyA9IGRvYztcbn07XG5cbi8qIVxuICogQ29udmVydHMgdG8gUE9KTyB3aGVuIHlvdSB1c2UgdGhlIGRvY3VtZW50IGZvciBxdWVyeWluZ1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS50b0JTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgZG9jdW1lbnQgd2l0aG91dCBzZXR0ZXJzIG9yIG1hcmtpbmcgYW55dGhpbmcgbW9kaWZpZWQuXG4gKlxuICogQ2FsbGVkIGludGVybmFsbHkgYWZ0ZXIgYSBkb2N1bWVudCBpcyByZXR1cm5lZCBmcm9tIG1vbmdvZGIuIE5vcm1hbGx5LFxuICogeW91IGRvICoqbm90KiogbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gb24geW91ciBvd24uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyBgaW5pdGAgW21pZGRsZXdhcmVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWwpLlxuICogTm90ZSB0aGF0IGBpbml0YCBob29rcyBhcmUgW3N5bmNocm9ub3VzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbWlkZGxld2FyZS5odG1sI3N5bmNocm9ub3VzKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIGRvY3VtZW50IHJldHVybmVkIGJ5IG1vbmdvXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGRvYywgb3B0cywgZm4pIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBvcHRzO1xuICAgIG9wdHMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy4kX19pbml0KGRvYywgb3B0cyk7XG5cbiAgaWYgKGZuKSB7XG4gICAgZm4obnVsbCwgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIFtgLmluaXRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLmluaXQoKSlcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaW5pdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBcImluaXRcIiBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICogQHJldHVybnMge0RvY3VtZW50fSB0aGlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9faW5pdCA9IGZ1bmN0aW9uKGRvYywgb3B0cykge1xuICB0aGlzLiRpc05ldyA9IGZhbHNlO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAvLyBoYW5kbGUgZG9jcyB3aXRoIHBvcHVsYXRlZCBwYXRoc1xuICAvLyBJZiBkb2MuX2lkIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICBpZiAoZG9jLl9pZCAhPSBudWxsICYmIG9wdHMucG9wdWxhdGVkICYmIG9wdHMucG9wdWxhdGVkLmxlbmd0aCkge1xuICAgIGNvbnN0IGlkID0gU3RyaW5nKGRvYy5faWQpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBvcHRzLnBvcHVsYXRlZCkge1xuICAgICAgaWYgKGl0ZW0uaXNWaXJ0dWFsKSB7XG4gICAgICAgIHRoaXMuJHBvcHVsYXRlZChpdGVtLnBhdGgsIHV0aWxzLmdldFZhbHVlKGl0ZW0ucGF0aCwgZG9jKSwgaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRwb3B1bGF0ZWQoaXRlbS5wYXRoLCBpdGVtLl9kb2NzW2lkXSwgaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtLl9jaGlsZERvY3MgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaXRlbS5fY2hpbGREb2NzKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PSBudWxsIHx8IGNoaWxkLiRfXyA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQuJF9fLnBhcmVudCA9IHRoaXM7XG4gICAgICB9XG4gICAgICBpdGVtLl9jaGlsZERvY3MgPSBbXTtcbiAgICB9XG4gIH1cblxuICBpbml0KHRoaXMsIGRvYywgdGhpcy5fZG9jLCBvcHRzKTtcblxuICBtYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkKHRoaXMsIG9wdHMucG9wdWxhdGVkKTtcblxuICB0aGlzLiRlbWl0KCdpbml0JywgdGhpcyk7XG4gIHRoaXMuY29uc3RydWN0b3IuZW1pdCgnaW5pdCcsIHRoaXMpO1xuXG4gIGNvbnN0IGhhc0luY2x1ZGVkQ2hpbGRyZW4gPSB0aGlzLiRfXy5leGNsdWRlID09PSBmYWxzZSAmJiB0aGlzLiRfXy5zZWxlY3RlZCA/XG4gICAgJF9faGFzSW5jbHVkZWRDaGlsZHJlbih0aGlzLiRfXy5zZWxlY3RlZCkgOlxuICAgIG51bGw7XG5cbiAgYXBwbHlEZWZhdWx0cyh0aGlzLCB0aGlzLiRfXy5zZWxlY3RlZCwgdGhpcy4kX18uZXhjbHVkZSwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgZmFsc2UsIHRoaXMuJF9fLnNraXBEZWZhdWx0cyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluaXQgaGVscGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIGRvY3VtZW50IGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHJhdyBtb25nb2RiIGRvY1xuICogQHBhcmFtIHtPYmplY3R9IGRvYyBvYmplY3Qgd2UgYXJlIGluaXRpYWxpemluZ1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBPcHRpb25hbCBPcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRzLnNldHRlcnNdIENhbGwgYGFwcGx5U2V0dGVyc2AgaW5zdGVhZCBvZiBgY2FzdGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4XSBQcmVmaXggdG8gYWRkIHRvIGVhY2ggcGF0aFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaW5pdChzZWxmLCBvYmosIGRvYywgb3B0cywgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICBpZiAob2JqLiRfXyAhPSBudWxsKSB7XG4gICAgb2JqID0gb2JqLl9kb2M7XG4gIH1cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQgc2NoZW1hVHlwZTtcbiAgbGV0IHBhdGg7XG4gIGxldCBpO1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBzdHJpY3QgPSBzZWxmLiRfXy5zdHJpY3RNb2RlO1xuICBjb25zdCBkb2NTY2hlbWEgPSBzZWxmLiRfX3NjaGVtYTtcblxuICB3aGlsZSAoaW5kZXggPCBsZW4pIHtcbiAgICBfaW5pdChpbmRleCsrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbml0KGluZGV4KSB7XG4gICAgaSA9IGtleXNbaW5kZXhdO1xuICAgIC8vIGF2b2lkIHByb3RvdHlwZSBwb2xsdXRpb25cbiAgICBpZiAoaSA9PT0gJ19fcHJvdG9fXycgfHwgaSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXRoID0gcHJlZml4ID8gcHJlZml4ICsgaSA6IGk7XG4gICAgc2NoZW1hVHlwZSA9IGRvY1NjaGVtYS5wYXRoKHBhdGgpO1xuXG4gICAgLy8gU2hvdWxkIHN0aWxsIHdvcmsgaWYgbm90IGEgbW9kZWwtbGV2ZWwgZGlzY3JpbWluYXRvciwgYnV0IHNob3VsZCBub3QgYmVcbiAgICAvLyBuZWNlc3NhcnkuIFRoaXMgaXMgKm9ubHkqIHRvIGNhdGNoIHRoZSBjYXNlIHdoZXJlIHdlIHF1ZXJpZWQgdXNpbmcgdGhlXG4gICAgLy8gYmFzZSBtb2RlbCBhbmQgdGhlIGRpc2NyaW1pbmF0ZWQgbW9kZWwgaGFzIGEgcHJvamVjdGlvblxuICAgIGlmIChkb2NTY2hlbWEuJGlzUm9vdERpc2NyaW1pbmF0b3IgJiYgIXNlbGYuJF9faXNTZWxlY3RlZChwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gb2JqW2ldO1xuICAgIGlmICghc2NoZW1hVHlwZSAmJiB1dGlscy5pc1BPSk8odmFsdWUpKSB7XG4gICAgICAvLyBhc3N1bWUgbmVzdGVkIG9iamVjdFxuICAgICAgaWYgKCFkb2NbaV0pIHtcbiAgICAgICAgZG9jW2ldID0ge307XG4gICAgICAgIGlmICghc3RyaWN0ICYmICEoaSBpbiBkb2NTY2hlbWEudHJlZSkgJiYgIShpIGluIGRvY1NjaGVtYS5tZXRob2RzKSAmJiAhKGkgaW4gZG9jU2NoZW1hLnZpcnR1YWxzKSkge1xuICAgICAgICAgIHNlbGZbaV0gPSBkb2NbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluaXQoc2VsZiwgdmFsdWUsIGRvY1tpXSwgb3B0cywgcGF0aCArICcuJyk7XG4gICAgfSBlbHNlIGlmICghc2NoZW1hVHlwZSkge1xuICAgICAgZG9jW2ldID0gdmFsdWU7XG4gICAgICBpZiAoIXN0cmljdCAmJiAhcHJlZml4KSB7XG4gICAgICAgIHNlbGZbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0YWluIG9yZGVyIHdoZW4gb3ZlcndyaXRpbmcgZGVmYXVsdHNcbiAgICAgIGlmIChkb2MuaGFzT3duUHJvcGVydHkoaSkgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBkZWxldGUgZG9jW2ldO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGRvY1tpXSA9IHNjaGVtYVR5cGUuX2Nhc3ROdWxsaXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHdhc1BvcHVsYXRlZCA9IHZhbHVlLiRfXyA9PSBudWxsID8gbnVsbCA6IHZhbHVlLiRfXy53YXNQb3B1bGF0ZWQ7XG5cbiAgICAgICAgaWYgKHNjaGVtYVR5cGUgJiYgIXdhc1BvcHVsYXRlZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAob3B0cyAmJiBvcHRzLnNldHRlcnMpIHtcbiAgICAgICAgICAgICAgLy8gQ2FsbCBhcHBseVNldHRlcnMgd2l0aCBgaW5pdCA9IGZhbHNlYCBiZWNhdXNlIG90aGVyd2lzZSBzZXR0ZXJzIGFyZSBhIG5vb3BcbiAgICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGVJbml0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGRvY1tpXSA9IHNjaGVtYVR5cGUuYXBwbHlTZXR0ZXJzKHZhbHVlLCBzZWxmLCBvdmVycmlkZUluaXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZG9jW2ldID0gc2NoZW1hVHlwZS5jYXN0KHZhbHVlLCBzZWxmLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZWxmLmludmFsaWRhdGUoZS5wYXRoLCBuZXcgVmFsaWRhdG9yRXJyb3Ioe1xuICAgICAgICAgICAgICBwYXRoOiBlLnBhdGgsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2Nhc3QnLFxuICAgICAgICAgICAgICB2YWx1ZTogZS52YWx1ZSxcbiAgICAgICAgICAgICAgcmVhc29uOiBlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY1tpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBtYXJrIGFzIGh5ZHJhdGVkXG4gICAgICBpZiAoIXNlbGYuJGlzTW9kaWZpZWQocGF0aCkpIHtcbiAgICAgICAgc2VsZi4kX18uYWN0aXZlUGF0aHMuaW5pdChwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kcyBhbiB1cGRhdGVPbmUgY29tbWFuZCB3aXRoIHRoaXMgZG9jdW1lbnQgYF9pZGAgYXMgdGhlIHF1ZXJ5IHNlbGVjdG9yLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgd2VpcmRDYXIudXBkYXRlT25lKHskaW5jOiB7d2hlZWxzOjF9fSwgeyB3OiAxIH0sIGNhbGxiYWNrKTtcbiAqXG4gKiAjIyMjIFZhbGlkIG9wdGlvbnM6XG4gKlxuICogIC0gc2FtZSBhcyBpbiBbTW9kZWwudXBkYXRlT25lXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwudXBkYXRlT25lKVxuICpcbiAqIEBzZWUgTW9kZWwudXBkYXRlT25lIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGVPbmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxlYW5dIGlmIHRydXRoeSwgbW9uZ29vc2Ugd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgcmF0aGVyIHRoYW4gYSBtb25nb29zZSBkb2N1bWVudC4gU2VlIFtgUXVlcnkubGVhbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpIGFuZCB0aGUgW01vbmdvb3NlIGxlYW4gdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3MgeW91IHRvIG92ZXJ3cml0ZSB0aW1lc3RhbXBzLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUoZG9jLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBxdWVyeSA9IHRoaXMuY29uc3RydWN0b3IudXBkYXRlT25lKHsgX2lkOiB0aGlzLl9pZCB9LCBkb2MsIG9wdGlvbnMpO1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgcXVlcnkucHJlKGZ1bmN0aW9uIHF1ZXJ5UHJlVXBkYXRlT25lKGNiKSB7XG4gICAgc2VsZi5jb25zdHJ1Y3Rvci5fbWlkZGxld2FyZS5leGVjUHJlKCd1cGRhdGVPbmUnLCBzZWxmLCBbc2VsZl0sIGNiKTtcbiAgfSk7XG4gIHF1ZXJ5LnBvc3QoZnVuY3Rpb24gcXVlcnlQb3N0VXBkYXRlT25lKGNiKSB7XG4gICAgc2VsZi5jb25zdHJ1Y3Rvci5fbWlkZGxld2FyZS5leGVjUG9zdCgndXBkYXRlT25lJywgc2VsZiwgW3NlbGZdLCB7fSwgY2IpO1xuICB9KTtcblxuICBpZiAodGhpcy4kc2Vzc2lvbigpICE9IG51bGwpIHtcbiAgICBpZiAoISgnc2Vzc2lvbicgaW4gcXVlcnkub3B0aW9ucykpIHtcbiAgICAgIHF1ZXJ5Lm9wdGlvbnMuc2Vzc2lvbiA9IHRoaXMuJHNlc3Npb24oKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgIHJldHVybiBxdWVyeS5leGVjKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBxdWVyeTtcbn07XG5cbi8qKlxuICogU2VuZHMgYSByZXBsYWNlT25lIGNvbW1hbmQgd2l0aCB0aGlzIGRvY3VtZW50IGBfaWRgIGFzIHRoZSBxdWVyeSBzZWxlY3Rvci5cbiAqXG4gKiAjIyMjIFZhbGlkIG9wdGlvbnM6XG4gKlxuICogIC0gc2FtZSBhcyBpbiBbTW9kZWwucmVwbGFjZU9uZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnJlcGxhY2VPbmUoKSlcbiAqXG4gKiBAc2VlIE1vZGVsLnJlcGxhY2VPbmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnJlcGxhY2VPbmUoKVxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUucmVwbGFjZU9uZSA9IGZ1bmN0aW9uIHJlcGxhY2VPbmUoKSB7XG4gIGNvbnN0IGFyZ3MgPSBbLi4uYXJndW1lbnRzXTtcbiAgYXJncy51bnNoaWZ0KHsgX2lkOiB0aGlzLl9pZCB9KTtcbiAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucmVwbGFjZU9uZS5hcHBseSh0aGlzLmNvbnN0cnVjdG9yLCBhcmdzKTtcbn07XG5cbi8qKlxuICogR2V0dGVyL3NldHRlciBhcm91bmQgdGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgZG9jdW1lbnQuIFVzZWQgdG9cbiAqIGF1dG9tYXRpY2FsbHkgc2V0IGBzZXNzaW9uYCBpZiB5b3UgYHNhdmUoKWAgYSBkb2MgdGhhdCB5b3UgZ290IGZyb20gYVxuICogcXVlcnkgd2l0aCBhbiBhc3NvY2lhdGVkIHNlc3Npb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzZXNzaW9uID0gTXlNb2RlbC5zdGFydFNlc3Npb24oKTtcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNeU1vZGVsLmZpbmRPbmUoKS5zZXNzaW9uKHNlc3Npb24pO1xuICogICAgIGRvYy4kc2Vzc2lvbigpID09PSBzZXNzaW9uOyAvLyB0cnVlXG4gKiAgICAgZG9jLiRzZXNzaW9uKG51bGwpO1xuICogICAgIGRvYy4kc2Vzc2lvbigpID09PSBudWxsOyAvLyB0cnVlXG4gKlxuICogSWYgdGhpcyBpcyBhIHRvcC1sZXZlbCBkb2N1bWVudCwgc2V0dGluZyB0aGUgc2Vzc2lvbiBwcm9wYWdhdGVzIHRvIGFsbCBjaGlsZFxuICogZG9jcy5cbiAqXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtzZXNzaW9uXSBvdmVyd3JpdGUgdGhlIGN1cnJlbnQgc2Vzc2lvblxuICogQHJldHVybiB7Q2xpZW50U2Vzc2lvbn1cbiAqIEBtZXRob2QgJHNlc3Npb25cbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJHNlc3Npb24gPSBmdW5jdGlvbiAkc2Vzc2lvbihzZXNzaW9uKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHRoaXMuJF9fLnNlc3Npb24gIT0gbnVsbCAmJiB0aGlzLiRfXy5zZXNzaW9uLmhhc0VuZGVkKSB7XG4gICAgICB0aGlzLiRfXy5zZXNzaW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kX18uc2Vzc2lvbjtcbiAgfVxuXG4gIGlmIChzZXNzaW9uICE9IG51bGwgJiYgc2Vzc2lvbi5oYXNFbmRlZCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3Qgc2V0IGEgZG9jdW1lbnRcXCdzIHNlc3Npb24gdG8gYSBzZXNzaW9uIHRoYXQgaGFzIGVuZGVkLiBNYWtlIHN1cmUgeW91IGhhdmVuXFwndCAnICtcbiAgICAgICdjYWxsZWQgYGVuZFNlc3Npb24oKWAgb24gdGhlIHNlc3Npb24geW91IGFyZSBwYXNzaW5nIHRvIGAkc2Vzc2lvbigpYC4nKTtcbiAgfVxuXG4gIGlmIChzZXNzaW9uID09IG51bGwgJiYgdGhpcy4kX18uc2Vzc2lvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy4kX18uc2Vzc2lvbiA9IHNlc3Npb247XG5cbiAgaWYgKCF0aGlzLiRpc1N1YmRvY3VtZW50KSB7XG4gICAgY29uc3Qgc3ViZG9jcyA9IHRoaXMuJGdldEFsbFN1YmRvY3MoKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHN1YmRvY3MpIHtcbiAgICAgIGNoaWxkLiRzZXNzaW9uKHNlc3Npb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXNzaW9uO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIvc2V0dGVyIGFyb3VuZCB3aGV0aGVyIHRoaXMgZG9jdW1lbnQgd2lsbCBhcHBseSB0aW1lc3RhbXBzIGJ5XG4gKiBkZWZhdWx0IHdoZW4gdXNpbmcgYHNhdmUoKWAgYW5kIGBidWxrU2F2ZSgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRlc3RNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9LCB7IHRpbWVzdGFtcHM6IHRydWUgfSkpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBUZXN0TW9kZWwoeyBuYW1lOiAnSm9obiBTbWl0aCcgfSk7XG4gKlxuICogICAgIGRvYy4kdGltZXN0YW1wcygpOyAvLyB0cnVlXG4gKlxuICogICAgIGRvYy4kdGltZXN0YW1wcyhmYWxzZSk7XG4gKiAgICAgYXdhaXQgZG9jLnNhdmUoKTsgLy8gRG9lcyAqKm5vdCoqIGFwcGx5IHRpbWVzdGFtcHNcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt2YWx1ZV0gb3ZlcndyaXRlIHRoZSBjdXJyZW50IHNlc3Npb25cbiAqIEByZXR1cm4ge0RvY3VtZW50fGJvb2xlYW58dW5kZWZpbmVkfSBXaGVuIHVzZWQgYXMgYSBnZXR0ZXIgKG5vIGFyZ3VtZW50KSwgYSBib29sZWFuIHdpbGwgYmUgcmV0dXJuZWQgaW5kaWNhdGluZyB0aGUgdGltZXN0YW1wcyBvcHRpb24gc3RhdGUgb3IgaWYgdW5zZXQgXCJ1bmRlZmluZWRcIiB3aWxsIGJlIHVzZWQsIG90aGVyd2lzZSB3aWxsIHJldHVybiBcInRoaXNcIlxuICogQG1ldGhvZCAkdGltZXN0YW1wc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kdGltZXN0YW1wcyA9IGZ1bmN0aW9uICR0aW1lc3RhbXBzKHZhbHVlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHRoaXMuJF9fLnRpbWVzdGFtcHMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuJF9fLnRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuJF9fc2NoZW1hKSB7XG4gICAgICByZXR1cm4gdGhpcy4kX19zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLiR0aW1lc3RhbXBzKCk7XG4gIGlmICh2YWx1ZSAhPT0gY3VycmVudFZhbHVlKSB7XG4gICAgdGhpcy4kX18udGltZXN0YW1wcyA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJ3cml0ZSBhbGwgdmFsdWVzIGluIHRoaXMgZG9jdW1lbnQgd2l0aCB0aGUgdmFsdWVzIG9mIGBvYmpgLCBleGNlcHRcbiAqIGZvciBpbW11dGFibGUgcHJvcGVydGllcy4gQmVoYXZlcyBzaW1pbGFybHkgdG8gYHNldCgpYCwgZXhjZXB0IGZvciBpdFxuICogdW5zZXRzIGFsbCBwcm9wZXJ0aWVzIHRoYXQgYXJlbid0IGluIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byBvdmVyd3JpdGUgdGhpcyBkb2N1bWVudCB3aXRoXG4gKiBAbWV0aG9kIG92ZXJ3cml0ZVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gdGhpc1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5vdmVyd3JpdGUgPSBmdW5jdGlvbiBvdmVyd3JpdGUob2JqKSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fZG9jKS5jb25jYXQoT2JqZWN0LmtleXMob2JqKSkpKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKGtleSA9PT0gJ19pZCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBFeHBsaWNpdGx5IHNraXAgdmVyc2lvbiBrZXlcbiAgICBpZiAodGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5ICYmIGtleSA9PT0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSAmJiBrZXkgPT09IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuJHNldChrZXksIG9ialtrZXldKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgYHNldCgpYCwgdXNlZCBpbnRlcm5hbGx5IHRvIGF2b2lkIGNvbmZsaWN0c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcGF0aCBwYXRoIG9yIG9iamVjdCBvZiBrZXkvdmFscyB0byBzZXRcbiAqIEBwYXJhbSB7QW55fSB2YWwgdGhlIHZhbHVlIHRvIHNldFxuICogQHBhcmFtIHtTY2hlbWF8U3RyaW5nfE51bWJlcnxCdWZmZXJ8Kn0gW3R5cGVdIG9wdGlvbmFsbHkgc3BlY2lmeSBhIHR5cGUgZm9yIFwib24tdGhlLWZseVwiIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWxseSBzcGVjaWZ5IG9wdGlvbnMgdGhhdCBtb2RpZnkgdGhlIGJlaGF2aW9yIG9mIHRoZSBzZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWVyZ2U9ZmFsc2VdIGlmIHRydWUsIHNldHRpbmcgYSBbbmVzdGVkIHBhdGhdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zdWJkb2NzLmh0bWwjc3ViZG9jdW1lbnRzLXZlcnN1cy1uZXN0ZWQtcGF0aHMpIHdpbGwgbWVyZ2UgZXhpc3RpbmcgdmFsdWVzIHJhdGhlciB0aGFuIG92ZXJ3cml0ZSB0aGUgd2hvbGUgb2JqZWN0LiBTbyBgZG9jLnNldCgnbmVzdGVkJywgeyBhOiAxLCBiOiAyIH0pYCBiZWNvbWVzIGBkb2Muc2V0KCduZXN0ZWQuYScsIDEpOyBkb2Muc2V0KCduZXN0ZWQuYicsIDIpO2BcbiAqIEByZXR1cm4ge0RvY3VtZW50fSB0aGlzXG4gKiBAbWV0aG9kICRzZXRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kc2V0ID0gZnVuY3Rpb24gJHNldChwYXRoLCB2YWwsIHR5cGUsIG9wdGlvbnMpIHtcbiAgaWYgKHV0aWxzLmlzUE9KTyh0eXBlKSkge1xuICAgIG9wdGlvbnMgPSB0eXBlO1xuICAgIHR5cGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBtZXJnZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5tZXJnZTtcbiAgY29uc3QgYWRob2MgPSB0eXBlICYmIHR5cGUgIT09IHRydWU7XG4gIGNvbnN0IGNvbnN0cnVjdGluZyA9IHR5cGUgPT09IHRydWU7XG4gIGxldCBhZGhvY3M7XG4gIGxldCBrZXlzO1xuICBsZXQgaSA9IDA7XG4gIGxldCBwYXRodHlwZTtcbiAgbGV0IGtleTtcbiAgbGV0IHByZWZpeDtcblxuICBjb25zdCB1c2VyU3BlY2lmaWVkU3RyaWN0ID0gb3B0aW9ucyAmJiAnc3RyaWN0JyBpbiBvcHRpb25zO1xuICBsZXQgc3RyaWN0ID0gdXNlclNwZWNpZmllZFN0cmljdFxuICAgID8gb3B0aW9ucy5zdHJpY3RcbiAgICA6IHRoaXMuJF9fLnN0cmljdE1vZGU7XG5cbiAgaWYgKGFkaG9jKSB7XG4gICAgYWRob2NzID0gdGhpcy4kX18uYWRob2NQYXRocyB8fCAodGhpcy4kX18uYWRob2NQYXRocyA9IHt9KTtcbiAgICBhZGhvY3NbcGF0aF0gPSB0aGlzLiRfX3NjaGVtYS5pbnRlcnByZXRBc1R5cGUocGF0aCwgdHlwZSwgdGhpcy4kX19zY2hlbWEub3B0aW9ucyk7XG4gIH1cblxuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgW3BhdGgsIHZhbF0gPSBbdmFsLCBwYXRoXTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBuZXcgRG9jdW1lbnQoeyBrZXk6IHZhbCB9KVxuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIGlmIChwYXRoLiRfX2lzTmVzdGVkKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnRvT2JqZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHRlcm5hcnkgaXMgdG8gc3VwcG9ydCBnaC03ODk4IChjb3B5aW5nIHZpcnR1YWxzIGlmIHNhbWUgc2NoZW1hKVxuICAgICAgICAvLyB3aGlsZSBub3QgYnJlYWtpbmcgZ2gtMTA4MTksIHdoaWNoIGZvciBzb21lIHJlYXNvbiBicmVha3MgaWYgd2UgdXNlIHRvT2JqZWN0KClcbiAgICAgICAgcGF0aCA9IHBhdGguJF9fc2NoZW1hID09PSB0aGlzLiRfX3NjaGVtYVxuICAgICAgICAgID8gYXBwbHlWaXJ0dWFscyhwYXRoLCB7IC4uLnBhdGguX2RvYyB9KVxuICAgICAgICAgIDogcGF0aC5fZG9jO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICBbcGF0aCwgdmFsXSA9IFt2YWwsIHBhdGhdO1xuICAgIH1cblxuICAgIHByZWZpeCA9IHZhbCA/IHZhbCArICcuJyA6ICcnO1xuICAgIGtleXMgPSBnZXRLZXlzSW5TY2hlbWFPcmRlcih0aGlzLiRfX3NjaGVtYSwgcGF0aCk7XG5cbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcblxuICAgIC8vIGBfc2tpcE1pbmltaXplVG9wTGV2ZWxgIGlzIGJlY2F1c2Ugd2UgbWF5IGhhdmUgZGVsZXRlZCB0aGUgdG9wLWxldmVsXG4gICAgLy8gbmVzdGVkIGtleSB0byBlbnN1cmUga2V5IG9yZGVyLlxuICAgIGNvbnN0IF9za2lwTWluaW1pemVUb3BMZXZlbCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5fc2tpcE1pbmltaXplVG9wTGV2ZWwgfHwgZmFsc2U7XG4gICAgaWYgKGxlbiA9PT0gMCAmJiBfc2tpcE1pbmltaXplVG9wTGV2ZWwpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLl9za2lwTWluaW1pemVUb3BMZXZlbDtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgdGhpcy4kc2V0KHZhbCwge30pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgX3NraXBNaW5pbWl6ZVRvcExldmVsOiBmYWxzZSB9KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBjb25zdCBwYXRoTmFtZSA9IHByZWZpeCA/IHByZWZpeCArIGtleSA6IGtleTtcbiAgICAgIHBhdGh0eXBlID0gdGhpcy4kX19zY2hlbWEucGF0aFR5cGUocGF0aE5hbWUpO1xuICAgICAgY29uc3QgdmFsRm9yS2V5ID0gcGF0aFtrZXldO1xuXG4gICAgICAvLyBPbiBpbml0aWFsIHNldCwgZGVsZXRlIGFueSBuZXN0ZWQga2V5cyBpZiB3ZSdyZSBnb2luZyB0byBvdmVyd3JpdGVcbiAgICAgIC8vIHRoZW0gdG8gZW5zdXJlIHdlIGtlZXAgdGhlIHVzZXIncyBrZXkgb3JkZXIuXG4gICAgICBpZiAodHlwZSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICFwcmVmaXggJiZcbiAgICAgICAgICB2YWxGb3JLZXkgIT0gbnVsbCAmJlxuICAgICAgICAgIHBhdGh0eXBlID09PSAnbmVzdGVkJyAmJlxuICAgICAgICAgIHRoaXMuX2RvY1trZXldICE9IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2RvY1trZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNOb25CdWlsdGluT2JqZWN0KHZhbEZvcktleSkgJiYgcGF0aHR5cGUgPT09ICduZXN0ZWQnKSB7XG4gICAgICAgIHRoaXMuJHNldChwYXRoTmFtZSwgdmFsRm9yS2V5LCBjb25zdHJ1Y3RpbmcsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgX3NraXBNYXJrTW9kaWZpZWQ6IHRydWUgfSkpO1xuICAgICAgICAkYXBwbHlEZWZhdWx0c1RvTmVzdGVkKHRoaXMuJGdldChwYXRoTmFtZSksIHBhdGhOYW1lLCB0aGlzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0cmljdCkge1xuICAgICAgICAvLyBEb24ndCBvdmVyd3JpdGUgZGVmYXVsdHMgd2l0aCB1bmRlZmluZWQga2V5cyAoZ2gtMzk4MSkgKGdoLTkwMzkpXG4gICAgICAgIGlmIChjb25zdHJ1Y3RpbmcgJiYgdmFsRm9yS2V5ID09PSB2b2lkIDAgJiZcbiAgICAgICAgICAgIHRoaXMuJGdldChwYXRoTmFtZSkgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGh0eXBlID09PSAnYWRob2NPclVuZGVmaW5lZCcpIHtcbiAgICAgICAgICBwYXRodHlwZSA9IGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGgodGhpcywgcGF0aE5hbWUsIHsgdHlwZU9ubHk6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aHR5cGUgPT09ICdyZWFsJyB8fCBwYXRodHlwZSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgICAgICAgdGhpcy4kc2V0KHBhdGhOYW1lLCB2YWxGb3JLZXksIGNvbnN0cnVjdGluZywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0aHR5cGUgPT09ICduZXN0ZWQnICYmIHZhbEZvcktleSBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgICAgdGhpcy4kc2V0KHBhdGhOYW1lLFxuICAgICAgICAgICAgdmFsRm9yS2V5LnRvT2JqZWN0KHsgdHJhbnNmb3JtOiBmYWxzZSB9KSwgY29uc3RydWN0aW5nLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgPT09ICd0aHJvdycpIHtcbiAgICAgICAgICBpZiAocGF0aHR5cGUgPT09ICduZXN0ZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0RXhwZWN0ZWRFcnJvcihrZXksIHZhbEZvcktleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3Ioa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGF0aHR5cGUgPT09ICduZXN0ZWQnICYmIHZhbEZvcktleSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy4kc2V0KHBhdGhOYW1lLCB2YWxGb3JLZXksIGNvbnN0cnVjdGluZywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmFsRm9yS2V5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy4kc2V0KHBhdGhOYW1lLCB2YWxGb3JLZXksIGNvbnN0cnVjdGluZywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGFsbCBwcm9wZXJ0aWVzIGFyZSBpbiBjb3JyZWN0IG9yZGVyXG4gICAgY29uc3Qgb3JkZXJlZERvYyA9IHt9O1xuICAgIGNvbnN0IG9yZGVyZWRLZXlzID0gT2JqZWN0LmtleXModGhpcy4kX19zY2hlbWEudHJlZSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9yZGVyZWRLZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAoa2V5ID0gb3JkZXJlZEtleXNbaV0pICYmXG4gICAgICAodGhpcy5fZG9jLmhhc093blByb3BlcnR5KGtleSkpICYmXG4gICAgICAob3JkZXJlZERvY1trZXldID0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdGhpcy5fZG9jID0gT2JqZWN0LmFzc2lnbihvcmRlcmVkRG9jLCB0aGlzLl9kb2MpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsZXQgcGF0aFR5cGUgPSB0aGlzLiRfX3NjaGVtYS5wYXRoVHlwZShwYXRoKTtcbiAgbGV0IHBhcnRzID0gbnVsbDtcbiAgaWYgKHBhdGhUeXBlID09PSAnYWRob2NPclVuZGVmaW5lZCcpIHtcbiAgICBwYXJ0cyA9IHBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICBwYXRoVHlwZSA9IGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGgodGhpcywgcGFydHMsIHsgdHlwZU9ubHk6IHRydWUgfSk7XG4gIH1cbiAgaWYgKHBhdGhUeXBlID09PSAnYWRob2NPclVuZGVmaW5lZCcgJiYgIXVzZXJTcGVjaWZpZWRTdHJpY3QpIHtcbiAgICAvLyBNYXkgYmUgcGF0aCB1bmRlcm5lYXRoIG5vbi1zdHJpY3Qgc2NoZW1hXG4gICAgaWYgKHBhcnRzID09IG51bGwpIHtcbiAgICAgIHBhcnRzID0gcGF0aC5pbmRleE9mKCcuJykgPT09IC0xID8gW3BhdGhdIDogcGF0aC5zcGxpdCgnLicpO1xuICAgIH1cbiAgICBjb25zdCBzdWJkb2NTdHJpY3QgPSBnZXRTdWJkb2N1bWVudFN0cmljdFZhbHVlKHRoaXMuJF9fc2NoZW1hLCBwYXJ0cyk7XG4gICAgaWYgKHN1YmRvY1N0cmljdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHJpY3QgPSBzdWJkb2NTdHJpY3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gQXNzdW1lIHRoaXMgaXMgYSBNb25nb29zZSBkb2N1bWVudCB0aGF0IHdhcyBjb3BpZWQgaW50byBhIFBPSk8gdXNpbmdcbiAgLy8gYE9iamVjdC5hc3NpZ24oKWAgb3IgYHsuLi5kb2N9YFxuICB2YWwgPSBoYW5kbGVTcHJlYWREb2ModmFsKTtcblxuICAvLyBpZiB0aGlzIGRvYyBpcyBiZWluZyBjb25zdHJ1Y3RlZCB3ZSBzaG91bGQgbm90IHRyaWdnZXIgZ2V0dGVyc1xuICBjb25zdCBwcmlvclZhbCA9ICgoKSA9PiB7XG4gICAgaWYgKHRoaXMuJF9fLnByaW9yRG9jICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLiRfXy5wcmlvckRvYy4kX19nZXRWYWx1ZShwYXRoKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cnVjdGluZykge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJF9fZ2V0VmFsdWUocGF0aCk7XG4gIH0pKCk7XG5cbiAgaWYgKHBhdGhUeXBlID09PSAnbmVzdGVkJyAmJiB2YWwpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9IG51bGwpIHtcbiAgICAgIGlmICh2YWwuJF9fICE9IG51bGwpIHtcbiAgICAgICAgdmFsID0gdmFsLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmludmFsaWRhdGUocGF0aCwgbmV3IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKCdPYmplY3QnLCB2YWwsIHBhdGgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjb25zdCB3YXNNb2RpZmllZCA9IHRoaXMuJGlzTW9kaWZpZWQocGF0aCk7XG4gICAgICBjb25zdCBoYXNJbml0aWFsVmFsID0gdGhpcy4kX18uc2F2ZWRTdGF0ZSAhPSBudWxsICYmIHRoaXMuJF9fLnNhdmVkU3RhdGUuaGFzT3duUHJvcGVydHkocGF0aCk7XG4gICAgICBpZiAodGhpcy4kX18uc2F2ZWRTdGF0ZSAhPSBudWxsICYmICF0aGlzLiRpc05ldyAmJiAhdGhpcy4kX18uc2F2ZWRTdGF0ZS5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgICAgICBjb25zdCBpbml0aWFsVmFsID0gdGhpcy4kX19nZXRWYWx1ZShwYXRoKTtcbiAgICAgICAgdGhpcy4kX18uc2F2ZWRTdGF0ZVtwYXRoXSA9IGluaXRpYWxWYWw7XG5cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGluaXRpYWxWYWwgfHwge30pO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgdGhpcy4kX18uc2F2ZWRTdGF0ZVtwYXRoICsgJy4nICsga2V5XSA9IGluaXRpYWxWYWxba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW1lcmdlKSB7XG4gICAgICAgIHRoaXMuJF9fc2V0VmFsdWUocGF0aCwgbnVsbCk7XG4gICAgICAgIGNsZWFuTW9kaWZpZWRTdWJwYXRocyh0aGlzLCBwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzZXQodmFsLCBwYXRoLCBjb25zdHJ1Y3RpbmcsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXlzID0gZ2V0S2V5c0luU2NoZW1hT3JkZXIodGhpcy4kX19zY2hlbWEsIHZhbCwgcGF0aCk7XG5cbiAgICAgIHRoaXMuJF9fc2V0VmFsdWUocGF0aCwge30pO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICB0aGlzLiRzZXQocGF0aCArICcuJyArIGtleSwgdmFsW2tleV0sIGNvbnN0cnVjdGluZywgeyAuLi5vcHRpb25zLCBfc2tpcE1hcmtNb2RpZmllZDogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmlvclZhbCAhPSBudWxsICYmXG4gICAgICAgICAgKCF3YXNNb2RpZmllZCB8fCBoYXNJbml0aWFsVmFsKSAmJlxuICAgICAgICAgIHV0aWxzLmRlZXBFcXVhbChoYXNJbml0aWFsVmFsID8gdGhpcy4kX18uc2F2ZWRTdGF0ZVtwYXRoXSA6IHByaW9yVmFsLCB2YWwpKSB7XG4gICAgICAgIHRoaXMudW5tYXJrTW9kaWZpZWQocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1hcmtNb2RpZmllZChwYXRoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLmludmFsaWRhdGUocGF0aCwgbmV3IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKCdPYmplY3QnLCB2YWwsIHBhdGgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxldCBzY2hlbWE7XG4gIGlmIChwYXJ0cyA9PSBudWxsKSB7XG4gICAgcGFydHMgPSBwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcuJyk7XG4gIH1cblxuICAvLyBNaWdodCBuZWVkIHRvIGNoYW5nZSBwYXRoIGZvciB0b3AtbGV2ZWwgYWxpYXNcbiAgaWYgKHR5cGVvZiB0aGlzLiRfX3NjaGVtYS5hbGlhc2VzW3BhcnRzWzBdXSA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXJ0c1swXSA9IHRoaXMuJF9fc2NoZW1hLmFsaWFzZXNbcGFydHNbMF1dO1xuICB9XG5cbiAgaWYgKHBhdGhUeXBlID09PSAnYWRob2NPclVuZGVmaW5lZCcgJiYgc3RyaWN0KSB7XG4gICAgLy8gY2hlY2sgZm9yIHJvb3RzIHRoYXQgYXJlIE1peGVkIHR5cGVzXG4gICAgbGV0IG1peGVkO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBzdWJwYXRoID0gcGFydHMuc2xpY2UoMCwgaSArIDEpLmpvaW4oJy4nKTtcblxuICAgICAgLy8gSWYgcGF0aCBpcyB1bmRlcm5lYXRoIGEgdmlydHVhbCwgYnlwYXNzIGV2ZXJ5dGhpbmcgYW5kIGp1c3Qgc2V0IGl0LlxuICAgICAgaWYgKGkgKyAxIDwgcGFydHMubGVuZ3RoICYmIHRoaXMuJF9fc2NoZW1hLnBhdGhUeXBlKHN1YnBhdGgpID09PSAndmlydHVhbCcpIHtcbiAgICAgICAgbXBhdGguc2V0KHBhdGgsIHZhbCwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBzY2hlbWEgPSB0aGlzLiRfX3NjaGVtYS5wYXRoKHN1YnBhdGgpO1xuICAgICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgTWl4ZWRTY2hlbWEpIHtcbiAgICAgICAgLy8gYWxsb3cgY2hhbmdlcyB0byBzdWIgcGF0aHMgb2YgbWl4ZWQgdHlwZXNcbiAgICAgICAgbWl4ZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc2NoZW1hLiRpc1NjaGVtYU1hcCAmJiBzY2hlbWEuJF9fc2NoZW1hVHlwZSBpbnN0YW5jZW9mIE1peGVkU2NoZW1hICYmIGkgPCBwYXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIE1hcCBvZiBtaXhlZCBhbmQgbm90IHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHBhdGggcmVzb2x2ZXMgdG8gbWl4ZWRcbiAgICAgICAgbWl4ZWQgPSB0cnVlO1xuICAgICAgICBzY2hlbWEgPSBzY2hlbWEuJF9fc2NoZW1hVHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICAvLyBDaGVjayBmb3IgZW1iZWRkZWQgZGlzY3JpbWluYXRvcnNcbiAgICAgIHNjaGVtYSA9IGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGgodGhpcywgcGF0aCk7XG4gICAgfVxuXG4gICAgaWYgKCFtaXhlZCAmJiAhc2NoZW1hKSB7XG4gICAgICBpZiAoc3RyaWN0ID09PSAndGhyb3cnKSB7XG4gICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0gZWxzZSBpZiAocGF0aFR5cGUgPT09ICd2aXJ0dWFsJykge1xuICAgIHNjaGVtYSA9IHRoaXMuJF9fc2NoZW1hLnZpcnR1YWxwYXRoKHBhdGgpO1xuICAgIHNjaGVtYS5hcHBseVNldHRlcnModmFsLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICBzY2hlbWEgPSB0aGlzLiRfX3BhdGgocGF0aCk7XG4gIH1cblxuICAvLyBnaC00NTc4LCBpZiBzZXR0aW5nIGEgZGVlcGx5IG5lc3RlZCBwYXRoIHRoYXQgZG9lc24ndCBleGlzdCB5ZXQsIGNyZWF0ZSBpdFxuICBsZXQgY3VyID0gdGhpcy5fZG9jO1xuICBsZXQgY3VyUGF0aCA9ICcnO1xuICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgY3VyID0gY3VyW3BhcnRzW2ldXTtcbiAgICBjdXJQYXRoICs9IChjdXJQYXRoLmxlbmd0aCAhPT0gMCA/ICcuJyA6ICcnKSArIHBhcnRzW2ldO1xuICAgIGlmICghY3VyKSB7XG4gICAgICB0aGlzLiRzZXQoY3VyUGF0aCwge30pO1xuICAgICAgLy8gSGFjayByZTogZ2gtNTgwMC4gSWYgbmVzdGVkIGZpZWxkIGlzIG5vdCBzZWxlY3RlZCwgaXQgcHJvYmFibHkgZXhpc3RzXG4gICAgICAvLyBzbyBgTW9uZ29TZXJ2ZXJFcnJvcjogY2Fubm90IHVzZSB0aGUgcGFydCAobmVzdGVkIG9mIG5lc3RlZC5udW0pIHRvXG4gICAgICAvLyB0cmF2ZXJzZSB0aGUgZWxlbWVudCAoe25lc3RlZDogbnVsbH0pYCBpcyBub3QgbGlrZWx5LiBJZiB1c2VyIGdldHNcbiAgICAgIC8vIHRoYXQgZXJyb3IsIGl0cyB0aGVpciBmYXVsdCBmb3Igbm93LiBXZSBzaG91bGQgcmVjb25zaWRlciBkaXNhbGxvd2luZ1xuICAgICAgLy8gbW9kaWZ5aW5nIG5vdCBzZWxlY3RlZCBwYXRocyBmb3IgNi54XG4gICAgICBpZiAoIXRoaXMuJF9faXNTZWxlY3RlZChjdXJQYXRoKSkge1xuICAgICAgICB0aGlzLnVubWFya01vZGlmaWVkKGN1clBhdGgpO1xuICAgICAgfVxuICAgICAgY3VyID0gdGhpcy4kX19nZXRWYWx1ZShjdXJQYXRoKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcGF0aFRvTWFyaztcblxuICAvLyBXaGVuIHVzaW5nIHRoZSAkc2V0IG9wZXJhdG9yIHRoZSBwYXRoIHRvIHRoZSBmaWVsZCBtdXN0IGFscmVhZHkgZXhpc3QuXG4gIC8vIEVsc2UgbW9uZ29kYiB0aHJvd3M6IFwiTEVGVF9TVUJGSUVMRCBvbmx5IHN1cHBvcnRzIE9iamVjdFwiXG5cbiAgaWYgKHBhcnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgcGF0aFRvTWFyayA9IHBhdGg7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGVuID0gcGFydHMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3Qgc3VicGF0aCA9IHBhcnRzLnNsaWNlKDAsIGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICBpZiAodGhpcy4kZ2V0KHN1YnBhdGgsIG51bGwsIHsgZ2V0dGVyczogZmFsc2UgfSkgPT09IG51bGwpIHtcbiAgICAgICAgcGF0aFRvTWFyayA9IHN1YnBhdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGF0aFRvTWFyaykge1xuICAgICAgcGF0aFRvTWFyayA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzY2hlbWEpIHtcbiAgICB0aGlzLiRfX3NldChwYXRoVG9NYXJrLCBwYXRoLCBvcHRpb25zLCBjb25zdHJ1Y3RpbmcsIHBhcnRzLCBzY2hlbWEsIHZhbCwgcHJpb3JWYWwpO1xuXG4gICAgaWYgKHBhdGhUeXBlID09PSAnbmVzdGVkJyAmJiB2YWwgPT0gbnVsbCkge1xuICAgICAgY2xlYW5Nb2RpZmllZFN1YnBhdGhzKHRoaXMsIHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIElmIG92ZXJ3cml0aW5nIGEgc3ViZG9jdW1lbnQgcGF0aCwgbWFrZSBzdXJlIHRvIGNsZWFyIG91dFxuICAvLyBhbnkgZXJyb3JzIF9iZWZvcmVfIHNldHRpbmcsIHNvIG5ldyBlcnJvcnMgdGhhdCBoYXBwZW5cbiAgLy8gZ2V0IHBlcnNpc3RlZC4gUmU6ICM5MDgwXG4gIGlmIChzY2hlbWEuJGlzU2luZ2xlTmVzdGVkIHx8IHNjaGVtYS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgX21hcmtWYWxpZFN1YnBhdGhzKHRoaXMsIHBhdGgpO1xuICB9XG5cbiAgaWYgKHZhbCAhPSBudWxsICYmIG1lcmdlICYmIHNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIHZhbCA9IHZhbC50b09iamVjdCh7IHZpcnR1YWxzOiBmYWxzZSwgdHJhbnNmb3JtOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgdGhpcy4kc2V0KHBhdGggKyAnLicgKyBrZXksIHZhbFtrZXldLCBjb25zdHJ1Y3RpbmcsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGV0IHNob3VsZFNldCA9IHRydWU7XG4gIHRyeSB7XG4gICAgLy8gSWYgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHNldCBhIHJlZiBwYXRoIHRvIGEgZG9jdW1lbnQgd2l0aFxuICAgIC8vIHRoZSBjb3JyZWN0IG1vZGVsIG5hbWUsIHRyZWF0IGl0IGFzIHBvcHVsYXRlZFxuICAgIGNvbnN0IHJlZk1hdGNoZXMgPSAoKCkgPT4ge1xuICAgICAgaWYgKHNjaGVtYS5vcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCEodmFsIGluc3RhbmNlb2YgRG9jdW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gdmFsLmNvbnN0cnVjdG9yO1xuXG4gICAgICAvLyBDaGVjayByZWZcbiAgICAgIGNvbnN0IHJlZiA9IHNjaGVtYS5vcHRpb25zLnJlZjtcbiAgICAgIGlmIChyZWYgIT0gbnVsbCAmJiAocmVmID09PSBtb2RlbC5tb2RlbE5hbWUgfHwgcmVmID09PSBtb2RlbC5iYXNlTW9kZWxOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgcmVmUGF0aFxuICAgICAgY29uc3QgcmVmUGF0aCA9IHNjaGVtYS5vcHRpb25zLnJlZlBhdGg7XG4gICAgICBpZiAocmVmUGF0aCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHZhbC5nZXQocmVmUGF0aCk7XG4gICAgICByZXR1cm4gbW9kZWxOYW1lID09PSBtb2RlbC5tb2RlbE5hbWUgfHwgbW9kZWxOYW1lID09PSBtb2RlbC5iYXNlTW9kZWxOYW1lO1xuICAgIH0pKCk7XG5cbiAgICBsZXQgZGlkUG9wdWxhdGUgPSBmYWxzZTtcbiAgICBpZiAocmVmTWF0Y2hlcyAmJiB2YWwgaW5zdGFuY2VvZiBEb2N1bWVudCAmJiAoIXZhbC4kX18ud2FzUG9wdWxhdGVkIHx8IHV0aWxzLmRlZXBFcXVhbCh2YWwuJF9fLndhc1BvcHVsYXRlZC52YWx1ZSwgdmFsLl9pZCkpKSB7XG4gICAgICBjb25zdCB1bnBvcHVsYXRlZFZhbHVlID0gKHNjaGVtYSAmJiBzY2hlbWEuJGlzU2luZ2xlTmVzdGVkKSA/IHNjaGVtYS5jYXN0KHZhbCwgdGhpcykgOiB2YWwuX2lkO1xuICAgICAgdGhpcy4kcG9wdWxhdGVkKHBhdGgsIHVucG9wdWxhdGVkVmFsdWUsIHsgW3BvcHVsYXRlTW9kZWxTeW1ib2xdOiB2YWwuY29uc3RydWN0b3IgfSk7XG4gICAgICB2YWwuJF9fLndhc1BvcHVsYXRlZCA9IHsgdmFsdWU6IHVucG9wdWxhdGVkVmFsdWUgfTtcbiAgICAgIGRpZFBvcHVsYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgcG9wT3B0cztcbiAgICBjb25zdCB0eXBlS2V5ID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy50eXBlS2V5O1xuICAgIGlmIChzY2hlbWEub3B0aW9ucyAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHNjaGVtYS5vcHRpb25zW3R5cGVLZXldKSAmJlxuICAgICAgICBzY2hlbWEub3B0aW9uc1t0eXBlS2V5XS5sZW5ndGggJiZcbiAgICAgICAgc2NoZW1hLm9wdGlvbnNbdHlwZUtleV1bMF0ucmVmICYmXG4gICAgICAgIF9pc01hbnVhbGx5UG9wdWxhdGVkQXJyYXkodmFsLCBzY2hlbWEub3B0aW9uc1t0eXBlS2V5XVswXS5yZWYpKSB7XG4gICAgICBwb3BPcHRzID0geyBbcG9wdWxhdGVNb2RlbFN5bWJvbF06IHZhbFswXS5jb25zdHJ1Y3RvciB9O1xuICAgICAgdGhpcy4kcG9wdWxhdGVkKHBhdGgsIHZhbC5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi5faWQ7IH0pLCBwb3BPcHRzKTtcblxuICAgICAgZm9yIChjb25zdCBkb2Mgb2YgdmFsKSB7XG4gICAgICAgIGRvYy4kX18ud2FzUG9wdWxhdGVkID0geyB2YWx1ZTogZG9jLl9pZCB9O1xuICAgICAgfVxuICAgICAgZGlkUG9wdWxhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghcmVmTWF0Y2hlcyB8fCAhc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCB8fCAhdmFsLiRfXykge1xuICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIHVuZGVybmVhdGggYSBzaW5nbGUgbmVzdGVkIHNjaGVtYSwgd2UnbGwgY2FsbCB0aGUgc2V0dGVyXG4gICAgICAvLyBsYXRlciBpbiBgJF9fc2V0KClgIGJlY2F1c2Ugd2UgZG9uJ3QgdGFrZSBgX2RvY2Agd2hlbiB3ZSBpdGVyYXRlIHRocm91Z2hcbiAgICAgIC8vIGEgc2luZ2xlIG5lc3RlZCBkb2MuIFRoYXQncyB0byBtYWtlIHN1cmUgd2UgZ2V0IHRoZSBjb3JyZWN0IGNvbnRleHQuXG4gICAgICAvLyBPdGhlcndpc2Ugd2Ugd291bGQgZG91YmxlLWNhbGwgdGhlIHNldHRlciwgc2VlIGdoLTcxOTYuXG4gICAgICBsZXQgc2V0dGVyQ29udGV4dCA9IHRoaXM7XG4gICAgICBpZiAodGhpcy4kX19zY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHNbcGF0aF0gIT0gbnVsbCAmJiBwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNldHRlckNvbnRleHQgPSBnZXREZWVwZXN0U3ViZG9jdW1lbnRGb3JQYXRoKHRoaXMsIHBhcnRzLCB0aGlzLnNjaGVtYSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMub3ZlcndyaXRlSW1tdXRhYmxlKSB7XG4gICAgICAgIHZhbCA9IHNjaGVtYS5hcHBseVNldHRlcnModmFsLCBzZXR0ZXJDb250ZXh0LCBmYWxzZSwgcHJpb3JWYWwsIHsgb3ZlcndyaXRlSW1tdXRhYmxlOiB0cnVlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gc2NoZW1hLmFwcGx5U2V0dGVycyh2YWwsIHNldHRlckNvbnRleHQsIGZhbHNlLCBwcmlvclZhbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheShzY2hlbWEpICYmXG4gICAgICAgIHNjaGVtYS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiZcbiAgICAgICAgdmFsLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgICB2YWxbMF0gIT0gbnVsbCAmJlxuICAgICAgICB2YWxbMF0uJF9fICE9IG51bGwgJiZcbiAgICAgICAgdmFsWzBdLiRfXy5wb3B1bGF0ZWQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcG9wdWxhdGVkUGF0aHMgPSBPYmplY3Qua2V5cyh2YWxbMF0uJF9fLnBvcHVsYXRlZCk7XG4gICAgICBmb3IgKGNvbnN0IHBvcHVsYXRlZFBhdGggb2YgcG9wdWxhdGVkUGF0aHMpIHtcbiAgICAgICAgdGhpcy4kcG9wdWxhdGVkKHBhdGggKyAnLicgKyBwb3B1bGF0ZWRQYXRoLFxuICAgICAgICAgIHZhbC5tYXAodiA9PiB2LiRwb3B1bGF0ZWQocG9wdWxhdGVkUGF0aCkpLFxuICAgICAgICAgIHZhbFswXS4kX18ucG9wdWxhdGVkW3BvcHVsYXRlZFBhdGhdLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZGlkUG9wdWxhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghZGlkUG9wdWxhdGUgJiYgdGhpcy4kX18ucG9wdWxhdGVkKSB7XG4gICAgICAvLyBJZiB0aGlzIGFycmF5IHBhcnRpYWxseSBjb250YWlucyBwb3B1bGF0ZWQgZG9jdW1lbnRzLCBjb252ZXJ0IHRoZW1cbiAgICAgIC8vIGFsbCB0byBPYmplY3RJZHMgcmU6ICM4NDQzXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmIHRoaXMuJF9fLnBvcHVsYXRlZFtwYXRoXSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh2YWxbaV0gaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgICAgICAgdmFsLnNldChpLCB2YWxbaV0uX2lkLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLiRfXy5wb3B1bGF0ZWRbcGF0aF07XG4gICAgfVxuXG4gICAgaWYgKHZhbCAhPSBudWxsICYmIHNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIF9jaGVja0ltbXV0YWJsZVN1YnBhdGhzKHZhbCwgc2NoZW1hLCBwcmlvclZhbCk7XG4gICAgfVxuXG4gICAgdGhpcy4kbWFya1ZhbGlkKHBhdGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBNb25nb29zZUVycm9yLlN0cmljdE1vZGVFcnJvciAmJiBlLmlzSW1tdXRhYmxlRXJyb3IpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZShwYXRoLCBlKTtcbiAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBNb25nb29zZUVycm9yLkNhc3RFcnJvcikge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKGUucGF0aCwgZSk7XG4gICAgICBpZiAoZS4kb3JpZ2luYWxFcnJvclBhdGgpIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKHBhdGgsXG4gICAgICAgICAgbmV3IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKHNjaGVtYS5pbnN0YW5jZSwgdmFsLCBwYXRoLCBlLiRvcmlnaW5hbEVycm9yUGF0aCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUocGF0aCxcbiAgICAgICAgbmV3IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKHNjaGVtYS5pbnN0YW5jZSwgdmFsLCBwYXRoLCBlKSk7XG4gICAgfVxuICAgIHNob3VsZFNldCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHNob3VsZFNldCkge1xuICAgIGxldCBzYXZlZFN0YXRlID0gbnVsbDtcbiAgICBsZXQgc2F2ZWRTdGF0ZVBhdGggPSBudWxsO1xuICAgIGlmICghY29uc3RydWN0aW5nKSB7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLiRpc1N1YmRvY3VtZW50ID8gdGhpcy5vd25lckRvY3VtZW50KCkgOiB0aGlzO1xuICAgICAgc2F2ZWRTdGF0ZSA9IGRvYy4kX18uc2F2ZWRTdGF0ZTtcbiAgICAgIHNhdmVkU3RhdGVQYXRoID0gdGhpcy4kaXNTdWJkb2N1bWVudCA/IHRoaXMuJF9fLmZ1bGxQYXRoICsgJy4nICsgcGF0aCA6IHBhdGg7XG4gICAgICBkb2MuJF9fc2F2ZUluaXRpYWxTdGF0ZShzYXZlZFN0YXRlUGF0aCk7XG4gICAgfVxuXG4gICAgdGhpcy4kX19zZXQocGF0aFRvTWFyaywgcGF0aCwgb3B0aW9ucywgY29uc3RydWN0aW5nLCBwYXJ0cywgc2NoZW1hLCB2YWwsIHByaW9yVmFsKTtcblxuICAgIGNvbnN0IGlzSW5UcmFuc2FjdGlvbiA9ICEhdGhpcy4kX18uc2Vzc2lvbj8udHJhbnNhY3Rpb247XG4gICAgY29uc3QgaXNNb2RpZmllZFdpdGhpblRyYW5zYWN0aW9uID0gdGhpcy4kX18uc2Vzc2lvbiAmJlxuICAgICAgdGhpcy4kX18uc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXSAmJlxuICAgICAgdGhpcy4kX18uc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXS5oYXModGhpcykgJiZcbiAgICAgIHRoaXMuJF9fLnNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10uZ2V0KHRoaXMpLm1vZGlmaWVkUGF0aHMgJiZcbiAgICAgICF0aGlzLiRfXy5zZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdLmdldCh0aGlzKS5tb2RpZmllZFBhdGhzLmhhcyhzYXZlZFN0YXRlUGF0aCk7XG4gICAgaWYgKHNhdmVkU3RhdGUgIT0gbnVsbCAmJlxuICAgICAgICBzYXZlZFN0YXRlLmhhc093blByb3BlcnR5KHNhdmVkU3RhdGVQYXRoKSAmJlxuICAgICAgICAoIWlzSW5UcmFuc2FjdGlvbiB8fCBpc01vZGlmaWVkV2l0aGluVHJhbnNhY3Rpb24pICYmXG4gICAgICAgIHV0aWxzLmRlZXBFcXVhbCh2YWwsIHNhdmVkU3RhdGVbc2F2ZWRTdGF0ZVBhdGhdKSkge1xuICAgICAgdGhpcy51bm1hcmtNb2RpZmllZChwYXRoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCAmJiAodGhpcy5pc0RpcmVjdE1vZGlmaWVkKHBhdGgpIHx8IHZhbCA9PSBudWxsKSkge1xuICAgIGNsZWFuTW9kaWZpZWRTdWJwYXRocyh0aGlzLCBwYXRoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfaXNNYW51YWxseVBvcHVsYXRlZEFycmF5KHZhbCwgcmVmKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBlbCBvZiB2YWwpIHtcbiAgICBpZiAoIShlbCBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtb2RlbE5hbWUgPSBlbC5jb25zdHJ1Y3Rvci5tb2RlbE5hbWU7XG4gICAgaWYgKG1vZGVsTmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlbC5jb25zdHJ1Y3Rvci5tb2RlbE5hbWUgIT0gcmVmICYmIGVsLmNvbnN0cnVjdG9yLmJhc2VNb2RlbE5hbWUgIT0gcmVmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwYXRoLCBvciBtYW55IHBhdGhzLlxuICogQWxpYXMgZm9yIFtgLiRzZXRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLiRzZXQoKSkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBwYXRoLCB2YWx1ZVxuICogICAgIGRvYy5zZXQocGF0aCwgdmFsdWUpXG4gKlxuICogICAgIC8vIG9iamVjdFxuICogICAgIGRvYy5zZXQoe1xuICogICAgICAgICBwYXRoICA6IHZhbHVlXG4gKiAgICAgICAsIHBhdGgyIDoge1xuICogICAgICAgICAgICBwYXRoICA6IHZhbHVlXG4gKiAgICAgICAgIH1cbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBvbi10aGUtZmx5IGNhc3QgdG8gbnVtYmVyXG4gKiAgICAgZG9jLnNldChwYXRoLCB2YWx1ZSwgTnVtYmVyKVxuICpcbiAqICAgICAvLyBvbi10aGUtZmx5IGNhc3QgdG8gc3RyaW5nXG4gKiAgICAgZG9jLnNldChwYXRoLCB2YWx1ZSwgU3RyaW5nKVxuICpcbiAqICAgICAvLyBjaGFuZ2luZyBzdHJpY3QgbW9kZSBiZWhhdmlvclxuICogICAgIGRvYy5zZXQocGF0aCwgdmFsdWUsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHBhdGggcGF0aCBvciBvYmplY3Qgb2Yga2V5L3ZhbHMgdG8gc2V0XG4gKiBAcGFyYW0ge0FueX0gdmFsIHRoZSB2YWx1ZSB0byBzZXRcbiAqIEBwYXJhbSB7U2NoZW1hfFN0cmluZ3xOdW1iZXJ8QnVmZmVyfCp9IFt0eXBlXSBvcHRpb25hbGx5IHNwZWNpZnkgYSB0eXBlIGZvciBcIm9uLXRoZS1mbHlcIiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsbHkgc3BlY2lmeSBvcHRpb25zIHRoYXQgbW9kaWZ5IHRoZSBiZWhhdmlvciBvZiB0aGUgc2V0XG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2Qgc2V0XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5zZXQgPSBEb2N1bWVudC5wcm90b3R5cGUuJHNldDtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIG1hcmsgdGhpcyBjaGFuZ2UgYXMgbW9kaWZpZWQuXG4gKlxuICogQHBhcmFtIHtuZXZlcn0gcGF0aFRvTWFyayBVTlVTRURcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QW55fSBjb25zdHJ1Y3RpbmdcbiAqIEBwYXJhbSB7bmV2ZXJ9IHBhcnRzIFVOVVNFRFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQHBhcmFtIHtBbnl9IHByaW9yVmFsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX3Nob3VsZE1vZGlmeVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fc2hvdWxkTW9kaWZ5ID0gZnVuY3Rpb24ocGF0aFRvTWFyaywgcGF0aCwgb3B0aW9ucywgY29uc3RydWN0aW5nLCBwYXJ0cywgc2NoZW1hLCB2YWwsIHByaW9yVmFsKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX3NraXBNYXJrTW9kaWZpZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMuJGlzTmV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSXMgcGF0aCBhbHJlYWR5IG1vZGlmaWVkPyBJZiBzbywgYWx3YXlzIG1vZGlmeS4gV2UgbWF5IHVubWFyayBtb2RpZmllZCBsYXRlci5cbiAgaWYgKHBhdGggaW4gdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh2YWwgPT09IHZvaWQgMCAmJiAhdGhpcy4kX19pc1NlbGVjdGVkKHBhdGgpKSB7XG4gICAgLy8gd2hlbiBhIHBhdGggaXMgbm90IHNlbGVjdGVkIGluIGEgcXVlcnksIGl0cyBpbml0aWFsXG4gICAgLy8gdmFsdWUgd2lsbCBiZSB1bmRlZmluZWQuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodmFsID09PSB2b2lkIDAgJiYgcGF0aCBpbiB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdkZWZhdWx0JykpIHtcbiAgICAvLyB3ZSdyZSBqdXN0IHVuc2V0dGluZyB0aGUgZGVmYXVsdCB2YWx1ZSB3aGljaCB3YXMgbmV2ZXIgc2F2ZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBnaC0zOTkyOiBpZiBzZXR0aW5nIGEgcG9wdWxhdGVkIGZpZWxkIHRvIGEgZG9jLCBkb24ndCBtYXJrIG1vZGlmaWVkXG4gIC8vIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBfaWRcbiAgaWYgKHRoaXMuJHBvcHVsYXRlZChwYXRoKSAmJlxuICAgICAgdmFsIGluc3RhbmNlb2YgRG9jdW1lbnQgJiZcbiAgICAgIGRlZXBFcXVhbCh2YWwuX2lkLCBwcmlvclZhbCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWRlZXBFcXVhbCh2YWwsIHByaW9yVmFsICE9PSB1bmRlZmluZWQgPyBwcmlvclZhbCA6IHV0aWxzLmdldFZhbHVlKHBhdGgsIHRoaXMpKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCFjb25zdHJ1Y3RpbmcgJiZcbiAgICAgIHZhbCAhPT0gbnVsbCAmJlxuICAgICAgdmFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIHBhdGggaW4gdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnZGVmYXVsdCcpICYmXG4gICAgICBkZWVwRXF1YWwodmFsLCBzY2hlbWEuZ2V0RGVmYXVsdCh0aGlzLCBjb25zdHJ1Y3RpbmcpKSkge1xuICAgIC8vIGEgcGF0aCB3aXRoIGEgZGVmYXVsdCB3YXMgJHVuc2V0IG9uIHRoZSBzZXJ2ZXJcbiAgICAvLyBhbmQgdGhlIHVzZXIgaXMgc2V0dGluZyBpdCB0byB0aGUgc2FtZSB2YWx1ZSBhZ2FpblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyB0aGUgYWN0dWFsIHNldHRpbmcgb2YgdGhlIHZhbHVlIGFuZCBtYXJraW5nIHRoZSBwYXRoIG1vZGlmaWVkIGlmIGFwcHJvcHJpYXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoVG9NYXJrXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0FueX0gY29uc3RydWN0aW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0c1xuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQHBhcmFtIHtBbnl9IHByaW9yVmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fc2V0XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19zZXQgPSBmdW5jdGlvbihwYXRoVG9NYXJrLCBwYXRoLCBvcHRpb25zLCBjb25zdHJ1Y3RpbmcsIHBhcnRzLCBzY2hlbWEsIHZhbCwgcHJpb3JWYWwpIHtcbiAgRW1iZWRkZWQgPSBFbWJlZGRlZCB8fCByZXF1aXJlKCcuL3R5cGVzL0FycmF5U3ViZG9jdW1lbnQnKTtcblxuICBjb25zdCBzaG91bGRNb2RpZnkgPSB0aGlzLiRfX3Nob3VsZE1vZGlmeShwYXRoVG9NYXJrLCBwYXRoLCBvcHRpb25zLCBjb25zdHJ1Y3RpbmcsIHBhcnRzLFxuICAgIHNjaGVtYSwgdmFsLCBwcmlvclZhbCk7XG5cbiAgaWYgKHNob3VsZE1vZGlmeSkge1xuICAgIGlmICh0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzICYmIHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3NbcGF0aF0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzW3BhdGhdO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy4kX18ucHJpbWl0aXZlQXRvbWljcztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrTW9kaWZpZWQocGF0aFRvTWFyayk7XG5cbiAgICAvLyBoYW5kbGUgZGlyZWN0bHkgc2V0dGluZyBhcnJheXMgKGdoLTExMjYpXG4gICAgTW9uZ29vc2VBcnJheSB8fCAoTW9uZ29vc2VBcnJheSA9IHJlcXVpcmUoJy4vdHlwZXMvYXJyYXknKSk7XG4gICAgaWYgKHZhbCAmJiB1dGlscy5pc01vbmdvb3NlQXJyYXkodmFsKSkge1xuICAgICAgdmFsLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHZhbCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBlbWJlZGRlZCBkb2N1bWVudCBwYXJlbnQgcmVmZXJlbmNlcyAoZ2gtNTE4OSlcbiAgICAgIGlmICh1dGlscy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBpdGVtICYmIGl0ZW0uX19wYXJlbnRBcnJheSAmJiAoaXRlbS5fX3BhcmVudEFycmF5ID0gdmFsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSAmJiBBcnJheS5pc0FycmF5KHByaW9yVmFsKSAmJiB1dGlscy5pc01vbmdvb3NlQXJyYXkodmFsKSAmJiB1dGlscy5pc01vbmdvb3NlQXJyYXkocHJpb3JWYWwpKSB7XG4gICAgdmFsW2FycmF5QXRvbWljc1N5bWJvbF0gPSBwcmlvclZhbFthcnJheUF0b21pY3NTeW1ib2xdO1xuICAgIHZhbFthcnJheUF0b21pY3NCYWNrdXBTeW1ib2xdID0gcHJpb3JWYWxbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXTtcbiAgICBpZiAodXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkodmFsKSkge1xuICAgICAgdmFsLmZvckVhY2goZG9jID0+IHtcbiAgICAgICAgaWYgKGRvYyAhPSBudWxsKSB7XG4gICAgICAgICAgZG9jLiRpc05ldyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBsZXQgb2JqID0gdGhpcy5fZG9jO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGwgPSBwYXJ0cy5sZW5ndGg7XG4gIGxldCBjdXIgPSAnJztcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG5leHQgPSBpICsgMTtcbiAgICBjb25zdCBsYXN0ID0gbmV4dCA9PT0gbDtcbiAgICBjdXIgKz0gKGN1ciA/ICcuJyArIHBhcnRzW2ldIDogcGFydHNbaV0pO1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMocGFydHNbaV0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgb2JqLnNldChwYXJ0c1tpXSwgdmFsKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgICBpZiAoIShwYXJ0c1tpXSBpbiBvYmopKSB7XG4gICAgICAgICAgb2JqW3BhcnRzW2ldXSA9IHZhbDtcbiAgICAgICAgICBvYmouX2RvY1twYXJ0c1tpXV0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqLl9kb2NbcGFydHNbaV1dID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbcGFydHNbaV1dID0gdmFsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc01hcCA9IG9iaiBpbnN0YW5jZW9mIE1hcDtcbiAgICAgIGxldCB2YWx1ZSA9IGlzTWFwID8gb2JqLmdldChwYXJ0c1tpXSkgOiBvYmpbcGFydHNbaV1dO1xuICAgICAgaWYgKHV0aWxzLmlzUE9KTyh2YWx1ZSkpIHtcbiAgICAgICAgb2JqID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgRW1iZWRkZWQpIHtcbiAgICAgICAgb2JqID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgb2JqID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIG9iaiA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0ge307XG4gICAgICAgIGlmIChpc01hcCkge1xuICAgICAgICAgIG9iai5zZXQocGFydHNbaV0sIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpbcGFydHNbaV1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyBhIHJhdyB2YWx1ZSBmcm9tIGEgcGF0aCAobm8gZ2V0dGVycylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QW55fSBSZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBgcGF0aGAuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fZ2V0VmFsdWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiB1dGlscy5nZXRWYWx1ZShwYXRoLCB0aGlzLl9kb2MpO1xufTtcblxuLyoqXG4gKiBJbmNyZW1lbnRzIHRoZSBudW1lcmljIHZhbHVlIGF0IGBwYXRoYCBieSB0aGUgZ2l2ZW4gYHZhbGAuXG4gKiBXaGVuIHlvdSBjYWxsIGBzYXZlKClgIG9uIHRoaXMgZG9jdW1lbnQsIE1vbmdvb3NlIHdpbGwgc2VuZCBhXG4gKiBbYCRpbmNgXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlL2luYy8pXG4gKiBhcyBvcHBvc2VkIHRvIGEgYCRzZXRgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IGNvdW50ZXI6IE51bWJlciB9KTtcbiAqICAgICBjb25zdCBUZXN0ID0gZGIubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBUZXN0LmNyZWF0ZSh7IGNvdW50ZXI6IDAgfSk7XG4gKiAgICAgZG9jLiRpbmMoJ2NvdW50ZXInLCAyKTtcbiAqICAgICBhd2FpdCBkb2Muc2F2ZSgpOyAvLyBTZW5kcyBhIGB7ICRpbmM6IHsgY291bnRlcjogMiB9IH1gIHRvIE1vbmdvREJcbiAqICAgICBkb2MuY291bnRlcjsgLy8gMlxuICpcbiAqICAgICBkb2MuY291bnRlciArPSAyO1xuICogICAgIGF3YWl0IGRvYy5zYXZlKCk7IC8vIFNlbmRzIGEgYHsgJHNldDogeyBjb3VudGVyOiAyIH0gfWAgdG8gTW9uZ29EQlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwYXRoIHBhdGggb3IgcGF0aHMgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsIGluY3JlbWVudCBgcGF0aGAgYnkgdGhpcyB2YWx1ZVxuICogQHJldHVybiB7RG9jdW1lbnR9IHRoaXNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGluYyA9IGZ1bmN0aW9uICRpbmMocGF0aCwgdmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIHZhbCA9IDE7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHBhdGguZm9yRWFjaCgocCkgPT4gdGhpcy4kaW5jKHAsIHZhbCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IHRoaXMuJF9fcGF0aChwYXRoKTtcbiAgaWYgKHNjaGVtYVR5cGUgPT0gbnVsbCkge1xuICAgIGlmICh0aGlzLiRfXy5zdHJpY3RNb2RlID09PSAndGhyb3cnKSB7XG4gICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKHBhdGgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4kX18uc3RyaWN0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNjaGVtYVR5cGUuaW5zdGFuY2UgIT09ICdOdW1iZXInKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlKHBhdGgsIG5ldyBNb25nb29zZUVycm9yLkNhc3RFcnJvcihzY2hlbWFUeXBlLmluc3RhbmNlLCB2YWwsIHBhdGgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuJF9fZ2V0VmFsdWUocGF0aCkgfHwgMDtcbiAgbGV0IHNob3VsZFNldCA9IGZhbHNlO1xuICBsZXQgdmFsVG9TZXQgPSBudWxsO1xuICBsZXQgdmFsVG9JbmMgPSB2YWw7XG5cbiAgdHJ5IHtcbiAgICB2YWwgPSBzY2hlbWFUeXBlLmNhc3QodmFsKTtcbiAgICB2YWxUb1NldCA9IHNjaGVtYVR5cGUuYXBwbHlTZXR0ZXJzKGN1cnJlbnRWYWx1ZSArIHZhbCwgdGhpcyk7XG4gICAgdmFsVG9JbmMgPSB2YWxUb1NldCAtIGN1cnJlbnRWYWx1ZTtcbiAgICBzaG91bGRTZXQgPSB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLmludmFsaWRhdGUocGF0aCwgbmV3IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKCdudW1iZXInLCB2YWwsIHBhdGgsIGVycikpO1xuICB9XG5cbiAgaWYgKHNob3VsZFNldCkge1xuICAgIHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3MgPSB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzIHx8IHt9O1xuICAgIGlmICh0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzW3BhdGhdID09IG51bGwpIHtcbiAgICAgIHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3NbcGF0aF0gPSB7ICRpbmM6IHZhbFRvSW5jIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3NbcGF0aF0uJGluYyArPSB2YWxUb0luYztcbiAgICB9XG4gICAgdGhpcy5tYXJrTW9kaWZpZWQocGF0aCk7XG4gICAgdGhpcy4kX19zZXRWYWx1ZShwYXRoLCB2YWxUb1NldCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhIHJhdyB2YWx1ZSBmb3IgYSBwYXRoIChubyBjYXN0aW5nLCBzZXR0ZXJzLCB0cmFuc2Zvcm1hdGlvbnMpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7RG9jdW1lbnR9IHRoaXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19zZXRWYWx1ZSA9IGZ1bmN0aW9uKHBhdGgsIHZhbCkge1xuICB1dGlscy5zZXRWYWx1ZShwYXRoLCB2YWwsIHRoaXMuX2RvYyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHBhdGguXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBwYXRoXG4gKiAgICAgZG9jLmdldCgnYWdlJykgLy8gNDdcbiAqXG4gKiAgICAgLy8gZHluYW1pYyBjYXN0aW5nIHRvIGEgc3RyaW5nXG4gKiAgICAgZG9jLmdldCgnYWdlJywgU3RyaW5nKSAvLyBcIjQ3XCJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtTY2hlbWF8U3RyaW5nfE51bWJlcnxCdWZmZXJ8Kn0gW3R5cGVdIG9wdGlvbmFsbHkgc3BlY2lmeSBhIHR5cGUgZm9yIG9uLXRoZS1mbHkgYXR0cmlidXRlc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52aXJ0dWFscz1mYWxzZV0gQXBwbHkgdmlydHVhbHMgYmVmb3JlIGdldHRpbmcgdGhpcyBwYXRoXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmdldHRlcnM9dHJ1ZV0gSWYgZmFsc2UsIHNraXAgYXBwbHlpbmcgZ2V0dGVycyBhbmQganVzdCBnZXQgdGhlIHJhdyB2YWx1ZVxuICogQHJldHVybiB7QW55fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGF0aCwgdHlwZSwgb3B0aW9ucykge1xuICBsZXQgYWRob2M7XG4gIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKHR5cGUpIHtcbiAgICBhZGhvYyA9IHRoaXMuJF9fc2NoZW1hLmludGVycHJldEFzVHlwZShwYXRoLCB0eXBlLCB0aGlzLiRfX3NjaGVtYS5vcHRpb25zKTtcbiAgfVxuICBjb25zdCBub0RvdHRlZFBhdGggPSBvcHRpb25zLm5vRG90dGVkUGF0aDtcblxuICAvLyBGYXN0IHBhdGggaWYgd2Uga25vdyB3ZSdyZSBqdXN0IGFjY2Vzc2luZyB0b3AtbGV2ZWwgcGF0aCBvbiB0aGUgZG9jdW1lbnQ6XG4gIC8vIGp1c3QgZ2V0IHRoZSBzY2hlbWEgcGF0aCwgYXZvaWQgYCRfX3BhdGgoKWAgYmVjYXVzZSB0aGF0IGRvZXMgc3RyaW5nIG1hbmlwdWxhdGlvblxuICBsZXQgc2NoZW1hID0gbm9Eb3R0ZWRQYXRoID8gdGhpcy4kX19zY2hlbWEucGF0aHNbcGF0aF0gOiB0aGlzLiRfX3BhdGgocGF0aCk7XG4gIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgIHNjaGVtYSA9IHRoaXMuJF9fc2NoZW1hLnZpcnR1YWxwYXRoKHBhdGgpO1xuXG4gICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLmFwcGx5R2V0dGVycyh2b2lkIDAsIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub0RvdHRlZFBhdGgpIHtcbiAgICBsZXQgb2JqID0gdGhpcy5fZG9jW3BhdGhdO1xuICAgIGlmIChhZGhvYykge1xuICAgICAgb2JqID0gYWRob2MuY2FzdChvYmopO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9IG51bGwgJiYgb3B0aW9ucy5nZXR0ZXJzICE9PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHNjaGVtYS5hcHBseUdldHRlcnMob2JqLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChzY2hlbWEgIT0gbnVsbCAmJiBzY2hlbWEuaW5zdGFuY2UgPT09ICdNaXhlZCcpIHtcbiAgICBjb25zdCB2aXJ0dWFsID0gdGhpcy4kX19zY2hlbWEudmlydHVhbHBhdGgocGF0aCk7XG4gICAgaWYgKHZpcnR1YWwgIT0gbnVsbCkge1xuICAgICAgc2NoZW1hID0gdmlydHVhbDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBoYXNEb3QgPSBwYXRoLmluZGV4T2YoJy4nKSAhPT0gLTE7XG4gIGxldCBvYmogPSB0aGlzLl9kb2M7XG5cbiAgY29uc3QgcGllY2VzID0gaGFzRG90ID8gcGF0aC5zcGxpdCgnLicpIDogW3BhdGhdO1xuICAvLyBNaWdodCBuZWVkIHRvIGNoYW5nZSBwYXRoIGZvciB0b3AtbGV2ZWwgYWxpYXNcbiAgaWYgKHR5cGVvZiB0aGlzLiRfX3NjaGVtYS5hbGlhc2VzW3BpZWNlc1swXV0gPT09ICdzdHJpbmcnKSB7XG4gICAgcGllY2VzWzBdID0gdGhpcy4kX19zY2hlbWEuYWxpYXNlc1twaWVjZXNbMF1dO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwaWVjZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKG9iaiAmJiBvYmouX2RvYykge1xuICAgICAgb2JqID0gb2JqLl9kb2M7XG4gICAgfVxuXG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICBvYmogPSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIG9iaiA9IG9iai5nZXQocGllY2VzW2ldLCB7IGdldHRlcnM6IGZhbHNlIH0pO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbCAtIDEpIHtcbiAgICAgIG9iaiA9IHV0aWxzLmdldFZhbHVlKHBpZWNlc1tpXSwgb2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqID0gb2JqW3BpZWNlc1tpXV07XG4gICAgfVxuICB9XG5cbiAgaWYgKGFkaG9jKSB7XG4gICAgb2JqID0gYWRob2MuY2FzdChvYmopO1xuICB9XG5cbiAgaWYgKHNjaGVtYSAhPSBudWxsICYmIG9wdGlvbnMuZ2V0dGVycyAhPT0gZmFsc2UpIHtcbiAgICBvYmogPSBzY2hlbWEuYXBwbHlHZXR0ZXJzKG9iaiwgdGhpcyk7XG4gIH0gZWxzZSBpZiAodGhpcy4kX19zY2hlbWEubmVzdGVkW3BhdGhdICYmIG9wdGlvbnMudmlydHVhbHMpIHtcbiAgICAvLyBNaWdodCBuZWVkIHRvIGFwcGx5IHZpcnR1YWxzIGlmIHRoaXMgaXMgYSBuZXN0ZWQgcGF0aFxuICAgIHJldHVybiBhcHBseVZpcnR1YWxzKHRoaXMsIGNsb25lKG9iaikgfHwge30sIHsgcGF0aDogcGF0aCB9KTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZVtnZXRTeW1ib2xdID0gRG9jdW1lbnQucHJvdG90eXBlLmdldDtcbkRvY3VtZW50LnByb3RvdHlwZS4kZ2V0ID0gRG9jdW1lbnQucHJvdG90eXBlLmdldDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY2hlbWF0eXBlIGZvciB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtTY2hlbWFQYXRofVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX3BhdGhcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3BhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gIGNvbnN0IGFkaG9jcyA9IHRoaXMuJF9fLmFkaG9jUGF0aHM7XG4gIGNvbnN0IGFkaG9jVHlwZSA9IGFkaG9jcyAmJiBhZGhvY3MuaGFzT3duUHJvcGVydHkocGF0aCkgPyBhZGhvY3NbcGF0aF0gOiBudWxsO1xuXG4gIGlmIChhZGhvY1R5cGUpIHtcbiAgICByZXR1cm4gYWRob2NUeXBlO1xuICB9XG4gIHJldHVybiB0aGlzLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xufTtcblxuLyoqXG4gKiBNYXJrcyB0aGUgcGF0aCBhcyBoYXZpbmcgcGVuZGluZyBjaGFuZ2VzIHRvIHdyaXRlIHRvIHRoZSBkYi5cbiAqXG4gKiBfVmVyeSBoZWxwZnVsIHdoZW4gdXNpbmcgW01peGVkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNtaXhlZCkgdHlwZXMuX1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZG9jLm1peGVkLnR5cGUgPSAnY2hhbmdlZCc7XG4gKiAgICAgZG9jLm1hcmtNb2RpZmllZCgnbWl4ZWQudHlwZScpO1xuICogICAgIGRvYy5zYXZlKCkgLy8gY2hhbmdlcyB0byBtaXhlZC50eXBlIGFyZSBub3cgcGVyc2lzdGVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gbWFyayBtb2RpZmllZFxuICogQHBhcmFtIHtEb2N1bWVudH0gW3Njb3BlXSB0aGUgc2NvcGUgdG8gcnVuIHZhbGlkYXRvcnMgd2l0aFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUubWFya01vZGlmaWVkID0gZnVuY3Rpb24ocGF0aCwgc2NvcGUpIHtcbiAgdGhpcy4kX19zYXZlSW5pdGlhbFN0YXRlKHBhdGgpO1xuXG4gIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLm1vZGlmeShwYXRoKTtcbiAgaWYgKHNjb3BlICE9IG51bGwgJiYgIXRoaXMuJGlzU3ViZG9jdW1lbnQpIHtcbiAgICB0aGlzLiRfXy5wYXRoc1RvU2NvcGVzID0gdGhpcy4kX19wYXRoc1RvU2NvcGVzIHx8IHt9O1xuICAgIHRoaXMuJF9fLnBhdGhzVG9TY29wZXNbcGF0aF0gPSBzY29wZTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fc2F2ZUluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uICRfX3NhdmVJbml0aWFsU3RhdGUocGF0aCkge1xuICBjb25zdCBzYXZlZFN0YXRlID0gdGhpcy4kX18uc2F2ZWRTdGF0ZTtcbiAgY29uc3Qgc2F2ZWRTdGF0ZVBhdGggPSBwYXRoO1xuICBpZiAoc2F2ZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgY29uc3QgZmlyc3REb3QgPSBzYXZlZFN0YXRlUGF0aC5pbmRleE9mKCcuJyk7XG4gICAgY29uc3QgdG9wTGV2ZWxQYXRoID0gZmlyc3REb3QgPT09IC0xID8gc2F2ZWRTdGF0ZVBhdGggOiBzYXZlZFN0YXRlUGF0aC5zbGljZSgwLCBmaXJzdERvdCk7XG4gICAgaWYgKCFzYXZlZFN0YXRlLmhhc093blByb3BlcnR5KHRvcExldmVsUGF0aCkpIHtcbiAgICAgIHNhdmVkU3RhdGVbdG9wTGV2ZWxQYXRoXSA9IGNsb25lKHRoaXMuJF9fZ2V0VmFsdWUodG9wTGV2ZWxQYXRoKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbW9kaWZpZWQgc3RhdGUgb24gdGhlIHNwZWNpZmllZCBwYXRoLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZG9jLmZvbyA9ICdiYXInO1xuICogICAgIGRvYy51bm1hcmtNb2RpZmllZCgnZm9vJyk7XG4gKiAgICAgZG9jLnNhdmUoKTsgLy8gY2hhbmdlcyB0byBmb28gd2lsbCBub3QgYmUgcGVyc2lzdGVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gdW5tYXJrIG1vZGlmaWVkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS51bm1hcmtNb2RpZmllZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdGhpcy4kX18uYWN0aXZlUGF0aHMuaW5pdChwYXRoKTtcbiAgaWYgKHRoaXMuJF9fLnBhdGhzVG9TY29wZXMgIT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLiRfXy5wYXRoc1RvU2NvcGVzW3BhdGhdO1xuICB9XG59O1xuXG4vKipcbiAqIERvbid0IHJ1biB2YWxpZGF0aW9uIG9uIHRoaXMgcGF0aCBvciBwZXJzaXN0IGNoYW5nZXMgdG8gdGhpcyBwYXRoLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZG9jLmZvbyA9IG51bGw7XG4gKiAgICAgZG9jLiRpZ25vcmUoJ2ZvbycpO1xuICogICAgIGRvYy5zYXZlKCk7IC8vIGNoYW5nZXMgdG8gZm9vIHdpbGwgbm90IGJlIHBlcnNpc3RlZCBhbmQgdmFsaWRhdG9ycyB3b24ndCBiZSBydW5cbiAqXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQG1ldGhvZCAkaWdub3JlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byBpZ25vcmVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRpZ25vcmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmlnbm9yZShwYXRoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGlzdCBvZiBwYXRocyB0aGF0IGhhdmUgYmVlbiBkaXJlY3RseSBtb2RpZmllZC4gQSBkaXJlY3RcbiAqIG1vZGlmaWVkIHBhdGggaXMgYSBwYXRoIHRoYXQgeW91IGV4cGxpY2l0bHkgc2V0LCB3aGV0aGVyIHZpYSBgZG9jLmZvbyA9ICdiYXInYCxcbiAqIGBPYmplY3QuYXNzaWduKGRvYywgeyBmb286ICdiYXInIH0pYCwgb3IgYGRvYy5zZXQoJ2ZvbycsICdiYXInKWAuXG4gKlxuICogQSBwYXRoIGBhYCBtYXkgYmUgaW4gYG1vZGlmaWVkUGF0aHMoKWAgYnV0IG5vdCBpbiBgZGlyZWN0TW9kaWZpZWRQYXRocygpYFxuICogYmVjYXVzZSBhIGNoaWxkIG9mIGBhYCB3YXMgZGlyZWN0bHkgbW9kaWZpZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgZm9vOiBTdHJpbmcsIG5lc3RlZDogeyBiYXI6IFN0cmluZyB9IH0pO1xuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIGF3YWl0IE1vZGVsLmNyZWF0ZSh7IGZvbzogJ29yaWdpbmFsJywgbmVzdGVkOiB7IGJhcjogJ29yaWdpbmFsJyB9IH0pO1xuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNb2RlbC5maW5kT25lKCk7XG4gKiAgICAgZG9jLm5lc3RlZC5iYXIgPSAnbW9kaWZpZWQnO1xuICogICAgIGRvYy5kaXJlY3RNb2RpZmllZFBhdGhzKCk7IC8vIFsnbmVzdGVkLmJhciddXG4gKiAgICAgZG9jLm1vZGlmaWVkUGF0aHMoKTsgLy8gWyduZXN0ZWQnLCAnbmVzdGVkLmJhciddXG4gKlxuICogQHJldHVybiB7U3RyaW5nW119XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5kaXJlY3RNb2RpZmllZFBhdGhzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdtb2RpZnknKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0aCBpcyBudWxsaXNoIG9yIG9ubHkgY29udGFpbnMgZW1wdHkgb2JqZWN0cy5cbiAqIFVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGlzIHN1YmRvYyB3aWxsIGdldCBzdHJpcHBlZCBvdXQgYnkgdGhlXG4gKiBbbWluaW1pemUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNtaW5pbWl6ZSkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmVzdGVkOiB7IGZvbzogU3RyaW5nIH0gfSk7XG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKiAgICAgY29uc3QgZG9jID0gbmV3IE1vZGVsKHt9KTtcbiAqICAgICBkb2MuJGlzRW1wdHkoJ25lc3RlZCcpOyAvLyB0cnVlXG4gKiAgICAgZG9jLm5lc3RlZC4kaXNFbXB0eSgpOyAvLyB0cnVlXG4gKlxuICogICAgIGRvYy5uZXN0ZWQuZm9vID0gJ2Jhcic7XG4gKiAgICAgZG9jLiRpc0VtcHR5KCduZXN0ZWQnKTsgLy8gZmFsc2VcbiAqICAgICBkb2MubmVzdGVkLiRpc0VtcHR5KCk7IC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kICRpc0VtcHR5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNFbXB0eSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgY29uc3QgaXNFbXB0eU9wdGlvbnMgPSB7XG4gICAgbWluaW1pemU6IHRydWUsXG4gICAgdmlydHVhbHM6IGZhbHNlLFxuICAgIGdldHRlcnM6IGZhbHNlLFxuICAgIHRyYW5zZm9ybTogZmFsc2VcbiAgfTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLiRnZXQocGF0aCk7XG4gICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzUE9KTyh2KSkge1xuICAgICAgcmV0dXJuIF9pc0VtcHR5KHYpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXModi50b09iamVjdChpc0VtcHR5T3B0aW9ucykpLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRvT2JqZWN0KGlzRW1wdHlPcHRpb25zKSkubGVuZ3RoID09PSAwO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfaXNFbXB0eSh2KSB7XG4gIGlmICh2ID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHYgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModikpIHtcbiAgICBpZiAoIV9pc0VtcHR5KHZba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGlzdCBvZiBwYXRocyB0aGF0IGhhdmUgYmVlbiBtb2RpZmllZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVDaGlsZHJlbj1mYWxzZV0gaWYgdHJ1ZSwgcmV0dXJucyBjaGlsZHJlbiBvZiBtb2RpZmllZCBwYXRocyBhcyB3ZWxsLiBGb3IgZXhhbXBsZSwgaWYgZmFsc2UsIHRoZSBsaXN0IG9mIG1vZGlmaWVkIHBhdGhzIGZvciBgZG9jLmNvbG9ycyA9IHsgcHJpbWFyeTogJ2JsdWUnIH07YCB3aWxsICoqbm90KiogY29udGFpbiBgY29sb3JzLnByaW1hcnlgLiBJZiB0cnVlLCBgbW9kaWZpZWRQYXRocygpYCB3aWxsIHJldHVybiBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGBjb2xvcnMucHJpbWFyeWAuXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLm1vZGlmaWVkUGF0aHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGRpcmVjdE1vZGlmaWVkUGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdtb2RpZnknKSk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcblxuICBsZXQgaSA9IDA7XG4gIGxldCBqID0gMDtcbiAgY29uc3QgbGVuID0gZGlyZWN0TW9kaWZpZWRQYXRocy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY29uc3QgcGF0aCA9IGRpcmVjdE1vZGlmaWVkUGF0aHNbaV07XG4gICAgY29uc3QgcGFydHMgPSBwYXJlbnRQYXRocyhwYXRoKTtcbiAgICBjb25zdCBwTGVuID0gcGFydHMubGVuZ3RoO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHBMZW47ICsraikge1xuICAgICAgcmVzdWx0LmFkZChwYXJ0c1tqXSk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVDaGlsZHJlbikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IGlpID0gMDtcbiAgICBsZXQgY3VyID0gdGhpcy4kZ2V0KHBhdGgpO1xuICAgIGlmICh0eXBlb2YgY3VyID09PSAnb2JqZWN0JyAmJiBjdXIgIT09IG51bGwpIHtcbiAgICAgIGlmIChjdXIuX2RvYykge1xuICAgICAgICBjdXIgPSBjdXIuX2RvYztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlbiA9IGN1ci5sZW5ndGg7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXIpKSB7XG4gICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IGxlbjsgKytpaSkge1xuICAgICAgICAgIGNvbnN0IHN1YlBhdGggPSBwYXRoICsgJy4nICsgaWk7XG4gICAgICAgICAgaWYgKCFyZXN1bHQuaGFzKHN1YlBhdGgpKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKHN1YlBhdGgpO1xuICAgICAgICAgICAgaWYgKGN1cltpaV0gIT0gbnVsbCAmJiBjdXJbaWldLiRfXykge1xuICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZCA9IGN1cltpaV0ubW9kaWZpZWRQYXRocygpO1xuICAgICAgICAgICAgICBsZXQgaWlpID0gMDtcbiAgICAgICAgICAgICAgY29uc3QgaWlpTGVuID0gbW9kaWZpZWQubGVuZ3RoO1xuICAgICAgICAgICAgICBmb3IgKGlpaSA9IDA7IGlpaSA8IGlpaUxlbjsgKytpaWkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkKHN1YlBhdGggKyAnLicgKyBtb2RpZmllZFtpaWldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGN1cik7XG4gICAgICAgIGxldCBpaSA9IDA7XG4gICAgICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBsZW47ICsraWkpIHtcbiAgICAgICAgICByZXN1bHQuYWRkKHBhdGggKyAnLicgKyBrZXlzW2lpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20ocmVzdWx0KTtcbn07XG5cbkRvY3VtZW50LnByb3RvdHlwZVtkb2N1bWVudE1vZGlmaWVkUGF0aHNdID0gRG9jdW1lbnQucHJvdG90eXBlLm1vZGlmaWVkUGF0aHM7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGUgZ2l2ZW4gcGF0aHMgaXMgbW9kaWZpZWQsIGVsc2UgZmFsc2UuIElmIG5vIGFyZ3VtZW50cywgcmV0dXJucyBgdHJ1ZWAgaWYgYW55IHBhdGhcbiAqIGluIHRoaXMgZG9jdW1lbnQgaXMgbW9kaWZpZWQuXG4gKlxuICogSWYgYHBhdGhgIGlzIGdpdmVuLCBjaGVja3MgaWYgYSBwYXRoIG9yIGFueSBmdWxsIHBhdGggY29udGFpbmluZyBgcGF0aGAgYXMgcGFydCBvZiBpdHMgcGF0aCBjaGFpbiBoYXMgYmVlbiBtb2RpZmllZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGRvYy5zZXQoJ2RvY3VtZW50cy4wLnRpdGxlJywgJ2NoYW5nZWQnKTtcbiAqICAgICBkb2MuaXNNb2RpZmllZCgpICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqICAgICBkb2MuaXNNb2RpZmllZCgnZG9jdW1lbnRzJykgICAgICAgICAgIC8vIHRydWVcbiAqICAgICBkb2MuaXNNb2RpZmllZCgnZG9jdW1lbnRzLjAudGl0bGUnKSAgIC8vIHRydWVcbiAqICAgICBkb2MuaXNNb2RpZmllZCgnZG9jdW1lbnRzIG90aGVyUHJvcCcpIC8vIHRydWVcbiAqICAgICBkb2MuaXNEaXJlY3RNb2RpZmllZCgnZG9jdW1lbnRzJykgICAgIC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSBvcHRpb25hbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pZ25vcmVBdG9taWNzPWZhbHNlXSBJZiB0cnVlLCBkb2Vzbid0IHJldHVybiB0cnVlIGlmIHBhdGggaXMgdW5kZXJuZWF0aCBhbiBhcnJheSB0aGF0IHdhcyBtb2RpZmllZCB3aXRoIGF0b21pYyBvcGVyYXRpb25zIGxpa2UgYHB1c2goKWBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5pc01vZGlmaWVkID0gZnVuY3Rpb24ocGF0aHMsIG9wdGlvbnMsIG1vZGlmaWVkUGF0aHMpIHtcbiAgaWYgKHBhdGhzKSB7XG4gICAgY29uc3QgaWdub3JlQXRvbWljcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pZ25vcmVBdG9taWNzO1xuICAgIGNvbnN0IGRpcmVjdE1vZGlmaWVkUGF0aHNPYmogPSB0aGlzLiRfXy5hY3RpdmVQYXRocy5zdGF0ZXMubW9kaWZ5O1xuICAgIGlmIChkaXJlY3RNb2RpZmllZFBhdGhzT2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBhdGhzID09PSAnc3RyaW5nJykge1xuICAgICAgcGF0aHMgPSBwYXRocy5pbmRleE9mKCcgJykgPT09IC0xID8gW3BhdGhzXSA6IHBhdGhzLnNwbGl0KCcgJyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBpZiAoZGlyZWN0TW9kaWZpZWRQYXRoc09ialtwYXRoXSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1vZGlmaWVkID0gbW9kaWZpZWRQYXRocyB8fCB0aGlzW2RvY3VtZW50TW9kaWZpZWRQYXRoc10oKTtcbiAgICBjb25zdCBpc01vZGlmaWVkQ2hpbGQgPSBwYXRocy5zb21lKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiAhIX5tb2RpZmllZC5pbmRleE9mKHBhdGgpO1xuICAgIH0pO1xuXG4gICAgbGV0IGRpcmVjdE1vZGlmaWVkUGF0aHMgPSBPYmplY3Qua2V5cyhkaXJlY3RNb2RpZmllZFBhdGhzT2JqKTtcbiAgICBpZiAoaWdub3JlQXRvbWljcykge1xuICAgICAgZGlyZWN0TW9kaWZpZWRQYXRocyA9IGRpcmVjdE1vZGlmaWVkUGF0aHMuZmlsdGVyKHBhdGggPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlW2FycmF5QXRvbWljc1N5bWJvbF0gIT0gbnVsbCAmJiB2YWx1ZVthcnJheUF0b21pY3NTeW1ib2xdLiRzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaXNNb2RpZmllZENoaWxkIHx8IHBhdGhzLnNvbWUoZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuIGRpcmVjdE1vZGlmaWVkUGF0aHMuc29tZShmdW5jdGlvbihtb2QpIHtcbiAgICAgICAgcmV0dXJuIG1vZCA9PT0gcGF0aCB8fCBwYXRoLnN0YXJ0c1dpdGgobW9kICsgJy4nKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLnNvbWUoJ21vZGlmeScpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBvZiBbYC5pc01vZGlmaWVkYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5pc01vZGlmaWVkKCkpXG4gKlxuICogQG1ldGhvZCAkaXNNb2RpZmllZFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNNb2RpZmllZCA9IERvY3VtZW50LnByb3RvdHlwZS5pc01vZGlmaWVkO1xuXG5Eb2N1bWVudC5wcm90b3R5cGVbZG9jdW1lbnRJc01vZGlmaWVkXSA9IERvY3VtZW50LnByb3RvdHlwZS5pc01vZGlmaWVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHBhdGggaXMgc2V0IHRvIGl0cyBkZWZhdWx0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTXlNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCd0ZXN0JywgeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ1ZhbCAnfSB9KTtcbiAqICAgICBjb25zdCBtID0gbmV3IE15TW9kZWwoKTtcbiAqICAgICBtLiRpc0RlZmF1bHQoJ25hbWUnKTsgLy8gdHJ1ZVxuICpcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAbWV0aG9kICRpc0RlZmF1bHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNEZWZhdWx0ID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLnNvbWUoJ2RlZmF1bHQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgcGF0aC5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2RlZmF1bHQnKS5oYXNPd25Qcm9wZXJ0eShwYXRoKTtcbiAgfVxuXG4gIGxldCBwYXRocyA9IHBhdGg7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICBwYXRocyA9IHBhdGhzLnNwbGl0KCcgJyk7XG4gIH1cblxuICByZXR1cm4gcGF0aHMuc29tZShwYXRoID0+IHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2RlZmF1bHQnKS5oYXNPd25Qcm9wZXJ0eShwYXRoKSk7XG59O1xuXG4vKipcbiAqIEdldHRlci9zZXR0ZXIsIGRldGVybWluZXMgd2hldGhlciB0aGUgZG9jdW1lbnQgd2FzIHJlbW92ZWQgb3Igbm90LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcHJvZHVjdCA9IGF3YWl0IHByb2R1Y3QucmVtb3ZlKCk7XG4gKiAgICAgcHJvZHVjdC4kaXNEZWxldGVkKCk7IC8vIHRydWVcbiAqICAgICBwcm9kdWN0LnJlbW92ZSgpOyAvLyBuby1vcCwgZG9lc24ndCBzZW5kIGFueXRoaW5nIHRvIHRoZSBkYlxuICpcbiAqICAgICBwcm9kdWN0LiRpc0RlbGV0ZWQoZmFsc2UpO1xuICogICAgIHByb2R1Y3QuJGlzRGVsZXRlZCgpOyAvLyBmYWxzZVxuICogICAgIHByb2R1Y3QucmVtb3ZlKCk7IC8vIHdpbGwgZXhlY3V0ZSBhIHJlbW92ZSBhZ2FpbnN0IHRoZSBkYlxuICpcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt2YWxdIG9wdGlvbmFsLCBvdmVycmlkZXMgd2hldGhlciBtb25nb29zZSB0aGlua3MgdGhlIGRvYyBpcyBkZWxldGVkXG4gKiBAcmV0dXJuIHtCb29sZWFufERvY3VtZW50fSB3aGV0aGVyIG1vbmdvb3NlIHRoaW5rcyB0aGlzIGRvYyBpcyBkZWxldGVkLlxuICogQG1ldGhvZCAkaXNEZWxldGVkXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGlzRGVsZXRlZCA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAhIXRoaXMuJF9fLmlzRGVsZXRlZDtcbiAgfVxuXG4gIHRoaXMuJF9fLmlzRGVsZXRlZCA9ICEhdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBwYXRoYCB3YXMgZGlyZWN0bHkgc2V0IGFuZCBtb2RpZmllZCwgZWxzZSBmYWxzZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGRvYy5zZXQoJ2RvY3VtZW50cy4wLnRpdGxlJywgJ2NoYW5nZWQnKTtcbiAqICAgICBkb2MuaXNEaXJlY3RNb2RpZmllZCgnZG9jdW1lbnRzLjAudGl0bGUnKSAvLyB0cnVlXG4gKiAgICAgZG9jLmlzRGlyZWN0TW9kaWZpZWQoJ2RvY3VtZW50cycpIC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IFtwYXRoXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmlzRGlyZWN0TW9kaWZpZWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmIChwYXRoID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy4kX18uYWN0aXZlUGF0aHMuc29tZSgnbW9kaWZ5Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmIHBhdGguaW5kZXhPZignICcpID09PSAtMSkge1xuICAgIGNvbnN0IHJlcyA9IHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpLmhhc093blByb3BlcnR5KHBhdGgpO1xuICAgIGlmIChyZXMgfHwgcGF0aC5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGNvbnN0IHBpZWNlcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGNvbnN0IHN1YnBhdGggPSBwaWVjZXMuc2xpY2UoMCwgaSArIDEpLmpvaW4oJy4nKTtcbiAgICAgIGNvbnN0IHN1YmRvYyA9IHRoaXMuJGdldChzdWJwYXRoKTtcbiAgICAgIGlmIChzdWJkb2MgIT0gbnVsbCAmJiBzdWJkb2MuJF9fICE9IG51bGwgJiYgc3ViZG9jLmlzRGlyZWN0TW9kaWZpZWQocGllY2VzLnNsaWNlKGkgKyAxKS5qb2luKCcuJykpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCBwYXRocyA9IHBhdGg7XG4gIGlmICh0eXBlb2YgcGF0aHMgPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aHMgPSBwYXRocy5zcGxpdCgnICcpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhzLnNvbWUocGF0aCA9PiB0aGlzLmlzRGlyZWN0TW9kaWZpZWQocGF0aCkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGluIHRoZSBgaW5pdGAgc3RhdGUsIHRoYXQgaXMsIGl0IHdhcyBzZXQgYnkgYERvY3VtZW50I2luaXQoKWAgYW5kIG5vdCBtb2RpZmllZCBzaW5jZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaXNJbml0ID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLnNvbWUoJ2luaXQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgcGF0aC5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2luaXQnKS5oYXNPd25Qcm9wZXJ0eShwYXRoKTtcbiAgfVxuXG4gIGxldCBwYXRocyA9IHBhdGg7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICBwYXRocyA9IHBhdGhzLnNwbGl0KCcgJyk7XG4gIH1cblxuICByZXR1cm4gcGF0aHMuc29tZShwYXRoID0+IHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2luaXQnKS5oYXNPd25Qcm9wZXJ0eShwYXRoKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgd2FzIHNlbGVjdGVkIGluIHRoZSBzb3VyY2UgcXVlcnkgd2hpY2ggaW5pdGlhbGl6ZWQgdGhpcyBkb2N1bWVudC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IFRoaW5nLmZpbmRPbmUoKS5zZWxlY3QoJ25hbWUnKTtcbiAqICAgICBkb2MuaXNTZWxlY3RlZCgnbmFtZScpIC8vIHRydWVcbiAqICAgICBkb2MuaXNTZWxlY3RlZCgnYWdlJykgIC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24gaXNTZWxlY3RlZChwYXRoKSB7XG4gIGlmICh0aGlzLiRfXy5zZWxlY3RlZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFwYXRoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChwYXRoID09PSAnX2lkJykge1xuICAgIHJldHVybiB0aGlzLiRfXy5zZWxlY3RlZC5faWQgIT09IDA7XG4gIH1cblxuICBpZiAocGF0aC5pbmRleE9mKCcgJykgIT09IC0xKSB7XG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJyAnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBwYXRoLnNvbWUocCA9PiB0aGlzLiRfX2lzU2VsZWN0ZWQocCkpO1xuICB9XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLiRfXy5zZWxlY3RlZCk7XG4gIGxldCBpbmNsdXNpdmUgPSBudWxsO1xuXG4gIGlmIChwYXRocy5sZW5ndGggPT09IDEgJiYgcGF0aHNbMF0gPT09ICdfaWQnKSB7XG4gICAgLy8gb25seSBfaWQgd2FzIHNlbGVjdGVkLlxuICAgIHJldHVybiB0aGlzLiRfXy5zZWxlY3RlZC5faWQgPT09IDA7XG4gIH1cblxuICBmb3IgKGNvbnN0IGN1ciBvZiBwYXRocykge1xuICAgIGlmIChjdXIgPT09ICdfaWQnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFpc0RlZmluaW5nUHJvamVjdGlvbih0aGlzLiRfXy5zZWxlY3RlZFtjdXJdKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluY2x1c2l2ZSA9ICEhdGhpcy4kX18uc2VsZWN0ZWRbY3VyXTtcbiAgICBicmVhaztcbiAgfVxuXG4gIGlmIChpbmNsdXNpdmUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwYXRoIGluIHRoaXMuJF9fLnNlbGVjdGVkKSB7XG4gICAgcmV0dXJuIGluY2x1c2l2ZTtcbiAgfVxuXG4gIGNvbnN0IHBhdGhEb3QgPSBwYXRoICsgJy4nO1xuXG4gIGZvciAoY29uc3QgY3VyIG9mIHBhdGhzKSB7XG4gICAgaWYgKGN1ciA9PT0gJ19pZCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjdXIuc3RhcnRzV2l0aChwYXRoRG90KSkge1xuICAgICAgcmV0dXJuIGluY2x1c2l2ZSB8fCBjdXIgIT09IHBhdGhEb3Q7XG4gICAgfVxuXG4gICAgaWYgKHBhdGhEb3Quc3RhcnRzV2l0aChjdXIgKyAnLicpKSB7XG4gICAgICByZXR1cm4gaW5jbHVzaXZlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gIWluY2x1c2l2ZTtcbn07XG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19pc1NlbGVjdGVkID0gRG9jdW1lbnQucHJvdG90eXBlLmlzU2VsZWN0ZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCB3YXMgZXhwbGljaXRseSBzZWxlY3RlZC4gSWYgbm8gcHJvamVjdGlvbiwgYWx3YXlzIHJldHVybnNcbiAqIHRydWUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBUaGluZy5maW5kT25lKCkuc2VsZWN0KCduZXN0ZWQubmFtZScpLmV4ZWMoZnVuY3Rpb24gKGVyciwgZG9jKSB7XG4gKiAgICAgICAgZG9jLmlzRGlyZWN0U2VsZWN0ZWQoJ25lc3RlZC5uYW1lJykgLy8gdHJ1ZVxuICogICAgICAgIGRvYy5pc0RpcmVjdFNlbGVjdGVkKCduZXN0ZWQub3RoZXJOYW1lJykgLy8gZmFsc2VcbiAqICAgICAgICBkb2MuaXNEaXJlY3RTZWxlY3RlZCgnbmVzdGVkJykgIC8vIGZhbHNlXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmlzRGlyZWN0U2VsZWN0ZWQgPSBmdW5jdGlvbiBpc0RpcmVjdFNlbGVjdGVkKHBhdGgpIHtcbiAgaWYgKHRoaXMuJF9fLnNlbGVjdGVkID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwYXRoID09PSAnX2lkJykge1xuICAgIHJldHVybiB0aGlzLiRfXy5zZWxlY3RlZC5faWQgIT09IDA7XG4gIH1cblxuICBpZiAocGF0aC5pbmRleE9mKCcgJykgIT09IC0xKSB7XG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJyAnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBwYXRoLnNvbWUocCA9PiB0aGlzLmlzRGlyZWN0U2VsZWN0ZWQocCkpO1xuICB9XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLiRfXy5zZWxlY3RlZCk7XG4gIGxldCBpbmNsdXNpdmUgPSBudWxsO1xuXG4gIGlmIChwYXRocy5sZW5ndGggPT09IDEgJiYgcGF0aHNbMF0gPT09ICdfaWQnKSB7XG4gICAgLy8gb25seSBfaWQgd2FzIHNlbGVjdGVkLlxuICAgIHJldHVybiB0aGlzLiRfXy5zZWxlY3RlZC5faWQgPT09IDA7XG4gIH1cblxuICBmb3IgKGNvbnN0IGN1ciBvZiBwYXRocykge1xuICAgIGlmIChjdXIgPT09ICdfaWQnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFpc0RlZmluaW5nUHJvamVjdGlvbih0aGlzLiRfXy5zZWxlY3RlZFtjdXJdKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluY2x1c2l2ZSA9ICEhdGhpcy4kX18uc2VsZWN0ZWRbY3VyXTtcbiAgICBicmVhaztcbiAgfVxuXG4gIGlmIChpbmNsdXNpdmUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0aGlzLiRfXy5zZWxlY3RlZC5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgIHJldHVybiBpbmNsdXNpdmU7XG4gIH1cblxuICByZXR1cm4gIWluY2x1c2l2ZTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgcmVnaXN0ZXJlZCB2YWxpZGF0aW9uIHJ1bGVzIGZvciB0aGlzIGRvY3VtZW50LlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYHByZWAgc2F2ZSBhbmQgaWYgYSB2YWxpZGF0aW9uIHJ1bGUgaXMgdmlvbGF0ZWQsIFtzYXZlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwucHJvdG90eXBlLnNhdmUoKSkgaXMgYWJvcnRlZCBhbmQgdGhlIGVycm9yIGlzIHRocm93bi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IGRvYy52YWxpZGF0ZSh7IHZhbGlkYXRlTW9kaWZpZWRPbmx5OiBmYWxzZSwgcGF0aHNUb1NraXA6IFsnbmFtZScsICdlbWFpbCddfSk7XG4gKlxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IFtwYXRoc1RvVmFsaWRhdGVdIGxpc3Qgb2YgcGF0aHMgdG8gdmFsaWRhdGUuIElmIHNldCwgTW9uZ29vc2Ugd2lsbCB2YWxpZGF0ZSBvbmx5IHRoZSBtb2RpZmllZCBwYXRocyB0aGF0IGFyZSBpbiB0aGUgZ2l2ZW4gbGlzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gaW50ZXJuYWwgb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seT1mYWxzZV0gaWYgYHRydWVgIG1vbmdvb3NlIHZhbGlkYXRlcyBvbmx5IG1vZGlmaWVkIHBhdGhzLlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IFtvcHRpb25zLnBhdGhzVG9Ta2lwXSBsaXN0IG9mIHBhdGhzIHRvIHNraXAuIElmIHNldCwgTW9uZ29vc2Ugd2lsbCB2YWxpZGF0ZSBldmVyeSBtb2RpZmllZCBwYXRoIHRoYXQgaXMgbm90IGluIHRoaXMgbGlzdC5cbiAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgYSBQcm9taXNlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGUgPSBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZShwYXRoc1RvVmFsaWRhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXRoc1RvVmFsaWRhdGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdEb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgbGV0IHBhcmFsbGVsVmFsaWRhdGU7XG4gIHRoaXMuJG9wID0gJ3ZhbGlkYXRlJztcblxuICBpZiAodGhpcy4kaXNTdWJkb2N1bWVudCAhPSBudWxsKSB7XG4gICAgLy8gU2tpcCBwYXJhbGxlbCB2YWxpZGF0ZSBjaGVjayBmb3Igc3ViZG9jdW1lbnRzXG4gIH0gZWxzZSBpZiAodGhpcy4kX18udmFsaWRhdGluZykge1xuICAgIHBhcmFsbGVsVmFsaWRhdGUgPSBuZXcgUGFyYWxsZWxWYWxpZGF0ZUVycm9yKHRoaXMsIHtcbiAgICAgIHBhcmVudFN0YWNrOiBvcHRpb25zICYmIG9wdGlvbnMucGFyZW50U3RhY2ssXG4gICAgICBjb25mbGljdFN0YWNrOiB0aGlzLiRfXy52YWxpZGF0aW5nLnN0YWNrXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy4kX18udmFsaWRhdGluZyA9IG5ldyBQYXJhbGxlbFZhbGlkYXRlRXJyb3IodGhpcywgeyBwYXJlbnRTdGFjazogb3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudFN0YWNrIH0pO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHBhdGhzVG9WYWxpZGF0ZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnBhdGhzVG9Ta2lwID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGlzT25lUGF0aE9ubHkgPSBvcHRpb25zLnBhdGhzVG9Ta2lwLmluZGV4T2YoJyAnKSA9PT0gLTE7XG4gICAgb3B0aW9ucy5wYXRoc1RvU2tpcCA9IGlzT25lUGF0aE9ubHkgPyBbb3B0aW9ucy5wYXRoc1RvU2tpcF0gOiBvcHRpb25zLnBhdGhzVG9Ta2lwLnNwbGl0KCcgJyk7XG4gIH1cblxuICBpZiAocGFyYWxsZWxWYWxpZGF0ZSAhPSBudWxsKSB7XG4gICAgdGhyb3cgcGFyYWxsZWxWYWxpZGF0ZTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy4kX192YWxpZGF0ZShwYXRoc1RvVmFsaWRhdGUsIG9wdGlvbnMsIChlcnJvcikgPT4ge1xuICAgICAgdGhpcy4kb3AgPSBudWxsO1xuICAgICAgdGhpcy4kX18udmFsaWRhdGluZyA9IG51bGw7XG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIG9mIFtgLnZhbGlkYXRlYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZSgpKVxuICpcbiAqIEBtZXRob2QgJHZhbGlkYXRlXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiR2YWxpZGF0ZSA9IERvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXZhbHVhdGVSZXF1aXJlZEZ1bmN0aW9ucyhkb2MpIHtcbiAgY29uc3QgcmVxdWlyZWRGaWVsZHMgPSBPYmplY3Qua2V5cyhkb2MuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ3JlcXVpcmUnKSk7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuID0gcmVxdWlyZWRGaWVsZHMubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjb25zdCBwYXRoID0gcmVxdWlyZWRGaWVsZHNbaV07XG5cbiAgICBjb25zdCBwID0gZG9jLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xuXG4gICAgaWYgKHAgIT0gbnVsbCAmJiB0eXBlb2YgcC5vcmlnaW5hbFJlcXVpcmVkVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRvYy4kX18uY2FjaGVkUmVxdWlyZWQgPSBkb2MuJF9fLmNhY2hlZFJlcXVpcmVkIHx8IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jLiRfXy5jYWNoZWRSZXF1aXJlZFtwYXRoXSA9IHAub3JpZ2luYWxSZXF1aXJlZFZhbHVlLmNhbGwoZG9jLCBkb2MpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRvYy5pbnZhbGlkYXRlKHBhdGgsIGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2dldFBhdGhzVG9WYWxpZGF0ZShkb2MsIHBhdGhzVG9WYWxpZGF0ZSwgcGF0aHNUb1NraXApIHtcbiAgY29uc3QgZG9WYWxpZGF0ZU9wdGlvbnMgPSB7fTtcblxuICBfZXZhbHVhdGVSZXF1aXJlZEZ1bmN0aW9ucyhkb2MpO1xuICAvLyBvbmx5IHZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkcyB3aGVuIG5lY2Vzc2FyeVxuICBsZXQgcGF0aHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygncmVxdWlyZScpKS5maWx0ZXIoZnVuY3Rpb24ocGF0aCkge1xuICAgIGlmICghZG9jLiRfX2lzU2VsZWN0ZWQocGF0aCkgJiYgIWRvYy4kaXNNb2RpZmllZChwYXRoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZG9jLiRfXy5jYWNoZWRSZXF1aXJlZCAhPSBudWxsICYmIHBhdGggaW4gZG9jLiRfXy5jYWNoZWRSZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGRvYy4kX18uY2FjaGVkUmVxdWlyZWRbcGF0aF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KSk7XG5cbiAgT2JqZWN0LmtleXMoZG9jLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdpbml0JykpLmZvckVhY2goYWRkVG9QYXRocyk7XG4gIE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykpLmZvckVhY2goYWRkVG9QYXRocyk7XG4gIE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnZGVmYXVsdCcpKS5mb3JFYWNoKGFkZFRvUGF0aHMpO1xuICBmdW5jdGlvbiBhZGRUb1BhdGhzKHApIHsgcGF0aHMuYWRkKHApOyB9XG5cbiAgY29uc3Qgc3ViZG9jcyA9IGRvYy4kZ2V0QWxsU3ViZG9jcygpO1xuICBjb25zdCBtb2RpZmllZFBhdGhzID0gZG9jLm1vZGlmaWVkUGF0aHMoKTtcbiAgZm9yIChjb25zdCBzdWJkb2Mgb2Ygc3ViZG9jcykge1xuICAgIGlmIChzdWJkb2MuJGJhc2VQYXRoKSB7XG4gICAgICBjb25zdCBmdWxsUGF0aFRvU3ViZG9jID0gc3ViZG9jLiRpc1NpbmdsZU5lc3RlZCA/IHN1YmRvYy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCgpIDogc3ViZG9jLiRfX2Z1bGxQYXRoV2l0aEluZGV4ZXMoKTtcblxuICAgICAgLy8gUmVtb3ZlIGNoaWxkIHBhdGhzIGZvciBub3csIGJlY2F1c2Ugd2UnbGwgYmUgdmFsaWRhdGluZyB0aGUgd2hvbGVcbiAgICAgIC8vIHN1YmRvYy5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgYSBmYXN0ZXIgdGFrZSBvbiBsb29waW5nIHRocm91Z2ggZXZlcnkgcGF0aCBpbiBgcGF0aHNgXG4gICAgICAvLyBhbmQgY2hlY2tpbmcgaWYgdGhlIHBhdGggc3RhcnRzIHdpdGggYGZ1bGxQYXRoVG9TdWJkb2NgIHJlOiBnaC0xMzE5MVxuICAgICAgZm9yIChjb25zdCBtb2RpZmllZFBhdGggb2Ygc3ViZG9jLm1vZGlmaWVkUGF0aHMoKSkge1xuICAgICAgICBwYXRocy5kZWxldGUoZnVsbFBhdGhUb1N1YmRvYyArICcuJyArIG1vZGlmaWVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb2MuJGlzTW9kaWZpZWQoZnVsbFBhdGhUb1N1YmRvYywgbnVsbCwgbW9kaWZpZWRQYXRocykgJiZcbiAgICAgICAgICAgICFkb2MuaXNEaXJlY3RNb2RpZmllZChmdWxsUGF0aFRvU3ViZG9jKSAmJlxuICAgICAgICAgICAgIWRvYy4kaXNEZWZhdWx0KGZ1bGxQYXRoVG9TdWJkb2MpKSB7XG4gICAgICAgIHBhdGhzLmFkZChmdWxsUGF0aFRvU3ViZG9jKTtcbiAgICAgICAgaWYgKGRvYy4kX18ucGF0aHNUb1Njb3BlcyA9PSBudWxsKSB7XG4gICAgICAgICAgZG9jLiRfXy5wYXRoc1RvU2NvcGVzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZG9jLiRfXy5wYXRoc1RvU2NvcGVzW2Z1bGxQYXRoVG9TdWJkb2NdID0gc3ViZG9jLiRpc0RvY3VtZW50QXJyYXlFbGVtZW50ID9cbiAgICAgICAgICBzdWJkb2MuX19wYXJlbnRBcnJheSA6XG4gICAgICAgICAgc3ViZG9jLiRwYXJlbnQoKTtcblxuICAgICAgICBkb1ZhbGlkYXRlT3B0aW9uc1tmdWxsUGF0aFRvU3ViZG9jXSA9IHsgc2tpcFNjaGVtYVZhbGlkYXRvcnM6IHRydWUgfTtcbiAgICAgICAgaWYgKHN1YmRvYy4kaXNEb2N1bWVudEFycmF5RWxlbWVudCAmJiBzdWJkb2MuX19pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgZG9WYWxpZGF0ZU9wdGlvbnNbZnVsbFBhdGhUb1N1YmRvY10uaW5kZXggPSBzdWJkb2MuX19pbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGNvbnN0IF9wYXRoVHlwZSA9IGRvYy4kX19zY2hlbWEucGF0aChwYXRoKTtcbiAgICBpZiAoIV9wYXRoVHlwZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKF9wYXRoVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgIGZvciAoY29uc3QgcCBvZiBwYXRocykge1xuICAgICAgICBpZiAocCA9PSBudWxsIHx8IHAuc3RhcnRzV2l0aChfcGF0aFR5cGUucGF0aCArICcuJykpIHtcbiAgICAgICAgICBwYXRocy5kZWxldGUocCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPcHRpbWl6YXRpb246IGlmIHByaW1pdGl2ZSBwYXRoIHdpdGggbm8gdmFsaWRhdG9ycywgb3IgYXJyYXkgb2YgcHJpbWl0aXZlc1xuICAgIC8vIHdpdGggbm8gdmFsaWRhdG9ycywgc2tpcCB2YWxpZGF0aW5nIHRoaXMgcGF0aCBlbnRpcmVseS5cbiAgICBpZiAoIV9wYXRoVHlwZS5jYXN0ZXIgJiYgX3BhdGhUeXBlLnZhbGlkYXRvcnMubGVuZ3RoID09PSAwICYmICFfcGF0aFR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5KSB7XG4gICAgICBwYXRocy5kZWxldGUocGF0aCk7XG4gICAgfSBlbHNlIGlmIChfcGF0aFR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJlxuICAgICAgIV9wYXRoVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiYgLy8gU2tpcCBkb2N1bWVudCBhcnJheXMuLi5cbiAgICAgICFfcGF0aFR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS4kaXNNb25nb29zZUFycmF5ICYmIC8vIGFuZCBhcnJheXMgb2YgYXJyYXlzXG4gICAgICBfcGF0aFR5cGUudmFsaWRhdG9ycy5sZW5ndGggPT09IDAgJiYgLy8gYW5kIGFycmF5cyB3aXRoIHRvcC1sZXZlbCB2YWxpZGF0b3JzXG4gICAgICBfcGF0aFR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS52YWxpZGF0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcGF0aHMuZGVsZXRlKHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIC8vIFNpbmdsZSBuZXN0ZWQgcGF0aHMgKHBhdGhzIGVtYmVkZGVkIHVuZGVyIHNpbmdsZSBuZXN0ZWQgc3ViZG9jcykgd2lsbFxuICAgIC8vIGJlIHZhbGlkYXRlZCBvbiB0aGVpciBvd24gd2hlbiB3ZSBjYWxsIGB2YWxpZGF0ZSgpYCBvbiB0aGUgc3ViZG9jIGl0c2VsZi5cbiAgICAvLyBSZTogZ2gtODQ2OFxuICAgIGlmIChkb2MuJF9fc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgICBwYXRocy5kZWxldGUocGF0aCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoc1RvVmFsaWRhdGUpKSB7XG4gICAgcGF0aHMgPSBfaGFuZGxlUGF0aHNUb1ZhbGlkYXRlKHBhdGhzLCBwYXRoc1RvVmFsaWRhdGUpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGF0aHNUb1NraXApKSB7XG4gICAgcGF0aHMgPSBfaGFuZGxlUGF0aHNUb1NraXAocGF0aHMsIHBhdGhzVG9Ta2lwKTtcbiAgfVxuXG4gIC8vIGZyb20gaGVyZSBvbiB3ZSdyZSBub3QgcmVtb3ZpbmcgaXRlbXMgZnJvbSBwYXRoc1xuXG4gIC8vIGdoLTY2MTogaWYgYSB3aG9sZSBhcnJheSBpcyBtb2RpZmllZCwgbWFrZSBzdXJlIHRvIHJ1biB2YWxpZGF0aW9uIG9uIGFsbFxuICAvLyB0aGUgY2hpbGRyZW4gYXMgd2VsbFxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBfcGF0aFR5cGUgPSBkb2MuJF9fc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgaWYgKCFfcGF0aFR5cGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghX3BhdGhUeXBlLiRpc01vbmdvb3NlQXJyYXkgfHxcbiAgICAgICAgLy8gVG8gYXZvaWQgcG90ZW50aWFsIHBlcmZvcm1hbmNlIGlzc3Vlcywgc2tpcCBkb2MgYXJyYXlzIHdob3NlIGNoaWxkcmVuXG4gICAgICAgIC8vIGFyZSBub3QgcmVxdWlyZWQuIGBnZXRQb3NpdGlvbmFsUGF0aFR5cGUoKWAgbWF5IGJlIHNsb3csIHNvIGF2b2lkXG4gICAgICAgIC8vIGl0IHVubGVzcyB3ZSBoYXZlIGEgY2FzZSBvZiAjNjM2NFxuICAgICAgICAoIUFycmF5LmlzQXJyYXkoX3BhdGhUeXBlKSAmJlxuICAgICAgICAgIF9wYXRoVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiZcbiAgICAgICAgICAhKF9wYXRoVHlwZSAmJiBfcGF0aFR5cGUuc2NoZW1hT3B0aW9ucyAmJiBfcGF0aFR5cGUuc2NoZW1hT3B0aW9ucy5yZXF1aXJlZCkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBnaC0xMTM4MDogb3B0aW1pemF0aW9uLiBJZiB0aGUgYXJyYXkgaXNuJ3QgYSBkb2N1bWVudCBhcnJheSBhbmQgdGhlcmUncyBubyB2YWxpZGF0b3JzXG4gICAgLy8gb24gdGhlIGFycmF5IHR5cGUsIHRoZXJlJ3Mgbm8gbmVlZCB0byBydW4gdmFsaWRhdGlvbiBvbiB0aGUgaW5kaXZpZHVhbCBhcnJheSBlbGVtZW50cy5cbiAgICBpZiAoX3BhdGhUeXBlLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgICAgIV9wYXRoVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiYgLy8gU2tpcCBkb2N1bWVudCBhcnJheXMuLi5cbiAgICAgICAgIV9wYXRoVHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkgJiYgLy8gYW5kIGFycmF5cyBvZiBhcnJheXNcbiAgICAgICAgX3BhdGhUeXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUudmFsaWRhdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbCA9IGRvYy4kX19nZXRWYWx1ZShwYXRoKTtcbiAgICBfcHVzaE5lc3RlZEFycmF5UGF0aHModmFsLCBwYXRocywgcGF0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBfcHVzaE5lc3RlZEFycmF5UGF0aHModmFsLCBwYXRocywgcGF0aCkge1xuICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbnVtRWxlbWVudHMgPSB2YWwubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1FbGVtZW50czsgKytqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbFtqXSkpIHtcbiAgICAgICAgICBfcHVzaE5lc3RlZEFycmF5UGF0aHModmFsW2pdLCBwYXRocywgcGF0aCArICcuJyArIGopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhzLmFkZChwYXRoICsgJy4nICsgaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBmbGF0dGVuT3B0aW9ucyA9IHsgc2tpcEFycmF5czogdHJ1ZSB9O1xuICBmb3IgKGNvbnN0IHBhdGhUb0NoZWNrIG9mIHBhdGhzKSB7XG4gICAgaWYgKGRvYy4kX19zY2hlbWEubmVzdGVkW3BhdGhUb0NoZWNrXSkge1xuICAgICAgbGV0IF92ID0gZG9jLiRfX2dldFZhbHVlKHBhdGhUb0NoZWNrKTtcbiAgICAgIGlmIChpc01vbmdvb3NlT2JqZWN0KF92KSkge1xuICAgICAgICBfdiA9IF92LnRvT2JqZWN0KHsgdHJhbnNmb3JtOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZsYXQgPSBmbGF0dGVuKF92LCBwYXRoVG9DaGVjaywgZmxhdHRlbk9wdGlvbnMsIGRvYy4kX19zY2hlbWEpO1xuICAgICAgT2JqZWN0LmtleXMoZmxhdCkuZm9yRWFjaChhZGRUb1BhdGhzKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBfcGF0aFR5cGUgPSBkb2MuJF9fc2NoZW1hLnBhdGgocGF0aCk7XG5cbiAgICBpZiAoIV9wYXRoVHlwZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSWYgdW5kZXJuZWF0aCBhIGRvY3VtZW50IGFycmF5LCBtYXkgbmVlZCB0byByZS12YWxpZGF0ZSB0aGUgcGFyZW50XG4gICAgLy8gYXJyYXkgcmU6IGdoLTY4MTguIERvIHRoaXMgX2FmdGVyXyBhZGRpbmcgc3VicGF0aHMsIGJlY2F1c2VcbiAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGFkZCBldmVyeSBhcnJheSBzdWJwYXRoLlxuICAgIGlmIChfcGF0aFR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5ICYmIHR5cGVvZiBfcGF0aFR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5LnBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXRocy5hZGQoX3BhdGhUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheS5wYXRoKTtcbiAgICB9XG5cbiAgICBpZiAoIV9wYXRoVHlwZS4kaXNTY2hlbWFNYXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbCA9IGRvYy4kX19nZXRWYWx1ZShwYXRoKTtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiB2YWwua2V5cygpKSB7XG4gICAgICBwYXRocy5hZGQocGF0aCArICcuJyArIGtleSk7XG4gICAgfVxuICB9XG5cbiAgcGF0aHMgPSBBcnJheS5mcm9tKHBhdGhzKTtcbiAgcmV0dXJuIFtwYXRocywgZG9WYWxpZGF0ZU9wdGlvbnNdO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX192YWxpZGF0ZSA9IGZ1bmN0aW9uKHBhdGhzVG9WYWxpZGF0ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBwYXRoc1RvVmFsaWRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHBhdGhzVG9WYWxpZGF0ZTtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgICBwYXRoc1RvVmFsaWRhdGUgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgY29uc3QgaGFzVmFsaWRhdGVNb2RpZmllZE9ubHlPcHRpb24gPSBvcHRpb25zICYmXG4gICAgICAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSAmJlxuICAgICAgKCd2YWxpZGF0ZU1vZGlmaWVkT25seScgaW4gb3B0aW9ucyk7XG5cbiAgY29uc3QgcGF0aHNUb1NraXAgPSAob3B0aW9ucyAmJiBvcHRpb25zLnBhdGhzVG9Ta2lwKSB8fCBudWxsO1xuXG4gIGxldCBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seTtcbiAgaWYgKGhhc1ZhbGlkYXRlTW9kaWZpZWRPbmx5T3B0aW9uKSB7XG4gICAgc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHkgPSAhIW9wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHk7XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHkgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5O1xuICB9XG5cbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBjb25zdCBfY29tcGxldGUgPSAoKSA9PiB7XG4gICAgbGV0IHZhbGlkYXRpb25FcnJvciA9IHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvcjtcbiAgICB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgPSBudWxsO1xuICAgIHRoaXMuJF9fLnZhbGlkYXRpbmcgPSBudWxsO1xuXG4gICAgaWYgKHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5ICYmIHZhbGlkYXRpb25FcnJvciAhPSBudWxsKSB7XG4gICAgICAvLyBSZW1vdmUgYW55IHZhbGlkYXRpb24gZXJyb3JzIHRoYXQgYXJlbid0IGZyb20gbW9kaWZpZWQgcGF0aHNcbiAgICAgIGNvbnN0IGVycm9ycyA9IE9iamVjdC5rZXlzKHZhbGlkYXRpb25FcnJvci5lcnJvcnMpO1xuICAgICAgZm9yIChjb25zdCBlcnJQYXRoIG9mIGVycm9ycykge1xuICAgICAgICBpZiAoIXRoaXMuJGlzTW9kaWZpZWQoZXJyUGF0aCkpIHtcbiAgICAgICAgICBkZWxldGUgdmFsaWRhdGlvbkVycm9yLmVycm9yc1tlcnJQYXRoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbGlkYXRpb25FcnJvci5lcnJvcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YWxpZGF0aW9uRXJyb3IgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4kX18uY2FjaGVkUmVxdWlyZWQgPSB7fTtcbiAgICB0aGlzLiRlbWl0KCd2YWxpZGF0ZScsIF90aGlzKTtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmVtaXQoJ3ZhbGlkYXRlJywgX3RoaXMpO1xuXG4gICAgaWYgKHZhbGlkYXRpb25FcnJvcikge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsaWRhdGlvbkVycm9yLmVycm9ycykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgY2FzdCBlcnJvcnMgcGVyc2lzdFxuICAgICAgICBpZiAoIXRoaXNbZG9jdW1lbnRBcnJheVBhcmVudF0gJiZcbiAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvci5lcnJvcnNba2V5XSBpbnN0YW5jZW9mIE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKSB7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKGtleSwgdmFsaWRhdGlvbkVycm9yLmVycm9yc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsaWRhdGlvbkVycm9yO1xuICAgIH1cbiAgfTtcblxuICAvLyBvbmx5IHZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkcyB3aGVuIG5lY2Vzc2FyeVxuICBjb25zdCBwYXRoRGV0YWlscyA9IF9nZXRQYXRoc1RvVmFsaWRhdGUodGhpcywgcGF0aHNUb1ZhbGlkYXRlLCBwYXRoc1RvU2tpcCk7XG4gIGNvbnN0IHBhdGhzID0gc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHkgP1xuICAgIHBhdGhEZXRhaWxzWzBdLmZpbHRlcigocGF0aCkgPT4gdGhpcy4kaXNNb2RpZmllZChwYXRoKSkgOlxuICAgIHBhdGhEZXRhaWxzWzBdO1xuICBjb25zdCBkb1ZhbGlkYXRlT3B0aW9uc0J5UGF0aCA9IHBhdGhEZXRhaWxzWzFdO1xuICBpZiAodHlwZW9mIHBhdGhzVG9WYWxpZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXRoc1RvVmFsaWRhdGUgPSBwYXRoc1RvVmFsaWRhdGUuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZXJyb3IgPSBfY29tcGxldGUoKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gX3RoaXMuJF9fc2NoZW1hLnMuaG9va3MuZXhlY1Bvc3QoJ3ZhbGlkYXRlOmVycm9yJywgX3RoaXMsIFtfdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIF90aGlzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRlZCA9IHt9O1xuICBsZXQgdG90YWwgPSAwO1xuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIHZhbGlkYXRlUGF0aChwYXRoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlUGF0aChwYXRoKSB7XG4gICAgaWYgKHBhdGggPT0gbnVsbCB8fCB2YWxpZGF0ZWRbcGF0aF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZWRbcGF0aF0gPSB0cnVlO1xuICAgIHRvdGFsKys7XG5cbiAgICBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBzY2hlbWFUeXBlID0gX3RoaXMuJF9fc2NoZW1hLnBhdGgocGF0aCk7XG5cbiAgICAgIGlmICghc2NoZW1hVHlwZSkge1xuICAgICAgICByZXR1cm4gLS10b3RhbCB8fCBjb21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB1c2VyIG1hcmtlZCBhcyBpbnZhbGlkIG9yIHRoZXJlIHdhcyBhIGNhc3QgZXJyb3IsIGRvbid0IHZhbGlkYXRlXG4gICAgICBpZiAoIV90aGlzLiRpc1ZhbGlkKHBhdGgpKSB7XG4gICAgICAgIC0tdG90YWwgfHwgY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBzZXR0aW5nIGEgcGF0aCB1bmRlciBhIG1peGVkIHBhdGgsIGF2b2lkIHVzaW5nIHRoZSBtaXhlZCBwYXRoIHZhbGlkYXRvciAoZ2gtMTAxNDEpXG4gICAgICBpZiAoc2NoZW1hVHlwZVtzY2hlbWFNaXhlZFN5bWJvbF0gIT0gbnVsbCAmJiBwYXRoICE9PSBzY2hlbWFUeXBlLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuIC0tdG90YWwgfHwgY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHZhbCA9IF90aGlzLiRfX2dldFZhbHVlKHBhdGgpO1xuXG4gICAgICAvLyBJZiB5b3UgYHBvcHVsYXRlKClgIGFuZCBnZXQgYmFjayBhIG51bGwgdmFsdWUsIHJlcXVpcmVkIHZhbGlkYXRvcnNcbiAgICAgIC8vIHNob3VsZG4ndCBmYWlsIChnaC04MDE4KS4gV2Ugc2hvdWxkIGFsd2F5cyBmYWxsIGJhY2sgdG8gdGhlIHBvcHVsYXRlZFxuICAgICAgLy8gdmFsdWUuXG4gICAgICBsZXQgcG9wO1xuICAgICAgaWYgKChwb3AgPSBfdGhpcy4kcG9wdWxhdGVkKHBhdGgpKSkge1xuICAgICAgICB2YWwgPSBwb3A7XG4gICAgICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsICYmIHZhbC4kX18gIT0gbnVsbCAmJiB2YWwuJF9fLndhc1BvcHVsYXRlZCkge1xuICAgICAgICAvLyBBcnJheSBwYXRocywgbGlrZSBgc29tZWFycmF5LjFgLCBkbyBub3Qgc2hvdyB1cCBhcyBwb3B1bGF0ZWQgd2l0aCBgJHBvcHVsYXRlZCgpYCxcbiAgICAgICAgLy8gc28gaW4gdGhhdCBjYXNlIHB1bGwgb3V0IHRoZSBkb2N1bWVudCdzIGlkXG4gICAgICAgIHZhbCA9IHZhbC5faWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBzY29wZSA9IF90aGlzLiRfXy5wYXRoc1RvU2NvcGVzICE9IG51bGwgJiYgcGF0aCBpbiBfdGhpcy4kX18ucGF0aHNUb1Njb3BlcyA/XG4gICAgICAgIF90aGlzLiRfXy5wYXRoc1RvU2NvcGVzW3BhdGhdIDpcbiAgICAgICAgX3RoaXM7XG5cbiAgICAgIGNvbnN0IGRvVmFsaWRhdGVPcHRpb25zID0ge1xuICAgICAgICAuLi5kb1ZhbGlkYXRlT3B0aW9uc0J5UGF0aFtwYXRoXSxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsaWRhdGVNb2RpZmllZE9ubHk6IHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5XG4gICAgICB9O1xuXG4gICAgICBzY2hlbWFUeXBlLmRvVmFsaWRhdGUodmFsLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNvbnN0IGlzU3ViZG9jID0gc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQgfHxcbiAgICAgICAgICAgICAgc2NoZW1hVHlwZS4kaXNBcnJheVN1YmRvY3VtZW50IHx8XG4gICAgICAgICAgICAgIHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5O1xuICAgICAgICAgIGlmIChpc1N1YmRvYyAmJiBlcnIgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAtLXRvdGFsIHx8IGNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLmludmFsaWRhdGUocGF0aCwgZXJyLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC0tdG90YWwgfHwgY29tcGxldGUoKTtcbiAgICAgIH0sIHNjb3BlLCBkb1ZhbGlkYXRlT3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICBjb25zdCBlcnJvciA9IF9jb21wbGV0ZSgpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIF90aGlzLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQb3N0KCd2YWxpZGF0ZTplcnJvcicsIF90aGlzLCBbX3RoaXNdLCB7IGVycm9yOiBlcnJvciB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgX3RoaXMpO1xuICB9XG5cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2hhbmRsZVBhdGhzVG9WYWxpZGF0ZShwYXRocywgcGF0aHNUb1ZhbGlkYXRlKSB7XG4gIGNvbnN0IF9wYXRoc1RvVmFsaWRhdGUgPSBuZXcgU2V0KHBhdGhzVG9WYWxpZGF0ZSk7XG4gIGNvbnN0IHBhcmVudFBhdGhzID0gbmV3IE1hcChbXSk7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoc1RvVmFsaWRhdGUpIHtcbiAgICBpZiAocGF0aC5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGllY2VzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCBjdXIgPSBwaWVjZXNbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwaWVjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIFNpbmNlIHdlIHNraXAgc3VicGF0aHMgdW5kZXIgc2luZ2xlIG5lc3RlZCBzdWJkb2NzIHRvXG4gICAgICAvLyBhdm9pZCBkb3VibGUgdmFsaWRhdGlvbiwgd2UgbmVlZCB0byBhZGQgYmFjayB0aGVcbiAgICAgIC8vIHNpbmdsZSBuZXN0ZWQgc3VicGF0aCBpZiB0aGUgdXNlciBhc2tlZCBmb3IgaXQgKGdoLTg2MjYpXG4gICAgICBwYXJlbnRQYXRocy5zZXQoY3VyLCBwYXRoKTtcbiAgICAgIGN1ciA9IGN1ciArICcuJyArIHBpZWNlc1tpXTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXQgPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGlmIChfcGF0aHNUb1ZhbGlkYXRlLmhhcyhwYXRoKSkge1xuICAgICAgcmV0LmFkZChwYXRoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudFBhdGhzLmhhcyhwYXRoKSkge1xuICAgICAgcmV0LmFkZChwYXJlbnRQYXRocy5nZXQocGF0aCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9oYW5kbGVQYXRoc1RvU2tpcChwYXRocywgcGF0aHNUb1NraXApIHtcbiAgcGF0aHNUb1NraXAgPSBuZXcgU2V0KHBhdGhzVG9Ta2lwKTtcbiAgcGF0aHMgPSBBcnJheS5mcm9tKHBhdGhzKS5maWx0ZXIocCA9PiAhcGF0aHNUb1NraXAuaGFzKHApKTtcbiAgcmV0dXJuIG5ldyBTZXQocGF0aHMpO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIHJlZ2lzdGVyZWQgdmFsaWRhdGlvbiBydWxlcyAoc2tpcHBpbmcgYXN5bmNocm9ub3VzIHZhbGlkYXRvcnMpIGZvciB0aGlzIGRvY3VtZW50LlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgaWYgeW91IG5lZWQgc3luY2hyb25vdXMgdmFsaWRhdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGVyciA9IGRvYy52YWxpZGF0ZVN5bmMoKTtcbiAqICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAvLyB2YWxpZGF0aW9uIHBhc3NlZFxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gW3BhdGhzVG9WYWxpZGF0ZV0gb25seSB2YWxpZGF0ZSB0aGUgZ2l2ZW4gcGF0aHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBmb3IgdmFsaWRhdGlvblxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seT1mYWxzZV0gSWYgYHRydWVgLCBNb25nb29zZSB3aWxsIG9ubHkgdmFsaWRhdGUgbW9kaWZpZWQgcGF0aHMsIGFzIG9wcG9zZWQgdG8gbW9kaWZpZWQgcGF0aHMgYW5kIGByZXF1aXJlZGAgcGF0aHMuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gW29wdGlvbnMucGF0aHNUb1NraXBdIGxpc3Qgb2YgcGF0aHMgdG8gc2tpcC4gSWYgc2V0LCBNb25nb29zZSB3aWxsIHZhbGlkYXRlIGV2ZXJ5IG1vZGlmaWVkIHBhdGggdGhhdCBpcyBub3QgaW4gdGhpcyBsaXN0LlxuICogQHJldHVybiB7VmFsaWRhdGlvbkVycm9yfHVuZGVmaW5lZH0gVmFsaWRhdGlvbkVycm9yIGlmIHRoZXJlIGFyZSBlcnJvcnMgZHVyaW5nIHZhbGlkYXRpb24sIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBlcnJvci5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlU3luYyA9IGZ1bmN0aW9uKHBhdGhzVG9WYWxpZGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgcGF0aHNUb1ZhbGlkYXRlID0gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGhhc1ZhbGlkYXRlTW9kaWZpZWRPbmx5T3B0aW9uID0gb3B0aW9ucyAmJlxuICAgICAgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JykgJiZcbiAgICAgICgndmFsaWRhdGVNb2RpZmllZE9ubHknIGluIG9wdGlvbnMpO1xuXG4gIGxldCBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seTtcbiAgaWYgKGhhc1ZhbGlkYXRlTW9kaWZpZWRPbmx5T3B0aW9uKSB7XG4gICAgc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHkgPSAhIW9wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHk7XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHkgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5O1xuICB9XG5cbiAgbGV0IHBhdGhzVG9Ta2lwID0gb3B0aW9ucyAmJiBvcHRpb25zLnBhdGhzVG9Ta2lwO1xuXG4gIGlmICh0eXBlb2YgcGF0aHNUb1ZhbGlkYXRlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGlzT25lUGF0aE9ubHkgPSBwYXRoc1RvVmFsaWRhdGUuaW5kZXhPZignICcpID09PSAtMTtcbiAgICBwYXRoc1RvVmFsaWRhdGUgPSBpc09uZVBhdGhPbmx5ID8gW3BhdGhzVG9WYWxpZGF0ZV0gOiBwYXRoc1RvVmFsaWRhdGUuc3BsaXQoJyAnKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0aHNUb1NraXAgPT09ICdzdHJpbmcnICYmIHBhdGhzVG9Ta2lwLmluZGV4T2YoJyAnKSAhPT0gLTEpIHtcbiAgICBwYXRoc1RvU2tpcCA9IHBhdGhzVG9Ta2lwLnNwbGl0KCcgJyk7XG4gIH1cblxuICAvLyBvbmx5IHZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkcyB3aGVuIG5lY2Vzc2FyeVxuICBjb25zdCBwYXRoRGV0YWlscyA9IF9nZXRQYXRoc1RvVmFsaWRhdGUodGhpcywgcGF0aHNUb1ZhbGlkYXRlLCBwYXRoc1RvU2tpcCk7XG4gIGNvbnN0IHBhdGhzID0gc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHkgP1xuICAgIHBhdGhEZXRhaWxzWzBdLmZpbHRlcigocGF0aCkgPT4gdGhpcy4kaXNNb2RpZmllZChwYXRoKSkgOlxuICAgIHBhdGhEZXRhaWxzWzBdO1xuICBjb25zdCBza2lwU2NoZW1hVmFsaWRhdG9ycyA9IHBhdGhEZXRhaWxzWzFdO1xuXG4gIGNvbnN0IHZhbGlkYXRpbmcgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGF0aHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjb25zdCBwYXRoID0gcGF0aHNbaV07XG5cbiAgICBpZiAodmFsaWRhdGluZ1twYXRoXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFsaWRhdGluZ1twYXRoXSA9IHRydWU7XG5cbiAgICBjb25zdCBwID0gX3RoaXMuJF9fc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgaWYgKCFwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFfdGhpcy4kaXNWYWxpZChwYXRoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsID0gX3RoaXMuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgY29uc3QgZXJyID0gcC5kb1ZhbGlkYXRlU3luYyh2YWwsIF90aGlzLCB7XG4gICAgICBza2lwU2NoZW1hVmFsaWRhdG9yczogc2tpcFNjaGVtYVZhbGlkYXRvcnNbcGF0aF0sXG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgdmFsaWRhdGVNb2RpZmllZE9ubHk6IHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5XG4gICAgfSk7XG4gICAgaWYgKGVycikge1xuICAgICAgY29uc3QgaXNTdWJkb2MgPSBwLiRpc1NpbmdsZU5lc3RlZCB8fFxuICAgICAgICBwLiRpc0FycmF5U3ViZG9jdW1lbnQgfHxcbiAgICAgICAgcC4kaXNNb25nb29zZURvY3VtZW50QXJyYXk7XG4gICAgICBpZiAoaXNTdWJkb2MgJiYgZXJyIGluc3RhbmNlb2YgVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgX3RoaXMuaW52YWxpZGF0ZShwYXRoLCBlcnIsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZXJyID0gX3RoaXMuJF9fLnZhbGlkYXRpb25FcnJvcjtcbiAgX3RoaXMuJF9fLnZhbGlkYXRpb25FcnJvciA9IHVuZGVmaW5lZDtcbiAgX3RoaXMuJGVtaXQoJ3ZhbGlkYXRlJywgX3RoaXMpO1xuICBfdGhpcy5jb25zdHJ1Y3Rvci5lbWl0KCd2YWxpZGF0ZScsIF90aGlzKTtcblxuICBpZiAoZXJyKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZXJyLmVycm9ycykge1xuICAgICAgLy8gTWFrZSBzdXJlIGNhc3QgZXJyb3JzIHBlcnNpc3RcbiAgICAgIGlmIChlcnIuZXJyb3JzW2tleV0gaW5zdGFuY2VvZiBNb25nb29zZUVycm9yLkNhc3RFcnJvcikge1xuICAgICAgICBfdGhpcy5pbnZhbGlkYXRlKGtleSwgZXJyLmVycm9yc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBNYXJrcyBhIHBhdGggYXMgaW52YWxpZCwgY2F1c2luZyB2YWxpZGF0aW9uIHRvIGZhaWwuXG4gKlxuICogVGhlIGBlcnJvck1zZ2AgYXJndW1lbnQgd2lsbCBiZWNvbWUgdGhlIG1lc3NhZ2Ugb2YgdGhlIGBWYWxpZGF0aW9uRXJyb3JgLlxuICpcbiAqIFRoZSBgdmFsdWVgIGFyZ3VtZW50IChpZiBwYXNzZWQpIHdpbGwgYmUgYXZhaWxhYmxlIHRocm91Z2ggdGhlIGBWYWxpZGF0aW9uRXJyb3IudmFsdWVgIHByb3BlcnR5LlxuICpcbiAqICAgICBkb2MuaW52YWxpZGF0ZSgnc2l6ZScsICdtdXN0IGJlIGxlc3MgdGhhbiAyMCcsIDE0KTtcbiAqXG4gKiAgICAgZG9jLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGVycilcbiAqICAgICAgIC8vIHByaW50c1xuICogICAgICAgeyBtZXNzYWdlOiAnVmFsaWRhdGlvbiBmYWlsZWQnLFxuICogICAgICAgICBuYW1lOiAnVmFsaWRhdGlvbkVycm9yJyxcbiAqICAgICAgICAgZXJyb3JzOlxuICogICAgICAgICAgeyBzaXplOlxuICogICAgICAgICAgICAgeyBtZXNzYWdlOiAnbXVzdCBiZSBsZXNzIHRoYW4gMjAnLFxuICogICAgICAgICAgICAgICBuYW1lOiAnVmFsaWRhdG9yRXJyb3InLFxuICogICAgICAgICAgICAgICBwYXRoOiAnc2l6ZScsXG4gKiAgICAgICAgICAgICAgIHR5cGU6ICd1c2VyIGRlZmluZWQnLFxuICogICAgICAgICAgICAgICB2YWx1ZTogMTQgfSB9IH1cbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBmaWVsZCB0byBpbnZhbGlkYXRlLiBGb3IgYXJyYXkgZWxlbWVudHMsIHVzZSB0aGUgYGFycmF5LmkuZmllbGRgIHN5bnRheCwgd2hlcmUgYGlgIGlzIHRoZSAwLWJhc2VkIGluZGV4IGluIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB7U3RyaW5nfEVycm9yfSBlcnIgdGhlIGVycm9yIHdoaWNoIHN0YXRlcyB0aGUgcmVhc29uIGBwYXRoYCB3YXMgaW52YWxpZFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfE51bWJlcnxhbnl9IHZhbCBvcHRpb25hbCBpbnZhbGlkIHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gW2tpbmRdIG9wdGlvbmFsIGBraW5kYCBwcm9wZXJ0eSBmb3IgdGhlIGVycm9yXG4gKiBAcmV0dXJuIHtWYWxpZGF0aW9uRXJyb3J9IHRoZSBjdXJyZW50IFZhbGlkYXRpb25FcnJvciwgd2l0aCBhbGwgY3VycmVudGx5IGludmFsaWRhdGVkIHBhdGhzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24ocGF0aCwgZXJyLCB2YWwsIGtpbmQpIHtcbiAgaWYgKCF0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IpIHtcbiAgICB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgPSBuZXcgVmFsaWRhdGlvbkVycm9yKHRoaXMpO1xuICB9XG5cbiAgaWYgKHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnNbcGF0aF0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWVyciB8fCB0eXBlb2YgZXJyID09PSAnc3RyaW5nJykge1xuICAgIGVyciA9IG5ldyBWYWxpZGF0b3JFcnJvcih7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgbWVzc2FnZTogZXJyLFxuICAgICAgdHlwZToga2luZCB8fCAndXNlciBkZWZpbmVkJyxcbiAgICAgIHZhbHVlOiB2YWxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgPT09IGVycikge1xuICAgIHJldHVybiB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3I7XG4gIH1cblxuICB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuYWRkRXJyb3IocGF0aCwgZXJyKTtcbiAgcmV0dXJuIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvcjtcbn07XG5cbi8qKlxuICogTWFya3MgYSBwYXRoIGFzIHZhbGlkLCByZW1vdmluZyBleGlzdGluZyB2YWxpZGF0aW9uIGVycm9ycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgZmllbGQgdG8gbWFyayBhcyB2YWxpZFxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAbWV0aG9kICRtYXJrVmFsaWRcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJG1hcmtWYWxpZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYgKCF0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgfHwgIXRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnNbcGF0aF0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkZWxldGUgdGhpcy4kX18udmFsaWRhdGlvbkVycm9yLmVycm9yc1twYXRoXTtcbiAgaWYgKE9iamVjdC5rZXlzKHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvciA9IG51bGw7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX21hcmtWYWxpZFN1YnBhdGhzKGRvYywgcGF0aCkge1xuICBpZiAoIWRvYy4kX18udmFsaWRhdGlvbkVycm9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRvYy4kX18udmFsaWRhdGlvbkVycm9yLmVycm9ycyk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgocGF0aCArICcuJykpIHtcbiAgICAgIGRlbGV0ZSBkb2MuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKGRvYy4kX18udmFsaWRhdGlvbkVycm9yLmVycm9ycykubGVuZ3RoID09PSAwKSB7XG4gICAgZG9jLiRfXy52YWxpZGF0aW9uRXJyb3IgPSBudWxsO1xuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2NoZWNrSW1tdXRhYmxlU3VicGF0aHMoc3ViZG9jLCBzY2hlbWF0eXBlLCBwcmlvclZhbCkge1xuICBjb25zdCBzY2hlbWEgPSBzY2hlbWF0eXBlLnNjaGVtYTtcbiAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKSkge1xuICAgIGNvbnN0IHBhdGggPSBzY2hlbWEucGF0aHNba2V5XTtcbiAgICBpZiAocGF0aC4kaW1tdXRhYmxlU2V0dGVyID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBvbGRWYWwgPSBwcmlvclZhbCA9PSBudWxsID8gdm9pZCAwIDogcHJpb3JWYWwuJF9fZ2V0VmFsdWUoa2V5KTtcbiAgICAvLyBDYWxsaW5nIGltbXV0YWJsZVNldHRlciB3aXRoIGBvbGRWYWxgIGV2ZW4gdGhvdWdoIGl0IGV4cGVjdHMgYG5ld1ZhbGBcbiAgICAvLyBpcyBpbnRlbnRpb25hbC4gVGhhdCdzIGJlY2F1c2UgYCRpbW11dGFibGVTZXR0ZXJgIGNvbXBhcmVzIGl0cyBwYXJhbVxuICAgIC8vIHRvIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgIHBhdGguJGltbXV0YWJsZVNldHRlci5jYWxsKHN1YmRvYywgb2xkVmFsKTtcbiAgfVxufVxuXG4vKipcbiAqIFNhdmVzIHRoaXMgZG9jdW1lbnQgYnkgaW5zZXJ0aW5nIGEgbmV3IGRvY3VtZW50IGludG8gdGhlIGRhdGFiYXNlIGlmIFtkb2N1bWVudC5pc05ld10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5pc05ldygpKSBpcyBgdHJ1ZWAsXG4gKiBvciBzZW5kcyBhbiBbdXBkYXRlT25lXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnVwZGF0ZU9uZSgpKSBvcGVyYXRpb24gKipvbmx5Kiogd2l0aCB0aGUgbW9kaWZpY2F0aW9ucyB0byB0aGUgZGF0YWJhc2UsIGl0IGRvZXMgbm90IHJlcGxhY2UgdGhlIHdob2xlIGRvY3VtZW50IGluIHRoZSBsYXR0ZXIgY2FzZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHByb2R1Y3Quc29sZCA9IERhdGUubm93KCk7XG4gKiAgICAgcHJvZHVjdCA9IGF3YWl0IHByb2R1Y3Quc2F2ZSgpO1xuICpcbiAqIElmIHNhdmUgaXMgc3VjY2Vzc2Z1bCwgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBmdWxmaWxsIHdpdGggdGhlIGRvY3VtZW50XG4gKiBzYXZlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG5ld1Byb2R1Y3QgPSBhd2FpdCBwcm9kdWN0LnNhdmUoKTtcbiAqICAgICBuZXdQcm9kdWN0ID09PSBwcm9kdWN0OyAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSB0aGUgW3Nlc3Npb25dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9zZXJ2ZXItc2Vzc2lvbnMvKSBhc3NvY2lhdGVkIHdpdGggdGhpcyBzYXZlIG9wZXJhdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gdGhlIFtkb2N1bWVudCdzIGFzc29jaWF0ZWQgc2Vzc2lvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS4kc2Vzc2lvbigpKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zYWZlXSAoREVQUkVDQVRFRCkgb3ZlcnJpZGVzIFtzY2hlbWEncyBzYWZlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc2FmZSkuIFVzZSB0aGUgYHdgIG9wdGlvbiBpbnN0ZWFkLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52YWxpZGF0ZUJlZm9yZVNhdmVdIHNldCB0byBmYWxzZSB0byBzYXZlIHdpdGhvdXQgdmFsaWRhdGluZy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHk9ZmFsc2VdIElmIGB0cnVlYCwgTW9uZ29vc2Ugd2lsbCBvbmx5IHZhbGlkYXRlIG1vZGlmaWVkIHBhdGhzLCBhcyBvcHBvc2VkIHRvIG1vZGlmaWVkIHBhdGhzIGFuZCBgcmVxdWlyZWRgIHBhdGhzLlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbb3B0aW9ucy53XSBzZXQgdGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jdy1vcHRpb24pLiBPdmVycmlkZXMgdGhlIFtzY2hlbWEtbGV2ZWwgYHdyaXRlQ29uY2VybmAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmpdIHNldCB0byB0cnVlIGZvciBNb25nb0RCIHRvIHdhaXQgdW50aWwgdGhpcyBgc2F2ZSgpYCBoYXMgYmVlbiBbam91cm5hbGVkIGJlZm9yZSByZXNvbHZpbmcgdGhlIHJldHVybmVkIHByb21pc2VdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyNqLW9wdGlvbikuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCBgd3JpdGVDb25jZXJuYCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53dGltZW91dF0gc2V0cyBhIFt0aW1lb3V0IGZvciB0aGUgd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3d0aW1lb3V0KS4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIGB3cml0ZUNvbmNlcm5gIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2hlY2tLZXlzPXRydWVdIHRoZSBNb25nb0RCIGRyaXZlciBwcmV2ZW50cyB5b3UgZnJvbSBzYXZpbmcga2V5cyB0aGF0IHN0YXJ0IHdpdGggJyQnIG9yIGNvbnRhaW4gJy4nIGJ5IGRlZmF1bHQuIFNldCB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHRvIHNraXAgdGhhdCBjaGVjay4gU2VlIFtyZXN0cmljdGlvbnMgb24gZmllbGQgbmFtZXNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9saW1pdHMvI1Jlc3RyaWN0aW9ucy1vbi1GaWVsZC1OYW1lcylcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz10cnVlXSBpZiBgZmFsc2VgIGFuZCBbdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyBgc2F2ZSgpYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIEBtZXRob2Qgc2F2ZVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEB0aHJvd3Mge0RvY3VtZW50Tm90Rm91bmRFcnJvcn0gaWYgdGhpcyBbc2F2ZSB1cGRhdGVzIGFuIGV4aXN0aW5nIGRvY3VtZW50XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLmlzTmV3KCkpIGJ1dCB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdCBpbiB0aGUgZGF0YWJhc2UuIEZvciBleGFtcGxlLCB5b3Ugd2lsbCBnZXQgdGhpcyBlcnJvciBpZiB0aGUgZG9jdW1lbnQgaXMgW2RlbGV0ZWQgYmV0d2VlbiB3aGVuIHlvdSByZXRyaWV2ZWQgdGhlIGRvY3VtZW50IGFuZCB3aGVuIHlvdSBzYXZlZCBpdF0oZG9jdW1lbnRzLmh0bWwjdXBkYXRpbmcpLlxuICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgdW5kZWZpbmVkIGlmIHVzZWQgd2l0aCBjYWxsYmFjayBvciBhIFByb21pc2Ugb3RoZXJ3aXNlLlxuICogQGFwaSBwdWJsaWNcbiAqIEBzZWUgbWlkZGxld2FyZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbWlkZGxld2FyZS5odG1sXG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwYXRoIGlzIGludmFsaWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gW3BhdGhdIHRoZSBmaWVsZCB0byBjaGVjay4gSWYgdW5zZXQgd2lsbCBhbHdheXMgcmV0dXJuIFwiZmFsc2VcIlxuICogQG1ldGhvZCAkaXNWYWxpZFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNWYWxpZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYgKHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvciA9PSBudWxsIHx8IE9iamVjdC5rZXlzKHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwYXRoID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocGF0aC5pbmRleE9mKCcgJykgIT09IC0xKSB7XG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJyAnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBwYXRoLnNvbWUocCA9PiB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzW3BdID09IG51bGwpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnNbcGF0aF0gPT0gbnVsbDtcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoZSBpbnRlcm5hbCBtb2RpZmllZCBzdGF0ZSBvZiB0aGlzIGRvY3VtZW50LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHJldHVybiB7RG9jdW1lbnR9IHRoaXNcbiAqIEBtZXRob2QgJF9fcmVzZXRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3Jlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gIGxldCBfdGhpcyA9IHRoaXM7XG5cbiAgLy8gU2tpcCBmb3Igc3ViZG9jdW1lbnRzXG4gIGNvbnN0IHN1YmRvY3MgPSB0aGlzLiRwYXJlbnQoKSA9PT0gdGhpcyA/IHRoaXMuJGdldEFsbFN1YmRvY3MoKSA6IFtdO1xuICBjb25zdCByZXNldEFycmF5cyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBzdWJkb2Mgb2Ygc3ViZG9jcykge1xuICAgIGNvbnN0IGZ1bGxQYXRoV2l0aEluZGV4ZXMgPSBzdWJkb2MuJF9fZnVsbFBhdGhXaXRoSW5kZXhlcygpO1xuICAgIHN1YmRvYy4kX19yZXNldCgpO1xuICAgIGlmICh0aGlzLmlzTW9kaWZpZWQoZnVsbFBhdGhXaXRoSW5kZXhlcykgfHwgaXNQYXJlbnRJbml0KGZ1bGxQYXRoV2l0aEluZGV4ZXMpKSB7XG4gICAgICBpZiAoc3ViZG9jLiRpc0RvY3VtZW50QXJyYXlFbGVtZW50KSB7XG4gICAgICAgIHJlc2V0QXJyYXlzLmFkZChzdWJkb2MucGFyZW50QXJyYXkoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBzdWJkb2MuJHBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50ID09PSB0aGlzKSB7XG4gICAgICAgICAgdGhpcy4kX18uYWN0aXZlUGF0aHMuY2xlYXJQYXRoKHN1YmRvYy4kYmFzZVBhdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC4kaXNTdWJkb2N1bWVudCkge1xuICAgICAgICAgIC8vIElmIG1hcCBwYXRoIHVuZGVybmVhdGggc3ViZG9jdW1lbnQsIG1heSBlbmQgdXAgd2l0aCBhIGNhc2Ugd2hlcmVcbiAgICAgICAgICAvLyBtYXAgcGF0aCBpcyBtb2RpZmllZCBidXQgcGFyZW50IHN0aWxsIG5lZWRzIHRvIGJlIHJlc2V0LiBTZWUgZ2gtMTAyOTVcbiAgICAgICAgICBwYXJlbnQuJF9fcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgYXJyYXkgb2YgcmVzZXRBcnJheXMpIHtcbiAgICB0aGlzLiRfXy5hY3RpdmVQYXRocy5jbGVhclBhdGgoYXJyYXkuJHBhdGgoKSk7XG4gICAgYXJyYXlbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXSA9IGFycmF5W2FycmF5QXRvbWljc1N5bWJvbF07XG4gICAgYXJyYXlbYXJyYXlBdG9taWNzU3ltYm9sXSA9IHt9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXJlbnRJbml0KHBhdGgpIHtcbiAgICBwYXRoID0gcGF0aC5pbmRleE9mKCcuJykgPT09IC0xID8gW3BhdGhdIDogcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCBjdXIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICAgIGN1ciArPSAoY3VyLmxlbmd0aCA/ICcuJyA6ICcnKSArIHBhdGhbaV07XG4gICAgICBpZiAoX3RoaXMuJF9fLmFjdGl2ZVBhdGhzW2N1cl0gPT09ICdpbml0Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBjbGVhciBhdG9taWNzXG4gIHRoaXMuJF9fZGlydHkoKS5mb3JFYWNoKGZ1bmN0aW9uKGRpcnQpIHtcbiAgICBjb25zdCB0eXBlID0gZGlydC52YWx1ZTtcblxuICAgIGlmICh0eXBlICYmIHR5cGVbYXJyYXlBdG9taWNzU3ltYm9sXSkge1xuICAgICAgdHlwZVthcnJheUF0b21pY3NCYWNrdXBTeW1ib2xdID0gdHlwZVthcnJheUF0b21pY3NTeW1ib2xdO1xuICAgICAgdHlwZVthcnJheUF0b21pY3NTeW1ib2xdID0ge307XG4gICAgfVxuICB9KTtcblxuICB0aGlzLiRfXy5iYWNrdXAgPSB7fTtcbiAgdGhpcy4kX18uYmFja3VwLmFjdGl2ZVBhdGhzID0ge1xuICAgIG1vZGlmeTogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykpLFxuICAgIGRlZmF1bHQ6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2RlZmF1bHQnKSlcbiAgfTtcbiAgdGhpcy4kX18uYmFja3VwLnZhbGlkYXRpb25FcnJvciA9IHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvcjtcbiAgdGhpcy4kX18uYmFja3VwLmVycm9ycyA9IHRoaXMuJGVycm9ycztcblxuICAvLyBDbGVhciAnZGlydHknIGNhY2hlXG4gIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmNsZWFyKCdtb2RpZnknKTtcbiAgdGhpcy4kX18uYWN0aXZlUGF0aHMuY2xlYXIoJ2RlZmF1bHQnKTtcbiAgdGhpcy4kX18udmFsaWRhdGlvbkVycm9yID0gdW5kZWZpbmVkO1xuICB0aGlzLiRlcnJvcnMgPSB1bmRlZmluZWQ7XG4gIF90aGlzID0gdGhpcztcbiAgdGhpcy4kX19zY2hlbWEucmVxdWlyZWRQYXRocygpLmZvckVhY2goZnVuY3Rpb24ocGF0aCkge1xuICAgIF90aGlzLiRfXy5hY3RpdmVQYXRocy5yZXF1aXJlKHBhdGgpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3VuZG9SZXNldCA9IGZ1bmN0aW9uICRfX3VuZG9SZXNldCgpIHtcbiAgaWYgKHRoaXMuJF9fLmJhY2t1cCA9PSBudWxsIHx8IHRoaXMuJF9fLmJhY2t1cC5hY3RpdmVQYXRocyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy4kX18uYWN0aXZlUGF0aHMuc3RhdGVzLm1vZGlmeSA9IHRoaXMuJF9fLmJhY2t1cC5hY3RpdmVQYXRocy5tb2RpZnk7XG4gIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLnN0YXRlcy5kZWZhdWx0ID0gdGhpcy4kX18uYmFja3VwLmFjdGl2ZVBhdGhzLmRlZmF1bHQ7XG5cbiAgdGhpcy4kX18udmFsaWRhdGlvbkVycm9yID0gdGhpcy4kX18uYmFja3VwLnZhbGlkYXRpb25FcnJvcjtcbiAgdGhpcy4kZXJyb3JzID0gdGhpcy4kX18uYmFja3VwLmVycm9ycztcblxuICBmb3IgKGNvbnN0IGRpcnQgb2YgdGhpcy4kX19kaXJ0eSgpKSB7XG4gICAgY29uc3QgdHlwZSA9IGRpcnQudmFsdWU7XG5cbiAgICBpZiAodHlwZSAmJiB0eXBlW2FycmF5QXRvbWljc1N5bWJvbF0gJiYgdHlwZVthcnJheUF0b21pY3NCYWNrdXBTeW1ib2xdKSB7XG4gICAgICB0eXBlW2FycmF5QXRvbWljc1N5bWJvbF0gPSB0eXBlW2FycmF5QXRvbWljc0JhY2t1cFN5bWJvbF07XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBzdWJkb2Mgb2YgdGhpcy4kZ2V0QWxsU3ViZG9jcygpKSB7XG4gICAgc3ViZG9jLiRfX3VuZG9SZXNldCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBkb2N1bWVudHMgZGlydHkgcGF0aHMgLyB2YWxzLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX2RpcnR5XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19kaXJ0eSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGxldCBhbGwgPSB0aGlzLiRfXy5hY3RpdmVQYXRocy5tYXAoJ21vZGlmeScsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIHZhbHVlOiBfdGhpcy4kX19nZXRWYWx1ZShwYXRoKSxcbiAgICAgIHNjaGVtYTogX3RoaXMuJF9fcGF0aChwYXRoKVxuICAgIH07XG4gIH0pO1xuXG4gIC8vIGdoLTI1NTg6IGlmIHdlIGhhZCB0byBzZXQgYSBkZWZhdWx0IGFuZCB0aGUgdmFsdWUgaXMgbm90IHVuZGVmaW5lZCxcbiAgLy8gd2UgaGF2ZSB0byBzYXZlIGFzIHdlbGxcbiAgYWxsID0gYWxsLmNvbmNhdCh0aGlzLiRfXy5hY3RpdmVQYXRocy5tYXAoJ2RlZmF1bHQnLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKHBhdGggPT09ICdfaWQnIHx8IF90aGlzLiRfX2dldFZhbHVlKHBhdGgpID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB2YWx1ZTogX3RoaXMuJF9fZ2V0VmFsdWUocGF0aCksXG4gICAgICBzY2hlbWE6IF90aGlzLiRfX3BhdGgocGF0aClcbiAgICB9O1xuICB9KSk7XG5cbiAgY29uc3QgYWxsUGF0aHMgPSBuZXcgTWFwKGFsbC5maWx0ZXIoKGVsKSA9PiBlbCAhPSBudWxsKS5tYXAoKGVsKSA9PiBbZWwucGF0aCwgZWwudmFsdWVdKSk7XG4gIC8vIElnbm9yZSBcImZvby5hXCIgaWYgXCJmb29cIiBpcyBkaXJ0eSBhbHJlYWR5LlxuICBjb25zdCBtaW5pbWFsID0gW107XG5cbiAgYWxsLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgIGlmICghaXRlbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB0b3AgPSBudWxsO1xuXG4gICAgY29uc3QgYXJyYXkgPSBwYXJlbnRQYXRocyhpdGVtLnBhdGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBpZiAoYWxsUGF0aHMuaGFzKGFycmF5W2ldKSkge1xuICAgICAgICB0b3AgPSBhbGxQYXRocy5nZXQoYXJyYXlbaV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRvcCA9PSBudWxsKSB7XG4gICAgICBtaW5pbWFsLnB1c2goaXRlbSk7XG4gICAgfSBlbHNlIGlmICh0b3AgIT0gbnVsbCAmJlxuICAgICAgICB0b3BbYXJyYXlBdG9taWNzU3ltYm9sXSAhPSBudWxsICYmXG4gICAgICAgIHRvcC5oYXNBdG9taWNzKCkpIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgdG9wIGxldmVsIE1vbmdvb3NlQXJyYXlzXG4gICAgICAvLyB0aGUgYHRvcGAgYXJyYXkgaXRzZWxmIGFuZCBhIHN1YiBwYXRoIG9mIGB0b3BgIGFyZSBiZWluZyBzZXQuXG4gICAgICAvLyB0aGUgb25seSB3YXkgdG8gaG9ub3IgYWxsIG9mIGJvdGggbW9kaWZpY2F0aW9ucyBpcyB0aHJvdWdoIGEgJHNldFxuICAgICAgLy8gb2YgZW50aXJlIGFycmF5LlxuICAgICAgdG9wW2FycmF5QXRvbWljc1N5bWJvbF0gPSB7fTtcbiAgICAgIHRvcFthcnJheUF0b21pY3NTeW1ib2xdLiRzZXQgPSB0b3A7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1pbmltYWw7XG59O1xuXG4vKipcbiAqIEFzc2lnbnMvY29tcGlsZXMgYHNjaGVtYWAgaW50byB0aGlzIGRvY3VtZW50cyBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX3NldFNjaGVtYVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fc2V0U2NoZW1hID0gZnVuY3Rpb24oc2NoZW1hKSB7XG4gIGNvbXBpbGUoc2NoZW1hLnRyZWUsIHRoaXMsIHVuZGVmaW5lZCwgc2NoZW1hLm9wdGlvbnMpO1xuXG4gIC8vIEFwcGx5IGRlZmF1bHQgZ2V0dGVycyBpZiB2aXJ0dWFsIGRvZXNuJ3QgaGF2ZSBhbnkgKGdoLTYyNjIpXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYS52aXJ0dWFscykpIHtcbiAgICBzY2hlbWEudmlydHVhbHNba2V5XS5fYXBwbHlEZWZhdWx0R2V0dGVycygpO1xuICB9XG4gIGlmIChzY2hlbWEucGF0aCgnc2NoZW1hJykgPT0gbnVsbCkge1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICB9XG4gIHRoaXMuJF9fc2NoZW1hID0gc2NoZW1hO1xuICB0aGlzW2RvY3VtZW50U2NoZW1hU3ltYm9sXSA9IHNjaGVtYTtcbn07XG5cblxuLyoqXG4gKiBHZXQgYWN0aXZlIHBhdGggdGhhdCB3ZXJlIGNoYW5nZWQgYW5kIGFyZSBhcnJheXNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19nZXRBcnJheVBhdGhzVG9WYWxpZGF0ZVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fZ2V0QXJyYXlQYXRoc1RvVmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgRG9jdW1lbnRBcnJheSB8fCAoRG9jdW1lbnRBcnJheSA9IHJlcXVpcmUoJy4vdHlwZXMvRG9jdW1lbnRBcnJheScpKTtcblxuICAvLyB2YWxpZGF0ZSBhbGwgZG9jdW1lbnQgYXJyYXlzLlxuICByZXR1cm4gdGhpcy4kX18uYWN0aXZlUGF0aHNcbiAgICAubWFwKCdpbml0JywgJ21vZGlmeScsIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiB0aGlzLiRfX2dldFZhbHVlKGkpO1xuICAgIH0uYmluZCh0aGlzKSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCAmJiBBcnJheS5pc0FycmF5KHZhbCkgJiYgdXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbihzZWVkLCBhcnJheSkge1xuICAgICAgcmV0dXJuIHNlZWQuY29uY2F0KGFycmF5KTtcbiAgICB9LCBbXSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKGRvYykge1xuICAgICAgcmV0dXJuIGRvYztcbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBHZXQgYWxsIHN1YmRvY3MgKGJ5IGJmcylcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kICRnZXRBbGxTdWJkb2NzXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kZ2V0QWxsU3ViZG9jcyA9IGZ1bmN0aW9uKCkge1xuICBEb2N1bWVudEFycmF5IHx8IChEb2N1bWVudEFycmF5ID0gcmVxdWlyZSgnLi90eXBlcy9Eb2N1bWVudEFycmF5JykpO1xuICBFbWJlZGRlZCA9IEVtYmVkZGVkIHx8IHJlcXVpcmUoJy4vdHlwZXMvQXJyYXlTdWJkb2N1bWVudCcpO1xuXG4gIGZ1bmN0aW9uIGRvY1JlZHVjZXIoZG9jLCBzZWVkLCBwYXRoKSB7XG4gICAgbGV0IHZhbCA9IGRvYztcbiAgICBsZXQgaXNOZXN0ZWQgPSBmYWxzZTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgaWYgKGRvYyBpbnN0YW5jZW9mIERvY3VtZW50ICYmIGRvY1tkb2N1bWVudFNjaGVtYVN5bWJvbF0ucGF0aHNbcGF0aF0pIHtcbiAgICAgICAgdmFsID0gZG9jLl9kb2NbcGF0aF07XG4gICAgICB9IGVsc2UgaWYgKGRvYyBpbnN0YW5jZW9mIERvY3VtZW50ICYmIGRvY1tkb2N1bWVudFNjaGVtYVN5bWJvbF0ubmVzdGVkW3BhdGhdKSB7XG4gICAgICAgIHZhbCA9IGRvYy5fZG9jW3BhdGhdO1xuICAgICAgICBpc05lc3RlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBkb2NbcGF0aF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFbWJlZGRlZCkge1xuICAgICAgc2VlZC5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIHNlZWQgPSBBcnJheS5mcm9tKHZhbC5rZXlzKCkpLnJlZHVjZShmdW5jdGlvbihzZWVkLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBkb2NSZWR1Y2VyKHZhbC5nZXQocGF0aCksIHNlZWQsIG51bGwpO1xuICAgICAgfSwgc2VlZCk7XG4gICAgfSBlbHNlIGlmICh2YWwgJiYgIUFycmF5LmlzQXJyYXkodmFsKSAmJiB2YWwuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICBzZWVkID0gT2JqZWN0LmtleXModmFsLl9kb2MpLnJlZHVjZShmdW5jdGlvbihzZWVkLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBkb2NSZWR1Y2VyKHZhbCwgc2VlZCwgcGF0aCk7XG4gICAgICB9LCBzZWVkKTtcbiAgICAgIHNlZWQucHVzaCh2YWwpO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbCkpIHtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uIF9kb2NSZWR1Y2UoZG9jKSB7XG4gICAgICAgIGlmICghZG9jIHx8ICFkb2MuX2RvYykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWVkID0gT2JqZWN0LmtleXMoZG9jLl9kb2MpLnJlZHVjZShmdW5jdGlvbihzZWVkLCBwYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY1JlZHVjZXIoZG9jLl9kb2MsIHNlZWQsIHBhdGgpO1xuICAgICAgICB9LCBzZWVkKTtcbiAgICAgICAgaWYgKGRvYyBpbnN0YW5jZW9mIEVtYmVkZGVkKSB7XG4gICAgICAgICAgc2VlZC5wdXNoKGRvYyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNOZXN0ZWQgJiYgdmFsICE9IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBPYmplY3Qua2V5cyh2YWwpKSB7XG4gICAgICAgIGRvY1JlZHVjZXIodmFsLCBzZWVkLCBwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlZWQ7XG4gIH1cblxuICBjb25zdCBzdWJEb2NzID0gW107XG4gIGZvciAoY29uc3QgcGF0aCBvZiBPYmplY3Qua2V5cyh0aGlzLl9kb2MpKSB7XG4gICAgZG9jUmVkdWNlcih0aGlzLCBzdWJEb2NzLCBwYXRoKTtcbiAgfVxuXG4gIHJldHVybiBzdWJEb2NzO1xufTtcblxuLyohXG4gKiBSdW5zIHF1ZXVlZCBmdW5jdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVF1ZXVlKGRvYykge1xuICBjb25zdCBxID0gZG9jLiRfX3NjaGVtYSAmJiBkb2MuJF9fc2NoZW1hLmNhbGxRdWV1ZTtcbiAgaWYgKCFxLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoY29uc3QgcGFpciBvZiBxKSB7XG4gICAgaWYgKHBhaXJbMF0gIT09ICdwcmUnICYmIHBhaXJbMF0gIT09ICdwb3N0JyAmJiBwYWlyWzBdICE9PSAnb24nKSB7XG4gICAgICBkb2NbcGFpclswXV0uYXBwbHkoZG9jLCBwYWlyWzFdKTtcbiAgICB9XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9faGFuZGxlUmVqZWN0ID0gZnVuY3Rpb24gaGFuZGxlUmVqZWN0KGVycikge1xuICAvLyBlbWl0IG9uIHRoZSBNb2RlbCBpZiBsaXN0ZW5pbmdcbiAgaWYgKHRoaXMuJGxpc3RlbmVycygnZXJyb3InKS5sZW5ndGgpIHtcbiAgICB0aGlzLiRlbWl0KCdlcnJvcicsIGVycik7XG4gIH0gZWxzZSBpZiAodGhpcy5jb25zdHJ1Y3Rvci5saXN0ZW5lcnMgJiYgdGhpcy5jb25zdHJ1Y3Rvci5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZvciB0b09iamVjdCgpIGFuZCB0b0pTT04oKSB0aGF0IGRvZXNuJ3QgbWFuaXB1bGF0ZSBvcHRpb25zXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICR0b09iamVjdFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJHRvT2JqZWN0ID0gZnVuY3Rpb24ob3B0aW9ucywganNvbikge1xuICBsZXQgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgdHJhbnNmb3JtOiB0cnVlLFxuICAgIGZsYXR0ZW5EZWNpbWFsczogdHJ1ZVxuICB9O1xuXG4gIGNvbnN0IHBhdGggPSBqc29uID8gJ3RvSlNPTicgOiAndG9PYmplY3QnO1xuICBjb25zdCBiYXNlT3B0aW9ucyA9IHRoaXMuY29uc3RydWN0b3IgJiZcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmJhc2UgJiZcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmJhc2Uub3B0aW9ucyAmJlxuICAgIGdldCh0aGlzLmNvbnN0cnVjdG9yLmJhc2Uub3B0aW9ucywgcGF0aCkgfHwge307XG4gIGNvbnN0IHNjaGVtYU9wdGlvbnMgPSB0aGlzLiRfX3NjaGVtYSAmJiB0aGlzLiRfX3NjaGVtYS5vcHRpb25zIHx8IHt9O1xuICAvLyBtZXJnZSBiYXNlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIFNjaGVtYSdzIHNldCBkZWZhdWx0IG9wdGlvbnMgaWYgYXZhaWxhYmxlLlxuICAvLyBgY2xvbmVgIGlzIG5lY2Vzc2FyeSBoZXJlIGJlY2F1c2UgYHV0aWxzLm9wdGlvbnNgIGRpcmVjdGx5IG1vZGlmaWVzIHRoZSBzZWNvbmQgaW5wdXQuXG4gIGRlZmF1bHRPcHRpb25zID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4uYmFzZU9wdGlvbnMsIC4uLnNjaGVtYU9wdGlvbnNbcGF0aF0gfTtcblxuICAvLyBJZiBvcHRpb25zIGRvIG5vdCBleGlzdCBvciBpcyBub3QgYW4gb2JqZWN0LCBzZXQgaXQgdG8gZW1wdHkgb2JqZWN0XG4gIG9wdGlvbnMgPSB1dGlscy5pc1BPSk8ob3B0aW9ucykgPyB7IC4uLm9wdGlvbnMgfSA6IHt9O1xuICBvcHRpb25zLl9jYWxsZWRXaXRoT3B0aW9ucyA9IG9wdGlvbnMuX2NhbGxlZFdpdGhPcHRpb25zIHx8IHsgLi4ub3B0aW9ucyB9O1xuXG4gIGxldCBfbWluaW1pemU7XG4gIGlmIChvcHRpb25zLl9jYWxsZWRXaXRoT3B0aW9ucy5taW5pbWl6ZSAhPSBudWxsKSB7XG4gICAgX21pbmltaXplID0gb3B0aW9ucy5taW5pbWl6ZTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0T3B0aW9ucy5taW5pbWl6ZSAhPSBudWxsKSB7XG4gICAgX21pbmltaXplID0gZGVmYXVsdE9wdGlvbnMubWluaW1pemU7XG4gIH0gZWxzZSB7XG4gICAgX21pbmltaXplID0gc2NoZW1hT3B0aW9ucy5taW5pbWl6ZTtcbiAgfVxuXG4gIGxldCBmbGF0dGVuTWFwcztcbiAgaWYgKG9wdGlvbnMuX2NhbGxlZFdpdGhPcHRpb25zLmZsYXR0ZW5NYXBzICE9IG51bGwpIHtcbiAgICBmbGF0dGVuTWFwcyA9IG9wdGlvbnMuZmxhdHRlbk1hcHM7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdE9wdGlvbnMuZmxhdHRlbk1hcHMgIT0gbnVsbCkge1xuICAgIGZsYXR0ZW5NYXBzID0gZGVmYXVsdE9wdGlvbnMuZmxhdHRlbk1hcHM7XG4gIH0gZWxzZSB7XG4gICAgZmxhdHRlbk1hcHMgPSBzY2hlbWFPcHRpb25zLmZsYXR0ZW5NYXBzO1xuICB9XG5cbiAgbGV0IGZsYXR0ZW5PYmplY3RJZHM7XG4gIGlmIChvcHRpb25zLl9jYWxsZWRXaXRoT3B0aW9ucy5mbGF0dGVuT2JqZWN0SWRzICE9IG51bGwpIHtcbiAgICBmbGF0dGVuT2JqZWN0SWRzID0gb3B0aW9ucy5mbGF0dGVuT2JqZWN0SWRzO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRPcHRpb25zLmZsYXR0ZW5PYmplY3RJZHMgIT0gbnVsbCkge1xuICAgIGZsYXR0ZW5PYmplY3RJZHMgPSBkZWZhdWx0T3B0aW9ucy5mbGF0dGVuT2JqZWN0SWRzO1xuICB9IGVsc2Uge1xuICAgIGZsYXR0ZW5PYmplY3RJZHMgPSBzY2hlbWFPcHRpb25zLmZsYXR0ZW5PYmplY3RJZHM7XG4gIH1cblxuICAvLyBUaGUgb3JpZ2luYWwgb3B0aW9ucyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIGBjbG9uZSgpYC4gSW1wb3J0YW50IGJlY2F1c2VcbiAgLy8gYGNsb25lKClgIHdpbGwgcmVjdXJzaXZlbHkgY2FsbCBgJHRvT2JqZWN0KClgIG9uIGVtYmVkZGVkIGRvY3MsIHNvIHdlXG4gIC8vIG5lZWQgdGhlIG9yaWdpbmFsIG9wdGlvbnMgdGhlIHVzZXIgcGFzc2VkIGluLCBwbHVzIGBfaXNOZXN0ZWRgIGFuZFxuICAvLyBgX3BhcmVudE9wdGlvbnNgIGZvciBjaGVja2luZyB3aGV0aGVyIHdlIG5lZWQgdG8gZGVwb3B1bGF0ZS5cbiAgY29uc3QgY2xvbmVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgIF9pc05lc3RlZDogdHJ1ZSxcbiAgICBqc29uOiBqc29uLFxuICAgIG1pbmltaXplOiBfbWluaW1pemUsXG4gICAgZmxhdHRlbk1hcHM6IGZsYXR0ZW5NYXBzLFxuICAgIGZsYXR0ZW5PYmplY3RJZHM6IGZsYXR0ZW5PYmplY3RJZHMsXG4gICAgX3NlZW46IChvcHRpb25zICYmIG9wdGlvbnMuX3NlZW4pIHx8IG5ldyBNYXAoKVxuICB9KTtcblxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvcHRpb25zLCAnZ2V0dGVycycpKSB7XG4gICAgY2xvbmVPcHRpb25zLmdldHRlcnMgPSBvcHRpb25zLmdldHRlcnM7XG4gIH1cbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkob3B0aW9ucywgJ3ZpcnR1YWxzJykpIHtcbiAgICBjbG9uZU9wdGlvbnMudmlydHVhbHMgPSBvcHRpb25zLnZpcnR1YWxzO1xuICB9XG5cbiAgY29uc3QgZGVwb3B1bGF0ZSA9IG9wdGlvbnMuZGVwb3B1bGF0ZSB8fFxuICAgIChvcHRpb25zLl9wYXJlbnRPcHRpb25zICYmIG9wdGlvbnMuX3BhcmVudE9wdGlvbnMuZGVwb3B1bGF0ZSB8fCBmYWxzZSk7XG4gIC8vIF9pc05lc3RlZCB3aWxsIG9ubHkgYmUgdHJ1ZSBpZiB0aGlzIGlzIG5vdCB0aGUgdG9wIGxldmVsIGRvY3VtZW50LCB3ZVxuICAvLyBzaG91bGQgbmV2ZXIgZGVwb3B1bGF0ZSB0aGUgdG9wLWxldmVsIGRvY3VtZW50XG4gIGlmIChkZXBvcHVsYXRlICYmIG9wdGlvbnMuX2lzTmVzdGVkICYmIHRoaXMuJF9fLndhc1BvcHVsYXRlZCkge1xuICAgIHJldHVybiBjbG9uZSh0aGlzLiRfXy53YXNQb3B1bGF0ZWQudmFsdWUgfHwgdGhpcy5faWQsIGNsb25lT3B0aW9ucyk7XG4gIH1cblxuICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCBpbnB1dCBvcHRpb25zLlxuICBvcHRpb25zID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICBvcHRpb25zLl9pc05lc3RlZCA9IHRydWU7XG4gIG9wdGlvbnMuanNvbiA9IGpzb247XG4gIG9wdGlvbnMubWluaW1pemUgPSBfbWluaW1pemU7XG5cbiAgY2xvbmVPcHRpb25zLl9wYXJlbnRPcHRpb25zID0gb3B0aW9ucztcbiAgY2xvbmVPcHRpb25zLl9za2lwU2luZ2xlTmVzdGVkR2V0dGVycyA9IGZhbHNlO1xuXG4gIGNvbnN0IGdldHRlcnNPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgY2xvbmVPcHRpb25zKTtcbiAgZ2V0dGVyc09wdGlvbnMuX3NraXBTaW5nbGVOZXN0ZWRHZXR0ZXJzID0gdHJ1ZTtcblxuICAvLyByZW1lbWJlciB0aGUgcm9vdCB0cmFuc2Zvcm0gZnVuY3Rpb25cbiAgLy8gdG8gc2F2ZSBpdCBmcm9tIGJlaW5nIG92ZXJ3cml0dGVuIGJ5IHN1Yi10cmFuc2Zvcm0gZnVuY3Rpb25zXG4gIGNvbnN0IG9yaWdpbmFsVHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgbGV0IHJldCA9IGNsb25lKHRoaXMuX2RvYywgY2xvbmVPcHRpb25zKSB8fCB7fTtcblxuICBpZiAob3B0aW9ucy5nZXR0ZXJzKSB7XG4gICAgYXBwbHlHZXR0ZXJzKHRoaXMsIHJldCwgZ2V0dGVyc09wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMubWluaW1pemUpIHtcbiAgICAgIHJldCA9IG1pbmltaXplKHJldCkgfHwge307XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMudmlydHVhbHMgfHwgKG9wdGlvbnMuZ2V0dGVycyAmJiBvcHRpb25zLnZpcnR1YWxzICE9PSBmYWxzZSkpIHtcbiAgICBhcHBseVZpcnR1YWxzKHRoaXMsIHJldCwgZ2V0dGVyc09wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudmVyc2lvbktleSA9PT0gZmFsc2UgJiYgdGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5KSB7XG4gICAgZGVsZXRlIHJldFt0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXldO1xuICB9XG5cbiAgbGV0IHRyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gIC8vIEluIHRoZSBjYXNlIHdoZXJlIGEgc3ViZG9jdW1lbnQgaGFzIGl0cyBvd24gdHJhbnNmb3JtIGZ1bmN0aW9uLCB3ZSBuZWVkIHRvXG4gIC8vIGNoZWNrIGFuZCBzZWUgaWYgdGhlIHBhcmVudCBoYXMgYSB0cmFuc2Zvcm0gKG9wdGlvbnMudHJhbnNmb3JtKSBhbmQgaWYgdGhlXG4gIC8vIGNoaWxkIHNjaGVtYSBoYXMgYSB0cmFuc2Zvcm0gKHRoaXMuc2NoZW1hLm9wdGlvbnMudG9PYmplY3QpIEluIHRoaXMgY2FzZSxcbiAgLy8gd2UgbmVlZCB0byBhZGp1c3Qgb3B0aW9ucy50cmFuc2Zvcm0gdG8gYmUgdGhlIGNoaWxkIHNjaGVtYSdzIHRyYW5zZm9ybSBhbmRcbiAgLy8gbm90IHRoZSBwYXJlbnQgc2NoZW1hJ3NcbiAgaWYgKHRyYW5zZm9ybSkge1xuICAgIGFwcGx5U2NoZW1hVHlwZVRyYW5zZm9ybXModGhpcywgcmV0KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnVzZVByb2plY3Rpb24pIHtcbiAgICBvbWl0RGVzZWxlY3RlZEZpZWxkcyh0aGlzLCByZXQpO1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybSA9PT0gdHJ1ZSB8fCAoc2NoZW1hT3B0aW9ucy50b09iamVjdCAmJiB0cmFuc2Zvcm0pKSB7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuanNvbiA/IHNjaGVtYU9wdGlvbnMudG9KU09OIDogc2NoZW1hT3B0aW9ucy50b09iamVjdDtcblxuICAgIGlmIChvcHRzKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50cmFuc2Zvcm0gOiBvcHRzLnRyYW5zZm9ybSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMudHJhbnNmb3JtID0gb3JpZ2luYWxUcmFuc2Zvcm07XG4gIH1cblxuICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHhmb3JtZWQgPSB0cmFuc2Zvcm0odGhpcywgcmV0LCBvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIHhmb3JtZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXQgPSB4Zm9ybWVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgZG9jdW1lbnQgaW50byBhIHBsYWluLW9sZCBKYXZhU2NyaXB0IG9iamVjdCAoW1BPSk9dKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wb2pvKSkuXG4gKlxuICogQnVmZmVycyBhcmUgY29udmVydGVkIHRvIGluc3RhbmNlcyBvZiBbbW9uZ29kYi5CaW5hcnldKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9CaW5hcnkuaHRtbCkgZm9yIHByb3BlciBzdG9yYWdlLlxuICpcbiAqICMjIyMgR2V0dGVycy9WaXJ0dWFsc1xuICpcbiAqIEV4YW1wbGUgb2Ygb25seSBhcHBseWluZyBwYXRoIGdldHRlcnNcbiAqXG4gKiAgICAgZG9jLnRvT2JqZWN0KHsgZ2V0dGVyczogdHJ1ZSwgdmlydHVhbHM6IGZhbHNlIH0pXG4gKlxuICogRXhhbXBsZSBvZiBvbmx5IGFwcGx5aW5nIHZpcnR1YWwgZ2V0dGVyc1xuICpcbiAqICAgICBkb2MudG9PYmplY3QoeyB2aXJ0dWFsczogdHJ1ZSB9KVxuICpcbiAqIEV4YW1wbGUgb2YgYXBwbHlpbmcgYm90aCBwYXRoIGFuZCB2aXJ0dWFsIGdldHRlcnNcbiAqXG4gKiAgICAgZG9jLnRvT2JqZWN0KHsgZ2V0dGVyczogdHJ1ZSB9KVxuICpcbiAqIFRvIGFwcGx5IHRoZXNlIG9wdGlvbnMgdG8gZXZlcnkgZG9jdW1lbnQgb2YgeW91ciBzY2hlbWEgYnkgZGVmYXVsdCwgc2V0IHlvdXIgW3NjaGVtYXNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hLmh0bWwjU2NoZW1hKCkpIGB0b09iamVjdGAgb3B0aW9uIHRvIHRoZSBzYW1lIGFyZ3VtZW50LlxuICpcbiAqICAgICBzY2hlbWEuc2V0KCd0b09iamVjdCcsIHsgdmlydHVhbHM6IHRydWUgfSlcbiAqXG4gKiAjIyMjIFRyYW5zZm9ybTpcbiAqXG4gKiBXZSBtYXkgbmVlZCB0byBwZXJmb3JtIGEgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHJlc3VsdGluZyBvYmplY3QgYmFzZWQgb24gc29tZSBjcml0ZXJpYSwgc2F5IHRvIHJlbW92ZSBzb21lIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiBvciByZXR1cm4gYSBjdXN0b20gb2JqZWN0LiBJbiB0aGlzIGNhc2Ugd2Ugc2V0IHRoZSBvcHRpb25hbCBgdHJhbnNmb3JtYCBmdW5jdGlvbi5cbiAqXG4gKiBUcmFuc2Zvcm0gZnVuY3Rpb25zIHJlY2VpdmUgdGhyZWUgYXJndW1lbnRzXG4gKlxuICogICAgIGZ1bmN0aW9uIChkb2MsIHJldCwgb3B0aW9ucykge31cbiAqXG4gKiAtIGBkb2NgIFRoZSBtb25nb29zZSBkb2N1bWVudCB3aGljaCBpcyBiZWluZyBjb252ZXJ0ZWRcbiAqIC0gYHJldGAgVGhlIHBsYWluIG9iamVjdCByZXByZXNlbnRhdGlvbiB3aGljaCBoYXMgYmVlbiBjb252ZXJ0ZWRcbiAqIC0gYG9wdGlvbnNgIFRoZSBvcHRpb25zIGluIHVzZSAoZWl0aGVyIHNjaGVtYSBvcHRpb25zIG9yIHRoZSBvcHRpb25zIHBhc3NlZCBpbmxpbmUpXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBzcGVjaWZ5IHRoZSB0cmFuc2Zvcm0gc2NoZW1hIG9wdGlvblxuICogICAgIGlmICghc2NoZW1hLm9wdGlvbnMudG9PYmplY3QpIHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0ID0ge307XG4gKiAgICAgc2NoZW1hLm9wdGlvbnMudG9PYmplY3QudHJhbnNmb3JtID0gZnVuY3Rpb24gKGRvYywgcmV0LCBvcHRpb25zKSB7XG4gKiAgICAgICAvLyByZW1vdmUgdGhlIF9pZCBvZiBldmVyeSBkb2N1bWVudCBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHRcbiAqICAgICAgIGRlbGV0ZSByZXQuX2lkO1xuICogICAgICAgcmV0dXJuIHJldDtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIHdpdGhvdXQgdGhlIHRyYW5zZm9ybWF0aW9uIGluIHRoZSBzY2hlbWFcbiAqICAgICBkb2MudG9PYmplY3QoKTsgLy8geyBfaWQ6ICdhbklkJywgbmFtZTogJ1dyZWNrLWl0IFJhbHBoJyB9XG4gKlxuICogICAgIC8vIHdpdGggdGhlIHRyYW5zZm9ybWF0aW9uXG4gKiAgICAgZG9jLnRvT2JqZWN0KCk7IC8vIHsgbmFtZTogJ1dyZWNrLWl0IFJhbHBoJyB9XG4gKlxuICogV2l0aCB0cmFuc2Zvcm1hdGlvbnMgd2UgY2FuIGRvIGEgbG90IG1vcmUgdGhhbiByZW1vdmUgcHJvcGVydGllcy4gV2UgY2FuIGV2ZW4gcmV0dXJuIGNvbXBsZXRlbHkgbmV3IGN1c3RvbWl6ZWQgb2JqZWN0czpcbiAqXG4gKiAgICAgaWYgKCFzY2hlbWEub3B0aW9ucy50b09iamVjdCkgc2NoZW1hLm9wdGlvbnMudG9PYmplY3QgPSB7fTtcbiAqICAgICBzY2hlbWEub3B0aW9ucy50b09iamVjdC50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZG9jLCByZXQsIG9wdGlvbnMpIHtcbiAqICAgICAgIHJldHVybiB7IG1vdmllOiByZXQubmFtZSB9XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyB3aXRob3V0IHRoZSB0cmFuc2Zvcm1hdGlvbiBpbiB0aGUgc2NoZW1hXG4gKiAgICAgZG9jLnRvT2JqZWN0KCk7IC8vIHsgX2lkOiAnYW5JZCcsIG5hbWU6ICdXcmVjay1pdCBSYWxwaCcgfVxuICpcbiAqICAgICAvLyB3aXRoIHRoZSB0cmFuc2Zvcm1hdGlvblxuICogICAgIGRvYy50b09iamVjdCgpOyAvLyB7IG1vdmllOiAnV3JlY2staXQgUmFscGgnIH1cbiAqXG4gKiBfTm90ZTogaWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQuX1xuICpcbiAqIFRyYW5zZm9ybWF0aW9ucyBtYXkgYWxzbyBiZSBhcHBsaWVkIGlubGluZSwgb3ZlcnJpZGRpbmcgYW55IHRyYW5zZm9ybSBzZXQgaW4gdGhlIG9wdGlvbnM6XG4gKlxuICogICAgIGZ1bmN0aW9uIHhmb3JtIChkb2MsIHJldCwgb3B0aW9ucykge1xuICogICAgICAgcmV0dXJuIHsgaW5saW5lOiByZXQubmFtZSwgY3VzdG9tOiB0cnVlIH1cbiAqICAgICB9XG4gKlxuICogICAgIC8vIHBhc3MgdGhlIHRyYW5zZm9ybSBhcyBhbiBpbmxpbmUgb3B0aW9uXG4gKiAgICAgZG9jLnRvT2JqZWN0KHsgdHJhbnNmb3JtOiB4Zm9ybSB9KTsgLy8geyBpbmxpbmU6ICdXcmVjay1pdCBSYWxwaCcsIGN1c3RvbTogdHJ1ZSB9XG4gKlxuICogSWYgeW91IHdhbnQgdG8gc2tpcCB0cmFuc2Zvcm1hdGlvbnMsIHVzZSBgdHJhbnNmb3JtOiBmYWxzZWA6XG4gKlxuICogICAgIHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0LmhpZGUgPSAnX2lkJztcbiAqICAgICBzY2hlbWEub3B0aW9ucy50b09iamVjdC50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZG9jLCByZXQsIG9wdGlvbnMpIHtcbiAqICAgICAgIGlmIChvcHRpb25zLmhpZGUpIHtcbiAqICAgICAgICAgb3B0aW9ucy5oaWRlLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICogICAgICAgICAgIGRlbGV0ZSByZXRbcHJvcF07XG4gKiAgICAgICAgIH0pO1xuICogICAgICAgfVxuICogICAgICAgcmV0dXJuIHJldDtcbiAqICAgICB9XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IG5ldyBEb2MoeyBfaWQ6ICdhbklkJywgc2VjcmV0OiA0NywgbmFtZTogJ1dyZWNrLWl0IFJhbHBoJyB9KTtcbiAqICAgICBkb2MudG9PYmplY3QoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geyBzZWNyZXQ6IDQ3LCBuYW1lOiAnV3JlY2staXQgUmFscGgnIH1cbiAqICAgICBkb2MudG9PYmplY3QoeyBoaWRlOiAnc2VjcmV0IF9pZCcsIHRyYW5zZm9ybTogZmFsc2UgfSk7Ly8geyBfaWQ6ICdhbklkJywgc2VjcmV0OiA0NywgbmFtZTogJ1dyZWNrLWl0IFJhbHBoJyB9XG4gKiAgICAgZG9jLnRvT2JqZWN0KHsgaGlkZTogJ3NlY3JldCBfaWQnLCB0cmFuc2Zvcm06IHRydWUgfSk7IC8vIHsgbmFtZTogJ1dyZWNrLWl0IFJhbHBoJyB9XG4gKlxuICogSWYgeW91IHBhc3MgYSB0cmFuc2Zvcm0gaW4gYHRvT2JqZWN0KClgIG9wdGlvbnMsIE1vbmdvb3NlIHdpbGwgYXBwbHkgdGhlIHRyYW5zZm9ybVxuICogdG8gW3N1YmRvY3VtZW50c10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3N1YmRvY3MuaHRtbCkgaW4gYWRkaXRpb24gdG8gdGhlIHRvcC1sZXZlbCBkb2N1bWVudC5cbiAqIFNpbWlsYXJseSwgYHRyYW5zZm9ybTogZmFsc2VgIHNraXBzIHRyYW5zZm9ybXMgZm9yIGFsbCBzdWJkb2N1bWVudHMuXG4gKiBOb3RlIHRoYXQgdGhpcyBiZWhhdmlvciBpcyBkaWZmZXJlbnQgZm9yIHRyYW5zZm9ybXMgZGVmaW5lZCBpbiB0aGUgc2NoZW1hOlxuICogaWYgeW91IGRlZmluZSBhIHRyYW5zZm9ybSBpbiBgc2NoZW1hLm9wdGlvbnMudG9PYmplY3QudHJhbnNmb3JtYCwgdGhhdCB0cmFuc2Zvcm1cbiAqIHdpbGwgKipub3QqKiBhcHBseSB0byBzdWJkb2N1bWVudHMuXG4gKlxuICogICAgIGNvbnN0IG1lbWJlclNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGVtYWlsOiBTdHJpbmcgfSk7XG4gKiAgICAgY29uc3QgZ3JvdXBTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbWVtYmVyczogW21lbWJlclNjaGVtYV0sIG5hbWU6IFN0cmluZywgZW1haWwgfSk7XG4gKiAgICAgY29uc3QgR3JvdXAgPSBtb25nb29zZS5tb2RlbCgnR3JvdXAnLCBncm91cFNjaGVtYSk7XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IG5ldyBHcm91cCh7XG4gKiAgICAgICBuYW1lOiAnRW5naW5lZXJpbmcnLFxuICogICAgICAgZW1haWw6ICdkZXZAbW9uZ29vc2Vqcy5pbycsXG4gKiAgICAgICBtZW1iZXJzOiBbeyBuYW1lOiAnVmFsJywgZW1haWw6ICd2YWxAbW9uZ29vc2Vqcy5pbycgfV1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gUmVtb3ZlcyBgZW1haWxgIGZyb20gYm90aCB0b3AtbGV2ZWwgZG9jdW1lbnQgKiphbmQqKiBhcnJheSBlbGVtZW50c1xuICogICAgIC8vIHsgbmFtZTogJ0VuZ2luZWVyaW5nJywgbWVtYmVyczogW3sgbmFtZTogJ1ZhbCcgfV0gfVxuICogICAgIGRvYy50b09iamVjdCh7IHRyYW5zZm9ybTogKGRvYywgcmV0KSA9PiB7IGRlbGV0ZSByZXQuZW1haWw7IHJldHVybiByZXQ7IH0gfSk7XG4gKlxuICogVHJhbnNmb3JtcywgbGlrZSBhbGwgb2YgdGhlc2Ugb3B0aW9ucywgYXJlIGFsc28gYXZhaWxhYmxlIGZvciBgdG9KU09OYC4gU2VlIFt0aGlzIGd1aWRlIHRvIGBKU09OLnN0cmluZ2lmeSgpYF0oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS90aGUtODAtMjAtZ3VpZGUtdG8tanNvbi1zdHJpbmdpZnktaW4tamF2YXNjcmlwdC5odG1sKSB0byBsZWFybiB3aHkgYHRvSlNPTigpYCBhbmQgYHRvT2JqZWN0KClgIGFyZSBzZXBhcmF0ZSBmdW5jdGlvbnMuXG4gKlxuICogU2VlIFtzY2hlbWEgb3B0aW9uc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdG9PYmplY3QpIGZvciBzb21lIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBfRHVyaW5nIHNhdmUsIG5vIGN1c3RvbSBvcHRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgZGF0YWJhc2UuX1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZ2V0dGVycz1mYWxzZV0gaWYgdHJ1ZSwgYXBwbHkgYWxsIGdldHRlcnMsIGluY2x1ZGluZyB2aXJ0dWFsc1xuICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gW29wdGlvbnMudmlydHVhbHM9ZmFsc2VdIGlmIHRydWUsIGFwcGx5IHZpcnR1YWxzLCBpbmNsdWRpbmcgYWxpYXNlcy4gVXNlIGB7IGdldHRlcnM6IHRydWUsIHZpcnR1YWxzOiBmYWxzZSB9YCB0byBqdXN0IGFwcGx5IGdldHRlcnMsIG5vdCB2aXJ0dWFscy4gQW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7IHBhdGhzVG9Ta2lwOiBbJ3NvbWVWaXJ0dWFsJ10gfWAgbWF5IGFsc28gYmUgdXNlZCB0byBvbWl0IHNwZWNpZmljIHZpcnR1YWxzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGlhc2VzPXRydWVdIGlmIGBvcHRpb25zLnZpcnR1YWxzID0gdHJ1ZWAsIHlvdSBjYW4gc2V0IGBvcHRpb25zLmFsaWFzZXMgPSBmYWxzZWAgdG8gc2tpcCBhcHBseWluZyBhbGlhc2VzLiBUaGlzIG9wdGlvbiBpcyBhIG5vLW9wIGlmIGBvcHRpb25zLnZpcnR1YWxzID0gZmFsc2VgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5taW5pbWl6ZT10cnVlXSBpZiB0cnVlLCBvbWl0IGFueSBlbXB0eSBvYmplY3RzIGZyb20gdGhlIG91dHB1dFxuICogQHBhcmFtIHtGdW5jdGlvbnxudWxsfSBbb3B0aW9ucy50cmFuc2Zvcm09bnVsbF0gaWYgc2V0LCBtb25nb29zZSB3aWxsIGNhbGwgdGhpcyBmdW5jdGlvbiB0byBhbGxvdyB5b3UgdG8gdHJhbnNmb3JtIHRoZSByZXR1cm5lZCBvYmplY3RcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGVwb3B1bGF0ZT1mYWxzZV0gaWYgdHJ1ZSwgcmVwbGFjZSBhbnkgY29udmVudGlvbmFsbHkgcG9wdWxhdGVkIHBhdGhzIHdpdGggdGhlIG9yaWdpbmFsIGlkIGluIHRoZSBvdXRwdXQuIEhhcyBubyBhZmZlY3Qgb24gdmlydHVhbCBwb3B1bGF0ZWQgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZlcnNpb25LZXk9dHJ1ZV0gaWYgZmFsc2UsIGV4Y2x1ZGUgdGhlIHZlcnNpb24ga2V5IChgX192YCBieSBkZWZhdWx0KSBmcm9tIHRoZSBvdXRwdXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmxhdHRlbk1hcHM9ZmFsc2VdIGlmIHRydWUsIGNvbnZlcnQgTWFwcyB0byBQT0pPcy4gVXNlZnVsIGlmIHlvdSB3YW50IHRvIGBKU09OLnN0cmluZ2lmeSgpYCB0aGUgcmVzdWx0IG9mIGB0b09iamVjdCgpYC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmxhdHRlbk9iamVjdElkcz1mYWxzZV0gaWYgdHJ1ZSwgY29udmVydCBhbnkgT2JqZWN0SWRzIGluIHRoZSByZXN1bHQgdG8gMjQgY2hhcmFjdGVyIGhleCBzdHJpbmdzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VQcm9qZWN0aW9uPWZhbHNlXSAtIElmIHRydWUsIG9taXRzIGZpZWxkcyB0aGF0IGFyZSBleGNsdWRlZCBpbiB0aGlzIGRvY3VtZW50J3MgcHJvamVjdGlvbi4gVW5sZXNzIHlvdSBzcGVjaWZpZWQgYSBwcm9qZWN0aW9uLCB0aGlzIHdpbGwgb21pdCBhbnkgZmllbGQgdGhhdCBoYXMgYHNlbGVjdDogZmFsc2VgIGluIHRoZSBzY2hlbWEuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGpzIG9iamVjdCAobm90IGEgUE9KTylcbiAqIEBzZWUgbW9uZ29kYi5CaW5hcnkgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0JpbmFyeS5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUudG9PYmplY3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLiR0b09iamVjdChvcHRpb25zKTtcbn07XG5cbi8qKlxuICogTWluaW1pemVzIGFuIG9iamVjdCwgcmVtb3ZpbmcgdW5kZWZpbmVkIHZhbHVlcyBhbmQgZW1wdHkgb2JqZWN0c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbWluaW1pemVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1pbmltaXplKG9iaikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGhhc0tleXM7XG4gIGxldCBrZXk7XG4gIGxldCB2YWw7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAodXRpbHMuaXNQT0pPKHZhbCkpIHtcbiAgICAgIG9ialtrZXldID0gbWluaW1pemUodmFsKTtcbiAgICB9XG5cbiAgICBpZiAodW5kZWZpbmVkID09PSBvYmpba2V5XSkge1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaGFzS2V5cyA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gaGFzS2V5c1xuICAgID8gb2JqXG4gICAgOiB1bmRlZmluZWQ7XG59XG5cbi8qIVxuICogQXBwbGllcyB2aXJ0dWFscyBwcm9wZXJ0aWVzIHRvIGBqc29uYC5cbiAqL1xuXG5mdW5jdGlvbiBhcHBseVZpcnR1YWxzKHNlbGYsIGpzb24sIG9wdGlvbnMsIHRvT2JqZWN0T3B0aW9ucykge1xuICBjb25zdCBzY2hlbWEgPSBzZWxmLiRfX3NjaGVtYTtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhzY2hlbWEudmlydHVhbHMpO1xuICBsZXQgaSA9IHBhdGhzLmxlbmd0aDtcbiAgY29uc3QgbnVtUGF0aHMgPSBpO1xuICBsZXQgcGF0aDtcbiAgbGV0IGFzc2lnblBhdGg7XG4gIGxldCBjdXIgPSBzZWxmLl9kb2M7XG4gIGxldCB2O1xuICBjb25zdCBhbGlhc2VzID0gdHlwZW9mICh0b09iamVjdE9wdGlvbnMgJiYgdG9PYmplY3RPcHRpb25zLmFsaWFzZXMpID09PSAnYm9vbGVhbidcbiAgICA/IHRvT2JqZWN0T3B0aW9ucy5hbGlhc2VzXG4gICAgOiB0cnVlO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgdmlydHVhbHNUb0FwcGx5ID0gbnVsbDtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy52aXJ0dWFscykpIHtcbiAgICB2aXJ0dWFsc1RvQXBwbHkgPSBuZXcgU2V0KG9wdGlvbnMudmlydHVhbHMpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMudmlydHVhbHMgJiYgb3B0aW9ucy52aXJ0dWFscy5wYXRoc1RvU2tpcCkge1xuICAgIHZpcnR1YWxzVG9BcHBseSA9IG5ldyBTZXQocGF0aHMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy52aXJ0dWFscy5wYXRoc1RvU2tpcC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZpcnR1YWxzVG9BcHBseS5oYXMob3B0aW9ucy52aXJ0dWFscy5wYXRoc1RvU2tpcFtpXSkpIHtcbiAgICAgICAgdmlydHVhbHNUb0FwcGx5LmRlbGV0ZShvcHRpb25zLnZpcnR1YWxzLnBhdGhzVG9Ta2lwW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWN1cikge1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG51bVBhdGhzOyArK2kpIHtcbiAgICBwYXRoID0gcGF0aHNbaV07XG5cbiAgICBpZiAodmlydHVhbHNUb0FwcGx5ICE9IG51bGwgJiYgIXZpcnR1YWxzVG9BcHBseS5oYXMocGF0aCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEFsbG93IHNraXBwaW5nIGFsaWFzZXMgd2l0aCBgdG9PYmplY3QoeyB2aXJ0dWFsczogdHJ1ZSwgYWxpYXNlczogZmFsc2UgfSlgXG4gICAgaWYgKCFhbGlhc2VzICYmIHNjaGVtYS5hbGlhc2VzLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBXZSBtYXkgYmUgYXBwbHlpbmcgdmlydHVhbHMgdG8gYSBuZXN0ZWQgb2JqZWN0LCBmb3IgZXhhbXBsZSBpZiBjYWxsaW5nXG4gICAgLy8gYGRvYy5uZXN0ZWRQcm9wLnRvSlNPTigpYC4gSWYgc28sIHRoZSBwYXRoIHdlIGFzc2lnbiB0bywgYGFzc2lnblBhdGhgLFxuICAgIC8vIHdpbGwgYmUgYSB0cmFpbGluZyBzdWJzdHJpbmcgb2YgdGhlIGBwYXRoYC5cbiAgICBhc3NpZ25QYXRoID0gcGF0aDtcbiAgICBpZiAob3B0aW9ucy5wYXRoICE9IG51bGwpIHtcbiAgICAgIGlmICghcGF0aC5zdGFydHNXaXRoKG9wdGlvbnMucGF0aCArICcuJykpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25QYXRoID0gcGF0aC5zdWJzdHJpbmcob3B0aW9ucy5wYXRoLmxlbmd0aCArIDEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IGFzc2lnblBhdGguc3BsaXQoJy4nKTtcbiAgICB2ID0gY2xvbmUoc2VsZi5nZXQocGF0aCksIG9wdGlvbnMpO1xuICAgIGlmICh2ID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwbGVuID0gcGFydHMubGVuZ3RoO1xuICAgIGN1ciA9IGpzb247XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwbGVuIC0gMTsgKytqKSB7XG4gICAgICBjdXJbcGFydHNbal1dID0gY3VyW3BhcnRzW2pdXSB8fCB7fTtcbiAgICAgIGN1ciA9IGN1cltwYXJ0c1tqXV07XG4gICAgfVxuICAgIGN1cltwYXJ0c1twbGVuIC0gMV1dID0gdjtcbiAgfVxuXG4gIHJldHVybiBqc29uO1xufVxuXG5cbi8qKlxuICogQXBwbGllcyB2aXJ0dWFscyBwcm9wZXJ0aWVzIHRvIGBqc29uYC5cbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBzZWxmXG4gKiBAcGFyYW0ge09iamVjdH0ganNvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7T2JqZWN0fSBganNvbmBcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5R2V0dGVycyhzZWxmLCBqc29uLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtYSA9IHNlbGYuJF9fc2NoZW1hO1xuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocyk7XG4gIGxldCBpID0gcGF0aHMubGVuZ3RoO1xuICBsZXQgcGF0aDtcbiAgbGV0IGN1ciA9IHNlbGYuX2RvYztcbiAgbGV0IHY7XG5cbiAgaWYgKCFjdXIpIHtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBwYXRoID0gcGF0aHNbaV07XG5cbiAgICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcblxuICAgIGNvbnN0IHBsZW4gPSBwYXJ0cy5sZW5ndGg7XG4gICAgY29uc3QgbGFzdCA9IHBsZW4gLSAxO1xuICAgIGxldCBicmFuY2ggPSBqc29uO1xuICAgIGxldCBwYXJ0O1xuICAgIGN1ciA9IHNlbGYuX2RvYztcblxuICAgIGlmICghc2VsZi4kX19pc1NlbGVjdGVkKHBhdGgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgcGxlbjsgKytpaSkge1xuICAgICAgcGFydCA9IHBhcnRzW2lpXTtcbiAgICAgIHYgPSBjdXJbcGFydF07XG4gICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIGEgbm9uLW9iamVjdCBwYXJ0IG9mIHRoZSBicmFuY2gsIGNvbnRpbnVpbmcgd291bGRcbiAgICAgIC8vIGNhdXNlIFwiQ2Fubm90IGNyZWF0ZSBwcm9wZXJ0eSAnZm9vJyBvbiBzdHJpbmcgJ2JhcidcIiBlcnJvci5cbiAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgbW9uZ29vc2UtaW50bCBwbHVnaW4gcmU6IGdoLTE0NDQ2XG4gICAgICBpZiAoYnJhbmNoICE9IG51bGwgJiYgdHlwZW9mIGJyYW5jaCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGlpID09PSBsYXN0KSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHNlbGYuJGdldChwYXRoKTtcbiAgICAgICAgYnJhbmNoW3BhcnRdID0gY2xvbmUodmFsLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnJhbmNoW3BhcnRdKSAmJiBzY2hlbWEucGF0aHNbcGF0aF0uJGVtYmVkZGVkU2NoZW1hVHlwZSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnJhbmNoW3BhcnRdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBicmFuY2hbcGFydF1baV0gPSBzY2hlbWEucGF0aHNbcGF0aF0uJGVtYmVkZGVkU2NoZW1hVHlwZS5hcHBseUdldHRlcnMoXG4gICAgICAgICAgICAgIGJyYW5jaFtwYXJ0XVtpXSxcbiAgICAgICAgICAgICAgc2VsZlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIGlmIChwYXJ0IGluIGN1cikge1xuICAgICAgICAgIGJyYW5jaFtwYXJ0XSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmFuY2ggPSBicmFuY2hbcGFydF0gfHwgKGJyYW5jaFtwYXJ0XSA9IHt9KTtcbiAgICAgIH1cbiAgICAgIGN1ciA9IHY7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGpzb247XG59XG5cbi8qKlxuICogQXBwbGllcyBzY2hlbWEgdHlwZSB0cmFuc2Zvcm1zIHRvIGBqc29uYC5cbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBzZWxmXG4gKiBAcGFyYW0ge09iamVjdH0ganNvblxuICogQHJldHVybiB7T2JqZWN0fSBganNvbmBcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5U2NoZW1hVHlwZVRyYW5zZm9ybXMoc2VsZiwganNvbikge1xuICBjb25zdCBzY2hlbWEgPSBzZWxmLiRfX3NjaGVtYTtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMgfHwge30pO1xuICBjb25zdCBjdXIgPSBzZWxmLl9kb2M7XG5cbiAgaWYgKCFjdXIpIHtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGNvbnN0IHNjaGVtYXR5cGUgPSBzY2hlbWEucGF0aHNbcGF0aF07XG4gICAgaWYgKHR5cGVvZiBzY2hlbWF0eXBlLm9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCB2YWwgPSBzZWxmLiRnZXQocGF0aCk7XG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFZhbHVlID0gc2NoZW1hdHlwZS5vcHRpb25zLnRyYW5zZm9ybS5jYWxsKHNlbGYsIHZhbCk7XG4gICAgICB0aHJvd0Vycm9ySWZQcm9taXNlKHBhdGgsIHRyYW5zZm9ybWVkVmFsdWUpO1xuICAgICAgdXRpbHMuc2V0VmFsdWUocGF0aCwgdHJhbnNmb3JtZWRWYWx1ZSwganNvbik7XG4gICAgfSBlbHNlIGlmIChzY2hlbWF0eXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2Ygc2NoZW1hdHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLm9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCB2YWwgPSBzZWxmLiRnZXQocGF0aCk7XG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWxzID0gW10uY29uY2F0KHZhbCk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzY2hlbWF0eXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUub3B0aW9ucy50cmFuc2Zvcm07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRWYWx1ZSA9IHRyYW5zZm9ybS5jYWxsKHNlbGYsIHZhbHNbaV0pO1xuICAgICAgICB2YWxzW2ldID0gdHJhbnNmb3JtZWRWYWx1ZTtcbiAgICAgICAgdGhyb3dFcnJvcklmUHJvbWlzZShwYXRoLCB0cmFuc2Zvcm1lZFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAganNvbltwYXRoXSA9IHZhbHM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGpzb247XG59XG5cbmZ1bmN0aW9uIHRocm93RXJyb3JJZlByb21pc2UocGF0aCwgdHJhbnNmb3JtZWRWYWx1ZSkge1xuICBpZiAoaXNQcm9taXNlKHRyYW5zZm9ybWVkVmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdHJhbnNmb3JtYCBmdW5jdGlvbiBtdXN0IGJlIHN5bmNocm9ub3VzLCBidXQgdGhlIHRyYW5zZm9ybSBvbiBwYXRoIGAnICsgcGF0aCArICdgIHJldHVybmVkIGEgcHJvbWlzZS4nKTtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIG9taXREZXNlbGVjdGVkRmllbGRzKHNlbGYsIGpzb24pIHtcbiAgY29uc3Qgc2NoZW1hID0gc2VsZi4kX19zY2hlbWE7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzIHx8IHt9KTtcbiAgY29uc3QgY3VyID0gc2VsZi5fZG9jO1xuXG4gIGlmICghY3VyKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBsZXQgc2VsZWN0ZWQgPSBzZWxmLiRfXy5zZWxlY3RlZDtcbiAgaWYgKHNlbGVjdGVkID09PSB2b2lkIDApIHtcbiAgICBzZWxlY3RlZCA9IHt9O1xuICAgIHF1ZXJ5aGVscGVycy5hcHBseVBhdGhzKHNlbGVjdGVkLCBzY2hlbWEpO1xuICB9XG4gIGlmIChzZWxlY3RlZCA9PSBudWxsIHx8IE9iamVjdC5rZXlzKHNlbGVjdGVkKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGlmIChzZWxlY3RlZFtwYXRoXSAhPSBudWxsICYmICFzZWxlY3RlZFtwYXRoXSkge1xuICAgICAgZGVsZXRlIGpzb25bcGF0aF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGpzb247XG59XG5cbi8qKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZCBpcyB1c2VkIGluIGNhbGxzIHRvIFtgSlNPTi5zdHJpbmdpZnkoZG9jKWBdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vdGhlLTgwLTIwLWd1aWRlLXRvLWpzb24tc3RyaW5naWZ5LWluLWphdmFzY3JpcHQjdGhlLXRvanNvbi1mdW5jdGlvbikuXG4gKlxuICogVGhpcyBtZXRob2QgYWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIFtEb2N1bWVudCN0b09iamVjdF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS50b09iamVjdCgpKS4gVG8gYXBwbHkgdGhlIG9wdGlvbnMgdG8gZXZlcnkgZG9jdW1lbnQgb2YgeW91ciBzY2hlbWEgYnkgZGVmYXVsdCwgc2V0IHlvdXIgW3NjaGVtYXNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hLmh0bWwjU2NoZW1hKCkpIGB0b0pTT05gIG9wdGlvbiB0byB0aGUgc2FtZSBhcmd1bWVudC5cbiAqXG4gKiAgICAgc2NoZW1hLnNldCgndG9KU09OJywgeyB2aXJ0dWFsczogdHJ1ZSB9KTtcbiAqXG4gKiBUaGVyZSBpcyBvbmUgZGlmZmVyZW5jZSBiZXR3ZWVuIGB0b0pTT04oKWAgYW5kIGB0b09iamVjdCgpYCBvcHRpb25zLlxuICogV2hlbiB5b3UgY2FsbCBgdG9KU09OKClgLCB0aGUgW2BmbGF0dGVuTWFwc2Agb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnRvT2JqZWN0KCkpIGRlZmF1bHRzIHRvIGB0cnVlYCwgYmVjYXVzZSBgSlNPTi5zdHJpbmdpZnkoKWAgZG9lc24ndCBjb252ZXJ0IG1hcHMgdG8gb2JqZWN0cyBieSBkZWZhdWx0LlxuICogV2hlbiB5b3UgY2FsbCBgdG9PYmplY3QoKWAsIHRoZSBgZmxhdHRlbk1hcHNgIG9wdGlvbiBpcyBgZmFsc2VgIGJ5IGRlZmF1bHQuXG4gKlxuICogU2VlIFtzY2hlbWEgb3B0aW9uc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdG9KU09OKSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzZXR0aW5nIGB0b0pTT05gIG9wdGlvbiBkZWZhdWx0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mbGF0dGVuTWFwcz10cnVlXSBpZiB0cnVlLCBjb252ZXJ0IE1hcHMgdG8gW1BPSk9zXShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcG9qbykuIFVzZWZ1bCBpZiB5b3Ugd2FudCB0byBgSlNPTi5zdHJpbmdpZnkoKWAgdGhlIHJlc3VsdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmxhdHRlbk9iamVjdElkcz1mYWxzZV0gaWYgdHJ1ZSwgY29udmVydCBhbnkgT2JqZWN0SWRzIGluIHRoZSByZXN1bHQgdG8gMjQgY2hhcmFjdGVyIGhleCBzdHJpbmdzLlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBEb2N1bWVudCN0b09iamVjdCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnRvT2JqZWN0KClcbiAqIEBzZWUgSlNPTi5zdHJpbmdpZnkoKSBpbiBKYXZhU2NyaXB0IGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vdGhlLTgwLTIwLWd1aWRlLXRvLWpzb24tc3RyaW5naWZ5LWluLWphdmFzY3JpcHQuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuJHRvT2JqZWN0KG9wdGlvbnMsIHRydWUpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUub3duZXJEb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBJZiB0aGlzIGRvY3VtZW50IGlzIGEgc3ViZG9jdW1lbnQgb3IgcG9wdWxhdGVkIGRvY3VtZW50LCByZXR1cm5zIHRoZSBkb2N1bWVudCdzXG4gKiBwYXJlbnQuIFJldHVybnMgdGhlIG9yaWdpbmFsIGRvY3VtZW50IGlmIHRoZXJlIGlzIG5vIHBhcmVudC5cbiAqXG4gKiBAcmV0dXJuIHtEb2N1bWVudH1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHBhcmVudFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLiRpc1N1YmRvY3VtZW50IHx8IHRoaXMuJF9fLndhc1BvcHVsYXRlZCkge1xuICAgIHJldHVybiB0aGlzLiRfXy5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciBbYHBhcmVudCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5wYXJlbnQoKSkuIElmIHRoaXMgZG9jdW1lbnQgaXMgYSBzdWJkb2N1bWVudCBvciBwb3B1bGF0ZWRcbiAqIGRvY3VtZW50LCByZXR1cm5zIHRoZSBkb2N1bWVudCdzIHBhcmVudC4gUmV0dXJucyBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gKlxuICogQHJldHVybiB7RG9jdW1lbnR9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCAkcGFyZW50XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kcGFyZW50ID0gRG9jdW1lbnQucHJvdG90eXBlLnBhcmVudDtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNvbnNvbGUubG9nXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgaW5zcGVjdFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgY29uc3QgaXNQT0pPID0gdXRpbHMuaXNQT0pPKG9wdGlvbnMpO1xuICBsZXQgb3B0cztcbiAgaWYgKGlzUE9KTykge1xuICAgIG9wdHMgPSBvcHRpb25zO1xuICAgIG9wdHMubWluaW1pemUgPSBmYWxzZTtcbiAgfVxuICBjb25zdCByZXQgPSB0aGlzLnRvT2JqZWN0KG9wdHMpO1xuXG4gIGlmIChyZXQgPT0gbnVsbCkge1xuICAgIC8vIElmIGB0b09iamVjdCgpYCByZXR1cm5zIG51bGwsIGB0aGlzYCBpcyBzdGlsbCBhbiBvYmplY3QsIHNvIGlmIGBpbnNwZWN0KClgXG4gICAgLy8gcHJpbnRzIG91dCBudWxsIHRoaXMgY2FuIGNhdXNlIHNvbWUgc2VyaW91cyBjb25mdXNpb24uIFNlZSBnaC03OTQyLlxuICAgIHJldHVybiAnTW9uZ29vc2VEb2N1bWVudCB7ICcgKyByZXQgKyAnIH0nO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmlmIChpbnNwZWN0LmN1c3RvbSkge1xuICAvLyBBdm9pZCBOb2RlIGRlcHJlY2F0aW9uIHdhcm5pbmcgREVQMDA3OVxuICBEb2N1bWVudC5wcm90b3R5cGVbaW5zcGVjdC5jdXN0b21dID0gRG9jdW1lbnQucHJvdG90eXBlLmluc3BlY3Q7XG59XG5cbi8qKlxuICogSGVscGVyIGZvciBjb25zb2xlLmxvZ1xuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCByZXQgPSB0aGlzLmluc3BlY3QoKTtcbiAgaWYgKHR5cGVvZiByZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICByZXR1cm4gaW5zcGVjdChyZXQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBkb2N1bWVudCBpcyBlcXVhbCB0byBhbm90aGVyIGRvY3VtZW50LlxuICpcbiAqIERvY3VtZW50cyBhcmUgY29uc2lkZXJlZCBlcXVhbCB3aGVuIHRoZXkgaGF2ZSBtYXRjaGluZyBgX2lkYHMsIHVubGVzcyBuZWl0aGVyXG4gKiBkb2N1bWVudCBoYXMgYW4gYF9pZGAsIGluIHdoaWNoIGNhc2UgdGhpcyBmdW5jdGlvbiBmYWxscyBiYWNrIHRvIHVzaW5nXG4gKiBgZGVlcEVxdWFsKClgLlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IFtkb2NdIGEgZG9jdW1lbnQgdG8gY29tcGFyZS4gSWYgZmFsc3ksIHdpbGwgYWx3YXlzIHJldHVybiBcImZhbHNlXCIuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKGRvYykge1xuICBpZiAoIWRvYykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHRpZCA9IHRoaXMuJF9fZ2V0VmFsdWUoJ19pZCcpO1xuICBjb25zdCBkb2NpZCA9IGRvYy4kX18gIT0gbnVsbCA/IGRvYy4kX19nZXRWYWx1ZSgnX2lkJykgOiBkb2M7XG4gIGlmICghdGlkICYmICFkb2NpZCkge1xuICAgIHJldHVybiBkZWVwRXF1YWwodGhpcywgZG9jKTtcbiAgfVxuICByZXR1cm4gdGlkICYmIHRpZC5lcXVhbHNcbiAgICA/IHRpZC5lcXVhbHMoZG9jaWQpXG4gICAgOiB0aWQgPT09IGRvY2lkO1xufTtcblxuLyoqXG4gKiBQb3B1bGF0ZXMgcGF0aHMgb24gYW4gZXhpc3RpbmcgZG9jdW1lbnQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBHaXZlbiBhIGRvY3VtZW50LCBgcG9wdWxhdGUoKWAgbGV0cyB5b3UgcHVsbCBpbiByZWZlcmVuY2VkIGRvY3NcbiAqICAgICBhd2FpdCBkb2MucG9wdWxhdGUoW1xuICogICAgICAgJ3N0b3JpZXMnLFxuICogICAgICAgeyBwYXRoOiAnZmFucycsIHNvcnQ6IHsgbmFtZTogLTEgfSB9XG4gKiAgICAgXSk7XG4gKiAgICAgZG9jLnBvcHVsYXRlZCgnc3RvcmllcycpOyAvLyBBcnJheSBvZiBPYmplY3RJZHNcbiAqICAgICBkb2Muc3Rvcmllc1swXS50aXRsZTsgLy8gJ0Nhc2lubyBSb3lhbGUnXG4gKiAgICAgZG9jLnBvcHVsYXRlZCgnZmFucycpOyAvLyBBcnJheSBvZiBPYmplY3RJZHNcbiAqXG4gKiAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZWQgZG9jIGhhcyBiZWVuIGRlbGV0ZWQsIGBwb3B1bGF0ZSgpYCB3aWxsXG4gKiAgICAgLy8gcmVtb3ZlIHRoYXQgZW50cnkgZnJvbSB0aGUgYXJyYXkuXG4gKiAgICAgYXdhaXQgU3RvcnkuZGVsZXRlKHsgdGl0bGU6ICdDYXNpbm8gUm95YWxlJyB9KTtcbiAqICAgICBhd2FpdCBkb2MucG9wdWxhdGUoJ3N0b3JpZXMnKTsgLy8gRW1wdHkgYXJyYXlcbiAqXG4gKiAgICAgLy8gWW91IGNhbiBhbHNvIHBhc3MgYWRkaXRpb25hbCBxdWVyeSBvcHRpb25zIHRvIGBwb3B1bGF0ZSgpYCxcbiAqICAgICAvLyBsaWtlIHByb2plY3Rpb25zOlxuICogICAgIGF3YWl0IGRvYy5wb3B1bGF0ZSgnZmFucycsICctZW1haWwnKTtcbiAqICAgICBkb2MuZmFuc1swXS5lbWFpbCAvLyB1bmRlZmluZWQgYmVjYXVzZSBvZiAybmQgcGFyYW0gYHNlbGVjdGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8QXJyYXl9IHBhdGggZWl0aGVyIHRoZSBwYXRoIHRvIHBvcHVsYXRlIG9yIGFuIG9iamVjdCBzcGVjaWZ5aW5nIGFsbCBwYXJhbWV0ZXJzLCBvciBlaXRoZXIgYW4gYXJyYXkgb2YgdGhvc2VcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW3NlbGVjdF0gRmllbGQgc2VsZWN0aW9uIGZvciB0aGUgcG9wdWxhdGlvbiBxdWVyeVxuICogQHBhcmFtIHtNb2RlbH0gW21vZGVsXSBUaGUgbW9kZWwgeW91IHdpc2ggdG8gdXNlIGZvciBwb3B1bGF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCBwb3B1bGF0ZSB3aWxsIGxvb2sgdXAgdGhlIG1vZGVsIGJ5IHRoZSBuYW1lIGluIHRoZSBTY2hlbWEncyBgcmVmYCBmaWVsZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbbWF0Y2hdIENvbmRpdGlvbnMgZm9yIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5IChzb3J0LCBldGMpXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aD1udWxsXSBUaGUgcGF0aCB0byBwb3B1bGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfFBvcHVsYXRlT3B0aW9uc30gW29wdGlvbnMucG9wdWxhdGU9bnVsbF0gUmVjdXJzaXZlbHkgcG9wdWxhdGUgcGF0aHMgaW4gdGhlIHBvcHVsYXRlZCBkb2N1bWVudHMuIFNlZSBbZGVlcCBwb3B1bGF0ZSBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbCNkZWVwLXBvcHVsYXRlKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV0YWluTnVsbFZhbHVlcz1mYWxzZV0gYnkgZGVmYXVsdCwgTW9uZ29vc2UgcmVtb3ZlcyBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGZyb20gcG9wdWxhdGVkIGFycmF5cy4gVXNlIHRoaXMgb3B0aW9uIHRvIG1ha2UgYHBvcHVsYXRlKClgIHJldGFpbiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFycmF5IGVudHJpZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmdldHRlcnM9ZmFsc2VdIGlmIHRydWUsIE1vbmdvb3NlIHdpbGwgY2FsbCBhbnkgZ2V0dGVycyBkZWZpbmVkIG9uIHRoZSBgbG9jYWxGaWVsZGAuIEJ5IGRlZmF1bHQsIE1vbmdvb3NlIGdldHMgdGhlIHJhdyB2YWx1ZSBvZiBgbG9jYWxGaWVsZGAuIEZvciBleGFtcGxlLCB5b3Ugd291bGQgbmVlZCB0byBzZXQgdGhpcyBvcHRpb24gdG8gYHRydWVgIGlmIHlvdSB3YW50ZWQgdG8gW2FkZCBhIGBsb3dlcmNhc2VgIGdldHRlciB0byB5b3VyIGBsb2NhbEZpZWxkYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjc2NoZW1hdHlwZS1vcHRpb25zKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xvbmU9ZmFsc2VdIFdoZW4geW91IGRvIGBCbG9nUG9zdC5maW5kKCkucG9wdWxhdGUoJ2F1dGhvcicpYCwgYmxvZyBwb3N0cyB3aXRoIHRoZSBzYW1lIGF1dGhvciB3aWxsIHNoYXJlIDEgY29weSBvZiBhbiBgYXV0aG9yYCBkb2MuIEVuYWJsZSB0aGlzIG9wdGlvbiB0byBtYWtlIE1vbmdvb3NlIGNsb25lIHBvcHVsYXRlZCBkb2NzIGJlZm9yZSBhc3NpZ25pbmcgdGhlbS5cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbb3B0aW9ucy5tYXRjaD1udWxsXSBBZGQgYW4gYWRkaXRpb25hbCBmaWx0ZXIgdG8gdGhlIHBvcHVsYXRlIHF1ZXJ5LiBDYW4gYmUgYSBmaWx0ZXIgb2JqZWN0IGNvbnRhaW5pbmcgW01vbmdvREIgcXVlcnkgc3ludGF4XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9xdWVyeS1kb2N1bWVudHMvKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmaWx0ZXIgb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudHJhbnNmb3JtPW51bGxdIEZ1bmN0aW9uIHRoYXQgTW9uZ29vc2Ugd2lsbCBjYWxsIG9uIGV2ZXJ5IHBvcHVsYXRlZCBkb2N1bWVudCB0aGF0IGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIHRoZSBwb3B1bGF0ZWQgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMub3B0aW9ucz1udWxsXSBBZGRpdGlvbmFsIG9wdGlvbnMgbGlrZSBgbGltaXRgIGFuZCBgbGVhbmAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrXG4gKiBAc2VlIHBvcHVsYXRpb24gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWxcbiAqIEBzZWUgUXVlcnkjc2VsZWN0IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClcbiAqIEBzZWUgTW9kZWwucG9wdWxhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnBvcHVsYXRlKClcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJuIHtQcm9taXNlfG51bGx9IFJldHVybnMgYSBQcm9taXNlIGlmIG5vIGBjYWxsYmFja2AgaXMgZ2l2ZW4uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIHBvcHVsYXRlKCkge1xuICBjb25zdCBwb3AgPSB7fTtcbiAgY29uc3QgYXJncyA9IFsuLi5hcmd1bWVudHNdO1xuICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdEb2N1bWVudC5wcm90b3R5cGUucG9wdWxhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoYXJncy5sZW5ndGggIT09IDApIHtcbiAgICAvLyB1c2UgaGFzaCB0byByZW1vdmUgZHVwbGljYXRlIHBhdGhzXG4gICAgY29uc3QgcmVzID0gdXRpbHMucG9wdWxhdGUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgZm9yIChjb25zdCBwb3B1bGF0ZU9wdGlvbnMgb2YgcmVzKSB7XG4gICAgICBwb3BbcG9wdWxhdGVPcHRpb25zLnBhdGhdID0gcG9wdWxhdGVPcHRpb25zO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHBhdGhzID0gdXRpbHMub2JqZWN0LnZhbHMocG9wKTtcbiAgbGV0IHRvcExldmVsTW9kZWwgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICBpZiAodGhpcy4kX19pc05lc3RlZCkge1xuICAgIHRvcExldmVsTW9kZWwgPSB0aGlzLiRfX1tzY29wZVN5bWJvbF0uY29uc3RydWN0b3I7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHRoaXMuJF9fLm5lc3RlZFBhdGg7XG4gICAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbihwb3B1bGF0ZU9wdGlvbnMpIHtcbiAgICAgIHBvcHVsYXRlT3B0aW9ucy5wYXRoID0gbmVzdGVkUGF0aCArICcuJyArIHBvcHVsYXRlT3B0aW9ucy5wYXRoO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVXNlIGAkc2Vzc2lvbigpYCBieSBkZWZhdWx0IGlmIHRoZSBkb2N1bWVudCBoYXMgYW4gYXNzb2NpYXRlZCBzZXNzaW9uXG4gIC8vIFNlZSBnaC02NzU0XG4gIGlmICh0aGlzLiRzZXNzaW9uKCkgIT0gbnVsbCkge1xuICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLiRzZXNzaW9uKCk7XG4gICAgcGF0aHMuZm9yRWFjaChwYXRoID0+IHtcbiAgICAgIGlmIChwYXRoLm9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBwYXRoLm9wdGlvbnMgPSB7IHNlc3Npb246IHNlc3Npb24gfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCEoJ3Nlc3Npb24nIGluIHBhdGgub3B0aW9ucykpIHtcbiAgICAgICAgcGF0aC5vcHRpb25zLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcGF0aHMuZm9yRWFjaChwID0+IHtcbiAgICBwLl9sb2NhbE1vZGVsID0gdG9wTGV2ZWxNb2RlbDtcbiAgfSk7XG5cbiAgcmV0dXJuIHRvcExldmVsTW9kZWwucG9wdWxhdGUodGhpcywgcGF0aHMpO1xufTtcblxuLyoqXG4gKiBHZXRzIGFsbCBwb3B1bGF0ZWQgZG9jdW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGRvY3VtZW50LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtEb2N1bWVudFtdfSBhcnJheSBvZiBwb3B1bGF0ZWQgZG9jdW1lbnRzLiBFbXB0eSBhcnJheSBpZiB0aGVyZSBhcmUgbm8gcG9wdWxhdGVkIGRvY3VtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBkb2N1bWVudC5cbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQG1ldGhvZCAkZ2V0UG9wdWxhdGVkRG9jc1xuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRnZXRQb3B1bGF0ZWREb2NzID0gZnVuY3Rpb24gJGdldFBvcHVsYXRlZERvY3MoKSB7XG4gIGxldCBrZXlzID0gW107XG4gIGlmICh0aGlzLiRfXy5wb3B1bGF0ZWQgIT0gbnVsbCkge1xuICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3Qua2V5cyh0aGlzLiRfXy5wb3B1bGF0ZWQpKTtcbiAgfVxuICBsZXQgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuJGdldChrZXkpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldHMgX2lkKHMpIHVzZWQgZHVyaW5nIHBvcHVsYXRpb24gb2YgdGhlIGdpdmVuIGBwYXRoYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRPbmUoKS5wb3B1bGF0ZSgnYXV0aG9yJyk7XG4gKlxuICogICAgIGNvbnNvbGUubG9nKGRvYy5hdXRob3IubmFtZSk7IC8vIERyLlNldXNzXG4gKiAgICAgY29uc29sZS5sb2coZG9jLnBvcHVsYXRlZCgnYXV0aG9yJykpOyAvLyAnNTE0NGNmODA1MGYwNzFkOTc5YzExOGE3J1xuICpcbiAqIElmIHRoZSBwYXRoIHdhcyBub3QgcG9wdWxhdGVkLCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge0FueX0gW3ZhbF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge0FycmF5fE9iamVjdElkfE51bWJlcnxCdWZmZXJ8U3RyaW5nfHVuZGVmaW5lZH1cbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZWQgPSBmdW5jdGlvbihwYXRoLCB2YWwsIG9wdGlvbnMpIHtcbiAgLy8gdmFsIGFuZCBvcHRpb25zIGFyZSBpbnRlcm5hbFxuICBpZiAodmFsID09IG51bGwgfHwgdmFsID09PSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLiRfXy5wb3B1bGF0ZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gTWFwIHBhdGhzIGNhbiBiZSBwb3B1bGF0ZWQgd2l0aCBlaXRoZXIgYHBhdGguJCpgIG9yIGp1c3QgYHBhdGhgXG4gICAgY29uc3QgX3BhdGggPSBwYXRoLmVuZHNXaXRoKCcuJConKSA/IHBhdGgucmVwbGFjZSgvXFwuXFwkXFwqJC8sICcnKSA6IHBhdGg7XG5cbiAgICBjb25zdCB2ID0gdGhpcy4kX18ucG9wdWxhdGVkW19wYXRoXTtcbiAgICBpZiAodikge1xuICAgICAgcmV0dXJuIHZhbCA9PT0gdHJ1ZSA/IHYgOiB2LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdGhpcy4kX18ucG9wdWxhdGVkIHx8ICh0aGlzLiRfXy5wb3B1bGF0ZWQgPSB7fSk7XG4gIHRoaXMuJF9fLnBvcHVsYXRlZFtwYXRoXSA9IHsgdmFsdWU6IHZhbCwgb3B0aW9uczogb3B0aW9ucyB9O1xuXG4gIC8vIElmIHRoaXMgd2FzIGEgbmVzdGVkIHBvcHVsYXRlLCBtYWtlIHN1cmUgZWFjaCBwb3B1bGF0ZWQgZG9jIGtub3dzXG4gIC8vIGFib3V0IGl0cyBwb3B1bGF0ZWQgY2hpbGRyZW4gKGdoLTc2ODUpXG4gIGNvbnN0IHBpZWNlcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgY29uc3Qgc3VicGF0aCA9IHBpZWNlcy5zbGljZSgwLCBpICsgMSkuam9pbignLicpO1xuICAgIGNvbnN0IHN1YmRvYyA9IHRoaXMuJGdldChzdWJwYXRoKTtcbiAgICBpZiAoc3ViZG9jICE9IG51bGwgJiYgc3ViZG9jLiRfXyAhPSBudWxsICYmIHRoaXMuJHBvcHVsYXRlZChzdWJwYXRoKSkge1xuICAgICAgY29uc3QgcmVzdCA9IHBpZWNlcy5zbGljZShpICsgMSkuam9pbignLicpO1xuICAgICAgc3ViZG9jLiRwb3B1bGF0ZWQocmVzdCwgdmFsLCBvcHRpb25zKTtcbiAgICAgIC8vIE5vIG5lZWQgdG8gY29udGludWUgYmVjYXVzZSB0aGUgYWJvdmUgcmVjdXJzaW9uIHNob3VsZCB0YWtlIGNhcmUgb2ZcbiAgICAgIC8vIG1hcmtpbmcgdGhlIHJlc3Qgb2YgdGhlIGRvY3MgYXMgcG9wdWxhdGVkXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBBbGlhcyBvZiBbYC5wb3B1bGF0ZWRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlZCgpKS5cbiAqXG4gKiBAbWV0aG9kICRwb3B1bGF0ZWRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJHBvcHVsYXRlZCA9IERvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZWQ7XG5cbi8qKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIGEgZ2l2ZW4gcGF0aCBpcyBub3QgcG9wdWxhdGVkXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNb2RlbC5maW5kT25lKCkucG9wdWxhdGUoJ2F1dGhvcicpO1xuICpcbiAqICAgICBkb2MuJGFzc2VydFBvcHVsYXRlZCgnYXV0aG9yJyk7IC8vIGRvZXMgbm90IHRocm93XG4gKiAgICAgZG9jLiRhc3NlcnRQb3B1bGF0ZWQoJ290aGVyIHBhdGgnKTsgLy8gdGhyb3dzIGFuIGVycm9yXG4gKlxuICogICAgIC8vIE1hbnVhbGx5IHBvcHVsYXRlIGFuZCBhc3NlcnQgaW4gb25lIGNhbGwuIFRoZSBmb2xsb3dpbmcgZG9lc1xuICogICAgIC8vIGBkb2MuJHNldCh7IGxpa2VzIH0pYCBiZWZvcmUgYXNzZXJ0aW5nLlxuICogICAgIGRvYy4kYXNzZXJ0UG9wdWxhdGVkKCdsaWtlcycsIHsgbGlrZXMgfSk7XG4gKlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBwYXRoIHBhdGggb3IgYXJyYXkgb2YgcGF0aHMgdG8gY2hlY2suIGAkYXNzZXJ0UG9wdWxhdGVkYCB0aHJvd3MgaWYgYW55IG9mIHRoZSBnaXZlbiBwYXRocyBpcyBub3QgcG9wdWxhdGVkLlxuICogQHBhcmFtIHtPYmplY3R9IFt2YWx1ZXNdIG9wdGlvbmFsIHZhbHVlcyB0byBgJHNldCgpYC4gQ29udmVuaWVudCBpZiB5b3Ugd2FudCB0byBtYW51YWxseSBwb3B1bGF0ZSBhIHBhdGggYW5kIGFzc2VydCB0aGF0IHRoZSBwYXRoIHdhcyBwb3B1bGF0ZWQgaW4gMSBjYWxsLlxuICogQHJldHVybiB7RG9jdW1lbnR9IHRoaXNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQG1ldGhvZCAkYXNzZXJ0UG9wdWxhdGVkXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRhc3NlcnRQb3B1bGF0ZWQgPSBmdW5jdGlvbiAkYXNzZXJ0UG9wdWxhdGVkKHBhdGgsIHZhbHVlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHBhdGguZm9yRWFjaChwID0+IHRoaXMuJGFzc2VydFBvcHVsYXRlZChwLCB2YWx1ZXMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHRoaXMuJHNldCh2YWx1ZXMpO1xuICB9XG5cbiAgaWYgKCF0aGlzLiRwb3B1bGF0ZWQocGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihgRXhwZWN0ZWQgcGF0aCBcIiR7cGF0aH1cIiB0byBiZSBwb3B1bGF0ZWRgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIHBvcHVsYXRlZCBmaWVsZCBhbmQgcmV0dXJucyBpdCB0byBpdHMgdW5wb3B1bGF0ZWQgc3RhdGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBNb2RlbC5maW5kT25lKCkucG9wdWxhdGUoJ2F1dGhvcicpLmV4ZWMoZnVuY3Rpb24gKGVyciwgZG9jKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MuYXV0aG9yLm5hbWUpOyAvLyBEci5TZXVzc1xuICogICAgICAgY29uc29sZS5sb2coZG9jLmRlcG9wdWxhdGUoJ2F1dGhvcicpKTtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5hdXRob3IpOyAvLyAnNTE0NGNmODA1MGYwNzFkOTc5YzExOGE3J1xuICogICAgIH0pXG4gKlxuICogSWYgdGhlIHBhdGggd2FzIG5vdCBwcm92aWRlZCwgdGhlbiBhbGwgcG9wdWxhdGVkIGZpZWxkcyBhcmUgcmV0dXJuZWQgdG8gdGhlaXIgdW5wb3B1bGF0ZWQgc3RhdGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IFtwYXRoXSBTcGVjaWZpYyBQYXRoIHRvIGRlcG9wdWxhdGUuIElmIHVuc2V0LCB3aWxsIGRlcG9wdWxhdGUgYWxsIHBhdGhzIG9uIHRoZSBEb2N1bWVudC4gT3IgbXVsdGlwbGUgc3BhY2UtZGVsaW1pdGVkIHBhdGhzLlxuICogQHJldHVybiB7RG9jdW1lbnR9IHRoaXNcbiAqIEBzZWUgRG9jdW1lbnQucG9wdWxhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZSgpXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuZGVwb3B1bGF0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHBhdGggPSBwYXRoLmluZGV4T2YoJyAnKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcgJyk7XG4gIH1cblxuICBsZXQgcG9wdWxhdGVkSWRzO1xuICBjb25zdCB2aXJ0dWFsS2V5cyA9IHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFscyA/IE9iamVjdC5rZXlzKHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFscykgOiBbXTtcbiAgY29uc3QgcG9wdWxhdGVkID0gdGhpcy4kX18gJiYgdGhpcy4kX18ucG9wdWxhdGVkIHx8IHt9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gRGVwb3B1bGF0ZSBhbGxcbiAgICBmb3IgKGNvbnN0IHZpcnR1YWxLZXkgb2YgdmlydHVhbEtleXMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbdmlydHVhbEtleV07XG4gICAgICBkZWxldGUgdGhpcy5fZG9jW3ZpcnR1YWxLZXldO1xuICAgICAgZGVsZXRlIHBvcHVsYXRlZFt2aXJ0dWFsS2V5XTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocG9wdWxhdGVkKTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIHBvcHVsYXRlZElkcyA9IHRoaXMuJHBvcHVsYXRlZChrZXkpO1xuICAgICAgaWYgKCFwb3B1bGF0ZWRJZHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBkZWxldGUgcG9wdWxhdGVkW2tleV07XG4gICAgICB1dGlscy5zZXRWYWx1ZShrZXksIHBvcHVsYXRlZElkcywgdGhpcy5fZG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IgKGNvbnN0IHNpbmdsZVBhdGggb2YgcGF0aCkge1xuICAgIHBvcHVsYXRlZElkcyA9IHRoaXMuJHBvcHVsYXRlZChzaW5nbGVQYXRoKTtcbiAgICBkZWxldGUgcG9wdWxhdGVkW3NpbmdsZVBhdGhdO1xuXG4gICAgaWYgKHZpcnR1YWxLZXlzLmluZGV4T2Yoc2luZ2xlUGF0aCkgIT09IC0xKSB7XG4gICAgICBkZWxldGUgdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzW3NpbmdsZVBhdGhdO1xuICAgICAgZGVsZXRlIHRoaXMuX2RvY1tzaW5nbGVQYXRoXTtcbiAgICB9IGVsc2UgaWYgKHBvcHVsYXRlZElkcykge1xuICAgICAgdXRpbHMuc2V0VmFsdWUoc2luZ2xlUGF0aCwgcG9wdWxhdGVkSWRzLCB0aGlzLl9kb2MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIHBhdGggdG8gdGhpcyBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fZnVsbFBhdGhcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX2Z1bGxQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICAvLyBvdmVycmlkZGVuIGluIFN1YkRvY3VtZW50c1xuICByZXR1cm4gcGF0aCB8fCAnJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2hhbmdlcyB0aGF0IGhhcHBlbmVkIHRvIHRoZSBkb2N1bWVudFxuICogaW4gdGhlIGZvcm1hdCB0aGF0IHdpbGwgYmUgc2VudCB0byBNb25nb0RCLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgbmFtZTogU3RyaW5nLFxuICogICAgICAgYWdlOiBOdW1iZXIsXG4gKiAgICAgICBjb3VudHJ5OiBTdHJpbmdcbiAqICAgICB9KTtcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCB1c2VyU2NoZW1hKTtcbiAqICAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlci5jcmVhdGUoe1xuICogICAgICAgbmFtZTogJ0hhZmV6JyxcbiAqICAgICAgIGFnZTogMjUsXG4gKiAgICAgICBjb3VudHJ5OiAnRWd5cHQnXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIHJldHVybnMgYW4gZW1wdHkgb2JqZWN0LCBubyBjaGFuZ2VzIGhhcHBlbmVkIHlldFxuICogICAgIHVzZXIuZ2V0Q2hhbmdlcygpOyAvLyB7IH1cbiAqXG4gKiAgICAgdXNlci5jb3VudHJ5ID0gdW5kZWZpbmVkO1xuICogICAgIHVzZXIuYWdlID0gMjY7XG4gKlxuICogICAgIHVzZXIuZ2V0Q2hhbmdlcygpOyAvLyB7ICRzZXQ6IHsgYWdlOiAyNiB9LCB7ICR1bnNldDogeyBjb3VudHJ5OiAxIH0gfSB9XG4gKlxuICogICAgIGF3YWl0IHVzZXIuc2F2ZSgpO1xuICpcbiAqICAgICB1c2VyLmdldENoYW5nZXMoKTsgLy8geyB9XG4gKlxuICogTW9kaWZ5aW5nIHRoZSBvYmplY3QgdGhhdCBgZ2V0Q2hhbmdlcygpYCByZXR1cm5zIGRvZXMgbm90IGFmZmVjdCB0aGUgZG9jdW1lbnQnc1xuICogY2hhbmdlIHRyYWNraW5nIHN0YXRlLiBFdmVuIGlmIHlvdSBgZGVsZXRlIHVzZXIuZ2V0Q2hhbmdlcygpLiRzZXRgLCBNb25nb29zZVxuICogd2lsbCBzdGlsbCBzZW5kIGEgYCRzZXRgIHRvIHRoZSBzZXJ2ZXIuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgZ2V0Q2hhbmdlc1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuZ2V0Q2hhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBkZWx0YSA9IHRoaXMuJF9fZGVsdGEoKTtcbiAgY29uc3QgY2hhbmdlcyA9IGRlbHRhID8gZGVsdGFbMV0gOiB7fTtcbiAgcmV0dXJuIGNoYW5nZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgZG9jdW1lbnQgd2l0aCBhIGRlZXAgY2xvbmUgb2YgYF9kb2NgIGFuZCBgJF9fYC5cbiAqXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gYSBjb3B5IG9mIHRoaXMgZG9jdW1lbnRcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kICRjbG9uZVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IE1vZGVsID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgY29uc3QgY2xvbmVkRG9jID0gbmV3IE1vZGVsKCk7XG4gIGNsb25lZERvYy4kaXNOZXcgPSB0aGlzLiRpc05ldztcbiAgaWYgKHRoaXMuX2RvYykge1xuICAgIGNsb25lZERvYy5fZG9jID0gY2xvbmUodGhpcy5fZG9jKTtcbiAgfVxuICBpZiAodGhpcy4kX18pIHtcbiAgICBjb25zdCBDYWNoZSA9IHRoaXMuJF9fLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGNsb25lZENhY2hlID0gbmV3IENhY2hlKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy4kX18pKSB7XG4gICAgICBpZiAoa2V5ID09PSAnYWN0aXZlUGF0aHMnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2xvbmVkQ2FjaGVba2V5XSA9IGNsb25lKHRoaXMuJF9fW2tleV0pO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKGNsb25lZENhY2hlLmFjdGl2ZVBhdGhzLCBjbG9uZSh7IC4uLnRoaXMuJF9fLmFjdGl2ZVBhdGhzIH0pKTtcbiAgICBjbG9uZWREb2MuJF9fID0gY2xvbmVkQ2FjaGU7XG4gIH1cbiAgcmV0dXJuIGNsb25lZERvYztcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuRG9jdW1lbnQuVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gRG9jdW1lbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/document.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/document_provider.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/document_provider.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint-env browser */\n\n/*!\n * Module dependencies.\n */\nconst Document = __webpack_require__(/*! ./document.js */ \"(api)/../server/node_modules/mongoose/lib/document.js\");\nconst BrowserDocument = __webpack_require__(/*! ./browserDocument.js */ \"(api)/../server/node_modules/mongoose/lib/browserDocument.js\");\n\nlet isBrowser = false;\n\n/**\n * Returns the Document constructor for the current context\n *\n * @api private\n */\nmodule.exports = function() {\n  if (isBrowser) {\n    return BrowserDocument;\n  }\n  return Document;\n};\n\n/*!\n * ignore\n */\nmodule.exports.setBrowser = function(flag) {\n  isBrowser = flag;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZG9jdW1lbnRfcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsNEVBQWU7QUFDeEMsd0JBQXdCLG1CQUFPLENBQUMsMEZBQXNCOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcZG9jdW1lbnRfcHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5jb25zdCBEb2N1bWVudCA9IHJlcXVpcmUoJy4vZG9jdW1lbnQuanMnKTtcbmNvbnN0IEJyb3dzZXJEb2N1bWVudCA9IHJlcXVpcmUoJy4vYnJvd3NlckRvY3VtZW50LmpzJyk7XG5cbmxldCBpc0Jyb3dzZXIgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBEb2N1bWVudCBjb25zdHJ1Y3RvciBmb3IgdGhlIGN1cnJlbnQgY29udGV4dFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIEJyb3dzZXJEb2N1bWVudDtcbiAgfVxuICByZXR1cm4gRG9jdW1lbnQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5tb2R1bGUuZXhwb3J0cy5zZXRCcm93c2VyID0gZnVuY3Rpb24oZmxhZykge1xuICBpc0Jyb3dzZXIgPSBmbGFnO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/document_provider.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/driver.js":
/*!*****************************************************!*\
  !*** ../server/node_modules/mongoose/lib/driver.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nlet driver = null;\n\nmodule.exports.get = function() {\n  return driver;\n};\n\nmodule.exports.set = function(v) {\n  driver = v;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZHJpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGRyaXZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubGV0IGRyaXZlciA9IG51bGw7XG5cbm1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZHJpdmVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24odikge1xuICBkcml2ZXIgPSB2O1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/driver.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseCollection = __webpack_require__(/*! ../../collection */ \"(api)/../server/node_modules/mongoose/lib/collection.js\");\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst Collection = (__webpack_require__(/*! mongodb */ \"(api)/../server/node_modules/mongodb/lib/index.js\").Collection);\nconst ObjectId = __webpack_require__(/*! ../../types/objectid */ \"(api)/../server/node_modules/mongoose/lib/types/objectid.js\");\nconst getConstructorName = __webpack_require__(/*! ../../helpers/getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../../options */ \"(api)/../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.\n *\n * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.\n *\n * @inherits Collection https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html\n * @api private\n */\n\nfunction NativeCollection(name, conn, options) {\n  this.collection = null;\n  this.Promise = options.Promise || Promise;\n  this.modelName = options.modelName;\n  delete options.modelName;\n  this._closed = false;\n  MongooseCollection.apply(this, arguments);\n}\n\n/*!\n * Inherit from abstract Collection.\n */\n\nObject.setPrototypeOf(NativeCollection.prototype, MongooseCollection.prototype);\n\n/**\n * Called when the connection opens.\n *\n * @api private\n */\n\nNativeCollection.prototype.onOpen = function() {\n  this.collection = this.conn.db.collection(this.name);\n  MongooseCollection.prototype.onOpen.call(this);\n  return this.collection;\n};\n\n/**\n * Called when the connection closes\n *\n * @api private\n */\n\nNativeCollection.prototype.onClose = function(force) {\n  MongooseCollection.prototype.onClose.call(this, force);\n};\n\n/**\n * Helper to get the collection, in case `this.collection` isn't set yet.\n * May happen if `bufferCommands` is false and created the model when\n * Mongoose was disconnected.\n *\n * @api private\n */\n\nNativeCollection.prototype._getCollection = function _getCollection() {\n  if (this.collection) {\n    return this.collection;\n  }\n  if (this.conn.db != null) {\n    this.collection = this.conn.db.collection(this.name);\n    return this.collection;\n  }\n  return null;\n};\n\n/*!\n * ignore\n */\n\nconst syncCollectionMethods = { watch: true, find: true, aggregate: true };\n\n/**\n * Copy the collection methods and make them subject to queues\n * @param {Number|String} I\n * @api private\n */\n\nfunction iter(i) {\n  NativeCollection.prototype[i] = function() {\n    const collection = this._getCollection();\n    const args = Array.from(arguments);\n    const _this = this;\n    const globalDebug = _this &&\n      _this.conn &&\n      _this.conn.base &&\n      _this.conn.base.options &&\n      _this.conn.base.options.debug;\n    const connectionDebug = _this &&\n      _this.conn &&\n      _this.conn.options &&\n      _this.conn.options.debug;\n    const debug = connectionDebug == null ? globalDebug : connectionDebug;\n    const lastArg = arguments[arguments.length - 1];\n    const opId = new ObjectId();\n\n    // If user force closed, queueing will hang forever. See #5664\n    if (this.conn.$wasForceClosed) {\n      const error = new MongooseError('Connection was force closed');\n      if (args.length > 0 &&\n        typeof args[args.length - 1] === 'function') {\n        args[args.length - 1](error);\n        return;\n      } else {\n        throw error;\n      }\n    }\n\n    let _args = args;\n    let callback = null;\n    if (this._shouldBufferCommands() && this.buffer) {\n      this.conn.emit('buffer', {\n        _id: opId,\n        modelName: _this.modelName,\n        collectionName: _this.name,\n        method: i,\n        args: args\n      });\n\n      let callback;\n      let _args = args;\n      let promise = null;\n      let timeout = null;\n      if (syncCollectionMethods[i] && typeof lastArg === 'function') {\n        this.addQueue(i, _args);\n        callback = lastArg;\n      } else if (syncCollectionMethods[i]) {\n        promise = new this.Promise((resolve, reject) => {\n          callback = function collectionOperationCallback(err, res) {\n            if (timeout != null) {\n              clearTimeout(timeout);\n            }\n            if (err != null) {\n              return reject(err);\n            }\n            resolve(res);\n          };\n          _args = args.concat([callback]);\n          this.addQueue(i, _args);\n        });\n      } else if (typeof lastArg === 'function') {\n        callback = function collectionOperationCallback() {\n          if (timeout != null) {\n            clearTimeout(timeout);\n          }\n          return lastArg.apply(this, arguments);\n        };\n        _args = args.slice(0, args.length - 1).concat([callback]);\n      } else {\n        promise = new Promise((resolve, reject) => {\n          callback = function collectionOperationCallback(err, res) {\n            if (timeout != null) {\n              clearTimeout(timeout);\n            }\n            if (err != null) {\n              return reject(err);\n            }\n            resolve(res);\n          };\n          _args = args.concat([callback]);\n          this.addQueue(i, _args);\n        });\n      }\n\n      const bufferTimeoutMS = this._getBufferTimeoutMS();\n      timeout = setTimeout(() => {\n        const removed = this.removeQueue(i, _args);\n        if (removed) {\n          const message = 'Operation `' + this.name + '.' + i + '()` buffering timed out after ' +\n            bufferTimeoutMS + 'ms';\n          const err = new MongooseError(message);\n          this.conn.emit('buffer-end', { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });\n          callback(err);\n        }\n      }, bufferTimeoutMS);\n\n      if (!syncCollectionMethods[i] && typeof lastArg === 'function') {\n        this.addQueue(i, _args);\n        return;\n      }\n\n      return promise;\n    } else if (!syncCollectionMethods[i] && typeof lastArg === 'function') {\n      callback = function collectionOperationCallback(err, res) {\n        if (err != null) {\n          _this.conn.emit('operation-end', { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });\n        } else {\n          _this.conn.emit('operation-end', { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, result: res });\n        }\n        return lastArg.apply(this, arguments);\n      };\n      _args = args.slice(0, args.length - 1).concat([callback]);\n    }\n\n    if (debug) {\n      if (typeof debug === 'function') {\n        let argsToAdd = null;\n        if (typeof args[args.length - 1] == 'function') {\n          argsToAdd = args.slice(0, args.length - 1);\n        } else {\n          argsToAdd = args;\n        }\n        debug.apply(_this,\n          [_this.name, i].concat(argsToAdd));\n      } else if (debug instanceof stream.Writable) {\n        this.$printToStream(_this.name, i, args, debug);\n      } else {\n        const color = debug.color == null ? true : debug.color;\n        const shell = debug.shell == null ? false : debug.shell;\n        this.$print(_this.name, i, args, color, shell);\n      }\n    }\n\n    this.conn.emit('operation-start', { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, params: _args });\n\n    try {\n      if (collection == null) {\n        const message = 'Cannot call `' + this.name + '.' + i + '()` before initial connection ' +\n          'is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if ' +\n          'you have `bufferCommands = false`.';\n        throw new MongooseError(message);\n      }\n\n      if (syncCollectionMethods[i] && typeof lastArg === 'function') {\n        const ret = collection[i].apply(collection, _args.slice(0, _args.length - 1));\n        return lastArg.call(this, null, ret);\n      }\n\n      const ret = collection[i].apply(collection, _args);\n      if (ret != null && typeof ret.then === 'function') {\n        return ret.then(\n          res => {\n            typeof lastArg === 'function' && lastArg(null, res);\n            return res;\n          },\n          err => {\n            if (typeof lastArg === 'function') {\n              lastArg(err);\n              return;\n            }\n            throw err;\n          }\n        );\n      }\n      return ret;\n    } catch (error) {\n      // Collection operation may throw because of max bson size, catch it here\n      // See gh-3906\n      if (typeof lastArg === 'function') {\n        return lastArg(error);\n      } else {\n        this.conn.emit('operation-end', { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error: error });\n\n        throw error;\n      }\n    }\n  };\n}\n\nfor (const key of Object.getOwnPropertyNames(Collection.prototype)) {\n  // Janky hack to work around gh-3005 until we can get rid of the mongoose\n  // collection abstraction\n  const descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key);\n  // Skip properties with getters because they may throw errors (gh-8528)\n  if (descriptor.get !== undefined) {\n    continue;\n  }\n  if (typeof Collection.prototype[key] !== 'function') {\n    continue;\n  }\n\n  iter(key);\n}\n\n/**\n * Debug print helper\n *\n * @api public\n * @method $print\n */\n\nNativeCollection.prototype.$print = function(name, i, args, color, shell) {\n  const moduleName = color ? '\\x1B[0;36mMongoose:\\x1B[0m ' : 'Mongoose: ';\n  const functionCall = [name, i].join('.');\n  const _args = [];\n  for (let j = args.length - 1; j >= 0; --j) {\n    if (this.$format(args[j]) || _args.length) {\n      _args.unshift(this.$format(args[j], color, shell));\n    }\n  }\n  const params = '(' + _args.join(', ') + ')';\n\n  console.info(moduleName + functionCall + params);\n};\n\n/**\n * Debug print helper\n *\n * @api public\n * @method $print\n */\n\nNativeCollection.prototype.$printToStream = function(name, i, args, stream) {\n  const functionCall = [name, i].join('.');\n  const _args = [];\n  for (let j = args.length - 1; j >= 0; --j) {\n    if (this.$format(args[j]) || _args.length) {\n      _args.unshift(this.$format(args[j]));\n    }\n  }\n  const params = '(' + _args.join(', ') + ')';\n\n  stream.write(functionCall + params, 'utf8');\n};\n\n/**\n * Formatter for debug print args\n *\n * @api public\n * @method $format\n */\n\nNativeCollection.prototype.$format = function(arg, color, shell) {\n  const type = typeof arg;\n  if (type === 'function' || type === 'undefined') return '';\n  return format(arg, false, color, shell);\n};\n\n/**\n * Debug print helper\n * @param {Any} representation\n * @api private\n */\n\nfunction inspectable(representation) {\n  const ret = {\n    inspect: function() { return representation; }\n  };\n  if (util.inspect.custom) {\n    ret[util.inspect.custom] = ret.inspect;\n  }\n  return ret;\n}\nfunction map(o) {\n  return format(o, true);\n}\nfunction formatObjectId(x, key) {\n  x[key] = inspectable('ObjectId(\"' + x[key].toHexString() + '\")');\n}\nfunction formatDate(x, key, shell) {\n  if (shell) {\n    x[key] = inspectable('ISODate(\"' + x[key].toUTCString() + '\")');\n  } else {\n    x[key] = inspectable('new Date(\"' + x[key].toUTCString() + '\")');\n  }\n}\nfunction format(obj, sub, color, shell) {\n  if (obj && typeof obj.toBSON === 'function') {\n    obj = obj.toBSON();\n  }\n  if (obj == null) {\n    return obj;\n  }\n\n  const clone = __webpack_require__(/*! ../../helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\n  let x = clone(obj, internalToObjectOptions);\n  const constructorName = getConstructorName(x);\n\n  if (constructorName === 'Binary') {\n    x = 'BinData(' + x.sub_type + ', \"' + x.toString('base64') + '\")';\n  } else if (constructorName === 'ObjectId') {\n    x = inspectable('ObjectId(\"' + x.toHexString() + '\")');\n  } else if (constructorName === 'Date') {\n    x = inspectable('new Date(\"' + x.toUTCString() + '\")');\n  } else if (constructorName === 'Object') {\n    const keys = Object.keys(x);\n    const numKeys = keys.length;\n    let key;\n    for (let i = 0; i < numKeys; ++i) {\n      key = keys[i];\n      if (x[key]) {\n        let error;\n        if (typeof x[key].toBSON === 'function') {\n          try {\n            // `session.toBSON()` throws an error. This means we throw errors\n            // in debug mode when using transactions, see gh-6712. As a\n            // workaround, catch `toBSON()` errors, try to serialize without\n            // `toBSON()`, and rethrow if serialization still fails.\n            x[key] = x[key].toBSON();\n          } catch (_error) {\n            error = _error;\n          }\n        }\n        const _constructorName = getConstructorName(x[key]);\n        if (_constructorName === 'Binary') {\n          x[key] = 'BinData(' + x[key].sub_type + ', \"' +\n            x[key].buffer.toString('base64') + '\")';\n        } else if (_constructorName === 'Object') {\n          x[key] = format(x[key], true);\n        } else if (_constructorName === 'ObjectId') {\n          formatObjectId(x, key);\n        } else if (_constructorName === 'Date') {\n          formatDate(x, key, shell);\n        } else if (_constructorName === 'ClientSession') {\n          x[key] = inspectable('ClientSession(\"' +\n            (\n              x[key] &&\n              x[key].id &&\n              x[key].id.id &&\n              x[key].id.id.buffer || ''\n            ).toString('hex') + '\")');\n        } else if (Array.isArray(x[key])) {\n          x[key] = x[key].map(map);\n        } else if (error != null) {\n          // If there was an error with `toBSON()` and the object wasn't\n          // already converted to a string representation, rethrow it.\n          // Open to better ideas on how to handle this.\n          throw error;\n        }\n      }\n    }\n  }\n  if (sub) {\n    return x;\n  }\n\n  return util.\n    inspect(x, false, 10, color).\n    replace(/\\n/g, '').\n    replace(/\\s{2,}/g, ' ');\n}\n\n/**\n * Retrieves information about this collections indexes.\n *\n * @param {Function} callback\n * @method getIndexes\n * @api public\n */\n\nNativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeCollection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZHJpdmVycy9ub2RlLW1vbmdvZGItbmF0aXZlL2NvbGxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixtQkFBTyxDQUFDLGlGQUFrQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyxtR0FBMkI7QUFDekQsbUJBQW1CLG9HQUE2QjtBQUNoRCxpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDL0MsMkJBQTJCLG1CQUFPLENBQUMsaUhBQWtDO0FBQ3JFLGdDQUFnQywwSEFBZ0Q7QUFDaEYsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxkcml2ZXJzXFxub2RlLW1vbmdvZGItbmF0aXZlXFxjb2xsZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IE1vbmdvb3NlQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL2NvbGxlY3Rpb24nKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBDb2xsZWN0aW9uID0gcmVxdWlyZSgnbW9uZ29kYicpLkNvbGxlY3Rpb247XG5jb25zdCBPYmplY3RJZCA9IHJlcXVpcmUoJy4uLy4uL3R5cGVzL29iamVjdGlkJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2dldENvbnN0cnVjdG9yTmFtZScpO1xuY29uc3QgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgPSByZXF1aXJlKCcuLi8uLi9vcHRpb25zJykuaW50ZXJuYWxUb09iamVjdE9wdGlvbnM7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogQSBbbm9kZS1tb25nb2RiLW5hdGl2ZV0oaHR0cHM6Ly9naXRodWIuY29tL21vbmdvZGIvbm9kZS1tb25nb2RiLW5hdGl2ZSkgY29sbGVjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBBbGwgbWV0aG9kcyBtZXRob2RzIGZyb20gdGhlIFtub2RlLW1vbmdvZGItbmF0aXZlXShodHRwczovL2dpdGh1Yi5jb20vbW9uZ29kYi9ub2RlLW1vbmdvZGItbmF0aXZlKSBkcml2ZXIgYXJlIGNvcGllZCBhbmQgd3JhcHBlZCBpbiBxdWV1ZSBtYW5hZ2VtZW50LlxuICpcbiAqIEBpbmhlcml0cyBDb2xsZWN0aW9uIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIE5hdGl2ZUNvbGxlY3Rpb24obmFtZSwgY29ubiwgb3B0aW9ucykge1xuICB0aGlzLmNvbGxlY3Rpb24gPSBudWxsO1xuICB0aGlzLlByb21pc2UgPSBvcHRpb25zLlByb21pc2UgfHwgUHJvbWlzZTtcbiAgdGhpcy5tb2RlbE5hbWUgPSBvcHRpb25zLm1vZGVsTmFtZTtcbiAgZGVsZXRlIG9wdGlvbnMubW9kZWxOYW1lO1xuICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgTW9uZ29vc2VDb2xsZWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIGFic3RyYWN0IENvbGxlY3Rpb24uXG4gKi9cblxuT2JqZWN0LnNldFByb3RvdHlwZU9mKE5hdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlLCBNb25nb29zZUNvbGxlY3Rpb24ucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBvcGVucy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5OYXRpdmVDb2xsZWN0aW9uLnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb2xsZWN0aW9uID0gdGhpcy5jb25uLmRiLmNvbGxlY3Rpb24odGhpcy5uYW1lKTtcbiAgTW9uZ29vc2VDb2xsZWN0aW9uLnByb3RvdHlwZS5vbk9wZW4uY2FsbCh0aGlzKTtcbiAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbjtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gY2xvc2VzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gIE1vbmdvb3NlQ29sbGVjdGlvbi5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMsIGZvcmNlKTtcbn07XG5cbi8qKlxuICogSGVscGVyIHRvIGdldCB0aGUgY29sbGVjdGlvbiwgaW4gY2FzZSBgdGhpcy5jb2xsZWN0aW9uYCBpc24ndCBzZXQgeWV0LlxuICogTWF5IGhhcHBlbiBpZiBgYnVmZmVyQ29tbWFuZHNgIGlzIGZhbHNlIGFuZCBjcmVhdGVkIHRoZSBtb2RlbCB3aGVuXG4gKiBNb25nb29zZSB3YXMgZGlzY29ubmVjdGVkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk5hdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlLl9nZXRDb2xsZWN0aW9uID0gZnVuY3Rpb24gX2dldENvbGxlY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNvbGxlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uO1xuICB9XG4gIGlmICh0aGlzLmNvbm4uZGIgIT0gbnVsbCkge1xuICAgIHRoaXMuY29sbGVjdGlvbiA9IHRoaXMuY29ubi5kYi5jb2xsZWN0aW9uKHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3Qgc3luY0NvbGxlY3Rpb25NZXRob2RzID0geyB3YXRjaDogdHJ1ZSwgZmluZDogdHJ1ZSwgYWdncmVnYXRlOiB0cnVlIH07XG5cbi8qKlxuICogQ29weSB0aGUgY29sbGVjdGlvbiBtZXRob2RzIGFuZCBtYWtlIHRoZW0gc3ViamVjdCB0byBxdWV1ZXNcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gSVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXRlcihpKSB7XG4gIE5hdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlW2ldID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMuX2dldENvbGxlY3Rpb24oKTtcbiAgICBjb25zdCBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICBjb25zdCBnbG9iYWxEZWJ1ZyA9IF90aGlzICYmXG4gICAgICBfdGhpcy5jb25uICYmXG4gICAgICBfdGhpcy5jb25uLmJhc2UgJiZcbiAgICAgIF90aGlzLmNvbm4uYmFzZS5vcHRpb25zICYmXG4gICAgICBfdGhpcy5jb25uLmJhc2Uub3B0aW9ucy5kZWJ1ZztcbiAgICBjb25zdCBjb25uZWN0aW9uRGVidWcgPSBfdGhpcyAmJlxuICAgICAgX3RoaXMuY29ubiAmJlxuICAgICAgX3RoaXMuY29ubi5vcHRpb25zICYmXG4gICAgICBfdGhpcy5jb25uLm9wdGlvbnMuZGVidWc7XG4gICAgY29uc3QgZGVidWcgPSBjb25uZWN0aW9uRGVidWcgPT0gbnVsbCA/IGdsb2JhbERlYnVnIDogY29ubmVjdGlvbkRlYnVnO1xuICAgIGNvbnN0IGxhc3RBcmcgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IG9wSWQgPSBuZXcgT2JqZWN0SWQoKTtcblxuICAgIC8vIElmIHVzZXIgZm9yY2UgY2xvc2VkLCBxdWV1ZWluZyB3aWxsIGhhbmcgZm9yZXZlci4gU2VlICM1NjY0XG4gICAgaWYgKHRoaXMuY29ubi4kd2FzRm9yY2VDbG9zZWQpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IE1vbmdvb3NlRXJyb3IoJ0Nvbm5lY3Rpb24gd2FzIGZvcmNlIGNsb3NlZCcpO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCAmJlxuICAgICAgICB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXShlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBfYXJncyA9IGFyZ3M7XG4gICAgbGV0IGNhbGxiYWNrID0gbnVsbDtcbiAgICBpZiAodGhpcy5fc2hvdWxkQnVmZmVyQ29tbWFuZHMoKSAmJiB0aGlzLmJ1ZmZlcikge1xuICAgICAgdGhpcy5jb25uLmVtaXQoJ2J1ZmZlcicsIHtcbiAgICAgICAgX2lkOiBvcElkLFxuICAgICAgICBtb2RlbE5hbWU6IF90aGlzLm1vZGVsTmFtZSxcbiAgICAgICAgY29sbGVjdGlvbk5hbWU6IF90aGlzLm5hbWUsXG4gICAgICAgIG1ldGhvZDogaSxcbiAgICAgICAgYXJnczogYXJnc1xuICAgICAgfSk7XG5cbiAgICAgIGxldCBjYWxsYmFjaztcbiAgICAgIGxldCBfYXJncyA9IGFyZ3M7XG4gICAgICBsZXQgcHJvbWlzZSA9IG51bGw7XG4gICAgICBsZXQgdGltZW91dCA9IG51bGw7XG4gICAgICBpZiAoc3luY0NvbGxlY3Rpb25NZXRob2RzW2ldICYmIHR5cGVvZiBsYXN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuYWRkUXVldWUoaSwgX2FyZ3MpO1xuICAgICAgICBjYWxsYmFjayA9IGxhc3RBcmc7XG4gICAgICB9IGVsc2UgaWYgKHN5bmNDb2xsZWN0aW9uTWV0aG9kc1tpXSkge1xuICAgICAgICBwcm9taXNlID0gbmV3IHRoaXMuUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiBjb2xsZWN0aW9uT3BlcmF0aW9uQ2FsbGJhY2soZXJyLCByZXMpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIF9hcmdzID0gYXJncy5jb25jYXQoW2NhbGxiYWNrXSk7XG4gICAgICAgICAgdGhpcy5hZGRRdWV1ZShpLCBfYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIGNvbGxlY3Rpb25PcGVyYXRpb25DYWxsYmFjaygpIHtcbiAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsYXN0QXJnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIF9hcmdzID0gYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpLmNvbmNhdChbY2FsbGJhY2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiBjb2xsZWN0aW9uT3BlcmF0aW9uQ2FsbGJhY2soZXJyLCByZXMpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIF9hcmdzID0gYXJncy5jb25jYXQoW2NhbGxiYWNrXSk7XG4gICAgICAgICAgdGhpcy5hZGRRdWV1ZShpLCBfYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBidWZmZXJUaW1lb3V0TVMgPSB0aGlzLl9nZXRCdWZmZXJUaW1lb3V0TVMoKTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHRoaXMucmVtb3ZlUXVldWUoaSwgX2FyZ3MpO1xuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnT3BlcmF0aW9uIGAnICsgdGhpcy5uYW1lICsgJy4nICsgaSArICcoKWAgYnVmZmVyaW5nIHRpbWVkIG91dCBhZnRlciAnICtcbiAgICAgICAgICAgIGJ1ZmZlclRpbWVvdXRNUyArICdtcyc7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IE1vbmdvb3NlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgdGhpcy5jb25uLmVtaXQoJ2J1ZmZlci1lbmQnLCB7IF9pZDogb3BJZCwgbW9kZWxOYW1lOiBfdGhpcy5tb2RlbE5hbWUsIGNvbGxlY3Rpb25OYW1lOiBfdGhpcy5uYW1lLCBtZXRob2Q6IGksIGVycm9yOiBlcnIgfSk7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSwgYnVmZmVyVGltZW91dE1TKTtcblxuICAgICAgaWYgKCFzeW5jQ29sbGVjdGlvbk1ldGhvZHNbaV0gJiYgdHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5hZGRRdWV1ZShpLCBfYXJncyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSBlbHNlIGlmICghc3luY0NvbGxlY3Rpb25NZXRob2RzW2ldICYmIHR5cGVvZiBsYXN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIGNvbGxlY3Rpb25PcGVyYXRpb25DYWxsYmFjayhlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICBfdGhpcy5jb25uLmVtaXQoJ29wZXJhdGlvbi1lbmQnLCB7IF9pZDogb3BJZCwgbW9kZWxOYW1lOiBfdGhpcy5tb2RlbE5hbWUsIGNvbGxlY3Rpb25OYW1lOiBfdGhpcy5uYW1lLCBtZXRob2Q6IGksIGVycm9yOiBlcnIgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuY29ubi5lbWl0KCdvcGVyYXRpb24tZW5kJywgeyBfaWQ6IG9wSWQsIG1vZGVsTmFtZTogX3RoaXMubW9kZWxOYW1lLCBjb2xsZWN0aW9uTmFtZTogX3RoaXMubmFtZSwgbWV0aG9kOiBpLCByZXN1bHQ6IHJlcyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdEFyZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIF9hcmdzID0gYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpLmNvbmNhdChbY2FsbGJhY2tdKTtcbiAgICB9XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGlmICh0eXBlb2YgZGVidWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbGV0IGFyZ3NUb0FkZCA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBhcmdzVG9BZGQgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJnc1RvQWRkID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zy5hcHBseShfdGhpcyxcbiAgICAgICAgICBbX3RoaXMubmFtZSwgaV0uY29uY2F0KGFyZ3NUb0FkZCkpO1xuICAgICAgfSBlbHNlIGlmIChkZWJ1ZyBpbnN0YW5jZW9mIHN0cmVhbS5Xcml0YWJsZSkge1xuICAgICAgICB0aGlzLiRwcmludFRvU3RyZWFtKF90aGlzLm5hbWUsIGksIGFyZ3MsIGRlYnVnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gZGVidWcuY29sb3IgPT0gbnVsbCA/IHRydWUgOiBkZWJ1Zy5jb2xvcjtcbiAgICAgICAgY29uc3Qgc2hlbGwgPSBkZWJ1Zy5zaGVsbCA9PSBudWxsID8gZmFsc2UgOiBkZWJ1Zy5zaGVsbDtcbiAgICAgICAgdGhpcy4kcHJpbnQoX3RoaXMubmFtZSwgaSwgYXJncywgY29sb3IsIHNoZWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbm4uZW1pdCgnb3BlcmF0aW9uLXN0YXJ0JywgeyBfaWQ6IG9wSWQsIG1vZGVsTmFtZTogX3RoaXMubW9kZWxOYW1lLCBjb2xsZWN0aW9uTmFtZTogdGhpcy5uYW1lLCBtZXRob2Q6IGksIHBhcmFtczogX2FyZ3MgfSk7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0Nhbm5vdCBjYWxsIGAnICsgdGhpcy5uYW1lICsgJy4nICsgaSArICcoKWAgYmVmb3JlIGluaXRpYWwgY29ubmVjdGlvbiAnICtcbiAgICAgICAgICAnaXMgY29tcGxldGUgaWYgYGJ1ZmZlckNvbW1hbmRzID0gZmFsc2VgLiBNYWtlIHN1cmUgeW91IGBhd2FpdCBtb25nb29zZS5jb25uZWN0KClgIGlmICcgK1xuICAgICAgICAgICd5b3UgaGF2ZSBgYnVmZmVyQ29tbWFuZHMgPSBmYWxzZWAuJztcbiAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzeW5jQ29sbGVjdGlvbk1ldGhvZHNbaV0gJiYgdHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gY29sbGVjdGlvbltpXS5hcHBseShjb2xsZWN0aW9uLCBfYXJncy5zbGljZSgwLCBfYXJncy5sZW5ndGggLSAxKSk7XG4gICAgICAgIHJldHVybiBsYXN0QXJnLmNhbGwodGhpcywgbnVsbCwgcmV0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmV0ID0gY29sbGVjdGlvbltpXS5hcHBseShjb2xsZWN0aW9uLCBfYXJncyk7XG4gICAgICBpZiAocmV0ICE9IG51bGwgJiYgdHlwZW9mIHJldC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiByZXQudGhlbihcbiAgICAgICAgICByZXMgPT4ge1xuICAgICAgICAgICAgdHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicgJiYgbGFzdEFyZyhudWxsLCByZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgbGFzdEFyZyhlcnIpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gQ29sbGVjdGlvbiBvcGVyYXRpb24gbWF5IHRocm93IGJlY2F1c2Ugb2YgbWF4IGJzb24gc2l6ZSwgY2F0Y2ggaXQgaGVyZVxuICAgICAgLy8gU2VlIGdoLTM5MDZcbiAgICAgIGlmICh0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbGFzdEFyZyhlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbm4uZW1pdCgnb3BlcmF0aW9uLWVuZCcsIHsgX2lkOiBvcElkLCBtb2RlbE5hbWU6IF90aGlzLm1vZGVsTmFtZSwgY29sbGVjdGlvbk5hbWU6IHRoaXMubmFtZSwgbWV0aG9kOiBpLCBlcnJvcjogZXJyb3IgfSk7XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhDb2xsZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgLy8gSmFua3kgaGFjayB0byB3b3JrIGFyb3VuZCBnaC0zMDA1IHVudGlsIHdlIGNhbiBnZXQgcmlkIG9mIHRoZSBtb25nb29zZVxuICAvLyBjb2xsZWN0aW9uIGFic3RyYWN0aW9uXG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKENvbGxlY3Rpb24ucHJvdG90eXBlLCBrZXkpO1xuICAvLyBTa2lwIHByb3BlcnRpZXMgd2l0aCBnZXR0ZXJzIGJlY2F1c2UgdGhleSBtYXkgdGhyb3cgZXJyb3JzIChnaC04NTI4KVxuICBpZiAoZGVzY3JpcHRvci5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnRpbnVlO1xuICB9XG4gIGlmICh0eXBlb2YgQ29sbGVjdGlvbi5wcm90b3R5cGVba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnRpbnVlO1xuICB9XG5cbiAgaXRlcihrZXkpO1xufVxuXG4vKipcbiAqIERlYnVnIHByaW50IGhlbHBlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kICRwcmludFxuICovXG5cbk5hdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlLiRwcmludCA9IGZ1bmN0aW9uKG5hbWUsIGksIGFyZ3MsIGNvbG9yLCBzaGVsbCkge1xuICBjb25zdCBtb2R1bGVOYW1lID0gY29sb3IgPyAnXFx4MUJbMDszNm1Nb25nb29zZTpcXHgxQlswbSAnIDogJ01vbmdvb3NlOiAnO1xuICBjb25zdCBmdW5jdGlvbkNhbGwgPSBbbmFtZSwgaV0uam9pbignLicpO1xuICBjb25zdCBfYXJncyA9IFtdO1xuICBmb3IgKGxldCBqID0gYXJncy5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xuICAgIGlmICh0aGlzLiRmb3JtYXQoYXJnc1tqXSkgfHwgX2FyZ3MubGVuZ3RoKSB7XG4gICAgICBfYXJncy51bnNoaWZ0KHRoaXMuJGZvcm1hdChhcmdzW2pdLCBjb2xvciwgc2hlbGwpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFyYW1zID0gJygnICsgX2FyZ3Muam9pbignLCAnKSArICcpJztcblxuICBjb25zb2xlLmluZm8obW9kdWxlTmFtZSArIGZ1bmN0aW9uQ2FsbCArIHBhcmFtcyk7XG59O1xuXG4vKipcbiAqIERlYnVnIHByaW50IGhlbHBlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kICRwcmludFxuICovXG5cbk5hdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlLiRwcmludFRvU3RyZWFtID0gZnVuY3Rpb24obmFtZSwgaSwgYXJncywgc3RyZWFtKSB7XG4gIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IFtuYW1lLCBpXS5qb2luKCcuJyk7XG4gIGNvbnN0IF9hcmdzID0gW107XG4gIGZvciAobGV0IGogPSBhcmdzLmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgaWYgKHRoaXMuJGZvcm1hdChhcmdzW2pdKSB8fCBfYXJncy5sZW5ndGgpIHtcbiAgICAgIF9hcmdzLnVuc2hpZnQodGhpcy4kZm9ybWF0KGFyZ3Nbal0pKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFyYW1zID0gJygnICsgX2FyZ3Muam9pbignLCAnKSArICcpJztcblxuICBzdHJlYW0ud3JpdGUoZnVuY3Rpb25DYWxsICsgcGFyYW1zLCAndXRmOCcpO1xufTtcblxuLyoqXG4gKiBGb3JtYXR0ZXIgZm9yIGRlYnVnIHByaW50IGFyZ3NcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCAkZm9ybWF0XG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuJGZvcm1hdCA9IGZ1bmN0aW9uKGFyZywgY29sb3IsIHNoZWxsKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJnO1xuICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAndW5kZWZpbmVkJykgcmV0dXJuICcnO1xuICByZXR1cm4gZm9ybWF0KGFyZywgZmFsc2UsIGNvbG9yLCBzaGVsbCk7XG59O1xuXG4vKipcbiAqIERlYnVnIHByaW50IGhlbHBlclxuICogQHBhcmFtIHtBbnl9IHJlcHJlc2VudGF0aW9uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpbnNwZWN0YWJsZShyZXByZXNlbnRhdGlvbikge1xuICBjb25zdCByZXQgPSB7XG4gICAgaW5zcGVjdDogZnVuY3Rpb24oKSB7IHJldHVybiByZXByZXNlbnRhdGlvbjsgfVxuICB9O1xuICBpZiAodXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICAgIHJldFt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IHJldC5pbnNwZWN0O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBtYXAobykge1xuICByZXR1cm4gZm9ybWF0KG8sIHRydWUpO1xufVxuZnVuY3Rpb24gZm9ybWF0T2JqZWN0SWQoeCwga2V5KSB7XG4gIHhba2V5XSA9IGluc3BlY3RhYmxlKCdPYmplY3RJZChcIicgKyB4W2tleV0udG9IZXhTdHJpbmcoKSArICdcIiknKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdERhdGUoeCwga2V5LCBzaGVsbCkge1xuICBpZiAoc2hlbGwpIHtcbiAgICB4W2tleV0gPSBpbnNwZWN0YWJsZSgnSVNPRGF0ZShcIicgKyB4W2tleV0udG9VVENTdHJpbmcoKSArICdcIiknKTtcbiAgfSBlbHNlIHtcbiAgICB4W2tleV0gPSBpbnNwZWN0YWJsZSgnbmV3IERhdGUoXCInICsgeFtrZXldLnRvVVRDU3RyaW5nKCkgKyAnXCIpJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdChvYmosIHN1YiwgY29sb3IsIHNoZWxsKSB7XG4gIGlmIChvYmogJiYgdHlwZW9mIG9iai50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICBvYmogPSBvYmoudG9CU09OKCk7XG4gIH1cbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9jbG9uZScpO1xuICBsZXQgeCA9IGNsb25lKG9iaiwgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xuICBjb25zdCBjb25zdHJ1Y3Rvck5hbWUgPSBnZXRDb25zdHJ1Y3Rvck5hbWUoeCk7XG5cbiAgaWYgKGNvbnN0cnVjdG9yTmFtZSA9PT0gJ0JpbmFyeScpIHtcbiAgICB4ID0gJ0JpbkRhdGEoJyArIHguc3ViX3R5cGUgKyAnLCBcIicgKyB4LnRvU3RyaW5nKCdiYXNlNjQnKSArICdcIiknO1xuICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yTmFtZSA9PT0gJ09iamVjdElkJykge1xuICAgIHggPSBpbnNwZWN0YWJsZSgnT2JqZWN0SWQoXCInICsgeC50b0hleFN0cmluZygpICsgJ1wiKScpO1xuICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yTmFtZSA9PT0gJ0RhdGUnKSB7XG4gICAgeCA9IGluc3BlY3RhYmxlKCduZXcgRGF0ZShcIicgKyB4LnRvVVRDU3RyaW5nKCkgKyAnXCIpJyk7XG4gIH0gZWxzZSBpZiAoY29uc3RydWN0b3JOYW1lID09PSAnT2JqZWN0Jykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh4KTtcbiAgICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGtleTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICh4W2tleV0pIHtcbiAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICBpZiAodHlwZW9mIHhba2V5XS50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gYHNlc3Npb24udG9CU09OKClgIHRocm93cyBhbiBlcnJvci4gVGhpcyBtZWFucyB3ZSB0aHJvdyBlcnJvcnNcbiAgICAgICAgICAgIC8vIGluIGRlYnVnIG1vZGUgd2hlbiB1c2luZyB0cmFuc2FjdGlvbnMsIHNlZSBnaC02NzEyLiBBcyBhXG4gICAgICAgICAgICAvLyB3b3JrYXJvdW5kLCBjYXRjaCBgdG9CU09OKClgIGVycm9ycywgdHJ5IHRvIHNlcmlhbGl6ZSB3aXRob3V0XG4gICAgICAgICAgICAvLyBgdG9CU09OKClgLCBhbmQgcmV0aHJvdyBpZiBzZXJpYWxpemF0aW9uIHN0aWxsIGZhaWxzLlxuICAgICAgICAgICAgeFtrZXldID0geFtrZXldLnRvQlNPTigpO1xuICAgICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBfZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9jb25zdHJ1Y3Rvck5hbWUgPSBnZXRDb25zdHJ1Y3Rvck5hbWUoeFtrZXldKTtcbiAgICAgICAgaWYgKF9jb25zdHJ1Y3Rvck5hbWUgPT09ICdCaW5hcnknKSB7XG4gICAgICAgICAgeFtrZXldID0gJ0JpbkRhdGEoJyArIHhba2V5XS5zdWJfdHlwZSArICcsIFwiJyArXG4gICAgICAgICAgICB4W2tleV0uYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKSArICdcIiknO1xuICAgICAgICB9IGVsc2UgaWYgKF9jb25zdHJ1Y3Rvck5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgeFtrZXldID0gZm9ybWF0KHhba2V5XSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2NvbnN0cnVjdG9yTmFtZSA9PT0gJ09iamVjdElkJykge1xuICAgICAgICAgIGZvcm1hdE9iamVjdElkKHgsIGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2NvbnN0cnVjdG9yTmFtZSA9PT0gJ0RhdGUnKSB7XG4gICAgICAgICAgZm9ybWF0RGF0ZSh4LCBrZXksIHNoZWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChfY29uc3RydWN0b3JOYW1lID09PSAnQ2xpZW50U2Vzc2lvbicpIHtcbiAgICAgICAgICB4W2tleV0gPSBpbnNwZWN0YWJsZSgnQ2xpZW50U2Vzc2lvbihcIicgK1xuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICB4W2tleV0gJiZcbiAgICAgICAgICAgICAgeFtrZXldLmlkICYmXG4gICAgICAgICAgICAgIHhba2V5XS5pZC5pZCAmJlxuICAgICAgICAgICAgICB4W2tleV0uaWQuaWQuYnVmZmVyIHx8ICcnXG4gICAgICAgICAgICApLnRvU3RyaW5nKCdoZXgnKSArICdcIiknKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHhba2V5XSkpIHtcbiAgICAgICAgICB4W2tleV0gPSB4W2tleV0ubWFwKG1hcCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aXRoIGB0b0JTT04oKWAgYW5kIHRoZSBvYmplY3Qgd2Fzbid0XG4gICAgICAgICAgLy8gYWxyZWFkeSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24sIHJldGhyb3cgaXQuXG4gICAgICAgICAgLy8gT3BlbiB0byBiZXR0ZXIgaWRlYXMgb24gaG93IHRvIGhhbmRsZSB0aGlzLlxuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzdWIpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIHJldHVybiB1dGlsLlxuICAgIGluc3BlY3QoeCwgZmFsc2UsIDEwLCBjb2xvcikuXG4gICAgcmVwbGFjZSgvXFxuL2csICcnKS5cbiAgICByZXBsYWNlKC9cXHN7Mix9L2csICcgJyk7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgY29sbGVjdGlvbnMgaW5kZXhlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQG1ldGhvZCBnZXRJbmRleGVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5hdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldEluZGV4ZXMgPSBOYXRpdmVDb2xsZWN0aW9uLnByb3RvdHlwZS5pbmRleEluZm9ybWF0aW9uO1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTmF0aXZlQ29sbGVjdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseConnection = __webpack_require__(/*! ../../connection */ \"(api)/../server/node_modules/mongoose/lib/connection.js\");\nconst MongooseError = __webpack_require__(/*! ../../error/index */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nconst STATES = __webpack_require__(/*! ../../connectionstate */ \"(api)/../server/node_modules/mongoose/lib/connectionstate.js\");\nconst mongodb = __webpack_require__(/*! mongodb */ \"(api)/../server/node_modules/mongodb/lib/index.js\");\nconst pkg = __webpack_require__(/*! ../../../package.json */ \"(api)/../server/node_modules/mongoose/package.json\");\nconst processConnectionOptions = __webpack_require__(/*! ../../helpers/processConnectionOptions */ \"(api)/../server/node_modules/mongoose/lib/helpers/processConnectionOptions.js\");\nconst setTimeout = (__webpack_require__(/*! ../../helpers/timers */ \"(api)/../server/node_modules/mongoose/lib/helpers/timers.js\").setTimeout);\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nObject.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function(name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n\n  newConn.client = _this.client;\n\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this.once('connected', wireup);\n  }\n\n  function wireup() {\n    newConn.client = _this.client;\n    const _opts = {};\n    if (options.hasOwnProperty('noListener')) {\n      _opts.noListener = options.noListener;\n    }\n    newConn.db = _this.client.db(name, _opts);\n    newConn.onOpen();\n  }\n\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  if (options.noListener !== true) {\n    this.otherDbs.push(newConn);\n  }\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n\n  return newConn;\n};\n\n/**\n * Removes the database connection with the given name created with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n */\n\nNativeConnection.prototype.removeDb = function removeDb(name) {\n  const dbs = this.otherDbs.filter(db => db.name === name);\n  if (!dbs.length) {\n    throw new MongooseError(`No connections to database \"${name}\" found`);\n  }\n\n  for (const db of dbs) {\n    db._closeCalled = true;\n    db._destroyCalled = true;\n    db._readyState = STATES.disconnected;\n    db.$wasForceClosed = true;\n  }\n  delete this.relatedDbs[name];\n  this.otherDbs = this.otherDbs.filter(db => db.name !== name);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = async function doClose(force) {\n  if (this.client == null) {\n    return this;\n  }\n\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n\n  if (skipCloseClient) {\n    return this;\n  }\n\n  await this.client.close(force);\n  // Defer because the driver will wait at least 1ms before finishing closing\n  // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n  // If there's queued operations, you may still get some background work\n  // after the callback is called.\n  await new Promise(resolve => setTimeout(resolve, 1));\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.createClient = async function createClient(uri, options) {\n  if (typeof uri !== 'string') {\n    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' +\n      `string, got \"${typeof uri}\". Make sure the first parameter to ` +\n      '`mongoose.connect()` or `mongoose.createConnection()` is a string.');\n  }\n\n  if (this._destroyCalled) {\n    throw new MongooseError(\n      'Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' +\n      'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.'\n    );\n  }\n\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString !== uri) {\n      throw new MongooseError('Can\\'t call `openUri()` on an active connection with ' +\n        'different connection strings. Make sure you aren\\'t calling `mongoose.connect()` ' +\n        'multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections');\n    }\n  }\n\n  options = processConnectionOptions(uri, options);\n\n  if (options) {\n\n    const autoIndex = options.config && options.config.autoIndex != null ?\n      options.config.autoIndex :\n      options.autoIndex;\n    if (autoIndex != null) {\n      this.config.autoIndex = autoIndex !== false;\n      delete options.config;\n      delete options.autoIndex;\n    }\n\n    if ('autoCreate' in options) {\n      this.config.autoCreate = !!options.autoCreate;\n      delete options.autoCreate;\n    }\n\n    if ('sanitizeFilter' in options) {\n      this.config.sanitizeFilter = options.sanitizeFilter;\n      delete options.sanitizeFilter;\n    }\n\n    // Backwards compat\n    if (options.user || options.pass) {\n      options.auth = options.auth || {};\n      options.auth.username = options.user;\n      options.auth.password = options.pass;\n\n      this.user = options.user;\n      this.pass = options.pass;\n    }\n    delete options.user;\n    delete options.pass;\n\n    if (options.bufferCommands != null) {\n      this.config.bufferCommands = options.bufferCommands;\n      delete options.bufferCommands;\n    }\n  } else {\n    options = {};\n  }\n\n  this._connectionOptions = options;\n  const dbName = options.dbName;\n  if (dbName != null) {\n    this.$dbName = dbName;\n  }\n  delete options.dbName;\n\n  if (!utils.hasUserDefinedProperty(options, 'driverInfo')) {\n    options.driverInfo = {\n      name: 'Mongoose',\n      version: pkg.version\n    };\n  }\n\n  this.readyState = STATES.connecting;\n  this._connectionString = uri;\n\n  let client;\n  try {\n    client = new mongodb.MongoClient(uri, options);\n  } catch (error) {\n    this.readyState = STATES.disconnected;\n    throw error;\n  }\n  this.client = client;\n\n  client.setMaxListeners(0);\n  await client.connect();\n\n  _setClient(this, client, options, dbName);\n\n  for (const db of this.otherDbs) {\n    _setClient(db, client, {}, db.name);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.setClient = function setClient(client) {\n  if (!(client instanceof mongodb.MongoClient)) {\n    throw new MongooseError('Must call `setClient()` with an instance of MongoClient');\n  }\n  if (this.readyState !== STATES.disconnected) {\n    throw new MongooseError('Cannot call `setClient()` on a connection that is already connected.');\n  }\n  if (client.topology == null) {\n    throw new MongooseError('Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.');\n  }\n\n  this._connectionString = client.s.url;\n  _setClient(this, client, {}, client.s.options.dbName);\n\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _setClient(conn, client, options, dbName) {\n  const db = dbName != null ? client.db(dbName) : client.db();\n  conn.db = db;\n  conn.client = client;\n  conn.host = client &&\n    client.s &&\n    client.s.options &&\n    client.s.options.hosts &&\n    client.s.options.hosts[0] &&\n    client.s.options.hosts[0].host || void 0;\n  conn.port = client &&\n    client.s &&\n    client.s.options &&\n    client.s.options.hosts &&\n    client.s.options.hosts[0] &&\n    client.s.options.hosts[0].port || void 0;\n  conn.name = dbName != null ? dbName : db.databaseName;\n  conn._closeCalled = client._closeCalled;\n\n  const _handleReconnect = () => {\n    // If we aren't disconnected, we assume this reconnect is due to a\n    // socket timeout. If there's no activity on a socket for\n    // `socketTimeoutMS`, the driver will attempt to reconnect and emit\n    // this event.\n    if (conn.readyState !== STATES.connected) {\n      conn.readyState = STATES.connected;\n      conn.emit('reconnect');\n      conn.emit('reconnected');\n      conn.onOpen();\n    }\n  };\n\n  const type = client &&\n  client.topology &&\n  client.topology.description &&\n  client.topology.description.type || '';\n\n  if (type === 'Single') {\n    client.on('serverDescriptionChanged', ev => {\n      const newDescription = ev.newDescription;\n      if (newDescription.type === 'Unknown') {\n        conn.readyState = STATES.disconnected;\n      } else {\n        _handleReconnect();\n      }\n    });\n  } else if (type.startsWith('ReplicaSet')) {\n    client.on('topologyDescriptionChanged', ev => {\n      // Emit disconnected if we've lost connectivity to the primary\n      const description = ev.newDescription;\n      if (conn.readyState === STATES.connected && description.type !== 'ReplicaSetWithPrimary') {\n        // Implicitly emits 'disconnected'\n        conn.readyState = STATES.disconnected;\n      } else if (conn.readyState === STATES.disconnected && description.type === 'ReplicaSetWithPrimary') {\n        _handleReconnect();\n      }\n    });\n  }\n\n  conn.onOpen();\n\n  for (const i in conn.collections) {\n    if (utils.object.hasOwnProperty(conn.collections, i)) {\n      conn.collections[i].onOpen();\n    }\n  }\n}\n\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZHJpdmVycy9ub2RlLW1vbmdvZGItbmF0aXZlL2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLDJCQUEyQixtQkFBTyxDQUFDLGlGQUFrQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyxtRkFBbUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLDJGQUF1QjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBUztBQUNqQyxZQUFZLG1CQUFPLENBQUMsaUZBQXVCO0FBQzNDLGlDQUFpQyxtQkFBTyxDQUFDLDZIQUF3QztBQUNqRixtQkFBbUIsMkhBQTBDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyx1RUFBYTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxZQUFZO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxLQUFLO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcZHJpdmVyc1xcbm9kZS1tb25nb2RiLW5hdGl2ZVxcY29ubmVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUNvbm5lY3Rpb24gPSByZXF1aXJlKCcuLi8uLi9jb25uZWN0aW9uJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IFNUQVRFUyA9IHJlcXVpcmUoJy4uLy4uL2Nvbm5lY3Rpb25zdGF0ZScpO1xuY29uc3QgbW9uZ29kYiA9IHJlcXVpcmUoJ21vbmdvZGInKTtcbmNvbnN0IHBrZyA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhY2thZ2UuanNvbicpO1xuY29uc3QgcHJvY2Vzc0Nvbm5lY3Rpb25PcHRpb25zID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9wcm9jZXNzQ29ubmVjdGlvbk9wdGlvbnMnKTtcbmNvbnN0IHNldFRpbWVvdXQgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3RpbWVycycpLnNldFRpbWVvdXQ7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQSBbbm9kZS1tb25nb2RiLW5hdGl2ZV0oaHR0cHM6Ly9naXRodWIuY29tL21vbmdvZGIvbm9kZS1tb25nb2RiLW5hdGl2ZSkgY29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAaW5oZXJpdHMgQ29ubmVjdGlvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gTmF0aXZlQ29ubmVjdGlvbigpIHtcbiAgTW9uZ29vc2VDb25uZWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMuX2xpc3RlbmluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEV4cG9zZSB0aGUgcG9zc2libGUgY29ubmVjdGlvbiBzdGF0ZXMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5hdGl2ZUNvbm5lY3Rpb24uU1RBVEVTID0gU1RBVEVTO1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gQ29ubmVjdGlvbi5cbiAqL1xuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoTmF0aXZlQ29ubmVjdGlvbi5wcm90b3R5cGUsIE1vbmdvb3NlQ29ubmVjdGlvbi5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN3aXRjaGVzIHRvIGEgZGlmZmVyZW50IGRhdGFiYXNlIHVzaW5nIHRoZSBzYW1lIGNvbm5lY3Rpb24gcG9vbC5cbiAqXG4gKiBSZXR1cm5zIGEgbmV3IGNvbm5lY3Rpb24gb2JqZWN0LCB3aXRoIHRoZSBuZXcgZGIuIElmIHlvdSBzZXQgdGhlIGB1c2VDYWNoZWBcbiAqIG9wdGlvbiwgYHVzZURiKClgIHdpbGwgY2FjaGUgY29ubmVjdGlvbnMgYnkgYG5hbWVgLlxuICpcbiAqICoqTm90ZToqKiBDYWxsaW5nIGBjbG9zZSgpYCBvbiBhIGB1c2VEYigpYCBjb25uZWN0aW9uIHdpbGwgY2xvc2UgdGhlIGJhc2UgY29ubmVjdGlvbiBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBkYXRhYmFzZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzZUNhY2hlPWZhbHNlXSBJZiB0cnVlLCBjYWNoZSByZXN1bHRzIHNvIGNhbGxpbmcgYHVzZURiKClgIG11bHRpcGxlIHRpbWVzIHdpdGggdGhlIHNhbWUgbmFtZSBvbmx5IGNyZWF0ZXMgMSBjb25uZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9MaXN0ZW5lcj1mYWxzZV0gSWYgdHJ1ZSwgdGhlIG5ldyBjb25uZWN0aW9uIG9iamVjdCB3b24ndCBsaXN0ZW4gdG8gYW55IGV2ZW50cyBvbiB0aGUgYmFzZSBjb25uZWN0aW9uLiBUaGlzIGlzIGJldHRlciBmb3IgbWVtb3J5IHVzYWdlIGluIGNhc2VzIHdoZXJlIHlvdSdyZSBjYWxsaW5nIGB1c2VEYigpYCBmb3IgZXZlcnkgcmVxdWVzdC5cbiAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IE5ldyBDb25uZWN0aW9uIE9iamVjdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5OYXRpdmVDb25uZWN0aW9uLnByb3RvdHlwZS51c2VEYiA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IGlmIGNhY2hlZFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMudXNlQ2FjaGUgJiYgdGhpcy5yZWxhdGVkRGJzW25hbWVdKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXRlZERic1tuYW1lXTtcbiAgfVxuXG4gIC8vIHdlIGhhdmUgdG8gbWFudWFsbHkgY29weSBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMuLi5cbiAgY29uc3QgbmV3Q29ubiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gIG5ld0Nvbm4ubmFtZSA9IG5hbWU7XG4gIG5ld0Nvbm4uYmFzZSA9IHRoaXMuYmFzZTtcbiAgbmV3Q29ubi5jb2xsZWN0aW9ucyA9IHt9O1xuICBuZXdDb25uLm1vZGVscyA9IHt9O1xuICBuZXdDb25uLnJlcGxpY2EgPSB0aGlzLnJlcGxpY2E7XG4gIG5ld0Nvbm4uY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWcsIG5ld0Nvbm4uY29uZmlnKTtcbiAgbmV3Q29ubi5uYW1lID0gdGhpcy5uYW1lO1xuICBuZXdDb25uLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIG5ld0Nvbm4uX3JlYWR5U3RhdGUgPSB0aGlzLl9yZWFkeVN0YXRlO1xuICBuZXdDb25uLl9jbG9zZUNhbGxlZCA9IHRoaXMuX2Nsb3NlQ2FsbGVkO1xuICBuZXdDb25uLl9oYXNPcGVuZWQgPSB0aGlzLl9oYXNPcGVuZWQ7XG4gIG5ld0Nvbm4uX2xpc3RlbmluZyA9IGZhbHNlO1xuICBuZXdDb25uLl9wYXJlbnQgPSB0aGlzO1xuXG4gIG5ld0Nvbm4uaG9zdCA9IHRoaXMuaG9zdDtcbiAgbmV3Q29ubi5wb3J0ID0gdGhpcy5wb3J0O1xuICBuZXdDb25uLnVzZXIgPSB0aGlzLnVzZXI7XG4gIG5ld0Nvbm4ucGFzcyA9IHRoaXMucGFzcztcblxuICAvLyBGaXJzdCwgd2hlbiB3ZSBjcmVhdGUgYW5vdGhlciBkYiBvYmplY3QsIHdlIGFyZSBub3QgZ3VhcmFudGVlZCB0byBoYXZlIGFcbiAgLy8gZGIgb2JqZWN0IHRvIHdvcmsgd2l0aC4gU28sIGluIHRoZSBjYXNlIHdoZXJlIHdlIGhhdmUgYSBkYiBvYmplY3QgYW5kIGl0XG4gIC8vIGlzIGNvbm5lY3RlZCwgd2UgY2FuIGp1c3QgcHJvY2VlZCB3aXRoIHNldHRpbmcgZXZlcnl0aGluZyB1cC4gSG93ZXZlciwgaWZcbiAgLy8gd2UgZG8gbm90IGhhdmUgYSBkYiBvciB0aGUgc3RhdGUgaXMgbm90IGNvbm5lY3RlZCwgdGhlbiB3ZSBuZWVkIHRvIHdhaXQgb25cbiAgLy8gdGhlICdvcGVuJyBldmVudCBvZiB0aGUgY29ubmVjdGlvbiBiZWZvcmUgZG9pbmcgdGhlIHJlc3Qgb2YgdGhlIHNldHVwXG4gIC8vIHRoZSAnY29ubmVjdGVkJyBldmVudCBpcyB0aGUgZmlyc3QgdGltZSB3ZSdsbCBoYXZlIGFjY2VzcyB0byB0aGUgZGIgb2JqZWN0XG5cbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuXG4gIG5ld0Nvbm4uY2xpZW50ID0gX3RoaXMuY2xpZW50O1xuXG4gIGlmICh0aGlzLmRiICYmIHRoaXMuX3JlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0ZWQpIHtcbiAgICB3aXJldXAoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9uY2UoJ2Nvbm5lY3RlZCcsIHdpcmV1cCk7XG4gIH1cblxuICBmdW5jdGlvbiB3aXJldXAoKSB7XG4gICAgbmV3Q29ubi5jbGllbnQgPSBfdGhpcy5jbGllbnQ7XG4gICAgY29uc3QgX29wdHMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbm9MaXN0ZW5lcicpKSB7XG4gICAgICBfb3B0cy5ub0xpc3RlbmVyID0gb3B0aW9ucy5ub0xpc3RlbmVyO1xuICAgIH1cbiAgICBuZXdDb25uLmRiID0gX3RoaXMuY2xpZW50LmRiKG5hbWUsIF9vcHRzKTtcbiAgICBuZXdDb25uLm9uT3BlbigpO1xuICB9XG5cbiAgbmV3Q29ubi5uYW1lID0gbmFtZTtcblxuICAvLyBwdXNoIG9udG8gdGhlIG90aGVyRGJzIHN0YWNrLCB0aGlzIGlzIHVzZWQgd2hlbiBzdGF0ZSBjaGFuZ2VzXG4gIGlmIChvcHRpb25zLm5vTGlzdGVuZXIgIT09IHRydWUpIHtcbiAgICB0aGlzLm90aGVyRGJzLnB1c2gobmV3Q29ubik7XG4gIH1cbiAgbmV3Q29ubi5vdGhlckRicy5wdXNoKHRoaXMpO1xuXG4gIC8vIHB1c2ggb250byB0aGUgcmVsYXRlZERicyBjYWNoZSwgdGhpcyBpcyB1c2VkIHdoZW4gc3RhdGUgY2hhbmdlc1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVzZUNhY2hlKSB7XG4gICAgdGhpcy5yZWxhdGVkRGJzW25ld0Nvbm4ubmFtZV0gPSBuZXdDb25uO1xuICAgIG5ld0Nvbm4ucmVsYXRlZERicyA9IHRoaXMucmVsYXRlZERicztcbiAgfVxuXG4gIHJldHVybiBuZXdDb25uO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5hbWUgY3JlYXRlZCB3aXRoIGB1c2VEYigpYC5cbiAqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gd2FzIG5vdCBmb3VuZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIENvbm5lY3QgdG8gYGluaXRpYWxkYmAgZmlyc3RcbiAqICAgICBjb25zdCBjb25uID0gYXdhaXQgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9pbml0aWFsZGInKS5hc1Byb21pc2UoKTtcbiAqXG4gKiAgICAgLy8gQ3JlYXRlcyBhbiB1bi1jYWNoZWQgY29ubmVjdGlvbiB0byBgbXlkYmBcbiAqICAgICBjb25zdCBkYiA9IGNvbm4udXNlRGIoJ215ZGInKTtcbiAqXG4gKiAgICAgLy8gQ2xvc2VzIGBkYmAsIGFuZCByZW1vdmVzIGBkYmAgZnJvbSBgY29ubi5yZWxhdGVkRGJzYCBhbmQgYGNvbm4ub3RoZXJEYnNgXG4gKiAgICAgYXdhaXQgY29ubi5yZW1vdmVEYignbXlkYicpO1xuICpcbiAqIEBtZXRob2QgcmVtb3ZlRGJcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZGF0YWJhc2UgbmFtZVxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gdGhpc1xuICovXG5cbk5hdGl2ZUNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZURiID0gZnVuY3Rpb24gcmVtb3ZlRGIobmFtZSkge1xuICBjb25zdCBkYnMgPSB0aGlzLm90aGVyRGJzLmZpbHRlcihkYiA9PiBkYi5uYW1lID09PSBuYW1lKTtcbiAgaWYgKCFkYnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoYE5vIGNvbm5lY3Rpb25zIHRvIGRhdGFiYXNlIFwiJHtuYW1lfVwiIGZvdW5kYCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGRiIG9mIGRicykge1xuICAgIGRiLl9jbG9zZUNhbGxlZCA9IHRydWU7XG4gICAgZGIuX2Rlc3Ryb3lDYWxsZWQgPSB0cnVlO1xuICAgIGRiLl9yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3RlZDtcbiAgICBkYi4kd2FzRm9yY2VDbG9zZWQgPSB0cnVlO1xuICB9XG4gIGRlbGV0ZSB0aGlzLnJlbGF0ZWREYnNbbmFtZV07XG4gIHRoaXMub3RoZXJEYnMgPSB0aGlzLm90aGVyRGJzLmZpbHRlcihkYiA9PiBkYi5uYW1lICE9PSBuYW1lKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gKiBAcmV0dXJuIHtDb25uZWN0aW9ufSB0aGlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5OYXRpdmVDb25uZWN0aW9uLnByb3RvdHlwZS5kb0Nsb3NlID0gYXN5bmMgZnVuY3Rpb24gZG9DbG9zZShmb3JjZSkge1xuICBpZiAodGhpcy5jbGllbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGV0IHNraXBDbG9zZUNsaWVudCA9IGZhbHNlO1xuICBpZiAoZm9yY2UgIT0gbnVsbCAmJiB0eXBlb2YgZm9yY2UgPT09ICdvYmplY3QnKSB7XG4gICAgc2tpcENsb3NlQ2xpZW50ID0gZm9yY2Uuc2tpcENsb3NlQ2xpZW50O1xuICAgIGZvcmNlID0gZm9yY2UuZm9yY2U7XG4gIH1cblxuICBpZiAoc2tpcENsb3NlQ2xpZW50KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhd2FpdCB0aGlzLmNsaWVudC5jbG9zZShmb3JjZSk7XG4gIC8vIERlZmVyIGJlY2F1c2UgdGhlIGRyaXZlciB3aWxsIHdhaXQgYXQgbGVhc3QgMW1zIGJlZm9yZSBmaW5pc2hpbmcgY2xvc2luZ1xuICAvLyB0aGUgcG9vbCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb25nb2RiLWpzL21vbmdvZGItY29yZS9ibG9iL2E4ZjhlNGNlNDE5MzZiYWJjM2I5MTEyYmY0MmQ2MDk3NzlmMDNiMzkvbGliL2Nvbm5lY3Rpb24vcG9vbC5qcyNMMTAyNi1MMTAzMC5cbiAgLy8gSWYgdGhlcmUncyBxdWV1ZWQgb3BlcmF0aW9ucywgeW91IG1heSBzdGlsbCBnZXQgc29tZSBiYWNrZ3JvdW5kIHdvcmtcbiAgLy8gYWZ0ZXIgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEpKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuTmF0aXZlQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQ2xpZW50ID0gYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ2xpZW50KHVyaSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignVGhlIGB1cmlgIHBhcmFtZXRlciB0byBgb3BlblVyaSgpYCBtdXN0IGJlIGEgJyArXG4gICAgICBgc3RyaW5nLCBnb3QgXCIke3R5cGVvZiB1cml9XCIuIE1ha2Ugc3VyZSB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIGAgK1xuICAgICAgJ2Btb25nb29zZS5jb25uZWN0KClgIG9yIGBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKClgIGlzIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2Rlc3Ryb3lDYWxsZWQpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihcbiAgICAgICdDb25uZWN0aW9uIGhhcyBiZWVuIGNsb3NlZCBhbmQgZGVzdHJveWVkLCBhbmQgY2Fubm90IGJlIHVzZWQgZm9yIHJlLW9wZW5pbmcgdGhlIGNvbm5lY3Rpb24uICcgK1xuICAgICAgJ1BsZWFzZSBjcmVhdGUgYSBuZXcgY29ubmVjdGlvbiB3aXRoIGBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKClgIG9yIGBtb25nb29zZS5jb25uZWN0KClgLidcbiAgICApO1xuICB9XG5cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RpbmcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGVkKSB7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25TdHJpbmcgIT09IHVyaSkge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0NhblxcJ3QgY2FsbCBgb3BlblVyaSgpYCBvbiBhbiBhY3RpdmUgY29ubmVjdGlvbiB3aXRoICcgK1xuICAgICAgICAnZGlmZmVyZW50IGNvbm5lY3Rpb24gc3RyaW5ncy4gTWFrZSBzdXJlIHlvdSBhcmVuXFwndCBjYWxsaW5nIGBtb25nb29zZS5jb25uZWN0KClgICcgK1xuICAgICAgICAnbXVsdGlwbGUgdGltZXMuIFNlZTogaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2Nvbm5lY3Rpb25zLmh0bWwjbXVsdGlwbGVfY29ubmVjdGlvbnMnKTtcbiAgICB9XG4gIH1cblxuICBvcHRpb25zID0gcHJvY2Vzc0Nvbm5lY3Rpb25PcHRpb25zKHVyaSwgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGF1dG9JbmRleCA9IG9wdGlvbnMuY29uZmlnICYmIG9wdGlvbnMuY29uZmlnLmF1dG9JbmRleCAhPSBudWxsID9cbiAgICAgIG9wdGlvbnMuY29uZmlnLmF1dG9JbmRleCA6XG4gICAgICBvcHRpb25zLmF1dG9JbmRleDtcbiAgICBpZiAoYXV0b0luZGV4ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY29uZmlnLmF1dG9JbmRleCA9IGF1dG9JbmRleCAhPT0gZmFsc2U7XG4gICAgICBkZWxldGUgb3B0aW9ucy5jb25maWc7XG4gICAgICBkZWxldGUgb3B0aW9ucy5hdXRvSW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKCdhdXRvQ3JlYXRlJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLmNvbmZpZy5hdXRvQ3JlYXRlID0gISFvcHRpb25zLmF1dG9DcmVhdGU7XG4gICAgICBkZWxldGUgb3B0aW9ucy5hdXRvQ3JlYXRlO1xuICAgIH1cblxuICAgIGlmICgnc2FuaXRpemVGaWx0ZXInIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY29uZmlnLnNhbml0aXplRmlsdGVyID0gb3B0aW9ucy5zYW5pdGl6ZUZpbHRlcjtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnNhbml0aXplRmlsdGVyO1xuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRcbiAgICBpZiAob3B0aW9ucy51c2VyIHx8IG9wdGlvbnMucGFzcykge1xuICAgICAgb3B0aW9ucy5hdXRoID0gb3B0aW9ucy5hdXRoIHx8IHt9O1xuICAgICAgb3B0aW9ucy5hdXRoLnVzZXJuYW1lID0gb3B0aW9ucy51c2VyO1xuICAgICAgb3B0aW9ucy5hdXRoLnBhc3N3b3JkID0gb3B0aW9ucy5wYXNzO1xuXG4gICAgICB0aGlzLnVzZXIgPSBvcHRpb25zLnVzZXI7XG4gICAgICB0aGlzLnBhc3MgPSBvcHRpb25zLnBhc3M7XG4gICAgfVxuICAgIGRlbGV0ZSBvcHRpb25zLnVzZXI7XG4gICAgZGVsZXRlIG9wdGlvbnMucGFzcztcblxuICAgIGlmIChvcHRpb25zLmJ1ZmZlckNvbW1hbmRzICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY29uZmlnLmJ1ZmZlckNvbW1hbmRzID0gb3B0aW9ucy5idWZmZXJDb21tYW5kcztcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmJ1ZmZlckNvbW1hbmRzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB0aGlzLl9jb25uZWN0aW9uT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGNvbnN0IGRiTmFtZSA9IG9wdGlvbnMuZGJOYW1lO1xuICBpZiAoZGJOYW1lICE9IG51bGwpIHtcbiAgICB0aGlzLiRkYk5hbWUgPSBkYk5hbWU7XG4gIH1cbiAgZGVsZXRlIG9wdGlvbnMuZGJOYW1lO1xuXG4gIGlmICghdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvcHRpb25zLCAnZHJpdmVySW5mbycpKSB7XG4gICAgb3B0aW9ucy5kcml2ZXJJbmZvID0ge1xuICAgICAgbmFtZTogJ01vbmdvb3NlJyxcbiAgICAgIHZlcnNpb246IHBrZy52ZXJzaW9uXG4gICAgfTtcbiAgfVxuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNUQVRFUy5jb25uZWN0aW5nO1xuICB0aGlzLl9jb25uZWN0aW9uU3RyaW5nID0gdXJpO1xuXG4gIGxldCBjbGllbnQ7XG4gIHRyeSB7XG4gICAgY2xpZW50ID0gbmV3IG1vbmdvZGIuTW9uZ29DbGllbnQodXJpLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTVEFURVMuZGlzY29ubmVjdGVkO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuXG4gIGNsaWVudC5zZXRNYXhMaXN0ZW5lcnMoMCk7XG4gIGF3YWl0IGNsaWVudC5jb25uZWN0KCk7XG5cbiAgX3NldENsaWVudCh0aGlzLCBjbGllbnQsIG9wdGlvbnMsIGRiTmFtZSk7XG5cbiAgZm9yIChjb25zdCBkYiBvZiB0aGlzLm90aGVyRGJzKSB7XG4gICAgX3NldENsaWVudChkYiwgY2xpZW50LCB7fSwgZGIubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbk5hdGl2ZUNvbm5lY3Rpb24ucHJvdG90eXBlLnNldENsaWVudCA9IGZ1bmN0aW9uIHNldENsaWVudChjbGllbnQpIHtcbiAgaWYgKCEoY2xpZW50IGluc3RhbmNlb2YgbW9uZ29kYi5Nb25nb0NsaWVudCkpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTXVzdCBjYWxsIGBzZXRDbGllbnQoKWAgd2l0aCBhbiBpbnN0YW5jZSBvZiBNb25nb0NsaWVudCcpO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFNUQVRFUy5kaXNjb25uZWN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ2Fubm90IGNhbGwgYHNldENsaWVudCgpYCBvbiBhIGNvbm5lY3Rpb24gdGhhdCBpcyBhbHJlYWR5IGNvbm5lY3RlZC4nKTtcbiAgfVxuICBpZiAoY2xpZW50LnRvcG9sb2d5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ2Fubm90IGNhbGwgYHNldENsaWVudCgpYCB3aXRoIGEgTW9uZ29DbGllbnQgdGhhdCB5b3UgaGF2ZSBub3QgY2FsbGVkIGBjb25uZWN0KClgIG9uIHlldC4nKTtcbiAgfVxuXG4gIHRoaXMuX2Nvbm5lY3Rpb25TdHJpbmcgPSBjbGllbnQucy51cmw7XG4gIF9zZXRDbGllbnQodGhpcywgY2xpZW50LCB7fSwgY2xpZW50LnMub3B0aW9ucy5kYk5hbWUpO1xuXG4gIGZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1vZGVscykpIHtcbiAgICAvLyBFcnJvcnMgaGFuZGxlZCBpbnRlcm5hbGx5LCBzbyBzYWZlIHRvIGlnbm9yZSBlcnJvclxuICAgIG1vZGVsLmluaXQoKS5jYXRjaChmdW5jdGlvbiAkbW9kZWxJbml0Tm9vcCgpIHt9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfc2V0Q2xpZW50KGNvbm4sIGNsaWVudCwgb3B0aW9ucywgZGJOYW1lKSB7XG4gIGNvbnN0IGRiID0gZGJOYW1lICE9IG51bGwgPyBjbGllbnQuZGIoZGJOYW1lKSA6IGNsaWVudC5kYigpO1xuICBjb25uLmRiID0gZGI7XG4gIGNvbm4uY2xpZW50ID0gY2xpZW50O1xuICBjb25uLmhvc3QgPSBjbGllbnQgJiZcbiAgICBjbGllbnQucyAmJlxuICAgIGNsaWVudC5zLm9wdGlvbnMgJiZcbiAgICBjbGllbnQucy5vcHRpb25zLmhvc3RzICYmXG4gICAgY2xpZW50LnMub3B0aW9ucy5ob3N0c1swXSAmJlxuICAgIGNsaWVudC5zLm9wdGlvbnMuaG9zdHNbMF0uaG9zdCB8fCB2b2lkIDA7XG4gIGNvbm4ucG9ydCA9IGNsaWVudCAmJlxuICAgIGNsaWVudC5zICYmXG4gICAgY2xpZW50LnMub3B0aW9ucyAmJlxuICAgIGNsaWVudC5zLm9wdGlvbnMuaG9zdHMgJiZcbiAgICBjbGllbnQucy5vcHRpb25zLmhvc3RzWzBdICYmXG4gICAgY2xpZW50LnMub3B0aW9ucy5ob3N0c1swXS5wb3J0IHx8IHZvaWQgMDtcbiAgY29ubi5uYW1lID0gZGJOYW1lICE9IG51bGwgPyBkYk5hbWUgOiBkYi5kYXRhYmFzZU5hbWU7XG4gIGNvbm4uX2Nsb3NlQ2FsbGVkID0gY2xpZW50Ll9jbG9zZUNhbGxlZDtcblxuICBjb25zdCBfaGFuZGxlUmVjb25uZWN0ID0gKCkgPT4ge1xuICAgIC8vIElmIHdlIGFyZW4ndCBkaXNjb25uZWN0ZWQsIHdlIGFzc3VtZSB0aGlzIHJlY29ubmVjdCBpcyBkdWUgdG8gYVxuICAgIC8vIHNvY2tldCB0aW1lb3V0LiBJZiB0aGVyZSdzIG5vIGFjdGl2aXR5IG9uIGEgc29ja2V0IGZvclxuICAgIC8vIGBzb2NrZXRUaW1lb3V0TVNgLCB0aGUgZHJpdmVyIHdpbGwgYXR0ZW1wdCB0byByZWNvbm5lY3QgYW5kIGVtaXRcbiAgICAvLyB0aGlzIGV2ZW50LlxuICAgIGlmIChjb25uLnJlYWR5U3RhdGUgIT09IFNUQVRFUy5jb25uZWN0ZWQpIHtcbiAgICAgIGNvbm4ucmVhZHlTdGF0ZSA9IFNUQVRFUy5jb25uZWN0ZWQ7XG4gICAgICBjb25uLmVtaXQoJ3JlY29ubmVjdCcpO1xuICAgICAgY29ubi5lbWl0KCdyZWNvbm5lY3RlZCcpO1xuICAgICAgY29ubi5vbk9wZW4oKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdHlwZSA9IGNsaWVudCAmJlxuICBjbGllbnQudG9wb2xvZ3kgJiZcbiAgY2xpZW50LnRvcG9sb2d5LmRlc2NyaXB0aW9uICYmXG4gIGNsaWVudC50b3BvbG9neS5kZXNjcmlwdGlvbi50eXBlIHx8ICcnO1xuXG4gIGlmICh0eXBlID09PSAnU2luZ2xlJykge1xuICAgIGNsaWVudC5vbignc2VydmVyRGVzY3JpcHRpb25DaGFuZ2VkJywgZXYgPT4ge1xuICAgICAgY29uc3QgbmV3RGVzY3JpcHRpb24gPSBldi5uZXdEZXNjcmlwdGlvbjtcbiAgICAgIGlmIChuZXdEZXNjcmlwdGlvbi50eXBlID09PSAnVW5rbm93bicpIHtcbiAgICAgICAgY29ubi5yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9oYW5kbGVSZWNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ1JlcGxpY2FTZXQnKSkge1xuICAgIGNsaWVudC5vbigndG9wb2xvZ3lEZXNjcmlwdGlvbkNoYW5nZWQnLCBldiA9PiB7XG4gICAgICAvLyBFbWl0IGRpc2Nvbm5lY3RlZCBpZiB3ZSd2ZSBsb3N0IGNvbm5lY3Rpdml0eSB0byB0aGUgcHJpbWFyeVxuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBldi5uZXdEZXNjcmlwdGlvbjtcbiAgICAgIGlmIChjb25uLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0ZWQgJiYgZGVzY3JpcHRpb24udHlwZSAhPT0gJ1JlcGxpY2FTZXRXaXRoUHJpbWFyeScpIHtcbiAgICAgICAgLy8gSW1wbGljaXRseSBlbWl0cyAnZGlzY29ubmVjdGVkJ1xuICAgICAgICBjb25uLnJlYWR5U3RhdGUgPSBTVEFURVMuZGlzY29ubmVjdGVkO1xuICAgICAgfSBlbHNlIGlmIChjb25uLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5kaXNjb25uZWN0ZWQgJiYgZGVzY3JpcHRpb24udHlwZSA9PT0gJ1JlcGxpY2FTZXRXaXRoUHJpbWFyeScpIHtcbiAgICAgICAgX2hhbmRsZVJlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29ubi5vbk9wZW4oKTtcblxuICBmb3IgKGNvbnN0IGkgaW4gY29ubi5jb2xsZWN0aW9ucykge1xuICAgIGlmICh1dGlscy5vYmplY3QuaGFzT3duUHJvcGVydHkoY29ubi5jb2xsZWN0aW9ucywgaSkpIHtcbiAgICAgIGNvbm4uY29sbGVjdGlvbnNbaV0ub25PcGVuKCk7XG4gICAgfVxuICB9XG59XG5cblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdGl2ZUNvbm5lY3Rpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js":
/*!********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module exports.\n */\n\n\n\nexports.Collection = __webpack_require__(/*! ./collection */ \"(api)/../server/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js\");\nexports.Connection = __webpack_require__(/*! ./connection */ \"(api)/../server/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZHJpdmVycy9ub2RlLW1vbmdvZGItbmF0aXZlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixtSkFBNEM7QUFDNUMsbUpBQTRDIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcZHJpdmVyc1xcbm9kZS1tb25nb2RiLW5hdGl2ZVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xuZXhwb3J0cy5Db25uZWN0aW9uID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/bulkWriteError.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/bulkWriteError.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\n\n/**\n * If `bulkWrite()` or `insertMany()` has validation errors, but\n * all valid operations succeed, and 'throwOnValidationError' is true,\n * Mongoose will throw this error.\n *\n * @api private\n */\n\nclass MongooseBulkWriteError extends MongooseError {\n  constructor(validationErrors, results, rawResult, operation) {\n    let preview = validationErrors.map(e => e.message).join(', ');\n    if (preview.length > 200) {\n      preview = preview.slice(0, 200) + '...';\n    }\n    super(`${operation} failed with ${validationErrors.length} Mongoose validation errors: ${preview}`);\n\n    this.validationErrors = validationErrors;\n    this.results = results;\n    this.rawResult = rawResult;\n    this.operation = operation;\n  }\n}\n\nObject.defineProperty(MongooseBulkWriteError.prototype, 'name', {\n  value: 'MongooseBulkWriteError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = MongooseBulkWriteError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvYnVsa1dyaXRlRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLG9FQUFJOzs7QUFHbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXLGNBQWMseUJBQXlCLDhCQUE4QixRQUFROztBQUVyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcZXJyb3JcXGJ1bGtXcml0ZUVycm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5cbi8qKlxuICogSWYgYGJ1bGtXcml0ZSgpYCBvciBgaW5zZXJ0TWFueSgpYCBoYXMgdmFsaWRhdGlvbiBlcnJvcnMsIGJ1dFxuICogYWxsIHZhbGlkIG9wZXJhdGlvbnMgc3VjY2VlZCwgYW5kICd0aHJvd09uVmFsaWRhdGlvbkVycm9yJyBpcyB0cnVlLFxuICogTW9uZ29vc2Ugd2lsbCB0aHJvdyB0aGlzIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNsYXNzIE1vbmdvb3NlQnVsa1dyaXRlRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgY29uc3RydWN0b3IodmFsaWRhdGlvbkVycm9ycywgcmVzdWx0cywgcmF3UmVzdWx0LCBvcGVyYXRpb24pIHtcbiAgICBsZXQgcHJldmlldyA9IHZhbGlkYXRpb25FcnJvcnMubWFwKGUgPT4gZS5tZXNzYWdlKS5qb2luKCcsICcpO1xuICAgIGlmIChwcmV2aWV3Lmxlbmd0aCA+IDIwMCkge1xuICAgICAgcHJldmlldyA9IHByZXZpZXcuc2xpY2UoMCwgMjAwKSArICcuLi4nO1xuICAgIH1cbiAgICBzdXBlcihgJHtvcGVyYXRpb259IGZhaWxlZCB3aXRoICR7dmFsaWRhdGlvbkVycm9ycy5sZW5ndGh9IE1vbmdvb3NlIHZhbGlkYXRpb24gZXJyb3JzOiAke3ByZXZpZXd9YCk7XG5cbiAgICB0aGlzLnZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0aW9uRXJyb3JzO1xuICAgIHRoaXMucmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgdGhpcy5yYXdSZXN1bHQgPSByYXdSZXN1bHQ7XG4gICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vbmdvb3NlQnVsa1dyaXRlRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdNb25nb29zZUJ1bGtXcml0ZUVycm9yJ1xufSk7XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTW9uZ29vc2VCdWxrV3JpdGVFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/bulkWriteError.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/cast.js":
/*!*********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/cast.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * Casting Error constructor.\n *\n * @param {String} type\n * @param {String} value\n * @inherits MongooseError\n * @api private\n */\n\nclass CastError extends MongooseError {\n  constructor(type, value, path, reason, schemaType) {\n    // If no args, assume we'll `init()` later.\n    if (arguments.length > 0) {\n      const valueType = getValueType(value);\n      const messageFormat = getMessageFormat(schemaType);\n      const msg = formatMessage(null, type, value, path, messageFormat, valueType, reason);\n      super(msg);\n      this.init(type, value, path, reason, schemaType);\n    } else {\n      super(formatMessage());\n    }\n  }\n\n  toJSON() {\n    return {\n      stringValue: this.stringValue,\n      valueType: this.valueType,\n      kind: this.kind,\n      value: this.value,\n      path: this.path,\n      reason: this.reason,\n      name: this.name,\n      message: this.message\n    };\n  }\n  /*!\n   * ignore\n   */\n  init(type, value, path, reason, schemaType) {\n    this.stringValue = getStringValue(value);\n    this.messageFormat = getMessageFormat(schemaType);\n    this.kind = type;\n    this.value = value;\n    this.path = path;\n    this.reason = reason;\n    this.valueType = getValueType(value);\n  }\n\n  /**\n   * ignore\n   * @param {Readonly<CastError>} other\n   * @api private\n   */\n  copy(other) {\n    this.messageFormat = other.messageFormat;\n    this.stringValue = other.stringValue;\n    this.kind = other.kind;\n    this.value = other.value;\n    this.path = other.path;\n    this.reason = other.reason;\n    this.message = other.message;\n    this.valueType = other.valueType;\n  }\n\n  /*!\n   * ignore\n   */\n  setModel(model) {\n    this.model = model;\n    this.message = formatMessage(model, this.kind, this.value, this.path,\n      this.messageFormat, this.valueType);\n  }\n}\n\nObject.defineProperty(CastError.prototype, 'name', {\n  value: 'CastError'\n});\n\nfunction getStringValue(value) {\n  let stringValue = util.inspect(value);\n  stringValue = stringValue.replace(/^'|'$/g, '\"');\n  if (!stringValue.startsWith('\"')) {\n    stringValue = '\"' + stringValue + '\"';\n  }\n  return stringValue;\n}\n\nfunction getValueType(value) {\n  if (value == null) {\n    return '' + value;\n  }\n\n  const t = typeof value;\n  if (t !== 'object') {\n    return t;\n  }\n  if (typeof value.constructor !== 'function') {\n    return t;\n  }\n  return value.constructor.name;\n}\n\nfunction getMessageFormat(schemaType) {\n  const messageFormat = schemaType && schemaType._castErrorMessage || null;\n  if (typeof messageFormat === 'string' || typeof messageFormat === 'function') {\n    return messageFormat;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction formatMessage(model, kind, value, path, messageFormat, valueType, reason) {\n  if (typeof messageFormat === 'string') {\n    const stringValue = getStringValue(value);\n    let ret = messageFormat.\n      replace('{KIND}', kind).\n      replace('{VALUE}', stringValue).\n      replace('{PATH}', path);\n    if (model != null) {\n      ret = ret.replace('{MODEL}', model.modelName);\n    }\n\n    return ret;\n  } else if (typeof messageFormat === 'function') {\n    return messageFormat(value, path, model, kind);\n  } else {\n    const stringValue = getStringValue(value);\n    const valueTypeMsg = valueType ? ' (type ' + valueType + ')' : '';\n    let ret = 'Cast to ' + kind + ' failed for value ' +\n      stringValue + valueTypeMsg + ' at path \"' + path + '\"';\n    if (model != null) {\n      ret += ' for model \"' + model.modelName + '\"';\n    }\n    if (reason != null &&\n        typeof reason.constructor === 'function' &&\n        reason.constructor.name !== 'AssertionError' &&\n        reason.constructor.name !== 'Error') {\n      ret += ' because of \"' + reason.constructor.name + '\"';\n    }\n    return ret;\n  }\n}\n\n/*!\n * exports\n */\n\nmodule.exports = CastError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvY2FzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMseUZBQWlCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcZXJyb3JcXGNhc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBDYXN0aW5nIEVycm9yIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBpbmhlcml0cyBNb25nb29zZUVycm9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jbGFzcyBDYXN0RXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgY29uc3RydWN0b3IodHlwZSwgdmFsdWUsIHBhdGgsIHJlYXNvbiwgc2NoZW1hVHlwZSkge1xuICAgIC8vIElmIG5vIGFyZ3MsIGFzc3VtZSB3ZSdsbCBgaW5pdCgpYCBsYXRlci5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGdldFZhbHVlVHlwZSh2YWx1ZSk7XG4gICAgICBjb25zdCBtZXNzYWdlRm9ybWF0ID0gZ2V0TWVzc2FnZUZvcm1hdChzY2hlbWFUeXBlKTtcbiAgICAgIGNvbnN0IG1zZyA9IGZvcm1hdE1lc3NhZ2UobnVsbCwgdHlwZSwgdmFsdWUsIHBhdGgsIG1lc3NhZ2VGb3JtYXQsIHZhbHVlVHlwZSwgcmVhc29uKTtcbiAgICAgIHN1cGVyKG1zZyk7XG4gICAgICB0aGlzLmluaXQodHlwZSwgdmFsdWUsIHBhdGgsIHJlYXNvbiwgc2NoZW1hVHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyKGZvcm1hdE1lc3NhZ2UoKSk7XG4gICAgfVxuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJpbmdWYWx1ZTogdGhpcy5zdHJpbmdWYWx1ZSxcbiAgICAgIHZhbHVlVHlwZTogdGhpcy52YWx1ZVR5cGUsXG4gICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICAgIHJlYXNvbjogdGhpcy5yZWFzb24sXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICB9O1xuICB9XG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG4gIGluaXQodHlwZSwgdmFsdWUsIHBhdGgsIHJlYXNvbiwgc2NoZW1hVHlwZSkge1xuICAgIHRoaXMuc3RyaW5nVmFsdWUgPSBnZXRTdHJpbmdWYWx1ZSh2YWx1ZSk7XG4gICAgdGhpcy5tZXNzYWdlRm9ybWF0ID0gZ2V0TWVzc2FnZUZvcm1hdChzY2hlbWFUeXBlKTtcbiAgICB0aGlzLmtpbmQgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMudmFsdWVUeXBlID0gZ2V0VmFsdWVUeXBlKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpZ25vcmVcbiAgICogQHBhcmFtIHtSZWFkb25seTxDYXN0RXJyb3I+fSBvdGhlclxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvcHkob3RoZXIpIHtcbiAgICB0aGlzLm1lc3NhZ2VGb3JtYXQgPSBvdGhlci5tZXNzYWdlRm9ybWF0O1xuICAgIHRoaXMuc3RyaW5nVmFsdWUgPSBvdGhlci5zdHJpbmdWYWx1ZTtcbiAgICB0aGlzLmtpbmQgPSBvdGhlci5raW5kO1xuICAgIHRoaXMudmFsdWUgPSBvdGhlci52YWx1ZTtcbiAgICB0aGlzLnBhdGggPSBvdGhlci5wYXRoO1xuICAgIHRoaXMucmVhc29uID0gb3RoZXIucmVhc29uO1xuICAgIHRoaXMubWVzc2FnZSA9IG90aGVyLm1lc3NhZ2U7XG4gICAgdGhpcy52YWx1ZVR5cGUgPSBvdGhlci52YWx1ZVR5cGU7XG4gIH1cblxuICAvKiFcbiAgICogaWdub3JlXG4gICAqL1xuICBzZXRNb2RlbChtb2RlbCkge1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB0aGlzLm1lc3NhZ2UgPSBmb3JtYXRNZXNzYWdlKG1vZGVsLCB0aGlzLmtpbmQsIHRoaXMudmFsdWUsIHRoaXMucGF0aCxcbiAgICAgIHRoaXMubWVzc2FnZUZvcm1hdCwgdGhpcy52YWx1ZVR5cGUpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXN0RXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdDYXN0RXJyb3InXG59KTtcblxuZnVuY3Rpb24gZ2V0U3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgbGV0IHN0cmluZ1ZhbHVlID0gdXRpbC5pbnNwZWN0KHZhbHVlKTtcbiAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZS5yZXBsYWNlKC9eJ3wnJC9nLCAnXCInKTtcbiAgaWYgKCFzdHJpbmdWYWx1ZS5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgc3RyaW5nVmFsdWUgPSAnXCInICsgc3RyaW5nVmFsdWUgKyAnXCInO1xuICB9XG4gIHJldHVybiBzdHJpbmdWYWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVUeXBlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7XG4gIH1cblxuICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlLmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG59XG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2VGb3JtYXQoc2NoZW1hVHlwZSkge1xuICBjb25zdCBtZXNzYWdlRm9ybWF0ID0gc2NoZW1hVHlwZSAmJiBzY2hlbWFUeXBlLl9jYXN0RXJyb3JNZXNzYWdlIHx8IG51bGw7XG4gIGlmICh0eXBlb2YgbWVzc2FnZUZvcm1hdCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG1lc3NhZ2VGb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWVzc2FnZUZvcm1hdDtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UobW9kZWwsIGtpbmQsIHZhbHVlLCBwYXRoLCBtZXNzYWdlRm9ybWF0LCB2YWx1ZVR5cGUsIHJlYXNvbikge1xuICBpZiAodHlwZW9mIG1lc3NhZ2VGb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSBnZXRTdHJpbmdWYWx1ZSh2YWx1ZSk7XG4gICAgbGV0IHJldCA9IG1lc3NhZ2VGb3JtYXQuXG4gICAgICByZXBsYWNlKCd7S0lORH0nLCBraW5kKS5cbiAgICAgIHJlcGxhY2UoJ3tWQUxVRX0nLCBzdHJpbmdWYWx1ZSkuXG4gICAgICByZXBsYWNlKCd7UEFUSH0nLCBwYXRoKTtcbiAgICBpZiAobW9kZWwgIT0gbnVsbCkge1xuICAgICAgcmV0ID0gcmV0LnJlcGxhY2UoJ3tNT0RFTH0nLCBtb2RlbC5tb2RlbE5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1lc3NhZ2VGb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWVzc2FnZUZvcm1hdCh2YWx1ZSwgcGF0aCwgbW9kZWwsIGtpbmQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gZ2V0U3RyaW5nVmFsdWUodmFsdWUpO1xuICAgIGNvbnN0IHZhbHVlVHlwZU1zZyA9IHZhbHVlVHlwZSA/ICcgKHR5cGUgJyArIHZhbHVlVHlwZSArICcpJyA6ICcnO1xuICAgIGxldCByZXQgPSAnQ2FzdCB0byAnICsga2luZCArICcgZmFpbGVkIGZvciB2YWx1ZSAnICtcbiAgICAgIHN0cmluZ1ZhbHVlICsgdmFsdWVUeXBlTXNnICsgJyBhdCBwYXRoIFwiJyArIHBhdGggKyAnXCInO1xuICAgIGlmIChtb2RlbCAhPSBudWxsKSB7XG4gICAgICByZXQgKz0gJyBmb3IgbW9kZWwgXCInICsgbW9kZWwubW9kZWxOYW1lICsgJ1wiJztcbiAgICB9XG4gICAgaWYgKHJlYXNvbiAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiByZWFzb24uY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgcmVhc29uLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdBc3NlcnRpb25FcnJvcicgJiZcbiAgICAgICAgcmVhc29uLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdFcnJvcicpIHtcbiAgICAgIHJldCArPSAnIGJlY2F1c2Ugb2YgXCInICsgcmVhc29uLmNvbnN0cnVjdG9yLm5hbWUgKyAnXCInO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQ2FzdEVycm9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/cast.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/createCollectionsError.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/createCollectionsError.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * createCollections Error constructor\n *\n * @param {String} message\n * @param {String} errorsMap\n * @inherits MongooseError\n * @api private\n */\n\nclass CreateCollectionsError extends MongooseError {\n  constructor(message, errorsMap) {\n    super(message);\n    this.errors = errorsMap;\n  }\n}\n\nObject.defineProperty(CreateCollectionsError.prototype, 'name', {\n  value: 'CreateCollectionsError'\n});\n\nmodule.exports = CreateCollectionsError;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvY3JlYXRlQ29sbGVjdGlvbnNFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBaUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGVycm9yXFxjcmVhdGVDb2xsZWN0aW9uc0Vycm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vbW9uZ29vc2VFcnJvcicpO1xuXG4vKipcbiAqIGNyZWF0ZUNvbGxlY3Rpb25zIEVycm9yIGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvcnNNYXBcbiAqIEBpbmhlcml0cyBNb25nb29zZUVycm9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jbGFzcyBDcmVhdGVDb2xsZWN0aW9uc0Vycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yc01hcCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzTWFwO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDcmVhdGVDb2xsZWN0aW9uc0Vycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnQ3JlYXRlQ29sbGVjdGlvbnNFcnJvcidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZUNvbGxlY3Rpb25zRXJyb3I7XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/createCollectionsError.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/divergentArray.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/divergentArray.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\nclass DivergentArrayError extends MongooseError {\n  /**\n   * DivergentArrayError constructor.\n   * @param {Array<String>} paths\n   * @api private\n   */\n  constructor(paths) {\n    const msg = 'For your own good, using `document.save()` to update an array '\n            + 'which was selected using an $elemMatch projection OR '\n            + 'populated using skip, limit, query conditions, or exclusion of '\n            + 'the _id field when the operation results in a $pop or $set of '\n            + 'the entire array is not supported. The following '\n            + 'path(s) would have been modified unsafely:\\n'\n            + '  ' + paths.join('\\n  ') + '\\n'\n            + 'Use Model.updateOne() to update these arrays instead.';\n    // TODO write up a docs page (FAQ) and link to it\n    super(msg);\n  }\n}\n\nObject.defineProperty(DivergentArrayError.prototype, 'name', {\n  value: 'DivergentArrayError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = DivergentArrayError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvZGl2ZXJnZW50QXJyYXkuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxvRUFBSTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxlcnJvclxcZGl2ZXJnZW50QXJyYXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuY2xhc3MgRGl2ZXJnZW50QXJyYXlFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogRGl2ZXJnZW50QXJyYXlFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBwYXRoc1xuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhdGhzKSB7XG4gICAgY29uc3QgbXNnID0gJ0ZvciB5b3VyIG93biBnb29kLCB1c2luZyBgZG9jdW1lbnQuc2F2ZSgpYCB0byB1cGRhdGUgYW4gYXJyYXkgJ1xuICAgICAgICAgICAgKyAnd2hpY2ggd2FzIHNlbGVjdGVkIHVzaW5nIGFuICRlbGVtTWF0Y2ggcHJvamVjdGlvbiBPUiAnXG4gICAgICAgICAgICArICdwb3B1bGF0ZWQgdXNpbmcgc2tpcCwgbGltaXQsIHF1ZXJ5IGNvbmRpdGlvbnMsIG9yIGV4Y2x1c2lvbiBvZiAnXG4gICAgICAgICAgICArICd0aGUgX2lkIGZpZWxkIHdoZW4gdGhlIG9wZXJhdGlvbiByZXN1bHRzIGluIGEgJHBvcCBvciAkc2V0IG9mICdcbiAgICAgICAgICAgICsgJ3RoZSBlbnRpcmUgYXJyYXkgaXMgbm90IHN1cHBvcnRlZC4gVGhlIGZvbGxvd2luZyAnXG4gICAgICAgICAgICArICdwYXRoKHMpIHdvdWxkIGhhdmUgYmVlbiBtb2RpZmllZCB1bnNhZmVseTpcXG4nXG4gICAgICAgICAgICArICcgICcgKyBwYXRocy5qb2luKCdcXG4gICcpICsgJ1xcbidcbiAgICAgICAgICAgICsgJ1VzZSBNb2RlbC51cGRhdGVPbmUoKSB0byB1cGRhdGUgdGhlc2UgYXJyYXlzIGluc3RlYWQuJztcbiAgICAvLyBUT0RPIHdyaXRlIHVwIGEgZG9jcyBwYWdlIChGQVEpIGFuZCBsaW5rIHRvIGl0XG4gICAgc3VwZXIobXNnKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGl2ZXJnZW50QXJyYXlFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ0RpdmVyZ2VudEFycmF5RXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBEaXZlcmdlbnRBcnJheUVycm9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/divergentArray.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/eachAsyncMultiError.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/eachAsyncMultiError.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\n\n/**\n * If `eachAsync()` is called with `continueOnError: true`, there can be\n * multiple errors. This error class contains an `errors` property, which\n * contains an array of all errors that occurred in `eachAsync()`.\n *\n * @api private\n */\n\nclass EachAsyncMultiError extends MongooseError {\n  /**\n   * @param {String} connectionString\n   */\n  constructor(errors) {\n    let preview = errors.map(e => e.message).join(', ');\n    if (preview.length > 50) {\n      preview = preview.slice(0, 50) + '...';\n    }\n    super(`eachAsync() finished with ${errors.length} errors: ${preview}`);\n\n    this.errors = errors;\n  }\n}\n\nObject.defineProperty(EachAsyncMultiError.prototype, 'name', {\n  value: 'EachAsyncMultiError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = EachAsyncMultiError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvZWFjaEFzeW5jTXVsdGlFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsb0VBQUk7OztBQUdsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlLFVBQVUsUUFBUTs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGVycm9yXFxlYWNoQXN5bmNNdWx0aUVycm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5cbi8qKlxuICogSWYgYGVhY2hBc3luYygpYCBpcyBjYWxsZWQgd2l0aCBgY29udGludWVPbkVycm9yOiB0cnVlYCwgdGhlcmUgY2FuIGJlXG4gKiBtdWx0aXBsZSBlcnJvcnMuIFRoaXMgZXJyb3IgY2xhc3MgY29udGFpbnMgYW4gYGVycm9yc2AgcHJvcGVydHksIHdoaWNoXG4gKiBjb250YWlucyBhbiBhcnJheSBvZiBhbGwgZXJyb3JzIHRoYXQgb2NjdXJyZWQgaW4gYGVhY2hBc3luYygpYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jbGFzcyBFYWNoQXN5bmNNdWx0aUVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29ubmVjdGlvblN0cmluZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgbGV0IHByZXZpZXcgPSBlcnJvcnMubWFwKGUgPT4gZS5tZXNzYWdlKS5qb2luKCcsICcpO1xuICAgIGlmIChwcmV2aWV3Lmxlbmd0aCA+IDUwKSB7XG4gICAgICBwcmV2aWV3ID0gcHJldmlldy5zbGljZSgwLCA1MCkgKyAnLi4uJztcbiAgICB9XG4gICAgc3VwZXIoYGVhY2hBc3luYygpIGZpbmlzaGVkIHdpdGggJHtlcnJvcnMubGVuZ3RofSBlcnJvcnM6ICR7cHJldmlld31gKTtcblxuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFYWNoQXN5bmNNdWx0aUVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnRWFjaEFzeW5jTXVsdGlFcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVhY2hBc3luY011bHRpRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/eachAsyncMultiError.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/index.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/index.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * MongooseError constructor. MongooseError is the base class for all\n * Mongoose-specific errors.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', new mongoose.Schema({ answer: Number }));\n *     const doc = new Model({ answer: 'not a number' });\n *     const err = doc.validateSync();\n *\n *     err instanceof mongoose.Error.ValidationError; // true\n *\n * @constructor Error\n * @param {String} msg Error message\n * @inherits Error https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * The name of the error. The name uniquely identifies this Mongoose error. The\n * possible values are:\n *\n * - `MongooseError`: general Mongoose error\n * - `CastError`: Mongoose could not convert a value to the type defined in the schema path. May be in a `ValidationError` class' `errors` property.\n * - `DivergentArrayError`: You attempted to `save()` an array that was modified after you loaded it with a `$elemMatch` or similar projection\n * - `MissingSchemaError`: You tried to access a model with [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.model()) that was not defined\n * - `DocumentNotFoundError`: The document you tried to [`save()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.save()) was not found\n * - `ValidatorError`: error from an individual schema path's validator\n * - `ValidationError`: error returned from [`validate()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()) or [`validateSync()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validateSync()). Contains zero or more `ValidatorError` instances in `.errors` property.\n * - `MissingSchemaError`: You called `mongoose.Document()` without a schema\n * - `ObjectExpectedError`: Thrown when you set a nested path to a non-object value with [strict mode set](https://mongoosejs.com/docs/guide.html#strict).\n * - `ObjectParameterError`: Thrown when you pass a non-object value to a function which expects an object as a paramter\n * - `OverwriteModelError`: Thrown when you call [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.model()) to re-define a model that was already defined.\n * - `ParallelSaveError`: Thrown when you call [`save()`](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) on a document when the same document instance is already saving.\n * - `StrictModeError`: Thrown when you set a path that isn't the schema and [strict mode](https://mongoosejs.com/docs/guide.html#strict) is set to `throw`.\n * - `VersionError`: Thrown when the [document is out of sync](https://mongoosejs.com/docs/guide.html#versionKey)\n *\n * @api public\n * @property {String} name\n * @memberOf Error\n * @instance\n */\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseError;\n\n/**\n * The default built-in validator error messages.\n *\n * @see Error.messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.messages = __webpack_require__(/*! ./messages */ \"(api)/../server/node_modules/mongoose/lib/error/messages.js\");\n\n// backward compat\nMongooseError.Messages = MongooseError.messages;\n\n/**\n * An instance of this error class will be returned when `save()` fails\n * because the underlying\n * document was not found. The constructor takes one parameter, the\n * conditions that mongoose passed to `updateOne()` when trying to update\n * the document.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.DocumentNotFoundError = __webpack_require__(/*! ./notFound */ \"(api)/../server/node_modules/mongoose/lib/error/notFound.js\");\n\n/**\n * An instance of this error class will be returned when mongoose failed to\n * cast a value.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.CastError = __webpack_require__(/*! ./cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * An instance of this error class will be returned when [validation](https://mongoosejs.com/docs/validation.html) failed.\n * The `errors` property contains an object whose keys are the paths that failed and whose values are\n * instances of CastError or ValidationError.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.ValidationError = __webpack_require__(/*! ./validation */ \"(api)/../server/node_modules/mongoose/lib/error/validation.js\");\n\n/**\n * A `ValidationError` has a hash of `errors` that contain individual\n * `ValidatorError` instances.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: { type: String, required: true } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *\n *     // Top-level error is a ValidationError, **not** a ValidatorError\n *     const err = doc.validateSync();\n *     err instanceof mongoose.Error.ValidationError; // true\n *\n *     // A ValidationError `err` has 0 or more ValidatorErrors keyed by the\n *     // path in the `err.errors` property.\n *     err.errors['name'] instanceof mongoose.Error.ValidatorError;\n *\n *     err.errors['name'].kind; // 'required'\n *     err.errors['name'].path; // 'name'\n *     err.errors['name'].value; // undefined\n *\n * Instances of `ValidatorError` have the following properties:\n *\n * - `kind`: The validator's `type`, like `'required'` or `'regexp'`\n * - `path`: The path that failed validation\n * - `value`: The value that failed validation\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.ValidatorError = __webpack_require__(/*! ./validator */ \"(api)/../server/node_modules/mongoose/lib/error/validator.js\");\n\n/**\n * An instance of this error class will be returned when you call `save()` after\n * the document in the database was changed in a potentially unsafe way. See\n * the [`versionKey` option](https://mongoosejs.com/docs/guide.html#versionKey) for more information.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.VersionError = __webpack_require__(/*! ./version */ \"(api)/../server/node_modules/mongoose/lib/error/version.js\");\n\n/**\n * An instance of this error class will be returned when you call `save()` multiple\n * times on the same document in parallel. See the [FAQ](https://mongoosejs.com/docs/faq.html) for more\n * information.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.ParallelSaveError = __webpack_require__(/*! ./parallelSave */ \"(api)/../server/node_modules/mongoose/lib/error/parallelSave.js\");\n\n/**\n * Thrown when a model with the given name was already registered on the connection.\n * See [the FAQ about `OverwriteModelError`](https://mongoosejs.com/docs/faq.html#overwrite-model-error).\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.OverwriteModelError = __webpack_require__(/*! ./overwriteModel */ \"(api)/../server/node_modules/mongoose/lib/error/overwriteModel.js\");\n\n/**\n * Thrown when you try to access a model that has not been registered yet\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.MissingSchemaError = __webpack_require__(/*! ./missingSchema */ \"(api)/../server/node_modules/mongoose/lib/error/missingSchema.js\");\n\n/**\n * Thrown when the MongoDB Node driver can't connect to a valid server\n * to send an operation to.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.MongooseServerSelectionError = __webpack_require__(/*! ./serverSelection */ \"(api)/../server/node_modules/mongoose/lib/error/serverSelection.js\");\n\n/**\n * An instance of this error will be returned if you used an array projection\n * and then modified the array in an unsafe way.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.DivergentArrayError = __webpack_require__(/*! ./divergentArray */ \"(api)/../server/node_modules/mongoose/lib/error/divergentArray.js\");\n\n/**\n * Thrown when your try to pass values to model constructor that\n * were not specified in schema or change immutable properties when\n * `strict` mode is `\"throw\"`\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.StrictModeError = __webpack_require__(/*! ./strict */ \"(api)/../server/node_modules/mongoose/lib/error/strict.js\");\n\n/**\n * An instance of this error class will be returned when mongoose failed to\n * populate with a path that is not existing.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.StrictPopulateError = __webpack_require__(/*! ./strictPopulate */ \"(api)/../server/node_modules/mongoose/lib/error/strictPopulate.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRiwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLHlGQUFpQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG1CQUFPLENBQUMsK0VBQVk7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsbUJBQU8sQ0FBQywrRUFBWTs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsbUJBQU8sQ0FBQyx1RUFBUTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxtQkFBTyxDQUFDLG1GQUFjOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUSxnQ0FBZ0M7QUFDdkU7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixtQkFBTyxDQUFDLGlGQUFhOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLG1CQUFPLENBQUMsNkVBQVc7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsbUJBQU8sQ0FBQyx1RkFBZ0I7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLG1CQUFPLENBQUMsMkZBQWtCOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsbUJBQU8sQ0FBQyx5RkFBaUI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLG1CQUFPLENBQUMsNkZBQW1COztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxtQkFBTyxDQUFDLDJGQUFrQjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxtQkFBTyxDQUFDLDJFQUFVOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxtQkFBTyxDQUFDLDJGQUFrQiIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGVycm9yXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9uZ29vc2VFcnJvciBjb25zdHJ1Y3Rvci4gTW9uZ29vc2VFcnJvciBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsXG4gKiBNb25nb29zZS1zcGVjaWZpYyBlcnJvcnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IG1vbmdvb3NlLlNjaGVtYSh7IGFuc3dlcjogTnVtYmVyIH0pKTtcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgTW9kZWwoeyBhbnN3ZXI6ICdub3QgYSBudW1iZXInIH0pO1xuICogICAgIGNvbnN0IGVyciA9IGRvYy52YWxpZGF0ZVN5bmMoKTtcbiAqXG4gKiAgICAgZXJyIGluc3RhbmNlb2YgbW9uZ29vc2UuRXJyb3IuVmFsaWRhdGlvbkVycm9yOyAvLyB0cnVlXG4gKlxuICogQGNvbnN0cnVjdG9yIEVycm9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIEVycm9yIG1lc3NhZ2VcbiAqIEBpbmhlcml0cyBFcnJvciBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvclxuICovXG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL21vbmdvb3NlRXJyb3InKTtcblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgZXJyb3IuIFRoZSBuYW1lIHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhpcyBNb25nb29zZSBlcnJvci4gVGhlXG4gKiBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICpcbiAqIC0gYE1vbmdvb3NlRXJyb3JgOiBnZW5lcmFsIE1vbmdvb3NlIGVycm9yXG4gKiAtIGBDYXN0RXJyb3JgOiBNb25nb29zZSBjb3VsZCBub3QgY29udmVydCBhIHZhbHVlIHRvIHRoZSB0eXBlIGRlZmluZWQgaW4gdGhlIHNjaGVtYSBwYXRoLiBNYXkgYmUgaW4gYSBgVmFsaWRhdGlvbkVycm9yYCBjbGFzcycgYGVycm9yc2AgcHJvcGVydHkuXG4gKiAtIGBEaXZlcmdlbnRBcnJheUVycm9yYDogWW91IGF0dGVtcHRlZCB0byBgc2F2ZSgpYCBhbiBhcnJheSB0aGF0IHdhcyBtb2RpZmllZCBhZnRlciB5b3UgbG9hZGVkIGl0IHdpdGggYSBgJGVsZW1NYXRjaGAgb3Igc2ltaWxhciBwcm9qZWN0aW9uXG4gKiAtIGBNaXNzaW5nU2NoZW1hRXJyb3JgOiBZb3UgdHJpZWQgdG8gYWNjZXNzIGEgbW9kZWwgd2l0aCBbYG1vbmdvb3NlLm1vZGVsKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UubW9kZWwoKSkgdGhhdCB3YXMgbm90IGRlZmluZWRcbiAqIC0gYERvY3VtZW50Tm90Rm91bmRFcnJvcmA6IFRoZSBkb2N1bWVudCB5b3UgdHJpZWQgdG8gW2BzYXZlKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnNhdmUoKSkgd2FzIG5vdCBmb3VuZFxuICogLSBgVmFsaWRhdG9yRXJyb3JgOiBlcnJvciBmcm9tIGFuIGluZGl2aWR1YWwgc2NoZW1hIHBhdGgncyB2YWxpZGF0b3JcbiAqIC0gYFZhbGlkYXRpb25FcnJvcmA6IGVycm9yIHJldHVybmVkIGZyb20gW2B2YWxpZGF0ZSgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZSgpKSBvciBbYHZhbGlkYXRlU3luYygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZVN5bmMoKSkuIENvbnRhaW5zIHplcm8gb3IgbW9yZSBgVmFsaWRhdG9yRXJyb3JgIGluc3RhbmNlcyBpbiBgLmVycm9yc2AgcHJvcGVydHkuXG4gKiAtIGBNaXNzaW5nU2NoZW1hRXJyb3JgOiBZb3UgY2FsbGVkIGBtb25nb29zZS5Eb2N1bWVudCgpYCB3aXRob3V0IGEgc2NoZW1hXG4gKiAtIGBPYmplY3RFeHBlY3RlZEVycm9yYDogVGhyb3duIHdoZW4geW91IHNldCBhIG5lc3RlZCBwYXRoIHRvIGEgbm9uLW9iamVjdCB2YWx1ZSB3aXRoIFtzdHJpY3QgbW9kZSBzZXRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdCkuXG4gKiAtIGBPYmplY3RQYXJhbWV0ZXJFcnJvcmA6IFRocm93biB3aGVuIHlvdSBwYXNzIGEgbm9uLW9iamVjdCB2YWx1ZSB0byBhIGZ1bmN0aW9uIHdoaWNoIGV4cGVjdHMgYW4gb2JqZWN0IGFzIGEgcGFyYW10ZXJcbiAqIC0gYE92ZXJ3cml0ZU1vZGVsRXJyb3JgOiBUaHJvd24gd2hlbiB5b3UgY2FsbCBbYG1vbmdvb3NlLm1vZGVsKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UubW9kZWwoKSkgdG8gcmUtZGVmaW5lIGEgbW9kZWwgdGhhdCB3YXMgYWxyZWFkeSBkZWZpbmVkLlxuICogLSBgUGFyYWxsZWxTYXZlRXJyb3JgOiBUaHJvd24gd2hlbiB5b3UgY2FsbCBbYHNhdmUoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5wcm90b3R5cGUuc2F2ZSgpKSBvbiBhIGRvY3VtZW50IHdoZW4gdGhlIHNhbWUgZG9jdW1lbnQgaW5zdGFuY2UgaXMgYWxyZWFkeSBzYXZpbmcuXG4gKiAtIGBTdHJpY3RNb2RlRXJyb3JgOiBUaHJvd24gd2hlbiB5b3Ugc2V0IGEgcGF0aCB0aGF0IGlzbid0IHRoZSBzY2hlbWEgYW5kIFtzdHJpY3QgbW9kZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KSBpcyBzZXQgdG8gYHRocm93YC5cbiAqIC0gYFZlcnNpb25FcnJvcmA6IFRocm93biB3aGVuIHRoZSBbZG9jdW1lbnQgaXMgb3V0IG9mIHN5bmNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3ZlcnNpb25LZXkpXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBpbnN0YW5jZVxuICovXG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gTW9uZ29vc2VFcnJvcjtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBidWlsdC1pbiB2YWxpZGF0b3IgZXJyb3IgbWVzc2FnZXMuXG4gKlxuICogQHNlZSBFcnJvci5tZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLm1lc3NhZ2VzID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vLyBiYWNrd2FyZCBjb21wYXRcbk1vbmdvb3NlRXJyb3IuTWVzc2FnZXMgPSBNb25nb29zZUVycm9yLm1lc3NhZ2VzO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3IgY2xhc3Mgd2lsbCBiZSByZXR1cm5lZCB3aGVuIGBzYXZlKClgIGZhaWxzXG4gKiBiZWNhdXNlIHRoZSB1bmRlcmx5aW5nXG4gKiBkb2N1bWVudCB3YXMgbm90IGZvdW5kLiBUaGUgY29uc3RydWN0b3IgdGFrZXMgb25lIHBhcmFtZXRlciwgdGhlXG4gKiBjb25kaXRpb25zIHRoYXQgbW9uZ29vc2UgcGFzc2VkIHRvIGB1cGRhdGVPbmUoKWAgd2hlbiB0cnlpbmcgdG8gdXBkYXRlXG4gKiB0aGUgZG9jdW1lbnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuRG9jdW1lbnROb3RGb3VuZEVycm9yID0gcmVxdWlyZSgnLi9ub3RGb3VuZCcpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3IgY2xhc3Mgd2lsbCBiZSByZXR1cm5lZCB3aGVuIG1vbmdvb3NlIGZhaWxlZCB0b1xuICogY2FzdCBhIHZhbHVlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLkNhc3RFcnJvciA9IHJlcXVpcmUoJy4vY2FzdCcpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3IgY2xhc3Mgd2lsbCBiZSByZXR1cm5lZCB3aGVuIFt2YWxpZGF0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdmFsaWRhdGlvbi5odG1sKSBmYWlsZWQuXG4gKiBUaGUgYGVycm9yc2AgcHJvcGVydHkgY29udGFpbnMgYW4gb2JqZWN0IHdob3NlIGtleXMgYXJlIHRoZSBwYXRocyB0aGF0IGZhaWxlZCBhbmQgd2hvc2UgdmFsdWVzIGFyZVxuICogaW5zdGFuY2VzIG9mIENhc3RFcnJvciBvciBWYWxpZGF0aW9uRXJyb3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQSBgVmFsaWRhdGlvbkVycm9yYCBoYXMgYSBoYXNoIG9mIGBlcnJvcnNgIHRoYXQgY29udGFpbiBpbmRpdmlkdWFsXG4gKiBgVmFsaWRhdG9yRXJyb3JgIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9IH0pO1xuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7fSk7XG4gKlxuICogICAgIC8vIFRvcC1sZXZlbCBlcnJvciBpcyBhIFZhbGlkYXRpb25FcnJvciwgKipub3QqKiBhIFZhbGlkYXRvckVycm9yXG4gKiAgICAgY29uc3QgZXJyID0gZG9jLnZhbGlkYXRlU3luYygpO1xuICogICAgIGVyciBpbnN0YW5jZW9mIG1vbmdvb3NlLkVycm9yLlZhbGlkYXRpb25FcnJvcjsgLy8gdHJ1ZVxuICpcbiAqICAgICAvLyBBIFZhbGlkYXRpb25FcnJvciBgZXJyYCBoYXMgMCBvciBtb3JlIFZhbGlkYXRvckVycm9ycyBrZXllZCBieSB0aGVcbiAqICAgICAvLyBwYXRoIGluIHRoZSBgZXJyLmVycm9yc2AgcHJvcGVydHkuXG4gKiAgICAgZXJyLmVycm9yc1snbmFtZSddIGluc3RhbmNlb2YgbW9uZ29vc2UuRXJyb3IuVmFsaWRhdG9yRXJyb3I7XG4gKlxuICogICAgIGVyci5lcnJvcnNbJ25hbWUnXS5raW5kOyAvLyAncmVxdWlyZWQnXG4gKiAgICAgZXJyLmVycm9yc1snbmFtZSddLnBhdGg7IC8vICduYW1lJ1xuICogICAgIGVyci5lcnJvcnNbJ25hbWUnXS52YWx1ZTsgLy8gdW5kZWZpbmVkXG4gKlxuICogSW5zdGFuY2VzIG9mIGBWYWxpZGF0b3JFcnJvcmAgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSBga2luZGA6IFRoZSB2YWxpZGF0b3IncyBgdHlwZWAsIGxpa2UgYCdyZXF1aXJlZCdgIG9yIGAncmVnZXhwJ2BcbiAqIC0gYHBhdGhgOiBUaGUgcGF0aCB0aGF0IGZhaWxlZCB2YWxpZGF0aW9uXG4gKiAtIGB2YWx1ZWA6IFRoZSB2YWx1ZSB0aGF0IGZhaWxlZCB2YWxpZGF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuVmFsaWRhdG9yRXJyb3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3IgY2xhc3Mgd2lsbCBiZSByZXR1cm5lZCB3aGVuIHlvdSBjYWxsIGBzYXZlKClgIGFmdGVyXG4gKiB0aGUgZG9jdW1lbnQgaW4gdGhlIGRhdGFiYXNlIHdhcyBjaGFuZ2VkIGluIGEgcG90ZW50aWFsbHkgdW5zYWZlIHdheS4gU2VlXG4gKiB0aGUgW2B2ZXJzaW9uS2V5YCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3ZlcnNpb25LZXkpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLlZlcnNpb25FcnJvciA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3IgY2xhc3Mgd2lsbCBiZSByZXR1cm5lZCB3aGVuIHlvdSBjYWxsIGBzYXZlKClgIG11bHRpcGxlXG4gKiB0aW1lcyBvbiB0aGUgc2FtZSBkb2N1bWVudCBpbiBwYXJhbGxlbC4gU2VlIHRoZSBbRkFRXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZmFxLmh0bWwpIGZvciBtb3JlXG4gKiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5QYXJhbGxlbFNhdmVFcnJvciA9IHJlcXVpcmUoJy4vcGFyYWxsZWxTYXZlJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBtb2RlbCB3aXRoIHRoZSBnaXZlbiBuYW1lIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgb24gdGhlIGNvbm5lY3Rpb24uXG4gKiBTZWUgW3RoZSBGQVEgYWJvdXQgYE92ZXJ3cml0ZU1vZGVsRXJyb3JgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZmFxLmh0bWwjb3ZlcndyaXRlLW1vZGVsLWVycm9yKS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5PdmVyd3JpdGVNb2RlbEVycm9yID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVNb2RlbCcpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIHlvdSB0cnkgdG8gYWNjZXNzIGEgbW9kZWwgdGhhdCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCB5ZXRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5NaXNzaW5nU2NoZW1hRXJyb3IgPSByZXF1aXJlKCcuL21pc3NpbmdTY2hlbWEnKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgTW9uZ29EQiBOb2RlIGRyaXZlciBjYW4ndCBjb25uZWN0IHRvIGEgdmFsaWQgc2VydmVyXG4gKiB0byBzZW5kIGFuIG9wZXJhdGlvbiB0by5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5Nb25nb29zZVNlcnZlclNlbGVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi9zZXJ2ZXJTZWxlY3Rpb24nKTtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGlzIGVycm9yIHdpbGwgYmUgcmV0dXJuZWQgaWYgeW91IHVzZWQgYW4gYXJyYXkgcHJvamVjdGlvblxuICogYW5kIHRoZW4gbW9kaWZpZWQgdGhlIGFycmF5IGluIGFuIHVuc2FmZSB3YXkuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuRGl2ZXJnZW50QXJyYXlFcnJvciA9IHJlcXVpcmUoJy4vZGl2ZXJnZW50QXJyYXknKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiB5b3VyIHRyeSB0byBwYXNzIHZhbHVlcyB0byBtb2RlbCBjb25zdHJ1Y3RvciB0aGF0XG4gKiB3ZXJlIG5vdCBzcGVjaWZpZWQgaW4gc2NoZW1hIG9yIGNoYW5nZSBpbW11dGFibGUgcHJvcGVydGllcyB3aGVuXG4gKiBgc3RyaWN0YCBtb2RlIGlzIGBcInRocm93XCJgXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuU3RyaWN0TW9kZUVycm9yID0gcmVxdWlyZSgnLi9zdHJpY3QnKTtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGlzIGVycm9yIGNsYXNzIHdpbGwgYmUgcmV0dXJuZWQgd2hlbiBtb25nb29zZSBmYWlsZWQgdG9cbiAqIHBvcHVsYXRlIHdpdGggYSBwYXRoIHRoYXQgaXMgbm90IGV4aXN0aW5nLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLlN0cmljdFBvcHVsYXRlRXJyb3IgPSByZXF1aXJlKCcuL3N0cmljdFBvcHVsYXRlJyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/index.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/invalidSchemaOption.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/invalidSchemaOption.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\nclass InvalidSchemaOptionError extends MongooseError {\n  /**\n   * InvalidSchemaOption Error constructor.\n   * @param {String} name\n   * @api private\n   */\n  constructor(name, option) {\n    const msg = `Cannot create use schema for property \"${name}\" because the schema has the ${option} option enabled.`;\n    super(msg);\n  }\n}\n\nObject.defineProperty(InvalidSchemaOptionError.prototype, 'name', {\n  value: 'InvalidSchemaOptionError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = InvalidSchemaOptionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvaW52YWxpZFNjaGVtYU9wdGlvbi5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLG9FQUFJOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUssK0JBQStCLFFBQVE7QUFDdEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGVycm9yXFxpbnZhbGlkU2NoZW1hT3B0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cbmNsYXNzIEludmFsaWRTY2hlbWFPcHRpb25FcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogSW52YWxpZFNjaGVtYU9wdGlvbiBFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuYW1lLCBvcHRpb24pIHtcbiAgICBjb25zdCBtc2cgPSBgQ2Fubm90IGNyZWF0ZSB1c2Ugc2NoZW1hIGZvciBwcm9wZXJ0eSBcIiR7bmFtZX1cIiBiZWNhdXNlIHRoZSBzY2hlbWEgaGFzIHRoZSAke29wdGlvbn0gb3B0aW9uIGVuYWJsZWQuYDtcbiAgICBzdXBlcihtc2cpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnZhbGlkU2NoZW1hT3B0aW9uRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdJbnZhbGlkU2NoZW1hT3B0aW9uRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBJbnZhbGlkU2NoZW1hT3B0aW9uRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/invalidSchemaOption.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/messages.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/messages.js ***!
  \*************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n/**\n * The default built-in validator error messages. These may be customized.\n *\n *     // customize within each schema or globally like so\n *     const mongoose = require('mongoose');\n *     mongoose.Error.messages.String.enum  = \"Your custom message for {PATH}.\";\n *\n * Error messages support basic templating. Mongoose will replace the following strings with the corresponding value.\n *\n * - `{PATH}` is replaced with the invalid document path\n * - `{VALUE}` is replaced with the invalid value\n * - `{TYPE}` is replaced with the validator type such as \"regexp\", \"min\", or \"user defined\"\n * - `{MIN}` is replaced with the declared min value for the Number.min validator\n * - `{MAX}` is replaced with the declared max value for the Number.max validator\n *\n * Click the \"show code\" link below to see all defaults.\n *\n * @static\n * @memberOf MongooseError\n * @api public\n */\n\n\n\nconst msg = module.exports = exports = {};\n\nmsg.DocumentNotFoundError = null;\n\nmsg.general = {};\nmsg.general.default = 'Validator failed for path `{PATH}` with value `{VALUE}`';\nmsg.general.required = 'Path `{PATH}` is required.';\n\nmsg.Number = {};\nmsg.Number.min = 'Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).';\nmsg.Number.max = 'Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).';\nmsg.Number.enum = '`{VALUE}` is not a valid enum value for path `{PATH}`.';\n\nmsg.Date = {};\nmsg.Date.min = 'Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).';\nmsg.Date.max = 'Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).';\n\nmsg.String = {};\nmsg.String.enum = '`{VALUE}` is not a valid enum value for path `{PATH}`.';\nmsg.String.match = 'Path `{PATH}` is invalid ({VALUE}).';\nmsg.String.minlength = 'Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).';\nmsg.String.maxlength = 'Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEtBQUs7QUFDWixPQUFPLE1BQU07QUFDYixPQUFPLEtBQUs7QUFDWixPQUFPLElBQUk7QUFDWCxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQTs7QUFFQTtBQUNBLG1EQUFtRCxLQUFLLGVBQWUsTUFBTTtBQUM3RSwrQkFBK0IsS0FBSzs7QUFFcEM7QUFDQSx5QkFBeUIsS0FBSyxJQUFJLE1BQU0sdUNBQXVDLElBQUk7QUFDbkYseUJBQXlCLEtBQUssSUFBSSxNQUFNLHVDQUF1QyxJQUFJO0FBQ25GLHFCQUFxQixNQUFNLHVDQUF1QyxLQUFLOztBQUV2RTtBQUNBLHVCQUF1QixLQUFLLElBQUksTUFBTSxvQ0FBb0MsSUFBSTtBQUM5RSx1QkFBdUIsS0FBSyxJQUFJLE1BQU0sbUNBQW1DLElBQUk7O0FBRTdFO0FBQ0EscUJBQXFCLE1BQU0sdUNBQXVDLEtBQUs7QUFDdkUsMkJBQTJCLEtBQUssZUFBZSxNQUFNO0FBQ3JELCtCQUErQixLQUFLLEtBQUssTUFBTSxnREFBZ0QsVUFBVTtBQUN6RywrQkFBK0IsS0FBSyxLQUFLLE1BQU0sK0NBQStDLFVBQVUiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxlcnJvclxcbWVzc2FnZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoZSBkZWZhdWx0IGJ1aWx0LWluIHZhbGlkYXRvciBlcnJvciBtZXNzYWdlcy4gVGhlc2UgbWF5IGJlIGN1c3RvbWl6ZWQuXG4gKlxuICogICAgIC8vIGN1c3RvbWl6ZSB3aXRoaW4gZWFjaCBzY2hlbWEgb3IgZ2xvYmFsbHkgbGlrZSBzb1xuICogICAgIGNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbiAqICAgICBtb25nb29zZS5FcnJvci5tZXNzYWdlcy5TdHJpbmcuZW51bSAgPSBcIllvdXIgY3VzdG9tIG1lc3NhZ2UgZm9yIHtQQVRIfS5cIjtcbiAqXG4gKiBFcnJvciBtZXNzYWdlcyBzdXBwb3J0IGJhc2ljIHRlbXBsYXRpbmcuIE1vbmdvb3NlIHdpbGwgcmVwbGFjZSB0aGUgZm9sbG93aW5nIHN0cmluZ3Mgd2l0aCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAqXG4gKiAtIGB7UEFUSH1gIGlzIHJlcGxhY2VkIHdpdGggdGhlIGludmFsaWQgZG9jdW1lbnQgcGF0aFxuICogLSBge1ZBTFVFfWAgaXMgcmVwbGFjZWQgd2l0aCB0aGUgaW52YWxpZCB2YWx1ZVxuICogLSBge1RZUEV9YCBpcyByZXBsYWNlZCB3aXRoIHRoZSB2YWxpZGF0b3IgdHlwZSBzdWNoIGFzIFwicmVnZXhwXCIsIFwibWluXCIsIG9yIFwidXNlciBkZWZpbmVkXCJcbiAqIC0gYHtNSU59YCBpcyByZXBsYWNlZCB3aXRoIHRoZSBkZWNsYXJlZCBtaW4gdmFsdWUgZm9yIHRoZSBOdW1iZXIubWluIHZhbGlkYXRvclxuICogLSBge01BWH1gIGlzIHJlcGxhY2VkIHdpdGggdGhlIGRlY2xhcmVkIG1heCB2YWx1ZSBmb3IgdGhlIE51bWJlci5tYXggdmFsaWRhdG9yXG4gKlxuICogQ2xpY2sgdGhlIFwic2hvdyBjb2RlXCIgbGluayBiZWxvdyB0byBzZWUgYWxsIGRlZmF1bHRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBNb25nb29zZUVycm9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgbXNnID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0ge307XG5cbm1zZy5Eb2N1bWVudE5vdEZvdW5kRXJyb3IgPSBudWxsO1xuXG5tc2cuZ2VuZXJhbCA9IHt9O1xubXNnLmdlbmVyYWwuZGVmYXVsdCA9ICdWYWxpZGF0b3IgZmFpbGVkIGZvciBwYXRoIGB7UEFUSH1gIHdpdGggdmFsdWUgYHtWQUxVRX1gJztcbm1zZy5nZW5lcmFsLnJlcXVpcmVkID0gJ1BhdGggYHtQQVRIfWAgaXMgcmVxdWlyZWQuJztcblxubXNnLk51bWJlciA9IHt9O1xubXNnLk51bWJlci5taW4gPSAnUGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgaXMgbGVzcyB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZSAoe01JTn0pLic7XG5tc2cuTnVtYmVyLm1heCA9ICdQYXRoIGB7UEFUSH1gICh7VkFMVUV9KSBpcyBtb3JlIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlICh7TUFYfSkuJztcbm1zZy5OdW1iZXIuZW51bSA9ICdge1ZBTFVFfWAgaXMgbm90IGEgdmFsaWQgZW51bSB2YWx1ZSBmb3IgcGF0aCBge1BBVEh9YC4nO1xuXG5tc2cuRGF0ZSA9IHt9O1xubXNnLkRhdGUubWluID0gJ1BhdGggYHtQQVRIfWAgKHtWQUxVRX0pIGlzIGJlZm9yZSBtaW5pbXVtIGFsbG93ZWQgdmFsdWUgKHtNSU59KS4nO1xubXNnLkRhdGUubWF4ID0gJ1BhdGggYHtQQVRIfWAgKHtWQUxVRX0pIGlzIGFmdGVyIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoe01BWH0pLic7XG5cbm1zZy5TdHJpbmcgPSB7fTtcbm1zZy5TdHJpbmcuZW51bSA9ICdge1ZBTFVFfWAgaXMgbm90IGEgdmFsaWQgZW51bSB2YWx1ZSBmb3IgcGF0aCBge1BBVEh9YC4nO1xubXNnLlN0cmluZy5tYXRjaCA9ICdQYXRoIGB7UEFUSH1gIGlzIGludmFsaWQgKHtWQUxVRX0pLic7XG5tc2cuU3RyaW5nLm1pbmxlbmd0aCA9ICdQYXRoIGB7UEFUSH1gIChge1ZBTFVFfWApIGlzIHNob3J0ZXIgdGhhbiB0aGUgbWluaW11bSBhbGxvd2VkIGxlbmd0aCAoe01JTkxFTkdUSH0pLic7XG5tc2cuU3RyaW5nLm1heGxlbmd0aCA9ICdQYXRoIGB7UEFUSH1gIChge1ZBTFVFfWApIGlzIGxvbmdlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoICh7TUFYTEVOR1RIfSkuJztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/messages.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/missingSchema.js":
/*!******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/missingSchema.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\nclass MissingSchemaError extends MongooseError {\n  /**\n   * MissingSchema Error constructor.\n   * @param {String} name\n   * @api private\n   */\n  constructor(name) {\n    const msg = 'Schema hasn\\'t been registered for model \"' + name + '\".\\n'\n            + 'Use mongoose.model(name, schema)';\n    super(msg);\n  }\n}\n\nObject.defineProperty(MissingSchemaError.prototype, 'name', {\n  value: 'MissingSchemaError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = MissingSchemaError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvbWlzc2luZ1NjaGVtYS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLG9FQUFJOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxlcnJvclxcbWlzc2luZ1NjaGVtYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5jbGFzcyBNaXNzaW5nU2NoZW1hRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIE1pc3NpbmdTY2hlbWEgRXJyb3IgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIGNvbnN0IG1zZyA9ICdTY2hlbWEgaGFzblxcJ3QgYmVlbiByZWdpc3RlcmVkIGZvciBtb2RlbCBcIicgKyBuYW1lICsgJ1wiLlxcbidcbiAgICAgICAgICAgICsgJ1VzZSBtb25nb29zZS5tb2RlbChuYW1lLCBzY2hlbWEpJztcbiAgICBzdXBlcihtc2cpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNaXNzaW5nU2NoZW1hRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdNaXNzaW5nU2NoZW1hRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNaXNzaW5nU2NoZW1hRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/missingSchema.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/mongooseError.js":
/*!******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/mongooseError.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nclass MongooseError extends Error { }\n\nObject.defineProperty(MongooseError.prototype, 'name', {\n  value: 'MongooseError'\n});\n\nmodule.exports = MongooseError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvbW9uZ29vc2VFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxlcnJvclxcbW9uZ29vc2VFcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY2xhc3MgTW9uZ29vc2VFcnJvciBleHRlbmRzIEVycm9yIHsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ01vbmdvb3NlRXJyb3InXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb25nb29zZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/notFound.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/notFound.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nclass DocumentNotFoundError extends MongooseError {\n  /**\n   * OverwriteModel Error constructor.\n   * @api private\n   */\n  constructor(filter, model, numAffected, result) {\n    let msg;\n    const messages = MongooseError.messages;\n    if (messages.DocumentNotFoundError != null) {\n      msg = typeof messages.DocumentNotFoundError === 'function' ?\n        messages.DocumentNotFoundError(filter, model) :\n        messages.DocumentNotFoundError;\n    } else {\n      msg = 'No document found for query \"' + util.inspect(filter) +\n        '\" on model \"' + model + '\"';\n    }\n\n    super(msg);\n\n    this.result = result;\n    this.numAffected = numAffected;\n    this.filter = filter;\n    // Backwards compat\n    this.query = filter;\n  }\n}\n\nObject.defineProperty(DocumentNotFoundError.prototype, 'name', {\n  value: 'DocumentNotFoundError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = DocumentNotFoundError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivbm90Rm91bmQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLG9FQUFJO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxlcnJvclxcbm90Rm91bmQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jbGFzcyBEb2N1bWVudE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIE92ZXJ3cml0ZU1vZGVsIEVycm9yIGNvbnN0cnVjdG9yLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGZpbHRlciwgbW9kZWwsIG51bUFmZmVjdGVkLCByZXN1bHQpIHtcbiAgICBsZXQgbXNnO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gTW9uZ29vc2VFcnJvci5tZXNzYWdlcztcbiAgICBpZiAobWVzc2FnZXMuRG9jdW1lbnROb3RGb3VuZEVycm9yICE9IG51bGwpIHtcbiAgICAgIG1zZyA9IHR5cGVvZiBtZXNzYWdlcy5Eb2N1bWVudE5vdEZvdW5kRXJyb3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBtZXNzYWdlcy5Eb2N1bWVudE5vdEZvdW5kRXJyb3IoZmlsdGVyLCBtb2RlbCkgOlxuICAgICAgICBtZXNzYWdlcy5Eb2N1bWVudE5vdEZvdW5kRXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1zZyA9ICdObyBkb2N1bWVudCBmb3VuZCBmb3IgcXVlcnkgXCInICsgdXRpbC5pbnNwZWN0KGZpbHRlcikgK1xuICAgICAgICAnXCIgb24gbW9kZWwgXCInICsgbW9kZWwgKyAnXCInO1xuICAgIH1cblxuICAgIHN1cGVyKG1zZyk7XG5cbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB0aGlzLm51bUFmZmVjdGVkID0gbnVtQWZmZWN0ZWQ7XG4gICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdFxuICAgIHRoaXMucXVlcnkgPSBmaWx0ZXI7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY3VtZW50Tm90Rm91bmRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ0RvY3VtZW50Tm90Rm91bmRFcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50Tm90Rm91bmRFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/notFound.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/objectExpected.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/objectExpected.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\n\nclass ObjectExpectedError extends MongooseError {\n  /**\n   * Strict mode error constructor\n   *\n   * @param {string} type\n   * @param {string} value\n   * @api private\n   */\n  constructor(path, val) {\n    const typeDescription = Array.isArray(val) ? 'array' : 'primitive value';\n    super('Tried to set nested object field `' + path +\n      `\\` to ${typeDescription} \\`` + val + '`');\n    this.path = path;\n  }\n}\n\nObject.defineProperty(ObjectExpectedError.prototype, 'name', {\n  value: 'ObjectExpectedError'\n});\n\nmodule.exports = ObjectExpectedError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivb2JqZWN0RXhwZWN0ZWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLG9FQUFJOzs7QUFHbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxlcnJvclxcb2JqZWN0RXhwZWN0ZWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cblxuY2xhc3MgT2JqZWN0RXhwZWN0ZWRFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogU3RyaWN0IG1vZGUgZXJyb3IgY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocGF0aCwgdmFsKSB7XG4gICAgY29uc3QgdHlwZURlc2NyaXB0aW9uID0gQXJyYXkuaXNBcnJheSh2YWwpID8gJ2FycmF5JyA6ICdwcmltaXRpdmUgdmFsdWUnO1xuICAgIHN1cGVyKCdUcmllZCB0byBzZXQgbmVzdGVkIG9iamVjdCBmaWVsZCBgJyArIHBhdGggK1xuICAgICAgYFxcYCB0byAke3R5cGVEZXNjcmlwdGlvbn0gXFxgYCArIHZhbCArICdgJyk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0RXhwZWN0ZWRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ09iamVjdEV4cGVjdGVkRXJyb3InXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RFeHBlY3RlZEVycm9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/objectExpected.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/objectParameter.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/objectParameter.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\nclass ObjectParameterError extends MongooseError {\n  /**\n   * Constructor for errors that happen when a parameter that's expected to be\n   * an object isn't an object\n   *\n   * @param {Any} value\n   * @param {String} paramName\n   * @param {String} fnName\n   * @api private\n   */\n  constructor(value, paramName, fnName) {\n    super('Parameter \"' + paramName + '\" to ' + fnName +\n      '() must be an object, got \"' + value.toString() + '\" (type ' + typeof value + ')');\n  }\n}\n\n\nObject.defineProperty(ObjectParameterError.prototype, 'name', {\n  value: 'ObjectParameterError'\n});\n\nmodule.exports = ObjectParameterError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivb2JqZWN0UGFyYW1ldGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxvRUFBSTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGVycm9yXFxvYmplY3RQYXJhbWV0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cbmNsYXNzIE9iamVjdFBhcmFtZXRlckVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgZXJyb3JzIHRoYXQgaGFwcGVuIHdoZW4gYSBwYXJhbWV0ZXIgdGhhdCdzIGV4cGVjdGVkIHRvIGJlXG4gICAqIGFuIG9iamVjdCBpc24ndCBhbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbU5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZuTmFtZVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBwYXJhbU5hbWUsIGZuTmFtZSkge1xuICAgIHN1cGVyKCdQYXJhbWV0ZXIgXCInICsgcGFyYW1OYW1lICsgJ1wiIHRvICcgKyBmbk5hbWUgK1xuICAgICAgJygpIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgXCInICsgdmFsdWUudG9TdHJpbmcoKSArICdcIiAodHlwZSAnICsgdHlwZW9mIHZhbHVlICsgJyknKTtcbiAgfVxufVxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3RQYXJhbWV0ZXJFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ09iamVjdFBhcmFtZXRlckVycm9yJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0UGFyYW1ldGVyRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/objectParameter.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/overwriteModel.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/overwriteModel.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\n\nclass OverwriteModelError extends MongooseError {\n  /**\n   * OverwriteModel Error constructor.\n   * @param {String} name\n   * @api private\n   */\n  constructor(name) {\n    super('Cannot overwrite `' + name + '` model once compiled.');\n  }\n}\n\nObject.defineProperty(OverwriteModelError.prototype, 'name', {\n  value: 'OverwriteModelError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = OverwriteModelError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivb3ZlcndyaXRlTW9kZWwuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxvRUFBSTs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcZXJyb3JcXG92ZXJ3cml0ZU1vZGVsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cblxuY2xhc3MgT3ZlcndyaXRlTW9kZWxFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogT3ZlcndyaXRlTW9kZWwgRXJyb3IgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHN1cGVyKCdDYW5ub3Qgb3ZlcndyaXRlIGAnICsgbmFtZSArICdgIG1vZGVsIG9uY2UgY29tcGlsZWQuJyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE92ZXJ3cml0ZU1vZGVsRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdPdmVyd3JpdGVNb2RlbEVycm9yJ1xufSk7XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT3ZlcndyaXRlTW9kZWxFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/overwriteModel.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/parallelSave.js":
/*!*****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/parallelSave.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\nclass ParallelSaveError extends MongooseError {\n  /**\n   * ParallelSave Error constructor.\n   *\n   * @param {Document} doc\n   * @api private\n   */\n  constructor(doc) {\n    const msg = 'Can\\'t save() the same doc multiple times in parallel. Document: ';\n    super(msg + doc._id);\n  }\n}\n\nObject.defineProperty(ParallelSaveError.prototype, 'name', {\n  value: 'ParallelSaveError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = ParallelSaveError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvcGFyYWxsZWxTYXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQU8sQ0FBQyxvRUFBSTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcZXJyb3JcXHBhcmFsbGVsU2F2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuY2xhc3MgUGFyYWxsZWxTYXZlRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIFBhcmFsbGVsU2F2ZSBFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgY29uc3QgbXNnID0gJ0NhblxcJ3Qgc2F2ZSgpIHRoZSBzYW1lIGRvYyBtdWx0aXBsZSB0aW1lcyBpbiBwYXJhbGxlbC4gRG9jdW1lbnQ6ICc7XG4gICAgc3VwZXIobXNnICsgZG9jLl9pZCk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcmFsbGVsU2F2ZUVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnUGFyYWxsZWxTYXZlRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbGxlbFNhdmVFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/parallelSave.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/parallelValidate.js":
/*!*********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/parallelValidate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\n\n\nclass ParallelValidateError extends MongooseError {\n  /**\n   * ParallelValidate Error constructor.\n   *\n   * @param {Document} doc\n   * @api private\n   */\n  constructor(doc) {\n    const msg = 'Can\\'t validate() the same doc multiple times in parallel. Document: ';\n    super(msg + doc._id);\n  }\n}\n\nObject.defineProperty(ParallelValidateError.prototype, 'name', {\n  value: 'ParallelValidateError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = ParallelValidateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvcGFyYWxsZWxWYWxpZGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMseUZBQWlCOzs7QUFHL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcZXJyb3JcXHBhcmFsbGVsVmFsaWRhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vbW9uZ29vc2VFcnJvcicpO1xuXG5cbmNsYXNzIFBhcmFsbGVsVmFsaWRhdGVFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogUGFyYWxsZWxWYWxpZGF0ZSBFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgY29uc3QgbXNnID0gJ0NhblxcJ3QgdmFsaWRhdGUoKSB0aGUgc2FtZSBkb2MgbXVsdGlwbGUgdGltZXMgaW4gcGFyYWxsZWwuIERvY3VtZW50OiAnO1xuICAgIHN1cGVyKG1zZyArIGRvYy5faWQpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXJhbGxlbFZhbGlkYXRlRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdQYXJhbGxlbFZhbGlkYXRlRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbGxlbFZhbGlkYXRlRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/parallelValidate.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/serverSelection.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/serverSelection.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst allServersUnknown = __webpack_require__(/*! ../helpers/topology/allServersUnknown */ \"(api)/../server/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js\");\nconst isAtlas = __webpack_require__(/*! ../helpers/topology/isAtlas */ \"(api)/../server/node_modules/mongoose/lib/helpers/topology/isAtlas.js\");\nconst isSSLError = __webpack_require__(/*! ../helpers/topology/isSSLError */ \"(api)/../server/node_modules/mongoose/lib/helpers/topology/isSSLError.js\");\n\n/*!\n * ignore\n */\n\nconst atlasMessage = 'Could not connect to any servers in your MongoDB Atlas cluster. ' +\n  'One common reason is that you\\'re trying to access the database from ' +\n  'an IP that isn\\'t whitelisted. Make sure your current IP address is on your Atlas ' +\n  'cluster\\'s IP whitelist: https://www.mongodb.com/docs/atlas/security-whitelist/';\n\nconst sslMessage = 'Mongoose is connecting with SSL enabled, but the server is ' +\n  'not accepting SSL connections. Please ensure that the MongoDB server you are ' +\n  'connecting to is configured to accept SSL connections. Learn more: ' +\n  'https://mongoosejs.com/docs/tutorials/ssl.html';\n\nclass MongooseServerSelectionError extends MongooseError {\n  /**\n   * MongooseServerSelectionError constructor\n   *\n   * @api private\n   */\n  assimilateError(err) {\n    const reason = err.reason;\n    // Special message for a case that is likely due to IP whitelisting issues.\n    const isAtlasWhitelistError = isAtlas(reason) &&\n      allServersUnknown(reason) &&\n      err.message.indexOf('bad auth') === -1 &&\n      err.message.indexOf('Authentication failed') === -1;\n\n    if (isAtlasWhitelistError) {\n      this.message = atlasMessage;\n    } else if (isSSLError(reason)) {\n      this.message = sslMessage;\n    } else {\n      this.message = err.message;\n    }\n    for (const key in err) {\n      if (key !== 'name') {\n        this[key] = err[key];\n      }\n    }\n\n    return this;\n  }\n}\n\nObject.defineProperty(MongooseServerSelectionError.prototype, 'name', {\n  value: 'MongooseServerSelectionError'\n});\n\nmodule.exports = MongooseServerSelectionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc2VydmVyU2VsZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyx5RkFBaUI7QUFDL0MsMEJBQTBCLG1CQUFPLENBQUMsOEhBQXVDO0FBQ3pFLGdCQUFnQixtQkFBTyxDQUFDLDBHQUE2QjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQyxnSEFBZ0M7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGVycm9yXFxzZXJ2ZXJTZWxlY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgYWxsU2VydmVyc1Vua25vd24gPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RvcG9sb2d5L2FsbFNlcnZlcnNVbmtub3duJyk7XG5jb25zdCBpc0F0bGFzID0gcmVxdWlyZSgnLi4vaGVscGVycy90b3BvbG9neS9pc0F0bGFzJyk7XG5jb25zdCBpc1NTTEVycm9yID0gcmVxdWlyZSgnLi4vaGVscGVycy90b3BvbG9neS9pc1NTTEVycm9yJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3QgYXRsYXNNZXNzYWdlID0gJ0NvdWxkIG5vdCBjb25uZWN0IHRvIGFueSBzZXJ2ZXJzIGluIHlvdXIgTW9uZ29EQiBBdGxhcyBjbHVzdGVyLiAnICtcbiAgJ09uZSBjb21tb24gcmVhc29uIGlzIHRoYXQgeW91XFwncmUgdHJ5aW5nIHRvIGFjY2VzcyB0aGUgZGF0YWJhc2UgZnJvbSAnICtcbiAgJ2FuIElQIHRoYXQgaXNuXFwndCB3aGl0ZWxpc3RlZC4gTWFrZSBzdXJlIHlvdXIgY3VycmVudCBJUCBhZGRyZXNzIGlzIG9uIHlvdXIgQXRsYXMgJyArXG4gICdjbHVzdGVyXFwncyBJUCB3aGl0ZWxpc3Q6IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvYXRsYXMvc2VjdXJpdHktd2hpdGVsaXN0Lyc7XG5cbmNvbnN0IHNzbE1lc3NhZ2UgPSAnTW9uZ29vc2UgaXMgY29ubmVjdGluZyB3aXRoIFNTTCBlbmFibGVkLCBidXQgdGhlIHNlcnZlciBpcyAnICtcbiAgJ25vdCBhY2NlcHRpbmcgU1NMIGNvbm5lY3Rpb25zLiBQbGVhc2UgZW5zdXJlIHRoYXQgdGhlIE1vbmdvREIgc2VydmVyIHlvdSBhcmUgJyArXG4gICdjb25uZWN0aW5nIHRvIGlzIGNvbmZpZ3VyZWQgdG8gYWNjZXB0IFNTTCBjb25uZWN0aW9ucy4gTGVhcm4gbW9yZTogJyArXG4gICdodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL3NzbC5odG1sJztcblxuY2xhc3MgTW9uZ29vc2VTZXJ2ZXJTZWxlY3Rpb25FcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogTW9uZ29vc2VTZXJ2ZXJTZWxlY3Rpb25FcnJvciBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFzc2ltaWxhdGVFcnJvcihlcnIpIHtcbiAgICBjb25zdCByZWFzb24gPSBlcnIucmVhc29uO1xuICAgIC8vIFNwZWNpYWwgbWVzc2FnZSBmb3IgYSBjYXNlIHRoYXQgaXMgbGlrZWx5IGR1ZSB0byBJUCB3aGl0ZWxpc3RpbmcgaXNzdWVzLlxuICAgIGNvbnN0IGlzQXRsYXNXaGl0ZWxpc3RFcnJvciA9IGlzQXRsYXMocmVhc29uKSAmJlxuICAgICAgYWxsU2VydmVyc1Vua25vd24ocmVhc29uKSAmJlxuICAgICAgZXJyLm1lc3NhZ2UuaW5kZXhPZignYmFkIGF1dGgnKSA9PT0gLTEgJiZcbiAgICAgIGVyci5tZXNzYWdlLmluZGV4T2YoJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpID09PSAtMTtcblxuICAgIGlmIChpc0F0bGFzV2hpdGVsaXN0RXJyb3IpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IGF0bGFzTWVzc2FnZTtcbiAgICB9IGVsc2UgaWYgKGlzU1NMRXJyb3IocmVhc29uKSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gc3NsTWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGVycikge1xuICAgICAgaWYgKGtleSAhPT0gJ25hbWUnKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IGVycltrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZVNlcnZlclNlbGVjdGlvbkVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnTW9uZ29vc2VTZXJ2ZXJTZWxlY3Rpb25FcnJvcidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbmdvb3NlU2VydmVyU2VsZWN0aW9uRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/serverSelection.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/setOptionError.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/setOptionError.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst combinePathErrors = __webpack_require__(/*! ../helpers/error/combinePathErrors */ \"(api)/../server/node_modules/mongoose/lib/helpers/error/combinePathErrors.js\");\n\nclass SetOptionError extends MongooseError {\n  /**\n   * Mongoose.set Error\n   *\n   * @api private\n   * @inherits MongooseError\n   */\n  constructor() {\n    super('');\n\n    this.errors = {};\n  }\n\n  /**\n   * Console.log helper\n   */\n  toString() {\n    return combinePathErrors(this);\n  }\n\n  /**\n   * inspect helper\n   * @api private\n   */\n  inspect() {\n    return Object.assign(new Error(this.message), this);\n  }\n\n  /**\n  * add message\n  * @param {String} key\n  * @param {String|Error} error\n  * @api private\n  */\n  addError(key, error) {\n    if (error instanceof SetOptionError) {\n      const { errors } = error;\n      for (const optionKey of Object.keys(errors)) {\n        this.addError(optionKey, errors[optionKey]);\n      }\n\n      return;\n    }\n\n    this.errors[key] = error;\n    this.message = combinePathErrors(this);\n  }\n}\n\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  SetOptionError.prototype[util.inspect.custom] = SetOptionError.prototype.inspect;\n}\n\n/**\n * Helper for JSON.stringify\n * Ensure `name` and `message` show up in toJSON output re: gh-9847\n * @api private\n */\nObject.defineProperty(SetOptionError.prototype, 'toJSON', {\n  enumerable: false,\n  writable: false,\n  configurable: true,\n  value: function() {\n    return Object.assign({}, this, { name: this.name, message: this.message });\n  }\n});\n\n\nObject.defineProperty(SetOptionError.prototype, 'name', {\n  value: 'SetOptionError'\n});\n\nclass SetOptionInnerError extends MongooseError {\n  /**\n   * Error for the \"errors\" array in \"SetOptionError\" with consistent message\n   * @param {String} key\n   */\n  constructor(key) {\n    super(`\"${key}\" is not a valid option to set`);\n  }\n}\n\nSetOptionError.SetOptionInnerError = SetOptionInnerError;\n\n/*!\n * Module exports\n */\n\nmodule.exports = SetOptionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc2V0T3B0aW9uRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLHlGQUFpQjtBQUMvQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsd0hBQW9DOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsd0NBQXdDO0FBQzdFO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxlcnJvclxcc2V0T3B0aW9uRXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgY29tYmluZVBhdGhFcnJvcnMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Vycm9yL2NvbWJpbmVQYXRoRXJyb3JzJyk7XG5cbmNsYXNzIFNldE9wdGlvbkVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBNb25nb29zZS5zZXQgRXJyb3JcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBpbmhlcml0cyBNb25nb29zZUVycm9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignJyk7XG5cbiAgICB0aGlzLmVycm9ycyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnNvbGUubG9nIGhlbHBlclxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVQYXRoRXJyb3JzKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGluc3BlY3QgaGVscGVyXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaW5zcGVjdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IodGhpcy5tZXNzYWdlKSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgKiBhZGQgbWVzc2FnZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgKiBAcGFyYW0ge1N0cmluZ3xFcnJvcn0gZXJyb3JcbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cbiAgYWRkRXJyb3Ioa2V5LCBlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFNldE9wdGlvbkVycm9yKSB7XG4gICAgICBjb25zdCB7IGVycm9ycyB9ID0gZXJyb3I7XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbktleSBvZiBPYmplY3Qua2V5cyhlcnJvcnMpKSB7XG4gICAgICAgIHRoaXMuYWRkRXJyb3Iob3B0aW9uS2V5LCBlcnJvcnNbb3B0aW9uS2V5XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVycm9yc1trZXldID0gZXJyb3I7XG4gICAgdGhpcy5tZXNzYWdlID0gY29tYmluZVBhdGhFcnJvcnModGhpcyk7XG4gIH1cbn1cblxuXG5pZiAodXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICAvLyBBdm9pZCBOb2RlIGRlcHJlY2F0aW9uIHdhcm5pbmcgREVQMDA3OVxuICBTZXRPcHRpb25FcnJvci5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBTZXRPcHRpb25FcnJvci5wcm90b3R5cGUuaW5zcGVjdDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIEpTT04uc3RyaW5naWZ5XG4gKiBFbnN1cmUgYG5hbWVgIGFuZCBgbWVzc2FnZWAgc2hvdyB1cCBpbiB0b0pTT04gb3V0cHV0IHJlOiBnaC05ODQ3XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldE9wdGlvbkVycm9yLnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMsIHsgbmFtZTogdGhpcy5uYW1lLCBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UgfSk7XG4gIH1cbn0pO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXRPcHRpb25FcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1NldE9wdGlvbkVycm9yJ1xufSk7XG5cbmNsYXNzIFNldE9wdGlvbklubmVyRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIEVycm9yIGZvciB0aGUgXCJlcnJvcnNcIiBhcnJheSBpbiBcIlNldE9wdGlvbkVycm9yXCIgd2l0aCBjb25zaXN0ZW50IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoYFwiJHtrZXl9XCIgaXMgbm90IGEgdmFsaWQgb3B0aW9uIHRvIHNldGApO1xuICB9XG59XG5cblNldE9wdGlvbkVycm9yLlNldE9wdGlvbklubmVyRXJyb3IgPSBTZXRPcHRpb25Jbm5lckVycm9yO1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTZXRPcHRpb25FcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/setOptionError.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/strict.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/strict.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\n\nclass StrictModeError extends MongooseError {\n  /**\n   * Strict mode error constructor\n   *\n   * @param {String} path\n   * @param {String} [msg]\n   * @param {Boolean} [immutable]\n   * @inherits MongooseError\n   * @api private\n   */\n  constructor(path, msg, immutable) {\n    msg = msg || 'Field `' + path + '` is not in schema and strict ' +\n      'mode is set to throw.';\n    super(msg);\n    this.isImmutableError = !!immutable;\n    this.path = path;\n  }\n}\n\nObject.defineProperty(StrictModeError.prototype, 'name', {\n  value: 'StrictModeError'\n});\n\nmodule.exports = StrictModeError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc3RyaWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxvRUFBSTs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGVycm9yXFxzdHJpY3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cblxuY2xhc3MgU3RyaWN0TW9kZUVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBTdHJpY3QgbW9kZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW21zZ11cbiAgICogQHBhcmFtIHtCb29sZWFufSBbaW1tdXRhYmxlXVxuICAgKiBAaW5oZXJpdHMgTW9uZ29vc2VFcnJvclxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhdGgsIG1zZywgaW1tdXRhYmxlKSB7XG4gICAgbXNnID0gbXNnIHx8ICdGaWVsZCBgJyArIHBhdGggKyAnYCBpcyBub3QgaW4gc2NoZW1hIGFuZCBzdHJpY3QgJyArXG4gICAgICAnbW9kZSBpcyBzZXQgdG8gdGhyb3cuJztcbiAgICBzdXBlcihtc2cpO1xuICAgIHRoaXMuaXNJbW11dGFibGVFcnJvciA9ICEhaW1tdXRhYmxlO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmljdE1vZGVFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1N0cmljdE1vZGVFcnJvcidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmljdE1vZGVFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/strict.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/strictPopulate.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/strictPopulate.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\nclass StrictPopulateError extends MongooseError {\n  /**\n   * Strict mode error constructor\n   *\n   * @param {String} path\n   * @param {String} [msg]\n   * @inherits MongooseError\n   * @api private\n   */\n  constructor(path, msg) {\n    msg = msg || 'Cannot populate path `' + path + '` because it is not in your schema. ' + 'Set the `strictPopulate` option to false to override.';\n    super(msg);\n    this.path = path;\n  }\n}\n\nObject.defineProperty(StrictPopulateError.prototype, 'name', {\n  value: 'StrictPopulateError'\n});\n\nmodule.exports = StrictPopulateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc3RyaWN0UG9wdWxhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLG9FQUFJOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcZXJyb3JcXHN0cmljdFBvcHVsYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5jbGFzcyBTdHJpY3RQb3B1bGF0ZUVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBTdHJpY3QgbW9kZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW21zZ11cbiAgICogQGluaGVyaXRzIE1vbmdvb3NlRXJyb3JcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXRoLCBtc2cpIHtcbiAgICBtc2cgPSBtc2cgfHwgJ0Nhbm5vdCBwb3B1bGF0ZSBwYXRoIGAnICsgcGF0aCArICdgIGJlY2F1c2UgaXQgaXMgbm90IGluIHlvdXIgc2NoZW1hLiAnICsgJ1NldCB0aGUgYHN0cmljdFBvcHVsYXRlYCBvcHRpb24gdG8gZmFsc2UgdG8gb3ZlcnJpZGUuJztcbiAgICBzdXBlcihtc2cpO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmljdFBvcHVsYXRlRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdTdHJpY3RQb3B1bGF0ZUVycm9yJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaWN0UG9wdWxhdGVFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/strictPopulate.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/syncIndexes.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/syncIndexes.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * SyncIndexes Error constructor.\n *\n * @param {String} message\n * @param {String} errorsMap\n * @inherits MongooseError\n * @api private\n */\n\nclass SyncIndexesError extends MongooseError {\n  constructor(message, errorsMap) {\n    super(message);\n    this.errors = errorsMap;\n  }\n}\n\nObject.defineProperty(SyncIndexesError.prototype, 'name', {\n  value: 'SyncIndexesError'\n});\n\n\nmodule.exports = SyncIndexesError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc3luY0luZGV4ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLHlGQUFpQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGVycm9yXFxzeW5jSW5kZXhlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5cbi8qKlxuICogU3luY0luZGV4ZXMgRXJyb3IgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvcnNNYXBcbiAqIEBpbmhlcml0cyBNb25nb29zZUVycm9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jbGFzcyBTeW5jSW5kZXhlc0Vycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yc01hcCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzTWFwO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTeW5jSW5kZXhlc0Vycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnU3luY0luZGV4ZXNFcnJvcidcbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3luY0luZGV4ZXNFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/syncIndexes.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/validation.js":
/*!***************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/validation.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst combinePathErrors = __webpack_require__(/*! ../helpers/error/combinePathErrors */ \"(api)/../server/node_modules/mongoose/lib/helpers/error/combinePathErrors.js\");\n\nclass ValidationError extends MongooseError {\n  /**\n   * Document Validation Error\n   *\n   * @api private\n   * @param {Document} [instance]\n   * @inherits MongooseError\n   */\n  constructor(instance) {\n    let _message;\n    if (getConstructorName(instance) === 'model') {\n      _message = instance.constructor.modelName + ' validation failed';\n    } else {\n      _message = 'Validation failed';\n    }\n\n    super(_message);\n\n    this.errors = {};\n    this._message = _message;\n\n    if (instance) {\n      instance.$errors = this.errors;\n    }\n  }\n\n  /**\n   * Console.log helper\n   */\n  toString() {\n    return this.name + ': ' + combinePathErrors(this);\n  }\n\n  /**\n   * inspect helper\n   * @api private\n   */\n  inspect() {\n    return Object.assign(new Error(this.message), this);\n  }\n\n  /**\n  * add message\n  * @param {String} path\n  * @param {String|Error} error\n  * @api private\n  */\n  addError(path, error) {\n    if (error instanceof ValidationError) {\n      const { errors } = error;\n      for (const errorPath of Object.keys(errors)) {\n        this.addError(`${path}.${errorPath}`, errors[errorPath]);\n      }\n\n      return;\n    }\n\n    this.errors[path] = error;\n    this.message = this._message + ': ' + combinePathErrors(this);\n  }\n}\n\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  ValidationError.prototype[util.inspect.custom] = ValidationError.prototype.inspect;\n}\n\n/**\n * Helper for JSON.stringify\n * Ensure `name` and `message` show up in toJSON output re: gh-9847\n * @api private\n */\nObject.defineProperty(ValidationError.prototype, 'toJSON', {\n  enumerable: false,\n  writable: false,\n  configurable: true,\n  value: function() {\n    return Object.assign({}, this, { name: this.name, message: this.message });\n  }\n});\n\n\nObject.defineProperty(ValidationError.prototype, 'name', {\n  value: 'ValidationError'\n});\n\n/*!\n * Module exports\n */\n\nmodule.exports = ValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvdmFsaWRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMseUZBQWlCO0FBQy9DLDJCQUEyQixtQkFBTyxDQUFDLDhHQUErQjtBQUNsRSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsd0hBQW9DOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EseUJBQXlCLEtBQUssR0FBRyxVQUFVO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsd0NBQXdDO0FBQzdFO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcZXJyb3JcXHZhbGlkYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2dldENvbnN0cnVjdG9yTmFtZScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGNvbWJpbmVQYXRoRXJyb3JzID0gcmVxdWlyZSgnLi4vaGVscGVycy9lcnJvci9jb21iaW5lUGF0aEVycm9ycycpO1xuXG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIERvY3VtZW50IFZhbGlkYXRpb24gRXJyb3JcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtpbnN0YW5jZV1cbiAgICogQGluaGVyaXRzIE1vbmdvb3NlRXJyb3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKGluc3RhbmNlKSB7XG4gICAgbGV0IF9tZXNzYWdlO1xuICAgIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUoaW5zdGFuY2UpID09PSAnbW9kZWwnKSB7XG4gICAgICBfbWVzc2FnZSA9IGluc3RhbmNlLmNvbnN0cnVjdG9yLm1vZGVsTmFtZSArICcgdmFsaWRhdGlvbiBmYWlsZWQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBfbWVzc2FnZSA9ICdWYWxpZGF0aW9uIGZhaWxlZCc7XG4gICAgfVxuXG4gICAgc3VwZXIoX21lc3NhZ2UpO1xuXG4gICAgdGhpcy5lcnJvcnMgPSB7fTtcbiAgICB0aGlzLl9tZXNzYWdlID0gX21lc3NhZ2U7XG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGluc3RhbmNlLiRlcnJvcnMgPSB0aGlzLmVycm9ycztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc29sZS5sb2cgaGVscGVyXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIGNvbWJpbmVQYXRoRXJyb3JzKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGluc3BlY3QgaGVscGVyXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaW5zcGVjdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IodGhpcy5tZXNzYWdlKSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgKiBhZGQgbWVzc2FnZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICogQHBhcmFtIHtTdHJpbmd8RXJyb3J9IGVycm9yXG4gICogQGFwaSBwcml2YXRlXG4gICovXG4gIGFkZEVycm9yKHBhdGgsIGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICBjb25zdCB7IGVycm9ycyB9ID0gZXJyb3I7XG4gICAgICBmb3IgKGNvbnN0IGVycm9yUGF0aCBvZiBPYmplY3Qua2V5cyhlcnJvcnMpKSB7XG4gICAgICAgIHRoaXMuYWRkRXJyb3IoYCR7cGF0aH0uJHtlcnJvclBhdGh9YCwgZXJyb3JzW2Vycm9yUGF0aF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lcnJvcnNbcGF0aF0gPSBlcnJvcjtcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLl9tZXNzYWdlICsgJzogJyArIGNvbWJpbmVQYXRoRXJyb3JzKHRoaXMpO1xuICB9XG59XG5cblxuaWYgKHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgLy8gQXZvaWQgTm9kZSBkZXByZWNhdGlvbiB3YXJuaW5nIERFUDAwNzlcbiAgVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IFZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUuaW5zcGVjdDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIEpTT04uc3RyaW5naWZ5XG4gKiBFbnN1cmUgYG5hbWVgIGFuZCBgbWVzc2FnZWAgc2hvdyB1cCBpbiB0b0pTT04gb3V0cHV0IHJlOiBnaC05ODQ3XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUsICd0b0pTT04nLCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLCB7IG5hbWU6IHRoaXMubmFtZSwgbWVzc2FnZTogdGhpcy5tZXNzYWdlIH0pO1xuICB9XG59KTtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVmFsaWRhdGlvbkVycm9yJ1xufSk7XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRpb25FcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/validation.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/validator.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/validator.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\n\nclass ValidatorError extends MongooseError {\n  /**\n   * Schema validator error\n   *\n   * @param {Object} properties\n   * @param {Document} doc\n   * @api private\n   */\n  constructor(properties, doc) {\n    let msg = properties.message;\n    if (!msg) {\n      msg = MongooseError.messages.general.default;\n    }\n\n    const message = formatMessage(msg, properties, doc);\n    super(message);\n\n    properties = Object.assign({}, properties, { message: message });\n    this.properties = properties;\n    this.kind = properties.type;\n    this.path = properties.path;\n    this.value = properties.value;\n    this.reason = properties.reason;\n  }\n\n  /**\n   * toString helper\n   * TODO remove? This defaults to `${this.name}: ${this.message}`\n   * @api private\n   */\n  toString() {\n    return this.message;\n  }\n\n  /**\n   * Ensure `name` and `message` show up in toJSON output re: gh-9296\n   * @api private\n   */\n\n  toJSON() {\n    return Object.assign({ name: this.name, message: this.message }, this);\n  }\n}\n\n\nObject.defineProperty(ValidatorError.prototype, 'name', {\n  value: 'ValidatorError'\n});\n\n/**\n * The object used to define this validator. Not enumerable to hide\n * it from `require('util').inspect()` output re: gh-3925\n * @api private\n */\n\nObject.defineProperty(ValidatorError.prototype, 'properties', {\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n// Exposed for testing\nValidatorError.prototype.formatMessage = formatMessage;\n\n/**\n * Formats error messages\n * @api private\n */\n\nfunction formatMessage(msg, properties, doc) {\n  if (typeof msg === 'function') {\n    return msg(properties, doc);\n  }\n\n  const propertyNames = Object.keys(properties);\n  for (const propertyName of propertyNames) {\n    if (propertyName === 'message') {\n      continue;\n    }\n    msg = msg.replace('{' + propertyName.toUpperCase() + '}', properties[propertyName]);\n  }\n\n  return msg;\n}\n\n/*!\n * exports\n */\n\nmodule.exports = ValidatorError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvdmFsaWRhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxvRUFBSTs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQyxnQkFBZ0Isa0JBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsSUFBSSxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsd0NBQXdDO0FBQ25FO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQ0FBbUM7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxlcnJvclxcdmFsaWRhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5cbmNsYXNzIFZhbGlkYXRvckVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBTY2hlbWEgdmFsaWRhdG9yIGVycm9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMsIGRvYykge1xuICAgIGxldCBtc2cgPSBwcm9wZXJ0aWVzLm1lc3NhZ2U7XG4gICAgaWYgKCFtc2cpIHtcbiAgICAgIG1zZyA9IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuZ2VuZXJhbC5kZWZhdWx0O1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2UgPSBmb3JtYXRNZXNzYWdlKG1zZywgcHJvcGVydGllcywgZG9jKTtcbiAgICBzdXBlcihtZXNzYWdlKTtcblxuICAgIHByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wZXJ0aWVzLCB7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICB0aGlzLmtpbmQgPSBwcm9wZXJ0aWVzLnR5cGU7XG4gICAgdGhpcy5wYXRoID0gcHJvcGVydGllcy5wYXRoO1xuICAgIHRoaXMudmFsdWUgPSBwcm9wZXJ0aWVzLnZhbHVlO1xuICAgIHRoaXMucmVhc29uID0gcHJvcGVydGllcy5yZWFzb247XG4gIH1cblxuICAvKipcbiAgICogdG9TdHJpbmcgaGVscGVyXG4gICAqIFRPRE8gcmVtb3ZlPyBUaGlzIGRlZmF1bHRzIHRvIGAke3RoaXMubmFtZX06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBgbmFtZWAgYW5kIGBtZXNzYWdlYCBzaG93IHVwIGluIHRvSlNPTiBvdXRwdXQgcmU6IGdoLTkyOTZcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IG5hbWU6IHRoaXMubmFtZSwgbWVzc2FnZTogdGhpcy5tZXNzYWdlIH0sIHRoaXMpO1xuICB9XG59XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbGlkYXRvckVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVmFsaWRhdG9yRXJyb3InXG59KTtcblxuLyoqXG4gKiBUaGUgb2JqZWN0IHVzZWQgdG8gZGVmaW5lIHRoaXMgdmFsaWRhdG9yLiBOb3QgZW51bWVyYWJsZSB0byBoaWRlXG4gKiBpdCBmcm9tIGByZXF1aXJlKCd1dGlsJykuaW5zcGVjdCgpYCBvdXRwdXQgcmU6IGdoLTM5MjVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWYWxpZGF0b3JFcnJvci5wcm90b3R5cGUsICdwcm9wZXJ0aWVzJywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlOiBudWxsXG59KTtcblxuLy8gRXhwb3NlZCBmb3IgdGVzdGluZ1xuVmFsaWRhdG9yRXJyb3IucHJvdG90eXBlLmZvcm1hdE1lc3NhZ2UgPSBmb3JtYXRNZXNzYWdlO1xuXG4vKipcbiAqIEZvcm1hdHMgZXJyb3IgbWVzc2FnZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UobXNnLCBwcm9wZXJ0aWVzLCBkb2MpIHtcbiAgaWYgKHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbXNnKHByb3BlcnRpZXMsIGRvYyk7XG4gIH1cblxuICBjb25zdCBwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIG9mIHByb3BlcnR5TmFtZXMpIHtcbiAgICBpZiAocHJvcGVydHlOYW1lID09PSAnbWVzc2FnZScpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBtc2cgPSBtc2cucmVwbGFjZSgneycgKyBwcm9wZXJ0eU5hbWUudG9VcHBlckNhc2UoKSArICd9JywgcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBtc2c7XG59XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdG9yRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/validator.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/error/version.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/error/version.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\nclass VersionError extends MongooseError {\n  /**\n   * Version Error constructor.\n   *\n   * @param {Document} doc\n   * @param {Number} currentVersion\n   * @param {Array<String>} modifiedPaths\n   * @api private\n   */\n  constructor(doc, currentVersion, modifiedPaths) {\n    const modifiedPathsStr = modifiedPaths.join(', ');\n    super('No matching document found for id \"' + doc._id +\n      '\" version ' + currentVersion + ' modifiedPaths \"' + modifiedPathsStr + '\"');\n    this.version = currentVersion;\n    this.modifiedPaths = modifiedPaths;\n  }\n}\n\n\nObject.defineProperty(VersionError.prototype, 'name', {\n  value: 'VersionError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = VersionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsb0VBQUk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGVycm9yXFx2ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5jbGFzcyBWZXJzaW9uRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIFZlcnNpb24gRXJyb3IgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICAgKiBAcGFyYW0ge051bWJlcn0gY3VycmVudFZlcnNpb25cbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBtb2RpZmllZFBhdGhzXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZG9jLCBjdXJyZW50VmVyc2lvbiwgbW9kaWZpZWRQYXRocykge1xuICAgIGNvbnN0IG1vZGlmaWVkUGF0aHNTdHIgPSBtb2RpZmllZFBhdGhzLmpvaW4oJywgJyk7XG4gICAgc3VwZXIoJ05vIG1hdGNoaW5nIGRvY3VtZW50IGZvdW5kIGZvciBpZCBcIicgKyBkb2MuX2lkICtcbiAgICAgICdcIiB2ZXJzaW9uICcgKyBjdXJyZW50VmVyc2lvbiArICcgbW9kaWZpZWRQYXRocyBcIicgKyBtb2RpZmllZFBhdGhzU3RyICsgJ1wiJyk7XG4gICAgdGhpcy52ZXJzaW9uID0gY3VycmVudFZlcnNpb247XG4gICAgdGhpcy5tb2RpZmllZFBhdGhzID0gbW9kaWZpZWRQYXRocztcbiAgfVxufVxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZXJzaW9uRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdWZXJzaW9uRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBWZXJzaW9uRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/error/version.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js":
/*!*********************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {\n  const discriminatorMapping = schema && schema.discriminatorMapping;\n  prefix = prefix || '';\n\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\n    const originalPipeline = pipeline;\n    const filterKey = (prefix.length > 0 ? prefix + '.' : prefix) + discriminatorMapping.key;\n    const discriminatorValue = discriminatorMapping.value;\n\n    // If the first pipeline stage is a match and it doesn't specify a `__t`\n    // key, add the discriminator key to it. This allows for potential\n    // aggregation query optimizations not to be disturbed by this feature.\n    if (originalPipeline[0] != null &&\n        originalPipeline[0].$match &&\n        (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {\n      originalPipeline[0].$match[filterKey] = discriminatorValue;\n      // `originalPipeline` is a ref, so there's no need for\n      // aggregate._pipeline = originalPipeline\n    } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {\n      originalPipeline[0].$geoNear.query =\n          originalPipeline[0].$geoNear.query || {};\n      originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;\n    } else if (originalPipeline[0] != null && originalPipeline[0].$search) {\n      if (originalPipeline[1] && originalPipeline[1].$match != null) {\n        originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;\n      } else {\n        const match = {};\n        match[filterKey] = discriminatorValue;\n        originalPipeline.splice(1, 0, { $match: match });\n      }\n    } else {\n      const match = {};\n      match[filterKey] = discriminatorValue;\n      originalPipeline.unshift({ $match: match });\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9hZ2dyZWdhdGUvcHJlcGFyZURpc2NyaW1pbmF0b3JQaXBlbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcYWdncmVnYXRlXFxwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lKHBpcGVsaW5lLCBzY2hlbWEsIHByZWZpeCkge1xuICBjb25zdCBkaXNjcmltaW5hdG9yTWFwcGluZyA9IHNjaGVtYSAmJiBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmc7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICBpZiAoZGlzY3JpbWluYXRvck1hcHBpbmcgJiYgIWRpc2NyaW1pbmF0b3JNYXBwaW5nLmlzUm9vdCkge1xuICAgIGNvbnN0IG9yaWdpbmFsUGlwZWxpbmUgPSBwaXBlbGluZTtcbiAgICBjb25zdCBmaWx0ZXJLZXkgPSAocHJlZml4Lmxlbmd0aCA+IDAgPyBwcmVmaXggKyAnLicgOiBwcmVmaXgpICsgZGlzY3JpbWluYXRvck1hcHBpbmcua2V5O1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlO1xuXG4gICAgLy8gSWYgdGhlIGZpcnN0IHBpcGVsaW5lIHN0YWdlIGlzIGEgbWF0Y2ggYW5kIGl0IGRvZXNuJ3Qgc3BlY2lmeSBhIGBfX3RgXG4gICAgLy8ga2V5LCBhZGQgdGhlIGRpc2NyaW1pbmF0b3Iga2V5IHRvIGl0LiBUaGlzIGFsbG93cyBmb3IgcG90ZW50aWFsXG4gICAgLy8gYWdncmVnYXRpb24gcXVlcnkgb3B0aW1pemF0aW9ucyBub3QgdG8gYmUgZGlzdHVyYmVkIGJ5IHRoaXMgZmVhdHVyZS5cbiAgICBpZiAob3JpZ2luYWxQaXBlbGluZVswXSAhPSBudWxsICYmXG4gICAgICAgIG9yaWdpbmFsUGlwZWxpbmVbMF0uJG1hdGNoICYmXG4gICAgICAgIChvcmlnaW5hbFBpcGVsaW5lWzBdLiRtYXRjaFtmaWx0ZXJLZXldID09PSB1bmRlZmluZWQgfHwgb3JpZ2luYWxQaXBlbGluZVswXS4kbWF0Y2hbZmlsdGVyS2V5XSA9PT0gZGlzY3JpbWluYXRvclZhbHVlKSkge1xuICAgICAgb3JpZ2luYWxQaXBlbGluZVswXS4kbWF0Y2hbZmlsdGVyS2V5XSA9IGRpc2NyaW1pbmF0b3JWYWx1ZTtcbiAgICAgIC8vIGBvcmlnaW5hbFBpcGVsaW5lYCBpcyBhIHJlZiwgc28gdGhlcmUncyBubyBuZWVkIGZvclxuICAgICAgLy8gYWdncmVnYXRlLl9waXBlbGluZSA9IG9yaWdpbmFsUGlwZWxpbmVcbiAgICB9IGVsc2UgaWYgKG9yaWdpbmFsUGlwZWxpbmVbMF0gIT0gbnVsbCAmJiBvcmlnaW5hbFBpcGVsaW5lWzBdLiRnZW9OZWFyKSB7XG4gICAgICBvcmlnaW5hbFBpcGVsaW5lWzBdLiRnZW9OZWFyLnF1ZXJ5ID1cbiAgICAgICAgICBvcmlnaW5hbFBpcGVsaW5lWzBdLiRnZW9OZWFyLnF1ZXJ5IHx8IHt9O1xuICAgICAgb3JpZ2luYWxQaXBlbGluZVswXS4kZ2VvTmVhci5xdWVyeVtmaWx0ZXJLZXldID0gZGlzY3JpbWluYXRvclZhbHVlO1xuICAgIH0gZWxzZSBpZiAob3JpZ2luYWxQaXBlbGluZVswXSAhPSBudWxsICYmIG9yaWdpbmFsUGlwZWxpbmVbMF0uJHNlYXJjaCkge1xuICAgICAgaWYgKG9yaWdpbmFsUGlwZWxpbmVbMV0gJiYgb3JpZ2luYWxQaXBlbGluZVsxXS4kbWF0Y2ggIT0gbnVsbCkge1xuICAgICAgICBvcmlnaW5hbFBpcGVsaW5lWzFdLiRtYXRjaFtmaWx0ZXJLZXldID0gb3JpZ2luYWxQaXBlbGluZVsxXS4kbWF0Y2hbZmlsdGVyS2V5XSB8fCBkaXNjcmltaW5hdG9yVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHt9O1xuICAgICAgICBtYXRjaFtmaWx0ZXJLZXldID0gZGlzY3JpbWluYXRvclZhbHVlO1xuICAgICAgICBvcmlnaW5hbFBpcGVsaW5lLnNwbGljZSgxLCAwLCB7ICRtYXRjaDogbWF0Y2ggfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1hdGNoID0ge307XG4gICAgICBtYXRjaFtmaWx0ZXJLZXldID0gZGlzY3JpbWluYXRvclZhbHVlO1xuICAgICAgb3JpZ2luYWxQaXBlbGluZS51bnNoaWZ0KHsgJG1hdGNoOiBtYXRjaCB9KTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js":
/*!*******************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js ***!
  \*******************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function stringifyFunctionOperators(pipeline) {\n  if (!Array.isArray(pipeline)) {\n    return;\n  }\n\n  for (const stage of pipeline) {\n    if (stage == null) {\n      continue;\n    }\n\n    const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;\n    if (canHaveAccumulator != null) {\n      for (const key of Object.keys(canHaveAccumulator)) {\n        handleAccumulator(canHaveAccumulator[key]);\n      }\n    }\n\n    const stageType = Object.keys(stage)[0];\n    if (stageType && typeof stage[stageType] === 'object') {\n      const stageOptions = stage[stageType];\n      for (const key of Object.keys(stageOptions)) {\n        if (stageOptions[key] != null &&\n            stageOptions[key].$function != null &&\n            typeof stageOptions[key].$function.body === 'function') {\n          stageOptions[key].$function.body = stageOptions[key].$function.body.toString();\n        }\n      }\n    }\n\n    if (stage.$facet != null) {\n      for (const key of Object.keys(stage.$facet)) {\n        stringifyFunctionOperators(stage.$facet[key]);\n      }\n    }\n  }\n};\n\nfunction handleAccumulator(operator) {\n  if (operator == null || operator.$accumulator == null) {\n    return;\n  }\n\n  for (const key of ['init', 'accumulate', 'merge', 'finalize']) {\n    if (typeof operator.$accumulator[key] === 'function') {\n      operator.$accumulator[key] = String(operator.$accumulator[key]);\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9hZ2dyZWdhdGUvc3RyaW5naWZ5RnVuY3Rpb25PcGVyYXRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcYWdncmVnYXRlXFxzdHJpbmdpZnlGdW5jdGlvbk9wZXJhdG9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5RnVuY3Rpb25PcGVyYXRvcnMocGlwZWxpbmUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBpcGVsaW5lKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoY29uc3Qgc3RhZ2Ugb2YgcGlwZWxpbmUpIHtcbiAgICBpZiAoc3RhZ2UgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgY2FuSGF2ZUFjY3VtdWxhdG9yID0gc3RhZ2UuJGdyb3VwIHx8IHN0YWdlLiRidWNrZXQgfHwgc3RhZ2UuJGJ1Y2tldEF1dG87XG4gICAgaWYgKGNhbkhhdmVBY2N1bXVsYXRvciAhPSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjYW5IYXZlQWNjdW11bGF0b3IpKSB7XG4gICAgICAgIGhhbmRsZUFjY3VtdWxhdG9yKGNhbkhhdmVBY2N1bXVsYXRvcltrZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdGFnZVR5cGUgPSBPYmplY3Qua2V5cyhzdGFnZSlbMF07XG4gICAgaWYgKHN0YWdlVHlwZSAmJiB0eXBlb2Ygc3RhZ2Vbc3RhZ2VUeXBlXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IHN0YWdlT3B0aW9ucyA9IHN0YWdlW3N0YWdlVHlwZV07XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzdGFnZU9wdGlvbnMpKSB7XG4gICAgICAgIGlmIChzdGFnZU9wdGlvbnNba2V5XSAhPSBudWxsICYmXG4gICAgICAgICAgICBzdGFnZU9wdGlvbnNba2V5XS4kZnVuY3Rpb24gIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHN0YWdlT3B0aW9uc1trZXldLiRmdW5jdGlvbi5ib2R5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc3RhZ2VPcHRpb25zW2tleV0uJGZ1bmN0aW9uLmJvZHkgPSBzdGFnZU9wdGlvbnNba2V5XS4kZnVuY3Rpb24uYm9keS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YWdlLiRmYWNldCAhPSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzdGFnZS4kZmFjZXQpKSB7XG4gICAgICAgIHN0cmluZ2lmeUZ1bmN0aW9uT3BlcmF0b3JzKHN0YWdlLiRmYWNldFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGhhbmRsZUFjY3VtdWxhdG9yKG9wZXJhdG9yKSB7XG4gIGlmIChvcGVyYXRvciA9PSBudWxsIHx8IG9wZXJhdG9yLiRhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgWydpbml0JywgJ2FjY3VtdWxhdGUnLCAnbWVyZ2UnLCAnZmluYWxpemUnXSkge1xuICAgIGlmICh0eXBlb2Ygb3BlcmF0b3IuJGFjY3VtdWxhdG9yW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wZXJhdG9yLiRhY2N1bXVsYXRvcltrZXldID0gU3RyaW5nKG9wZXJhdG9yLiRhY2N1bXVsYXRvcltrZXldKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/arrayDepth.js":
/*!*****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/arrayDepth.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = arrayDepth;\n\nfunction arrayDepth(arr) {\n  if (!Array.isArray(arr)) {\n    return { min: 0, max: 0, containsNonArrayItem: true };\n  }\n  if (arr.length === 0) {\n    return { min: 1, max: 1, containsNonArrayItem: false };\n  }\n  if (arr.length === 1 && !Array.isArray(arr[0])) {\n    return { min: 1, max: 1, containsNonArrayItem: false };\n  }\n\n  const res = arrayDepth(arr[0]);\n\n  for (let i = 1; i < arr.length; ++i) {\n    const _res = arrayDepth(arr[i]);\n    if (_res.min < res.min) {\n      res.min = _res.min;\n    }\n    if (_res.max > res.max) {\n      res.max = _res.max;\n    }\n    res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;\n  }\n\n  res.min = res.min + 1;\n  res.max = res.max + 1;\n\n  return res;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9hcnJheURlcHRoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXGFycmF5RGVwdGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RGVwdGg7XG5cbmZ1bmN0aW9uIGFycmF5RGVwdGgoYXJyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuIHsgbWluOiAwLCBtYXg6IDAsIGNvbnRhaW5zTm9uQXJyYXlJdGVtOiB0cnVlIH07XG4gIH1cbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geyBtaW46IDEsIG1heDogMSwgY29udGFpbnNOb25BcnJheUl0ZW06IGZhbHNlIH07XG4gIH1cbiAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgIUFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xuICAgIHJldHVybiB7IG1pbjogMSwgbWF4OiAxLCBjb250YWluc05vbkFycmF5SXRlbTogZmFsc2UgfTtcbiAgfVxuXG4gIGNvbnN0IHJlcyA9IGFycmF5RGVwdGgoYXJyWzBdKTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IF9yZXMgPSBhcnJheURlcHRoKGFycltpXSk7XG4gICAgaWYgKF9yZXMubWluIDwgcmVzLm1pbikge1xuICAgICAgcmVzLm1pbiA9IF9yZXMubWluO1xuICAgIH1cbiAgICBpZiAoX3Jlcy5tYXggPiByZXMubWF4KSB7XG4gICAgICByZXMubWF4ID0gX3Jlcy5tYXg7XG4gICAgfVxuICAgIHJlcy5jb250YWluc05vbkFycmF5SXRlbSA9IHJlcy5jb250YWluc05vbkFycmF5SXRlbSB8fCBfcmVzLmNvbnRhaW5zTm9uQXJyYXlJdGVtO1xuICB9XG5cbiAgcmVzLm1pbiA9IHJlcy5taW4gKyAxO1xuICByZXMubWF4ID0gcmVzLm1heCArIDE7XG5cbiAgcmV0dXJuIHJlcztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/arrayDepth.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/clone.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/clone.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Decimal = __webpack_require__(/*! ../types/decimal128 */ \"(api)/../server/node_modules/mongoose/lib/types/decimal128.js\");\nconst ObjectId = __webpack_require__(/*! ../types/objectid */ \"(api)/../server/node_modules/mongoose/lib/types/objectid.js\");\nconst specialProperties = __webpack_require__(/*! ./specialProperties */ \"(api)/../server/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst isMongooseObject = __webpack_require__(/*! ./isMongooseObject */ \"(api)/../server/node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst getFunctionName = __webpack_require__(/*! ./getFunctionName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getFunctionName.js\");\nconst isBsonType = __webpack_require__(/*! ./isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst isMongooseArray = (__webpack_require__(/*! ../types/array/isMongooseArray */ \"(api)/../server/node_modules/mongoose/lib/types/array/isMongooseArray.js\").isMongooseArray);\nconst isObject = __webpack_require__(/*! ./isObject */ \"(api)/../server/node_modules/mongoose/lib/helpers/isObject.js\");\nconst isPOJO = __webpack_require__(/*! ./isPOJO */ \"(api)/../server/node_modules/mongoose/lib/helpers/isPOJO.js\");\nconst symbols = __webpack_require__(/*! ./symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\");\nconst trustedSymbol = (__webpack_require__(/*! ./query/trusted */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/trusted.js\").trustedSymbol);\n\n/**\n * Object clone with Mongoose natives support.\n *\n * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.\n *\n * Functions are never cloned.\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.\n * @return {Object} the cloned object\n * @api private\n */\n\nfunction clone(obj, options, isArrayChild) {\n  if (obj == null) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return cloneArray(isMongooseArray(obj) ? obj.__array : obj, options);\n  }\n\n  if (isMongooseObject(obj)) {\n    // Single nested subdocs should apply getters later in `applyGetters()`\n    // when calling `toObject()`. See gh-7442, gh-8295\n    if (options && options._skipSingleNestedGetters && obj.$isSingleNested) {\n      options = Object.assign({}, options, { getters: false });\n    }\n    const isSingleNested = obj.$isSingleNested;\n\n    if (isPOJO(obj) && obj.$__ != null && obj._doc != null) {\n      return obj._doc;\n    }\n\n    let ret;\n    if (options && options.json && typeof obj.toJSON === 'function') {\n      ret = obj.toJSON(options);\n    } else {\n      ret = obj.toObject(options);\n    }\n\n    if (options && options.minimize && !obj.constructor.$__required && isSingleNested && Object.keys(ret).length === 0) {\n      return undefined;\n    }\n\n    return ret;\n  }\n\n  const objConstructor = obj.constructor;\n\n  if (objConstructor) {\n    switch (getFunctionName(objConstructor)) {\n      case 'Object':\n        return cloneObject(obj, options, isArrayChild);\n      case 'Date':\n        return new objConstructor(+obj);\n      case 'RegExp':\n        return cloneRegExp(obj);\n      default:\n        // ignore\n        break;\n    }\n  }\n\n  if (isBsonType(obj, 'ObjectId')) {\n    if (options && options.flattenObjectIds) {\n      return obj.toJSON();\n    }\n    return new ObjectId(obj.id);\n  }\n\n  if (isBsonType(obj, 'Decimal128')) {\n    if (options && options.flattenDecimals) {\n      return obj.toJSON();\n    }\n    return Decimal.fromString(obj.toString());\n  }\n\n  // object created with Object.create(null)\n  if (!objConstructor && isObject(obj)) {\n    return cloneObject(obj, options, isArrayChild);\n  }\n\n  if (typeof obj === 'object' && obj[symbols.schemaTypeSymbol]) {\n    return obj.clone();\n  }\n\n  // If we're cloning this object to go into a MongoDB command,\n  // and there's a `toBSON()` function, assume this object will be\n  // stored as a primitive in MongoDB and doesn't need to be cloned.\n  if (options && options.bson && typeof obj.toBSON === 'function') {\n    return obj;\n  }\n\n  if (typeof obj.valueOf === 'function') {\n    return obj.valueOf();\n  }\n\n  return cloneObject(obj, options, isArrayChild);\n}\nmodule.exports = clone;\n\n/*!\n * ignore\n */\n\nfunction cloneObject(obj, options, isArrayChild) {\n  const minimize = options && options.minimize;\n  const omitUndefined = options && options.omitUndefined;\n  const seen = options && options._seen;\n  const ret = {};\n  let hasKeys;\n\n  if (seen && seen.has(obj)) {\n    return seen.get(obj);\n  } else if (seen) {\n    seen.set(obj, ret);\n  }\n  if (trustedSymbol in obj) {\n    ret[trustedSymbol] = obj[trustedSymbol];\n  }\n\n  let i = 0;\n  let key = '';\n  const keys = Object.keys(obj);\n  const len = keys.length;\n\n  for (i = 0; i < len; ++i) {\n    if (specialProperties.has(key = keys[i])) {\n      continue;\n    }\n\n    // Don't pass `isArrayChild` down\n    const val = clone(obj[key], options, false);\n\n    if ((minimize === false || omitUndefined) && typeof val === 'undefined') {\n      delete ret[key];\n    } else if (minimize !== true || (typeof val !== 'undefined')) {\n      hasKeys || (hasKeys = true);\n      ret[key] = val;\n    }\n  }\n\n  return minimize && !isArrayChild ? hasKeys && ret : ret;\n}\n\nfunction cloneArray(arr, options) {\n  let i = 0;\n  const len = arr.length;\n  const ret = new Array(len);\n  for (i = 0; i < len; ++i) {\n    ret[i] = clone(arr[i], options, true);\n  }\n\n  return ret;\n}\n\nfunction cloneRegExp(regexp) {\n  const ret = new RegExp(regexp.source, regexp.flags);\n\n  if (ret.lastIndex !== regexp.lastIndex) {\n    ret.lastIndex = regexp.lastIndex;\n  }\n  return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9jbG9uZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBcUI7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsc0ZBQW1CO0FBQzVDLDBCQUEwQixtQkFBTyxDQUFDLG1HQUFxQjtBQUN2RCx5QkFBeUIsbUJBQU8sQ0FBQyxpR0FBb0I7QUFDckQsd0JBQXdCLG1CQUFPLENBQUMsK0ZBQW1CO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLHFGQUFjO0FBQ3pDLHdCQUF3Qix1SkFBeUQ7QUFDakYsaUJBQWlCLG1CQUFPLENBQUMsaUZBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDZFQUFVO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFXO0FBQ25DLHNCQUFzQixnSUFBd0M7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWEsZ0JBQWdCO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXGNsb25lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRGVjaW1hbCA9IHJlcXVpcmUoJy4uL3R5cGVzL2RlY2ltYWwxMjgnKTtcbmNvbnN0IE9iamVjdElkID0gcmVxdWlyZSgnLi4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IHNwZWNpYWxQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9zcGVjaWFsUHJvcGVydGllcycpO1xuY29uc3QgaXNNb25nb29zZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNNb25nb29zZU9iamVjdCcpO1xuY29uc3QgZ2V0RnVuY3Rpb25OYW1lID0gcmVxdWlyZSgnLi9nZXRGdW5jdGlvbk5hbWUnKTtcbmNvbnN0IGlzQnNvblR5cGUgPSByZXF1aXJlKCcuL2lzQnNvblR5cGUnKTtcbmNvbnN0IGlzTW9uZ29vc2VBcnJheSA9IHJlcXVpcmUoJy4uL3R5cGVzL2FycmF5L2lzTW9uZ29vc2VBcnJheScpLmlzTW9uZ29vc2VBcnJheTtcbmNvbnN0IGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuY29uc3QgaXNQT0pPID0gcmVxdWlyZSgnLi9pc1BPSk8nKTtcbmNvbnN0IHN5bWJvbHMgPSByZXF1aXJlKCcuL3N5bWJvbHMnKTtcbmNvbnN0IHRydXN0ZWRTeW1ib2wgPSByZXF1aXJlKCcuL3F1ZXJ5L3RydXN0ZWQnKS50cnVzdGVkU3ltYm9sO1xuXG4vKipcbiAqIE9iamVjdCBjbG9uZSB3aXRoIE1vbmdvb3NlIG5hdGl2ZXMgc3VwcG9ydC5cbiAqXG4gKiBJZiBvcHRpb25zLm1pbmltaXplIGlzIHRydWUsIGNyZWF0ZXMgYSBtaW5pbWFsIGRhdGEgb2JqZWN0LiBFbXB0eSBvYmplY3RzIGFuZCB1bmRlZmluZWQgdmFsdWVzIHdpbGwgbm90IGJlIGNsb25lZC4gVGhpcyBtYWtlcyB0aGUgZGF0YSBwYXlsb2FkIHNlbnQgdG8gTW9uZ29EQiBhcyBzbWFsbCBhcyBwb3NzaWJsZS5cbiAqXG4gKiBGdW5jdGlvbnMgYXJlIG5ldmVyIGNsb25lZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQXJyYXlDaGlsZCB0cnVlIGlmIGNsb25pbmcgaW1tZWRpYXRlbHkgdW5kZXJuZWF0aCBhbiBhcnJheS4gU3BlY2lhbCBjYXNlIGZvciBtaW5pbWl6ZS5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNsb25lZCBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNsb25lKG9iaiwgb3B0aW9ucywgaXNBcnJheUNoaWxkKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIGNsb25lQXJyYXkoaXNNb25nb29zZUFycmF5KG9iaikgPyBvYmouX19hcnJheSA6IG9iaiwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoaXNNb25nb29zZU9iamVjdChvYmopKSB7XG4gICAgLy8gU2luZ2xlIG5lc3RlZCBzdWJkb2NzIHNob3VsZCBhcHBseSBnZXR0ZXJzIGxhdGVyIGluIGBhcHBseUdldHRlcnMoKWBcbiAgICAvLyB3aGVuIGNhbGxpbmcgYHRvT2JqZWN0KClgLiBTZWUgZ2gtNzQ0MiwgZ2gtODI5NVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX3NraXBTaW5nbGVOZXN0ZWRHZXR0ZXJzICYmIG9iai4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IGdldHRlcnM6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBjb25zdCBpc1NpbmdsZU5lc3RlZCA9IG9iai4kaXNTaW5nbGVOZXN0ZWQ7XG5cbiAgICBpZiAoaXNQT0pPKG9iaikgJiYgb2JqLiRfXyAhPSBudWxsICYmIG9iai5fZG9jICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBvYmouX2RvYztcbiAgICB9XG5cbiAgICBsZXQgcmV0O1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuanNvbiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0ID0gb2JqLnRvSlNPTihvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ID0gb2JqLnRvT2JqZWN0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWluaW1pemUgJiYgIW9iai5jb25zdHJ1Y3Rvci4kX19yZXF1aXJlZCAmJiBpc1NpbmdsZU5lc3RlZCAmJiBPYmplY3Qua2V5cyhyZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgY29uc3Qgb2JqQ29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG5cbiAgaWYgKG9iakNvbnN0cnVjdG9yKSB7XG4gICAgc3dpdGNoIChnZXRGdW5jdGlvbk5hbWUob2JqQ29uc3RydWN0b3IpKSB7XG4gICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICByZXR1cm4gY2xvbmVPYmplY3Qob2JqLCBvcHRpb25zLCBpc0FycmF5Q2hpbGQpO1xuICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICAgIHJldHVybiBuZXcgb2JqQ29uc3RydWN0b3IoK29iaik7XG4gICAgICBjYXNlICdSZWdFeHAnOlxuICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGlnbm9yZVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNCc29uVHlwZShvYmosICdPYmplY3RJZCcpKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0dGVuT2JqZWN0SWRzKSB7XG4gICAgICByZXR1cm4gb2JqLnRvSlNPTigpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9iamVjdElkKG9iai5pZCk7XG4gIH1cblxuICBpZiAoaXNCc29uVHlwZShvYmosICdEZWNpbWFsMTI4JykpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZsYXR0ZW5EZWNpbWFscykge1xuICAgICAgcmV0dXJuIG9iai50b0pTT04oKTtcbiAgICB9XG4gICAgcmV0dXJuIERlY2ltYWwuZnJvbVN0cmluZyhvYmoudG9TdHJpbmcoKSk7XG4gIH1cblxuICAvLyBvYmplY3QgY3JlYXRlZCB3aXRoIE9iamVjdC5jcmVhdGUobnVsbClcbiAgaWYgKCFvYmpDb25zdHJ1Y3RvciAmJiBpc09iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGNsb25lT2JqZWN0KG9iaiwgb3B0aW9ucywgaXNBcnJheUNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmpbc3ltYm9scy5zY2hlbWFUeXBlU3ltYm9sXSkge1xuICAgIHJldHVybiBvYmouY2xvbmUoKTtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIGNsb25pbmcgdGhpcyBvYmplY3QgdG8gZ28gaW50byBhIE1vbmdvREIgY29tbWFuZCxcbiAgLy8gYW5kIHRoZXJlJ3MgYSBgdG9CU09OKClgIGZ1bmN0aW9uLCBhc3N1bWUgdGhpcyBvYmplY3Qgd2lsbCBiZVxuICAvLyBzdG9yZWQgYXMgYSBwcmltaXRpdmUgaW4gTW9uZ29EQiBhbmQgZG9lc24ndCBuZWVkIHRvIGJlIGNsb25lZC5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ic29uICYmIHR5cGVvZiBvYmoudG9CU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb2JqLnZhbHVlT2YoKTtcbiAgfVxuXG4gIHJldHVybiBjbG9uZU9iamVjdChvYmosIG9wdGlvbnMsIGlzQXJyYXlDaGlsZCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGNsb25lT2JqZWN0KG9iaiwgb3B0aW9ucywgaXNBcnJheUNoaWxkKSB7XG4gIGNvbnN0IG1pbmltaXplID0gb3B0aW9ucyAmJiBvcHRpb25zLm1pbmltaXplO1xuICBjb25zdCBvbWl0VW5kZWZpbmVkID0gb3B0aW9ucyAmJiBvcHRpb25zLm9taXRVbmRlZmluZWQ7XG4gIGNvbnN0IHNlZW4gPSBvcHRpb25zICYmIG9wdGlvbnMuX3NlZW47XG4gIGNvbnN0IHJldCA9IHt9O1xuICBsZXQgaGFzS2V5cztcblxuICBpZiAoc2VlbiAmJiBzZWVuLmhhcyhvYmopKSB7XG4gICAgcmV0dXJuIHNlZW4uZ2V0KG9iaik7XG4gIH0gZWxzZSBpZiAoc2Vlbikge1xuICAgIHNlZW4uc2V0KG9iaiwgcmV0KTtcbiAgfVxuICBpZiAodHJ1c3RlZFN5bWJvbCBpbiBvYmopIHtcbiAgICByZXRbdHJ1c3RlZFN5bWJvbF0gPSBvYmpbdHJ1c3RlZFN5bWJvbF07XG4gIH1cblxuICBsZXQgaSA9IDA7XG4gIGxldCBrZXkgPSAnJztcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5ID0ga2V5c1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIERvbid0IHBhc3MgYGlzQXJyYXlDaGlsZGAgZG93blxuICAgIGNvbnN0IHZhbCA9IGNsb25lKG9ialtrZXldLCBvcHRpb25zLCBmYWxzZSk7XG5cbiAgICBpZiAoKG1pbmltaXplID09PSBmYWxzZSB8fCBvbWl0VW5kZWZpbmVkKSAmJiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZGVsZXRlIHJldFtrZXldO1xuICAgIH0gZWxzZSBpZiAobWluaW1pemUgIT09IHRydWUgfHwgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgaGFzS2V5cyB8fCAoaGFzS2V5cyA9IHRydWUpO1xuICAgICAgcmV0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbmltaXplICYmICFpc0FycmF5Q2hpbGQgPyBoYXNLZXlzICYmIHJldCA6IHJldDtcbn1cblxuZnVuY3Rpb24gY2xvbmVBcnJheShhcnIsIG9wdGlvbnMpIHtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcmV0W2ldID0gY2xvbmUoYXJyW2ldLCBvcHRpb25zLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICBjb25zdCByZXQgPSBuZXcgUmVnRXhwKHJlZ2V4cC5zb3VyY2UsIHJlZ2V4cC5mbGFncyk7XG5cbiAgaWYgKHJldC5sYXN0SW5kZXggIT09IHJlZ2V4cC5sYXN0SW5kZXgpIHtcbiAgICByZXQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/clone.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/common.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/common.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst Binary = (__webpack_require__(/*! bson */ \"(api)/../server/node_modules/bson/lib/bson.cjs\").Binary);\nconst isBsonType = __webpack_require__(/*! ./isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst isMongooseObject = __webpack_require__(/*! ./isMongooseObject */ \"(api)/../server/node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst MongooseError = __webpack_require__(/*! ../error */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nexports.flatten = flatten;\nexports.modifiedPaths = modifiedPaths;\n\n/*!\n * ignore\n */\n\nfunction flatten(update, path, options, schema) {\n  let keys;\n  if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {\n    keys = Object.keys(update.toObject({ transform: false, virtuals: false }) || {});\n  } else {\n    keys = Object.keys(update || {});\n  }\n\n  const numKeys = keys.length;\n  const result = {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const val = update[key];\n    result[path + key] = val;\n\n    // Avoid going into mixed paths if schema is specified\n    const keySchema = schema && schema.path && schema.path(path + key);\n    const isNested = schema && schema.nested && schema.nested[path + key];\n    if (keySchema && keySchema.instance === 'Mixed') continue;\n\n    if (shouldFlatten(val)) {\n      if (options && options.skipArrays && Array.isArray(val)) {\n        continue;\n      }\n      const flat = flatten(val, path + key, options, schema);\n      for (const k in flat) {\n        result[k] = flat[k];\n      }\n      if (Array.isArray(val)) {\n        result[path + key] = val;\n      }\n    }\n\n    if (isNested) {\n      const paths = Object.keys(schema.paths);\n      for (const p of paths) {\n        if (p.startsWith(path + key + '.') && !result.hasOwnProperty(p)) {\n          result[p] = void 0;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction modifiedPaths(update, path, result, recursion = null) {\n  if (update == null || typeof update !== 'object') {\n    return;\n  }\n\n  if (recursion == null) {\n    recursion = {\n      raw: { update, path },\n      trace: new WeakSet()\n    };\n  }\n\n  if (recursion.trace.has(update)) {\n    throw new MongooseError(`a circular reference in the update value, updateValue:\n${util.inspect(recursion.raw.update, { showHidden: false, depth: 1 })}\nupdatePath: '${recursion.raw.path}'`);\n  }\n  recursion.trace.add(update);\n\n  const keys = Object.keys(update || {});\n  const numKeys = keys.length;\n  result = result || {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    let val = update[key];\n\n    const _path = path + key;\n    result[_path] = true;\n    if (!Buffer.isBuffer(val) && isMongooseObject(val)) {\n      val = val.toObject({ transform: false, virtuals: false });\n    }\n    if (shouldFlatten(val)) {\n      modifiedPaths(val, path + key, result, recursion);\n    }\n  }\n  recursion.trace.delete(update);\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction shouldFlatten(val) {\n  return val &&\n      typeof val === 'object' &&\n      !(val instanceof Date) &&\n      !isBsonType(val, 'ObjectId') &&\n      (!Array.isArray(val) || val.length !== 0) &&\n      !(val instanceof Buffer) &&\n      !isBsonType(val, 'Decimal128') &&\n      !(val instanceof Binary);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGVBQWUsMEZBQXNCO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLHFGQUFjO0FBQ3pDLHlCQUF5QixtQkFBTyxDQUFDLGlHQUFvQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQywwRUFBVTtBQUN4QyxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLGVBQWU7QUFDZixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUNBQW1DLE9BQU87QUFDbkYsSUFBSTtBQUNKLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUUscUNBQXFDLDZCQUE2QjtBQUNwRSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXGNvbW1vbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBCaW5hcnkgPSByZXF1aXJlKCdic29uJykuQmluYXJ5O1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4vaXNCc29uVHlwZScpO1xuY29uc3QgaXNNb25nb29zZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNNb25nb29zZU9iamVjdCcpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5leHBvcnRzLmZsYXR0ZW4gPSBmbGF0dGVuO1xuZXhwb3J0cy5tb2RpZmllZFBhdGhzID0gbW9kaWZpZWRQYXRocztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBmbGF0dGVuKHVwZGF0ZSwgcGF0aCwgb3B0aW9ucywgc2NoZW1hKSB7XG4gIGxldCBrZXlzO1xuICBpZiAodXBkYXRlICYmIGlzTW9uZ29vc2VPYmplY3QodXBkYXRlKSAmJiAhQnVmZmVyLmlzQnVmZmVyKHVwZGF0ZSkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlLnRvT2JqZWN0KHsgdHJhbnNmb3JtOiBmYWxzZSwgdmlydHVhbHM6IGZhbHNlIH0pIHx8IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlIHx8IHt9KTtcbiAgfVxuXG4gIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIHBhdGggPSBwYXRoID8gcGF0aCArICcuJyA6ICcnO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBjb25zdCB2YWwgPSB1cGRhdGVba2V5XTtcbiAgICByZXN1bHRbcGF0aCArIGtleV0gPSB2YWw7XG5cbiAgICAvLyBBdm9pZCBnb2luZyBpbnRvIG1peGVkIHBhdGhzIGlmIHNjaGVtYSBpcyBzcGVjaWZpZWRcbiAgICBjb25zdCBrZXlTY2hlbWEgPSBzY2hlbWEgJiYgc2NoZW1hLnBhdGggJiYgc2NoZW1hLnBhdGgocGF0aCArIGtleSk7XG4gICAgY29uc3QgaXNOZXN0ZWQgPSBzY2hlbWEgJiYgc2NoZW1hLm5lc3RlZCAmJiBzY2hlbWEubmVzdGVkW3BhdGggKyBrZXldO1xuICAgIGlmIChrZXlTY2hlbWEgJiYga2V5U2NoZW1hLmluc3RhbmNlID09PSAnTWl4ZWQnKSBjb250aW51ZTtcblxuICAgIGlmIChzaG91bGRGbGF0dGVuKHZhbCkpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2tpcEFycmF5cyAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBmbGF0ID0gZmxhdHRlbih2YWwsIHBhdGggKyBrZXksIG9wdGlvbnMsIHNjaGVtYSk7XG4gICAgICBmb3IgKGNvbnN0IGsgaW4gZmxhdCkge1xuICAgICAgICByZXN1bHRba10gPSBmbGF0W2tdO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICByZXN1bHRbcGF0aCArIGtleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzTmVzdGVkKSB7XG4gICAgICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocyk7XG4gICAgICBmb3IgKGNvbnN0IHAgb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKHAuc3RhcnRzV2l0aChwYXRoICsga2V5ICsgJy4nKSAmJiAhcmVzdWx0Lmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgcmVzdWx0W3BdID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBtb2RpZmllZFBhdGhzKHVwZGF0ZSwgcGF0aCwgcmVzdWx0LCByZWN1cnNpb24gPSBudWxsKSB7XG4gIGlmICh1cGRhdGUgPT0gbnVsbCB8fCB0eXBlb2YgdXBkYXRlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyZWN1cnNpb24gPT0gbnVsbCkge1xuICAgIHJlY3Vyc2lvbiA9IHtcbiAgICAgIHJhdzogeyB1cGRhdGUsIHBhdGggfSxcbiAgICAgIHRyYWNlOiBuZXcgV2Vha1NldCgpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChyZWN1cnNpb24udHJhY2UuaGFzKHVwZGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihgYSBjaXJjdWxhciByZWZlcmVuY2UgaW4gdGhlIHVwZGF0ZSB2YWx1ZSwgdXBkYXRlVmFsdWU6XG4ke3V0aWwuaW5zcGVjdChyZWN1cnNpb24ucmF3LnVwZGF0ZSwgeyBzaG93SGlkZGVuOiBmYWxzZSwgZGVwdGg6IDEgfSl9XG51cGRhdGVQYXRoOiAnJHtyZWN1cnNpb24ucmF3LnBhdGh9J2ApO1xuICB9XG4gIHJlY3Vyc2lvbi50cmFjZS5hZGQodXBkYXRlKTtcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlIHx8IHt9KTtcbiAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICByZXN1bHQgPSByZXN1bHQgfHwge307XG4gIHBhdGggPSBwYXRoID8gcGF0aCArICcuJyA6ICcnO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBsZXQgdmFsID0gdXBkYXRlW2tleV07XG5cbiAgICBjb25zdCBfcGF0aCA9IHBhdGggKyBrZXk7XG4gICAgcmVzdWx0W19wYXRoXSA9IHRydWU7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSAmJiBpc01vbmdvb3NlT2JqZWN0KHZhbCkpIHtcbiAgICAgIHZhbCA9IHZhbC50b09iamVjdCh7IHRyYW5zZm9ybTogZmFsc2UsIHZpcnR1YWxzOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaWYgKHNob3VsZEZsYXR0ZW4odmFsKSkge1xuICAgICAgbW9kaWZpZWRQYXRocyh2YWwsIHBhdGggKyBrZXksIHJlc3VsdCwgcmVjdXJzaW9uKTtcbiAgICB9XG4gIH1cbiAgcmVjdXJzaW9uLnRyYWNlLmRlbGV0ZSh1cGRhdGUpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gc2hvdWxkRmxhdHRlbih2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJlxuICAgICAgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICEodmFsIGluc3RhbmNlb2YgRGF0ZSkgJiZcbiAgICAgICFpc0Jzb25UeXBlKHZhbCwgJ09iamVjdElkJykgJiZcbiAgICAgICghQXJyYXkuaXNBcnJheSh2YWwpIHx8IHZhbC5sZW5ndGggIT09IDApICYmXG4gICAgICAhKHZhbCBpbnN0YW5jZW9mIEJ1ZmZlcikgJiZcbiAgICAgICFpc0Jzb25UeXBlKHZhbCwgJ0RlY2ltYWwxMjgnKSAmJlxuICAgICAgISh2YWwgaW5zdGFuY2VvZiBCaW5hcnkpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/common.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/cursor/eachAsync.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/cursor/eachAsync.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EachAsyncMultiError = __webpack_require__(/*! ../../error/eachAsyncMultiError */ \"(api)/../server/node_modules/mongoose/lib/error/eachAsyncMultiError.js\");\nconst immediate = __webpack_require__(/*! ../immediate */ \"(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\");\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} next the thunk to call to get the next document\n * @param {Function} fn\n * @param {Object} options\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\n * @param {Number} [options.parallel=1] maximum number of `fn` calls that Mongoose will run in parallel\n * @param {AbortSignal} [options.signal] allow cancelling this eachAsync(). Once the abort signal is fired, `eachAsync()` will immediately fulfill the returned promise (or call the callback) and not fetch any more documents.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nmodule.exports = async function eachAsync(next, fn, options) {\n  const parallel = options.parallel || 1;\n  const batchSize = options.batchSize;\n  const signal = options.signal;\n  const continueOnError = options.continueOnError;\n  const aggregatedErrors = [];\n  const enqueue = asyncQueue();\n\n  let aborted = false;\n\n  return new Promise((resolve, reject) => {\n    if (signal != null) {\n      if (signal.aborted) {\n        return resolve(null);\n      }\n\n      signal.addEventListener('abort', () => {\n        aborted = true;\n        return resolve(null);\n      }, { once: true });\n    }\n\n    if (batchSize != null) {\n      if (typeof batchSize !== 'number') {\n        throw new TypeError('batchSize must be a number');\n      } else if (!Number.isInteger(batchSize)) {\n        throw new TypeError('batchSize must be an integer');\n      } else if (batchSize < 1) {\n        throw new TypeError('batchSize must be at least 1');\n      }\n    }\n\n    iterate((err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n\n  function iterate(finalCallback) {\n    let handleResultsInProgress = 0;\n    let currentDocumentIndex = 0;\n\n    let error = null;\n    for (let i = 0; i < parallel; ++i) {\n      enqueue(createFetch());\n    }\n\n    function createFetch() {\n      let documentsBatch = [];\n      let drained = false;\n\n      return fetch;\n\n      function fetch(done) {\n        if (drained || aborted) {\n          return done();\n        } else if (error) {\n          return done();\n        }\n\n        next(function(err, doc) {\n          if (error != null) {\n            return done();\n          }\n          if (err != null) {\n            if (err.name === 'MongoCursorExhaustedError') {\n              // We may end up calling `next()` multiple times on an exhausted\n              // cursor, which leads to an error. In case cursor is exhausted,\n              // just treat it as if the cursor returned no document, which is\n              // how a cursor indicates it is exhausted.\n              doc = null;\n            } else if (continueOnError) {\n              aggregatedErrors.push(err);\n            } else {\n              error = err;\n              finalCallback(err);\n              return done();\n            }\n          }\n          if (doc == null) {\n            drained = true;\n            if (handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ?\n                createEachAsyncMultiError(aggregatedErrors) :\n                error;\n\n              finalCallback(finalErr);\n            } else if (batchSize && documentsBatch.length) {\n              handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\n            }\n            return done();\n          }\n\n          ++handleResultsInProgress;\n\n          // Kick off the subsequent `next()` before handling the result, but\n          // make sure we know that we still have a result to handle re: #8422\n          immediate(() => done());\n\n          if (batchSize) {\n            documentsBatch.push(doc);\n          }\n\n          // If the current documents size is less than the provided batch size don't process the documents yet\n          if (batchSize && documentsBatch.length !== batchSize) {\n            immediate(() => enqueue(fetch));\n            return;\n          }\n\n          const docsToProcess = batchSize ? documentsBatch : doc;\n\n          function handleNextResultCallBack(err) {\n            if (batchSize) {\n              handleResultsInProgress -= documentsBatch.length;\n              documentsBatch = [];\n            } else {\n              --handleResultsInProgress;\n            }\n            if (err != null) {\n              if (continueOnError) {\n                aggregatedErrors.push(err);\n              } else {\n                error = err;\n                return finalCallback(err);\n              }\n            }\n            if ((drained || aborted) && handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ?\n                createEachAsyncMultiError(aggregatedErrors) :\n                error;\n              return finalCallback(finalErr);\n            }\n\n            immediate(() => enqueue(fetch));\n          }\n\n          handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\n        });\n      }\n    }\n  }\n\n  function handleNextResult(doc, i, callback) {\n    let maybePromise;\n    try {\n      maybePromise = fn(doc, i);\n    } catch (err) {\n      return callback(err);\n    }\n    if (maybePromise && typeof maybePromise.then === 'function') {\n      maybePromise.then(\n        function() { callback(null); },\n        function(error) {\n          callback(error || new Error('`eachAsync()` promise rejected without error'));\n        });\n    } else {\n      callback(null);\n    }\n  }\n};\n\n// `next()` can only execute one at a time, so make sure we always execute\n// `next()` in series, while still allowing multiple `fn()` instances to run\n// in parallel.\nfunction asyncQueue() {\n  const _queue = [];\n  let inProgress = null;\n  let id = 0;\n\n  return function enqueue(fn) {\n    if (\n      inProgress === null &&\n      _queue.length === 0\n    ) {\n      inProgress = id++;\n      return fn(_step);\n    }\n    _queue.push(fn);\n  };\n\n  function _step() {\n    if (_queue.length !== 0) {\n      inProgress = id++;\n      const fn = _queue.shift();\n      fn(_step);\n    } else {\n      inProgress = null;\n    }\n  }\n}\n\nfunction createEachAsyncMultiError(aggregatedErrors) {\n  if (aggregatedErrors.length === 0) {\n    return null;\n  }\n\n  return new EachAsyncMultiError(aggregatedErrors);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9jdXJzb3IvZWFjaEFzeW5jLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsbUJBQU8sQ0FBQywrR0FBaUM7QUFDckUsa0JBQWtCLG1CQUFPLENBQUMsb0ZBQWM7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJLFlBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxjdXJzb3JcXGVhY2hBc3luYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBFYWNoQXN5bmNNdWx0aUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvZWFjaEFzeW5jTXVsdGlFcnJvcicpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi4vaW1tZWRpYXRlJyk7XG5cbi8qKlxuICogRXhlY3V0ZSBgZm5gIGZvciBldmVyeSBkb2N1bWVudCBpbiB0aGUgY3Vyc29yLiBJZiBgZm5gIHJldHVybnMgYSBwcm9taXNlLFxuICogd2lsbCB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBpdGVyYXRpbmcgb24gdG8gdGhlIG5leHQgb25lLlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGRvbmUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dCB0aGUgdGh1bmsgdG8gY2FsbCB0byBnZXQgdGhlIG5leHQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhdGNoU2l6ZT1udWxsXSBpZiBzZXQsIE1vbmdvb3NlIHdpbGwgY2FsbCBgZm5gIHdpdGggYW4gYXJyYXkgb2YgYXQgbW9zdCBgYmF0Y2hTaXplYCBkb2N1bWVudHMsIGluc3RlYWQgb2YgYSBzaW5nbGUgZG9jdW1lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYXJhbGxlbD0xXSBtYXhpbXVtIG51bWJlciBvZiBgZm5gIGNhbGxzIHRoYXQgTW9uZ29vc2Ugd2lsbCBydW4gaW4gcGFyYWxsZWxcbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtvcHRpb25zLnNpZ25hbF0gYWxsb3cgY2FuY2VsbGluZyB0aGlzIGVhY2hBc3luYygpLiBPbmNlIHRoZSBhYm9ydCBzaWduYWwgaXMgZmlyZWQsIGBlYWNoQXN5bmMoKWAgd2lsbCBpbW1lZGlhdGVseSBmdWxmaWxsIHRoZSByZXR1cm5lZCBwcm9taXNlIChvciBjYWxsIHRoZSBjYWxsYmFjaykgYW5kIG5vdCBmZXRjaCBhbnkgbW9yZSBkb2N1bWVudHMuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgZWFjaEFzeW5jXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyBmdW5jdGlvbiBlYWNoQXN5bmMobmV4dCwgZm4sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFyYWxsZWwgPSBvcHRpb25zLnBhcmFsbGVsIHx8IDE7XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IG9wdGlvbnMuYmF0Y2hTaXplO1xuICBjb25zdCBzaWduYWwgPSBvcHRpb25zLnNpZ25hbDtcbiAgY29uc3QgY29udGludWVPbkVycm9yID0gb3B0aW9ucy5jb250aW51ZU9uRXJyb3I7XG4gIGNvbnN0IGFnZ3JlZ2F0ZWRFcnJvcnMgPSBbXTtcbiAgY29uc3QgZW5xdWV1ZSA9IGFzeW5jUXVldWUoKTtcblxuICBsZXQgYWJvcnRlZCA9IGZhbHNlO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHNpZ25hbCAhPSBudWxsKSB7XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIGlmIChiYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBiYXRjaFNpemUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JhdGNoU2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGJhdGNoU2l6ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmF0Y2hTaXplIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgICAgfSBlbHNlIGlmIChiYXRjaFNpemUgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JhdGNoU2l6ZSBtdXN0IGJlIGF0IGxlYXN0IDEnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpdGVyYXRlKChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZShmaW5hbENhbGxiYWNrKSB7XG4gICAgbGV0IGhhbmRsZVJlc3VsdHNJblByb2dyZXNzID0gMDtcbiAgICBsZXQgY3VycmVudERvY3VtZW50SW5kZXggPSAwO1xuXG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFsbGVsOyArK2kpIHtcbiAgICAgIGVucXVldWUoY3JlYXRlRmV0Y2goKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRmV0Y2goKSB7XG4gICAgICBsZXQgZG9jdW1lbnRzQmF0Y2ggPSBbXTtcbiAgICAgIGxldCBkcmFpbmVkID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiBmZXRjaDtcblxuICAgICAgZnVuY3Rpb24gZmV0Y2goZG9uZSkge1xuICAgICAgICBpZiAoZHJhaW5lZCB8fCBhYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KGZ1bmN0aW9uKGVyciwgZG9jKSB7XG4gICAgICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnTW9uZ29DdXJzb3JFeGhhdXN0ZWRFcnJvcicpIHtcbiAgICAgICAgICAgICAgLy8gV2UgbWF5IGVuZCB1cCBjYWxsaW5nIGBuZXh0KClgIG11bHRpcGxlIHRpbWVzIG9uIGFuIGV4aGF1c3RlZFxuICAgICAgICAgICAgICAvLyBjdXJzb3IsIHdoaWNoIGxlYWRzIHRvIGFuIGVycm9yLiBJbiBjYXNlIGN1cnNvciBpcyBleGhhdXN0ZWQsXG4gICAgICAgICAgICAgIC8vIGp1c3QgdHJlYXQgaXQgYXMgaWYgdGhlIGN1cnNvciByZXR1cm5lZCBubyBkb2N1bWVudCwgd2hpY2ggaXNcbiAgICAgICAgICAgICAgLy8gaG93IGEgY3Vyc29yIGluZGljYXRlcyBpdCBpcyBleGhhdXN0ZWQuXG4gICAgICAgICAgICAgIGRvYyA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRpbnVlT25FcnJvcikge1xuICAgICAgICAgICAgICBhZ2dyZWdhdGVkRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICBmaW5hbENhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgZHJhaW5lZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoaGFuZGxlUmVzdWx0c0luUHJvZ3Jlc3MgPD0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBmaW5hbEVyciA9IGNvbnRpbnVlT25FcnJvciA/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWFjaEFzeW5jTXVsdGlFcnJvcihhZ2dyZWdhdGVkRXJyb3JzKSA6XG4gICAgICAgICAgICAgICAgZXJyb3I7XG5cbiAgICAgICAgICAgICAgZmluYWxDYWxsYmFjayhmaW5hbEVycik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJhdGNoU2l6ZSAmJiBkb2N1bWVudHNCYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaGFuZGxlTmV4dFJlc3VsdChkb2N1bWVudHNCYXRjaCwgY3VycmVudERvY3VtZW50SW5kZXgrKywgaGFuZGxlTmV4dFJlc3VsdENhbGxCYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgKytoYW5kbGVSZXN1bHRzSW5Qcm9ncmVzcztcblxuICAgICAgICAgIC8vIEtpY2sgb2ZmIHRoZSBzdWJzZXF1ZW50IGBuZXh0KClgIGJlZm9yZSBoYW5kbGluZyB0aGUgcmVzdWx0LCBidXRcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Uga25vdyB0aGF0IHdlIHN0aWxsIGhhdmUgYSByZXN1bHQgdG8gaGFuZGxlIHJlOiAjODQyMlxuICAgICAgICAgIGltbWVkaWF0ZSgoKSA9PiBkb25lKCkpO1xuXG4gICAgICAgICAgaWYgKGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgZG9jdW1lbnRzQmF0Y2gucHVzaChkb2MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGRvY3VtZW50cyBzaXplIGlzIGxlc3MgdGhhbiB0aGUgcHJvdmlkZWQgYmF0Y2ggc2l6ZSBkb24ndCBwcm9jZXNzIHRoZSBkb2N1bWVudHMgeWV0XG4gICAgICAgICAgaWYgKGJhdGNoU2l6ZSAmJiBkb2N1bWVudHNCYXRjaC5sZW5ndGggIT09IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgaW1tZWRpYXRlKCgpID0+IGVucXVldWUoZmV0Y2gpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBkb2NzVG9Qcm9jZXNzID0gYmF0Y2hTaXplID8gZG9jdW1lbnRzQmF0Y2ggOiBkb2M7XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVOZXh0UmVzdWx0Q2FsbEJhY2soZXJyKSB7XG4gICAgICAgICAgICBpZiAoYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICAgIGhhbmRsZVJlc3VsdHNJblByb2dyZXNzIC09IGRvY3VtZW50c0JhdGNoLmxlbmd0aDtcbiAgICAgICAgICAgICAgZG9jdW1lbnRzQmF0Y2ggPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC0taGFuZGxlUmVzdWx0c0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlT25FcnJvcikge1xuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZWRFcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5hbENhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZHJhaW5lZCB8fCBhYm9ydGVkKSAmJiBoYW5kbGVSZXN1bHRzSW5Qcm9ncmVzcyA8PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbmFsRXJyID0gY29udGludWVPbkVycm9yID9cbiAgICAgICAgICAgICAgICBjcmVhdGVFYWNoQXN5bmNNdWx0aUVycm9yKGFnZ3JlZ2F0ZWRFcnJvcnMpIDpcbiAgICAgICAgICAgICAgICBlcnJvcjtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsQ2FsbGJhY2soZmluYWxFcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbW1lZGlhdGUoKCkgPT4gZW5xdWV1ZShmZXRjaCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhhbmRsZU5leHRSZXN1bHQoZG9jc1RvUHJvY2VzcywgY3VycmVudERvY3VtZW50SW5kZXgrKywgaGFuZGxlTmV4dFJlc3VsdENhbGxCYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV4dFJlc3VsdChkb2MsIGksIGNhbGxiYWNrKSB7XG4gICAgbGV0IG1heWJlUHJvbWlzZTtcbiAgICB0cnkge1xuICAgICAgbWF5YmVQcm9taXNlID0gZm4oZG9jLCBpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbWF5YmVQcm9taXNlLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhudWxsKTsgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvciB8fCBuZXcgRXJyb3IoJ2BlYWNoQXN5bmMoKWAgcHJvbWlzZSByZWplY3RlZCB3aXRob3V0IGVycm9yJykpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBgbmV4dCgpYCBjYW4gb25seSBleGVjdXRlIG9uZSBhdCBhIHRpbWUsIHNvIG1ha2Ugc3VyZSB3ZSBhbHdheXMgZXhlY3V0ZVxuLy8gYG5leHQoKWAgaW4gc2VyaWVzLCB3aGlsZSBzdGlsbCBhbGxvd2luZyBtdWx0aXBsZSBgZm4oKWAgaW5zdGFuY2VzIHRvIHJ1blxuLy8gaW4gcGFyYWxsZWwuXG5mdW5jdGlvbiBhc3luY1F1ZXVlKCkge1xuICBjb25zdCBfcXVldWUgPSBbXTtcbiAgbGV0IGluUHJvZ3Jlc3MgPSBudWxsO1xuICBsZXQgaWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiBlbnF1ZXVlKGZuKSB7XG4gICAgaWYgKFxuICAgICAgaW5Qcm9ncmVzcyA9PT0gbnVsbCAmJlxuICAgICAgX3F1ZXVlLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgaW5Qcm9ncmVzcyA9IGlkKys7XG4gICAgICByZXR1cm4gZm4oX3N0ZXApO1xuICAgIH1cbiAgICBfcXVldWUucHVzaChmbik7XG4gIH07XG5cbiAgZnVuY3Rpb24gX3N0ZXAoKSB7XG4gICAgaWYgKF9xdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgIGluUHJvZ3Jlc3MgPSBpZCsrO1xuICAgICAgY29uc3QgZm4gPSBfcXVldWUuc2hpZnQoKTtcbiAgICAgIGZuKF9zdGVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVhY2hBc3luY011bHRpRXJyb3IoYWdncmVnYXRlZEVycm9ycykge1xuICBpZiAoYWdncmVnYXRlZEVycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBuZXcgRWFjaEFzeW5jTXVsdGlFcnJvcihhZ2dyZWdhdGVkRXJyb3JzKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/cursor/eachAsync.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js":
/*!************************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = applyEmbeddedDiscriminators;\n\nfunction applyEmbeddedDiscriminators(schema, seen = new WeakSet()) {\n  if (seen.has(schema)) {\n    return;\n  }\n  seen.add(schema);\n  for (const path of Object.keys(schema.paths)) {\n    const schemaType = schema.paths[path];\n    if (!schemaType.schema) {\n      continue;\n    }\n    applyEmbeddedDiscriminators(schemaType.schema, seen);\n    if (!schemaType.schema._applyDiscriminators) {\n      continue;\n    }\n    if (schemaType._appliedDiscriminators) {\n      continue;\n    }\n    for (const discriminatorKey of schemaType.schema._applyDiscriminators.keys()) {\n      const {\n        schema: discriminatorSchema,\n        options\n      } = schemaType.schema._applyDiscriminators.get(discriminatorKey);\n      applyEmbeddedDiscriminators(discriminatorSchema, seen);\n      schemaType.discriminator(discriminatorKey, discriminatorSchema, options);\n    }\n    schemaType._appliedDiscriminators = true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2FwcGx5RW1iZWRkZWREaXNjcmltaW5hdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcZGlzY3JpbWluYXRvclxcYXBwbHlFbWJlZGRlZERpc2NyaW1pbmF0b3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseUVtYmVkZGVkRGlzY3JpbWluYXRvcnM7XG5cbmZ1bmN0aW9uIGFwcGx5RW1iZWRkZWREaXNjcmltaW5hdG9ycyhzY2hlbWEsIHNlZW4gPSBuZXcgV2Vha1NldCgpKSB7XG4gIGlmIChzZWVuLmhhcyhzY2hlbWEpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlZW4uYWRkKHNjaGVtYSk7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpKSB7XG4gICAgY29uc3Qgc2NoZW1hVHlwZSA9IHNjaGVtYS5wYXRoc1twYXRoXTtcbiAgICBpZiAoIXNjaGVtYVR5cGUuc2NoZW1hKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYXBwbHlFbWJlZGRlZERpc2NyaW1pbmF0b3JzKHNjaGVtYVR5cGUuc2NoZW1hLCBzZWVuKTtcbiAgICBpZiAoIXNjaGVtYVR5cGUuc2NoZW1hLl9hcHBseURpc2NyaW1pbmF0b3JzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVR5cGUuX2FwcGxpZWREaXNjcmltaW5hdG9ycykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZGlzY3JpbWluYXRvcktleSBvZiBzY2hlbWFUeXBlLnNjaGVtYS5fYXBwbHlEaXNjcmltaW5hdG9ycy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NoZW1hOiBkaXNjcmltaW5hdG9yU2NoZW1hLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9ID0gc2NoZW1hVHlwZS5zY2hlbWEuX2FwcGx5RGlzY3JpbWluYXRvcnMuZ2V0KGRpc2NyaW1pbmF0b3JLZXkpO1xuICAgICAgYXBwbHlFbWJlZGRlZERpc2NyaW1pbmF0b3JzKGRpc2NyaW1pbmF0b3JTY2hlbWEsIHNlZW4pO1xuICAgICAgc2NoZW1hVHlwZS5kaXNjcmltaW5hdG9yKGRpc2NyaW1pbmF0b3JLZXksIGRpc2NyaW1pbmF0b3JTY2hlbWEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzY2hlbWFUeXBlLl9hcHBsaWVkRGlzY3JpbWluYXRvcnMgPSB0cnVlO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js":
/*!************************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isBsonType = __webpack_require__(/*! ../isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nmodule.exports = function areDiscriminatorValuesEqual(a, b) {\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a === b;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a === b;\n  }\n  if (isBsonType(a, 'ObjectId') && isBsonType(b, 'ObjectId')) {\n    return a.toString() === b.toString();\n  }\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2FyZURpc2NyaW1pbmF0b3JWYWx1ZXNFcXVhbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBZTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcZGlzY3JpbWluYXRvclxcYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uL2lzQnNvblR5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcmVEaXNjcmltaW5hdG9yVmFsdWVzRXF1YWwoYSwgYikge1xuICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgaWYgKGlzQnNvblR5cGUoYSwgJ09iamVjdElkJykgJiYgaXNCc29uVHlwZShiLCAnT2JqZWN0SWQnKSkge1xuICAgIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js":
/*!************************************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js ***!
  \************************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path, schema, selected, addedPaths) {\n  const userProjectedInPath = Object.keys(userProjection).\n    reduce((cur, key) => cur || key.startsWith(path + '.'), false);\n  const _discriminatorKey = path + '.' + schema.options.discriminatorKey;\n  if (!userProjectedInPath &&\n      addedPaths.length === 1 &&\n      addedPaths[0] === _discriminatorKey) {\n    selected.splice(selected.indexOf(_discriminatorKey), 1);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2NoZWNrRW1iZWRkZWREaXNjcmltaW5hdG9yS2V5UHJvamVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXGRpc2NyaW1pbmF0b3JcXGNoZWNrRW1iZWRkZWREaXNjcmltaW5hdG9yS2V5UHJvamVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2hlY2tFbWJlZGRlZERpc2NyaW1pbmF0b3JLZXlQcm9qZWN0aW9uKHVzZXJQcm9qZWN0aW9uLCBwYXRoLCBzY2hlbWEsIHNlbGVjdGVkLCBhZGRlZFBhdGhzKSB7XG4gIGNvbnN0IHVzZXJQcm9qZWN0ZWRJblBhdGggPSBPYmplY3Qua2V5cyh1c2VyUHJvamVjdGlvbikuXG4gICAgcmVkdWNlKChjdXIsIGtleSkgPT4gY3VyIHx8IGtleS5zdGFydHNXaXRoKHBhdGggKyAnLicpLCBmYWxzZSk7XG4gIGNvbnN0IF9kaXNjcmltaW5hdG9yS2V5ID0gcGF0aCArICcuJyArIHNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gIGlmICghdXNlclByb2plY3RlZEluUGF0aCAmJlxuICAgICAgYWRkZWRQYXRocy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGFkZGVkUGF0aHNbMF0gPT09IF9kaXNjcmltaW5hdG9yS2V5KSB7XG4gICAgc2VsZWN0ZWQuc3BsaWNlKHNlbGVjdGVkLmluZGV4T2YoX2Rpc2NyaW1pbmF0b3JLZXkpLCAxKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js":
/*!***********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst getDiscriminatorByValue = __webpack_require__(/*! ./getDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\n\n/**\n * Find the correct constructor, taking into account discriminators\n * @api private\n */\n\nmodule.exports = function getConstructor(Constructor, value, defaultDiscriminatorValue) {\n  const discriminatorKey = Constructor.schema.options.discriminatorKey;\n  let discriminatorValue = (value != null && value[discriminatorKey]);\n  if (discriminatorValue == null) {\n    discriminatorValue = defaultDiscriminatorValue;\n  }\n  if (Constructor.discriminators &&\n      discriminatorValue != null) {\n    if (Constructor.discriminators[discriminatorValue]) {\n      Constructor = Constructor.discriminators[discriminatorValue];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, discriminatorValue);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  return Constructor;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2dldENvbnN0cnVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdDQUFnQyxtQkFBTyxDQUFDLDZIQUEyQjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxkaXNjcmltaW5hdG9yXFxnZXRDb25zdHJ1Y3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuXG4vKipcbiAqIEZpbmQgdGhlIGNvcnJlY3QgY29uc3RydWN0b3IsIHRha2luZyBpbnRvIGFjY291bnQgZGlzY3JpbWluYXRvcnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3IoQ29uc3RydWN0b3IsIHZhbHVlLCBkZWZhdWx0RGlzY3JpbWluYXRvclZhbHVlKSB7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICBsZXQgZGlzY3JpbWluYXRvclZhbHVlID0gKHZhbHVlICE9IG51bGwgJiYgdmFsdWVbZGlzY3JpbWluYXRvcktleV0pO1xuICBpZiAoZGlzY3JpbWluYXRvclZhbHVlID09IG51bGwpIHtcbiAgICBkaXNjcmltaW5hdG9yVmFsdWUgPSBkZWZhdWx0RGlzY3JpbWluYXRvclZhbHVlO1xuICB9XG4gIGlmIChDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9ycyAmJlxuICAgICAgZGlzY3JpbWluYXRvclZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAoQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvclZhbHVlXSkge1xuICAgICAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yVmFsdWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RvckJ5VmFsdWUgPSBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9ycywgZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgIGlmIChjb25zdHJ1Y3RvckJ5VmFsdWUpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvckJ5VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js":
/*!********************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst areDiscriminatorValuesEqual = __webpack_require__(/*! ./areDiscriminatorValuesEqual */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js\");\n\n/**\n * returns discriminator by discriminatorMapping.value\n *\n * @param {Object} discriminators\n * @param {string} value\n * @api private\n */\n\nmodule.exports = function getDiscriminatorByValue(discriminators, value) {\n  if (discriminators == null) {\n    return null;\n  }\n  for (const name of Object.keys(discriminators)) {\n    const it = discriminators[name];\n    if (\n      it.schema &&\n      it.schema.discriminatorMapping &&\n      areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)\n    ) {\n      return it;\n    }\n  }\n  return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9DQUFvQyxtQkFBTyxDQUFDLHFJQUErQjs7QUFFM0U7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcZGlzY3JpbWluYXRvclxcZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhcmVEaXNjcmltaW5hdG9yVmFsdWVzRXF1YWwgPSByZXF1aXJlKCcuL2FyZURpc2NyaW1pbmF0b3JWYWx1ZXNFcXVhbCcpO1xuXG4vKipcbiAqIHJldHVybnMgZGlzY3JpbWluYXRvciBieSBkaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkaXNjcmltaW5hdG9yc1xuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKGRpc2NyaW1pbmF0b3JzLCB2YWx1ZSkge1xuICBpZiAoZGlzY3JpbWluYXRvcnMgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkaXNjcmltaW5hdG9ycykpIHtcbiAgICBjb25zdCBpdCA9IGRpc2NyaW1pbmF0b3JzW25hbWVdO1xuICAgIGlmIChcbiAgICAgIGl0LnNjaGVtYSAmJlxuICAgICAgaXQuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nICYmXG4gICAgICBhcmVEaXNjcmltaW5hdG9yVmFsdWVzRXF1YWwoaXQuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlLCB2YWx1ZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBpdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js":
/*!**************************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst areDiscriminatorValuesEqual = __webpack_require__(/*! ./areDiscriminatorValuesEqual */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js\");\n\n/**\n * returns discriminator by discriminatorMapping.value\n *\n * @param {Schema} schema\n * @param {string} value\n * @api private\n */\n\nmodule.exports = function getSchemaDiscriminatorByValue(schema, value) {\n  if (schema == null || schema.discriminators == null) {\n    return null;\n  }\n  for (const key of Object.keys(schema.discriminators)) {\n    const discriminatorSchema = schema.discriminators[key];\n    if (discriminatorSchema.discriminatorMapping == null) {\n      continue;\n    }\n    if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {\n      return discriminatorSchema;\n    }\n  }\n  return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2dldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9DQUFvQyxtQkFBTyxDQUFDLHFJQUErQjs7QUFFM0U7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXGRpc2NyaW1pbmF0b3JcXGdldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsID0gcmVxdWlyZSgnLi9hcmVEaXNjcmltaW5hdG9yVmFsdWVzRXF1YWwnKTtcblxuLyoqXG4gKiByZXR1cm5zIGRpc2NyaW1pbmF0b3IgYnkgZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWVcbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUoc2NoZW1hLCB2YWx1ZSkge1xuICBpZiAoc2NoZW1hID09IG51bGwgfHwgc2NoZW1hLmRpc2NyaW1pbmF0b3JzID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEuZGlzY3JpbWluYXRvcnMpKSB7XG4gICAgY29uc3QgZGlzY3JpbWluYXRvclNjaGVtYSA9IHNjaGVtYS5kaXNjcmltaW5hdG9yc1trZXldO1xuICAgIGlmIChkaXNjcmltaW5hdG9yU2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsKGRpc2NyaW1pbmF0b3JTY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWUsIHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGRpc2NyaW1pbmF0b3JTY2hlbWE7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js":
/*!*********************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst schemaMerge = __webpack_require__(/*! ../schema/merge */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/merge.js\");\nconst specialProperties = __webpack_require__(/*! ../../helpers/specialProperties */ \"(api)/../server/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst isBsonType = __webpack_require__(/*! ../../helpers/isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst ObjectId = __webpack_require__(/*! ../../types/objectid */ \"(api)/../server/node_modules/mongoose/lib/types/objectid.js\");\nconst isObject = __webpack_require__(/*! ../../helpers/isObject */ \"(api)/../server/node_modules/mongoose/lib/helpers/isObject.js\");\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @param {String} [path]\n * @api private\n */\n\nmodule.exports = function mergeDiscriminatorSchema(to, from, path, seen) {\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n\n  path = path || '';\n  seen = seen || new WeakSet();\n\n  if (seen.has(from)) {\n    return;\n  }\n  seen.add(from);\n\n  while (i < len) {\n    key = keys[i++];\n    if (!path) {\n      if (key === 'discriminators' ||\n        key === 'base' ||\n        key === '_applyDiscriminators' ||\n        key === '_userProvidedOptions' ||\n        key === 'options') {\n        continue;\n      }\n    }\n    if (path === 'tree' && from != null && from.instanceOfSchema) {\n      continue;\n    }\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (isObject(from[key])) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null) {\n        // Skip merging schemas if we're creating a discriminator schema and\n        // base schema has a given path as a single nested but discriminator schema\n        // has the path as a document array, or vice versa (gh-9534)\n        if ((from[key].$isSingleNested && to[key].$isMongooseDocumentArray) ||\n              (from[key].$isMongooseDocumentArray && to[key].$isSingleNested) ||\n              (from[key].$isMongooseDocumentArrayElement && to[key].$isMongooseDocumentArrayElement)) {\n          continue;\n        } else if (from[key].instanceOfSchema) {\n          if (to[key].instanceOfSchema) {\n            schemaMerge(to[key], from[key].clone(), true);\n          } else {\n            to[key] = from[key].clone();\n          }\n          continue;\n        } else if (isBsonType(from[key], 'ObjectId')) {\n          to[key] = new ObjectId(from[key]);\n          continue;\n        }\n      }\n      mergeDiscriminatorSchema(to[key], from[key], path ? path + '.' + key : key, seen);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL21lcmdlRGlzY3JpbWluYXRvclNjaGVtYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG9CQUFvQixtQkFBTyxDQUFDLDBGQUFpQjtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQywrR0FBaUM7QUFDbkUsbUJBQW1CLG1CQUFPLENBQUMsaUdBQTBCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLHlGQUFzQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyw2RkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcZGlzY3JpbWluYXRvclxcbWVyZ2VEaXNjcmltaW5hdG9yU2NoZW1hLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IHNjaGVtYU1lcmdlID0gcmVxdWlyZSgnLi4vc2NoZW1hL21lcmdlJyk7XG5jb25zdCBzcGVjaWFsUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3BlY2lhbFByb3BlcnRpZXMnKTtcbmNvbnN0IGlzQnNvblR5cGUgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2lzQnNvblR5cGUnKTtcbmNvbnN0IE9iamVjdElkID0gcmVxdWlyZSgnLi4vLi4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9pc09iamVjdCcpO1xuLyoqXG4gKiBNZXJnZXMgYGZyb21gIGludG8gYHRvYCB3aXRob3V0IG92ZXJ3cml0aW5nIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZURpc2NyaW1pbmF0b3JTY2hlbWEodG8sIGZyb20sIHBhdGgsIHNlZW4pIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQga2V5O1xuXG4gIHBhdGggPSBwYXRoIHx8ICcnO1xuICBzZWVuID0gc2VlbiB8fCBuZXcgV2Vha1NldCgpO1xuXG4gIGlmIChzZWVuLmhhcyhmcm9tKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZWVuLmFkZChmcm9tKTtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGtleSA9IGtleXNbaSsrXTtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIGlmIChrZXkgPT09ICdkaXNjcmltaW5hdG9ycycgfHxcbiAgICAgICAga2V5ID09PSAnYmFzZScgfHxcbiAgICAgICAga2V5ID09PSAnX2FwcGx5RGlzY3JpbWluYXRvcnMnIHx8XG4gICAgICAgIGtleSA9PT0gJ191c2VyUHJvdmlkZWRPcHRpb25zJyB8fFxuICAgICAgICBrZXkgPT09ICdvcHRpb25zJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdGggPT09ICd0cmVlJyAmJiBmcm9tICE9IG51bGwgJiYgZnJvbS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHRvW2tleV0gPT0gbnVsbCkge1xuICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZyb21ba2V5XSkpIHtcbiAgICAgIGlmICghaXNPYmplY3QodG9ba2V5XSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGZyb21ba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFNraXAgbWVyZ2luZyBzY2hlbWFzIGlmIHdlJ3JlIGNyZWF0aW5nIGEgZGlzY3JpbWluYXRvciBzY2hlbWEgYW5kXG4gICAgICAgIC8vIGJhc2Ugc2NoZW1hIGhhcyBhIGdpdmVuIHBhdGggYXMgYSBzaW5nbGUgbmVzdGVkIGJ1dCBkaXNjcmltaW5hdG9yIHNjaGVtYVxuICAgICAgICAvLyBoYXMgdGhlIHBhdGggYXMgYSBkb2N1bWVudCBhcnJheSwgb3IgdmljZSB2ZXJzYSAoZ2gtOTUzNClcbiAgICAgICAgaWYgKChmcm9tW2tleV0uJGlzU2luZ2xlTmVzdGVkICYmIHRvW2tleV0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB8fFxuICAgICAgICAgICAgICAoZnJvbVtrZXldLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJiB0b1trZXldLiRpc1NpbmdsZU5lc3RlZCkgfHxcbiAgICAgICAgICAgICAgKGZyb21ba2V5XS4kaXNNb25nb29zZURvY3VtZW50QXJyYXlFbGVtZW50ICYmIHRvW2tleV0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChmcm9tW2tleV0uaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgICAgICAgIGlmICh0b1trZXldLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYU1lcmdlKHRvW2tleV0sIGZyb21ba2V5XS5jbG9uZSgpLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XS5jbG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jzb25UeXBlKGZyb21ba2V5XSwgJ09iamVjdElkJykpIHtcbiAgICAgICAgICB0b1trZXldID0gbmV3IE9iamVjdElkKGZyb21ba2V5XSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1lcmdlRGlzY3JpbWluYXRvclNjaGVtYSh0b1trZXldLCBmcm9tW2tleV0sIHBhdGggPyBwYXRoICsgJy4nICsga2V5IDoga2V5LCBzZWVuKTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/document/applyDefaults.js":
/*!*****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/document/applyDefaults.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isNestedProjection = __webpack_require__(/*! ../projection/isNestedProjection */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js\");\n\nmodule.exports = function applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && doc.$__.skipId) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;\n        if ((curPath in fields && !isNestedProjection(fields[curPath])) || (j === len - 1 && hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath])) {\n          included = true;\n        } else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (isBeforeSetters != null) {\n          if (typeof type.defaultValue === 'function') {\n            if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n              break;\n            }\n            if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n              break;\n            }\n          } else if (!isBeforeSetters) {\n            // Non-function defaults should always run **before** setters\n            continue;\n          }\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              applyChangeTracking(doc, p);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              applyChangeTracking(doc, p);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            applyChangeTracking(doc, p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction applyChangeTracking(doc, fullPath) {\n  doc.$__.activePaths.default(fullPath);\n  if (doc.$isSubdocument && doc.$isSingleNested && doc.$parent() != null) {\n    doc.$parent().$__.activePaths.default(doc.$__pathRelativeToParent(fullPath));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9hcHBseURlZmF1bHRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDJCQUEyQixtQkFBTyxDQUFDLDRIQUFrQzs7QUFFckU7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXGRvY3VtZW50XFxhcHBseURlZmF1bHRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNOZXN0ZWRQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi4vcHJvamVjdGlvbi9pc05lc3RlZFByb2plY3Rpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBseURlZmF1bHRzKGRvYywgZmllbGRzLCBleGNsdWRlLCBoYXNJbmNsdWRlZENoaWxkcmVuLCBpc0JlZm9yZVNldHRlcnMsIHBhdGhzVG9Ta2lwKSB7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoZG9jLiRfX3NjaGVtYS5wYXRocyk7XG4gIGNvbnN0IHBsZW4gPSBwYXRocy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGVuOyArK2kpIHtcbiAgICBsZXQgZGVmO1xuICAgIGxldCBjdXJQYXRoID0gJyc7XG4gICAgY29uc3QgcCA9IHBhdGhzW2ldO1xuXG4gICAgaWYgKHAgPT09ICdfaWQnICYmIGRvYy4kX18uc2tpcElkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gZG9jLiRfX3NjaGVtYS5wYXRoc1twXTtcbiAgICBjb25zdCBwYXRoID0gdHlwZS5zcGxpdFBhdGgoKTtcbiAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICBsZXQgaW5jbHVkZWQgPSBmYWxzZTtcbiAgICBsZXQgZG9jXyA9IGRvYy5fZG9jO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyArK2opIHtcbiAgICAgIGlmIChkb2NfID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBpZWNlID0gcGF0aFtqXTtcbiAgICAgIGN1clBhdGggKz0gKCFjdXJQYXRoLmxlbmd0aCA/ICcnIDogJy4nKSArIHBpZWNlO1xuXG4gICAgICBpZiAoZXhjbHVkZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoY3VyUGF0aCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGNsdWRlID09PSBmYWxzZSAmJiBmaWVsZHMgJiYgIWluY2x1ZGVkKSB7XG4gICAgICAgIGNvbnN0IGhhc1N1YnBhdGhzID0gdHlwZS4kaXNTaW5nbGVOZXN0ZWQgfHwgdHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXk7XG4gICAgICAgIGlmICgoY3VyUGF0aCBpbiBmaWVsZHMgJiYgIWlzTmVzdGVkUHJvamVjdGlvbihmaWVsZHNbY3VyUGF0aF0pKSB8fCAoaiA9PT0gbGVuIC0gMSAmJiBoYXNTdWJwYXRocyAmJiBoYXNJbmNsdWRlZENoaWxkcmVuICE9IG51bGwgJiYgaGFzSW5jbHVkZWRDaGlsZHJlbltjdXJQYXRoXSkpIHtcbiAgICAgICAgICBpbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzSW5jbHVkZWRDaGlsZHJlbiAhPSBudWxsICYmICFoYXNJbmNsdWRlZENoaWxkcmVuW2N1clBhdGhdKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGogPT09IGxlbiAtIDEpIHtcbiAgICAgICAgaWYgKGRvY19bcGllY2VdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JlZm9yZVNldHRlcnMgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZS5kZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICghdHlwZS5kZWZhdWx0VmFsdWUuJHJ1bkJlZm9yZVNldHRlcnMgJiYgaXNCZWZvcmVTZXR0ZXJzKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUuZGVmYXVsdFZhbHVlLiRydW5CZWZvcmVTZXR0ZXJzICYmICFpc0JlZm9yZVNldHRlcnMpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghaXNCZWZvcmVTZXR0ZXJzKSB7XG4gICAgICAgICAgICAvLyBOb24tZnVuY3Rpb24gZGVmYXVsdHMgc2hvdWxkIGFsd2F5cyBydW4gKipiZWZvcmUqKiBzZXR0ZXJzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aHNUb1NraXAgJiYgcGF0aHNUb1NraXBbY3VyUGF0aF0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWVsZHMgJiYgZXhjbHVkZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChleGNsdWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBhcHBseSBkZWZhdWx0cyB0byBhbGwgbm9uLWV4Y2x1ZGVkIGZpZWxkc1xuICAgICAgICAgICAgaWYgKHAgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBkZWYgPSB0eXBlLmdldERlZmF1bHQoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgZG9jLmludmFsaWRhdGUocCwgZXJyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBkb2NfW3BpZWNlXSA9IGRlZjtcbiAgICAgICAgICAgICAgYXBwbHlDaGFuZ2VUcmFja2luZyhkb2MsIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZWQpIHtcbiAgICAgICAgICAgIC8vIHNlbGVjdGVkIGZpZWxkXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBkZWYgPSB0eXBlLmdldERlZmF1bHQoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgZG9jLmludmFsaWRhdGUocCwgZXJyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBkb2NfW3BpZWNlXSA9IGRlZjtcbiAgICAgICAgICAgICAgYXBwbHlDaGFuZ2VUcmFja2luZyhkb2MsIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmID0gdHlwZS5nZXREZWZhdWx0KGRvYywgZmFsc2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZG9jLmludmFsaWRhdGUocCwgZXJyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgZGVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZG9jX1twaWVjZV0gPSBkZWY7XG4gICAgICAgICAgICBhcHBseUNoYW5nZVRyYWNraW5nKGRvYywgcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2NfID0gZG9jX1twaWVjZV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlVHJhY2tpbmcoZG9jLCBmdWxsUGF0aCkge1xuICBkb2MuJF9fLmFjdGl2ZVBhdGhzLmRlZmF1bHQoZnVsbFBhdGgpO1xuICBpZiAoZG9jLiRpc1N1YmRvY3VtZW50ICYmIGRvYy4kaXNTaW5nbGVOZXN0ZWQgJiYgZG9jLiRwYXJlbnQoKSAhPSBudWxsKSB7XG4gICAgZG9jLiRwYXJlbnQoKS4kX18uYWN0aXZlUGF0aHMuZGVmYXVsdChkb2MuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQoZnVsbFBhdGgpKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/document/applyDefaults.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js ***!
  \*************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function cleanModifiedSubpaths(doc, path, options) {\n  options = options || {};\n  const skipDocArrays = options.skipDocArrays;\n\n  let deleted = 0;\n  if (!doc) {\n    return deleted;\n  }\n\n  for (const modifiedPath of Object.keys(doc.$__.activePaths.getStatePaths('modify'))) {\n    if (skipDocArrays) {\n      const schemaType = doc.$__schema.path(modifiedPath);\n      if (schemaType && schemaType.$isMongooseDocumentArray) {\n        continue;\n      }\n    }\n    if (modifiedPath.startsWith(path + '.')) {\n      doc.$__.activePaths.clearPath(modifiedPath);\n      ++deleted;\n\n      if (doc.$isSubdocument) {\n        const owner = doc.ownerDocument();\n        const fullPath = doc.$__fullPath(modifiedPath);\n        owner.$__.activePaths.clearPath(fullPath);\n      }\n    }\n  }\n  return deleted;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9jbGVhbk1vZGlmaWVkU3VicGF0aHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxkb2N1bWVudFxcY2xlYW5Nb2RpZmllZFN1YnBhdGhzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNsZWFuTW9kaWZpZWRTdWJwYXRocyhkb2MsIHBhdGgsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHNraXBEb2NBcnJheXMgPSBvcHRpb25zLnNraXBEb2NBcnJheXM7XG5cbiAgbGV0IGRlbGV0ZWQgPSAwO1xuICBpZiAoIWRvYykge1xuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgZm9yIChjb25zdCBtb2RpZmllZFBhdGggb2YgT2JqZWN0LmtleXMoZG9jLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdtb2RpZnknKSkpIHtcbiAgICBpZiAoc2tpcERvY0FycmF5cykge1xuICAgICAgY29uc3Qgc2NoZW1hVHlwZSA9IGRvYy4kX19zY2hlbWEucGF0aChtb2RpZmllZFBhdGgpO1xuICAgICAgaWYgKHNjaGVtYVR5cGUgJiYgc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtb2RpZmllZFBhdGguc3RhcnRzV2l0aChwYXRoICsgJy4nKSkge1xuICAgICAgZG9jLiRfXy5hY3RpdmVQYXRocy5jbGVhclBhdGgobW9kaWZpZWRQYXRoKTtcbiAgICAgICsrZGVsZXRlZDtcblxuICAgICAgaWYgKGRvYy4kaXNTdWJkb2N1bWVudCkge1xuICAgICAgICBjb25zdCBvd25lciA9IGRvYy5vd25lckRvY3VtZW50KCk7XG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gZG9jLiRfX2Z1bGxQYXRoKG1vZGlmaWVkUGF0aCk7XG4gICAgICAgIG93bmVyLiRfXy5hY3RpdmVQYXRocy5jbGVhclBhdGgoZnVsbFBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVsZXRlZDtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/document/compile.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/document/compile.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../../helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst documentSchemaSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").documentSchemaSymbol);\nconst internalToObjectOptions = (__webpack_require__(/*! ../../options */ \"(api)/../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nlet Document;\nconst getSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").getSymbol);\nconst scopeSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").scopeSymbol);\n\nconst isPOJO = utils.isPOJO;\n\n/*!\n * exports\n */\n\nexports.compile = compile;\nexports.defineKey = defineKey;\n\nconst _isEmptyOptions = Object.freeze({\n  minimize: true,\n  virtuals: false,\n  getters: false,\n  transform: false\n});\n\nconst noDottedPathGetOptions = Object.freeze({\n  noDottedPath: true\n});\n\n/**\n * Compiles schemas.\n * @param {Object} tree\n * @param {Any} proto\n * @param {String} prefix\n * @param {Object} options\n * @api private\n */\n\nfunction compile(tree, proto, prefix, options) {\n  Document = Document || __webpack_require__(/*! ../../document */ \"(api)/../server/node_modules/mongoose/lib/document.js\");\n  const typeKey = options.typeKey;\n\n  for (const key of Object.keys(tree)) {\n    const limb = tree[key];\n\n    const hasSubprops = isPOJO(limb) &&\n      Object.keys(limb).length > 0 &&\n      (!limb[typeKey] || (typeKey === 'type' && isPOJO(limb.type) && limb.type.type));\n    const subprops = hasSubprops ? limb : null;\n\n    defineKey({ prop: key, subprops: subprops, prototype: proto, prefix: prefix, options: options });\n  }\n}\n\n/**\n * Defines the accessor named prop on the incoming prototype.\n * @param {Object} options\n * @param {String} options.prop\n * @param {Boolean} options.subprops\n * @param {Any} options.prototype\n * @param {String} [options.prefix]\n * @param {Object} options.options\n * @api private\n */\n\nfunction defineKey({ prop, subprops, prototype, prefix, options }) {\n  Document = Document || __webpack_require__(/*! ../../document */ \"(api)/../server/node_modules/mongoose/lib/document.js\");\n  const path = (prefix ? prefix + '.' : '') + prop;\n  prefix = prefix || '';\n  const useGetOptions = prefix ? Object.freeze({}) : noDottedPathGetOptions;\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        const _this = this;\n        if (!this.$__.getters) {\n          this.$__.getters = {};\n        }\n\n        if (!this.$__.getters[path]) {\n          const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));\n\n          // save scope for nested getters/setters\n          if (!prefix) {\n            nested.$__[scopeSymbol] = this;\n          }\n          nested.$__.nestedPath = path;\n\n          Object.defineProperty(nested, 'schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, '$__schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, documentSchemaSymbol, {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, 'toObject', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return clone(_this.get(path, null, {\n                virtuals: this &&\n                  this.schema &&\n                  this.schema.options &&\n                  this.schema.options.toObject &&\n                  this.schema.options.toObject.virtuals || null\n              }));\n            }\n          });\n\n          Object.defineProperty(nested, '$__get', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path, null, {\n                virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null\n              });\n            }\n          });\n\n          Object.defineProperty(nested, 'toJSON', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path, null, {\n                virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null\n              });\n            }\n          });\n\n          Object.defineProperty(nested, '$__isNested', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: true\n          });\n\n          Object.defineProperty(nested, '$isEmpty', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;\n            }\n          });\n\n          Object.defineProperty(nested, '$__parent', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: this\n          });\n\n          compile(subprops, nested, path, options);\n          this.$__.getters[path] = nested;\n        }\n\n        return this.$__.getters[path];\n      },\n      set: function(v) {\n        if (v != null && v.$__isNested) {\n          // Convert top-level to POJO, but leave subdocs hydrated so `$set`\n          // can handle them. See gh-9293.\n          v = v.$__get();\n        } else if (v instanceof Document && !v.$__isNested) {\n          v = v.$toObject(internalToObjectOptions);\n        }\n        const doc = this.$__[scopeSymbol] || this;\n        doc.$set(path, v);\n      }\n    });\n  } else {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        return this[getSymbol].call(\n          this.$__[scopeSymbol] || this,\n          path,\n          null,\n          useGetOptions\n        );\n      },\n      set: function(v) {\n        this.$set.call(this.$__[scopeSymbol] || this, path, v);\n      }\n    });\n  }\n}\n\n// gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\nfunction getOwnPropertyDescriptors(object) {\n  const result = {};\n\n  Object.getOwnPropertyNames(object).forEach(function(key) {\n    const skip = [\n      'isNew',\n      '$__',\n      '$errors',\n      'errors',\n      '_doc',\n      '$locals',\n      '$op',\n      '__parentArray',\n      '__index',\n      '$isDocumentArrayElement'\n    ].indexOf(key) === -1;\n    if (skip) {\n      return;\n    }\n\n    result[key] = Object.getOwnPropertyDescriptor(object, key);\n    result[key].enumerable = false;\n  });\n\n  return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9jb21waWxlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDM0MsNkJBQTZCLHVJQUFxRDtBQUNsRixnQ0FBZ0MsMEhBQWdEO0FBQ2hGLGNBQWMsbUJBQU8sQ0FBQyx1RUFBYTs7QUFFbkM7QUFDQSxrQkFBa0IsNEhBQTBDO0FBQzVELG9CQUFvQiw4SEFBNEM7O0FBRWhFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2YsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUZBQW1GO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUEscUJBQXFCLDRDQUE0QztBQUNqRSx5QkFBeUIsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDakQ7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxkb2N1bWVudFxcY29tcGlsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgZG9jdW1lbnRTY2hlbWFTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5kb2N1bWVudFNjaGVtYVN5bWJvbDtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi4vLi4vb3B0aW9ucycpLmludGVybmFsVG9PYmplY3RPcHRpb25zO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG5sZXQgRG9jdW1lbnQ7XG5jb25zdCBnZXRTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5nZXRTeW1ib2w7XG5jb25zdCBzY29wZVN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLnNjb3BlU3ltYm9sO1xuXG5jb25zdCBpc1BPSk8gPSB1dGlscy5pc1BPSk87XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XG5leHBvcnRzLmRlZmluZUtleSA9IGRlZmluZUtleTtcblxuY29uc3QgX2lzRW1wdHlPcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG4gIG1pbmltaXplOiB0cnVlLFxuICB2aXJ0dWFsczogZmFsc2UsXG4gIGdldHRlcnM6IGZhbHNlLFxuICB0cmFuc2Zvcm06IGZhbHNlXG59KTtcblxuY29uc3Qgbm9Eb3R0ZWRQYXRoR2V0T3B0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuICBub0RvdHRlZFBhdGg6IHRydWVcbn0pO1xuXG4vKipcbiAqIENvbXBpbGVzIHNjaGVtYXMuXG4gKiBAcGFyYW0ge09iamVjdH0gdHJlZVxuICogQHBhcmFtIHtBbnl9IHByb3RvXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZSh0cmVlLCBwcm90bywgcHJlZml4LCBvcHRpb25zKSB7XG4gIERvY3VtZW50ID0gRG9jdW1lbnQgfHwgcmVxdWlyZSgnLi4vLi4vZG9jdW1lbnQnKTtcbiAgY29uc3QgdHlwZUtleSA9IG9wdGlvbnMudHlwZUtleTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0cmVlKSkge1xuICAgIGNvbnN0IGxpbWIgPSB0cmVlW2tleV07XG5cbiAgICBjb25zdCBoYXNTdWJwcm9wcyA9IGlzUE9KTyhsaW1iKSAmJlxuICAgICAgT2JqZWN0LmtleXMobGltYikubGVuZ3RoID4gMCAmJlxuICAgICAgKCFsaW1iW3R5cGVLZXldIHx8ICh0eXBlS2V5ID09PSAndHlwZScgJiYgaXNQT0pPKGxpbWIudHlwZSkgJiYgbGltYi50eXBlLnR5cGUpKTtcbiAgICBjb25zdCBzdWJwcm9wcyA9IGhhc1N1YnByb3BzID8gbGltYiA6IG51bGw7XG5cbiAgICBkZWZpbmVLZXkoeyBwcm9wOiBrZXksIHN1YnByb3BzOiBzdWJwcm9wcywgcHJvdG90eXBlOiBwcm90bywgcHJlZml4OiBwcmVmaXgsIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBhY2Nlc3NvciBuYW1lZCBwcm9wIG9uIHRoZSBpbmNvbWluZyBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucHJvcFxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnN1YnByb3BzXG4gKiBAcGFyYW0ge0FueX0gb3B0aW9ucy5wcm90b3R5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcmVmaXhdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5vcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVLZXkoeyBwcm9wLCBzdWJwcm9wcywgcHJvdG90eXBlLCBwcmVmaXgsIG9wdGlvbnMgfSkge1xuICBEb2N1bWVudCA9IERvY3VtZW50IHx8IHJlcXVpcmUoJy4uLy4uL2RvY3VtZW50Jyk7XG4gIGNvbnN0IHBhdGggPSAocHJlZml4ID8gcHJlZml4ICsgJy4nIDogJycpICsgcHJvcDtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuICBjb25zdCB1c2VHZXRPcHRpb25zID0gcHJlZml4ID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiBub0RvdHRlZFBhdGhHZXRPcHRpb25zO1xuXG4gIGlmIChzdWJwcm9wcykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIHByb3AsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy4kX18uZ2V0dGVycykge1xuICAgICAgICAgIHRoaXMuJF9fLmdldHRlcnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy4kX18uZ2V0dGVyc1twYXRoXSkge1xuICAgICAgICAgIGNvbnN0IG5lc3RlZCA9IE9iamVjdC5jcmVhdGUoRG9jdW1lbnQucHJvdG90eXBlLCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcblxuICAgICAgICAgIC8vIHNhdmUgc2NvcGUgZm9yIG5lc3RlZCBnZXR0ZXJzL3NldHRlcnNcbiAgICAgICAgICBpZiAoIXByZWZpeCkge1xuICAgICAgICAgICAgbmVzdGVkLiRfX1tzY29wZVN5bWJvbF0gPSB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXN0ZWQuJF9fLm5lc3RlZFBhdGggPSBwYXRoO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lc3RlZCwgJ3NjaGVtYScsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHByb3RvdHlwZS5zY2hlbWFcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsICckX19zY2hlbWEnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBwcm90b3R5cGUuc2NoZW1hXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmVzdGVkLCBkb2N1bWVudFNjaGVtYVN5bWJvbCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogcHJvdG90eXBlLnNjaGVtYVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lc3RlZCwgJ3RvT2JqZWN0Jywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZShfdGhpcy5nZXQocGF0aCwgbnVsbCwge1xuICAgICAgICAgICAgICAgIHZpcnR1YWxzOiB0aGlzICYmXG4gICAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYSAmJlxuICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlbWEub3B0aW9ucyAmJlxuICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlbWEub3B0aW9ucy50b09iamVjdCAmJlxuICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlbWEub3B0aW9ucy50b09iamVjdC52aXJ0dWFscyB8fCBudWxsXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsICckX19nZXQnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldChwYXRoLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgdmlydHVhbHM6IHRoaXMgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEub3B0aW9ucyAmJiB0aGlzLnNjaGVtYS5vcHRpb25zLnRvT2JqZWN0ICYmIHRoaXMuc2NoZW1hLm9wdGlvbnMudG9PYmplY3QudmlydHVhbHMgfHwgbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsICd0b0pTT04nLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldChwYXRoLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgdmlydHVhbHM6IHRoaXMgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEub3B0aW9ucyAmJiB0aGlzLnNjaGVtYS5vcHRpb25zLnRvSlNPTiAmJiB0aGlzLnNjaGVtYS5vcHRpb25zLnRvSlNPTi52aXJ0dWFscyB8fCBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lc3RlZCwgJyRfX2lzTmVzdGVkJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lc3RlZCwgJyRpc0VtcHR5Jywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldChwYXRoLCBudWxsLCBfaXNFbXB0eU9wdGlvbnMpIHx8IHt9KS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmVzdGVkLCAnJF9fcGFyZW50Jywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdGhpc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29tcGlsZShzdWJwcm9wcywgbmVzdGVkLCBwYXRoLCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLiRfXy5nZXR0ZXJzW3BhdGhdID0gbmVzdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9fLmdldHRlcnNbcGF0aF07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIGlmICh2ICE9IG51bGwgJiYgdi4kX19pc05lc3RlZCkge1xuICAgICAgICAgIC8vIENvbnZlcnQgdG9wLWxldmVsIHRvIFBPSk8sIGJ1dCBsZWF2ZSBzdWJkb2NzIGh5ZHJhdGVkIHNvIGAkc2V0YFxuICAgICAgICAgIC8vIGNhbiBoYW5kbGUgdGhlbS4gU2VlIGdoLTkyOTMuXG4gICAgICAgICAgdiA9IHYuJF9fZ2V0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIERvY3VtZW50ICYmICF2LiRfX2lzTmVzdGVkKSB7XG4gICAgICAgICAgdiA9IHYuJHRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2MgPSB0aGlzLiRfX1tzY29wZVN5bWJvbF0gfHwgdGhpcztcbiAgICAgICAgZG9jLiRzZXQocGF0aCwgdik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2dldFN5bWJvbF0uY2FsbChcbiAgICAgICAgICB0aGlzLiRfX1tzY29wZVN5bWJvbF0gfHwgdGhpcyxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgdXNlR2V0T3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLiRzZXQuY2FsbCh0aGlzLiRfX1tzY29wZVN5bWJvbF0gfHwgdGhpcywgcGF0aCwgdik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gZ2V0cyBkZXNjcmlwdG9ycyBmb3IgYWxsIHByb3BlcnRpZXMgb2YgYG9iamVjdGBcbi8vIG1ha2VzIGFsbCBwcm9wZXJ0aWVzIG5vbi1lbnVtZXJhYmxlIHRvIG1hdGNoIHByZXZpb3VzIGJlaGF2aW9yIHRvICMyMjExXG5mdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgY29uc3Qgc2tpcCA9IFtcbiAgICAgICdpc05ldycsXG4gICAgICAnJF9fJyxcbiAgICAgICckZXJyb3JzJyxcbiAgICAgICdlcnJvcnMnLFxuICAgICAgJ19kb2MnLFxuICAgICAgJyRsb2NhbHMnLFxuICAgICAgJyRvcCcsXG4gICAgICAnX19wYXJlbnRBcnJheScsXG4gICAgICAnX19pbmRleCcsXG4gICAgICAnJGlzRG9jdW1lbnRBcnJheUVsZW1lbnQnXG4gICAgXS5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgIGlmIChza2lwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzdWx0W2tleV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwga2V5KTtcbiAgICByZXN1bHRba2V5XS5lbnVtZXJhYmxlID0gZmFsc2U7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/document/compile.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js":
/*!********************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Find the deepest subdocument along a given path to ensure setter functions run\n * with the correct subdocument as `this`. If no subdocuments, returns the top-level\n * document.\n *\n * @param {Document} doc\n * @param {String[]} parts\n * @param {Schema} schema\n * @returns Document\n */\n\nmodule.exports = function getDeepestSubdocumentForPath(doc, parts, schema) {\n  let curPath = parts[0];\n  let curSchema = schema;\n  let subdoc = doc;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const curSchemaType = curSchema.path(curPath);\n    if (curSchemaType && curSchemaType.schema) {\n      let newSubdoc = subdoc.get(curPath);\n      curSchema = curSchemaType.schema;\n      curPath = parts[i + 1];\n      if (Array.isArray(newSubdoc) && !isNaN(curPath)) {\n        newSubdoc = newSubdoc[curPath];\n        curPath = '';\n      }\n      if (newSubdoc == null) {\n        break;\n      }\n      subdoc = newSubdoc;\n    } else {\n      curPath += curPath.length ? '.' + parts[i + 1] : parts[i + 1];\n    }\n  }\n\n  return subdoc;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9nZXREZWVwZXN0U3ViZG9jdW1lbnRGb3JQYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXGRvY3VtZW50XFxnZXREZWVwZXN0U3ViZG9jdW1lbnRGb3JQYXRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IHN1YmRvY3VtZW50IGFsb25nIGEgZ2l2ZW4gcGF0aCB0byBlbnN1cmUgc2V0dGVyIGZ1bmN0aW9ucyBydW5cbiAqIHdpdGggdGhlIGNvcnJlY3Qgc3ViZG9jdW1lbnQgYXMgYHRoaXNgLiBJZiBubyBzdWJkb2N1bWVudHMsIHJldHVybnMgdGhlIHRvcC1sZXZlbFxuICogZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXJ0c1xuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHJldHVybnMgRG9jdW1lbnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldERlZXBlc3RTdWJkb2N1bWVudEZvclBhdGgoZG9jLCBwYXJ0cywgc2NoZW1hKSB7XG4gIGxldCBjdXJQYXRoID0gcGFydHNbMF07XG4gIGxldCBjdXJTY2hlbWEgPSBzY2hlbWE7XG4gIGxldCBzdWJkb2MgPSBkb2M7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgY29uc3QgY3VyU2NoZW1hVHlwZSA9IGN1clNjaGVtYS5wYXRoKGN1clBhdGgpO1xuICAgIGlmIChjdXJTY2hlbWFUeXBlICYmIGN1clNjaGVtYVR5cGUuc2NoZW1hKSB7XG4gICAgICBsZXQgbmV3U3ViZG9jID0gc3ViZG9jLmdldChjdXJQYXRoKTtcbiAgICAgIGN1clNjaGVtYSA9IGN1clNjaGVtYVR5cGUuc2NoZW1hO1xuICAgICAgY3VyUGF0aCA9IHBhcnRzW2kgKyAxXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5ld1N1YmRvYykgJiYgIWlzTmFOKGN1clBhdGgpKSB7XG4gICAgICAgIG5ld1N1YmRvYyA9IG5ld1N1YmRvY1tjdXJQYXRoXTtcbiAgICAgICAgY3VyUGF0aCA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1N1YmRvYyA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3ViZG9jID0gbmV3U3ViZG9jO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJQYXRoICs9IGN1clBhdGgubGVuZ3RoID8gJy4nICsgcGFydHNbaSArIDFdIDogcGFydHNbaSArIDFdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJkb2M7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js":
/*!********************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getSchemaDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getSchemaDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\");\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n *\n * @param {Document} doc\n * @param {String|String[]} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {\n  options = options || {};\n  const typeOnly = options.typeOnly;\n  const parts = Array.isArray(path) ?\n    path :\n    (path.indexOf('.') === -1 ? [path] : path.split('.'));\n  let schemaType = null;\n  let type = 'adhocOrUndefined';\n\n  const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = parts.slice(0, i + 1).join('.');\n    schemaType = schema.path(subpath);\n    if (schemaType == null) {\n      type = 'adhocOrUndefined';\n      continue;\n    }\n    if (schemaType.instance === 'Mixed') {\n      return typeOnly ? 'real' : schemaType;\n    }\n    type = schema.pathType(subpath);\n    if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) &&\n    schemaType.schema.discriminators != null) {\n      const discriminators = schemaType.schema.discriminators;\n      const discriminatorKey = doc.get(subpath + '.' +\n        get(schemaType, 'schema.options.discriminatorKey'));\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);\n    }\n  }\n\n  // Are we getting the whole schema or just the type, 'real', 'nested', etc.\n  return typeOnly ? type : schemaType;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9nZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx3RUFBUTtBQUM1QixzQ0FBc0MsbUJBQU8sQ0FBQyx3SkFBZ0Q7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxkb2N1bWVudFxcZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuY29uc3QgZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuLi9kaXNjcmltaW5hdG9yL2dldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5cbi8qKlxuICogTGlrZSBgc2NoZW1hLnBhdGgoKWAsIGV4Y2VwdCB3aXRoIGEgZG9jdW1lbnQsIGJlY2F1c2UgaW1wb3NzaWJsZSB0b1xuICogZGV0ZXJtaW5lIHBhdGggdHlwZSB3aXRob3V0IGtub3dpbmcgdGhlIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3Iga2V5LlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aChkb2MsIHBhdGgsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHR5cGVPbmx5ID0gb3B0aW9ucy50eXBlT25seTtcbiAgY29uc3QgcGFydHMgPSBBcnJheS5pc0FycmF5KHBhdGgpID9cbiAgICBwYXRoIDpcbiAgICAocGF0aC5pbmRleE9mKCcuJykgPT09IC0xID8gW3BhdGhdIDogcGF0aC5zcGxpdCgnLicpKTtcbiAgbGV0IHNjaGVtYVR5cGUgPSBudWxsO1xuICBsZXQgdHlwZSA9ICdhZGhvY09yVW5kZWZpbmVkJztcblxuICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZShkb2Muc2NoZW1hLCBkb2MuZ2V0KGRvYy5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5KSkgfHwgZG9jLnNjaGVtYTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qgc3VicGF0aCA9IHBhcnRzLnNsaWNlKDAsIGkgKyAxKS5qb2luKCcuJyk7XG4gICAgc2NoZW1hVHlwZSA9IHNjaGVtYS5wYXRoKHN1YnBhdGgpO1xuICAgIGlmIChzY2hlbWFUeXBlID09IG51bGwpIHtcbiAgICAgIHR5cGUgPSAnYWRob2NPclVuZGVmaW5lZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVR5cGUuaW5zdGFuY2UgPT09ICdNaXhlZCcpIHtcbiAgICAgIHJldHVybiB0eXBlT25seSA/ICdyZWFsJyA6IHNjaGVtYVR5cGU7XG4gICAgfVxuICAgIHR5cGUgPSBzY2hlbWEucGF0aFR5cGUoc3VicGF0aCk7XG4gICAgaWYgKChzY2hlbWFUeXBlLiRpc1NpbmdsZU5lc3RlZCB8fCBzY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheUVsZW1lbnQpICYmXG4gICAgc2NoZW1hVHlwZS5zY2hlbWEuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgZGlzY3JpbWluYXRvcnMgPSBzY2hlbWFUeXBlLnNjaGVtYS5kaXNjcmltaW5hdG9ycztcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBkb2MuZ2V0KHN1YnBhdGggKyAnLicgK1xuICAgICAgICBnZXQoc2NoZW1hVHlwZSwgJ3NjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXknKSk7XG4gICAgICBpZiAoZGlzY3JpbWluYXRvcktleSA9PSBudWxsIHx8IGRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JLZXldID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN0ID0gcGFydHMuc2xpY2UoaSArIDEpLmpvaW4oJy4nKTtcbiAgICAgIHJldHVybiBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoKGRvYy5nZXQoc3VicGF0aCksIHJlc3QsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFyZSB3ZSBnZXR0aW5nIHRoZSB3aG9sZSBzY2hlbWEgb3IganVzdCB0aGUgdHlwZSwgJ3JlYWwnLCAnbmVzdGVkJywgZXRjLlxuICByZXR1cm4gdHlwZU9ubHkgPyB0eXBlIDogc2NoZW1hVHlwZTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nconst keysToSkip = new Set(['__index', '__parentArray', '_doc']);\n\n/**\n * Using spread operator on a Mongoose document gives you a\n * POJO that has a tendency to cause infinite recursion. So\n * we use this function on `set()` to prevent that.\n */\n\nmodule.exports = function handleSpreadDoc(v, includeExtraKeys) {\n  if (utils.isPOJO(v) && v.$__ != null && v._doc != null) {\n    if (includeExtraKeys) {\n      const extraKeys = {};\n      for (const key of Object.keys(v)) {\n        if (typeof key === 'symbol') {\n          continue;\n        }\n        if (key[0] === '$') {\n          continue;\n        }\n        if (keysToSkip.has(key)) {\n          continue;\n        }\n        extraKeys[key] = v[key];\n      }\n      return { ...v._doc, ...extraKeys };\n    }\n    return v._doc;\n  }\n\n  return v;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9oYW5kbGVTcHJlYWREb2MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHVFQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcZG9jdW1lbnRcXGhhbmRsZVNwcmVhZERvYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuY29uc3Qga2V5c1RvU2tpcCA9IG5ldyBTZXQoWydfX2luZGV4JywgJ19fcGFyZW50QXJyYXknLCAnX2RvYyddKTtcblxuLyoqXG4gKiBVc2luZyBzcHJlYWQgb3BlcmF0b3Igb24gYSBNb25nb29zZSBkb2N1bWVudCBnaXZlcyB5b3UgYVxuICogUE9KTyB0aGF0IGhhcyBhIHRlbmRlbmN5IHRvIGNhdXNlIGluZmluaXRlIHJlY3Vyc2lvbi4gU29cbiAqIHdlIHVzZSB0aGlzIGZ1bmN0aW9uIG9uIGBzZXQoKWAgdG8gcHJldmVudCB0aGF0LlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFuZGxlU3ByZWFkRG9jKHYsIGluY2x1ZGVFeHRyYUtleXMpIHtcbiAgaWYgKHV0aWxzLmlzUE9KTyh2KSAmJiB2LiRfXyAhPSBudWxsICYmIHYuX2RvYyAhPSBudWxsKSB7XG4gICAgaWYgKGluY2x1ZGVFeHRyYUtleXMpIHtcbiAgICAgIGNvbnN0IGV4dHJhS2V5cyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXNUb1NraXAuaGFzKGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBleHRyYUtleXNba2V5XSA9IHZba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLnYuX2RvYywgLi4uZXh0cmFLZXlzIH07XG4gICAgfVxuICAgIHJldHVybiB2Ll9kb2M7XG4gIH1cblxuICByZXR1cm4gdjtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/each.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/each.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function each(arr, cb, done) {\n  if (arr.length === 0) {\n    return done();\n  }\n\n  let remaining = arr.length;\n  let err = null;\n  for (const v of arr) {\n    cb(v, function(_err) {\n      if (err != null) {\n        return;\n      }\n      if (_err != null) {\n        err = _err;\n        return done(err);\n      }\n\n      if (--remaining <= 0) {\n        return done();\n      }\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9lYWNoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxlYWNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlYWNoKGFyciwgY2IsIGRvbmUpIHtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZG9uZSgpO1xuICB9XG5cbiAgbGV0IHJlbWFpbmluZyA9IGFyci5sZW5ndGg7XG4gIGxldCBlcnIgPSBudWxsO1xuICBmb3IgKGNvbnN0IHYgb2YgYXJyKSB7XG4gICAgY2IodiwgZnVuY3Rpb24oX2Vycikge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChfZXJyICE9IG51bGwpIHtcbiAgICAgICAgZXJyID0gX2VycjtcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKC0tcmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/each.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/error/combinePathErrors.js":
/*!******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/error/combinePathErrors.js ***!
  \******************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function combinePathErrors(err) {\n  const keys = Object.keys(err.errors || {});\n  const len = keys.length;\n  const msgs = [];\n  let key;\n\n  for (let i = 0; i < len; ++i) {\n    key = keys[i];\n    if (err === err.errors[key]) {\n      continue;\n    }\n    msgs.push(key + ': ' + err.errors[key].message);\n  }\n\n  return msgs.join(', ');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9lcnJvci9jb21iaW5lUGF0aEVycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcZXJyb3JcXGNvbWJpbmVQYXRoRXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVQYXRoRXJyb3JzKGVycikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXJyLmVycm9ycyB8fCB7fSk7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBjb25zdCBtc2dzID0gW107XG4gIGxldCBrZXk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgaWYgKGVyciA9PT0gZXJyLmVycm9yc1trZXldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbXNncy5wdXNoKGtleSArICc6ICcgKyBlcnIuZXJyb3JzW2tleV0ubWVzc2FnZSk7XG4gIH1cblxuICByZXR1cm4gbXNncy5qb2luKCcsICcpO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/error/combinePathErrors.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/firstKey.js":
/*!***************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/firstKey.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function firstKey(obj) {\n  if (obj == null) {\n    return null;\n  }\n  return Object.keys(obj)[0];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9maXJzdEtleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxmaXJzdEtleS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlyc3RLZXkob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopWzBdO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/firstKey.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/get.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/get.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Simplified lodash.get to work around the annoying null quirk. See:\n * https://github.com/lodash/lodash/issues/3659\n * @api private\n */\n\nmodule.exports = function get(obj, path, def) {\n  let parts;\n  let isPathArray = false;\n  if (typeof path === 'string') {\n    if (path.indexOf('.') === -1) {\n      const _v = getProperty(obj, path);\n      if (_v == null) {\n        return def;\n      }\n      return _v;\n    }\n\n    parts = path.split('.');\n  } else {\n    isPathArray = true;\n    parts = path;\n\n    if (parts.length === 1) {\n      const _v = getProperty(obj, parts[0]);\n      if (_v == null) {\n        return def;\n      }\n      return _v;\n    }\n  }\n  let rest = path;\n  let cur = obj;\n  for (const part of parts) {\n    if (cur == null) {\n      return def;\n    }\n\n    // `lib/cast.js` depends on being able to get dotted paths in updates,\n    // like `{ $set: { 'a.b': 42 } }`\n    if (!isPathArray && cur[rest] != null) {\n      return cur[rest];\n    }\n\n    cur = getProperty(cur, part);\n\n    if (!isPathArray) {\n      rest = rest.substr(part.length + 1);\n    }\n  }\n\n  return cur == null ? def : cur;\n};\n\nfunction getProperty(obj, prop) {\n  if (obj == null) {\n    return obj;\n  }\n  if (obj instanceof Map) {\n    return obj.get(prop);\n  }\n  return obj[prop];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9nZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUSxhQUFhO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXGdldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltcGxpZmllZCBsb2Rhc2guZ2V0IHRvIHdvcmsgYXJvdW5kIHRoZSBhbm5veWluZyBudWxsIHF1aXJrLiBTZWU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9pc3N1ZXMvMzY1OVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXQob2JqLCBwYXRoLCBkZWYpIHtcbiAgbGV0IHBhcnRzO1xuICBsZXQgaXNQYXRoQXJyYXkgPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIGlmIChwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IF92ID0gZ2V0UHJvcGVydHkob2JqLCBwYXRoKTtcbiAgICAgIGlmIChfdiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Y7XG4gICAgfVxuXG4gICAgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIH0gZWxzZSB7XG4gICAgaXNQYXRoQXJyYXkgPSB0cnVlO1xuICAgIHBhcnRzID0gcGF0aDtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IF92ID0gZ2V0UHJvcGVydHkob2JqLCBwYXJ0c1swXSk7XG4gICAgICBpZiAoX3YgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF92O1xuICAgIH1cbiAgfVxuICBsZXQgcmVzdCA9IHBhdGg7XG4gIGxldCBjdXIgPSBvYmo7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmIChjdXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG5cbiAgICAvLyBgbGliL2Nhc3QuanNgIGRlcGVuZHMgb24gYmVpbmcgYWJsZSB0byBnZXQgZG90dGVkIHBhdGhzIGluIHVwZGF0ZXMsXG4gICAgLy8gbGlrZSBgeyAkc2V0OiB7ICdhLmInOiA0MiB9IH1gXG4gICAgaWYgKCFpc1BhdGhBcnJheSAmJiBjdXJbcmVzdF0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGN1cltyZXN0XTtcbiAgICB9XG5cbiAgICBjdXIgPSBnZXRQcm9wZXJ0eShjdXIsIHBhcnQpO1xuXG4gICAgaWYgKCFpc1BhdGhBcnJheSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKHBhcnQubGVuZ3RoICsgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1ciA9PSBudWxsID8gZGVmIDogY3VyO1xufTtcblxuZnVuY3Rpb24gZ2V0UHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHJldHVybiBvYmouZ2V0KHByb3ApO1xuICB9XG4gIHJldHVybiBvYmpbcHJvcF07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/get.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/getConstructorName.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * If `val` is an object, returns constructor name, if possible. Otherwise returns undefined.\n * @api private\n */\n\nmodule.exports = function getConstructorName(val) {\n  if (val == null) {\n    return void 0;\n  }\n  if (typeof val.constructor !== 'function') {\n    return void 0;\n  }\n  return val.constructor.name;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9nZXRDb25zdHJ1Y3Rvck5hbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcZ2V0Q29uc3RydWN0b3JOYW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBJZiBgdmFsYCBpcyBhbiBvYmplY3QsIHJldHVybnMgY29uc3RydWN0b3IgbmFtZSwgaWYgcG9zc2libGUuIE90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3JOYW1lKHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsLmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yLm5hbWU7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js":
/*!********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nfunction getDefaultBulkwriteResult() {\n  return {\n    result: {\n      ok: 1,\n      writeErrors: [],\n      writeConcernErrors: [],\n      insertedIds: [],\n      nInserted: 0,\n      nUpserted: 0,\n      nMatched: 0,\n      nModified: 0,\n      nRemoved: 0,\n      upserted: []\n    },\n    insertedCount: 0,\n    matchedCount: 0,\n    modifiedCount: 0,\n    deletedCount: 0,\n    upsertedCount: 0,\n    upsertedIds: {},\n    insertedIds: {},\n    n: 0\n  };\n}\n\nmodule.exports = getDefaultBulkwriteResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9nZXREZWZhdWx0QnVsa3dyaXRlUmVzdWx0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcZ2V0RGVmYXVsdEJ1bGt3cml0ZVJlc3VsdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5mdW5jdGlvbiBnZXREZWZhdWx0QnVsa3dyaXRlUmVzdWx0KCkge1xuICByZXR1cm4ge1xuICAgIHJlc3VsdDoge1xuICAgICAgb2s6IDEsXG4gICAgICB3cml0ZUVycm9yczogW10sXG4gICAgICB3cml0ZUNvbmNlcm5FcnJvcnM6IFtdLFxuICAgICAgaW5zZXJ0ZWRJZHM6IFtdLFxuICAgICAgbkluc2VydGVkOiAwLFxuICAgICAgblVwc2VydGVkOiAwLFxuICAgICAgbk1hdGNoZWQ6IDAsXG4gICAgICBuTW9kaWZpZWQ6IDAsXG4gICAgICBuUmVtb3ZlZDogMCxcbiAgICAgIHVwc2VydGVkOiBbXVxuICAgIH0sXG4gICAgaW5zZXJ0ZWRDb3VudDogMCxcbiAgICBtYXRjaGVkQ291bnQ6IDAsXG4gICAgbW9kaWZpZWRDb3VudDogMCxcbiAgICBkZWxldGVkQ291bnQ6IDAsXG4gICAgdXBzZXJ0ZWRDb3VudDogMCxcbiAgICB1cHNlcnRlZElkczoge30sXG4gICAgaW5zZXJ0ZWRJZHM6IHt9LFxuICAgIG46IDBcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXREZWZhdWx0QnVsa3dyaXRlUmVzdWx0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/getFunctionName.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/getFunctionName.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst functionNameRE = /^function\\s*([^\\s(]+)/;\n\nmodule.exports = function(fn) {\n  return (\n    fn.name ||\n    (fn.toString().trim().match(functionNameRE) || [])[1]\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9nZXRGdW5jdGlvbk5hbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcZ2V0RnVuY3Rpb25OYW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZnVuY3Rpb25OYW1lUkUgPSAvXmZ1bmN0aW9uXFxzKihbXlxccyhdKykvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiAoXG4gICAgZm4ubmFtZSB8fFxuICAgIChmbi50b1N0cmluZygpLnRyaW0oKS5tYXRjaChmdW5jdGlvbk5hbWVSRSkgfHwgW10pWzFdXG4gICk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/getFunctionName.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/immediate.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/immediate.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Centralize this so we can more easily work around issues with people\n * stubbing out `process.nextTick()` in tests using sinon:\n * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time\n * See gh-6074\n */\n\n\n\nconst nextTick = typeof process !== 'undefined' && typeof process.nextTick === 'function' ?\n  process.nextTick.bind(process) :\n  cb => setTimeout(cb, 0); // Fallback for browser build\n\nmodule.exports = function immediate(cb) {\n  return nextTick(cb);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbW1lZGlhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXGltbWVkaWF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENlbnRyYWxpemUgdGhpcyBzbyB3ZSBjYW4gbW9yZSBlYXNpbHkgd29yayBhcm91bmQgaXNzdWVzIHdpdGggcGVvcGxlXG4gKiBzdHViYmluZyBvdXQgYHByb2Nlc3MubmV4dFRpY2soKWAgaW4gdGVzdHMgdXNpbmcgc2lub246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vc2lub25qcy9sb2xleCNhdXRvbWF0aWNhbGx5LWluY3JlbWVudGluZy1tb2NrZWQtdGltZVxuICogU2VlIGdoLTYwNzRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IG5leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nID9cbiAgcHJvY2Vzcy5uZXh0VGljay5iaW5kKHByb2Nlc3MpIDpcbiAgY2IgPT4gc2V0VGltZW91dChjYiwgMCk7IC8vIEZhbGxiYWNrIGZvciBicm93c2VyIGJ1aWxkXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW1tZWRpYXRlKGNiKSB7XG4gIHJldHVybiBuZXh0VGljayhjYik7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js":
/*!***********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isTextIndex = __webpack_require__(/*! ./isTextIndex */ \"(api)/../server/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js\");\n\nmodule.exports = function applySchemaCollation(indexKeys, indexOptions, schemaOptions) {\n  if (isTextIndex(indexKeys)) {\n    return;\n  }\n\n  if (schemaOptions.hasOwnProperty('collation') && !indexOptions.hasOwnProperty('collation')) {\n    indexOptions.collation = schemaOptions.collation;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2FwcGx5U2NoZW1hQ29sbGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLCtGQUFlOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXGluZGV4ZXNcXGFwcGx5U2NoZW1hQ29sbGF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNUZXh0SW5kZXggPSByZXF1aXJlKCcuL2lzVGV4dEluZGV4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBwbHlTY2hlbWFDb2xsYXRpb24oaW5kZXhLZXlzLCBpbmRleE9wdGlvbnMsIHNjaGVtYU9wdGlvbnMpIHtcbiAgaWYgKGlzVGV4dEluZGV4KGluZGV4S2V5cykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc2NoZW1hT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29sbGF0aW9uJykgJiYgIWluZGV4T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29sbGF0aW9uJykpIHtcbiAgICBpbmRleE9wdGlvbnMuY29sbGF0aW9uID0gc2NoZW1hT3B0aW9ucy5jb2xsYXRpb247XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js":
/*!************************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function decorateDiscriminatorIndexOptions(schema, indexOptions) {\n  // If the model is a discriminator and has an index, add a\n  // partialFilterExpression by default so the index will only apply\n  // to that discriminator.\n  const discriminatorName = schema.discriminatorMapping && schema.discriminatorMapping.value;\n  if (discriminatorName && !('sparse' in indexOptions)) {\n    const discriminatorKey = schema.options.discriminatorKey;\n    indexOptions.partialFilterExpression = indexOptions.partialFilterExpression || {};\n    indexOptions.partialFilterExpression[discriminatorKey] = discriminatorName;\n  }\n  return indexOptions;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2RlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxpbmRleGVzXFxkZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucyhzY2hlbWEsIGluZGV4T3B0aW9ucykge1xuICAvLyBJZiB0aGUgbW9kZWwgaXMgYSBkaXNjcmltaW5hdG9yIGFuZCBoYXMgYW4gaW5kZXgsIGFkZCBhXG4gIC8vIHBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uIGJ5IGRlZmF1bHQgc28gdGhlIGluZGV4IHdpbGwgb25seSBhcHBseVxuICAvLyB0byB0aGF0IGRpc2NyaW1pbmF0b3IuXG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JOYW1lID0gc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nICYmIHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZTtcbiAgaWYgKGRpc2NyaW1pbmF0b3JOYW1lICYmICEoJ3NwYXJzZScgaW4gaW5kZXhPcHRpb25zKSkge1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICAgIGluZGV4T3B0aW9ucy5wYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiA9IGluZGV4T3B0aW9ucy5wYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiB8fCB7fTtcbiAgICBpbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb25bZGlzY3JpbWluYXRvcktleV0gPSBkaXNjcmltaW5hdG9yTmFtZTtcbiAgfVxuICByZXR1cm4gaW5kZXhPcHRpb25zO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js":
/*!********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction getRelatedSchemaIndexes(model, schemaIndexes) {\n  return getRelatedIndexes({\n    baseModelName: model.baseModelName,\n    discriminatorMapping: model.schema.discriminatorMapping,\n    indexes: schemaIndexes,\n    indexesType: 'schema'\n  });\n}\n\nfunction getRelatedDBIndexes(model, dbIndexes) {\n  return getRelatedIndexes({\n    baseModelName: model.baseModelName,\n    discriminatorMapping: model.schema.discriminatorMapping,\n    indexes: dbIndexes,\n    indexesType: 'db'\n  });\n}\n\nmodule.exports = {\n  getRelatedSchemaIndexes,\n  getRelatedDBIndexes\n};\n\nfunction getRelatedIndexes({\n  baseModelName,\n  discriminatorMapping,\n  indexes,\n  indexesType\n}) {\n  const discriminatorKey = discriminatorMapping && discriminatorMapping.key;\n  const discriminatorValue = discriminatorMapping && discriminatorMapping.value;\n\n  if (!discriminatorKey) {\n    return indexes;\n  }\n\n  const isChildDiscriminatorModel = Boolean(baseModelName);\n  if (isChildDiscriminatorModel) {\n    return indexes.filter(index => {\n      const partialFilterExpression = getPartialFilterExpression(index, indexesType);\n      return partialFilterExpression && partialFilterExpression[discriminatorKey] === discriminatorValue;\n    });\n  }\n\n  return indexes.filter(index => {\n    const partialFilterExpression = getPartialFilterExpression(index, indexesType);\n    return !partialFilterExpression || !partialFilterExpression[discriminatorKey];\n  });\n}\n\nfunction getPartialFilterExpression(index, indexesType) {\n  if (indexesType === 'schema') {\n    const options = index[1];\n    return options && options.partialFilterExpression;\n  }\n  return index.partialFilterExpression;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2dldFJlbGF0ZWRJbmRleGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXGluZGV4ZXNcXGdldFJlbGF0ZWRJbmRleGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0UmVsYXRlZFNjaGVtYUluZGV4ZXMobW9kZWwsIHNjaGVtYUluZGV4ZXMpIHtcbiAgcmV0dXJuIGdldFJlbGF0ZWRJbmRleGVzKHtcbiAgICBiYXNlTW9kZWxOYW1lOiBtb2RlbC5iYXNlTW9kZWxOYW1lLFxuICAgIGRpc2NyaW1pbmF0b3JNYXBwaW5nOiBtb2RlbC5zY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcsXG4gICAgaW5kZXhlczogc2NoZW1hSW5kZXhlcyxcbiAgICBpbmRleGVzVHlwZTogJ3NjaGVtYSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbGF0ZWREQkluZGV4ZXMobW9kZWwsIGRiSW5kZXhlcykge1xuICByZXR1cm4gZ2V0UmVsYXRlZEluZGV4ZXMoe1xuICAgIGJhc2VNb2RlbE5hbWU6IG1vZGVsLmJhc2VNb2RlbE5hbWUsXG4gICAgZGlzY3JpbWluYXRvck1hcHBpbmc6IG1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyxcbiAgICBpbmRleGVzOiBkYkluZGV4ZXMsXG4gICAgaW5kZXhlc1R5cGU6ICdkYidcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRSZWxhdGVkU2NoZW1hSW5kZXhlcyxcbiAgZ2V0UmVsYXRlZERCSW5kZXhlc1xufTtcblxuZnVuY3Rpb24gZ2V0UmVsYXRlZEluZGV4ZXMoe1xuICBiYXNlTW9kZWxOYW1lLFxuICBkaXNjcmltaW5hdG9yTWFwcGluZyxcbiAgaW5kZXhlcyxcbiAgaW5kZXhlc1R5cGVcbn0pIHtcbiAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IGRpc2NyaW1pbmF0b3JNYXBwaW5nICYmIGRpc2NyaW1pbmF0b3JNYXBwaW5nLmtleTtcbiAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gZGlzY3JpbWluYXRvck1hcHBpbmcgJiYgZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWU7XG5cbiAgaWYgKCFkaXNjcmltaW5hdG9yS2V5KSB7XG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cblxuICBjb25zdCBpc0NoaWxkRGlzY3JpbWluYXRvck1vZGVsID0gQm9vbGVhbihiYXNlTW9kZWxOYW1lKTtcbiAgaWYgKGlzQ2hpbGREaXNjcmltaW5hdG9yTW9kZWwpIHtcbiAgICByZXR1cm4gaW5kZXhlcy5maWx0ZXIoaW5kZXggPT4ge1xuICAgICAgY29uc3QgcGFydGlhbEZpbHRlckV4cHJlc3Npb24gPSBnZXRQYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbihpbmRleCwgaW5kZXhlc1R5cGUpO1xuICAgICAgcmV0dXJuIHBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uICYmIHBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uW2Rpc2NyaW1pbmF0b3JLZXldID09PSBkaXNjcmltaW5hdG9yVmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gaW5kZXhlcy5maWx0ZXIoaW5kZXggPT4ge1xuICAgIGNvbnN0IHBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uID0gZ2V0UGFydGlhbEZpbHRlckV4cHJlc3Npb24oaW5kZXgsIGluZGV4ZXNUeXBlKTtcbiAgICByZXR1cm4gIXBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uIHx8ICFwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbltkaXNjcmltaW5hdG9yS2V5XTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uKGluZGV4LCBpbmRleGVzVHlwZSkge1xuICBpZiAoaW5kZXhlc1R5cGUgPT09ICdzY2hlbWEnKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGluZGV4WzFdO1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb247XG4gIH1cbiAgcmV0dXJuIGluZGV4LnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = function isDefaultIdIndex(index) {\n  if (Array.isArray(index)) {\n    // Mongoose syntax\n    const keys = Object.keys(index[0]);\n    return keys.length === 1 && keys[0] === '_id' && index[0]._id !== 'hashed';\n  }\n\n  if (typeof index !== 'object') {\n    return false;\n  }\n\n  const key = get(index, 'key', {});\n  return Object.keys(key).length === 1 && key.hasOwnProperty('_id');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2lzRGVmYXVsdElkSW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHdFQUFROztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcaW5kZXhlc1xcaXNEZWZhdWx0SWRJbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRGVmYXVsdElkSW5kZXgoaW5kZXgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5kZXgpKSB7XG4gICAgLy8gTW9uZ29vc2Ugc3ludGF4XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGluZGV4WzBdKTtcbiAgICByZXR1cm4ga2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ19pZCcgJiYgaW5kZXhbMF0uX2lkICE9PSAnaGFzaGVkJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qga2V5ID0gZ2V0KGluZGV4LCAna2V5Jywge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMoa2V5KS5sZW5ndGggPT09IDEgJiYga2V5Lmhhc093blByb3BlcnR5KCdfaWQnKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n/**\n * Given a Mongoose index definition (key + options objects) and a MongoDB server\n * index definition, determine if the two indexes are equal.\n *\n * @param {Object} schemaIndexKeysObject the Mongoose index spec\n * @param {Object} options the Mongoose index definition's options\n * @param {Object} dbIndex the index in MongoDB as returned by `listIndexes()`\n * @api private\n */\n\nmodule.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {\n  // Special case: text indexes have a special format in the db. For example,\n  // `{ name: 'text' }` becomes:\n  // {\n  //   v: 2,\n  //   key: { _fts: 'text', _ftsx: 1 },\n  //   name: 'name_text',\n  //   ns: 'test.tests',\n  //   background: true,\n  //   weights: { name: 1 },\n  //   default_language: 'english',\n  //   language_override: 'language',\n  //   textIndexVersion: 3\n  // }\n  if (dbIndex.textIndexVersion != null) {\n    delete dbIndex.key._fts;\n    delete dbIndex.key._ftsx;\n    const weights = { ...dbIndex.weights, ...dbIndex.key };\n    if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {\n      return false;\n    }\n    for (const prop of Object.keys(weights)) {\n      if (!(prop in schemaIndexKeysObject)) {\n        return false;\n      }\n      const weight = weights[prop];\n      if (weight !== get(options, 'weights.' + prop) && !(weight === 1 && get(options, 'weights.' + prop) == null)) {\n        return false;\n      }\n    }\n\n    if (options['default_language'] !== dbIndex['default_language']) {\n      return dbIndex['default_language'] === 'english' && options['default_language'] == null;\n    }\n\n    return true;\n  }\n\n  const optionKeys = [\n    'unique',\n    'partialFilterExpression',\n    'sparse',\n    'expireAfterSeconds',\n    'collation'\n  ];\n  for (const key of optionKeys) {\n    if (!(key in options) && !(key in dbIndex)) {\n      continue;\n    }\n    if (key === 'collation') {\n      if (options[key] == null || dbIndex[key] == null) {\n        return options[key] == null && dbIndex[key] == null;\n      }\n      const definedKeys = Object.keys(options.collation);\n      const schemaCollation = options.collation;\n      const dbCollation = dbIndex.collation;\n      for (const opt of definedKeys) {\n        if (get(schemaCollation, opt) !== get(dbCollation, opt)) {\n          return false;\n        }\n      }\n    } else if (!utils.deepEqual(options[key], dbIndex[key])) {\n      return false;\n    }\n  }\n\n  const schemaIndexKeys = Object.keys(schemaIndexKeysObject);\n  const dbIndexKeys = Object.keys(dbIndex.key);\n  if (schemaIndexKeys.length !== dbIndexKeys.length) {\n    return false;\n  }\n  for (let i = 0; i < schemaIndexKeys.length; ++i) {\n    if (schemaIndexKeys[i] !== dbIndexKeys[i]) {\n      return false;\n    }\n    if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2lzSW5kZXhFcXVhbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsd0VBQVE7QUFDNUIsY0FBYyxtQkFBTyxDQUFDLHVFQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXGluZGV4ZXNcXGlzSW5kZXhFcXVhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuLyoqXG4gKiBHaXZlbiBhIE1vbmdvb3NlIGluZGV4IGRlZmluaXRpb24gKGtleSArIG9wdGlvbnMgb2JqZWN0cykgYW5kIGEgTW9uZ29EQiBzZXJ2ZXJcbiAqIGluZGV4IGRlZmluaXRpb24sIGRldGVybWluZSBpZiB0aGUgdHdvIGluZGV4ZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFJbmRleEtleXNPYmplY3QgdGhlIE1vbmdvb3NlIGluZGV4IHNwZWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBNb25nb29zZSBpbmRleCBkZWZpbml0aW9uJ3Mgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGRiSW5kZXggdGhlIGluZGV4IGluIE1vbmdvREIgYXMgcmV0dXJuZWQgYnkgYGxpc3RJbmRleGVzKClgXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW5kZXhFcXVhbChzY2hlbWFJbmRleEtleXNPYmplY3QsIG9wdGlvbnMsIGRiSW5kZXgpIHtcbiAgLy8gU3BlY2lhbCBjYXNlOiB0ZXh0IGluZGV4ZXMgaGF2ZSBhIHNwZWNpYWwgZm9ybWF0IGluIHRoZSBkYi4gRm9yIGV4YW1wbGUsXG4gIC8vIGB7IG5hbWU6ICd0ZXh0JyB9YCBiZWNvbWVzOlxuICAvLyB7XG4gIC8vICAgdjogMixcbiAgLy8gICBrZXk6IHsgX2Z0czogJ3RleHQnLCBfZnRzeDogMSB9LFxuICAvLyAgIG5hbWU6ICduYW1lX3RleHQnLFxuICAvLyAgIG5zOiAndGVzdC50ZXN0cycsXG4gIC8vICAgYmFja2dyb3VuZDogdHJ1ZSxcbiAgLy8gICB3ZWlnaHRzOiB7IG5hbWU6IDEgfSxcbiAgLy8gICBkZWZhdWx0X2xhbmd1YWdlOiAnZW5nbGlzaCcsXG4gIC8vICAgbGFuZ3VhZ2Vfb3ZlcnJpZGU6ICdsYW5ndWFnZScsXG4gIC8vICAgdGV4dEluZGV4VmVyc2lvbjogM1xuICAvLyB9XG4gIGlmIChkYkluZGV4LnRleHRJbmRleFZlcnNpb24gIT0gbnVsbCkge1xuICAgIGRlbGV0ZSBkYkluZGV4LmtleS5fZnRzO1xuICAgIGRlbGV0ZSBkYkluZGV4LmtleS5fZnRzeDtcbiAgICBjb25zdCB3ZWlnaHRzID0geyAuLi5kYkluZGV4LndlaWdodHMsIC4uLmRiSW5kZXgua2V5IH07XG4gICAgaWYgKE9iamVjdC5rZXlzKHdlaWdodHMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoc2NoZW1hSW5kZXhLZXlzT2JqZWN0KS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5rZXlzKHdlaWdodHMpKSB7XG4gICAgICBpZiAoIShwcm9wIGluIHNjaGVtYUluZGV4S2V5c09iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2VpZ2h0ID0gd2VpZ2h0c1twcm9wXTtcbiAgICAgIGlmICh3ZWlnaHQgIT09IGdldChvcHRpb25zLCAnd2VpZ2h0cy4nICsgcHJvcCkgJiYgISh3ZWlnaHQgPT09IDEgJiYgZ2V0KG9wdGlvbnMsICd3ZWlnaHRzLicgKyBwcm9wKSA9PSBudWxsKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNbJ2RlZmF1bHRfbGFuZ3VhZ2UnXSAhPT0gZGJJbmRleFsnZGVmYXVsdF9sYW5ndWFnZSddKSB7XG4gICAgICByZXR1cm4gZGJJbmRleFsnZGVmYXVsdF9sYW5ndWFnZSddID09PSAnZW5nbGlzaCcgJiYgb3B0aW9uc1snZGVmYXVsdF9sYW5ndWFnZSddID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBvcHRpb25LZXlzID0gW1xuICAgICd1bmlxdWUnLFxuICAgICdwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbicsXG4gICAgJ3NwYXJzZScsXG4gICAgJ2V4cGlyZUFmdGVyU2Vjb25kcycsXG4gICAgJ2NvbGxhdGlvbidcbiAgXTtcbiAgZm9yIChjb25zdCBrZXkgb2Ygb3B0aW9uS2V5cykge1xuICAgIGlmICghKGtleSBpbiBvcHRpb25zKSAmJiAhKGtleSBpbiBkYkluZGV4KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChrZXkgPT09ICdjb2xsYXRpb24nKSB7XG4gICAgICBpZiAob3B0aW9uc1trZXldID09IG51bGwgfHwgZGJJbmRleFtrZXldID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNba2V5XSA9PSBudWxsICYmIGRiSW5kZXhba2V5XSA9PSBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVmaW5lZEtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zLmNvbGxhdGlvbik7XG4gICAgICBjb25zdCBzY2hlbWFDb2xsYXRpb24gPSBvcHRpb25zLmNvbGxhdGlvbjtcbiAgICAgIGNvbnN0IGRiQ29sbGF0aW9uID0gZGJJbmRleC5jb2xsYXRpb247XG4gICAgICBmb3IgKGNvbnN0IG9wdCBvZiBkZWZpbmVkS2V5cykge1xuICAgICAgICBpZiAoZ2V0KHNjaGVtYUNvbGxhdGlvbiwgb3B0KSAhPT0gZ2V0KGRiQ29sbGF0aW9uLCBvcHQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdXRpbHMuZGVlcEVxdWFsKG9wdGlvbnNba2V5XSwgZGJJbmRleFtrZXldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNjaGVtYUluZGV4S2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYUluZGV4S2V5c09iamVjdCk7XG4gIGNvbnN0IGRiSW5kZXhLZXlzID0gT2JqZWN0LmtleXMoZGJJbmRleC5rZXkpO1xuICBpZiAoc2NoZW1hSW5kZXhLZXlzLmxlbmd0aCAhPT0gZGJJbmRleEtleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hSW5kZXhLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHNjaGVtYUluZGV4S2V5c1tpXSAhPT0gZGJJbmRleEtleXNbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCF1dGlscy5kZWVwRXF1YWwoc2NoZW1hSW5kZXhLZXlzT2JqZWN0W3NjaGVtYUluZGV4S2V5c1tpXV0sIGRiSW5kZXgua2V5W2RiSW5kZXhLZXlzW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Returns `true` if the given index options have a `text` option.\n */\n\nmodule.exports = function isTextIndex(indexKeys) {\n  let isTextIndex = false;\n  for (const key of Object.keys(indexKeys)) {\n    if (indexKeys[key] === 'text') {\n      isTextIndex = true;\n    }\n  }\n\n  return isTextIndex;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2lzVGV4dEluZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcaW5kZXhlc1xcaXNUZXh0SW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpbmRleCBvcHRpb25zIGhhdmUgYSBgdGV4dGAgb3B0aW9uLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUZXh0SW5kZXgoaW5kZXhLZXlzKSB7XG4gIGxldCBpc1RleHRJbmRleCA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbmRleEtleXMpKSB7XG4gICAgaWYgKGluZGV4S2V5c1trZXldID09PSAndGV4dCcpIHtcbiAgICAgIGlzVGV4dEluZGV4ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNUZXh0SW5kZXg7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/isAsyncFunction.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isAsyncFunction.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isAsyncFunction(v) {\n  return (\n    typeof v === 'function' &&\n    v.constructor &&\n    v.constructor.name === 'AsyncFunction'\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc0FzeW5jRnVuY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxpc0FzeW5jRnVuY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2KSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHYgPT09ICdmdW5jdGlvbicgJiZcbiAgICB2LmNvbnN0cnVjdG9yICYmXG4gICAgdi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXN5bmNGdW5jdGlvbidcbiAgKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/isAsyncFunction.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js":
/*!*****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isBsonType.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Get the bson type, if it exists\n * @api private\n */\n\nfunction isBsonType(obj, typename) {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    obj._bsontype === typename\n  );\n}\n\nmodule.exports = isBsonType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc0Jzb25UeXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcaXNCc29uVHlwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0IHRoZSBic29uIHR5cGUsIGlmIGl0IGV4aXN0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCc29uVHlwZShvYmosIHR5cGVuYW1lKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcbiAgICBvYmogIT09IG51bGwgJiZcbiAgICBvYmouX2Jzb250eXBlID09PSB0eXBlbmFtZVxuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnNvblR5cGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/isMongooseObject.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isMongooseObject.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isMongooseArray = (__webpack_require__(/*! ../types/array/isMongooseArray */ \"(api)/../server/node_modules/mongoose/lib/types/array/isMongooseArray.js\").isMongooseArray);\n/**\n * Returns if `v` is a mongoose object that has a `toObject()` method we can use.\n *\n * This is for compatibility with libs like Date.js which do foolish things to Natives.\n *\n * @param {Any} v\n * @api private\n */\n\nmodule.exports = function(v) {\n  return (\n    v != null && (\n      isMongooseArray(v) || // Array or Document Array\n      v.$__ != null || // Document\n      v.isMongooseBuffer || // Buffer\n      v.$isMongooseMap // Map\n    )\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc01vbmdvb3NlT2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHdCQUF3Qix1SkFBeUQ7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcaXNNb25nb29zZU9iamVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzTW9uZ29vc2VBcnJheSA9IHJlcXVpcmUoJy4uL3R5cGVzL2FycmF5L2lzTW9uZ29vc2VBcnJheScpLmlzTW9uZ29vc2VBcnJheTtcbi8qKlxuICogUmV0dXJucyBpZiBgdmAgaXMgYSBtb25nb29zZSBvYmplY3QgdGhhdCBoYXMgYSBgdG9PYmplY3QoKWAgbWV0aG9kIHdlIGNhbiB1c2UuXG4gKlxuICogVGhpcyBpcyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGxpYnMgbGlrZSBEYXRlLmpzIHdoaWNoIGRvIGZvb2xpc2ggdGhpbmdzIHRvIE5hdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gKFxuICAgIHYgIT0gbnVsbCAmJiAoXG4gICAgICBpc01vbmdvb3NlQXJyYXkodikgfHwgLy8gQXJyYXkgb3IgRG9jdW1lbnQgQXJyYXlcbiAgICAgIHYuJF9fICE9IG51bGwgfHwgLy8gRG9jdW1lbnRcbiAgICAgIHYuaXNNb25nb29zZUJ1ZmZlciB8fCAvLyBCdWZmZXJcbiAgICAgIHYuJGlzTW9uZ29vc2VNYXAgLy8gTWFwXG4gICAgKVxuICApO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/isMongooseObject.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/isObject.js":
/*!***************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isObject.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nmodule.exports = function(arg) {\n  return (\n    Buffer.isBuffer(arg) ||\n    Object.prototype.toString.call(arg) === '[object Object]'\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc09iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRDtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxpc09iamVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYXJnYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfEZ1bmN0aW9ufFJlZ0V4cHxhbnl9IGFyZ1xuICogQGFwaSBwcml2YXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiAoXG4gICAgQnVmZmVyLmlzQnVmZmVyKGFyZykgfHxcbiAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbiAgKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/isObject.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/isPOJO.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isPOJO.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isPOJO(arg) {\n  if (arg == null || typeof arg !== 'object') {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(arg);\n  // Prototype may be null if you used `Object.create(null)`\n  // Checking `proto`'s constructor is safe because `getPrototypeOf()`\n  // explicitly crosses the boundary from object data to object metadata\n  return !proto || proto.constructor.name === 'Object';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc1BPSk8uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxpc1BPSk8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUE9KTyhhcmcpIHtcbiAgaWYgKGFyZyA9PSBudWxsIHx8IHR5cGVvZiBhcmcgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGFyZyk7XG4gIC8vIFByb3RvdHlwZSBtYXkgYmUgbnVsbCBpZiB5b3UgdXNlZCBgT2JqZWN0LmNyZWF0ZShudWxsKWBcbiAgLy8gQ2hlY2tpbmcgYHByb3RvYCdzIGNvbnN0cnVjdG9yIGlzIHNhZmUgYmVjYXVzZSBgZ2V0UHJvdG90eXBlT2YoKWBcbiAgLy8gZXhwbGljaXRseSBjcm9zc2VzIHRoZSBib3VuZGFyeSBmcm9tIG9iamVjdCBkYXRhIHRvIG9iamVjdCBtZXRhZGF0YVxuICByZXR1cm4gIXByb3RvIHx8IHByb3RvLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/isPOJO.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/isPromise.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isPromise.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\nfunction isPromise(val) {\n  return !!val && (typeof val === 'object' || typeof val === 'function') && typeof val.then === 'function';\n}\n\nmodule.exports = isPromise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc1Byb21pc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxpc1Byb21pc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbCkge1xuICByZXR1cm4gISF2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb21pc2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/isPromise.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/isSimpleValidator.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/isSimpleValidator.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines if `arg` is a flat object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nmodule.exports = function isSimpleValidator(obj) {\n  const keys = Object.keys(obj);\n  let result = true;\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    if (typeof obj[keys[i]] === 'object' && obj[keys[i]] !== null) {\n      result = false;\n      break;\n    }\n  }\n\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc1NpbXBsZVZhbGlkYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUF5QztBQUNwRDtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxpc1NpbXBsZVZhbGlkYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYXJnYCBpcyBhIGZsYXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ3xGdW5jdGlvbnxSZWdFeHB8YW55fSBhcmdcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU2ltcGxlVmFsaWRhdG9yKG9iaikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IHJlc3VsdCA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBvYmpba2V5c1tpXV0gPT09ICdvYmplY3QnICYmIG9ialtrZXlzW2ldXSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/isSimpleValidator.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js":
/*!********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function applyDefaultsToPOJO(doc, schema) {\n  const paths = Object.keys(schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    const type = schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let doc_ = doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (j === len - 1) {\n        if (typeof doc_[piece] !== 'undefined') {\n          if (type.$isSingleNested) {\n            applyDefaultsToPOJO(doc_[piece], type.caster.schema);\n          } else if (type.$isMongooseDocumentArray && Array.isArray(doc_[piece])) {\n            doc_[piece].forEach(el => applyDefaultsToPOJO(el, type.schema));\n          }\n\n          break;\n        }\n\n        const def = type.getDefault(doc, false, { skipCast: true });\n        if (typeof def !== 'undefined') {\n          doc_[piece] = def;\n\n          if (type.$isSingleNested) {\n            applyDefaultsToPOJO(def, type.caster.schema);\n          } else if (type.$isMongooseDocumentArray && Array.isArray(def)) {\n            def.forEach(el => applyDefaultsToPOJO(el, type.schema));\n          }\n        }\n      } else {\n        if (doc_[piece] == null) {\n          doc_[piece] = {};\n        }\n        doc_ = doc_[piece];\n      }\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseURlZmF1bHRzVG9QT0pPLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcbW9kZWxcXGFwcGx5RGVmYXVsdHNUb1BPSk8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdHNUb1BPSk8oZG9jLCBzY2hlbWEpIHtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpO1xuICBjb25zdCBwbGVuID0gcGF0aHMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGxlbjsgKytpKSB7XG4gICAgbGV0IGN1clBhdGggPSAnJztcbiAgICBjb25zdCBwID0gcGF0aHNbaV07XG5cbiAgICBjb25zdCB0eXBlID0gc2NoZW1hLnBhdGhzW3BdO1xuICAgIGNvbnN0IHBhdGggPSB0eXBlLnNwbGl0UGF0aCgpO1xuICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgIGxldCBkb2NfID0gZG9jO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyArK2opIHtcbiAgICAgIGlmIChkb2NfID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBpZWNlID0gcGF0aFtqXTtcbiAgICAgIGN1clBhdGggKz0gKCFjdXJQYXRoLmxlbmd0aCA/ICcnIDogJy4nKSArIHBpZWNlO1xuXG4gICAgICBpZiAoaiA9PT0gbGVuIC0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIGRvY19bcGllY2VdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmICh0eXBlLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgICAgICAgYXBwbHlEZWZhdWx0c1RvUE9KTyhkb2NfW3BpZWNlXSwgdHlwZS5jYXN0ZXIuc2NoZW1hKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmIEFycmF5LmlzQXJyYXkoZG9jX1twaWVjZV0pKSB7XG4gICAgICAgICAgICBkb2NfW3BpZWNlXS5mb3JFYWNoKGVsID0+IGFwcGx5RGVmYXVsdHNUb1BPSk8oZWwsIHR5cGUuc2NoZW1hKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWYgPSB0eXBlLmdldERlZmF1bHQoZG9jLCBmYWxzZSwgeyBza2lwQ2FzdDogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZG9jX1twaWVjZV0gPSBkZWY7XG5cbiAgICAgICAgICBpZiAodHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgICAgIGFwcGx5RGVmYXVsdHNUb1BPSk8oZGVmLCB0eXBlLmNhc3Rlci5zY2hlbWEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiYgQXJyYXkuaXNBcnJheShkZWYpKSB7XG4gICAgICAgICAgICBkZWYuZm9yRWFjaChlbCA9PiBhcHBseURlZmF1bHRzVG9QT0pPKGVsLCB0eXBlLnNjaGVtYSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRvY19bcGllY2VdID09IG51bGwpIHtcbiAgICAgICAgICBkb2NfW3BpZWNlXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGRvY18gPSBkb2NfW3BpZWNlXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/model/applyHooks.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/applyHooks.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst symbols = __webpack_require__(/*! ../../schema/symbols */ \"(api)/../server/node_modules/mongoose/lib/schema/symbols.js\");\nconst promiseOrCallback = __webpack_require__(/*! ../promiseOrCallback */ \"(api)/../server/node_modules/mongoose/lib/helpers/promiseOrCallback.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = applyHooks;\n\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = [\n  'deleteOne',\n  'save',\n  'validate',\n  'remove',\n  'updateOne',\n  'init'\n];\n\n/*!\n * ignore\n */\n\nconst alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap(fn => ([fn, `$__${fn}`])));\n\n/**\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} options\n * @api private\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n\n  model.$appliedHooks = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    let childModel = null;\n    if (type.$isSingleNested) {\n      childModel = type.caster;\n    } else if (type.$isMongooseDocumentArray) {\n      childModel = type.Constructor;\n    } else {\n      continue;\n    }\n\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n\n    applyHooks(childModel, type.schema, options);\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n      for (const key of keys) {\n        applyHooks(childModel.discriminators[key],\n          childModel.discriminators[key].schema, options);\n      }\n    }\n  }\n\n  // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n  const middleware = schema.s.hooks.\n    filter(hook => {\n      if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n        return !!hook['document'];\n      }\n      if (hook.name === 'remove' || hook.name === 'init') {\n        return hook['document'] == null || !!hook['document'];\n      }\n      if (hook.query != null || hook.document != null) {\n        return hook.document !== false;\n      }\n      return true;\n    }).\n    filter(hook => {\n      // If user has overwritten the method, don't apply built-in middleware\n      if (schema.methods[hook.name]) {\n        return !hook.fn[symbols.builtInMiddleware];\n      }\n\n      return true;\n    });\n\n  model._middleware = middleware;\n\n  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;\n\n  for (const method of ['save', 'validate', 'remove', 'deleteOne']) {\n    const toWrap = method === 'validate' ? '$__originalValidate' : `$__${method}`;\n    const wrapped = middleware.\n      createWrapper(method, objToDecorate[toWrap], null, kareemOptions);\n    objToDecorate[`$__${method}`] = wrapped;\n  }\n  objToDecorate.$__init = middleware.\n    createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);\n\n  // Support hooks for custom methods\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n  for (const method of customMethods) {\n    if (alreadyHookedFunctions.has(method)) {\n      continue;\n    }\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n    const originalMethod = objToDecorate[method];\n    objToDecorate[method] = function() {\n      const args = Array.prototype.slice.call(arguments);\n      const cb = args.slice(-1).pop();\n      const argsWithoutCallback = typeof cb === 'function' ?\n        args.slice(0, args.length - 1) : args;\n      return promiseOrCallback(cb, callback => {\n        return this[`$__${method}`].apply(this,\n          argsWithoutCallback.concat([callback]));\n      }, model.events);\n    };\n    objToDecorate[`$__${method}`] = middleware.\n      createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseUhvb2tzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLHlGQUFzQjtBQUM5QywwQkFBMEIsbUJBQU8sQ0FBQyxvR0FBc0I7O0FBRXhEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0dBQWdHLEdBQUc7O0FBRW5HO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQSx5RUFBeUUsT0FBTztBQUNoRjtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxtb2RlbFxcYXBwbHlIb29rcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHN5bWJvbHMgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvc3ltYm9scycpO1xuY29uc3QgcHJvbWlzZU9yQ2FsbGJhY2sgPSByZXF1aXJlKCcuLi9wcm9taXNlT3JDYWxsYmFjaycpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlIb29rcztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5hcHBseUhvb2tzLm1pZGRsZXdhcmVGdW5jdGlvbnMgPSBbXG4gICdkZWxldGVPbmUnLFxuICAnc2F2ZScsXG4gICd2YWxpZGF0ZScsXG4gICdyZW1vdmUnLFxuICAndXBkYXRlT25lJyxcbiAgJ2luaXQnXG5dO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IGFscmVhZHlIb29rZWRGdW5jdGlvbnMgPSBuZXcgU2V0KGFwcGx5SG9va3MubWlkZGxld2FyZUZ1bmN0aW9ucy5mbGF0TWFwKGZuID0+IChbZm4sIGAkX18ke2ZufWBdKSkpO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGhvb2tzIGZvciB0aGlzIG1vZGVsXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseUhvb2tzKG1vZGVsLCBzY2hlbWEsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3Qga2FyZWVtT3B0aW9ucyA9IHtcbiAgICB1c2VFcnJvckhhbmRsZXJzOiB0cnVlLFxuICAgIG51bUNhbGxiYWNrUGFyYW1zOiAxLFxuICAgIG51bGxSZXN1bHRCeURlZmF1bHQ6IHRydWUsXG4gICAgY29udGV4dFBhcmFtZXRlcjogdHJ1ZVxuICB9O1xuICBjb25zdCBvYmpUb0RlY29yYXRlID0gb3B0aW9ucy5kZWNvcmF0ZURvYyA/IG1vZGVsIDogbW9kZWwucHJvdG90eXBlO1xuXG4gIG1vZGVsLiRhcHBsaWVkSG9va3MgPSB0cnVlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpKSB7XG4gICAgY29uc3QgdHlwZSA9IHNjaGVtYS5wYXRoc1trZXldO1xuICAgIGxldCBjaGlsZE1vZGVsID0gbnVsbDtcbiAgICBpZiAodHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIGNoaWxkTW9kZWwgPSB0eXBlLmNhc3RlcjtcbiAgICB9IGVsc2UgaWYgKHR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICBjaGlsZE1vZGVsID0gdHlwZS5Db25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTW9kZWwuJGFwcGxpZWRIb29rcykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgYXBwbHlIb29rcyhjaGlsZE1vZGVsLCB0eXBlLnNjaGVtYSwgb3B0aW9ucyk7XG4gICAgaWYgKGNoaWxkTW9kZWwuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNoaWxkTW9kZWwuZGlzY3JpbWluYXRvcnMpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBhcHBseUhvb2tzKGNoaWxkTW9kZWwuZGlzY3JpbWluYXRvcnNba2V5XSxcbiAgICAgICAgICBjaGlsZE1vZGVsLmRpc2NyaW1pbmF0b3JzW2tleV0uc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBCdWlsdC1pbiBob29rcyByZWx5IG9uIGhvb2tpbmcgaW50ZXJuYWwgZnVuY3Rpb25zIGluIG9yZGVyIHRvIHN1cHBvcnRcbiAgLy8gcHJvbWlzZXMgYW5kIG1ha2UgaXQgc28gdGhhdCBgZG9jLnNhdmUudG9TdHJpbmcoKWAgcHJvdmlkZXMgbWVhbmluZ2Z1bFxuICAvLyBpbmZvcm1hdGlvbi5cblxuICBjb25zdCBtaWRkbGV3YXJlID0gc2NoZW1hLnMuaG9va3MuXG4gICAgZmlsdGVyKGhvb2sgPT4ge1xuICAgICAgaWYgKGhvb2submFtZSA9PT0gJ3VwZGF0ZU9uZScgfHwgaG9vay5uYW1lID09PSAnZGVsZXRlT25lJykge1xuICAgICAgICByZXR1cm4gISFob29rWydkb2N1bWVudCddO1xuICAgICAgfVxuICAgICAgaWYgKGhvb2submFtZSA9PT0gJ3JlbW92ZScgfHwgaG9vay5uYW1lID09PSAnaW5pdCcpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tbJ2RvY3VtZW50J10gPT0gbnVsbCB8fCAhIWhvb2tbJ2RvY3VtZW50J107XG4gICAgICB9XG4gICAgICBpZiAoaG9vay5xdWVyeSAhPSBudWxsIHx8IGhvb2suZG9jdW1lbnQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaG9vay5kb2N1bWVudCAhPT0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KS5cbiAgICBmaWx0ZXIoaG9vayA9PiB7XG4gICAgICAvLyBJZiB1c2VyIGhhcyBvdmVyd3JpdHRlbiB0aGUgbWV0aG9kLCBkb24ndCBhcHBseSBidWlsdC1pbiBtaWRkbGV3YXJlXG4gICAgICBpZiAoc2NoZW1hLm1ldGhvZHNbaG9vay5uYW1lXSkge1xuICAgICAgICByZXR1cm4gIWhvb2suZm5bc3ltYm9scy5idWlsdEluTWlkZGxld2FyZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gIG1vZGVsLl9taWRkbGV3YXJlID0gbWlkZGxld2FyZTtcblxuICBvYmpUb0RlY29yYXRlLiRfX29yaWdpbmFsVmFsaWRhdGUgPSBvYmpUb0RlY29yYXRlLiRfX29yaWdpbmFsVmFsaWRhdGUgfHwgb2JqVG9EZWNvcmF0ZS4kX192YWxpZGF0ZTtcblxuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBbJ3NhdmUnLCAndmFsaWRhdGUnLCAncmVtb3ZlJywgJ2RlbGV0ZU9uZSddKSB7XG4gICAgY29uc3QgdG9XcmFwID0gbWV0aG9kID09PSAndmFsaWRhdGUnID8gJyRfX29yaWdpbmFsVmFsaWRhdGUnIDogYCRfXyR7bWV0aG9kfWA7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG1pZGRsZXdhcmUuXG4gICAgICBjcmVhdGVXcmFwcGVyKG1ldGhvZCwgb2JqVG9EZWNvcmF0ZVt0b1dyYXBdLCBudWxsLCBrYXJlZW1PcHRpb25zKTtcbiAgICBvYmpUb0RlY29yYXRlW2AkX18ke21ldGhvZH1gXSA9IHdyYXBwZWQ7XG4gIH1cbiAgb2JqVG9EZWNvcmF0ZS4kX19pbml0ID0gbWlkZGxld2FyZS5cbiAgICBjcmVhdGVXcmFwcGVyU3luYygnaW5pdCcsIG9ialRvRGVjb3JhdGUuJF9faW5pdCwgbnVsbCwga2FyZWVtT3B0aW9ucyk7XG5cbiAgLy8gU3VwcG9ydCBob29rcyBmb3IgY3VzdG9tIG1ldGhvZHNcbiAgY29uc3QgY3VzdG9tTWV0aG9kcyA9IE9iamVjdC5rZXlzKHNjaGVtYS5tZXRob2RzKTtcbiAgY29uc3QgY3VzdG9tTWV0aG9kT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGthcmVlbU9wdGlvbnMsIHtcbiAgICAvLyBPbmx5IHVzZSBgY2hlY2tGb3JQcm9taXNlYCBmb3IgY3VzdG9tIG1ldGhvZHMsIGJlY2F1c2UgbW9uZ29vc2VcbiAgICAvLyBxdWVyeSB0aHVua3MgYXJlIG5vdCBhcyBjb25zaXN0ZW50IGFzIEkgd291bGQgbGlrZSBhYm91dCByZXR1cm5pbmdcbiAgICAvLyBhIG51bGxpc2ggdmFsdWUgcmF0aGVyIHRoYW4gdGhlIHF1ZXJ5LiBJZiBhIHF1ZXJ5IHRodW5rIHJldHVybnNcbiAgICAvLyBhIHF1ZXJ5LCBgY2hlY2tGb3JQcm9taXNlYCBjYXVzZXMgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgY2hlY2tGb3JQcm9taXNlOiB0cnVlXG4gIH0pO1xuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBjdXN0b21NZXRob2RzKSB7XG4gICAgaWYgKGFscmVhZHlIb29rZWRGdW5jdGlvbnMuaGFzKG1ldGhvZCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIW1pZGRsZXdhcmUuaGFzSG9va3MobWV0aG9kKSkge1xuICAgICAgLy8gRG9uJ3Qgd3JhcCBpZiB0aGVyZSBhcmUgbm8gaG9va3MgZm9yIHRoZSBjdXN0b20gbWV0aG9kIHRvIGF2b2lkXG4gICAgICAvLyBzdXJwcmlzZXMuIEFsc28sIGBjcmVhdGVXcmFwcGVyKClgIGVuZm9yY2VzIGNvbnNpc3RlbnQgYXN5bmMsXG4gICAgICAvLyBzbyB3cmFwcGluZyBhIHN5bmMgbWV0aG9kIHdvdWxkIGJyZWFrIGl0LlxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gb2JqVG9EZWNvcmF0ZVttZXRob2RdO1xuICAgIG9ialRvRGVjb3JhdGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBjb25zdCBjYiA9IGFyZ3Muc2xpY2UoLTEpLnBvcCgpO1xuICAgICAgY29uc3QgYXJnc1dpdGhvdXRDYWxsYmFjayA9IHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKSA6IGFyZ3M7XG4gICAgICByZXR1cm4gcHJvbWlzZU9yQ2FsbGJhY2soY2IsIGNhbGxiYWNrID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXNbYCRfXyR7bWV0aG9kfWBdLmFwcGx5KHRoaXMsXG4gICAgICAgICAgYXJnc1dpdGhvdXRDYWxsYmFjay5jb25jYXQoW2NhbGxiYWNrXSkpO1xuICAgICAgfSwgbW9kZWwuZXZlbnRzKTtcbiAgICB9O1xuICAgIG9ialRvRGVjb3JhdGVbYCRfXyR7bWV0aG9kfWBdID0gbWlkZGxld2FyZS5cbiAgICAgIGNyZWF0ZVdyYXBwZXIobWV0aG9kLCBvcmlnaW5hbE1ldGhvZCwgbnVsbCwgY3VzdG9tTWV0aG9kT3B0aW9ucyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/model/applyHooks.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/model/applyMethods.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/applyMethods.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\n/**\n * Register methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nmodule.exports = function applyMethods(model, schema) {\n  const Model = __webpack_require__(/*! ../../model */ \"(api)/../server/node_modules/mongoose/lib/model.js\");\n\n  function apply(method, schema) {\n    Object.defineProperty(model.prototype, method, {\n      get: function() {\n        const h = {};\n        for (const k in schema.methods[method]) {\n          h[k] = schema.methods[method][k].bind(this);\n        }\n        return h;\n      },\n      configurable: true\n    });\n  }\n  for (const method of Object.keys(schema.methods)) {\n    const fn = schema.methods[method];\n    if (schema.tree.hasOwnProperty(method)) {\n      throw new Error('You have a method and a property in your schema both ' +\n        'named \"' + method + '\"');\n    }\n\n    // Avoid making custom methods if user sets a method to itself, e.g.\n    // `schema.method(save, Document.prototype.save)`. Can happen when\n    // calling `loadClass()` with a class that `extends Document`. See gh-12254\n    if (typeof fn === 'function' &&\n        Model.prototype[method] === fn) {\n      delete schema.methods[method];\n      continue;\n    }\n\n    if (schema.reserved[method] &&\n        !get(schema, `methodOptions.${method}.suppressWarning`, false)) {\n      utils.warn(`mongoose: the method name \"${method}\" is used by mongoose ` +\n        'internally, overwriting it may cause bugs. If you\\'re sure you know ' +\n        'what you\\'re doing, you can suppress this error by using ' +\n        `\\`schema.method('${method}', fn, { suppressWarning: true })\\`.`);\n    }\n    if (typeof fn === 'function') {\n      model.prototype[method] = fn;\n    } else {\n      apply(method, schema);\n    }\n  }\n\n  // Recursively call `applyMethods()` on child schemas\n  model.$appliedMethods = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    if (type.$isSingleNested && !type.caster.$appliedMethods) {\n      applyMethods(type.caster, type.schema);\n    }\n    if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {\n      applyMethods(type.Constructor, type.schema);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseU1ldGhvZHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHdFQUFRO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQyx1RUFBYTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsdUVBQWE7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxTQUFTLHVCQUF1QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXG1vZGVsXFxhcHBseU1ldGhvZHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBSZWdpc3RlciBtZXRob2RzIGZvciB0aGlzIG1vZGVsXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBwbHlNZXRob2RzKG1vZGVsLCBzY2hlbWEpIHtcbiAgY29uc3QgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9tb2RlbCcpO1xuXG4gIGZ1bmN0aW9uIGFwcGx5KG1ldGhvZCwgc2NoZW1hKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZGVsLnByb3RvdHlwZSwgbWV0aG9kLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBoID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBpbiBzY2hlbWEubWV0aG9kc1ttZXRob2RdKSB7XG4gICAgICAgICAgaFtrXSA9IHNjaGVtYS5tZXRob2RzW21ldGhvZF1ba10uYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaDtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBPYmplY3Qua2V5cyhzY2hlbWEubWV0aG9kcykpIHtcbiAgICBjb25zdCBmbiA9IHNjaGVtYS5tZXRob2RzW21ldGhvZF07XG4gICAgaWYgKHNjaGVtYS50cmVlLmhhc093blByb3BlcnR5KG1ldGhvZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGhhdmUgYSBtZXRob2QgYW5kIGEgcHJvcGVydHkgaW4geW91ciBzY2hlbWEgYm90aCAnICtcbiAgICAgICAgJ25hbWVkIFwiJyArIG1ldGhvZCArICdcIicpO1xuICAgIH1cblxuICAgIC8vIEF2b2lkIG1ha2luZyBjdXN0b20gbWV0aG9kcyBpZiB1c2VyIHNldHMgYSBtZXRob2QgdG8gaXRzZWxmLCBlLmcuXG4gICAgLy8gYHNjaGVtYS5tZXRob2Qoc2F2ZSwgRG9jdW1lbnQucHJvdG90eXBlLnNhdmUpYC4gQ2FuIGhhcHBlbiB3aGVuXG4gICAgLy8gY2FsbGluZyBgbG9hZENsYXNzKClgIHdpdGggYSBjbGFzcyB0aGF0IGBleHRlbmRzIERvY3VtZW50YC4gU2VlIGdoLTEyMjU0XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICBNb2RlbC5wcm90b3R5cGVbbWV0aG9kXSA9PT0gZm4pIHtcbiAgICAgIGRlbGV0ZSBzY2hlbWEubWV0aG9kc1ttZXRob2RdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYS5yZXNlcnZlZFttZXRob2RdICYmXG4gICAgICAgICFnZXQoc2NoZW1hLCBgbWV0aG9kT3B0aW9ucy4ke21ldGhvZH0uc3VwcHJlc3NXYXJuaW5nYCwgZmFsc2UpKSB7XG4gICAgICB1dGlscy53YXJuKGBtb25nb29zZTogdGhlIG1ldGhvZCBuYW1lIFwiJHttZXRob2R9XCIgaXMgdXNlZCBieSBtb25nb29zZSBgICtcbiAgICAgICAgJ2ludGVybmFsbHksIG92ZXJ3cml0aW5nIGl0IG1heSBjYXVzZSBidWdzLiBJZiB5b3VcXCdyZSBzdXJlIHlvdSBrbm93ICcgK1xuICAgICAgICAnd2hhdCB5b3VcXCdyZSBkb2luZywgeW91IGNhbiBzdXBwcmVzcyB0aGlzIGVycm9yIGJ5IHVzaW5nICcgK1xuICAgICAgICBgXFxgc2NoZW1hLm1ldGhvZCgnJHttZXRob2R9JywgZm4sIHsgc3VwcHJlc3NXYXJuaW5nOiB0cnVlIH0pXFxgLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtb2RlbC5wcm90b3R5cGVbbWV0aG9kXSA9IGZuO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBseShtZXRob2QsIHNjaGVtYSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVjdXJzaXZlbHkgY2FsbCBgYXBwbHlNZXRob2RzKClgIG9uIGNoaWxkIHNjaGVtYXNcbiAgbW9kZWwuJGFwcGxpZWRNZXRob2RzID0gdHJ1ZTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKSkge1xuICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEucGF0aHNba2V5XTtcbiAgICBpZiAodHlwZS4kaXNTaW5nbGVOZXN0ZWQgJiYgIXR5cGUuY2FzdGVyLiRhcHBsaWVkTWV0aG9kcykge1xuICAgICAgYXBwbHlNZXRob2RzKHR5cGUuY2FzdGVyLCB0eXBlLnNjaGVtYSk7XG4gICAgfVxuICAgIGlmICh0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJiAhdHlwZS5Db25zdHJ1Y3Rvci4kYXBwbGllZE1ldGhvZHMpIHtcbiAgICAgIGFwcGx5TWV0aG9kcyh0eXBlLkNvbnN0cnVjdG9yLCB0eXBlLnNjaGVtYSk7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/model/applyMethods.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js":
/*!*****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst middlewareFunctions = (__webpack_require__(/*! ../query/applyQueryMiddleware */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js\").middlewareFunctions);\nconst promiseOrCallback = __webpack_require__(/*! ../promiseOrCallback */ \"(api)/../server/node_modules/mongoose/lib/helpers/promiseOrCallback.js\");\n\nmodule.exports = function applyStaticHooks(model, hooks, statics) {\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1\n  };\n\n  hooks = hooks.filter(hook => {\n    // If the custom static overwrites an existing query middleware, don't apply\n    // middleware to it by default. This avoids a potential backwards breaking\n    // change with plugins like `mongoose-delete` that use statics to overwrite\n    // built-in Mongoose functions.\n    if (middlewareFunctions.indexOf(hook.name) !== -1) {\n      return !!hook.model;\n    }\n    return hook.model !== false;\n  });\n\n  model.$__insertMany = hooks.createWrapper('insertMany',\n    model.$__insertMany, model, kareemOptions);\n\n  for (const key of Object.keys(statics)) {\n    if (hooks.hasHooks(key)) {\n      const original = model[key];\n\n      model[key] = function() {\n        const numArgs = arguments.length;\n        const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;\n        const cb = typeof lastArg === 'function' ? lastArg : null;\n        const args = Array.prototype.slice.\n          call(arguments, 0, cb == null ? numArgs : numArgs - 1);\n        // Special case: can't use `Kareem#wrap()` because it doesn't currently\n        // support wrapped functions that return a promise.\n        return promiseOrCallback(cb, callback => {\n          hooks.execPre(key, model, args, function(err) {\n            if (err != null) {\n              return callback(err);\n            }\n\n            let postCalled = 0;\n            const ret = original.apply(model, args.concat(post));\n            if (ret != null && typeof ret.then === 'function') {\n              ret.then(res => post(null, res), err => post(err));\n            }\n\n            function post(error, res) {\n              if (postCalled++ > 0) {\n                return;\n              }\n\n              if (error != null) {\n                return callback(error);\n              }\n\n              hooks.execPost(key, model, [res], function(error) {\n                if (error != null) {\n                  return callback(error);\n                }\n                callback(null, res);\n              });\n            }\n          });\n        }, model.events);\n      };\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseVN0YXRpY0hvb2tzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDRCQUE0QixpS0FBNEQ7QUFDeEYsMEJBQTBCLG1CQUFPLENBQUMsb0dBQXNCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxtb2RlbFxcYXBwbHlTdGF0aWNIb29rcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG1pZGRsZXdhcmVGdW5jdGlvbnMgPSByZXF1aXJlKCcuLi9xdWVyeS9hcHBseVF1ZXJ5TWlkZGxld2FyZScpLm1pZGRsZXdhcmVGdW5jdGlvbnM7XG5jb25zdCBwcm9taXNlT3JDYWxsYmFjayA9IHJlcXVpcmUoJy4uL3Byb21pc2VPckNhbGxiYWNrJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBwbHlTdGF0aWNIb29rcyhtb2RlbCwgaG9va3MsIHN0YXRpY3MpIHtcbiAgY29uc3Qga2FyZWVtT3B0aW9ucyA9IHtcbiAgICB1c2VFcnJvckhhbmRsZXJzOiB0cnVlLFxuICAgIG51bUNhbGxiYWNrUGFyYW1zOiAxXG4gIH07XG5cbiAgaG9va3MgPSBob29rcy5maWx0ZXIoaG9vayA9PiB7XG4gICAgLy8gSWYgdGhlIGN1c3RvbSBzdGF0aWMgb3ZlcndyaXRlcyBhbiBleGlzdGluZyBxdWVyeSBtaWRkbGV3YXJlLCBkb24ndCBhcHBseVxuICAgIC8vIG1pZGRsZXdhcmUgdG8gaXQgYnkgZGVmYXVsdC4gVGhpcyBhdm9pZHMgYSBwb3RlbnRpYWwgYmFja3dhcmRzIGJyZWFraW5nXG4gICAgLy8gY2hhbmdlIHdpdGggcGx1Z2lucyBsaWtlIGBtb25nb29zZS1kZWxldGVgIHRoYXQgdXNlIHN0YXRpY3MgdG8gb3ZlcndyaXRlXG4gICAgLy8gYnVpbHQtaW4gTW9uZ29vc2UgZnVuY3Rpb25zLlxuICAgIGlmIChtaWRkbGV3YXJlRnVuY3Rpb25zLmluZGV4T2YoaG9vay5uYW1lKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiAhIWhvb2subW9kZWw7XG4gICAgfVxuICAgIHJldHVybiBob29rLm1vZGVsICE9PSBmYWxzZTtcbiAgfSk7XG5cbiAgbW9kZWwuJF9faW5zZXJ0TWFueSA9IGhvb2tzLmNyZWF0ZVdyYXBwZXIoJ2luc2VydE1hbnknLFxuICAgIG1vZGVsLiRfX2luc2VydE1hbnksIG1vZGVsLCBrYXJlZW1PcHRpb25zKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzdGF0aWNzKSkge1xuICAgIGlmIChob29rcy5oYXNIb29rcyhrZXkpKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbCA9IG1vZGVsW2tleV07XG5cbiAgICAgIG1vZGVsW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgbnVtQXJncyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGxhc3RBcmcgPSBudW1BcmdzID4gMCA/IGFyZ3VtZW50c1tudW1BcmdzIC0gMV0gOiBudWxsO1xuICAgICAgICBjb25zdCBjYiA9IHR5cGVvZiBsYXN0QXJnID09PSAnZnVuY3Rpb24nID8gbGFzdEFyZyA6IG51bGw7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuXG4gICAgICAgICAgY2FsbChhcmd1bWVudHMsIDAsIGNiID09IG51bGwgPyBudW1BcmdzIDogbnVtQXJncyAtIDEpO1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IGNhbid0IHVzZSBgS2FyZWVtI3dyYXAoKWAgYmVjYXVzZSBpdCBkb2Vzbid0IGN1cnJlbnRseVxuICAgICAgICAvLyBzdXBwb3J0IHdyYXBwZWQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIGEgcHJvbWlzZS5cbiAgICAgICAgcmV0dXJuIHByb21pc2VPckNhbGxiYWNrKGNiLCBjYWxsYmFjayA9PiB7XG4gICAgICAgICAgaG9va3MuZXhlY1ByZShrZXksIG1vZGVsLCBhcmdzLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHBvc3RDYWxsZWQgPSAwO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gb3JpZ2luYWwuYXBwbHkobW9kZWwsIGFyZ3MuY29uY2F0KHBvc3QpKTtcbiAgICAgICAgICAgIGlmIChyZXQgIT0gbnVsbCAmJiB0eXBlb2YgcmV0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmV0LnRoZW4ocmVzID0+IHBvc3QobnVsbCwgcmVzKSwgZXJyID0+IHBvc3QoZXJyKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBvc3QoZXJyb3IsIHJlcykge1xuICAgICAgICAgICAgICBpZiAocG9zdENhbGxlZCsrID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGhvb2tzLmV4ZWNQb3N0KGtleSwgbW9kZWwsIFtyZXNdLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbW9kZWwuZXZlbnRzKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/model/applyStatics.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/applyStatics.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Register statics for this model\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\nmodule.exports = function applyStatics(model, schema) {\n  for (const i in schema.statics) {\n    model[i] = schema.statics[i];\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseVN0YXRpY3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxtb2RlbFxcYXBwbHlTdGF0aWNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZWdpc3RlciBzdGF0aWNzIGZvciB0aGlzIG1vZGVsXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBwbHlTdGF0aWNzKG1vZGVsLCBzY2hlbWEpIHtcbiAgZm9yIChjb25zdCBpIGluIHNjaGVtYS5zdGF0aWNzKSB7XG4gICAgbW9kZWxbaV0gPSBzY2hlbWEuc3RhdGljc1tpXTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/model/applyStatics.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/model/castBulkWrite.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/castBulkWrite.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../../helpers/discriminator/getDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst applyTimestampsToChildren = __webpack_require__(/*! ../update/applyTimestampsToChildren */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js\");\nconst applyTimestampsToUpdate = __webpack_require__(/*! ../update/applyTimestampsToUpdate */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js\");\nconst cast = __webpack_require__(/*! ../../cast */ \"(api)/../server/node_modules/mongoose/lib/cast.js\");\nconst castUpdate = __webpack_require__(/*! ../query/castUpdate */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/castUpdate.js\");\nconst decorateUpdateWithVersionKey = __webpack_require__(/*! ../update/decorateUpdateWithVersionKey */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js\");\nconst { inspect } = __webpack_require__(/*! util */ \"util\");\nconst setDefaultsOnInsert = __webpack_require__(/*! ../setDefaultsOnInsert */ \"(api)/../server/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js\");\n\n/**\n * Given a model and a bulkWrite op, return a thunk that handles casting and\n * validating the individual op.\n * @param {Model} originalModel\n * @param {Object} op\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function castBulkWrite(originalModel, op, options) {\n  const now = originalModel.base.now();\n\n  const globalSetDefaultsOnInsert = originalModel.base.options.setDefaultsOnInsert;\n  if (op['insertOne']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['insertOne']['document']);\n\n      const doc = new model(op['insertOne']['document']);\n      if (model.schema.options.timestamps && options.timestamps !== false) {\n        doc.initializeTimestamps();\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      const versionKey = model?.schema?.options?.versionKey;\n      if (versionKey && doc[versionKey] == null) {\n        doc[versionKey] = 0;\n      }\n      op['insertOne']['document'] = doc;\n\n      if (options.skipValidation || op['insertOne'].skipValidation) {\n        callback(null);\n        return;\n      }\n\n      op['insertOne']['document'].$validate().then(\n        () => { callback(null); },\n        err => { callback(err, null); }\n      );\n    };\n  } else if (op['updateOne']) {\n    return (callback) => {\n      try {\n        if (!op['updateOne']['filter']) {\n          throw new Error('Must provide a filter object.');\n        }\n        if (!op['updateOne']['update']) {\n          throw new Error('Must provide an update object.');\n        }\n\n        const model = decideModelByObject(originalModel, op['updateOne']['filter']);\n        const schema = model.schema;\n        const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n        _addDiscriminatorToObject(schema, op['updateOne']['filter']);\n\n        if (model.schema.$timestamps != null && op['updateOne'].timestamps !== false) {\n          const createdAt = model.schema.$timestamps.createdAt;\n          const updatedAt = model.schema.$timestamps.updatedAt;\n          applyTimestampsToUpdate(now, createdAt, updatedAt, op['updateOne']['update'], {});\n        }\n\n        if (op['updateOne'].timestamps !== false) {\n          applyTimestampsToChildren(now, op['updateOne']['update'], model.schema);\n        }\n\n        const shouldSetDefaultsOnInsert = op['updateOne'].setDefaultsOnInsert == null ?\n          globalSetDefaultsOnInsert :\n          op['updateOne'].setDefaultsOnInsert;\n        if (shouldSetDefaultsOnInsert !== false) {\n          setDefaultsOnInsert(op['updateOne']['filter'], model.schema, op['updateOne']['update'], {\n            setDefaultsOnInsert: true,\n            upsert: op['updateOne'].upsert\n          });\n        }\n\n        decorateUpdateWithVersionKey(\n          op['updateOne']['update'],\n          op['updateOne'],\n          model.schema.options.versionKey\n        );\n\n        op['updateOne']['filter'] = cast(model.schema, op['updateOne']['filter'], {\n          strict: strict,\n          upsert: op['updateOne'].upsert\n        });\n\n        op['updateOne']['update'] = castUpdate(model.schema, op['updateOne']['update'], {\n          strict: strict,\n          overwrite: false,\n          upsert: op['updateOne'].upsert\n        }, model, op['updateOne']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['updateMany']) {\n    return (callback) => {\n      try {\n        if (!op['updateMany']['filter']) {\n          throw new Error('Must provide a filter object.');\n        }\n        if (!op['updateMany']['update']) {\n          throw new Error('Must provide an update object.');\n        }\n\n        const model = decideModelByObject(originalModel, op['updateMany']['filter']);\n        const schema = model.schema;\n        const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n        const shouldSetDefaultsOnInsert = op['updateMany'].setDefaultsOnInsert == null ?\n          globalSetDefaultsOnInsert :\n          op['updateMany'].setDefaultsOnInsert;\n\n        if (shouldSetDefaultsOnInsert !== false) {\n          setDefaultsOnInsert(op['updateMany']['filter'], model.schema, op['updateMany']['update'], {\n            setDefaultsOnInsert: true,\n            upsert: op['updateMany'].upsert\n          });\n        }\n\n        if (model.schema.$timestamps != null && op['updateMany'].timestamps !== false) {\n          const createdAt = model.schema.$timestamps.createdAt;\n          const updatedAt = model.schema.$timestamps.updatedAt;\n          applyTimestampsToUpdate(now, createdAt, updatedAt, op['updateMany']['update'], {});\n        }\n        if (op['updateMany'].timestamps !== false) {\n          applyTimestampsToChildren(now, op['updateMany']['update'], model.schema);\n        }\n\n        _addDiscriminatorToObject(schema, op['updateMany']['filter']);\n\n        decorateUpdateWithVersionKey(\n          op['updateMany']['update'],\n          op['updateMany'],\n          model.schema.options.versionKey\n        );\n\n        op['updateMany']['filter'] = cast(model.schema, op['updateMany']['filter'], {\n          strict: strict,\n          upsert: op['updateMany'].upsert\n        });\n\n        op['updateMany']['update'] = castUpdate(model.schema, op['updateMany']['update'], {\n          strict: strict,\n          overwrite: false,\n          upsert: op['updateMany'].upsert\n        }, model, op['updateMany']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['replaceOne']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['replaceOne']['filter']);\n      const schema = model.schema;\n      const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n      _addDiscriminatorToObject(schema, op['replaceOne']['filter']);\n      try {\n        op['replaceOne']['filter'] = cast(model.schema, op['replaceOne']['filter'], {\n          strict: strict,\n          upsert: op['replaceOne'].upsert\n        });\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      // set `skipId`, otherwise we get \"_id field cannot be changed\"\n      const doc = new model(op['replaceOne']['replacement'], strict, true);\n      if (model.schema.options.timestamps) {\n        doc.initializeTimestamps();\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      const versionKey = model?.schema?.options?.versionKey;\n      if (versionKey && doc[versionKey] == null) {\n        doc[versionKey] = 0;\n      }\n      op['replaceOne']['replacement'] = doc;\n\n      if (options.skipValidation || op['replaceOne'].skipValidation) {\n        op['replaceOne']['replacement'] = op['replaceOne']['replacement'].toBSON();\n        callback(null);\n        return;\n      }\n\n      op['replaceOne']['replacement'].$validate().then(\n        () => {\n          op['replaceOne']['replacement'] = op['replaceOne']['replacement'].toBSON();\n          callback(null);\n        },\n        error => {\n          callback(error, null);\n        }\n      );\n    };\n  } else if (op['deleteOne']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['deleteOne']['filter']);\n      const schema = model.schema;\n\n      _addDiscriminatorToObject(schema, op['deleteOne']['filter']);\n\n      try {\n        op['deleteOne']['filter'] = cast(model.schema,\n          op['deleteOne']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['deleteMany']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['deleteMany']['filter']);\n      const schema = model.schema;\n\n      _addDiscriminatorToObject(schema, op['deleteMany']['filter']);\n\n      try {\n        op['deleteMany']['filter'] = cast(model.schema,\n          op['deleteMany']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else {\n    return (callback) => {\n      const error = new MongooseError(`Invalid op passed to \\`bulkWrite()\\`: ${inspect(op)}`);\n      callback(error, null);\n    };\n  }\n};\n\nfunction _addDiscriminatorToObject(schema, obj) {\n  if (schema == null) {\n    return;\n  }\n  if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {\n    obj[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;\n  }\n}\n\n/**\n * gets discriminator model if discriminator key is present in object\n * @api private\n */\n\nfunction decideModelByObject(model, object) {\n  const discriminatorKey = model.schema.options.discriminatorKey;\n  if (object != null && object.hasOwnProperty(discriminatorKey)) {\n    model = getDiscriminatorByValue(model.discriminators, object[discriminatorKey]) || model;\n  }\n  return model;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9jYXN0QnVsa1dyaXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLG1HQUEyQjtBQUN6RCxnQ0FBZ0MsbUJBQU8sQ0FBQyx1SkFBcUQ7QUFDN0Ysa0NBQWtDLG1CQUFPLENBQUMsa0lBQXFDO0FBQy9FLGdDQUFnQyxtQkFBTyxDQUFDLDhIQUFtQztBQUMzRSxhQUFhLG1CQUFPLENBQUMscUVBQVk7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsa0dBQXFCO0FBQ2hELHFDQUFxQyxtQkFBTyxDQUFDLHdJQUF3QztBQUNyRixRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ2xDLDRCQUE0QixtQkFBTyxDQUFDLHdHQUF3Qjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsK0VBQStFLFlBQVk7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXG1vZGVsXFxjYXN0QnVsa1dyaXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuID0gcmVxdWlyZSgnLi4vdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4nKTtcbmNvbnN0IGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlID0gcmVxdWlyZSgnLi4vdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvVXBkYXRlJyk7XG5jb25zdCBjYXN0ID0gcmVxdWlyZSgnLi4vLi4vY2FzdCcpO1xuY29uc3QgY2FzdFVwZGF0ZSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L2Nhc3RVcGRhdGUnKTtcbmNvbnN0IGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkgPSByZXF1aXJlKCcuLi91cGRhdGUvZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleScpO1xuY29uc3QgeyBpbnNwZWN0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBzZXREZWZhdWx0c09uSW5zZXJ0ID0gcmVxdWlyZSgnLi4vc2V0RGVmYXVsdHNPbkluc2VydCcpO1xuXG4vKipcbiAqIEdpdmVuIGEgbW9kZWwgYW5kIGEgYnVsa1dyaXRlIG9wLCByZXR1cm4gYSB0aHVuayB0aGF0IGhhbmRsZXMgY2FzdGluZyBhbmRcbiAqIHZhbGlkYXRpbmcgdGhlIGluZGl2aWR1YWwgb3AuXG4gKiBAcGFyYW0ge01vZGVsfSBvcmlnaW5hbE1vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3BcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdEJ1bGtXcml0ZShvcmlnaW5hbE1vZGVsLCBvcCwgb3B0aW9ucykge1xuICBjb25zdCBub3cgPSBvcmlnaW5hbE1vZGVsLmJhc2Uubm93KCk7XG5cbiAgY29uc3QgZ2xvYmFsU2V0RGVmYXVsdHNPbkluc2VydCA9IG9yaWdpbmFsTW9kZWwuYmFzZS5vcHRpb25zLnNldERlZmF1bHRzT25JbnNlcnQ7XG4gIGlmIChvcFsnaW5zZXJ0T25lJ10pIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbCA9IGRlY2lkZU1vZGVsQnlPYmplY3Qob3JpZ2luYWxNb2RlbCwgb3BbJ2luc2VydE9uZSddWydkb2N1bWVudCddKTtcblxuICAgICAgY29uc3QgZG9jID0gbmV3IG1vZGVsKG9wWydpbnNlcnRPbmUnXVsnZG9jdW1lbnQnXSk7XG4gICAgICBpZiAobW9kZWwuc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcyAmJiBvcHRpb25zLnRpbWVzdGFtcHMgIT09IGZhbHNlKSB7XG4gICAgICAgIGRvYy5pbml0aWFsaXplVGltZXN0YW1wcygpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGRvYy4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmVyc2lvbktleSA9IG1vZGVsPy5zY2hlbWE/Lm9wdGlvbnM/LnZlcnNpb25LZXk7XG4gICAgICBpZiAodmVyc2lvbktleSAmJiBkb2NbdmVyc2lvbktleV0gPT0gbnVsbCkge1xuICAgICAgICBkb2NbdmVyc2lvbktleV0gPSAwO1xuICAgICAgfVxuICAgICAgb3BbJ2luc2VydE9uZSddWydkb2N1bWVudCddID0gZG9jO1xuXG4gICAgICBpZiAob3B0aW9ucy5za2lwVmFsaWRhdGlvbiB8fCBvcFsnaW5zZXJ0T25lJ10uc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3BbJ2luc2VydE9uZSddWydkb2N1bWVudCddLiR2YWxpZGF0ZSgpLnRoZW4oXG4gICAgICAgICgpID0+IHsgY2FsbGJhY2sobnVsbCk7IH0sXG4gICAgICAgIGVyciA9PiB7IGNhbGxiYWNrKGVyciwgbnVsbCk7IH1cbiAgICAgICk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChvcFsndXBkYXRlT25lJ10pIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW9wWyd1cGRhdGVPbmUnXVsnZmlsdGVyJ10pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIGZpbHRlciBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcFsndXBkYXRlT25lJ11bJ3VwZGF0ZSddKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYW4gdXBkYXRlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1vZGVsID0gZGVjaWRlTW9kZWxCeU9iamVjdChvcmlnaW5hbE1vZGVsLCBvcFsndXBkYXRlT25lJ11bJ2ZpbHRlciddKTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuICAgICAgICBjb25zdCBzdHJpY3QgPSBvcHRpb25zLnN0cmljdCAhPSBudWxsID8gb3B0aW9ucy5zdHJpY3QgOiBtb2RlbC5zY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG5cbiAgICAgICAgX2FkZERpc2NyaW1pbmF0b3JUb09iamVjdChzY2hlbWEsIG9wWyd1cGRhdGVPbmUnXVsnZmlsdGVyJ10pO1xuXG4gICAgICAgIGlmIChtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMgIT0gbnVsbCAmJiBvcFsndXBkYXRlT25lJ10udGltZXN0YW1wcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSBtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMuY3JlYXRlZEF0O1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG1vZGVsLnNjaGVtYS4kdGltZXN0YW1wcy51cGRhdGVkQXQ7XG4gICAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGUobm93LCBjcmVhdGVkQXQsIHVwZGF0ZWRBdCwgb3BbJ3VwZGF0ZU9uZSddWyd1cGRhdGUnXSwge30pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wWyd1cGRhdGVPbmUnXS50aW1lc3RhbXBzICE9PSBmYWxzZSkge1xuICAgICAgICAgIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCBvcFsndXBkYXRlT25lJ11bJ3VwZGF0ZSddLCBtb2RlbC5zY2hlbWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2hvdWxkU2V0RGVmYXVsdHNPbkluc2VydCA9IG9wWyd1cGRhdGVPbmUnXS5zZXREZWZhdWx0c09uSW5zZXJ0ID09IG51bGwgP1xuICAgICAgICAgIGdsb2JhbFNldERlZmF1bHRzT25JbnNlcnQgOlxuICAgICAgICAgIG9wWyd1cGRhdGVPbmUnXS5zZXREZWZhdWx0c09uSW5zZXJ0O1xuICAgICAgICBpZiAoc2hvdWxkU2V0RGVmYXVsdHNPbkluc2VydCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBzZXREZWZhdWx0c09uSW5zZXJ0KG9wWyd1cGRhdGVPbmUnXVsnZmlsdGVyJ10sIG1vZGVsLnNjaGVtYSwgb3BbJ3VwZGF0ZU9uZSddWyd1cGRhdGUnXSwge1xuICAgICAgICAgICAgc2V0RGVmYXVsdHNPbkluc2VydDogdHJ1ZSxcbiAgICAgICAgICAgIHVwc2VydDogb3BbJ3VwZGF0ZU9uZSddLnVwc2VydFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleShcbiAgICAgICAgICBvcFsndXBkYXRlT25lJ11bJ3VwZGF0ZSddLFxuICAgICAgICAgIG9wWyd1cGRhdGVPbmUnXSxcbiAgICAgICAgICBtb2RlbC5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5XG4gICAgICAgICk7XG5cbiAgICAgICAgb3BbJ3VwZGF0ZU9uZSddWydmaWx0ZXInXSA9IGNhc3QobW9kZWwuc2NoZW1hLCBvcFsndXBkYXRlT25lJ11bJ2ZpbHRlciddLCB7XG4gICAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgICAgdXBzZXJ0OiBvcFsndXBkYXRlT25lJ10udXBzZXJ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9wWyd1cGRhdGVPbmUnXVsndXBkYXRlJ10gPSBjYXN0VXBkYXRlKG1vZGVsLnNjaGVtYSwgb3BbJ3VwZGF0ZU9uZSddWyd1cGRhdGUnXSwge1xuICAgICAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgICAgdXBzZXJ0OiBvcFsndXBkYXRlT25lJ10udXBzZXJ0XG4gICAgICAgIH0sIG1vZGVsLCBvcFsndXBkYXRlT25lJ11bJ2ZpbHRlciddKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAob3BbJ3VwZGF0ZU1hbnknXSkge1xuICAgIHJldHVybiAoY2FsbGJhY2spID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghb3BbJ3VwZGF0ZU1hbnknXVsnZmlsdGVyJ10pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIGZpbHRlciBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcFsndXBkYXRlTWFueSddWyd1cGRhdGUnXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGFuIHVwZGF0ZSBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtb2RlbCA9IGRlY2lkZU1vZGVsQnlPYmplY3Qob3JpZ2luYWxNb2RlbCwgb3BbJ3VwZGF0ZU1hbnknXVsnZmlsdGVyJ10pO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBtb2RlbC5zY2hlbWE7XG4gICAgICAgIGNvbnN0IHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0ICE9IG51bGwgPyBvcHRpb25zLnN0cmljdCA6IG1vZGVsLnNjaGVtYS5vcHRpb25zLnN0cmljdDtcblxuICAgICAgICBjb25zdCBzaG91bGRTZXREZWZhdWx0c09uSW5zZXJ0ID0gb3BbJ3VwZGF0ZU1hbnknXS5zZXREZWZhdWx0c09uSW5zZXJ0ID09IG51bGwgP1xuICAgICAgICAgIGdsb2JhbFNldERlZmF1bHRzT25JbnNlcnQgOlxuICAgICAgICAgIG9wWyd1cGRhdGVNYW55J10uc2V0RGVmYXVsdHNPbkluc2VydDtcblxuICAgICAgICBpZiAoc2hvdWxkU2V0RGVmYXVsdHNPbkluc2VydCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBzZXREZWZhdWx0c09uSW5zZXJ0KG9wWyd1cGRhdGVNYW55J11bJ2ZpbHRlciddLCBtb2RlbC5zY2hlbWEsIG9wWyd1cGRhdGVNYW55J11bJ3VwZGF0ZSddLCB7XG4gICAgICAgICAgICBzZXREZWZhdWx0c09uSW5zZXJ0OiB0cnVlLFxuICAgICAgICAgICAgdXBzZXJ0OiBvcFsndXBkYXRlTWFueSddLnVwc2VydFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGVsLnNjaGVtYS4kdGltZXN0YW1wcyAhPSBudWxsICYmIG9wWyd1cGRhdGVNYW55J10udGltZXN0YW1wcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSBtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMuY3JlYXRlZEF0O1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG1vZGVsLnNjaGVtYS4kdGltZXN0YW1wcy51cGRhdGVkQXQ7XG4gICAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGUobm93LCBjcmVhdGVkQXQsIHVwZGF0ZWRBdCwgb3BbJ3VwZGF0ZU1hbnknXVsndXBkYXRlJ10sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BbJ3VwZGF0ZU1hbnknXS50aW1lc3RhbXBzICE9PSBmYWxzZSkge1xuICAgICAgICAgIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCBvcFsndXBkYXRlTWFueSddWyd1cGRhdGUnXSwgbW9kZWwuc2NoZW1hKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9hZGREaXNjcmltaW5hdG9yVG9PYmplY3Qoc2NoZW1hLCBvcFsndXBkYXRlTWFueSddWydmaWx0ZXInXSk7XG5cbiAgICAgICAgZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleShcbiAgICAgICAgICBvcFsndXBkYXRlTWFueSddWyd1cGRhdGUnXSxcbiAgICAgICAgICBvcFsndXBkYXRlTWFueSddLFxuICAgICAgICAgIG1vZGVsLnNjaGVtYS5vcHRpb25zLnZlcnNpb25LZXlcbiAgICAgICAgKTtcblxuICAgICAgICBvcFsndXBkYXRlTWFueSddWydmaWx0ZXInXSA9IGNhc3QobW9kZWwuc2NoZW1hLCBvcFsndXBkYXRlTWFueSddWydmaWx0ZXInXSwge1xuICAgICAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgICAgIHVwc2VydDogb3BbJ3VwZGF0ZU1hbnknXS51cHNlcnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb3BbJ3VwZGF0ZU1hbnknXVsndXBkYXRlJ10gPSBjYXN0VXBkYXRlKG1vZGVsLnNjaGVtYSwgb3BbJ3VwZGF0ZU1hbnknXVsndXBkYXRlJ10sIHtcbiAgICAgICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICAgIHVwc2VydDogb3BbJ3VwZGF0ZU1hbnknXS51cHNlcnRcbiAgICAgICAgfSwgbW9kZWwsIG9wWyd1cGRhdGVNYW55J11bJ2ZpbHRlciddKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAob3BbJ3JlcGxhY2VPbmUnXSkge1xuICAgIHJldHVybiAoY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IG1vZGVsID0gZGVjaWRlTW9kZWxCeU9iamVjdChvcmlnaW5hbE1vZGVsLCBvcFsncmVwbGFjZU9uZSddWydmaWx0ZXInXSk7XG4gICAgICBjb25zdCBzY2hlbWEgPSBtb2RlbC5zY2hlbWE7XG4gICAgICBjb25zdCBzdHJpY3QgPSBvcHRpb25zLnN0cmljdCAhPSBudWxsID8gb3B0aW9ucy5zdHJpY3QgOiBtb2RlbC5zY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG5cbiAgICAgIF9hZGREaXNjcmltaW5hdG9yVG9PYmplY3Qoc2NoZW1hLCBvcFsncmVwbGFjZU9uZSddWydmaWx0ZXInXSk7XG4gICAgICB0cnkge1xuICAgICAgICBvcFsncmVwbGFjZU9uZSddWydmaWx0ZXInXSA9IGNhc3QobW9kZWwuc2NoZW1hLCBvcFsncmVwbGFjZU9uZSddWydmaWx0ZXInXSwge1xuICAgICAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgICAgIHVwc2VydDogb3BbJ3JlcGxhY2VPbmUnXS51cHNlcnRcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgYHNraXBJZGAsIG90aGVyd2lzZSB3ZSBnZXQgXCJfaWQgZmllbGQgY2Fubm90IGJlIGNoYW5nZWRcIlxuICAgICAgY29uc3QgZG9jID0gbmV3IG1vZGVsKG9wWydyZXBsYWNlT25lJ11bJ3JlcGxhY2VtZW50J10sIHN0cmljdCwgdHJ1ZSk7XG4gICAgICBpZiAobW9kZWwuc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcykge1xuICAgICAgICBkb2MuaW5pdGlhbGl6ZVRpbWVzdGFtcHMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICBkb2MuJHNlc3Npb24ob3B0aW9ucy5zZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZlcnNpb25LZXkgPSBtb2RlbD8uc2NoZW1hPy5vcHRpb25zPy52ZXJzaW9uS2V5O1xuICAgICAgaWYgKHZlcnNpb25LZXkgJiYgZG9jW3ZlcnNpb25LZXldID09IG51bGwpIHtcbiAgICAgICAgZG9jW3ZlcnNpb25LZXldID0gMDtcbiAgICAgIH1cbiAgICAgIG9wWydyZXBsYWNlT25lJ11bJ3JlcGxhY2VtZW50J10gPSBkb2M7XG5cbiAgICAgIGlmIChvcHRpb25zLnNraXBWYWxpZGF0aW9uIHx8IG9wWydyZXBsYWNlT25lJ10uc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgb3BbJ3JlcGxhY2VPbmUnXVsncmVwbGFjZW1lbnQnXSA9IG9wWydyZXBsYWNlT25lJ11bJ3JlcGxhY2VtZW50J10udG9CU09OKCk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9wWydyZXBsYWNlT25lJ11bJ3JlcGxhY2VtZW50J10uJHZhbGlkYXRlKCkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIG9wWydyZXBsYWNlT25lJ11bJ3JlcGxhY2VtZW50J10gPSBvcFsncmVwbGFjZU9uZSddWydyZXBsYWNlbWVudCddLnRvQlNPTigpO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAob3BbJ2RlbGV0ZU9uZSddKSB7XG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBkZWNpZGVNb2RlbEJ5T2JqZWN0KG9yaWdpbmFsTW9kZWwsIG9wWydkZWxldGVPbmUnXVsnZmlsdGVyJ10pO1xuICAgICAgY29uc3Qgc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuXG4gICAgICBfYWRkRGlzY3JpbWluYXRvclRvT2JqZWN0KHNjaGVtYSwgb3BbJ2RlbGV0ZU9uZSddWydmaWx0ZXInXSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG9wWydkZWxldGVPbmUnXVsnZmlsdGVyJ10gPSBjYXN0KG1vZGVsLnNjaGVtYSxcbiAgICAgICAgICBvcFsnZGVsZXRlT25lJ11bJ2ZpbHRlciddKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAob3BbJ2RlbGV0ZU1hbnknXSkge1xuICAgIHJldHVybiAoY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IG1vZGVsID0gZGVjaWRlTW9kZWxCeU9iamVjdChvcmlnaW5hbE1vZGVsLCBvcFsnZGVsZXRlTWFueSddWydmaWx0ZXInXSk7XG4gICAgICBjb25zdCBzY2hlbWEgPSBtb2RlbC5zY2hlbWE7XG5cbiAgICAgIF9hZGREaXNjcmltaW5hdG9yVG9PYmplY3Qoc2NoZW1hLCBvcFsnZGVsZXRlTWFueSddWydmaWx0ZXInXSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG9wWydkZWxldGVNYW55J11bJ2ZpbHRlciddID0gY2FzdChtb2RlbC5zY2hlbWEsXG4gICAgICAgICAgb3BbJ2RlbGV0ZU1hbnknXVsnZmlsdGVyJ10pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBNb25nb29zZUVycm9yKGBJbnZhbGlkIG9wIHBhc3NlZCB0byBcXGBidWxrV3JpdGUoKVxcYDogJHtpbnNwZWN0KG9wKX1gKTtcbiAgICAgIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBfYWRkRGlzY3JpbWluYXRvclRvT2JqZWN0KHNjaGVtYSwgb2JqKSB7XG4gIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nICYmICFzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcuaXNSb290KSB7XG4gICAgb2JqW3NjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy5rZXldID0gc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogZ2V0cyBkaXNjcmltaW5hdG9yIG1vZGVsIGlmIGRpc2NyaW1pbmF0b3Iga2V5IGlzIHByZXNlbnQgaW4gb2JqZWN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBkZWNpZGVNb2RlbEJ5T2JqZWN0KG1vZGVsLCBvYmplY3QpIHtcbiAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IG1vZGVsLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gIGlmIChvYmplY3QgIT0gbnVsbCAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkoZGlzY3JpbWluYXRvcktleSkpIHtcbiAgICBtb2RlbCA9IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKG1vZGVsLmRpc2NyaW1pbmF0b3JzLCBvYmplY3RbZGlzY3JpbWluYXRvcktleV0pIHx8IG1vZGVsO1xuICB9XG4gIHJldHVybiBtb2RlbDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/model/castBulkWrite.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/model/discriminator.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/discriminator.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Mixed = __webpack_require__(/*! ../../schema/mixed */ \"(api)/../server/node_modules/mongoose/lib/schema/mixed.js\");\nconst applyBuiltinPlugins = __webpack_require__(/*! ../schema/applyBuiltinPlugins */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js\");\nconst clone = __webpack_require__(/*! ../clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst defineKey = (__webpack_require__(/*! ../document/compile */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/compile.js\").defineKey);\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst mergeDiscriminatorSchema = __webpack_require__(/*! ../../helpers/discriminator/mergeDiscriminatorSchema */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js\");\n\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true,\n  virtuals: true,\n  methods: true\n};\n\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  mergeHooks = mergeHooks == null ? true : mergeHooks;\n\n  if (model.schema.discriminatorMapping &&\n      !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name +\n        '\" can only be a discriminator of the root model');\n  }\n\n  if (applyPlugins) {\n    const applyPluginsToDiscriminators = get(model.base,\n      'options.applyPluginsToDiscriminators', false) || !mergeHooks;\n    // Even if `applyPluginsToDiscriminators` isn't set, we should still apply\n    // global plugins to schemas embedded in the discriminator schema (gh-7370)\n    model.base._applyPlugins(schema, {\n      skipTopLevel: !applyPluginsToDiscriminators\n    });\n  } else if (!mergeHooks) {\n    applyBuiltinPlugins(schema);\n  }\n\n  const key = model.schema.options.discriminatorKey;\n\n  const existingPath = model.schema.path(key);\n  if (existingPath != null) {\n    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {\n      existingPath.options.select = true;\n    }\n    existingPath.options.$skipDiscriminatorCheck = true;\n  } else {\n    const baseSchemaAddition = {};\n    baseSchemaAddition[key] = {\n      default: void 0,\n      select: true,\n      $skipDiscriminatorCheck: true\n    };\n    baseSchemaAddition[key][model.schema.options.typeKey] = String;\n    model.schema.add(baseSchemaAddition);\n    defineKey({\n      prop: key,\n      prototype: model.prototype,\n      options: model.schema.options\n    });\n  }\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name +\n        '\" cannot have field with name \"' + key + '\"');\n  }\n\n  let value = name;\n  if ((typeof tiedValue === 'string' && tiedValue.length) || tiedValue != null) {\n    value = tiedValue;\n  }\n\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._baseSchema = baseSchema;\n    if (baseSchema.paths._id &&\n        baseSchema.paths._id.options &&\n        !baseSchema.paths._id.options.auto) {\n      schema.remove('_id');\n    }\n\n    // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n\n    for (const path of baseSchemaPaths) {\n      if (schema.nested[path]) {\n        conflictingPaths.push(path);\n        continue;\n      }\n\n      if (path.indexOf('.') === -1) {\n        continue;\n      }\n      const sp = path.split('.').slice(0, -1);\n      let cur = '';\n      for (const piece of sp) {\n        cur += (cur.length ? '.' : '') + piece;\n        if (schema.paths[cur] instanceof Mixed ||\n            schema.singleNestedPaths[cur] instanceof Mixed) {\n          conflictingPaths.push(path);\n        }\n      }\n    }\n\n    mergeDiscriminatorSchema(schema, baseSchema);\n\n    // Clean up conflicting paths _after_ merging re: gh-6076\n    for (const conflictingPath of conflictingPaths) {\n      delete schema.paths[conflictingPath];\n    }\n\n    // Rebuild schema models because schemas may have been merged re: #7884\n    schema.childSchemas.forEach(obj => {\n      obj.model.prototype.$__setSchema(obj.schema);\n    });\n\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function(newName) {\n        if (newName === value || (Array.isArray(value) && utils.deepEqual(newName, value))) {\n          return value;\n        }\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = existingPath ? existingPath.options[schema.options.typeKey] : String;\n    schema.add(obj);\n\n    schema.discriminatorMapping = { key: key, value: value, isRoot: false };\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n    const userProvidedOptions = schema._userProvidedOptions;\n    for (const _key of keys) {\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        // Use `schema.options` in `deepEqual()` because of `discriminatorKey`\n        // set above. We don't allow customizing discriminator key, always\n        // overwrite. See gh-9238\n        if (_key in userProvidedOptions && !utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key +\n            ' (can only modify ' +\n            Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +\n            ')');\n        }\n      }\n    }\n    schema.options = clone(baseSchema.options);\n\n    for (const _key of Object.keys(userProvidedOptions)) {\n      schema.options[_key] = userProvidedOptions[_key];\n    }\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n    schema.options.id = id;\n    if (mergeHooks) {\n      schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n    }\n    if (applyPlugins) {\n      schema.plugins = Array.prototype.slice.call(baseSchema.plugins);\n    }\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = { key: key, value: null, isRoot: true };\n  }\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name] && !schema.options.overwriteModels) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9kaXNjcmltaW5hdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDMUMsNEJBQTRCLG1CQUFPLENBQUMsc0hBQStCO0FBQ25FLGNBQWMsbUJBQU8sQ0FBQyw0RUFBVTtBQUNoQyxrQkFBa0IsbUlBQXdDO0FBQzFELFlBQVksbUJBQU8sQ0FBQyx3RUFBUTtBQUM1QixjQUFjLG1CQUFPLENBQUMsdUVBQWE7QUFDbkMsaUNBQWlDLG1CQUFPLENBQUMseUpBQXNEOztBQUUvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcbW9kZWxcXGRpc2NyaW1pbmF0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNaXhlZCA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9taXhlZCcpO1xuY29uc3QgYXBwbHlCdWlsdGluUGx1Z2lucyA9IHJlcXVpcmUoJy4uL3NjaGVtYS9hcHBseUJ1aWx0aW5QbHVnaW5zJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uL2Nsb25lJyk7XG5jb25zdCBkZWZpbmVLZXkgPSByZXF1aXJlKCcuLi9kb2N1bWVudC9jb21waWxlJykuZGVmaW5lS2V5O1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCBtZXJnZURpc2NyaW1pbmF0b3JTY2hlbWEgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvbWVyZ2VEaXNjcmltaW5hdG9yU2NoZW1hJyk7XG5cbmNvbnN0IENVU1RPTUlaQUJMRV9ESVNDUklNSU5BVE9SX09QVElPTlMgPSB7XG4gIHRvSlNPTjogdHJ1ZSxcbiAgdG9PYmplY3Q6IHRydWUsXG4gIF9pZDogdHJ1ZSxcbiAgaWQ6IHRydWUsXG4gIHZpcnR1YWxzOiB0cnVlLFxuICBtZXRob2RzOiB0cnVlXG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzY3JpbWluYXRvcihtb2RlbCwgbmFtZSwgc2NoZW1hLCB0aWVkVmFsdWUsIGFwcGx5UGx1Z2lucywgbWVyZ2VIb29rcykge1xuICBpZiAoIShzY2hlbWEgJiYgc2NoZW1hLmluc3RhbmNlT2ZTY2hlbWEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwYXNzIGEgdmFsaWQgZGlzY3JpbWluYXRvciBTY2hlbWEnKTtcbiAgfVxuXG4gIG1lcmdlSG9va3MgPSBtZXJnZUhvb2tzID09IG51bGwgPyB0cnVlIDogbWVyZ2VIb29rcztcblxuICBpZiAobW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nICYmXG4gICAgICAhbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLmlzUm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGlzY3JpbWluYXRvciBcIicgKyBuYW1lICtcbiAgICAgICAgJ1wiIGNhbiBvbmx5IGJlIGEgZGlzY3JpbWluYXRvciBvZiB0aGUgcm9vdCBtb2RlbCcpO1xuICB9XG5cbiAgaWYgKGFwcGx5UGx1Z2lucykge1xuICAgIGNvbnN0IGFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnMgPSBnZXQobW9kZWwuYmFzZSxcbiAgICAgICdvcHRpb25zLmFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnMnLCBmYWxzZSkgfHwgIW1lcmdlSG9va3M7XG4gICAgLy8gRXZlbiBpZiBgYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9yc2AgaXNuJ3Qgc2V0LCB3ZSBzaG91bGQgc3RpbGwgYXBwbHlcbiAgICAvLyBnbG9iYWwgcGx1Z2lucyB0byBzY2hlbWFzIGVtYmVkZGVkIGluIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSAoZ2gtNzM3MClcbiAgICBtb2RlbC5iYXNlLl9hcHBseVBsdWdpbnMoc2NoZW1hLCB7XG4gICAgICBza2lwVG9wTGV2ZWw6ICFhcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIW1lcmdlSG9va3MpIHtcbiAgICBhcHBseUJ1aWx0aW5QbHVnaW5zKHNjaGVtYSk7XG4gIH1cblxuICBjb25zdCBrZXkgPSBtb2RlbC5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuXG4gIGNvbnN0IGV4aXN0aW5nUGF0aCA9IG1vZGVsLnNjaGVtYS5wYXRoKGtleSk7XG4gIGlmIChleGlzdGluZ1BhdGggIT0gbnVsbCkge1xuICAgIGlmICghdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShleGlzdGluZ1BhdGgub3B0aW9ucywgJ3NlbGVjdCcpKSB7XG4gICAgICBleGlzdGluZ1BhdGgub3B0aW9ucy5zZWxlY3QgPSB0cnVlO1xuICAgIH1cbiAgICBleGlzdGluZ1BhdGgub3B0aW9ucy4kc2tpcERpc2NyaW1pbmF0b3JDaGVjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYmFzZVNjaGVtYUFkZGl0aW9uID0ge307XG4gICAgYmFzZVNjaGVtYUFkZGl0aW9uW2tleV0gPSB7XG4gICAgICBkZWZhdWx0OiB2b2lkIDAsXG4gICAgICBzZWxlY3Q6IHRydWUsXG4gICAgICAkc2tpcERpc2NyaW1pbmF0b3JDaGVjazogdHJ1ZVxuICAgIH07XG4gICAgYmFzZVNjaGVtYUFkZGl0aW9uW2tleV1bbW9kZWwuc2NoZW1hLm9wdGlvbnMudHlwZUtleV0gPSBTdHJpbmc7XG4gICAgbW9kZWwuc2NoZW1hLmFkZChiYXNlU2NoZW1hQWRkaXRpb24pO1xuICAgIGRlZmluZUtleSh7XG4gICAgICBwcm9wOiBrZXksXG4gICAgICBwcm90b3R5cGU6IG1vZGVsLnByb3RvdHlwZSxcbiAgICAgIG9wdGlvbnM6IG1vZGVsLnNjaGVtYS5vcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICBpZiAoc2NoZW1hLnBhdGgoa2V5KSAmJiBzY2hlbWEucGF0aChrZXkpLm9wdGlvbnMuJHNraXBEaXNjcmltaW5hdG9yQ2hlY2sgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rpc2NyaW1pbmF0b3IgXCInICsgbmFtZSArXG4gICAgICAgICdcIiBjYW5ub3QgaGF2ZSBmaWVsZCB3aXRoIG5hbWUgXCInICsga2V5ICsgJ1wiJyk7XG4gIH1cblxuICBsZXQgdmFsdWUgPSBuYW1lO1xuICBpZiAoKHR5cGVvZiB0aWVkVmFsdWUgPT09ICdzdHJpbmcnICYmIHRpZWRWYWx1ZS5sZW5ndGgpIHx8IHRpZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdmFsdWUgPSB0aWVkVmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZShzY2hlbWEsIGJhc2VTY2hlbWEpIHtcbiAgICAvLyBSZXRhaW4gb3JpZ2luYWwgc2NoZW1hIGJlZm9yZSBtZXJnaW5nIGJhc2Ugc2NoZW1hXG4gICAgc2NoZW1hLl9iYXNlU2NoZW1hID0gYmFzZVNjaGVtYTtcbiAgICBpZiAoYmFzZVNjaGVtYS5wYXRocy5faWQgJiZcbiAgICAgICAgYmFzZVNjaGVtYS5wYXRocy5faWQub3B0aW9ucyAmJlxuICAgICAgICAhYmFzZVNjaGVtYS5wYXRocy5faWQub3B0aW9ucy5hdXRvKSB7XG4gICAgICBzY2hlbWEucmVtb3ZlKCdfaWQnKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGNvbmZsaWN0aW5nIHBhdGhzOiBpZiBzb21ldGhpbmcgaXMgYSBwYXRoIGluIHRoZSBiYXNlIHNjaGVtYVxuICAgIC8vIGFuZCBhIG5lc3RlZCBwYXRoIGluIHRoZSBjaGlsZCBzY2hlbWEsIG92ZXJ3cml0ZSB0aGUgYmFzZSBzY2hlbWEgcGF0aC5cbiAgICAvLyBTZWUgZ2gtNjA3NlxuICAgIGNvbnN0IGJhc2VTY2hlbWFQYXRocyA9IE9iamVjdC5rZXlzKGJhc2VTY2hlbWEucGF0aHMpO1xuICAgIGNvbnN0IGNvbmZsaWN0aW5nUGF0aHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBiYXNlU2NoZW1hUGF0aHMpIHtcbiAgICAgIGlmIChzY2hlbWEubmVzdGVkW3BhdGhdKSB7XG4gICAgICAgIGNvbmZsaWN0aW5nUGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzcCA9IHBhdGguc3BsaXQoJy4nKS5zbGljZSgwLCAtMSk7XG4gICAgICBsZXQgY3VyID0gJyc7XG4gICAgICBmb3IgKGNvbnN0IHBpZWNlIG9mIHNwKSB7XG4gICAgICAgIGN1ciArPSAoY3VyLmxlbmd0aCA/ICcuJyA6ICcnKSArIHBpZWNlO1xuICAgICAgICBpZiAoc2NoZW1hLnBhdGhzW2N1cl0gaW5zdGFuY2VvZiBNaXhlZCB8fFxuICAgICAgICAgICAgc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzW2N1cl0gaW5zdGFuY2VvZiBNaXhlZCkge1xuICAgICAgICAgIGNvbmZsaWN0aW5nUGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG1lcmdlRGlzY3JpbWluYXRvclNjaGVtYShzY2hlbWEsIGJhc2VTY2hlbWEpO1xuXG4gICAgLy8gQ2xlYW4gdXAgY29uZmxpY3RpbmcgcGF0aHMgX2FmdGVyXyBtZXJnaW5nIHJlOiBnaC02MDc2XG4gICAgZm9yIChjb25zdCBjb25mbGljdGluZ1BhdGggb2YgY29uZmxpY3RpbmdQYXRocykge1xuICAgICAgZGVsZXRlIHNjaGVtYS5wYXRoc1tjb25mbGljdGluZ1BhdGhdO1xuICAgIH1cblxuICAgIC8vIFJlYnVpbGQgc2NoZW1hIG1vZGVscyBiZWNhdXNlIHNjaGVtYXMgbWF5IGhhdmUgYmVlbiBtZXJnZWQgcmU6ICM3ODg0XG4gICAgc2NoZW1hLmNoaWxkU2NoZW1hcy5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICBvYmoubW9kZWwucHJvdG90eXBlLiRfX3NldFNjaGVtYShvYmouc2NoZW1hKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIG9ialtrZXldID0ge1xuICAgICAgZGVmYXVsdDogdmFsdWUsXG4gICAgICBzZWxlY3Q6IHRydWUsXG4gICAgICBzZXQ6IGZ1bmN0aW9uKG5ld05hbWUpIHtcbiAgICAgICAgaWYgKG5ld05hbWUgPT09IHZhbHVlIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB1dGlscy5kZWVwRXF1YWwobmV3TmFtZSwgdmFsdWUpKSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3Qgc2V0IGRpc2NyaW1pbmF0b3Iga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgfSxcbiAgICAgICRza2lwRGlzY3JpbWluYXRvckNoZWNrOiB0cnVlXG4gICAgfTtcbiAgICBvYmpba2V5XVtzY2hlbWEub3B0aW9ucy50eXBlS2V5XSA9IGV4aXN0aW5nUGF0aCA/IGV4aXN0aW5nUGF0aC5vcHRpb25zW3NjaGVtYS5vcHRpb25zLnR5cGVLZXldIDogU3RyaW5nO1xuICAgIHNjaGVtYS5hZGQob2JqKTtcblxuICAgIHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyA9IHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSwgaXNSb290OiBmYWxzZSB9O1xuXG4gICAgaWYgKGJhc2VTY2hlbWEub3B0aW9ucy5jb2xsZWN0aW9uKSB7XG4gICAgICBzY2hlbWEub3B0aW9ucy5jb2xsZWN0aW9uID0gYmFzZVNjaGVtYS5vcHRpb25zLmNvbGxlY3Rpb247XG4gICAgfVxuICAgIGNvbnN0IHRvSlNPTiA9IHNjaGVtYS5vcHRpb25zLnRvSlNPTjtcbiAgICBjb25zdCB0b09iamVjdCA9IHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0O1xuICAgIGNvbnN0IF9pZCA9IHNjaGVtYS5vcHRpb25zLl9pZDtcbiAgICBjb25zdCBpZCA9IHNjaGVtYS5vcHRpb25zLmlkO1xuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYS5vcHRpb25zKTtcbiAgICBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5ID0gYmFzZVNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gICAgY29uc3QgdXNlclByb3ZpZGVkT3B0aW9ucyA9IHNjaGVtYS5fdXNlclByb3ZpZGVkT3B0aW9ucztcbiAgICBmb3IgKGNvbnN0IF9rZXkgb2Yga2V5cykge1xuICAgICAgaWYgKCFDVVNUT01JWkFCTEVfRElTQ1JJTUlOQVRPUl9PUFRJT05TW19rZXldKSB7XG4gICAgICAgIC8vIFVzZSBgc2NoZW1hLm9wdGlvbnNgIGluIGBkZWVwRXF1YWwoKWAgYmVjYXVzZSBvZiBgZGlzY3JpbWluYXRvcktleWBcbiAgICAgICAgLy8gc2V0IGFib3ZlLiBXZSBkb24ndCBhbGxvdyBjdXN0b21pemluZyBkaXNjcmltaW5hdG9yIGtleSwgYWx3YXlzXG4gICAgICAgIC8vIG92ZXJ3cml0ZS4gU2VlIGdoLTkyMzhcbiAgICAgICAgaWYgKF9rZXkgaW4gdXNlclByb3ZpZGVkT3B0aW9ucyAmJiAhdXRpbHMuZGVlcEVxdWFsKHNjaGVtYS5vcHRpb25zW19rZXldLCBiYXNlU2NoZW1hLm9wdGlvbnNbX2tleV0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGN1c3RvbWl6ZSBkaXNjcmltaW5hdG9yIG9wdGlvbiAnICsgX2tleSArXG4gICAgICAgICAgICAnIChjYW4gb25seSBtb2RpZnkgJyArXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhDVVNUT01JWkFCTEVfRElTQ1JJTUlOQVRPUl9PUFRJT05TKS5qb2luKCcsICcpICtcbiAgICAgICAgICAgICcpJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2NoZW1hLm9wdGlvbnMgPSBjbG9uZShiYXNlU2NoZW1hLm9wdGlvbnMpO1xuXG4gICAgZm9yIChjb25zdCBfa2V5IG9mIE9iamVjdC5rZXlzKHVzZXJQcm92aWRlZE9wdGlvbnMpKSB7XG4gICAgICBzY2hlbWEub3B0aW9uc1tfa2V5XSA9IHVzZXJQcm92aWRlZE9wdGlvbnNbX2tleV07XG4gICAgfVxuICAgIGlmICh0b0pTT04pIHNjaGVtYS5vcHRpb25zLnRvSlNPTiA9IHRvSlNPTjtcbiAgICBpZiAodG9PYmplY3QpIHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0ID0gdG9PYmplY3Q7XG4gICAgaWYgKHR5cGVvZiBfaWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzY2hlbWEub3B0aW9ucy5faWQgPSBfaWQ7XG4gICAgfVxuICAgIHNjaGVtYS5vcHRpb25zLmlkID0gaWQ7XG4gICAgaWYgKG1lcmdlSG9va3MpIHtcbiAgICAgIHNjaGVtYS5zLmhvb2tzID0gbW9kZWwuc2NoZW1hLnMuaG9va3MubWVyZ2Uoc2NoZW1hLnMuaG9va3MpO1xuICAgIH1cbiAgICBpZiAoYXBwbHlQbHVnaW5zKSB7XG4gICAgICBzY2hlbWEucGx1Z2lucyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJhc2VTY2hlbWEucGx1Z2lucyk7XG4gICAgfVxuICAgIHNjaGVtYS5jYWxsUXVldWUgPSBiYXNlU2NoZW1hLmNhbGxRdWV1ZS5jb25jYXQoc2NoZW1hLmNhbGxRdWV1ZSk7XG4gICAgZGVsZXRlIHNjaGVtYS5fcmVxdWlyZWRwYXRoczsgLy8gcmVzZXQganVzdCBpbiBjYXNlIFNjaGVtYSNyZXF1aXJlZFBhdGhzKCkgd2FzIGNhbGxlZCBvbiBlaXRoZXIgc2NoZW1hXG4gIH1cblxuICAvLyBtZXJnZXMgYmFzZSBzY2hlbWEgaW50byBuZXcgZGlzY3JpbWluYXRvciBzY2hlbWEgYW5kIHNldHMgbmV3IHR5cGUgZmllbGQuXG4gIG1lcmdlKHNjaGVtYSwgbW9kZWwuc2NoZW1hKTtcblxuICBpZiAoIW1vZGVsLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgbW9kZWwuZGlzY3JpbWluYXRvcnMgPSB7fTtcbiAgfVxuXG4gIGlmICghbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nKSB7XG4gICAgbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nID0geyBrZXk6IGtleSwgdmFsdWU6IG51bGwsIGlzUm9vdDogdHJ1ZSB9O1xuICB9XG4gIGlmICghbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JzID0ge307XG4gIH1cblxuICBtb2RlbC5zY2hlbWEuZGlzY3JpbWluYXRvcnNbbmFtZV0gPSBzY2hlbWE7XG5cbiAgaWYgKG1vZGVsLmRpc2NyaW1pbmF0b3JzW25hbWVdICYmICFzY2hlbWEub3B0aW9ucy5vdmVyd3JpdGVNb2RlbHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rpc2NyaW1pbmF0b3Igd2l0aCBuYW1lIFwiJyArIG5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMnKTtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWE7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/model/discriminator.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function pushNestedArrayPaths(paths, nestedArray, path) {\n  if (nestedArray == null) {\n    return;\n  }\n\n  for (let i = 0; i < nestedArray.length; ++i) {\n    if (Array.isArray(nestedArray[i])) {\n      pushNestedArrayPaths(paths, nestedArray[i], path + '.' + i);\n    } else {\n      paths.push(path + '.' + i);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9wdXNoTmVzdGVkQXJyYXlQYXRocy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxtb2RlbFxccHVzaE5lc3RlZEFycmF5UGF0aHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHB1c2hOZXN0ZWRBcnJheVBhdGhzKHBhdGhzLCBuZXN0ZWRBcnJheSwgcGF0aCkge1xuICBpZiAobmVzdGVkQXJyYXkgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmVzdGVkQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXN0ZWRBcnJheVtpXSkpIHtcbiAgICAgIHB1c2hOZXN0ZWRBcnJheVBhdGhzKHBhdGhzLCBuZXN0ZWRBcnJheVtpXSwgcGF0aCArICcuJyArIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRocy5wdXNoKHBhdGggKyAnLicgKyBpKTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/parallelLimit.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/parallelLimit.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = parallelLimit;\n\n/*!\n * ignore\n */\n\nfunction parallelLimit(fns, limit, callback) {\n  let numInProgress = 0;\n  let numFinished = 0;\n  let error = null;\n\n  if (limit <= 0) {\n    throw new Error('Limit must be positive');\n  }\n\n  if (fns.length === 0) {\n    return callback(null, []);\n  }\n\n  for (let i = 0; i < fns.length && i < limit; ++i) {\n    _start();\n  }\n\n  function _start() {\n    fns[numFinished + numInProgress](_done(numFinished + numInProgress));\n    ++numInProgress;\n  }\n\n  const results = [];\n\n  function _done(index) {\n    return (err, res) => {\n      --numInProgress;\n      ++numFinished;\n\n      if (error != null) {\n        return;\n      }\n      if (err != null) {\n        error = err;\n        return callback(error);\n      }\n\n      results[index] = res;\n\n      if (numFinished === fns.length) {\n        return callback(null, results);\n      } else if (numFinished + numInProgress < fns.length) {\n        _start();\n      }\n    };\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wYXJhbGxlbExpbWl0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxwYXJhbGxlbExpbWl0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJhbGxlbExpbWl0O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIHBhcmFsbGVsTGltaXQoZm5zLCBsaW1pdCwgY2FsbGJhY2spIHtcbiAgbGV0IG51bUluUHJvZ3Jlc3MgPSAwO1xuICBsZXQgbnVtRmluaXNoZWQgPSAwO1xuICBsZXQgZXJyb3IgPSBudWxsO1xuXG4gIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMaW1pdCBtdXN0IGJlIHBvc2l0aXZlJyk7XG4gIH1cblxuICBpZiAoZm5zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGggJiYgaSA8IGxpbWl0OyArK2kpIHtcbiAgICBfc3RhcnQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zdGFydCgpIHtcbiAgICBmbnNbbnVtRmluaXNoZWQgKyBudW1JblByb2dyZXNzXShfZG9uZShudW1GaW5pc2hlZCArIG51bUluUHJvZ3Jlc3MpKTtcbiAgICArK251bUluUHJvZ3Jlc3M7XG4gIH1cblxuICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgZnVuY3Rpb24gX2RvbmUoaW5kZXgpIHtcbiAgICByZXR1cm4gKGVyciwgcmVzKSA9PiB7XG4gICAgICAtLW51bUluUHJvZ3Jlc3M7XG4gICAgICArK251bUZpbmlzaGVkO1xuXG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gcmVzO1xuXG4gICAgICBpZiAobnVtRmluaXNoZWQgPT09IGZucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgfSBlbHNlIGlmIChudW1GaW5pc2hlZCArIG51bUluUHJvZ3Jlc3MgPCBmbnMubGVuZ3RoKSB7XG4gICAgICAgIF9zdGFydCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/parallelLimit.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/path/parentPaths.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/path/parentPaths.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst dotRE = /\\./g;\nmodule.exports = function parentPaths(path) {\n  if (path.indexOf('.') === -1) {\n    return [path];\n  }\n  const pieces = path.split(dotRE);\n  const len = pieces.length;\n  const ret = new Array(len);\n  let cur = '';\n  for (let i = 0; i < len; ++i) {\n    cur += (cur.length !== 0) ? '.' + pieces[i] : pieces[i];\n    ret[i] = cur;\n  }\n\n  return ret;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wYXRoL3BhcmVudFBhdGhzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccGF0aFxccGFyZW50UGF0aHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkb3RSRSA9IC9cXC4vZztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyZW50UGF0aHMocGF0aCkge1xuICBpZiAocGF0aC5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIFtwYXRoXTtcbiAgfVxuICBjb25zdCBwaWVjZXMgPSBwYXRoLnNwbGl0KGRvdFJFKTtcbiAgY29uc3QgbGVuID0gcGllY2VzLmxlbmd0aDtcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5KGxlbik7XG4gIGxldCBjdXIgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGN1ciArPSAoY3VyLmxlbmd0aCAhPT0gMCkgPyAnLicgKyBwaWVjZXNbaV0gOiBwaWVjZXNbaV07XG4gICAgcmV0W2ldID0gY3VyO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/path/parentPaths.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/path/setDottedPath.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/path/setDottedPath.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst specialProperties = __webpack_require__(/*! ../specialProperties */ \"(api)/../server/node_modules/mongoose/lib/helpers/specialProperties.js\");\n\n\nmodule.exports = function setDottedPath(obj, path, val) {\n  if (path.indexOf('.') === -1) {\n    if (specialProperties.has(path)) {\n      return;\n    }\n\n    obj[path] = val;\n    return;\n  }\n  const parts = path.split('.');\n\n  const last = parts.pop();\n  let cur = obj;\n  for (const part of parts) {\n    if (specialProperties.has(part)) {\n      continue;\n    }\n    if (cur[part] == null) {\n      cur[part] = {};\n    }\n\n    cur = cur[part];\n  }\n\n  if (!specialProperties.has(last)) {\n    cur[last] = val;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wYXRoL3NldERvdHRlZFBhdGguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEJBQTBCLG1CQUFPLENBQUMsb0dBQXNCOzs7QUFHeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHBhdGhcXHNldERvdHRlZFBhdGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzcGVjaWFsUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3NwZWNpYWxQcm9wZXJ0aWVzJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXREb3R0ZWRQYXRoKG9iaiwgcGF0aCwgdmFsKSB7XG4gIGlmIChwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKHBhdGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb2JqW3BhdGhdID0gdmFsO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcblxuICBjb25zdCBsYXN0ID0gcGFydHMucG9wKCk7XG4gIGxldCBjdXIgPSBvYmo7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMocGFydCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY3VyW3BhcnRdID09IG51bGwpIHtcbiAgICAgIGN1cltwYXJ0XSA9IHt9O1xuICAgIH1cblxuICAgIGN1ciA9IGN1cltwYXJ0XTtcbiAgfVxuXG4gIGlmICghc3BlY2lhbFByb3BlcnRpZXMuaGFzKGxhc3QpKSB7XG4gICAgY3VyW2xhc3RdID0gdmFsO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/path/setDottedPath.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/pluralize.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/pluralize.js ***!
  \****************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nmodule.exports = pluralize;\n\n/**\n * Pluralization rules.\n */\n\nexports.pluralization = [\n  [/human$/gi, 'humans'],\n  [/(m)an$/gi, '$1en'],\n  [/(pe)rson$/gi, '$1ople'],\n  [/(child)$/gi, '$1ren'],\n  [/^(ox)$/gi, '$1en'],\n  [/(ax|test)is$/gi, '$1es'],\n  [/(octop|vir)us$/gi, '$1i'],\n  [/(alias|status)$/gi, '$1es'],\n  [/(bu)s$/gi, '$1ses'],\n  [/(buffal|tomat|potat)o$/gi, '$1oes'],\n  [/([ti])um$/gi, '$1a'],\n  [/sis$/gi, 'ses'],\n  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],\n  [/(hive)$/gi, '$1s'],\n  [/([^aeiouy]|qu)y$/gi, '$1ies'],\n  [/(x|ch|ss|sh)$/gi, '$1es'],\n  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],\n  [/([m|l])ouse$/gi, '$1ice'],\n  [/(kn|w|l)ife$/gi, '$1ives'],\n  [/(quiz)$/gi, '$1zes'],\n  [/^goose$/i, 'geese'],\n  [/s$/gi, 's'],\n  [/([^a-z])$/, '$1'],\n  [/$/gi, 's']\n];\nconst rules = exports.pluralization;\n\n/**\n * Uncountable words.\n *\n * These words are applied while processing the argument to `toCollectionName`.\n * @api public\n */\n\nexports.uncountables = [\n  'advice',\n  'energy',\n  'excretion',\n  'digestion',\n  'cooperation',\n  'health',\n  'justice',\n  'labour',\n  'machinery',\n  'equipment',\n  'information',\n  'pollution',\n  'sewage',\n  'paper',\n  'money',\n  'species',\n  'series',\n  'rain',\n  'rice',\n  'fish',\n  'sheep',\n  'moose',\n  'deer',\n  'news',\n  'expertise',\n  'status',\n  'media'\n];\nconst uncountables = exports.uncountables;\n\n/**\n * Pluralize function.\n *\n * @author TJ Holowaychuk (extracted from _ext.js_)\n * @param {String} string to pluralize\n * @api private\n */\n\nfunction pluralize(str) {\n  let found;\n  str = str.toLowerCase();\n  if (!~uncountables.indexOf(str)) {\n    found = rules.filter(function(rule) {\n      return str.match(rule[0]);\n    });\n    if (found[0]) {\n      return str.replace(found[0][0], found[0][1]);\n    }\n  }\n  return str;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wbHVyYWxpemUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxwbHVyYWxpemUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBsdXJhbGl6ZTtcblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIHJ1bGVzLlxuICovXG5cbmV4cG9ydHMucGx1cmFsaXphdGlvbiA9IFtcbiAgWy9odW1hbiQvZ2ksICdodW1hbnMnXSxcbiAgWy8obSlhbiQvZ2ksICckMWVuJ10sXG4gIFsvKHBlKXJzb24kL2dpLCAnJDFvcGxlJ10sXG4gIFsvKGNoaWxkKSQvZ2ksICckMXJlbiddLFxuICBbL14ob3gpJC9naSwgJyQxZW4nXSxcbiAgWy8oYXh8dGVzdClpcyQvZ2ksICckMWVzJ10sXG4gIFsvKG9jdG9wfHZpcil1cyQvZ2ksICckMWknXSxcbiAgWy8oYWxpYXN8c3RhdHVzKSQvZ2ksICckMWVzJ10sXG4gIFsvKGJ1KXMkL2dpLCAnJDFzZXMnXSxcbiAgWy8oYnVmZmFsfHRvbWF0fHBvdGF0KW8kL2dpLCAnJDFvZXMnXSxcbiAgWy8oW3RpXSl1bSQvZ2ksICckMWEnXSxcbiAgWy9zaXMkL2dpLCAnc2VzJ10sXG4gIFsvKD86KFteZl0pZmV8KFtscl0pZikkL2dpLCAnJDEkMnZlcyddLFxuICBbLyhoaXZlKSQvZ2ksICckMXMnXSxcbiAgWy8oW15hZWlvdXldfHF1KXkkL2dpLCAnJDFpZXMnXSxcbiAgWy8oeHxjaHxzc3xzaCkkL2dpLCAnJDFlcyddLFxuICBbLyhtYXRyfHZlcnR8aW5kKWl4fGV4JC9naSwgJyQxaWNlcyddLFxuICBbLyhbbXxsXSlvdXNlJC9naSwgJyQxaWNlJ10sXG4gIFsvKGtufHd8bClpZmUkL2dpLCAnJDFpdmVzJ10sXG4gIFsvKHF1aXopJC9naSwgJyQxemVzJ10sXG4gIFsvXmdvb3NlJC9pLCAnZ2Vlc2UnXSxcbiAgWy9zJC9naSwgJ3MnXSxcbiAgWy8oW15hLXpdKSQvLCAnJDEnXSxcbiAgWy8kL2dpLCAncyddXG5dO1xuY29uc3QgcnVsZXMgPSBleHBvcnRzLnBsdXJhbGl6YXRpb247XG5cbi8qKlxuICogVW5jb3VudGFibGUgd29yZHMuXG4gKlxuICogVGhlc2Ugd29yZHMgYXJlIGFwcGxpZWQgd2hpbGUgcHJvY2Vzc2luZyB0aGUgYXJndW1lbnQgdG8gYHRvQ29sbGVjdGlvbk5hbWVgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnVuY291bnRhYmxlcyA9IFtcbiAgJ2FkdmljZScsXG4gICdlbmVyZ3knLFxuICAnZXhjcmV0aW9uJyxcbiAgJ2RpZ2VzdGlvbicsXG4gICdjb29wZXJhdGlvbicsXG4gICdoZWFsdGgnLFxuICAnanVzdGljZScsXG4gICdsYWJvdXInLFxuICAnbWFjaGluZXJ5JyxcbiAgJ2VxdWlwbWVudCcsXG4gICdpbmZvcm1hdGlvbicsXG4gICdwb2xsdXRpb24nLFxuICAnc2V3YWdlJyxcbiAgJ3BhcGVyJyxcbiAgJ21vbmV5JyxcbiAgJ3NwZWNpZXMnLFxuICAnc2VyaWVzJyxcbiAgJ3JhaW4nLFxuICAncmljZScsXG4gICdmaXNoJyxcbiAgJ3NoZWVwJyxcbiAgJ21vb3NlJyxcbiAgJ2RlZXInLFxuICAnbmV3cycsXG4gICdleHBlcnRpc2UnLFxuICAnc3RhdHVzJyxcbiAgJ21lZGlhJ1xuXTtcbmNvbnN0IHVuY291bnRhYmxlcyA9IGV4cG9ydHMudW5jb3VudGFibGVzO1xuXG4vKipcbiAqIFBsdXJhbGl6ZSBmdW5jdGlvbi5cbiAqXG4gKiBAYXV0aG9yIFRKIEhvbG93YXljaHVrIChleHRyYWN0ZWQgZnJvbSBfZXh0LmpzXylcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdG8gcGx1cmFsaXplXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWxpemUoc3RyKSB7XG4gIGxldCBmb3VuZDtcbiAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghfnVuY291bnRhYmxlcy5pbmRleE9mKHN0cikpIHtcbiAgICBmb3VuZCA9IHJ1bGVzLmZpbHRlcihmdW5jdGlvbihydWxlKSB7XG4gICAgICByZXR1cm4gc3RyLm1hdGNoKHJ1bGVbMF0pO1xuICAgIH0pO1xuICAgIGlmIChmb3VuZFswXSkge1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKGZvdW5kWzBdWzBdLCBmb3VuZFswXVsxXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/pluralize.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function SkipPopulateValue(val) {\n  if (!(this instanceof SkipPopulateValue)) {\n    return new SkipPopulateValue(val);\n  }\n\n  this.val = val;\n  return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9Ta2lwUG9wdWxhdGVWYWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxwb3B1bGF0ZVxcU2tpcFBvcHVsYXRlVmFsdWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFNraXBQb3B1bGF0ZVZhbHVlKHZhbCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2tpcFBvcHVsYXRlVmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBTa2lwUG9wdWxhdGVWYWx1ZSh2YWwpO1xuICB9XG5cbiAgdGhpcy52YWwgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js":
/*!******************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../../helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./leanPopulateMap */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst modelSymbol = (__webpack_require__(/*! ../symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").modelSymbol);\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = assignRawDocsToIdStructure;\n\nconst kHasArray = Symbol('assignRawDocsToIdStructure.hasArray');\n\n/**\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} resultDocs\n * @param {Array} resultOrder\n * @param {Object} options\n * @param {Boolean} recursed\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order, unless we're populating a single\n  // virtual underneath an array (e.g. populating `employees.mostRecentShift` where\n  // `mostRecentShift` is a virtual with `justOne`)\n  const newOrder = [];\n  const sorting = options.isVirtual && options.justOne && rawIds.length > 1\n    ? false :\n    options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n\n  if (utils.isMongooseArray(rawIds)) {\n    rawIds = rawIds.__array;\n  }\n\n  let i = 0;\n  const len = rawIds.length;\n\n  if (sorting && recursed && options[kHasArray] === undefined) {\n    options[kHasArray] = false;\n    for (const key in resultOrder) {\n      if (Array.isArray(resultOrder[key])) {\n        options[kHasArray] = true;\n        break;\n      }\n    }\n  }\n\n  for (i = 0; i < len; ++i) {\n    id = rawIds[i];\n\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id === null && sorting === false) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n\n    sid = String(id);\n    doc = resultDocs[sid];\n    // If user wants separate copies of same doc, use this option\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n        doc = clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          const _resultOrder = resultOrder[sid];\n          if (options[kHasArray]) {\n            // If result arrays, rely on the MongoDB server response for ordering\n            newOrder.push(doc);\n          } else {\n            newOrder[_resultOrder] = doc;\n          }\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function(doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9hc3NpZ25SYXdEb2NzVG9JZFN0cnVjdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsdUZBQXFCO0FBQzNDLHdCQUF3QixtQkFBTyxDQUFDLHdHQUFtQjtBQUNuRCxvQkFBb0IsbUhBQWlDO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyx1RUFBYTs7QUFFbkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxwb3B1bGF0ZVxcYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGxlYW5Qb3B1bGF0ZU1hcCA9IHJlcXVpcmUoJy4vbGVhblBvcHVsYXRlTWFwJyk7XG5jb25zdCBtb2RlbFN5bWJvbCA9IHJlcXVpcmUoJy4uL3N5bWJvbHMnKS5tb2RlbFN5bWJvbDtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25SYXdEb2NzVG9JZFN0cnVjdHVyZTtcblxuY29uc3Qga0hhc0FycmF5ID0gU3ltYm9sKCdhc3NpZ25SYXdEb2NzVG9JZFN0cnVjdHVyZS5oYXNBcnJheScpO1xuXG4vKipcbiAqIEFzc2lnbiBgdmFsc2AgcmV0dXJuZWQgYnkgbW9uZ28gcXVlcnkgdG8gdGhlIGByYXdJZHNgXG4gKiBzdHJ1Y3R1cmUgcmV0dXJuZWQgZnJvbSB1dGlscy5nZXRWYWxzKCkgaG9ub3JpbmdcbiAqIHF1ZXJ5IHNvcnQgb3JkZXIgaWYgc3BlY2lmaWVkIGJ5IHVzZXIuXG4gKlxuICogVGhpcyBjYW4gYmUgb3B0aW1pemVkLlxuICpcbiAqIFJ1bGVzOlxuICpcbiAqICAgaWYgdGhlIHZhbHVlIG9mIHRoZSBwYXRoIGlzIG5vdCBhbiBhcnJheSwgdXNlIGZpbmRPbmUgcnVsZXMsIGVsc2UgZmluZC5cbiAqICAgZm9yIGZpbmRPbmUgdGhlIHJlc3VsdHMgYXJlIGFzc2lnbmVkIGRpcmVjdGx5IHRvIGRvYyBwYXRoIChpbmNsdWRpbmcgbnVsbCByZXN1bHRzKS5cbiAqICAgZm9yIGZpbmQsIGlmIHVzZXIgc3BlY2lmaWVkIHNvcnQgb3JkZXIsIHJlc3VsdHMgYXJlIGFzc2lnbmVkIGRpcmVjdGx5XG4gKiAgIGVsc2UgZG9jdW1lbnRzIGFyZSBwdXQgYmFjayBpbiBvcmlnaW5hbCBvcmRlciBvZiBhcnJheSBpZiBmb3VuZCBpbiByZXN1bHRzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcmF3SWRzXG4gKiBAcGFyYW0ge0FycmF5fSByZXN1bHREb2NzXG4gKiBAcGFyYW0ge0FycmF5fSByZXN1bHRPcmRlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVjdXJzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGFzc2lnblJhd0RvY3NUb0lkU3RydWN0dXJlKHJhd0lkcywgcmVzdWx0RG9jcywgcmVzdWx0T3JkZXIsIG9wdGlvbnMsIHJlY3Vyc2VkKSB7XG4gIC8vIGhvbm9yIHVzZXIgc3BlY2lmaWVkIHNvcnQgb3JkZXIsIHVubGVzcyB3ZSdyZSBwb3B1bGF0aW5nIGEgc2luZ2xlXG4gIC8vIHZpcnR1YWwgdW5kZXJuZWF0aCBhbiBhcnJheSAoZS5nLiBwb3B1bGF0aW5nIGBlbXBsb3llZXMubW9zdFJlY2VudFNoaWZ0YCB3aGVyZVxuICAvLyBgbW9zdFJlY2VudFNoaWZ0YCBpcyBhIHZpcnR1YWwgd2l0aCBganVzdE9uZWApXG4gIGNvbnN0IG5ld09yZGVyID0gW107XG4gIGNvbnN0IHNvcnRpbmcgPSBvcHRpb25zLmlzVmlydHVhbCAmJiBvcHRpb25zLmp1c3RPbmUgJiYgcmF3SWRzLmxlbmd0aCA+IDFcbiAgICA/IGZhbHNlIDpcbiAgICBvcHRpb25zLnNvcnQgJiYgcmF3SWRzLmxlbmd0aCA+IDE7XG4gIGNvbnN0IG51bGxJZk5vdEZvdW5kID0gb3B0aW9ucy4kbnVsbElmTm90Rm91bmQ7XG4gIGxldCBkb2M7XG4gIGxldCBzaWQ7XG4gIGxldCBpZDtcblxuICBpZiAodXRpbHMuaXNNb25nb29zZUFycmF5KHJhd0lkcykpIHtcbiAgICByYXdJZHMgPSByYXdJZHMuX19hcnJheTtcbiAgfVxuXG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuID0gcmF3SWRzLmxlbmd0aDtcblxuICBpZiAoc29ydGluZyAmJiByZWN1cnNlZCAmJiBvcHRpb25zW2tIYXNBcnJheV0gPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnNba0hhc0FycmF5XSA9IGZhbHNlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdE9yZGVyKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRPcmRlcltrZXldKSkge1xuICAgICAgICBvcHRpb25zW2tIYXNBcnJheV0gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZCA9IHJhd0lkc1tpXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgICAgLy8gaGFuZGxlIFsgW2lkMCwgaWQyXSwgW2lkM10gXVxuICAgICAgYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmUoaWQsIHJlc3VsdERvY3MsIHJlc3VsdE9yZGVyLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgIG5ld09yZGVyLnB1c2goaWQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGlkID09PSBudWxsICYmIHNvcnRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAvLyBrZWVwIG51bGxzIGZvciBmaW5kT25lIHVubGVzcyBzb3J0aW5nLCB3aGljaCBhbHdheXNcbiAgICAgIC8vIHJlbW92ZXMgdGhlbSAoYmFja3dhcmQgY29tcGF0KVxuICAgICAgbmV3T3JkZXIucHVzaChpZCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzaWQgPSBTdHJpbmcoaWQpO1xuICAgIGRvYyA9IHJlc3VsdERvY3Nbc2lkXTtcbiAgICAvLyBJZiB1c2VyIHdhbnRzIHNlcGFyYXRlIGNvcGllcyBvZiBzYW1lIGRvYywgdXNlIHRoaXMgb3B0aW9uXG4gICAgaWYgKG9wdGlvbnMuY2xvbmUgJiYgZG9jICE9IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLmxlYW4pIHtcbiAgICAgICAgY29uc3QgX21vZGVsID0gbGVhblBvcHVsYXRlTWFwLmdldChkb2MpO1xuICAgICAgICBkb2MgPSBjbG9uZShkb2MpO1xuICAgICAgICBsZWFuUG9wdWxhdGVNYXAuc2V0KGRvYywgX21vZGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvYyA9IGRvYy5jb25zdHJ1Y3Rvci5oeWRyYXRlKGRvYy5fZG9jKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVjdXJzZWQpIHtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgaWYgKHNvcnRpbmcpIHtcbiAgICAgICAgICBjb25zdCBfcmVzdWx0T3JkZXIgPSByZXN1bHRPcmRlcltzaWRdO1xuICAgICAgICAgIGlmIChvcHRpb25zW2tIYXNBcnJheV0pIHtcbiAgICAgICAgICAgIC8vIElmIHJlc3VsdCBhcnJheXMsIHJlbHkgb24gdGhlIE1vbmdvREIgc2VydmVyIHJlc3BvbnNlIGZvciBvcmRlcmluZ1xuICAgICAgICAgICAgbmV3T3JkZXIucHVzaChkb2MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdPcmRlcltfcmVzdWx0T3JkZXJdID0gZG9jO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdPcmRlci5wdXNoKGRvYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWQgIT0gbnVsbCAmJiBpZFttb2RlbFN5bWJvbF0gIT0gbnVsbCkge1xuICAgICAgICBuZXdPcmRlci5wdXNoKGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09yZGVyLnB1c2gob3B0aW9ucy5yZXRhaW5OdWxsVmFsdWVzIHx8IG51bGxJZk5vdEZvdW5kID8gbnVsbCA6IGlkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXBwbHkgZmluZE9uZSBiZWhhdmlvciAtIGlmIGRvY3VtZW50IGluIHJlc3VsdHMsIGFzc2lnbiwgZWxzZSBhc3NpZ24gbnVsbFxuICAgICAgbmV3T3JkZXJbaV0gPSBkb2MgfHwgbnVsbDtcbiAgICB9XG4gIH1cblxuICByYXdJZHMubGVuZ3RoID0gMDtcbiAgaWYgKG5ld09yZGVyLmxlbmd0aCkge1xuICAgIC8vIHJlYXNzaWduIHRoZSBkb2N1bWVudHMgYmFzZWQgb24gY29ycmVjdGVkIG9yZGVyXG5cbiAgICAvLyBmb3JFYWNoIHNraXBzIG92ZXIgc3BhcnNlIGVudHJpZXMgaW4gYXJyYXlzIHNvIHdlXG4gICAgLy8gY2FuIHNhZmVseSB1c2UgdGhpcyB0byBvdXIgYWR2YW50YWdlIGRlYWxpbmcgd2l0aCBzb3J0ZWRcbiAgICAvLyByZXN1bHQgc2V0cyB0b28uXG4gICAgbmV3T3JkZXIuZm9yRWFjaChmdW5jdGlvbihkb2MsIGkpIHtcbiAgICAgIHJhd0lkc1tpXSA9IGRvYztcbiAgICB9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/assignVals.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/assignVals.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseMap = __webpack_require__(/*! ../../types/map */ \"(api)/../server/node_modules/mongoose/lib/types/map.js\");\nconst SkipPopulateValue = __webpack_require__(/*! ./SkipPopulateValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js\");\nconst assignRawDocsToIdStructure = __webpack_require__(/*! ./assignRawDocsToIdStructure */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js\");\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getVirtual = __webpack_require__(/*! ./getVirtual */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/getVirtual.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./leanPopulateMap */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst lookupLocalFields = __webpack_require__(/*! ./lookupLocalFields */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\");\nconst markArraySubdocsPopulated = __webpack_require__(/*! ./markArraySubdocsPopulated */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(api)/../server/node_modules/mpath/index.js\");\nconst sift = (__webpack_require__(/*! sift */ \"(api)/../server/node_modules/sift/index.js\")[\"default\"]);\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst { populateModelSymbol } = __webpack_require__(/*! ../symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\");\n\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));\n  // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne,\n    isVirtual: o.isVirtual\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n\n  const originalIds = [].concat(o.rawIds);\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n  let setValueIndex = 0;\n\n  function setValue(val) {\n    ++setValueIndex;\n    if (count) {\n      return val;\n    }\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n    if (val === void 0) {\n      return val;\n    }\n\n    const _allIds = o.allIds[i];\n\n    if (o.path.endsWith('.$*')) {\n      // Skip maps re: gh-12494\n      return valueFilter(val, options, populateOptions, _allIds);\n    }\n\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      }\n      // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    } else if (o.justOne === true && !Array.isArray(val) && Array.isArray(_allIds)) {\n      return valueFilter(val, options, populateOptions, val == null ? val : _allIds[setValueIndex - 1]);\n    }\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n\n  for (i = 0; i < docs.length; ++i) {\n    setValueIndex = 0;\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n\n    let valueToSet;\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ?\n        rawIds[i].filter(v => v == null || sift(o.match[i])(v)) :\n        [rawIds[i]].filter(v => v == null || sift(o.match[i])(v))[0];\n    } else {\n      valueToSet = rawIds[i];\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ?\n      existingVal instanceof Map :\n      utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ?\n        Array.from(existingVal.keys()) :\n        Object.keys(existingVal);\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val != null && val.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n\n    if (o.isVirtual && isDoc) {\n      docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      if (Array.isArray(valueToSet)) {\n        valueToSet = valueToSet.map(v => v == null ? void 0 : v);\n      }\n      mpath.set(_path, valueToSet, docs[i], void 0, setValue, false);\n      continue;\n    }\n\n    const parts = _path.split('.');\n    let cur = docs[i];\n    let curPath = parts[0];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n\n      if (parts[j] === '$*') {\n        break;\n      }\n\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const schematype = originalSchema._getSchema(curPath);\n        if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {\n          break;\n        }\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n      curPath += parts[j + 1] ? `.${parts[j + 1]}` : '';\n      // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n    if (docs[i].$__) {\n      o.allOptions.options[populateModelSymbol] = o.allOptions.model;\n      docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);\n\n      if (valueToSet != null && valueToSet.$__ != null) {\n        valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] };\n      }\n\n      if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {\n        valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);\n      }\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n\n    if (docs[i].$__) {\n      markArraySubdocsPopulated(docs[i], [o.allOptions.options]);\n    }\n  }\n};\n\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el) || el === null)) {\n      return v.map(el => {\n        if (el == null) {\n          return 0;\n        }\n        if (Array.isArray(el)) {\n          return el.filter(el => el != null).length;\n        }\n        return 1;\n      });\n    }\n    return v.filter(el => el != null).length;\n  }\n  return v == null ? 0 : 1;\n}\n\n/**\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n * @param {Any} val\n * @param {Object} assignmentOpts\n * @param {Object} populateOptions\n * @param {Function} [populateOptions.transform]\n * @param {Boolean} allIds\n * @api private\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : noop;\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (!populateOptions.retainNullValues && subdoc == null) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit &&\n          ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    const rLen = ret.length;\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > rLen) {\n      Array.prototype.pop.apply(val, []);\n    }\n    let i = 0;\n    if (utils.isMongooseArray(val)) {\n      for (i = 0; i < rLen; ++i) {\n        val.set(i, ret[i], true);\n      }\n    } else {\n      for (i = 0; i < rLen; ++i) {\n        val[i] = ret[i];\n      }\n    }\n    return val;\n  }\n\n  // findOne\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n  if (val instanceof Map) {\n    return val;\n  }\n\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n\n/**\n * Remove _id from `subdoc` if user specified \"lean\" query option\n * @param {Document} subdoc\n * @param {Object} assignmentOpts\n * @api private\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/**\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n * @param {Any} obj\n * @api private\n */\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return Array.isArray(obj) ||\n    obj.$isMongooseMap ||\n    obj.$__ != null ||\n    leanPopulateMap.has(obj);\n}\n\nfunction noop(v) {\n  return v;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9hc3NpZ25WYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLCtFQUFpQjtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBcUI7QUFDdkQsbUNBQW1DLG1CQUFPLENBQUMsOEhBQThCO0FBQ3pFLFlBQVksbUJBQU8sQ0FBQyx3RUFBUTtBQUM1QixtQkFBbUIsbUJBQU8sQ0FBQyw4RkFBYztBQUN6Qyx3QkFBd0IsbUJBQU8sQ0FBQyx3R0FBbUI7QUFDbkQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQXFCO0FBQ3ZELGtDQUFrQyxtQkFBTyxDQUFDLDRIQUE2QjtBQUN2RSxjQUFjLG1CQUFPLENBQUMsMERBQU87QUFDN0IsYUFBYSwwRkFBdUI7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHVFQUFhO0FBQ25DLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxnRkFBWTs7QUFFcEQ7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccG9wdWxhdGVcXGFzc2lnblZhbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZU1hcCA9IHJlcXVpcmUoJy4uLy4uL3R5cGVzL21hcCcpO1xuY29uc3QgU2tpcFBvcHVsYXRlVmFsdWUgPSByZXF1aXJlKCcuL1NraXBQb3B1bGF0ZVZhbHVlJyk7XG5jb25zdCBhc3NpZ25SYXdEb2NzVG9JZFN0cnVjdHVyZSA9IHJlcXVpcmUoJy4vYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmUnKTtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuY29uc3QgZ2V0VmlydHVhbCA9IHJlcXVpcmUoJy4vZ2V0VmlydHVhbCcpO1xuY29uc3QgbGVhblBvcHVsYXRlTWFwID0gcmVxdWlyZSgnLi9sZWFuUG9wdWxhdGVNYXAnKTtcbmNvbnN0IGxvb2t1cExvY2FsRmllbGRzID0gcmVxdWlyZSgnLi9sb29rdXBMb2NhbEZpZWxkcycpO1xuY29uc3QgbWFya0FycmF5U3ViZG9jc1BvcHVsYXRlZCA9IHJlcXVpcmUoJy4vbWFya0FycmF5U3ViZG9jc1BvcHVsYXRlZCcpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3Qgc2lmdCA9IHJlcXVpcmUoJ3NpZnQnKS5kZWZhdWx0O1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgeyBwb3B1bGF0ZU1vZGVsU3ltYm9sIH0gPSByZXF1aXJlKCcuLi9zeW1ib2xzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXNzaWduVmFscyhvKSB7XG4gIC8vIE9wdGlvbnMgdGhhdCBhcmVuJ3QgZXhwbGljaXRseSBsaXN0ZWQgaW4gYHBvcHVsYXRlT3B0aW9uc2BcbiAgY29uc3QgdXNlck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBnZXQobywgJ2FsbE9wdGlvbnMub3B0aW9ucy5vcHRpb25zJyksIGdldChvLCAnYWxsT3B0aW9ucy5vcHRpb25zJykpO1xuICAvLyBgby5vcHRpb25zYCBjb250YWlucyBvcHRpb25zIGV4cGxpY2l0bHkgbGlzdGVkIGluIGBwb3B1bGF0ZU9wdGlvbnNgLCBsaWtlXG4gIC8vIGBtYXRjaGAgYW5kIGBsaW1pdGAuXG4gIGNvbnN0IHBvcHVsYXRlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG8ub3B0aW9ucywgdXNlck9wdGlvbnMsIHtcbiAgICBqdXN0T25lOiBvLmp1c3RPbmUsXG4gICAgaXNWaXJ0dWFsOiBvLmlzVmlydHVhbFxuICB9KTtcbiAgcG9wdWxhdGVPcHRpb25zLiRudWxsSWZOb3RGb3VuZCA9IG8uaXNWaXJ0dWFsO1xuICBjb25zdCBwb3B1bGF0ZWRNb2RlbCA9IG8ucG9wdWxhdGVkTW9kZWw7XG5cbiAgY29uc3Qgb3JpZ2luYWxJZHMgPSBbXS5jb25jYXQoby5yYXdJZHMpO1xuXG4gIC8vIHJlcGxhY2UgdGhlIG9yaWdpbmFsIGlkcyBpbiBvdXIgaW50ZXJtZWRpYXRlIF9pZHMgc3RydWN0dXJlXG4gIC8vIHdpdGggdGhlIGRvY3VtZW50cyBmb3VuZCBieSBxdWVyeVxuICBvLmFsbElkcyA9IFtdLmNvbmNhdChvLmFsbElkcyk7XG4gIGFzc2lnblJhd0RvY3NUb0lkU3RydWN0dXJlKG8ucmF3SWRzLCBvLnJhd0RvY3MsIG8ucmF3T3JkZXIsIHBvcHVsYXRlT3B0aW9ucyk7XG5cbiAgLy8gbm93IHVwZGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnRzIGJlaW5nIHBvcHVsYXRlZCB1c2luZyB0aGVcbiAgLy8gcmVzdWx0IHN0cnVjdHVyZSB0aGF0IGNvbnRhaW5zIHJlYWwgZG9jdW1lbnRzLlxuICBjb25zdCBkb2NzID0gby5kb2NzO1xuICBjb25zdCByYXdJZHMgPSBvLnJhd0lkcztcbiAgY29uc3Qgb3B0aW9ucyA9IG8ub3B0aW9ucztcbiAgY29uc3QgY291bnQgPSBvLmNvdW50ICYmIG8uaXNWaXJ0dWFsO1xuICBsZXQgaTtcbiAgbGV0IHNldFZhbHVlSW5kZXggPSAwO1xuXG4gIGZ1bmN0aW9uIHNldFZhbHVlKHZhbCkge1xuICAgICsrc2V0VmFsdWVJbmRleDtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTa2lwUG9wdWxhdGVWYWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbC52YWw7XG4gICAgfVxuICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBjb25zdCBfYWxsSWRzID0gby5hbGxJZHNbaV07XG5cbiAgICBpZiAoby5wYXRoLmVuZHNXaXRoKCcuJConKSkge1xuICAgICAgLy8gU2tpcCBtYXBzIHJlOiBnaC0xMjQ5NFxuICAgICAgcmV0dXJuIHZhbHVlRmlsdGVyKHZhbCwgb3B0aW9ucywgcG9wdWxhdGVPcHRpb25zLCBfYWxsSWRzKTtcbiAgICB9XG5cbiAgICBpZiAoby5qdXN0T25lID09PSB0cnVlICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gTWlnaHQgYmUgYW4gZW1iZWRkZWQgZGlzY3JpbWluYXRvciAocmU6IGdoLTkyNDQpIHdpdGggbXVsdGlwbGUgbW9kZWxzLCBzbyBtYWtlIHN1cmUgdG8gcGljayB0aGUgcmlnaHRcbiAgICAgIC8vIG1vZGVsIGJlZm9yZSBhc3NpZ25pbmcuXG4gICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZG9jIG9mIHZhbCkge1xuICAgICAgICBjb25zdCBfZG9jUG9wdWxhdGVkTW9kZWwgPSBsZWFuUG9wdWxhdGVNYXAuZ2V0KGRvYyk7XG4gICAgICAgIGlmIChfZG9jUG9wdWxhdGVkTW9kZWwgPT0gbnVsbCB8fCBfZG9jUG9wdWxhdGVkTW9kZWwgPT09IHBvcHVsYXRlZE1vZGVsKSB7XG4gICAgICAgICAgcmV0LnB1c2goZG9jKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qgd2FudCB0byBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBtb25nb29zZWFycmF5LCBtYWtlIHN1cmUgdG9cbiAgICAgIC8vIG1vZGlmeSB0aGUgYXJyYXkgaW4gcGxhY2VcbiAgICAgIHdoaWxlICh2YWwubGVuZ3RoID4gcmV0Lmxlbmd0aCkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucG9wLmFwcGx5KHZhbCwgW10pO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsW2ldID0gcmV0W2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVGaWx0ZXIodmFsWzBdLCBvcHRpb25zLCBwb3B1bGF0ZU9wdGlvbnMsIF9hbGxJZHMpO1xuICAgIH0gZWxzZSBpZiAoby5qdXN0T25lID09PSBmYWxzZSAmJiAhQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXR1cm4gdmFsdWVGaWx0ZXIoW3ZhbF0sIG9wdGlvbnMsIHBvcHVsYXRlT3B0aW9ucywgX2FsbElkcyk7XG4gICAgfSBlbHNlIGlmIChvLmp1c3RPbmUgPT09IHRydWUgJiYgIUFycmF5LmlzQXJyYXkodmFsKSAmJiBBcnJheS5pc0FycmF5KF9hbGxJZHMpKSB7XG4gICAgICByZXR1cm4gdmFsdWVGaWx0ZXIodmFsLCBvcHRpb25zLCBwb3B1bGF0ZU9wdGlvbnMsIHZhbCA9PSBudWxsID8gdmFsIDogX2FsbElkc1tzZXRWYWx1ZUluZGV4IC0gMV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVGaWx0ZXIodmFsLCBvcHRpb25zLCBwb3B1bGF0ZU9wdGlvbnMsIF9hbGxJZHMpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGRvY3MubGVuZ3RoOyArK2kpIHtcbiAgICBzZXRWYWx1ZUluZGV4ID0gMDtcbiAgICBjb25zdCBfcGF0aCA9IG8ucGF0aC5lbmRzV2l0aCgnLiQqJykgPyBvLnBhdGguc2xpY2UoMCwgLTMpIDogby5wYXRoO1xuICAgIGNvbnN0IGV4aXN0aW5nVmFsID0gbXBhdGguZ2V0KF9wYXRoLCBkb2NzW2ldLCBsb29rdXBMb2NhbEZpZWxkcyk7XG4gICAgaWYgKGV4aXN0aW5nVmFsID09IG51bGwgJiYgIWdldFZpcnR1YWwoby5vcmlnaW5hbE1vZGVsLnNjaGVtYSwgX3BhdGgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgdmFsdWVUb1NldDtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHZhbHVlVG9TZXQgPSBudW1Eb2NzKHJhd0lkc1tpXSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG8ubWF0Y2gpKSB7XG4gICAgICB2YWx1ZVRvU2V0ID0gQXJyYXkuaXNBcnJheShyYXdJZHNbaV0pID9cbiAgICAgICAgcmF3SWRzW2ldLmZpbHRlcih2ID0+IHYgPT0gbnVsbCB8fCBzaWZ0KG8ubWF0Y2hbaV0pKHYpKSA6XG4gICAgICAgIFtyYXdJZHNbaV1dLmZpbHRlcih2ID0+IHYgPT0gbnVsbCB8fCBzaWZ0KG8ubWF0Y2hbaV0pKHYpKVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVUb1NldCA9IHJhd0lkc1tpXTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBwb3B1bGF0aW5nIGEgbWFwLCB0aGUgZXhpc3RpbmcgdmFsdWUgd2lsbCBiZSBhbiBvYmplY3QsIHNvXG4gICAgLy8gd2UgbmVlZCB0byB0cmFuc2Zvcm0gYWdhaW5cbiAgICBjb25zdCBvcmlnaW5hbFNjaGVtYSA9IG8ub3JpZ2luYWxNb2RlbC5zY2hlbWE7XG4gICAgY29uc3QgaXNEb2MgPSBnZXQoZG9jc1tpXSwgJyRfXycsIG51bGwpICE9IG51bGw7XG4gICAgbGV0IGlzTWFwID0gaXNEb2MgP1xuICAgICAgZXhpc3RpbmdWYWwgaW5zdGFuY2VvZiBNYXAgOlxuICAgICAgdXRpbHMuaXNQT0pPKGV4aXN0aW5nVmFsKTtcbiAgICAvLyBJZiB3ZSBwYXNzIHRoZSBmaXJzdCBjaGVjaywgYWxzbyBtYWtlIHN1cmUgdGhlIGxvY2FsIGZpZWxkJ3Mgc2NoZW1hdHlwZVxuICAgIC8vIGlzIG1hcCAocmU6IGdoLTY0NjApXG4gICAgaXNNYXAgPSBpc01hcCAmJiBnZXQob3JpZ2luYWxTY2hlbWEuX2dldFNjaGVtYShfcGF0aCksICckaXNTY2hlbWFNYXAnKTtcbiAgICBpZiAoIW8uaXNWaXJ0dWFsICYmIGlzTWFwKSB7XG4gICAgICBjb25zdCBfa2V5cyA9IGV4aXN0aW5nVmFsIGluc3RhbmNlb2YgTWFwID9cbiAgICAgICAgQXJyYXkuZnJvbShleGlzdGluZ1ZhbC5rZXlzKCkpIDpcbiAgICAgICAgT2JqZWN0LmtleXMoZXhpc3RpbmdWYWwpO1xuICAgICAgdmFsdWVUb1NldCA9IHZhbHVlVG9TZXQucmVkdWNlKChjdXIsIHYsIGkpID0+IHtcbiAgICAgICAgY3VyLnNldChfa2V5c1tpXSwgdik7XG4gICAgICAgIHJldHVybiBjdXI7XG4gICAgICB9LCBuZXcgTWFwKCkpO1xuICAgIH1cblxuICAgIGlmIChpc0RvYyAmJiBBcnJheS5pc0FycmF5KHZhbHVlVG9TZXQpKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbCBvZiB2YWx1ZVRvU2V0KSB7XG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwuJF9fICE9IG51bGwpIHtcbiAgICAgICAgICB2YWwuJF9fLnBhcmVudCA9IGRvY3NbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRG9jICYmIHZhbHVlVG9TZXQgIT0gbnVsbCAmJiB2YWx1ZVRvU2V0LiRfXyAhPSBudWxsKSB7XG4gICAgICB2YWx1ZVRvU2V0LiRfXy5wYXJlbnQgPSBkb2NzW2ldO1xuICAgIH1cblxuICAgIGlmIChvLmlzVmlydHVhbCAmJiBpc0RvYykge1xuICAgICAgZG9jc1tpXS4kcG9wdWxhdGVkKF9wYXRoLCBvLmp1c3RPbmUgPyBvcmlnaW5hbElkc1swXSA6IG9yaWdpbmFsSWRzLCBvLmFsbE9wdGlvbnMpO1xuICAgICAgLy8gSWYgdmlydHVhbCBwb3B1bGF0ZSBhbmQgZG9jIGlzIGFscmVhZHkgaW5pdC1lZCwgbmVlZCB0byB3YWxrIHRocm91Z2hcbiAgICAgIC8vIHRoZSBhY3R1YWwgZG9jIHRvIHNldCByYXRoZXIgdGhhbiBzZXR0aW5nIGBfZG9jYCBkaXJlY3RseVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVUb1NldCkpIHtcbiAgICAgICAgdmFsdWVUb1NldCA9IHZhbHVlVG9TZXQubWFwKHYgPT4gdiA9PSBudWxsID8gdm9pZCAwIDogdik7XG4gICAgICB9XG4gICAgICBtcGF0aC5zZXQoX3BhdGgsIHZhbHVlVG9TZXQsIGRvY3NbaV0sIHZvaWQgMCwgc2V0VmFsdWUsIGZhbHNlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnRzID0gX3BhdGguc3BsaXQoJy4nKTtcbiAgICBsZXQgY3VyID0gZG9jc1tpXTtcbiAgICBsZXQgY3VyUGF0aCA9IHBhcnRzWzBdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFydHMubGVuZ3RoIC0gMTsgKytqKSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgdG8gYW4gYXJyYXkgd2l0aCBhIGRvdHRlZCBwYXRoLCBsaWtlIGBhcnIuZm9vYCwgZG9uJ3Qgc2V0XG4gICAgICAvLyBgZm9vYCBvbiB0aGUgYXJyYXkuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXIpICYmICF1dGlscy5pc0FycmF5SW5kZXgocGFydHNbal0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFydHNbal0gPT09ICckKicpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJbcGFydHNbal1dID09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgbm90aGluZyB0byBzZXQsIGF2b2lkIGNyZWF0aW5nIGFuIHVubmVjZXNzYXJ5IGFycmF5LiBPdGhlcndpc2VcbiAgICAgICAgLy8gd2UnbGwgZW5kIHVwIHdpdGggYSBzaW5nbGUgZG9jIGluIHRoZSBhcnJheSB3aXRoIG9ubHkgZGVmYXVsdHMuXG4gICAgICAgIC8vIFNlZSBnaC04MzQyLCBnaC04NDU1XG4gICAgICAgIGNvbnN0IHNjaGVtYXR5cGUgPSBvcmlnaW5hbFNjaGVtYS5fZ2V0U2NoZW1hKGN1clBhdGgpO1xuICAgICAgICBpZiAodmFsdWVUb1NldCA9PSBudWxsICYmIHNjaGVtYXR5cGUgIT0gbnVsbCAmJiBzY2hlbWF0eXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJbcGFydHNbal1dID0ge307XG4gICAgICB9XG4gICAgICBjdXIgPSBjdXJbcGFydHNbal1dO1xuICAgICAgY3VyUGF0aCArPSBwYXJ0c1tqICsgMV0gPyBgLiR7cGFydHNbaiArIDFdfWAgOiAnJztcbiAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpbiBNb25nb0RCIGlzIGEgcHJpbWl0aXZlLCB3ZSB3b24ndCBiZSBhYmxlIHRvIHBvcHVsYXRlXG4gICAgICAvLyB0aGUgbmVzdGVkIHBhdGgsIHNvIHNraXAgaXQuIFNlZSBnaC03NTQ1XG4gICAgICBpZiAodHlwZW9mIGN1ciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkb2NzW2ldLiRfXykge1xuICAgICAgby5hbGxPcHRpb25zLm9wdGlvbnNbcG9wdWxhdGVNb2RlbFN5bWJvbF0gPSBvLmFsbE9wdGlvbnMubW9kZWw7XG4gICAgICBkb2NzW2ldLiRwb3B1bGF0ZWQoX3BhdGgsIG8udW5wb3B1bGF0ZWRWYWx1ZXNbaV0sIG8uYWxsT3B0aW9ucy5vcHRpb25zKTtcblxuICAgICAgaWYgKHZhbHVlVG9TZXQgIT0gbnVsbCAmJiB2YWx1ZVRvU2V0LiRfXyAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlVG9TZXQuJF9fLndhc1BvcHVsYXRlZCA9IHsgdmFsdWU6IG8udW5wb3B1bGF0ZWRWYWx1ZXNbaV0gfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlVG9TZXQgaW5zdGFuY2VvZiBNYXAgJiYgIXZhbHVlVG9TZXQuJGlzTW9uZ29vc2VNYXApIHtcbiAgICAgICAgdmFsdWVUb1NldCA9IG5ldyBNb25nb29zZU1hcCh2YWx1ZVRvU2V0LCBfcGF0aCwgZG9jc1tpXSwgZG9jc1tpXS5zY2hlbWEucGF0aChfcGF0aCkuJF9fc2NoZW1hVHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbGVhbiwgbmVlZCB0byBjaGVjayB0aGF0IGVhY2ggaW5kaXZpZHVhbCB2aXJ0dWFsIHJlc3BlY3RzXG4gICAgLy8gYGp1c3RPbmVgLCBiZWNhdXNlIHlvdSBtYXkgaGF2ZSBhIHBvcHVsYXRlZCB2aXJ0dWFsIHdpdGggYGp1c3RPbmVgXG4gICAgLy8gdW5kZXJuZWF0aCBhbiBhcnJheS4gU2VlIGdoLTY4NjdcbiAgICBtcGF0aC5zZXQoX3BhdGgsIHZhbHVlVG9TZXQsIGRvY3NbaV0sIGxvb2t1cExvY2FsRmllbGRzLCBzZXRWYWx1ZSwgZmFsc2UpO1xuXG4gICAgaWYgKGRvY3NbaV0uJF9fKSB7XG4gICAgICBtYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkKGRvY3NbaV0sIFtvLmFsbE9wdGlvbnMub3B0aW9uc10pO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gbnVtRG9jcyh2KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgLy8gSWYgc2V0dGluZyB1bmRlcm5lYXRoIGFuIGFycmF5IG9mIHBvcHVsYXRlZCBzdWJkb2NzLCB3ZSBtYXkgaGF2ZSBhblxuICAgIC8vIGFycmF5IG9mIGFycmF5cy4gU2VlIGdoLTc1NzNcbiAgICBpZiAodi5zb21lKGVsID0+IEFycmF5LmlzQXJyYXkoZWwpIHx8IGVsID09PSBudWxsKSkge1xuICAgICAgcmV0dXJuIHYubWFwKGVsID0+IHtcbiAgICAgICAgaWYgKGVsID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgICAgICByZXR1cm4gZWwuZmlsdGVyKGVsID0+IGVsICE9IG51bGwpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdi5maWx0ZXIoZWwgPT4gZWwgIT0gbnVsbCkubGVuZ3RoO1xuICB9XG4gIHJldHVybiB2ID09IG51bGwgPyAwIDogMTtcbn1cblxuLyoqXG4gKiAxKSBBcHBseSBiYWNrd2FyZHMgY29tcGF0aWJsZSBmaW5kL2ZpbmRPbmUgYmVoYXZpb3IgdG8gc3ViIGRvY3VtZW50c1xuICpcbiAqICAgIGZpbmQgbG9naWM6XG4gKiAgICAgIGEpIGZpbHRlciBvdXQgbm9uLWRvY3VtZW50c1xuICogICAgICBiKSByZW1vdmUgX2lkIGZyb20gc3ViIGRvY3Mgd2hlbiB1c2VyIHNwZWNpZmllZFxuICpcbiAqICAgIGZpbmRPbmVcbiAqICAgICAgYSkgaWYgbm8gZG9jIGZvdW5kLCBzZXQgdG8gbnVsbFxuICogICAgICBiKSByZW1vdmUgX2lkIGZyb20gc3ViIGRvY3Mgd2hlbiB1c2VyIHNwZWNpZmllZFxuICpcbiAqIDIpIFJlbW92ZSBfaWRzIHdoZW4gc3BlY2lmaWVkIGJ5IHVzZXJzIHF1ZXJ5LlxuICpcbiAqIGJhY2tncm91bmQ6XG4gKiBfaWRzIGFyZSBsZWZ0IGluIHRoZSBxdWVyeSBldmVuIHdoZW4gdXNlciBleGNsdWRlcyB0aGVtIHNvXG4gKiB0aGF0IHBvcHVsYXRpb24gbWFwcGluZyBjYW4gb2NjdXIuXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gYXNzaWdubWVudE9wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3B1bGF0ZU9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwb3B1bGF0ZU9wdGlvbnMudHJhbnNmb3JtXVxuICogQHBhcmFtIHtCb29sZWFufSBhbGxJZHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHZhbHVlRmlsdGVyKHZhbCwgYXNzaWdubWVudE9wdHMsIHBvcHVsYXRlT3B0aW9ucywgYWxsSWRzKSB7XG4gIGNvbnN0IHVzZXJTcGVjaWZpZWRUcmFuc2Zvcm0gPSB0eXBlb2YgcG9wdWxhdGVPcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJztcbiAgY29uc3QgdHJhbnNmb3JtID0gdXNlclNwZWNpZmllZFRyYW5zZm9ybSA/IHBvcHVsYXRlT3B0aW9ucy50cmFuc2Zvcm0gOiBub29wO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgLy8gZmluZCBsb2dpY1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IHZhbC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WYWx1ZXM7ICsraSkge1xuICAgICAgbGV0IHN1YmRvYyA9IHZhbFtpXTtcbiAgICAgIGNvbnN0IF9hbGxJZHMgPSBBcnJheS5pc0FycmF5KGFsbElkcykgPyBhbGxJZHNbaV0gOiBhbGxJZHM7XG4gICAgICBpZiAoIWlzUG9wdWxhdGVkT2JqZWN0KHN1YmRvYykgJiYgKCFwb3B1bGF0ZU9wdGlvbnMucmV0YWluTnVsbFZhbHVlcyB8fCBzdWJkb2MgIT0gbnVsbCkgJiYgIXVzZXJTcGVjaWZpZWRUcmFuc2Zvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKCFwb3B1bGF0ZU9wdGlvbnMucmV0YWluTnVsbFZhbHVlcyAmJiBzdWJkb2MgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAodXNlclNwZWNpZmllZFRyYW5zZm9ybSkge1xuICAgICAgICBzdWJkb2MgPSB0cmFuc2Zvcm0oaXNQb3B1bGF0ZWRPYmplY3Qoc3ViZG9jKSA/IHN1YmRvYyA6IG51bGwsIF9hbGxJZHMpO1xuICAgICAgfVxuICAgICAgbWF5YmVSZW1vdmVJZChzdWJkb2MsIGFzc2lnbm1lbnRPcHRzKTtcbiAgICAgIHJldC5wdXNoKHN1YmRvYyk7XG4gICAgICBpZiAoYXNzaWdubWVudE9wdHMub3JpZ2luYWxMaW1pdCAmJlxuICAgICAgICAgIHJldC5sZW5ndGggPj0gYXNzaWdubWVudE9wdHMub3JpZ2luYWxMaW1pdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByTGVuID0gcmV0Lmxlbmd0aDtcbiAgICAvLyBTaW5jZSB3ZSBkb24ndCB3YW50IHRvIGhhdmUgdG8gY3JlYXRlIGEgbmV3IG1vbmdvb3NlYXJyYXksIG1ha2Ugc3VyZSB0b1xuICAgIC8vIG1vZGlmeSB0aGUgYXJyYXkgaW4gcGxhY2VcbiAgICB3aGlsZSAodmFsLmxlbmd0aCA+IHJMZW4pIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wb3AuYXBwbHkodmFsLCBbXSk7XG4gICAgfVxuICAgIGxldCBpID0gMDtcbiAgICBpZiAodXRpbHMuaXNNb25nb29zZUFycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByTGVuOyArK2kpIHtcbiAgICAgICAgdmFsLnNldChpLCByZXRbaV0sIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgckxlbjsgKytpKSB7XG4gICAgICAgIHZhbFtpXSA9IHJldFtpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIC8vIGZpbmRPbmVcbiAgaWYgKGlzUG9wdWxhdGVkT2JqZWN0KHZhbCkgfHwgdXRpbHMuaXNQT0pPKHZhbCkpIHtcbiAgICBtYXliZVJlbW92ZUlkKHZhbCwgYXNzaWdubWVudE9wdHMpO1xuICAgIHJldHVybiB0cmFuc2Zvcm0odmFsLCBhbGxJZHMpO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgaWYgKHBvcHVsYXRlT3B0aW9ucy5qdXN0T25lID09PSBmYWxzZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiB2YWwgPT0gbnVsbCA/IHRyYW5zZm9ybSh2YWwsIGFsbElkcykgOiB0cmFuc2Zvcm0obnVsbCwgYWxsSWRzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgX2lkIGZyb20gYHN1YmRvY2AgaWYgdXNlciBzcGVjaWZpZWQgXCJsZWFuXCIgcXVlcnkgb3B0aW9uXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBzdWJkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBhc3NpZ25tZW50T3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWF5YmVSZW1vdmVJZChzdWJkb2MsIGFzc2lnbm1lbnRPcHRzKSB7XG4gIGlmIChzdWJkb2MgIT0gbnVsbCAmJiBhc3NpZ25tZW50T3B0cy5leGNsdWRlSWQpIHtcbiAgICBpZiAodHlwZW9mIHN1YmRvYy4kX19zZXRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGVsZXRlIHN1YmRvYy5fZG9jLl9pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHN1YmRvYy5faWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGBvYmpgIGlzIHNvbWV0aGluZyB3ZSBjYW4gc2V0IGEgcG9wdWxhdGVkIHBhdGggdG8uIENhbiBiZSBhXG4gKiBkb2N1bWVudCwgYSBsZWFuIGRvY3VtZW50LCBvciBhbiBhcnJheS9tYXAgdGhhdCBjb250YWlucyBkb2NzLlxuICogQHBhcmFtIHtBbnl9IG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNQb3B1bGF0ZWRPYmplY3Qob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICBvYmouJGlzTW9uZ29vc2VNYXAgfHxcbiAgICBvYmouJF9fICE9IG51bGwgfHxcbiAgICBsZWFuUG9wdWxhdGVNYXAuaGFzKG9iaik7XG59XG5cbmZ1bmN0aW9uIG5vb3Aodikge1xuICByZXR1cm4gdjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/assignVals.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js":
/*!*****************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SkipPopulateValue = __webpack_require__(/*! ./SkipPopulateValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js\");\nconst parentPaths = __webpack_require__(/*! ../path/parentPaths */ \"(api)/../server/node_modules/mongoose/lib/helpers/path/parentPaths.js\");\nconst { trusted } = __webpack_require__(/*! ../query/trusted */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/trusted.js\");\nconst hasDollarKeys = __webpack_require__(/*! ../query/hasDollarKeys */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\");\n\nmodule.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {\n  const match = _formatMatch(_match);\n\n  if (_foreignField.size === 1) {\n    const foreignField = Array.from(_foreignField)[0];\n    const foreignSchemaType = model.schema.path(foreignField);\n    if (foreignField !== '_id' || !match['_id']) {\n      ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n      match[foreignField] = trusted({ $in: ids });\n    } else if (foreignField === '_id' && match['_id']) {\n      const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ?\n        match[foreignField] :\n        { $eq: match[foreignField] };\n      match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };\n    }\n\n    const _parentPaths = parentPaths(foreignField);\n    for (let i = 0; i < _parentPaths.length - 1; ++i) {\n      const cur = _parentPaths[i];\n      if (match[cur] != null && match[cur].$elemMatch != null) {\n        match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = trusted({ $in: ids });\n        delete match[foreignField];\n        break;\n      }\n    }\n  } else {\n    const $or = [];\n    if (Array.isArray(match.$or)) {\n      match.$and = [{ $or: match.$or }, { $or: $or }];\n      delete match.$or;\n    } else {\n      match.$or = $or;\n    }\n    for (const foreignField of _foreignField) {\n      if (foreignField !== '_id' || !match['_id']) {\n        const foreignSchemaType = model.schema.path(foreignField);\n        ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n        $or.push({ [foreignField]: { $in: ids } });\n      } else if (foreignField === '_id' && match['_id']) {\n        const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ?\n          match[foreignField] :\n          { $eq: match[foreignField] };\n        match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };\n      }\n    }\n  }\n\n  return match;\n};\n\n/**\n * Optionally filter out invalid ids that don't conform to foreign field's schema\n * to avoid cast errors (gh-7706)\n * @param {Array} ids\n * @param {SchemaType} foreignSchemaType\n * @param {Boolean} [skipInvalidIds]\n * @api private\n */\n\nfunction _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {\n  ids = ids.filter(v => !(v instanceof SkipPopulateValue));\n  if (!skipInvalidIds) {\n    return ids;\n  }\n  return ids.filter(id => {\n    try {\n      foreignSchemaType.cast(id);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  });\n}\n\n/**\n * Format `mod.match` given that it may be an array that we need to $or if\n * the client has multiple docs with match functions\n * @param {Array|Any} match\n * @api private\n */\n\nfunction _formatMatch(match) {\n  if (Array.isArray(match)) {\n    if (match.length > 1) {\n      return { $or: [].concat(match.map(m => Object.assign({}, m))) };\n    }\n    return Object.assign({}, match[0]);\n  }\n  return Object.assign({}, match);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9jcmVhdGVQb3B1bGF0ZVF1ZXJ5RmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDRHQUFxQjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyxrR0FBcUI7QUFDakQsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyw0RkFBa0I7QUFDOUMsc0JBQXNCLG1CQUFPLENBQUMsd0dBQXdCOztBQUV0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRCxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDViw4QkFBOEIsYUFBYSxVQUFVO0FBQ3JEOztBQUVBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0EsOEVBQThFLFVBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0IsSUFBSSxVQUFVO0FBQ3BEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0IsWUFBWTtBQUNqRCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFlBQVk7QUFDWixnQ0FBZ0MsYUFBYSxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBOEM7QUFDN0Q7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxwb3B1bGF0ZVxcY3JlYXRlUG9wdWxhdGVRdWVyeUZpbHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNraXBQb3B1bGF0ZVZhbHVlID0gcmVxdWlyZSgnLi9Ta2lwUG9wdWxhdGVWYWx1ZScpO1xuY29uc3QgcGFyZW50UGF0aHMgPSByZXF1aXJlKCcuLi9wYXRoL3BhcmVudFBhdGhzJyk7XG5jb25zdCB7IHRydXN0ZWQgfSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L3RydXN0ZWQnKTtcbmNvbnN0IGhhc0RvbGxhcktleXMgPSByZXF1aXJlKCcuLi9xdWVyeS9oYXNEb2xsYXJLZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlUG9wdWxhdGVRdWVyeUZpbHRlcihpZHMsIF9tYXRjaCwgX2ZvcmVpZ25GaWVsZCwgbW9kZWwsIHNraXBJbnZhbGlkSWRzKSB7XG4gIGNvbnN0IG1hdGNoID0gX2Zvcm1hdE1hdGNoKF9tYXRjaCk7XG5cbiAgaWYgKF9mb3JlaWduRmllbGQuc2l6ZSA9PT0gMSkge1xuICAgIGNvbnN0IGZvcmVpZ25GaWVsZCA9IEFycmF5LmZyb20oX2ZvcmVpZ25GaWVsZClbMF07XG4gICAgY29uc3QgZm9yZWlnblNjaGVtYVR5cGUgPSBtb2RlbC5zY2hlbWEucGF0aChmb3JlaWduRmllbGQpO1xuICAgIGlmIChmb3JlaWduRmllbGQgIT09ICdfaWQnIHx8ICFtYXRjaFsnX2lkJ10pIHtcbiAgICAgIGlkcyA9IF9maWx0ZXJJbnZhbGlkSWRzKGlkcywgZm9yZWlnblNjaGVtYVR5cGUsIHNraXBJbnZhbGlkSWRzKTtcbiAgICAgIG1hdGNoW2ZvcmVpZ25GaWVsZF0gPSB0cnVzdGVkKHsgJGluOiBpZHMgfSk7XG4gICAgfSBlbHNlIGlmIChmb3JlaWduRmllbGQgPT09ICdfaWQnICYmIG1hdGNoWydfaWQnXSkge1xuICAgICAgY29uc3QgdXNlclNwZWNpZmllZE1hdGNoID0gaGFzRG9sbGFyS2V5cyhtYXRjaFtmb3JlaWduRmllbGRdKSA/XG4gICAgICAgIG1hdGNoW2ZvcmVpZ25GaWVsZF0gOlxuICAgICAgICB7ICRlcTogbWF0Y2hbZm9yZWlnbkZpZWxkXSB9O1xuICAgICAgbWF0Y2hbZm9yZWlnbkZpZWxkXSA9IHsgLi4udHJ1c3RlZCh7ICRpbjogaWRzIH0pLCAuLi51c2VyU3BlY2lmaWVkTWF0Y2ggfTtcbiAgICB9XG5cbiAgICBjb25zdCBfcGFyZW50UGF0aHMgPSBwYXJlbnRQYXRocyhmb3JlaWduRmllbGQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX3BhcmVudFBhdGhzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgY29uc3QgY3VyID0gX3BhcmVudFBhdGhzW2ldO1xuICAgICAgaWYgKG1hdGNoW2N1cl0gIT0gbnVsbCAmJiBtYXRjaFtjdXJdLiRlbGVtTWF0Y2ggIT0gbnVsbCkge1xuICAgICAgICBtYXRjaFtjdXJdLiRlbGVtTWF0Y2hbZm9yZWlnbkZpZWxkLnNsaWNlKGN1ci5sZW5ndGggKyAxKV0gPSB0cnVzdGVkKHsgJGluOiBpZHMgfSk7XG4gICAgICAgIGRlbGV0ZSBtYXRjaFtmb3JlaWduRmllbGRdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgJG9yID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0Y2guJG9yKSkge1xuICAgICAgbWF0Y2guJGFuZCA9IFt7ICRvcjogbWF0Y2guJG9yIH0sIHsgJG9yOiAkb3IgfV07XG4gICAgICBkZWxldGUgbWF0Y2guJG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaC4kb3IgPSAkb3I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZm9yZWlnbkZpZWxkIG9mIF9mb3JlaWduRmllbGQpIHtcbiAgICAgIGlmIChmb3JlaWduRmllbGQgIT09ICdfaWQnIHx8ICFtYXRjaFsnX2lkJ10pIHtcbiAgICAgICAgY29uc3QgZm9yZWlnblNjaGVtYVR5cGUgPSBtb2RlbC5zY2hlbWEucGF0aChmb3JlaWduRmllbGQpO1xuICAgICAgICBpZHMgPSBfZmlsdGVySW52YWxpZElkcyhpZHMsIGZvcmVpZ25TY2hlbWFUeXBlLCBza2lwSW52YWxpZElkcyk7XG4gICAgICAgICRvci5wdXNoKHsgW2ZvcmVpZ25GaWVsZF06IHsgJGluOiBpZHMgfSB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZm9yZWlnbkZpZWxkID09PSAnX2lkJyAmJiBtYXRjaFsnX2lkJ10pIHtcbiAgICAgICAgY29uc3QgdXNlclNwZWNpZmllZE1hdGNoID0gaGFzRG9sbGFyS2V5cyhtYXRjaFtmb3JlaWduRmllbGRdKSA/XG4gICAgICAgICAgbWF0Y2hbZm9yZWlnbkZpZWxkXSA6XG4gICAgICAgICAgeyAkZXE6IG1hdGNoW2ZvcmVpZ25GaWVsZF0gfTtcbiAgICAgICAgbWF0Y2hbZm9yZWlnbkZpZWxkXSA9IHsgLi4udHJ1c3RlZCh7ICRpbjogaWRzIH0pLCAuLi51c2VyU3BlY2lmaWVkTWF0Y2ggfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59O1xuXG4vKipcbiAqIE9wdGlvbmFsbHkgZmlsdGVyIG91dCBpbnZhbGlkIGlkcyB0aGF0IGRvbid0IGNvbmZvcm0gdG8gZm9yZWlnbiBmaWVsZCdzIHNjaGVtYVxuICogdG8gYXZvaWQgY2FzdCBlcnJvcnMgKGdoLTc3MDYpXG4gKiBAcGFyYW0ge0FycmF5fSBpZHNcbiAqIEBwYXJhbSB7U2NoZW1hVHlwZX0gZm9yZWlnblNjaGVtYVR5cGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBJbnZhbGlkSWRzXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2ZpbHRlckludmFsaWRJZHMoaWRzLCBmb3JlaWduU2NoZW1hVHlwZSwgc2tpcEludmFsaWRJZHMpIHtcbiAgaWRzID0gaWRzLmZpbHRlcih2ID0+ICEodiBpbnN0YW5jZW9mIFNraXBQb3B1bGF0ZVZhbHVlKSk7XG4gIGlmICghc2tpcEludmFsaWRJZHMpIHtcbiAgICByZXR1cm4gaWRzO1xuICB9XG4gIHJldHVybiBpZHMuZmlsdGVyKGlkID0+IHtcbiAgICB0cnkge1xuICAgICAgZm9yZWlnblNjaGVtYVR5cGUuY2FzdChpZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEZvcm1hdCBgbW9kLm1hdGNoYCBnaXZlbiB0aGF0IGl0IG1heSBiZSBhbiBhcnJheSB0aGF0IHdlIG5lZWQgdG8gJG9yIGlmXG4gKiB0aGUgY2xpZW50IGhhcyBtdWx0aXBsZSBkb2NzIHdpdGggbWF0Y2ggZnVuY3Rpb25zXG4gKiBAcGFyYW0ge0FycmF5fEFueX0gbWF0Y2hcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9mb3JtYXRNYXRjaChtYXRjaCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXRjaCkpIHtcbiAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgJG9yOiBbXS5jb25jYXQobWF0Y2gubWFwKG0gPT4gT2JqZWN0LmFzc2lnbih7fSwgbSkpKSB9O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2hbMF0pO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js":
/*!***************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/index */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nconst SkipPopulateValue = __webpack_require__(/*! ./SkipPopulateValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js\");\nconst clone = __webpack_require__(/*! ../clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getSchemaTypes = __webpack_require__(/*! ./getSchemaTypes */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js\");\nconst getVirtual = __webpack_require__(/*! ./getVirtual */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/getVirtual.js\");\nconst lookupLocalFields = __webpack_require__(/*! ./lookupLocalFields */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(api)/../server/node_modules/mpath/index.js\");\nconst modelNamesFromRefPath = __webpack_require__(/*! ./modelNamesFromRefPath */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nconst modelSymbol = (__webpack_require__(/*! ../symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").modelSymbol);\nconst populateModelSymbol = (__webpack_require__(/*! ../symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\nconst schemaMixedSymbol = (__webpack_require__(/*! ../../schema/symbols */ \"(api)/../server/node_modules/mongoose/lib/schema/symbols.js\").schemaMixedSymbol);\nconst StrictPopulate = __webpack_require__(/*! ../../error/strictPopulate */ \"(api)/../server/node_modules/mongoose/lib/error/strictPopulate.js\");\n\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  const available = {};\n\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null &&\n        schema.$isMongooseDocumentArray &&\n        schema.options.ref == null &&\n        schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path +\n        ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n\n    if (schema != null && schema.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ?\n          schema.every(schema => !schema.$isMongooseArray) :\n          !schema.$isMongooseArray;\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    let match = get(options, 'match', null);\n\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc,\n        modelSchema, data, options, normalizedRefPath, ret);\n\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n\n    const originalSchema = schema;\n    if (schema && schema.instance === 'Array') {\n      schema = schema.caster;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n\n    const ref = schema && schema.options && schema.options.ref;\n    refPath = schema && schema.options && schema.options.refPath;\n    if (schema != null &&\n        schema[schemaMixedSymbol] &&\n        !ref &&\n        !refPath &&\n        !modelNameFromQuery) {\n      return { modelNames: null };\n    }\n\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ?\n          utils.array.flatten(vals) :\n          (vals ? [vals] : []);\n\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n            forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null &&\n            typeof ref === 'function' &&\n            options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n              forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n      }\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ?\n      _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n\n    if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    if (virtual.options.refPath) {\n      modelNames =\n        modelNamesFromRefPath(virtual.options.refPath, doc, options.path);\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      let normalizedRef;\n      if (typeof virtual.options.ref === 'function' && !virtual.options.ref[modelSymbol]) {\n        normalizedRef = virtual.options.ref.call(doc, doc);\n      } else {\n        normalizedRef = virtual.options.ref;\n      }\n      justOne = !!virtual.options.justOne;\n      // When referencing nested arrays, the ref should be an Array\n      // of modelNames.\n      if (Array.isArray(normalizedRef)) {\n        modelNames = normalizedRef;\n      } else {\n        modelNames = [normalizedRef];\n      }\n    }\n\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) ||\n      get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection != null ? options.connection : model.db;\n\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n\n  if (modelNames == null) {\n    return;\n  }\n\n  let k = modelNames.length;\n  while (k--) {\n    const modelName = modelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n\n    let ids = ret;\n    const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\n\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\n    if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {\n      ids = flat.filter((val, i) => modelNamesForRefPath[i] === modelName);\n    }\n\n    const perDocumentLimit = options.perDocumentLimit == null ?\n      get(options, 'options.perDocumentLimit', null) :\n      options.perDocumentLimit;\n\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\n\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n\n  return conn.model(modelName);\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ?\n    model.schema.path(localField) :\n    localFieldPathType.schema;\n  const localFieldGetters = localFieldPath && localFieldPath.getters ?\n    localFieldPath.getters : [];\n\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\n\n  const _populateOptions = get(options, 'options', {});\n\n  const getters = 'getters' in _populateOptions ?\n    _populateOptions.getters :\n    get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>\n        localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n\n  if (Array.isArray(val)) {\n    const rawVal = val.__array != null ? val.__array : val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\n        rawVal[i] = rawVal[i]._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n      // The intent here is we should only flatten the object if we expect\n      // to get a Map in the end. Avoid doing this for mixed types.\n      (schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null &&\n        schematype.$isMongooseArray &&\n        schematype.caster.discriminators != null &&\n        Object.keys(schematype.caster.discriminators).length !== 0) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.caster.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator && discriminator.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n\n  return modelNames;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9nZXRNb2RlbHNNYXBGb3JQb3B1bGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxtRkFBbUI7QUFDakQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQXFCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyw0RUFBVTtBQUNoQyxZQUFZLG1CQUFPLENBQUMsd0VBQVE7QUFDNUIsZ0NBQWdDLG1CQUFPLENBQUMsNElBQTBDO0FBQ2xGLDJCQUEyQixtQkFBTyxDQUFDLHNHQUF1QjtBQUMxRCx1QkFBdUIsbUJBQU8sQ0FBQyxzR0FBa0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsOEZBQWM7QUFDekMsMEJBQTBCLG1CQUFPLENBQUMsNEdBQXFCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQywwREFBTztBQUM3Qiw4QkFBOEIsbUJBQU8sQ0FBQyxvSEFBeUI7QUFDL0QsY0FBYyxtQkFBTyxDQUFDLHVFQUFhOztBQUVuQyxvQkFBb0IsbUhBQWlDO0FBQ3JELDRCQUE0QiwySEFBeUM7QUFDckUsMEJBQTBCLGtJQUFpRDtBQUMzRSx1QkFBdUIsbUJBQU8sQ0FBQyxxR0FBNEI7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsYUFBYSxnQkFBZ0IsZ0JBQWdCO0FBQ3pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHBvcHVsYXRlXFxnZXRNb2RlbHNNYXBGb3JQb3B1bGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU2tpcFBvcHVsYXRlVmFsdWUgPSByZXF1aXJlKCcuL1NraXBQb3B1bGF0ZVZhbHVlJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uL2Nsb25lJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi4vZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBnZXRTY2hlbWFUeXBlcyA9IHJlcXVpcmUoJy4vZ2V0U2NoZW1hVHlwZXMnKTtcbmNvbnN0IGdldFZpcnR1YWwgPSByZXF1aXJlKCcuL2dldFZpcnR1YWwnKTtcbmNvbnN0IGxvb2t1cExvY2FsRmllbGRzID0gcmVxdWlyZSgnLi9sb29rdXBMb2NhbEZpZWxkcycpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3QgbW9kZWxOYW1lc0Zyb21SZWZQYXRoID0gcmVxdWlyZSgnLi9tb2RlbE5hbWVzRnJvbVJlZlBhdGgnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuY29uc3QgbW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuLi9zeW1ib2xzJykubW9kZWxTeW1ib2w7XG5jb25zdCBwb3B1bGF0ZU1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi4vc3ltYm9scycpLnBvcHVsYXRlTW9kZWxTeW1ib2w7XG5jb25zdCBzY2hlbWFNaXhlZFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9zeW1ib2xzJykuc2NoZW1hTWl4ZWRTeW1ib2w7XG5jb25zdCBTdHJpY3RQb3B1bGF0ZSA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL3N0cmljdFBvcHVsYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0TW9kZWxzTWFwRm9yUG9wdWxhdGUobW9kZWwsIGRvY3MsIG9wdGlvbnMpIHtcbiAgbGV0IGRvYztcbiAgY29uc3QgbGVuID0gZG9jcy5sZW5ndGg7XG4gIGNvbnN0IG1hcCA9IFtdO1xuICBjb25zdCBtb2RlbE5hbWVGcm9tUXVlcnkgPSBvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwubW9kZWxOYW1lIHx8IG9wdGlvbnMubW9kZWw7XG4gIGxldCBzY2hlbWE7XG4gIGxldCByZWZQYXRoO1xuICBsZXQgbW9kZWxOYW1lcztcbiAgY29uc3QgYXZhaWxhYmxlID0ge307XG5cbiAgY29uc3QgbW9kZWxTY2hlbWEgPSBtb2RlbC5zY2hlbWE7XG5cbiAgLy8gUG9wdWxhdGluZyBhIG5lc3RlZCBwYXRoIHNob3VsZCBhbHdheXMgYmUgYSBuby1vcCByZTogIzkwNzMuXG4gIC8vIFBlb3BsZSBzaG91bGRuJ3QgZG8gdGhpcywgYnV0IGFwcGFyZW50bHkgdGhleSBkby5cbiAgaWYgKG9wdGlvbnMuX2xvY2FsTW9kZWwgIT0gbnVsbCAmJiBvcHRpb25zLl9sb2NhbE1vZGVsLnNjaGVtYS5uZXN0ZWRbb3B0aW9ucy5wYXRoXSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IF92aXJ0dWFsUmVzID0gZ2V0VmlydHVhbChtb2RlbC5zY2hlbWEsIG9wdGlvbnMucGF0aCk7XG4gIGNvbnN0IHZpcnR1YWwgPSBfdmlydHVhbFJlcyA9PSBudWxsID8gbnVsbCA6IF92aXJ0dWFsUmVzLnZpcnR1YWw7XG4gIGlmICh2aXJ0dWFsICE9IG51bGwpIHtcbiAgICByZXR1cm4gX3ZpcnR1YWxQb3B1bGF0ZShtb2RlbCwgZG9jcywgb3B0aW9ucywgX3ZpcnR1YWxSZXMpO1xuICB9XG5cbiAgbGV0IGFsbFNjaGVtYVR5cGVzID0gZ2V0U2NoZW1hVHlwZXMobW9kZWwsIG1vZGVsU2NoZW1hLCBudWxsLCBvcHRpb25zLnBhdGgpO1xuICBhbGxTY2hlbWFUeXBlcyA9IEFycmF5LmlzQXJyYXkoYWxsU2NoZW1hVHlwZXMpID8gYWxsU2NoZW1hVHlwZXMgOiBbYWxsU2NoZW1hVHlwZXNdLmZpbHRlcih2ID0+IHYgIT0gbnVsbCk7XG5cbiAgY29uc3QgaXNTdHJpY3RQb3B1bGF0ZURpc2FibGVkID0gb3B0aW9ucy5zdHJpY3RQb3B1bGF0ZSA9PT0gZmFsc2UgfHwgb3B0aW9ucy5vcHRpb25zPy5zdHJpY3RQb3B1bGF0ZSA9PT0gZmFsc2U7XG4gIGlmICghaXNTdHJpY3RQb3B1bGF0ZURpc2FibGVkICYmIGFsbFNjaGVtYVR5cGVzLmxlbmd0aCA9PT0gMCAmJiBvcHRpb25zLl9sb2NhbE1vZGVsICE9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IFN0cmljdFBvcHVsYXRlKG9wdGlvbnMuX2Z1bGxQYXRoIHx8IG9wdGlvbnMucGF0aCk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgZG9jID0gZG9jc1tpXTtcbiAgICBsZXQganVzdE9uZSA9IG51bGw7XG5cbiAgICBjb25zdCBkb2NTY2hlbWEgPSBkb2MgIT0gbnVsbCAmJiBkb2MuJF9fICE9IG51bGwgPyBkb2MuJF9fc2NoZW1hIDogbW9kZWxTY2hlbWE7XG4gICAgc2NoZW1hID0gZ2V0U2NoZW1hVHlwZXMobW9kZWwsIGRvY1NjaGVtYSwgZG9jLCBvcHRpb25zLnBhdGgpO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlOiBwb3B1bGF0aW5nIGEgcGF0aCB0aGF0J3MgYSBEb2N1bWVudEFycmF5IHVubGVzc1xuICAgIC8vIHRoZXJlJ3MgYW4gZXhwbGljaXQgYHJlZmAgb3IgYHJlZlBhdGhgIHJlOiBnaC04OTQ2XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsICYmXG4gICAgICAgIHNjaGVtYS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiZcbiAgICAgICAgc2NoZW1hLm9wdGlvbnMucmVmID09IG51bGwgJiZcbiAgICAgICAgc2NoZW1hLm9wdGlvbnMucmVmUGF0aCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaXNVbmRlcm5lYXRoRG9jQXJyYXkgPSBzY2hlbWEgJiYgc2NoZW1hLiRwYXJlbnRTY2hlbWFEb2NBcnJheTtcbiAgICBpZiAoaXNVbmRlcm5lYXRoRG9jQXJyYXkgJiYgZ2V0KG9wdGlvbnMsICdvcHRpb25zLnNvcnQnKSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCBwb3B1bGF0ZSB3aXRoIGBzb3J0YCBvbiBwYXRoICcgKyBvcHRpb25zLnBhdGggK1xuICAgICAgICAnIGJlY2F1c2UgaXQgaXMgYSBzdWJwcm9wZXJ0eSBvZiBhIGRvY3VtZW50IGFycmF5Jyk7XG4gICAgfVxuXG4gICAgbW9kZWxOYW1lcyA9IG51bGw7XG4gICAgbGV0IGlzUmVmUGF0aCA9IGZhbHNlO1xuICAgIGxldCBub3JtYWxpemVkUmVmUGF0aCA9IG51bGw7XG4gICAgbGV0IHNjaGVtYU9wdGlvbnMgPSBudWxsO1xuICAgIGxldCBtb2RlbE5hbWVzSW5PcmRlciA9IG51bGw7XG5cbiAgICBpZiAoc2NoZW1hICE9IG51bGwgJiYgc2NoZW1hLmluc3RhbmNlID09PSAnRW1iZWRkZWQnKSB7XG4gICAgICBpZiAoc2NoZW1hLm9wdGlvbnMucmVmKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgbG9jYWxGaWVsZDogb3B0aW9ucy5wYXRoICsgJy5faWQnLFxuICAgICAgICAgIGZvcmVpZ25GaWVsZDogJ19pZCcsXG4gICAgICAgICAganVzdE9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXMgPSBfZ2V0TW9kZWxOYW1lcyhkb2MsIHNjaGVtYSwgbW9kZWxOYW1lRnJvbVF1ZXJ5LCBtb2RlbCk7XG5cbiAgICAgICAgY29uc3QgdW5wb3B1bGF0ZWRWYWx1ZSA9IG1wYXRoLmdldChvcHRpb25zLnBhdGgsIGRvYyk7XG4gICAgICAgIGNvbnN0IGlkID0gbXBhdGguZ2V0KCdfaWQnLCB1bnBvcHVsYXRlZFZhbHVlKTtcbiAgICAgICAgYWRkTW9kZWxOYW1lc1RvTWFwKG1vZGVsLCBtYXAsIGF2YWlsYWJsZSwgcmVzLm1vZGVsTmFtZXMsIG9wdGlvbnMsIGRhdGEsIGlkLCBkb2MsIHNjaGVtYU9wdGlvbnMsIHVucG9wdWxhdGVkVmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gTm8tb3AgaWYgbm8gYHJlZmAgc2V0LiBTZWUgZ2gtMTE1MzhcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgIGNvbnN0IHNjaGVtYXNBcnJheSA9IHNjaGVtYTtcbiAgICAgIGZvciAoY29uc3QgX3NjaGVtYSBvZiBzY2hlbWFzQXJyYXkpIHtcbiAgICAgICAgbGV0IF9tb2RlbE5hbWVzO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IF9nZXRNb2RlbE5hbWVzKGRvYywgX3NjaGVtYSwgbW9kZWxOYW1lRnJvbVF1ZXJ5LCBtb2RlbCk7XG4gICAgICAgICAgX21vZGVsTmFtZXMgPSByZXMubW9kZWxOYW1lcztcbiAgICAgICAgICBpc1JlZlBhdGggPSBpc1JlZlBhdGggfHwgcmVzLmlzUmVmUGF0aDtcbiAgICAgICAgICBub3JtYWxpemVkUmVmUGF0aCA9IG5vcm1hbGl6ZWRSZWZQYXRoIHx8IHJlcy5yZWZQYXRoO1xuICAgICAgICAgIGp1c3RPbmUgPSByZXMuanVzdE9uZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZWZQYXRoICYmICFyZXMuaXNSZWZQYXRoKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfbW9kZWxOYW1lcykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsTmFtZXMgPSBtb2RlbE5hbWVzIHx8IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZGVsTmFtZSBvZiBfbW9kZWxOYW1lcykge1xuICAgICAgICAgIGlmIChtb2RlbE5hbWVzLmluZGV4T2YobW9kZWxOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG1vZGVsTmFtZXMucHVzaChtb2RlbE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBfZ2V0TW9kZWxOYW1lcyhkb2MsIHNjaGVtYSwgbW9kZWxOYW1lRnJvbVF1ZXJ5LCBtb2RlbCk7XG4gICAgICAgIG1vZGVsTmFtZXMgPSByZXMubW9kZWxOYW1lcztcbiAgICAgICAgaXNSZWZQYXRoID0gcmVzLmlzUmVmUGF0aDtcbiAgICAgICAgbm9ybWFsaXplZFJlZlBhdGggPSBub3JtYWxpemVkUmVmUGF0aCB8fCByZXMucmVmUGF0aDtcbiAgICAgICAganVzdE9uZSA9IHJlcy5qdXN0T25lO1xuICAgICAgICBzY2hlbWFPcHRpb25zID0gZ2V0KHNjaGVtYSwgJ29wdGlvbnMucG9wdWxhdGUnLCBudWxsKTtcbiAgICAgICAgLy8gRGVkdXBlLCBiZWNhdXNlIGByZWZQYXRoYCBjYW4gcmV0dXJuIGR1cGxpY2F0ZXMgb2YgdGhlIHNhbWUgbW9kZWwgbmFtZSxcbiAgICAgICAgLy8gYW5kIHRoYXQgY2F1c2VzIHBlcmYgaXNzdWVzLlxuICAgICAgICBpZiAoaXNSZWZQYXRoKSB7XG4gICAgICAgICAgbW9kZWxOYW1lc0luT3JkZXIgPSBtb2RlbE5hbWVzO1xuICAgICAgICAgIG1vZGVsTmFtZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQobW9kZWxOYW1lcykpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICghbW9kZWxOYW1lcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgY29uc3QgbG9jYWxGaWVsZCA9IG9wdGlvbnMucGF0aDtcbiAgICBjb25zdCBmb3JlaWduRmllbGQgPSAnX2lkJztcblxuICAgIC8vIGBqdXN0T25lID0gbnVsbGAgbWVhbnMgd2UgZG9uJ3Qga25vdyBmcm9tIHRoZSBzY2hlbWEgd2hldGhlciB0aGUgZW5kXG4gICAgLy8gcmVzdWx0IHNob3VsZCBiZSBhbiBhcnJheSBvciBhIHNpbmdsZSBkb2MuIFRoaXMgY2FuIHJlc3VsdCBmcm9tXG4gICAgLy8gcG9wdWxhdGluZyBhIFBPSk8gdXNpbmcgYE1vZGVsLnBvcHVsYXRlKClgXG4gICAgaWYgKCdqdXN0T25lJyBpbiBvcHRpb25zICYmIG9wdGlvbnMuanVzdE9uZSAhPT0gdm9pZCAwKSB7XG4gICAgICBqdXN0T25lID0gb3B0aW9ucy5qdXN0T25lO1xuICAgIH0gZWxzZSBpZiAoc2NoZW1hICYmICFzY2hlbWFbc2NoZW1hTWl4ZWRTeW1ib2xdKSB7XG4gICAgICAvLyBTa2lwIE1peGVkIHR5cGVzIGJlY2F1c2Ugd2UgZXhwbGljaXRseSBkb24ndCBkbyBjYXN0aW5nIG9uIHRob3NlLlxuICAgICAgaWYgKG9wdGlvbnMucGF0aC5lbmRzV2l0aCgnLicgKyBzY2hlbWEucGF0aCkgfHwgb3B0aW9ucy5wYXRoID09PSBzY2hlbWEucGF0aCkge1xuICAgICAgICBqdXN0T25lID0gQXJyYXkuaXNBcnJheShzY2hlbWEpID9cbiAgICAgICAgICBzY2hlbWEuZXZlcnkoc2NoZW1hID0+ICFzY2hlbWEuJGlzTW9uZ29vc2VBcnJheSkgOlxuICAgICAgICAgICFzY2hlbWEuJGlzTW9uZ29vc2VBcnJheTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW1vZGVsTmFtZXMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGRhdGEuaXNWaXJ0dWFsID0gZmFsc2U7XG4gICAgZGF0YS5qdXN0T25lID0ganVzdE9uZTtcbiAgICBkYXRhLmxvY2FsRmllbGQgPSBsb2NhbEZpZWxkO1xuICAgIGRhdGEuZm9yZWlnbkZpZWxkID0gZm9yZWlnbkZpZWxkO1xuXG4gICAgLy8gR2V0IGxvY2FsIGZpZWxkc1xuICAgIGNvbnN0IHJldCA9IF9nZXRMb2NhbEZpZWxkVmFsdWVzKGRvYywgbG9jYWxGaWVsZCwgbW9kZWwsIG9wdGlvbnMsIG51bGwsIHNjaGVtYSk7XG5cbiAgICBjb25zdCBpZCA9IFN0cmluZyh1dGlscy5nZXRWYWx1ZShmb3JlaWduRmllbGQsIGRvYykpO1xuICAgIG9wdGlvbnMuX2RvY3NbaWRdID0gQXJyYXkuaXNBcnJheShyZXQpID8gcmV0LnNsaWNlKCkgOiByZXQ7XG5cbiAgICBsZXQgbWF0Y2ggPSBnZXQob3B0aW9ucywgJ21hdGNoJywgbnVsbCk7XG5cbiAgICBjb25zdCBoYXNNYXRjaEZ1bmN0aW9uID0gdHlwZW9mIG1hdGNoID09PSAnZnVuY3Rpb24nO1xuICAgIGlmIChoYXNNYXRjaEZ1bmN0aW9uKSB7XG4gICAgICBtYXRjaCA9IG1hdGNoLmNhbGwoZG9jLCBkb2MpO1xuICAgIH1cbiAgICBkYXRhLm1hdGNoID0gbWF0Y2g7XG4gICAgZGF0YS5oYXNNYXRjaEZ1bmN0aW9uID0gaGFzTWF0Y2hGdW5jdGlvbjtcbiAgICBkYXRhLmlzUmVmUGF0aCA9IGlzUmVmUGF0aDtcbiAgICBkYXRhLm1vZGVsTmFtZXNJbk9yZGVyID0gbW9kZWxOYW1lc0luT3JkZXI7XG5cbiAgICBpZiAoaXNSZWZQYXRoKSB7XG4gICAgICBjb25zdCBlbWJlZGRlZERpc2NyaW1pbmF0b3JNb2RlbE5hbWVzID0gX2ZpbmRSZWZQYXRoRm9yRGlzY3JpbWluYXRvcnMoZG9jLFxuICAgICAgICBtb2RlbFNjaGVtYSwgZGF0YSwgb3B0aW9ucywgbm9ybWFsaXplZFJlZlBhdGgsIHJldCk7XG5cbiAgICAgIG1vZGVsTmFtZXMgPSBlbWJlZGRlZERpc2NyaW1pbmF0b3JNb2RlbE5hbWVzIHx8IG1vZGVsTmFtZXM7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGFkZE1vZGVsTmFtZXNUb01hcChtb2RlbCwgbWFwLCBhdmFpbGFibGUsIG1vZGVsTmFtZXMsIG9wdGlvbnMsIGRhdGEsIHJldCwgZG9jLCBzY2hlbWFPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXA7XG5cbiAgZnVuY3Rpb24gX2dldE1vZGVsTmFtZXMoZG9jLCBzY2hlbWEsIG1vZGVsTmFtZUZyb21RdWVyeSwgbW9kZWwpIHtcbiAgICBsZXQgbW9kZWxOYW1lcztcbiAgICBsZXQgaXNSZWZQYXRoID0gZmFsc2U7XG4gICAgbGV0IGp1c3RPbmUgPSBudWxsO1xuXG4gICAgY29uc3Qgb3JpZ2luYWxTY2hlbWEgPSBzY2hlbWE7XG4gICAgaWYgKHNjaGVtYSAmJiBzY2hlbWEuaW5zdGFuY2UgPT09ICdBcnJheScpIHtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5jYXN0ZXI7XG4gICAgfVxuICAgIGlmIChzY2hlbWEgJiYgc2NoZW1hLiRpc1NjaGVtYU1hcCkge1xuICAgICAgc2NoZW1hID0gc2NoZW1hLiRfX3NjaGVtYVR5cGU7XG4gICAgfVxuXG4gICAgY29uc3QgcmVmID0gc2NoZW1hICYmIHNjaGVtYS5vcHRpb25zICYmIHNjaGVtYS5vcHRpb25zLnJlZjtcbiAgICByZWZQYXRoID0gc2NoZW1hICYmIHNjaGVtYS5vcHRpb25zICYmIHNjaGVtYS5vcHRpb25zLnJlZlBhdGg7XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsICYmXG4gICAgICAgIHNjaGVtYVtzY2hlbWFNaXhlZFN5bWJvbF0gJiZcbiAgICAgICAgIXJlZiAmJlxuICAgICAgICAhcmVmUGF0aCAmJlxuICAgICAgICAhbW9kZWxOYW1lRnJvbVF1ZXJ5KSB7XG4gICAgICByZXR1cm4geyBtb2RlbE5hbWVzOiBudWxsIH07XG4gICAgfVxuXG4gICAgaWYgKG1vZGVsTmFtZUZyb21RdWVyeSkge1xuICAgICAgbW9kZWxOYW1lcyA9IFttb2RlbE5hbWVGcm9tUXVlcnldOyAvLyBxdWVyeSBvcHRpb25zXG4gICAgfSBlbHNlIGlmIChyZWZQYXRoICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVmUGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBzdWJkb2NQYXRoID0gb3B0aW9ucy5wYXRoLnNsaWNlKDAsIG9wdGlvbnMucGF0aC5sZW5ndGggLSBzY2hlbWEucGF0aC5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgdmFscyA9IG1wYXRoLmdldChzdWJkb2NQYXRoLCBkb2MsIGxvb2t1cExvY2FsRmllbGRzKTtcbiAgICAgICAgY29uc3Qgc3ViZG9jc0JlaW5nUG9wdWxhdGVkID0gQXJyYXkuaXNBcnJheSh2YWxzKSA/XG4gICAgICAgICAgdXRpbHMuYXJyYXkuZmxhdHRlbih2YWxzKSA6XG4gICAgICAgICAgKHZhbHMgPyBbdmFsc10gOiBbXSk7XG5cbiAgICAgICAgbW9kZWxOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBzdWJkb2Mgb2Ygc3ViZG9jc0JlaW5nUG9wdWxhdGVkKSB7XG4gICAgICAgICAgcmVmUGF0aCA9IHJlZlBhdGguY2FsbChzdWJkb2MsIHN1YmRvYywgb3B0aW9ucy5wYXRoKTtcbiAgICAgICAgICBtb2RlbE5hbWVzRnJvbVJlZlBhdGgocmVmUGF0aCwgZG9jLCBvcHRpb25zLnBhdGgsIG1vZGVsU2NoZW1hLCBvcHRpb25zLl9xdWVyeVByb2plY3Rpb24pLlxuICAgICAgICAgICAgZm9yRWFjaChuYW1lID0+IG1vZGVsTmFtZXMuYWRkKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbE5hbWVzID0gQXJyYXkuZnJvbShtb2RlbE5hbWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGVsTmFtZXMgPSBtb2RlbE5hbWVzRnJvbVJlZlBhdGgocmVmUGF0aCwgZG9jLCBvcHRpb25zLnBhdGgsIG1vZGVsU2NoZW1hLCBvcHRpb25zLl9xdWVyeVByb2plY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBpc1JlZlBhdGggPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVmO1xuICAgICAgbGV0IHJlZlBhdGg7XG4gICAgICBsZXQgc2NoZW1hRm9yQ3VycmVudERvYztcbiAgICAgIGxldCBkaXNjcmltaW5hdG9yVmFsdWU7XG4gICAgICBsZXQgbW9kZWxGb3JDdXJyZW50RG9jID0gbW9kZWw7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gbW9kZWwuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcblxuICAgICAgaWYgKCFzY2hlbWEgJiYgZGlzY3JpbWluYXRvcktleSAmJiAoZGlzY3JpbWluYXRvclZhbHVlID0gdXRpbHMuZ2V0VmFsdWUoZGlzY3JpbWluYXRvcktleSwgZG9jKSkpIHtcbiAgICAgICAgLy8gYG1vZGVsTmFtZUZvckZpbmRgIGlzIHRoZSBkaXNjcmltaW5hdG9yIHZhbHVlLCBzbyB3ZSBtaWdodCBuZWVkXG4gICAgICAgIC8vIGZpbmQgdGhlIGRpc2NyaW1pbmF0ZWQgbW9kZWwgbmFtZVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yTW9kZWwgPSBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShtb2RlbC5kaXNjcmltaW5hdG9ycywgZGlzY3JpbWluYXRvclZhbHVlKSB8fCBtb2RlbDtcbiAgICAgICAgaWYgKGRpc2NyaW1pbmF0b3JNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgICAgbW9kZWxGb3JDdXJyZW50RG9jID0gZGlzY3JpbWluYXRvck1vZGVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtb2RlbEZvckN1cnJlbnREb2MgPSBfZ2V0TW9kZWxGcm9tQ29ubihtb2RlbC5kYiwgZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtYUZvckN1cnJlbnREb2MgPSBtb2RlbEZvckN1cnJlbnREb2Muc2NoZW1hLl9nZXRTY2hlbWEob3B0aW9ucy5wYXRoKTtcblxuICAgICAgICBpZiAoc2NoZW1hRm9yQ3VycmVudERvYyAmJiBzY2hlbWFGb3JDdXJyZW50RG9jLmNhc3Rlcikge1xuICAgICAgICAgIHNjaGVtYUZvckN1cnJlbnREb2MgPSBzY2hlbWFGb3JDdXJyZW50RG9jLmNhc3RlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRm9yQ3VycmVudERvYyA9IHNjaGVtYTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9yaWdpbmFsU2NoZW1hICYmIG9yaWdpbmFsU2NoZW1hLnBhdGguZW5kc1dpdGgoJy4kKicpKSB7XG4gICAgICAgIGp1c3RPbmUgPSAhb3JpZ2luYWxTY2hlbWEuJGlzTW9uZ29vc2VBcnJheSAmJiAhb3JpZ2luYWxTY2hlbWEuX2FycmF5UGF0aDtcbiAgICAgIH0gZWxzZSBpZiAoc2NoZW1hRm9yQ3VycmVudERvYyAhPSBudWxsKSB7XG4gICAgICAgIGp1c3RPbmUgPSAhc2NoZW1hRm9yQ3VycmVudERvYy4kaXNNb25nb29zZUFycmF5ICYmICFzY2hlbWFGb3JDdXJyZW50RG9jLl9hcnJheVBhdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgocmVmID0gZ2V0KHNjaGVtYUZvckN1cnJlbnREb2MsICdvcHRpb25zLnJlZicpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChzY2hlbWFGb3JDdXJyZW50RG9jICE9IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIG9wdGlvbnMucGF0aC5lbmRzV2l0aCgnLicgKyBzY2hlbWFGb3JDdXJyZW50RG9jLnBhdGgpKSB7XG4gICAgICAgICAgLy8gRW5zdXJlIGNvcnJlY3QgY29udGV4dCBmb3IgcmVmIGZ1bmN0aW9uczogc3ViZG9jLCBub3QgdG9wLWxldmVsIGRvYy4gU2VlIGdoLTg0NjlcbiAgICAgICAgICBtb2RlbE5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgY29uc3Qgc3ViZG9jUGF0aCA9IG9wdGlvbnMucGF0aC5zbGljZSgwLCBvcHRpb25zLnBhdGgubGVuZ3RoIC0gc2NoZW1hRm9yQ3VycmVudERvYy5wYXRoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGNvbnN0IHZhbHMgPSBtcGF0aC5nZXQoc3ViZG9jUGF0aCwgZG9jLCBsb29rdXBMb2NhbEZpZWxkcyk7XG4gICAgICAgICAgY29uc3Qgc3ViZG9jc0JlaW5nUG9wdWxhdGVkID0gQXJyYXkuaXNBcnJheSh2YWxzKSA/XG4gICAgICAgICAgICB1dGlscy5hcnJheS5mbGF0dGVuKHZhbHMpIDpcbiAgICAgICAgICAgICh2YWxzID8gW3ZhbHNdIDogW10pO1xuICAgICAgICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3NCZWluZ1BvcHVsYXRlZCkge1xuICAgICAgICAgICAgbW9kZWxOYW1lcy5hZGQoaGFuZGxlUmVmRnVuY3Rpb24ocmVmLCBzdWJkb2MpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3ViZG9jc0JlaW5nUG9wdWxhdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbW9kZWxOYW1lcyA9IFtoYW5kbGVSZWZGdW5jdGlvbihyZWYsIGRvYyldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlbE5hbWVzID0gQXJyYXkuZnJvbShtb2RlbE5hbWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmID0gaGFuZGxlUmVmRnVuY3Rpb24ocmVmLCBkb2MpO1xuICAgICAgICAgIG1vZGVsTmFtZXMgPSBbcmVmXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoc2NoZW1hRm9yQ3VycmVudERvYyA9IGdldChzY2hlbWEsICdvcHRpb25zLnJlZlBhdGgnKSkgIT0gbnVsbCkge1xuICAgICAgICBpc1JlZlBhdGggPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIHJlZlBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25zdCBzdWJkb2NQYXRoID0gb3B0aW9ucy5wYXRoLnNsaWNlKDAsIG9wdGlvbnMucGF0aC5sZW5ndGggLSBzY2hlbWFGb3JDdXJyZW50RG9jLnBhdGgubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgY29uc3QgdmFscyA9IG1wYXRoLmdldChzdWJkb2NQYXRoLCBkb2MsIGxvb2t1cExvY2FsRmllbGRzKTtcbiAgICAgICAgICBjb25zdCBzdWJkb2NzQmVpbmdQb3B1bGF0ZWQgPSBBcnJheS5pc0FycmF5KHZhbHMpID9cbiAgICAgICAgICAgIHV0aWxzLmFycmF5LmZsYXR0ZW4odmFscykgOlxuICAgICAgICAgICAgKHZhbHMgPyBbdmFsc10gOiBbXSk7XG5cbiAgICAgICAgICBtb2RlbE5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3NCZWluZ1BvcHVsYXRlZCkge1xuICAgICAgICAgICAgcmVmUGF0aCA9IHJlZlBhdGguY2FsbChzdWJkb2MsIHN1YmRvYywgb3B0aW9ucy5wYXRoKTtcbiAgICAgICAgICAgIG1vZGVsTmFtZXNGcm9tUmVmUGF0aChyZWZQYXRoLCBkb2MsIG9wdGlvbnMucGF0aCwgbW9kZWxTY2hlbWEsIG9wdGlvbnMuX3F1ZXJ5UHJvamVjdGlvbikuXG4gICAgICAgICAgICAgIGZvckVhY2gobmFtZSA9PiBtb2RlbE5hbWVzLmFkZChuYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGVsTmFtZXMgPSBBcnJheS5mcm9tKG1vZGVsTmFtZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsTmFtZXMgPSBtb2RlbE5hbWVzRnJvbVJlZlBhdGgocmVmUGF0aCwgZG9jLCBvcHRpb25zLnBhdGgsIG1vZGVsU2NoZW1hLCBvcHRpb25zLl9xdWVyeVByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFtb2RlbE5hbWVzKSB7XG4gICAgICAvLyBgTW9kZWwucG9wdWxhdGUoKWAgb24gYSBQT0pPIHdpdGggbm8ga25vd24gbG9jYWwgbW9kZWwuIERlZmF1bHQgdG8gdXNpbmcgdGhlIGBNb2RlbGBcbiAgICAgIGlmIChvcHRpb25zLl9sb2NhbE1vZGVsID09IG51bGwpIHtcbiAgICAgICAgbW9kZWxOYW1lcyA9IFttb2RlbC5tb2RlbE5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kZWxOYW1lczogbW9kZWxOYW1lcywganVzdE9uZToganVzdE9uZSwgaXNSZWZQYXRoOiBpc1JlZlBhdGgsIHJlZlBhdGg6IHJlZlBhdGggfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kZWxOYW1lcykpIHtcbiAgICAgIG1vZGVsTmFtZXMgPSBbbW9kZWxOYW1lc107XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbW9kZWxOYW1lczogbW9kZWxOYW1lcywganVzdE9uZToganVzdE9uZSwgaXNSZWZQYXRoOiBpc1JlZlBhdGgsIHJlZlBhdGg6IHJlZlBhdGggfTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfdmlydHVhbFBvcHVsYXRlKG1vZGVsLCBkb2NzLCBvcHRpb25zLCBfdmlydHVhbFJlcykge1xuICBjb25zdCBtYXAgPSBbXTtcbiAgY29uc3QgYXZhaWxhYmxlID0ge307XG4gIGNvbnN0IHZpcnR1YWwgPSBfdmlydHVhbFJlcy52aXJ0dWFsO1xuXG4gIGZvciAoY29uc3QgZG9jIG9mIGRvY3MpIHtcbiAgICBsZXQgbW9kZWxOYW1lcyA9IG51bGw7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuXG4gICAgLy8gbG9jYWxGaWVsZCBhbmQgZm9yZWlnbkZpZWxkXG4gICAgbGV0IGxvY2FsRmllbGQ7XG4gICAgY29uc3QgdmlydHVhbFByZWZpeCA9IF92aXJ0dWFsUmVzLm5lc3RlZFNjaGVtYVBhdGggP1xuICAgICAgX3ZpcnR1YWxSZXMubmVzdGVkU2NoZW1hUGF0aCArICcuJyA6ICcnO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbEZpZWxkID09PSAnc3RyaW5nJykge1xuICAgICAgbG9jYWxGaWVsZCA9IG9wdGlvbnMubG9jYWxGaWVsZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2aXJ0dWFsLm9wdGlvbnMubG9jYWxGaWVsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbG9jYWxGaWVsZCA9IHZpcnR1YWxQcmVmaXggKyB2aXJ0dWFsLm9wdGlvbnMubG9jYWxGaWVsZC5jYWxsKGRvYywgZG9jKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmlydHVhbC5vcHRpb25zLmxvY2FsRmllbGQpKSB7XG4gICAgICBsb2NhbEZpZWxkID0gdmlydHVhbC5vcHRpb25zLmxvY2FsRmllbGQubWFwKGZpZWxkID0+IHZpcnR1YWxQcmVmaXggKyBmaWVsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2FsRmllbGQgPSB2aXJ0dWFsUHJlZml4ICsgdmlydHVhbC5vcHRpb25zLmxvY2FsRmllbGQ7XG4gICAgfVxuICAgIGRhdGEuY291bnQgPSB2aXJ0dWFsLm9wdGlvbnMuY291bnQ7XG5cbiAgICBpZiAodmlydHVhbC5vcHRpb25zLnNraXAgIT0gbnVsbCAmJiAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2tpcCcpKSB7XG4gICAgICBvcHRpb25zLnNraXAgPSB2aXJ0dWFsLm9wdGlvbnMuc2tpcDtcbiAgICB9XG4gICAgaWYgKHZpcnR1YWwub3B0aW9ucy5saW1pdCAhPSBudWxsICYmICFvcHRpb25zLmhhc093blByb3BlcnR5KCdsaW1pdCcpKSB7XG4gICAgICBvcHRpb25zLmxpbWl0ID0gdmlydHVhbC5vcHRpb25zLmxpbWl0O1xuICAgIH1cbiAgICBpZiAodmlydHVhbC5vcHRpb25zLnBlckRvY3VtZW50TGltaXQgIT0gbnVsbCAmJiAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncGVyRG9jdW1lbnRMaW1pdCcpKSB7XG4gICAgICBvcHRpb25zLnBlckRvY3VtZW50TGltaXQgPSB2aXJ0dWFsLm9wdGlvbnMucGVyRG9jdW1lbnRMaW1pdDtcbiAgICB9XG4gICAgbGV0IGZvcmVpZ25GaWVsZCA9IHZpcnR1YWwub3B0aW9ucy5mb3JlaWduRmllbGQ7XG5cbiAgICBpZiAoIWxvY2FsRmllbGQgfHwgIWZvcmVpZ25GaWVsZCkge1xuICAgICAgcmV0dXJuIG5ldyBNb25nb29zZUVycm9yKGBDYW5ub3QgcG9wdWxhdGUgdmlydHVhbCBcXGAke29wdGlvbnMucGF0aH1cXGAgb24gbW9kZWwgXFxgJHttb2RlbC5tb2RlbE5hbWV9XFxgLCBiZWNhdXNlIG9wdGlvbnMgXFxgbG9jYWxGaWVsZFxcYCBhbmQgLyBvciBcXGBmb3JlaWduRmllbGRcXGAgYXJlIG1pc3NpbmdgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxvY2FsRmllbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxvY2FsRmllbGQgPSBsb2NhbEZpZWxkLmNhbGwoZG9jLCBkb2MpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZvcmVpZ25GaWVsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm9yZWlnbkZpZWxkID0gZm9yZWlnbkZpZWxkLmNhbGwoZG9jLCBkb2MpO1xuICAgIH1cblxuICAgIGRhdGEuaXNSZWZQYXRoID0gZmFsc2U7XG5cbiAgICAvLyBganVzdE9uZSA9IG51bGxgIG1lYW5zIHdlIGRvbid0IGtub3cgZnJvbSB0aGUgc2NoZW1hIHdoZXRoZXIgdGhlIGVuZFxuICAgIC8vIHJlc3VsdCBzaG91bGQgYmUgYW4gYXJyYXkgb3IgYSBzaW5nbGUgZG9jLiBUaGlzIGNhbiByZXN1bHQgZnJvbVxuICAgIC8vIHBvcHVsYXRpbmcgYSBQT0pPIHVzaW5nIGBNb2RlbC5wb3B1bGF0ZSgpYFxuICAgIGxldCBqdXN0T25lID0gbnVsbDtcbiAgICBpZiAoJ2p1c3RPbmUnIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5qdXN0T25lICE9PSB2b2lkIDApIHtcbiAgICAgIGp1c3RPbmUgPSBvcHRpb25zLmp1c3RPbmU7XG4gICAgfVxuXG4gICAgaWYgKHZpcnR1YWwub3B0aW9ucy5yZWZQYXRoKSB7XG4gICAgICBtb2RlbE5hbWVzID1cbiAgICAgICAgbW9kZWxOYW1lc0Zyb21SZWZQYXRoKHZpcnR1YWwub3B0aW9ucy5yZWZQYXRoLCBkb2MsIG9wdGlvbnMucGF0aCk7XG4gICAgICBqdXN0T25lID0gISF2aXJ0dWFsLm9wdGlvbnMuanVzdE9uZTtcbiAgICAgIGRhdGEuaXNSZWZQYXRoID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHZpcnR1YWwub3B0aW9ucy5yZWYpIHtcbiAgICAgIGxldCBub3JtYWxpemVkUmVmO1xuICAgICAgaWYgKHR5cGVvZiB2aXJ0dWFsLm9wdGlvbnMucmVmID09PSAnZnVuY3Rpb24nICYmICF2aXJ0dWFsLm9wdGlvbnMucmVmW21vZGVsU3ltYm9sXSkge1xuICAgICAgICBub3JtYWxpemVkUmVmID0gdmlydHVhbC5vcHRpb25zLnJlZi5jYWxsKGRvYywgZG9jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWRSZWYgPSB2aXJ0dWFsLm9wdGlvbnMucmVmO1xuICAgICAgfVxuICAgICAganVzdE9uZSA9ICEhdmlydHVhbC5vcHRpb25zLmp1c3RPbmU7XG4gICAgICAvLyBXaGVuIHJlZmVyZW5jaW5nIG5lc3RlZCBhcnJheXMsIHRoZSByZWYgc2hvdWxkIGJlIGFuIEFycmF5XG4gICAgICAvLyBvZiBtb2RlbE5hbWVzLlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9ybWFsaXplZFJlZikpIHtcbiAgICAgICAgbW9kZWxOYW1lcyA9IG5vcm1hbGl6ZWRSZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbE5hbWVzID0gW25vcm1hbGl6ZWRSZWZdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRhdGEuaXNWaXJ0dWFsID0gdHJ1ZTtcbiAgICBkYXRhLnZpcnR1YWwgPSB2aXJ0dWFsO1xuICAgIGRhdGEuanVzdE9uZSA9IGp1c3RPbmU7XG5cbiAgICAvLyBgbWF0Y2hgXG4gICAgY29uc3QgYmFzZU1hdGNoID0gZ2V0KGRhdGEsICd2aXJ0dWFsLm9wdGlvbnMubWF0Y2gnLCBudWxsKSB8fFxuICAgICAgZ2V0KGRhdGEsICd2aXJ0dWFsLm9wdGlvbnMub3B0aW9ucy5tYXRjaCcsIG51bGwpO1xuICAgIGxldCBtYXRjaCA9IGdldChvcHRpb25zLCAnbWF0Y2gnLCBudWxsKSB8fCBiYXNlTWF0Y2g7XG5cbiAgICBsZXQgaGFzTWF0Y2hGdW5jdGlvbiA9IHR5cGVvZiBtYXRjaCA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoaGFzTWF0Y2hGdW5jdGlvbikge1xuICAgICAgbWF0Y2ggPSBtYXRjaC5jYWxsKGRvYywgZG9jLCBkYXRhLnZpcnR1YWwpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGxvY2FsRmllbGQpICYmIEFycmF5LmlzQXJyYXkoZm9yZWlnbkZpZWxkKSAmJiBsb2NhbEZpZWxkLmxlbmd0aCA9PT0gZm9yZWlnbkZpZWxkLmxlbmd0aCkge1xuICAgICAgbWF0Y2ggPSBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCk7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxvY2FsRmllbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbWF0Y2hbZm9yZWlnbkZpZWxkW2ldXSA9IGNvbnZlcnRUb19pZChtcGF0aC5nZXQobG9jYWxGaWVsZFtpXSwgZG9jLCBsb29rdXBMb2NhbEZpZWxkcyksIG1vZGVsLnNjaGVtYSk7XG4gICAgICAgIGhhc01hdGNoRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBsb2NhbEZpZWxkID0gbG9jYWxGaWVsZFswXTtcbiAgICAgIGZvcmVpZ25GaWVsZCA9IGZvcmVpZ25GaWVsZFswXTtcbiAgICB9XG4gICAgZGF0YS5sb2NhbEZpZWxkID0gbG9jYWxGaWVsZDtcbiAgICBkYXRhLmZvcmVpZ25GaWVsZCA9IGZvcmVpZ25GaWVsZDtcbiAgICBkYXRhLm1hdGNoID0gbWF0Y2g7XG4gICAgZGF0YS5oYXNNYXRjaEZ1bmN0aW9uID0gaGFzTWF0Y2hGdW5jdGlvbjtcblxuICAgIC8vIEdldCBsb2NhbCBmaWVsZHNcbiAgICBjb25zdCByZXQgPSBfZ2V0TG9jYWxGaWVsZFZhbHVlcyhkb2MsIGxvY2FsRmllbGQsIG1vZGVsLCBvcHRpb25zLCB2aXJ0dWFsKTtcblxuICAgIHRyeSB7XG4gICAgICBhZGRNb2RlbE5hbWVzVG9NYXAobW9kZWwsIG1hcCwgYXZhaWxhYmxlLCBtb2RlbE5hbWVzLCBvcHRpb25zLCBkYXRhLCByZXQsIGRvYyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXA7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gYWRkTW9kZWxOYW1lc1RvTWFwKG1vZGVsLCBtYXAsIGF2YWlsYWJsZSwgbW9kZWxOYW1lcywgb3B0aW9ucywgZGF0YSwgcmV0LCBkb2MsIHNjaGVtYU9wdGlvbnMsIHVucG9wdWxhdGVkVmFsdWUpIHtcbiAgLy8gYFBvcHVsYXRlT3B0aW9ucyNjb25uZWN0aW9uYDogaWYgdGhlIG1vZGVsIGlzIHBhc3NlZCBhcyBhIHN0cmluZywgdGhlXG4gIC8vIGNvbm5lY3Rpb24gbWF0dGVycyBiZWNhdXNlIGRpZmZlcmVudCBjb25uZWN0aW9ucyBoYXZlIGRpZmZlcmVudCBtb2RlbHMuXG4gIGNvbnN0IGNvbm5lY3Rpb24gPSBvcHRpb25zLmNvbm5lY3Rpb24gIT0gbnVsbCA/IG9wdGlvbnMuY29ubmVjdGlvbiA6IG1vZGVsLmRiO1xuXG4gIHVucG9wdWxhdGVkVmFsdWUgPSB1bnBvcHVsYXRlZFZhbHVlID09PSB2b2lkIDAgPyByZXQgOiB1bnBvcHVsYXRlZFZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheSh1bnBvcHVsYXRlZFZhbHVlKSkge1xuICAgIHVucG9wdWxhdGVkVmFsdWUgPSB1dGlscy5jbG9uZUFycmF5cyh1bnBvcHVsYXRlZFZhbHVlKTtcbiAgfVxuXG4gIGlmIChtb2RlbE5hbWVzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgayA9IG1vZGVsTmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoay0tKSB7XG4gICAgY29uc3QgbW9kZWxOYW1lID0gbW9kZWxOYW1lc1trXTtcbiAgICBpZiAobW9kZWxOYW1lID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBNb2RlbDtcbiAgICBpZiAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsW21vZGVsU3ltYm9sXSkge1xuICAgICAgTW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIH0gZWxzZSBpZiAobW9kZWxOYW1lW21vZGVsU3ltYm9sXSkge1xuICAgICAgTW9kZWwgPSBtb2RlbE5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIE1vZGVsID0gX2dldE1vZGVsRnJvbUNvbm4oY29ubmVjdGlvbiwgbW9kZWxOYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAocmV0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgTW9kZWwgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBpZHMgPSByZXQ7XG4gICAgY29uc3QgZmxhdCA9IEFycmF5LmlzQXJyYXkocmV0KSA/IHV0aWxzLmFycmF5LmZsYXR0ZW4ocmV0KSA6IFtdO1xuXG4gICAgY29uc3QgbW9kZWxOYW1lc0ZvclJlZlBhdGggPSBkYXRhLm1vZGVsTmFtZXNJbk9yZGVyID8gZGF0YS5tb2RlbE5hbWVzSW5PcmRlciA6IG1vZGVsTmFtZXM7XG4gICAgaWYgKGRhdGEuaXNSZWZQYXRoICYmIEFycmF5LmlzQXJyYXkocmV0KSAmJiBmbGF0Lmxlbmd0aCA9PT0gbW9kZWxOYW1lc0ZvclJlZlBhdGgubGVuZ3RoKSB7XG4gICAgICBpZHMgPSBmbGF0LmZpbHRlcigodmFsLCBpKSA9PiBtb2RlbE5hbWVzRm9yUmVmUGF0aFtpXSA9PT0gbW9kZWxOYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCBwZXJEb2N1bWVudExpbWl0ID0gb3B0aW9ucy5wZXJEb2N1bWVudExpbWl0ID09IG51bGwgP1xuICAgICAgZ2V0KG9wdGlvbnMsICdvcHRpb25zLnBlckRvY3VtZW50TGltaXQnLCBudWxsKSA6XG4gICAgICBvcHRpb25zLnBlckRvY3VtZW50TGltaXQ7XG5cbiAgICBpZiAoIWF2YWlsYWJsZVttb2RlbE5hbWVdIHx8IHBlckRvY3VtZW50TGltaXQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgY3VycmVudE9wdGlvbnMgPSB7XG4gICAgICAgIG1vZGVsOiBNb2RlbFxuICAgICAgfTtcbiAgICAgIGlmIChkYXRhLmlzVmlydHVhbCAmJiBnZXQoZGF0YS52aXJ0dWFsLCAnb3B0aW9ucy5vcHRpb25zJykpIHtcbiAgICAgICAgY3VycmVudE9wdGlvbnMub3B0aW9ucyA9IGNsb25lKGRhdGEudmlydHVhbC5vcHRpb25zLm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChzY2hlbWFPcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgY3VycmVudE9wdGlvbnMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHNjaGVtYU9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdXRpbHMubWVyZ2UoY3VycmVudE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBVc2VkIGludGVybmFsbHkgZm9yIGNoZWNraW5nIHdoYXQgbW9kZWwgd2FzIHVzZWQgdG8gcG9wdWxhdGUgdGhpc1xuICAgICAgLy8gcGF0aC5cbiAgICAgIG9wdGlvbnNbcG9wdWxhdGVNb2RlbFN5bWJvbF0gPSBNb2RlbDtcbiAgICAgIGN1cnJlbnRPcHRpb25zW3BvcHVsYXRlTW9kZWxTeW1ib2xdID0gTW9kZWw7XG4gICAgICBhdmFpbGFibGVbbW9kZWxOYW1lXSA9IHtcbiAgICAgICAgbW9kZWw6IE1vZGVsLFxuICAgICAgICBvcHRpb25zOiBjdXJyZW50T3B0aW9ucyxcbiAgICAgICAgbWF0Y2g6IGRhdGEuaGFzTWF0Y2hGdW5jdGlvbiA/IFtkYXRhLm1hdGNoXSA6IGRhdGEubWF0Y2gsXG4gICAgICAgIGRvY3M6IFtkb2NdLFxuICAgICAgICBpZHM6IFtpZHNdLFxuICAgICAgICBhbGxJZHM6IFtyZXRdLFxuICAgICAgICB1bnBvcHVsYXRlZFZhbHVlczogW3VucG9wdWxhdGVkVmFsdWVdLFxuICAgICAgICBsb2NhbEZpZWxkOiBuZXcgU2V0KFtkYXRhLmxvY2FsRmllbGRdKSxcbiAgICAgICAgZm9yZWlnbkZpZWxkOiBuZXcgU2V0KFtkYXRhLmZvcmVpZ25GaWVsZF0pLFxuICAgICAgICBqdXN0T25lOiBkYXRhLmp1c3RPbmUsXG4gICAgICAgIGlzVmlydHVhbDogZGF0YS5pc1ZpcnR1YWwsXG4gICAgICAgIHZpcnR1YWw6IGRhdGEudmlydHVhbCxcbiAgICAgICAgY291bnQ6IGRhdGEuY291bnQsXG4gICAgICAgIFtwb3B1bGF0ZU1vZGVsU3ltYm9sXTogTW9kZWxcbiAgICAgIH07XG4gICAgICBtYXAucHVzaChhdmFpbGFibGVbbW9kZWxOYW1lXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF2YWlsYWJsZVttb2RlbE5hbWVdLmxvY2FsRmllbGQuYWRkKGRhdGEubG9jYWxGaWVsZCk7XG4gICAgICBhdmFpbGFibGVbbW9kZWxOYW1lXS5mb3JlaWduRmllbGQuYWRkKGRhdGEuZm9yZWlnbkZpZWxkKTtcbiAgICAgIGF2YWlsYWJsZVttb2RlbE5hbWVdLmRvY3MucHVzaChkb2MpO1xuICAgICAgYXZhaWxhYmxlW21vZGVsTmFtZV0uaWRzLnB1c2goaWRzKTtcbiAgICAgIGF2YWlsYWJsZVttb2RlbE5hbWVdLmFsbElkcy5wdXNoKHJldCk7XG4gICAgICBhdmFpbGFibGVbbW9kZWxOYW1lXS51bnBvcHVsYXRlZFZhbHVlcy5wdXNoKHVucG9wdWxhdGVkVmFsdWUpO1xuICAgICAgaWYgKGRhdGEuaGFzTWF0Y2hGdW5jdGlvbikge1xuICAgICAgICBhdmFpbGFibGVbbW9kZWxOYW1lXS5tYXRjaC5wdXNoKGRhdGEubWF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0TW9kZWxGcm9tQ29ubihjb25uLCBtb2RlbE5hbWUpIHtcbiAgLyogSWYgdGhpcyBjb25uZWN0aW9uIGhhcyBhIHBhcmVudCBmcm9tIGB1c2VEYigpYCwgYnViYmxlIHVwIHRvIHBhcmVudCdzIG1vZGVscyAqL1xuICBpZiAoY29ubi5tb2RlbHNbbW9kZWxOYW1lXSA9PSBudWxsICYmIGNvbm4uX3BhcmVudCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIF9nZXRNb2RlbEZyb21Db25uKGNvbm4uX3BhcmVudCwgbW9kZWxOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBjb25uLm1vZGVsKG1vZGVsTmFtZSk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlUmVmRnVuY3Rpb24ocmVmLCBkb2MpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicgJiYgIXJlZlttb2RlbFN5bWJvbF0pIHtcbiAgICByZXR1cm4gcmVmLmNhbGwoZG9jLCBkb2MpO1xuICB9XG4gIHJldHVybiByZWY7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2dldExvY2FsRmllbGRWYWx1ZXMoZG9jLCBsb2NhbEZpZWxkLCBtb2RlbCwgb3B0aW9ucywgdmlydHVhbCwgc2NoZW1hKSB7XG4gIC8vIEdldCBMb2NhbCBmaWVsZHNcbiAgY29uc3QgbG9jYWxGaWVsZFBhdGhUeXBlID0gbW9kZWwuc2NoZW1hLl9nZXRQYXRoVHlwZShsb2NhbEZpZWxkKTtcbiAgY29uc3QgbG9jYWxGaWVsZFBhdGggPSBsb2NhbEZpZWxkUGF0aFR5cGUgPT09ICdyZWFsJyA/XG4gICAgbW9kZWwuc2NoZW1hLnBhdGgobG9jYWxGaWVsZCkgOlxuICAgIGxvY2FsRmllbGRQYXRoVHlwZS5zY2hlbWE7XG4gIGNvbnN0IGxvY2FsRmllbGRHZXR0ZXJzID0gbG9jYWxGaWVsZFBhdGggJiYgbG9jYWxGaWVsZFBhdGguZ2V0dGVycyA/XG4gICAgbG9jYWxGaWVsZFBhdGguZ2V0dGVycyA6IFtdO1xuXG4gIGxvY2FsRmllbGQgPSBsb2NhbEZpZWxkUGF0aCAhPSBudWxsICYmIGxvY2FsRmllbGRQYXRoLmluc3RhbmNlID09PSAnRW1iZWRkZWQnID8gbG9jYWxGaWVsZCArICcuX2lkJyA6IGxvY2FsRmllbGQ7XG5cbiAgY29uc3QgX3BvcHVsYXRlT3B0aW9ucyA9IGdldChvcHRpb25zLCAnb3B0aW9ucycsIHt9KTtcblxuICBjb25zdCBnZXR0ZXJzID0gJ2dldHRlcnMnIGluIF9wb3B1bGF0ZU9wdGlvbnMgP1xuICAgIF9wb3B1bGF0ZU9wdGlvbnMuZ2V0dGVycyA6XG4gICAgZ2V0KHZpcnR1YWwsICdvcHRpb25zLmdldHRlcnMnLCBmYWxzZSk7XG4gIGlmIChsb2NhbEZpZWxkR2V0dGVycy5sZW5ndGggIT09IDAgJiYgZ2V0dGVycykge1xuICAgIGNvbnN0IGh5ZHJhdGVkRG9jID0gKGRvYy4kX18gIT0gbnVsbCkgPyBkb2MgOiBtb2RlbC5oeWRyYXRlKGRvYyk7XG4gICAgY29uc3QgbG9jYWxGaWVsZFZhbHVlID0gdXRpbHMuZ2V0VmFsdWUobG9jYWxGaWVsZCwgZG9jKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsb2NhbEZpZWxkVmFsdWUpKSB7XG4gICAgICBjb25zdCBsb2NhbEZpZWxkSHlkcmF0ZWRWYWx1ZSA9IHV0aWxzLmdldFZhbHVlKGxvY2FsRmllbGQuc3BsaXQoJy4nKS5zbGljZSgwLCAtMSksIGh5ZHJhdGVkRG9jKTtcbiAgICAgIHJldHVybiBsb2NhbEZpZWxkVmFsdWUubWFwKChsb2NhbEZpZWxkQXJyVmFsLCBsb2NhbEZpZWxkQXJySW5kZXgpID0+XG4gICAgICAgIGxvY2FsRmllbGRQYXRoLmFwcGx5R2V0dGVycyhsb2NhbEZpZWxkQXJyVmFsLCBsb2NhbEZpZWxkSHlkcmF0ZWRWYWx1ZVtsb2NhbEZpZWxkQXJySW5kZXhdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsb2NhbEZpZWxkUGF0aC5hcHBseUdldHRlcnMobG9jYWxGaWVsZFZhbHVlLCBoeWRyYXRlZERvYyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb252ZXJ0VG9faWQobXBhdGguZ2V0KGxvY2FsRmllbGQsIGRvYywgbG9va3VwTG9jYWxGaWVsZHMpLCBzY2hlbWEpO1xuICB9XG59XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIF9pZCBvZiBgdmFsYCBpZiBhIERvY3VtZW50IG9yIEFycmF5IG9mIERvY3VtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fERvY3VtZW50fEFueX0gdmFsXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcmV0dXJuIHtBcnJheXxEb2N1bWVudHxBbnl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9faWQodmFsLCBzY2hlbWEpIHtcbiAgaWYgKHZhbCAhPSBudWxsICYmIHZhbC4kX18gIT0gbnVsbCkge1xuICAgIHJldHVybiB2YWwuX2lkO1xuICB9XG4gIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwuX2lkICE9IG51bGwgJiYgKHNjaGVtYSA9PSBudWxsIHx8ICFzY2hlbWEuJGlzU2NoZW1hTWFwKSkge1xuICAgIHJldHVybiB2YWwuX2lkO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGNvbnN0IHJhd1ZhbCA9IHZhbC5fX2FycmF5ICE9IG51bGwgPyB2YWwuX19hcnJheSA6IHZhbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd1ZhbC5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHJhd1ZhbFtpXSAhPSBudWxsICYmIHJhd1ZhbFtpXS4kX18gIT0gbnVsbCkge1xuICAgICAgICByYXdWYWxbaV0gPSByYXdWYWxbaV0uX2lkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXRpbHMuaXNNb25nb29zZUFycmF5KHZhbCkgJiYgdmFsLiRzY2hlbWEoKSkge1xuICAgICAgcmV0dXJuIHZhbC4kc2NoZW1hKCkuX2Nhc3RGb3JQb3B1bGF0ZSh2YWwsIHZhbC4kcGFyZW50KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBbXS5jb25jYXQodmFsKTtcbiAgfVxuXG4gIC8vIGBwb3B1bGF0ZSgnbWFwJylgIG1heSBiZSBhbiBvYmplY3QgaWYgcG9wdWxhdGluZyBvbiBhIGRvYyB0aGF0IGhhc24ndFxuICAvLyBiZWVuIGh5ZHJhdGVkIHlldFxuICBpZiAoZ2V0Q29uc3RydWN0b3JOYW1lKHZhbCkgPT09ICdPYmplY3QnICYmXG4gICAgICAvLyBUaGUgaW50ZW50IGhlcmUgaXMgd2Ugc2hvdWxkIG9ubHkgZmxhdHRlbiB0aGUgb2JqZWN0IGlmIHdlIGV4cGVjdFxuICAgICAgLy8gdG8gZ2V0IGEgTWFwIGluIHRoZSBlbmQuIEF2b2lkIGRvaW5nIHRoaXMgZm9yIG1peGVkIHR5cGVzLlxuICAgICAgKHNjaGVtYSA9PSBudWxsIHx8IHNjaGVtYVtzY2hlbWFNaXhlZFN5bWJvbF0gPT0gbnVsbCkpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWwpKSB7XG4gICAgICByZXQucHVzaCh2YWxba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLy8gSWYgZG9jIGhhcyBhbHJlYWR5IGJlZW4gaHlkcmF0ZWQsIGUuZy4gYGRvYy5wb3B1bGF0ZSgnbWFwJylgXG4gIC8vIHRoZW4gYHZhbGAgd2lsbCBhbHJlYWR5IGJlIGEgbWFwXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWwudmFsdWVzKCkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZmluZFJlZlBhdGhGb3JEaXNjcmltaW5hdG9ycyhkb2MsIG1vZGVsU2NoZW1hLCBkYXRhLCBvcHRpb25zLCBub3JtYWxpemVkUmVmUGF0aCwgcmV0KSB7XG4gIC8vIFJlOiBnaC04NDUyLiBFbWJlZGRlZCBkaXNjcmltaW5hdG9ycyBtYXkgbm90IGhhdmUgYHJlZlBhdGhgLCBzbyBjbGVhclxuICAvLyBvdXQgZW1iZWRkZWQgZGlzY3JpbWluYXRvciBkb2NzIHRoYXQgZG9uJ3QgaGF2ZSBhIGByZWZQYXRoYCBvbiB0aGVcbiAgLy8gcG9wdWxhdGVkIHBhdGguXG4gIGlmICghZGF0YS5pc1JlZlBhdGggfHwgbm9ybWFsaXplZFJlZlBhdGggPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBpZWNlcyA9IG5vcm1hbGl6ZWRSZWZQYXRoLnNwbGl0KCcuJyk7XG4gIGxldCBjdXIgPSAnJztcbiAgbGV0IG1vZGVsTmFtZXMgPSB2b2lkIDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGllY2UgPSBwaWVjZXNbaV07XG4gICAgY3VyID0gY3VyICsgKGN1ci5sZW5ndGggPT09IDAgPyAnJyA6ICcuJykgKyBwaWVjZTtcbiAgICBjb25zdCBzY2hlbWF0eXBlID0gbW9kZWxTY2hlbWEucGF0aChjdXIpO1xuICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwgJiZcbiAgICAgICAgc2NoZW1hdHlwZS4kaXNNb25nb29zZUFycmF5ICYmXG4gICAgICAgIHNjaGVtYXR5cGUuY2FzdGVyLmRpc2NyaW1pbmF0b3JzICE9IG51bGwgJiZcbiAgICAgICAgT2JqZWN0LmtleXMoc2NoZW1hdHlwZS5jYXN0ZXIuZGlzY3JpbWluYXRvcnMpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3Qgc3ViZG9jcyA9IHV0aWxzLmdldFZhbHVlKGN1ciwgZG9jKTtcbiAgICAgIGNvbnN0IHJlbW5hbnQgPSBvcHRpb25zLnBhdGguc3Vic3RyaW5nKGN1ci5sZW5ndGggKyAxKTtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBzY2hlbWF0eXBlLmNhc3Rlci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICAgICAgbW9kZWxOYW1lcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBzdWJkb2Mgb2Ygc3ViZG9jcykge1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yTmFtZSA9IHV0aWxzLmdldFZhbHVlKGRpc2NyaW1pbmF0b3JLZXksIHN1YmRvYyk7XG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSBzY2hlbWF0eXBlLmNhc3Rlci5kaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yTmFtZV07XG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JTY2hlbWEgPSBkaXNjcmltaW5hdG9yICYmIGRpc2NyaW1pbmF0b3Iuc2NoZW1hO1xuICAgICAgICBpZiAoZGlzY3JpbWluYXRvclNjaGVtYSA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX3BhdGggPSBkaXNjcmltaW5hdG9yU2NoZW1hLnBhdGgocmVtbmFudCk7XG4gICAgICAgIGlmIChfcGF0aCA9PSBudWxsIHx8IF9wYXRoLm9wdGlvbnMucmVmUGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZG9jVmFsdWUgPSB1dGlscy5nZXRWYWx1ZShkYXRhLmxvY2FsRmllbGQuc3Vic3RyaW5nKGN1ci5sZW5ndGggKyAxKSwgc3ViZG9jKTtcbiAgICAgICAgICByZXQuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHYgPT09IGRvY1ZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldFtpXSA9IFNraXBQb3B1bGF0ZVZhbHVlKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHV0aWxzLmdldFZhbHVlKHBpZWNlcy5zbGljZShpICsgMSkuam9pbignLicpLCBzdWJkb2MpO1xuICAgICAgICBtb2RlbE5hbWVzLnB1c2gobW9kZWxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbW9kZWxOYW1lcztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js":
/*!******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nconst Mixed = __webpack_require__(/*! ../../schema/mixed */ \"(api)/../server/node_modules/mongoose/lib/schema/mixed.js\");\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./leanPopulateMap */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(api)/../server/node_modules/mpath/index.js\");\n\nconst populateModelSymbol = (__webpack_require__(/*! ../symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\n\n/**\n * Given a model and its schema, find all possible schema types for `path`,\n * including searching through discriminators. If `doc` is specified, will\n * use the doc's values for discriminator keys when searching, otherwise\n * will search all discriminators.\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n * @api private\n */\n\nmodule.exports = function getSchemaTypes(model, schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n\n  const discriminatorKey = schema.discriminatorMapping &&\n    schema.discriminatorMapping.key;\n  if (discriminatorKey && model != null) {\n    if (doc != null && doc[discriminatorKey] != null) {\n      const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      schema = discriminator ? discriminator.schema : schema;\n    } else if (model.discriminators != null) {\n      return Object.keys(model.discriminators).reduce((arr, name) => {\n        const disc = model.discriminators[name];\n        return arr.concat(getSchemaTypes(disc, disc.schema, null, path));\n      }, []);\n    }\n  }\n\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n\n        let schemas = null;\n        if (foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' +\n            foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).\n            reduce(function(cur, discriminator) {\n              const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n                cur.push(discriminators[discriminator]);\n              }\n              return cur;\n            }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(\n              parts.slice(p + 1),\n              schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(\n                parts.slice(p),\n                schema,\n                subdoc ? mpath.get(trypath, subdoc) : null,\n                nestedPath.concat(parts.slice(0, p))\n              );\n              if (_ret != null) {\n                _ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray ||\n                  (foundschema.schema.$isSingleNested ? null : foundschema);\n                if (_ret.$parentSchemaDocArray) {\n                  ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(\n              parts.slice(p),\n              foundschema.schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n        } else if (p !== parts.length &&\n            foundschema.$isMongooseArray &&\n            foundschema.casterConstructor.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.casterConstructor;\n          }\n\n          const ret = search(\n            parts.slice(p),\n            type.schema,\n            null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n          if (ret != null) {\n            return ret;\n          }\n\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {\n        return foundschema.$__schemaType;\n      }\n\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath) && p < parts.length) {\n        const model = doc.$__.populated[fullPath].options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(\n            parts.slice(p),\n            model.schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          return ret;\n        }\n      }\n\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ?\n          leanPopulateMap.get(_val[0]) :\n          leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model != null ? model.schema : null;\n        if (schema != null) {\n          const ret = search(\n            parts.slice(p),\n            schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret != null) {\n            ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n              (schema.$isSingleNested ? null : schema);\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9nZXRTY2hlbWFUeXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLHFGQUFvQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsd0VBQVE7QUFDNUIsZ0NBQWdDLG1CQUFPLENBQUMsNElBQTBDO0FBQ2xGLHdCQUF3QixtQkFBTyxDQUFDLHdHQUFtQjtBQUNuRCxjQUFjLG1CQUFPLENBQUMsMERBQU87O0FBRTdCLDRCQUE0QiwySEFBeUM7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHBvcHVsYXRlXFxnZXRTY2hlbWFUeXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3QgTWl4ZWQgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvbWl4ZWQnKTtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuLi9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBsZWFuUG9wdWxhdGVNYXAgPSByZXF1aXJlKCcuL2xlYW5Qb3B1bGF0ZU1hcCcpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuXG5jb25zdCBwb3B1bGF0ZU1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi4vc3ltYm9scycpLnBvcHVsYXRlTW9kZWxTeW1ib2w7XG5cbi8qKlxuICogR2l2ZW4gYSBtb2RlbCBhbmQgaXRzIHNjaGVtYSwgZmluZCBhbGwgcG9zc2libGUgc2NoZW1hIHR5cGVzIGZvciBgcGF0aGAsXG4gKiBpbmNsdWRpbmcgc2VhcmNoaW5nIHRocm91Z2ggZGlzY3JpbWluYXRvcnMuIElmIGBkb2NgIGlzIHNwZWNpZmllZCwgd2lsbFxuICogdXNlIHRoZSBkb2MncyB2YWx1ZXMgZm9yIGRpc2NyaW1pbmF0b3Iga2V5cyB3aGVuIHNlYXJjaGluZywgb3RoZXJ3aXNlXG4gKiB3aWxsIHNlYXJjaCBhbGwgZGlzY3JpbWluYXRvcnMuXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgUE9KT1xuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZXMobW9kZWwsIHNjaGVtYSwgZG9jLCBwYXRoKSB7XG4gIGNvbnN0IHBhdGhzY2hlbWEgPSBzY2hlbWEucGF0aChwYXRoKTtcbiAgY29uc3QgdG9wTGV2ZWxEb2MgPSBkb2M7XG4gIGlmIChwYXRoc2NoZW1hKSB7XG4gICAgcmV0dXJuIHBhdGhzY2hlbWE7XG4gIH1cblxuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nICYmXG4gICAgc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLmtleTtcbiAgaWYgKGRpc2NyaW1pbmF0b3JLZXkgJiYgbW9kZWwgIT0gbnVsbCkge1xuICAgIGlmIChkb2MgIT0gbnVsbCAmJiBkb2NbZGlzY3JpbWluYXRvcktleV0gIT0gbnVsbCkge1xuICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKG1vZGVsLmRpc2NyaW1pbmF0b3JzLCBkb2NbZGlzY3JpbWluYXRvcktleV0pO1xuICAgICAgc2NoZW1hID0gZGlzY3JpbWluYXRvciA/IGRpc2NyaW1pbmF0b3Iuc2NoZW1hIDogc2NoZW1hO1xuICAgIH0gZWxzZSBpZiAobW9kZWwuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1vZGVsLmRpc2NyaW1pbmF0b3JzKS5yZWR1Y2UoKGFyciwgbmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBkaXNjID0gbW9kZWwuZGlzY3JpbWluYXRvcnNbbmFtZV07XG4gICAgICAgIHJldHVybiBhcnIuY29uY2F0KGdldFNjaGVtYVR5cGVzKGRpc2MsIGRpc2Muc2NoZW1hLCBudWxsLCBwYXRoKSk7XG4gICAgICB9LCBbXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoKHBhcnRzLCBzY2hlbWEsIHN1YmRvYywgbmVzdGVkUGF0aCkge1xuICAgIGxldCBwID0gcGFydHMubGVuZ3RoICsgMTtcbiAgICBsZXQgZm91bmRzY2hlbWE7XG4gICAgbGV0IHRyeXBhdGg7XG5cbiAgICB3aGlsZSAocC0tKSB7XG4gICAgICB0cnlwYXRoID0gcGFydHMuc2xpY2UoMCwgcCkuam9pbignLicpO1xuICAgICAgZm91bmRzY2hlbWEgPSBzY2hlbWEucGF0aCh0cnlwYXRoKTtcbiAgICAgIGlmIChmb3VuZHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmRzY2hlbWEuY2FzdGVyKSB7XG4gICAgICAgIC8vIGFycmF5IG9mIE1peGVkP1xuICAgICAgICBpZiAoZm91bmRzY2hlbWEuY2FzdGVyIGluc3RhbmNlb2YgTWl4ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZm91bmRzY2hlbWEuY2FzdGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNjaGVtYXMgPSBudWxsO1xuICAgICAgICBpZiAoZm91bmRzY2hlbWEuc2NoZW1hICE9IG51bGwgJiYgZm91bmRzY2hlbWEuc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9ycyA9IGZvdW5kc2NoZW1hLnNjaGVtYS5kaXNjcmltaW5hdG9ycztcbiAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yS2V5UGF0aCA9IHRyeXBhdGggKyAnLicgK1xuICAgICAgICAgICAgZm91bmRzY2hlbWEuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgICAgICAgICBjb25zdCBrZXlzID0gc3ViZG9jID8gbXBhdGguZ2V0KGRpc2NyaW1pbmF0b3JLZXlQYXRoLCBzdWJkb2MpIHx8IFtdIDogW107XG4gICAgICAgICAgc2NoZW1hcyA9IE9iamVjdC5rZXlzKGRpc2NyaW1pbmF0b3JzKS5cbiAgICAgICAgICAgIHJlZHVjZShmdW5jdGlvbihjdXIsIGRpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgdGllZFZhbHVlID0gZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvcl0uZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChkb2MgPT0gbnVsbCB8fCBrZXlzLmluZGV4T2YoZGlzY3JpbWluYXRvcikgIT09IC0xIHx8IGtleXMuaW5kZXhPZih0aWVkVmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGN1ci5wdXNoKGRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IHRoYXQgd2UgZm91bmQgdGhlIGFycmF5LCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlXG4gICAgICAgIC8vIGFyZSByZW1haW5pbmcgZG9jdW1lbnQgcGF0aHMgdG8gbG9vayB1cCBmb3IgY2FzdGluZy5cbiAgICAgICAgLy8gQWxzbyB3ZSBuZWVkIHRvIGhhbmRsZSBhcnJheS4kLnBhdGggc2luY2Ugc2NoZW1hLnBhdGhcbiAgICAgICAgLy8gZG9lc24ndCB3b3JrIGZvciB0aGF0LlxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBmb3VuZHNjaGVtYS5zY2hlbWEgd2UgYXJlIGRlYWxpbmcgd2l0aFxuICAgICAgICAvLyBhIHBhdGggbGlrZSBhcnJheS4kXG4gICAgICAgIGlmIChwICE9PSBwYXJ0cy5sZW5ndGggJiYgZm91bmRzY2hlbWEuc2NoZW1hKSB7XG4gICAgICAgICAgbGV0IHJldDtcbiAgICAgICAgICBpZiAocGFydHNbcF0gPT09ICckJykge1xuICAgICAgICAgICAgaWYgKHAgKyAxID09PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gY29tbWVudHMuJFxuICAgICAgICAgICAgICByZXR1cm4gZm91bmRzY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb21tZW50cy4kLmNvbW1lbnRzLiQudGl0bGVcbiAgICAgICAgICAgIHJldCA9IHNlYXJjaChcbiAgICAgICAgICAgICAgcGFydHMuc2xpY2UocCArIDEpLFxuICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgIHN1YmRvYyA/IG1wYXRoLmdldCh0cnlwYXRoLCBzdWJkb2MpIDogbnVsbCxcbiAgICAgICAgICAgICAgbmVzdGVkUGF0aC5jb25jYXQocGFydHMuc2xpY2UoMCwgcCkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSB8fFxuICAgICAgICAgICAgICAgIChmb3VuZHNjaGVtYS5zY2hlbWEuJGlzU2luZ2xlTmVzdGVkID8gbnVsbCA6IGZvdW5kc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNjaGVtYXMgIT0gbnVsbCAmJiBzY2hlbWFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2Ygc2NoZW1hcykge1xuICAgICAgICAgICAgICBjb25zdCBfcmV0ID0gc2VhcmNoKFxuICAgICAgICAgICAgICAgIHBhcnRzLnNsaWNlKHApLFxuICAgICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgICBzdWJkb2MgPyBtcGF0aC5nZXQodHJ5cGF0aCwgc3ViZG9jKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgbmVzdGVkUGF0aC5jb25jYXQocGFydHMuc2xpY2UoMCwgcCkpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChfcmV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IF9yZXQuJHBhcmVudFNjaGVtYURvY0FycmF5IHx8XG4gICAgICAgICAgICAgICAgICAoZm91bmRzY2hlbWEuc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCA/IG51bGwgOiBmb3VuZHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKF9yZXQuJHBhcmVudFNjaGVtYURvY0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gX3JldC4kcGFyZW50U2NoZW1hRG9jQXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldC5wdXNoKF9yZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBzZWFyY2goXG4gICAgICAgICAgICAgIHBhcnRzLnNsaWNlKHApLFxuICAgICAgICAgICAgICBmb3VuZHNjaGVtYS5zY2hlbWEsXG4gICAgICAgICAgICAgIHN1YmRvYyA/IG1wYXRoLmdldCh0cnlwYXRoLCBzdWJkb2MpIDogbnVsbCxcbiAgICAgICAgICAgICAgbmVzdGVkUGF0aC5jb25jYXQocGFydHMuc2xpY2UoMCwgcCkpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgIHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPSByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5IHx8XG4gICAgICAgICAgICAgICAgKGZvdW5kc2NoZW1hLnNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQgPyBudWxsIDogZm91bmRzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocCAhPT0gcGFydHMubGVuZ3RoICYmXG4gICAgICAgICAgICBmb3VuZHNjaGVtYS4kaXNNb25nb29zZUFycmF5ICYmXG4gICAgICAgICAgICBmb3VuZHNjaGVtYS5jYXN0ZXJDb25zdHJ1Y3Rvci4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICAgICAgLy8gTmVzdGVkIGFycmF5cy4gRHJpbGwgZG93biB0byB0aGUgYm90dG9tIG9mIHRoZSBuZXN0ZWQgYXJyYXkuXG4gICAgICAgICAgbGV0IHR5cGUgPSBmb3VuZHNjaGVtYTtcbiAgICAgICAgICB3aGlsZSAodHlwZS4kaXNNb25nb29zZUFycmF5ICYmICF0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuY2FzdGVyQ29uc3RydWN0b3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmV0ID0gc2VhcmNoKFxuICAgICAgICAgICAgcGFydHMuc2xpY2UocCksXG4gICAgICAgICAgICB0eXBlLnNjaGVtYSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuZXN0ZWRQYXRoLmNvbmNhdChwYXJ0cy5zbGljZSgwLCBwKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChyZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZS5zY2hlbWEuZGlzY3JpbWluYXRvcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JQYXRocyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBkaXNjcmltaW5hdG9yTmFtZSBvZiBPYmplY3Qua2V5cyh0eXBlLnNjaGVtYS5kaXNjcmltaW5hdG9ycykpIHtcbiAgICAgICAgICAgICAgY29uc3QgX3NjaGVtYSA9IHR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JOYW1lXSB8fCB0eXBlLnNjaGVtYTtcbiAgICAgICAgICAgICAgY29uc3QgcmV0ID0gc2VhcmNoKHBhcnRzLnNsaWNlKHApLCBfc2NoZW1hLCBudWxsLCBuZXN0ZWRQYXRoLmNvbmNhdChwYXJ0cy5zbGljZSgwLCBwKSkpO1xuICAgICAgICAgICAgICBpZiAocmV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkaXNjcmltaW5hdG9yUGF0aHMucHVzaChyZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzY3JpbWluYXRvclBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRpc2NyaW1pbmF0b3JQYXRocztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZm91bmRzY2hlbWEuJGlzU2NoZW1hTWFwICYmIGZvdW5kc2NoZW1hLiRfX3NjaGVtYVR5cGUgaW5zdGFuY2VvZiBNaXhlZCkge1xuICAgICAgICByZXR1cm4gZm91bmRzY2hlbWEuJF9fc2NoZW1hVHlwZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZnVsbFBhdGggPSBuZXN0ZWRQYXRoLmNvbmNhdChbdHJ5cGF0aF0pLmpvaW4oJy4nKTtcbiAgICAgIGlmICh0b3BMZXZlbERvYyAhPSBudWxsICYmIHRvcExldmVsRG9jLiRfXyAmJiB0b3BMZXZlbERvYy4kcG9wdWxhdGVkKGZ1bGxQYXRoKSAmJiBwIDwgcGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gZG9jLiRfXy5wb3B1bGF0ZWRbZnVsbFBhdGhdLm9wdGlvbnNbcG9wdWxhdGVNb2RlbFN5bWJvbF07XG4gICAgICAgIGlmIChtb2RlbCAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgcmV0ID0gc2VhcmNoKFxuICAgICAgICAgICAgcGFydHMuc2xpY2UocCksXG4gICAgICAgICAgICBtb2RlbC5zY2hlbWEsXG4gICAgICAgICAgICBzdWJkb2MgPyBtcGF0aC5nZXQodHJ5cGF0aCwgc3ViZG9jKSA6IG51bGwsXG4gICAgICAgICAgICBuZXN0ZWRQYXRoLmNvbmNhdChwYXJ0cy5zbGljZSgwLCBwKSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBfdmFsID0gZ2V0KHRvcExldmVsRG9jLCB0cnlwYXRoKTtcbiAgICAgIGlmIChfdmFsICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSBBcnJheS5pc0FycmF5KF92YWwpICYmIF92YWwubGVuZ3RoID4gMCA/XG4gICAgICAgICAgbGVhblBvcHVsYXRlTWFwLmdldChfdmFsWzBdKSA6XG4gICAgICAgICAgbGVhblBvcHVsYXRlTWFwLmdldChfdmFsKTtcbiAgICAgICAgLy8gUG9wdWxhdGVkIHVzaW5nIGxlYW4sIGBsZWFuUG9wdWxhdGVNYXBgIHZhbHVlIGlzIHRoZSBmb3JlaWduIG1vZGVsXG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IG1vZGVsICE9IG51bGwgPyBtb2RlbC5zY2hlbWEgOiBudWxsO1xuICAgICAgICBpZiAoc2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCByZXQgPSBzZWFyY2goXG4gICAgICAgICAgICBwYXJ0cy5zbGljZShwKSxcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHN1YmRvYyA/IG1wYXRoLmdldCh0cnlwYXRoLCBzdWJkb2MpIDogbnVsbCxcbiAgICAgICAgICAgIG5lc3RlZFBhdGguY29uY2F0KHBhcnRzLnNsaWNlKDAsIHApKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAocmV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPSByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5IHx8XG4gICAgICAgICAgICAgIChzY2hlbWEuJGlzU2luZ2xlTmVzdGVkID8gbnVsbCA6IHNjaGVtYSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hO1xuICAgIH1cbiAgfVxuICAvLyBsb29rIGZvciBhcnJheXNcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAocGFydHNbaV0gPT09ICckJykge1xuICAgICAgLy8gUmU6IGdoLTU2MjgsIGJlY2F1c2UgYHNjaGVtYS5wYXRoKClgIGRvZXNuJ3QgdGFrZSAkIGludG8gYWNjb3VudC5cbiAgICAgIHBhcnRzW2ldID0gJzAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VhcmNoKHBhcnRzLCBzY2hlbWEsIGRvYywgW10pO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/getVirtual.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/getVirtual.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = getVirtual;\n\n/*!\n * ignore\n */\n\nfunction getVirtual(schema, name) {\n  if (schema.virtuals[name]) {\n    return { virtual: schema.virtuals[name], path: void 0 };\n  }\n\n  const parts = name.split('.');\n  let cur = '';\n  let nestedSchemaPath = '';\n  for (let i = 0; i < parts.length; ++i) {\n    cur += (cur.length > 0 ? '.' : '') + parts[i];\n    if (schema.virtuals[cur]) {\n      if (i === parts.length - 1) {\n        return { virtual: schema.virtuals[cur], path: nestedSchemaPath };\n      }\n      continue;\n    }\n\n    if (schema.nested[cur]) {\n      continue;\n    }\n\n    if (schema.paths[cur] && schema.paths[cur].schema) {\n      schema = schema.paths[cur].schema;\n      const rest = parts.slice(i + 1).join('.');\n\n      if (schema.virtuals[rest]) {\n        if (i === parts.length - 2) {\n          return {\n            virtual: schema.virtuals[rest],\n            nestedSchemaPath: [nestedSchemaPath, cur].filter(v => !!v).join('.')\n          };\n        }\n        continue;\n      }\n\n      if (i + 1 < parts.length && schema.discriminators) {\n        for (const key of Object.keys(schema.discriminators)) {\n          const res = getVirtual(schema.discriminators[key], rest);\n          if (res != null) {\n            const _path = [nestedSchemaPath, cur, res.nestedSchemaPath].\n              filter(v => !!v).join('.');\n            return {\n              virtual: res.virtual,\n              nestedSchemaPath: _path\n            };\n          }\n        }\n      }\n\n      nestedSchemaPath += (nestedSchemaPath.length > 0 ? '.' : '') + cur;\n      cur = '';\n      continue;\n    }\n\n    if (schema.discriminators) {\n      for (const discriminatorKey of Object.keys(schema.discriminators)) {\n        const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);\n        if (virtualFromDiscriminator) return virtualFromDiscriminator;\n      }\n    }\n\n    return null;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9nZXRWaXJ0dWFsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccG9wdWxhdGVcXGdldFZpcnR1YWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZpcnR1YWw7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZ2V0VmlydHVhbChzY2hlbWEsIG5hbWUpIHtcbiAgaWYgKHNjaGVtYS52aXJ0dWFsc1tuYW1lXSkge1xuICAgIHJldHVybiB7IHZpcnR1YWw6IHNjaGVtYS52aXJ0dWFsc1tuYW1lXSwgcGF0aDogdm9pZCAwIH07XG4gIH1cblxuICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgbGV0IGN1ciA9ICcnO1xuICBsZXQgbmVzdGVkU2NoZW1hUGF0aCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgY3VyICs9IChjdXIubGVuZ3RoID4gMCA/ICcuJyA6ICcnKSArIHBhcnRzW2ldO1xuICAgIGlmIChzY2hlbWEudmlydHVhbHNbY3VyXSkge1xuICAgICAgaWYgKGkgPT09IHBhcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIHsgdmlydHVhbDogc2NoZW1hLnZpcnR1YWxzW2N1cl0sIHBhdGg6IG5lc3RlZFNjaGVtYVBhdGggfTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWEubmVzdGVkW2N1cl0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWEucGF0aHNbY3VyXSAmJiBzY2hlbWEucGF0aHNbY3VyXS5zY2hlbWEpIHtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5wYXRoc1tjdXJdLnNjaGVtYTtcbiAgICAgIGNvbnN0IHJlc3QgPSBwYXJ0cy5zbGljZShpICsgMSkuam9pbignLicpO1xuXG4gICAgICBpZiAoc2NoZW1hLnZpcnR1YWxzW3Jlc3RdKSB7XG4gICAgICAgIGlmIChpID09PSBwYXJ0cy5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZpcnR1YWw6IHNjaGVtYS52aXJ0dWFsc1tyZXN0XSxcbiAgICAgICAgICAgIG5lc3RlZFNjaGVtYVBhdGg6IFtuZXN0ZWRTY2hlbWFQYXRoLCBjdXJdLmZpbHRlcih2ID0+ICEhdikuam9pbignLicpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgKyAxIDwgcGFydHMubGVuZ3RoICYmIHNjaGVtYS5kaXNjcmltaW5hdG9ycykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEuZGlzY3JpbWluYXRvcnMpKSB7XG4gICAgICAgICAgY29uc3QgcmVzID0gZ2V0VmlydHVhbChzY2hlbWEuZGlzY3JpbWluYXRvcnNba2V5XSwgcmVzdCk7XG4gICAgICAgICAgaWYgKHJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBfcGF0aCA9IFtuZXN0ZWRTY2hlbWFQYXRoLCBjdXIsIHJlcy5uZXN0ZWRTY2hlbWFQYXRoXS5cbiAgICAgICAgICAgICAgZmlsdGVyKHYgPT4gISF2KS5qb2luKCcuJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2aXJ0dWFsOiByZXMudmlydHVhbCxcbiAgICAgICAgICAgICAgbmVzdGVkU2NoZW1hUGF0aDogX3BhdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5lc3RlZFNjaGVtYVBhdGggKz0gKG5lc3RlZFNjaGVtYVBhdGgubGVuZ3RoID4gMCA/ICcuJyA6ICcnKSArIGN1cjtcbiAgICAgIGN1ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYS5kaXNjcmltaW5hdG9ycykge1xuICAgICAgZm9yIChjb25zdCBkaXNjcmltaW5hdG9yS2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYS5kaXNjcmltaW5hdG9ycykpIHtcbiAgICAgICAgY29uc3QgdmlydHVhbEZyb21EaXNjcmltaW5hdG9yID0gZ2V0VmlydHVhbChzY2hlbWEuZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvcktleV0sIG5hbWUpO1xuICAgICAgICBpZiAodmlydHVhbEZyb21EaXNjcmltaW5hdG9yKSByZXR1cm4gdmlydHVhbEZyb21EaXNjcmltaW5hdG9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/getVirtual.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9sZWFuUG9wdWxhdGVNYXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccG9wdWxhdGVcXGxlYW5Qb3B1bGF0ZU1hcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgV2Vha01hcCgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function lookupLocalFields(cur, path, val) {\n  if (cur == null) {\n    return cur;\n  }\n\n  if (cur._doc != null) {\n    cur = cur._doc;\n  }\n\n  if (arguments.length >= 3) {\n    if (typeof cur !== 'object') {\n      return void 0;\n    }\n    if (val === void 0) {\n      return void 0;\n    }\n    if (cur instanceof Map) {\n      cur.set(path, val);\n    } else {\n      cur[path] = val;\n    }\n    return val;\n  }\n\n\n  // Support populating paths under maps using `map.$*.subpath`\n  if (path === '$*') {\n    return cur instanceof Map ?\n      Array.from(cur.values()) :\n      Object.keys(cur).map(key => cur[key]);\n  }\n\n  if (cur instanceof Map) {\n    return cur.get(path);\n  }\n\n  return cur[path];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9sb29rdXBMb2NhbEZpZWxkcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxwb3B1bGF0ZVxcbG9va3VwTG9jYWxGaWVsZHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxvb2t1cExvY2FsRmllbGRzKGN1ciwgcGF0aCwgdmFsKSB7XG4gIGlmIChjdXIgPT0gbnVsbCkge1xuICAgIHJldHVybiBjdXI7XG4gIH1cblxuICBpZiAoY3VyLl9kb2MgIT0gbnVsbCkge1xuICAgIGN1ciA9IGN1ci5fZG9jO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xuICAgIGlmICh0eXBlb2YgY3VyICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoY3VyIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBjdXIuc2V0KHBhdGgsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cltwYXRoXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG5cbiAgLy8gU3VwcG9ydCBwb3B1bGF0aW5nIHBhdGhzIHVuZGVyIG1hcHMgdXNpbmcgYG1hcC4kKi5zdWJwYXRoYFxuICBpZiAocGF0aCA9PT0gJyQqJykge1xuICAgIHJldHVybiBjdXIgaW5zdGFuY2VvZiBNYXAgP1xuICAgICAgQXJyYXkuZnJvbShjdXIudmFsdWVzKCkpIDpcbiAgICAgIE9iamVjdC5rZXlzKGN1cikubWFwKGtleSA9PiBjdXJba2V5XSk7XG4gIH1cblxuICBpZiAoY3VyIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgcmV0dXJuIGN1ci5nZXQocGF0aCk7XG4gIH1cblxuICByZXR1cm4gY3VyW3BhdGhdO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js":
/*!*****************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\n/**\n * If populating a path within a document array, make sure each\n * subdoc within the array knows its subpaths are populated.\n *\n * #### Example:\n *\n *     const doc = await Article.findOne().populate('comments.author');\n *     doc.comments[0].populated('author'); // Should be set\n *\n * @param {Document} doc\n * @param {Object} [populated]\n * @api private\n */\n\nmodule.exports = function markArraySubdocsPopulated(doc, populated) {\n  if (doc._id == null || populated == null || populated.length === 0) {\n    return;\n  }\n\n  const id = String(doc._id);\n  for (const item of populated) {\n    if (item.isVirtual) {\n      continue;\n    }\n    const path = item.path;\n    const pieces = path.split('.');\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      const subpath = pieces.slice(0, i + 1).join('.');\n      const rest = pieces.slice(i + 1).join('.');\n      const val = doc.get(subpath);\n      if (val == null) {\n        continue;\n      }\n\n      if (utils.isMongooseDocumentArray(val)) {\n        for (let j = 0; j < val.length; ++j) {\n          if (val[j]) {\n            val[j].populated(rest, item._docs[id] == null ? void 0 : item._docs[id][j], item);\n          }\n        }\n        break;\n      }\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9tYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyx1RUFBYTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccG9wdWxhdGVcXG1hcmtBcnJheVN1YmRvY3NQb3B1bGF0ZWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogSWYgcG9wdWxhdGluZyBhIHBhdGggd2l0aGluIGEgZG9jdW1lbnQgYXJyYXksIG1ha2Ugc3VyZSBlYWNoXG4gKiBzdWJkb2Mgd2l0aGluIHRoZSBhcnJheSBrbm93cyBpdHMgc3VicGF0aHMgYXJlIHBvcHVsYXRlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IEFydGljbGUuZmluZE9uZSgpLnBvcHVsYXRlKCdjb21tZW50cy5hdXRob3InKTtcbiAqICAgICBkb2MuY29tbWVudHNbMF0ucG9wdWxhdGVkKCdhdXRob3InKTsgLy8gU2hvdWxkIGJlIHNldFxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHBhcmFtIHtPYmplY3R9IFtwb3B1bGF0ZWRdXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hcmtBcnJheVN1YmRvY3NQb3B1bGF0ZWQoZG9jLCBwb3B1bGF0ZWQpIHtcbiAgaWYgKGRvYy5faWQgPT0gbnVsbCB8fCBwb3B1bGF0ZWQgPT0gbnVsbCB8fCBwb3B1bGF0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaWQgPSBTdHJpbmcoZG9jLl9pZCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBwb3B1bGF0ZWQpIHtcbiAgICBpZiAoaXRlbS5pc1ZpcnR1YWwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gaXRlbS5wYXRoO1xuICAgIGNvbnN0IHBpZWNlcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGNvbnN0IHN1YnBhdGggPSBwaWVjZXMuc2xpY2UoMCwgaSArIDEpLmpvaW4oJy4nKTtcbiAgICAgIGNvbnN0IHJlc3QgPSBwaWVjZXMuc2xpY2UoaSArIDEpLmpvaW4oJy4nKTtcbiAgICAgIGNvbnN0IHZhbCA9IGRvYy5nZXQoc3VicGF0aCk7XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWwpKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaWYgKHZhbFtqXSkge1xuICAgICAgICAgICAgdmFsW2pdLnBvcHVsYXRlZChyZXN0LCBpdGVtLl9kb2NzW2lkXSA9PSBudWxsID8gdm9pZCAwIDogaXRlbS5fZG9jc1tpZF1bal0sIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst isPathExcluded = __webpack_require__(/*! ../projection/isPathExcluded */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js\");\nconst lookupLocalFields = __webpack_require__(/*! ./lookupLocalFields */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(api)/../server/node_modules/mpath/index.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nconst hasNumericPropRE = /(\\.\\d+$|\\.\\d+\\.)/g;\n\nmodule.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {\n  if (refPath == null) {\n    return [];\n  }\n\n  if (typeof refPath === 'string' && queryProjection != null && isPathExcluded(queryProjection, refPath)) {\n    throw new MongooseError('refPath `' + refPath + '` must not be excluded in projection, got ' +\n      util.inspect(queryProjection));\n  }\n\n  // If populated path has numerics, the end `refPath` should too. For example,\n  // if populating `a.0.b` instead of `a.b` and `b` has `refPath = a.c`, we\n  // should return `a.0.c` for the refPath.\n\n  if (hasNumericPropRE.test(populatedPath)) {\n    const chunks = populatedPath.split(hasNumericPropRE);\n\n    if (chunks[chunks.length - 1] === '') {\n      throw new Error('Can\\'t populate individual element in an array');\n    }\n\n    let _refPath = '';\n    let _remaining = refPath;\n    // 2nd, 4th, etc. will be numeric props. For example: `[ 'a', '.0.', 'b' ]`\n    for (let i = 0; i < chunks.length; i += 2) {\n      const chunk = chunks[i];\n      if (_remaining.startsWith(chunk + '.')) {\n        _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];\n        _remaining = _remaining.substring(chunk.length + 1);\n      } else if (i === chunks.length - 1) {\n        _refPath += _remaining;\n        _remaining = '';\n        break;\n      } else {\n        throw new Error('Could not normalize ref path, chunk ' + chunk + ' not in populated path');\n      }\n    }\n\n    const refValue = mpath.get(_refPath, doc, lookupLocalFields);\n    let modelNames = Array.isArray(refValue) ? refValue : [refValue];\n    modelNames = utils.array.flatten(modelNames);\n    return modelNames;\n  }\n\n  const refValue = mpath.get(refPath, doc, lookupLocalFields);\n\n  let modelNames;\n  if (modelSchema != null && modelSchema.virtuals.hasOwnProperty(refPath)) {\n    modelNames = [modelSchema.virtuals[refPath].applyGetters(void 0, doc)];\n  } else {\n    modelNames = Array.isArray(refValue) ? refValue : [refValue];\n  }\n\n  modelNames = utils.array.flatten(modelNames);\n\n  return modelNames;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9tb2RlbE5hbWVzRnJvbVJlZlBhdGguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsbUdBQTJCO0FBQ3pELHVCQUF1QixtQkFBTyxDQUFDLG9IQUE4QjtBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBcUI7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLDBEQUFPO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsdUVBQWE7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccG9wdWxhdGVcXG1vZGVsTmFtZXNGcm9tUmVmUGF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBpc1BhdGhFeGNsdWRlZCA9IHJlcXVpcmUoJy4uL3Byb2plY3Rpb24vaXNQYXRoRXhjbHVkZWQnKTtcbmNvbnN0IGxvb2t1cExvY2FsRmllbGRzID0gcmVxdWlyZSgnLi9sb29rdXBMb2NhbEZpZWxkcycpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuY29uc3QgaGFzTnVtZXJpY1Byb3BSRSA9IC8oXFwuXFxkKyR8XFwuXFxkK1xcLikvZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtb2RlbE5hbWVzRnJvbVJlZlBhdGgocmVmUGF0aCwgZG9jLCBwb3B1bGF0ZWRQYXRoLCBtb2RlbFNjaGVtYSwgcXVlcnlQcm9qZWN0aW9uKSB7XG4gIGlmIChyZWZQYXRoID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZlBhdGggPT09ICdzdHJpbmcnICYmIHF1ZXJ5UHJvamVjdGlvbiAhPSBudWxsICYmIGlzUGF0aEV4Y2x1ZGVkKHF1ZXJ5UHJvamVjdGlvbiwgcmVmUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcigncmVmUGF0aCBgJyArIHJlZlBhdGggKyAnYCBtdXN0IG5vdCBiZSBleGNsdWRlZCBpbiBwcm9qZWN0aW9uLCBnb3QgJyArXG4gICAgICB1dGlsLmluc3BlY3QocXVlcnlQcm9qZWN0aW9uKSk7XG4gIH1cblxuICAvLyBJZiBwb3B1bGF0ZWQgcGF0aCBoYXMgbnVtZXJpY3MsIHRoZSBlbmQgYHJlZlBhdGhgIHNob3VsZCB0b28uIEZvciBleGFtcGxlLFxuICAvLyBpZiBwb3B1bGF0aW5nIGBhLjAuYmAgaW5zdGVhZCBvZiBgYS5iYCBhbmQgYGJgIGhhcyBgcmVmUGF0aCA9IGEuY2AsIHdlXG4gIC8vIHNob3VsZCByZXR1cm4gYGEuMC5jYCBmb3IgdGhlIHJlZlBhdGguXG5cbiAgaWYgKGhhc051bWVyaWNQcm9wUkUudGVzdChwb3B1bGF0ZWRQYXRoKSkge1xuICAgIGNvbnN0IGNodW5rcyA9IHBvcHVsYXRlZFBhdGguc3BsaXQoaGFzTnVtZXJpY1Byb3BSRSk7XG5cbiAgICBpZiAoY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBwb3B1bGF0ZSBpbmRpdmlkdWFsIGVsZW1lbnQgaW4gYW4gYXJyYXknKTtcbiAgICB9XG5cbiAgICBsZXQgX3JlZlBhdGggPSAnJztcbiAgICBsZXQgX3JlbWFpbmluZyA9IHJlZlBhdGg7XG4gICAgLy8gMm5kLCA0dGgsIGV0Yy4gd2lsbCBiZSBudW1lcmljIHByb3BzLiBGb3IgZXhhbXBsZTogYFsgJ2EnLCAnLjAuJywgJ2InIF1gXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2ldO1xuICAgICAgaWYgKF9yZW1haW5pbmcuc3RhcnRzV2l0aChjaHVuayArICcuJykpIHtcbiAgICAgICAgX3JlZlBhdGggKz0gX3JlbWFpbmluZy5zdWJzdHJpbmcoMCwgY2h1bmsubGVuZ3RoKSArIGNodW5rc1tpICsgMV07XG4gICAgICAgIF9yZW1haW5pbmcgPSBfcmVtYWluaW5nLnN1YnN0cmluZyhjaHVuay5sZW5ndGggKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gY2h1bmtzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgX3JlZlBhdGggKz0gX3JlbWFpbmluZztcbiAgICAgICAgX3JlbWFpbmluZyA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IG5vcm1hbGl6ZSByZWYgcGF0aCwgY2h1bmsgJyArIGNodW5rICsgJyBub3QgaW4gcG9wdWxhdGVkIHBhdGgnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZWZWYWx1ZSA9IG1wYXRoLmdldChfcmVmUGF0aCwgZG9jLCBsb29rdXBMb2NhbEZpZWxkcyk7XG4gICAgbGV0IG1vZGVsTmFtZXMgPSBBcnJheS5pc0FycmF5KHJlZlZhbHVlKSA/IHJlZlZhbHVlIDogW3JlZlZhbHVlXTtcbiAgICBtb2RlbE5hbWVzID0gdXRpbHMuYXJyYXkuZmxhdHRlbihtb2RlbE5hbWVzKTtcbiAgICByZXR1cm4gbW9kZWxOYW1lcztcbiAgfVxuXG4gIGNvbnN0IHJlZlZhbHVlID0gbXBhdGguZ2V0KHJlZlBhdGgsIGRvYywgbG9va3VwTG9jYWxGaWVsZHMpO1xuXG4gIGxldCBtb2RlbE5hbWVzO1xuICBpZiAobW9kZWxTY2hlbWEgIT0gbnVsbCAmJiBtb2RlbFNjaGVtYS52aXJ0dWFscy5oYXNPd25Qcm9wZXJ0eShyZWZQYXRoKSkge1xuICAgIG1vZGVsTmFtZXMgPSBbbW9kZWxTY2hlbWEudmlydHVhbHNbcmVmUGF0aF0uYXBwbHlHZXR0ZXJzKHZvaWQgMCwgZG9jKV07XG4gIH0gZWxzZSB7XG4gICAgbW9kZWxOYW1lcyA9IEFycmF5LmlzQXJyYXkocmVmVmFsdWUpID8gcmVmVmFsdWUgOiBbcmVmVmFsdWVdO1xuICB9XG5cbiAgbW9kZWxOYW1lcyA9IHV0aWxzLmFycmF5LmZsYXR0ZW4obW9kZWxOYW1lcyk7XG5cbiAgcmV0dXJuIG1vZGVsTmFtZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js":
/*!********************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(api)/../server/node_modules/mpath/index.js\");\nconst parseProjection = __webpack_require__(/*! ../projection/parseProjection */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/parseProjection.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function removeDeselectedForeignField(foreignFields, options, docs) {\n  const projection = parseProjection(get(options, 'select', null), true) ||\n    parseProjection(get(options, 'options.select', null), true);\n\n  if (projection == null) {\n    return;\n  }\n  for (const foreignField of foreignFields) {\n    if (!projection.hasOwnProperty('-' + foreignField)) {\n      continue;\n    }\n\n    for (const val of docs) {\n      if (val.$__ != null) {\n        mpath.unset(foreignField, val._doc);\n      } else {\n        mpath.unset(foreignField, val);\n      }\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9yZW1vdmVEZXNlbGVjdGVkRm9yZWlnbkZpZWxkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx3RUFBUTtBQUM1QixjQUFjLG1CQUFPLENBQUMsMERBQU87QUFDN0Isd0JBQXdCLG1CQUFPLENBQUMsc0hBQStCOztBQUUvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccG9wdWxhdGVcXHJlbW92ZURlc2VsZWN0ZWRGb3JlaWduRmllbGQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IG1wYXRoID0gcmVxdWlyZSgnbXBhdGgnKTtcbmNvbnN0IHBhcnNlUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4uL3Byb2plY3Rpb24vcGFyc2VQcm9qZWN0aW9uJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZW1vdmVEZXNlbGVjdGVkRm9yZWlnbkZpZWxkKGZvcmVpZ25GaWVsZHMsIG9wdGlvbnMsIGRvY3MpIHtcbiAgY29uc3QgcHJvamVjdGlvbiA9IHBhcnNlUHJvamVjdGlvbihnZXQob3B0aW9ucywgJ3NlbGVjdCcsIG51bGwpLCB0cnVlKSB8fFxuICAgIHBhcnNlUHJvamVjdGlvbihnZXQob3B0aW9ucywgJ29wdGlvbnMuc2VsZWN0JywgbnVsbCksIHRydWUpO1xuXG4gIGlmIChwcm9qZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChjb25zdCBmb3JlaWduRmllbGQgb2YgZm9yZWlnbkZpZWxkcykge1xuICAgIGlmICghcHJvamVjdGlvbi5oYXNPd25Qcm9wZXJ0eSgnLScgKyBmb3JlaWduRmllbGQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBkb2NzKSB7XG4gICAgICBpZiAodmFsLiRfXyAhPSBudWxsKSB7XG4gICAgICAgIG1wYXRoLnVuc2V0KGZvcmVpZ25GaWVsZCwgdmFsLl9kb2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXBhdGgudW5zZXQoZm9yZWlnbkZpZWxkLCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/populate/validateRef.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/populate/validateRef.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nmodule.exports = validateRef;\n\nfunction validateRef(ref, path) {\n  if (typeof ref === 'string') {\n    return;\n  }\n\n  if (typeof ref === 'function') {\n    return;\n  }\n\n  throw new MongooseError('Invalid ref at path \"' + path + '\". Got ' +\n    util.inspect(ref, { depth: 0 }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS92YWxpZGF0ZVJlZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxtR0FBMkI7QUFDekQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHBvcHVsYXRlXFx2YWxpZGF0ZVJlZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlUmVmO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVJlZihyZWYsIHBhdGgpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignSW52YWxpZCByZWYgYXQgcGF0aCBcIicgKyBwYXRoICsgJ1wiLiBHb3QgJyArXG4gICAgdXRpbC5pbnNwZWN0KHJlZiwgeyBkZXB0aDogMCB9KSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/populate/validateRef.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/printJestWarning.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/printJestWarning.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nif (typeof jest !== 'undefined' && !process.env.SUPPRESS_JEST_WARNINGS) {\n  if (typeof window !== 'undefined') {\n    utils.warn('Mongoose: looks like you\\'re trying to test a Mongoose app ' +\n      'with Jest\\'s default jsdom test environment. Please make sure you read ' +\n      'Mongoose\\'s docs on configuring Jest to test Node.js apps: ' +\n      'https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true ' +\n      'to hide this warning.');\n  }\n\n  if (setTimeout.clock != null && typeof setTimeout.clock.Date === 'function') {\n    utils.warn('Mongoose: looks like you\\'re trying to test a Mongoose app ' +\n      'with Jest\\'s mock timers enabled. Please make sure you read ' +\n      'Mongoose\\'s docs on configuring Jest to test Node.js apps: ' +\n      'https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true ' +\n      'to hide this warning.');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcmludEplc3RXYXJuaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxvRUFBVTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccHJpbnRKZXN0V2FybmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuaWYgKHR5cGVvZiBqZXN0ICE9PSAndW5kZWZpbmVkJyAmJiAhcHJvY2Vzcy5lbnYuU1VQUFJFU1NfSkVTVF9XQVJOSU5HUykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB1dGlscy53YXJuKCdNb25nb29zZTogbG9va3MgbGlrZSB5b3VcXCdyZSB0cnlpbmcgdG8gdGVzdCBhIE1vbmdvb3NlIGFwcCAnICtcbiAgICAgICd3aXRoIEplc3RcXCdzIGRlZmF1bHQganNkb20gdGVzdCBlbnZpcm9ubWVudC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgcmVhZCAnICtcbiAgICAgICdNb25nb29zZVxcJ3MgZG9jcyBvbiBjb25maWd1cmluZyBKZXN0IHRvIHRlc3QgTm9kZS5qcyBhcHBzOiAnICtcbiAgICAgICdodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvamVzdC5odG1sLiBTZXQgdGhlIFNVUFBSRVNTX0pFU1RfV0FSTklOR1MgdG8gdHJ1ZSAnICtcbiAgICAgICd0byBoaWRlIHRoaXMgd2FybmluZy4nKTtcbiAgfVxuXG4gIGlmIChzZXRUaW1lb3V0LmNsb2NrICE9IG51bGwgJiYgdHlwZW9mIHNldFRpbWVvdXQuY2xvY2suRGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHV0aWxzLndhcm4oJ01vbmdvb3NlOiBsb29rcyBsaWtlIHlvdVxcJ3JlIHRyeWluZyB0byB0ZXN0IGEgTW9uZ29vc2UgYXBwICcgK1xuICAgICAgJ3dpdGggSmVzdFxcJ3MgbW9jayB0aW1lcnMgZW5hYmxlZC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgcmVhZCAnICtcbiAgICAgICdNb25nb29zZVxcJ3MgZG9jcyBvbiBjb25maWd1cmluZyBKZXN0IHRvIHRlc3QgTm9kZS5qcyBhcHBzOiAnICtcbiAgICAgICdodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvamVzdC5odG1sLiBTZXQgdGhlIFNVUFBSRVNTX0pFU1RfV0FSTklOR1MgdG8gdHJ1ZSAnICtcbiAgICAgICd0byBoaWRlIHRoaXMgd2FybmluZy4nKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/printJestWarning.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/processConnectionOptions.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/processConnectionOptions.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ./clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\n\nfunction processConnectionOptions(uri, options) {\n  const opts = options ? options : {};\n  const readPreference = opts.readPreference\n    ? opts.readPreference\n    : getUriReadPreference(uri);\n\n  const clonedOpts = clone(opts);\n  const resolvedOpts = (readPreference && readPreference !== 'primary' && readPreference !== 'primaryPreferred')\n    ? resolveOptsConflicts(readPreference, clonedOpts)\n    : clonedOpts;\n\n  return resolvedOpts;\n}\n\nfunction resolveOptsConflicts(pref, opts) {\n  // don't silently override user-provided indexing options\n  if (setsIndexOptions(opts) && setsSecondaryRead(pref)) {\n    throwReadPreferenceError();\n  }\n\n  // if user has not explicitly set any auto-indexing options,\n  // we can silently default them all to false\n  else {\n    return defaultIndexOptsToFalse(opts);\n  }\n}\n\nfunction setsIndexOptions(opts) {\n  const configIdx = opts.config && opts.config.autoIndex;\n  const { autoCreate, autoIndex } = opts;\n  return !!(configIdx || autoCreate || autoIndex);\n}\n\nfunction setsSecondaryRead(prefString) {\n  return !!(prefString === 'secondary' || prefString === 'secondaryPreferred');\n}\n\nfunction getUriReadPreference(connectionString) {\n  const exp = /(?:&|\\?)readPreference=(\\w+)(?:&|$)/;\n  const match = exp.exec(connectionString);\n  return match ? match[1] : null;\n}\n\nfunction defaultIndexOptsToFalse(opts) {\n  opts.config = { autoIndex: false };\n  opts.autoCreate = false;\n  opts.autoIndex = false;\n  return opts;\n}\n\nfunction throwReadPreferenceError() {\n  throw new MongooseError(\n    'MongoDB prohibits index creation on connections that read from ' +\n            'non-primary replicas.  Connections that set \"readPreference\" to \"secondary\" or ' +\n            '\"secondaryPreferred\" may not opt-in to the following connection options: ' +\n            'autoCreate, autoIndex'\n  );\n}\n\nmodule.exports = processConnectionOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9jZXNzQ29ubmVjdGlvbk9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLDJFQUFTO0FBQy9CLHNCQUFzQixtQkFBTyxDQUFDLGdGQUFnQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxwcm9jZXNzQ29ubmVjdGlvbk9wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9pbmRleCcpO1xuXG5mdW5jdGlvbiBwcm9jZXNzQ29ubmVjdGlvbk9wdGlvbnModXJpLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuICBjb25zdCByZWFkUHJlZmVyZW5jZSA9IG9wdHMucmVhZFByZWZlcmVuY2VcbiAgICA/IG9wdHMucmVhZFByZWZlcmVuY2VcbiAgICA6IGdldFVyaVJlYWRQcmVmZXJlbmNlKHVyaSk7XG5cbiAgY29uc3QgY2xvbmVkT3B0cyA9IGNsb25lKG9wdHMpO1xuICBjb25zdCByZXNvbHZlZE9wdHMgPSAocmVhZFByZWZlcmVuY2UgJiYgcmVhZFByZWZlcmVuY2UgIT09ICdwcmltYXJ5JyAmJiByZWFkUHJlZmVyZW5jZSAhPT0gJ3ByaW1hcnlQcmVmZXJyZWQnKVxuICAgID8gcmVzb2x2ZU9wdHNDb25mbGljdHMocmVhZFByZWZlcmVuY2UsIGNsb25lZE9wdHMpXG4gICAgOiBjbG9uZWRPcHRzO1xuXG4gIHJldHVybiByZXNvbHZlZE9wdHM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVPcHRzQ29uZmxpY3RzKHByZWYsIG9wdHMpIHtcbiAgLy8gZG9uJ3Qgc2lsZW50bHkgb3ZlcnJpZGUgdXNlci1wcm92aWRlZCBpbmRleGluZyBvcHRpb25zXG4gIGlmIChzZXRzSW5kZXhPcHRpb25zKG9wdHMpICYmIHNldHNTZWNvbmRhcnlSZWFkKHByZWYpKSB7XG4gICAgdGhyb3dSZWFkUHJlZmVyZW5jZUVycm9yKCk7XG4gIH1cblxuICAvLyBpZiB1c2VyIGhhcyBub3QgZXhwbGljaXRseSBzZXQgYW55IGF1dG8taW5kZXhpbmcgb3B0aW9ucyxcbiAgLy8gd2UgY2FuIHNpbGVudGx5IGRlZmF1bHQgdGhlbSBhbGwgdG8gZmFsc2VcbiAgZWxzZSB7XG4gICAgcmV0dXJuIGRlZmF1bHRJbmRleE9wdHNUb0ZhbHNlKG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldHNJbmRleE9wdGlvbnMob3B0cykge1xuICBjb25zdCBjb25maWdJZHggPSBvcHRzLmNvbmZpZyAmJiBvcHRzLmNvbmZpZy5hdXRvSW5kZXg7XG4gIGNvbnN0IHsgYXV0b0NyZWF0ZSwgYXV0b0luZGV4IH0gPSBvcHRzO1xuICByZXR1cm4gISEoY29uZmlnSWR4IHx8IGF1dG9DcmVhdGUgfHwgYXV0b0luZGV4KTtcbn1cblxuZnVuY3Rpb24gc2V0c1NlY29uZGFyeVJlYWQocHJlZlN0cmluZykge1xuICByZXR1cm4gISEocHJlZlN0cmluZyA9PT0gJ3NlY29uZGFyeScgfHwgcHJlZlN0cmluZyA9PT0gJ3NlY29uZGFyeVByZWZlcnJlZCcpO1xufVxuXG5mdW5jdGlvbiBnZXRVcmlSZWFkUHJlZmVyZW5jZShjb25uZWN0aW9uU3RyaW5nKSB7XG4gIGNvbnN0IGV4cCA9IC8oPzomfFxcPylyZWFkUHJlZmVyZW5jZT0oXFx3KykoPzomfCQpLztcbiAgY29uc3QgbWF0Y2ggPSBleHAuZXhlYyhjb25uZWN0aW9uU3RyaW5nKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0SW5kZXhPcHRzVG9GYWxzZShvcHRzKSB7XG4gIG9wdHMuY29uZmlnID0geyBhdXRvSW5kZXg6IGZhbHNlIH07XG4gIG9wdHMuYXV0b0NyZWF0ZSA9IGZhbHNlO1xuICBvcHRzLmF1dG9JbmRleCA9IGZhbHNlO1xuICByZXR1cm4gb3B0cztcbn1cblxuZnVuY3Rpb24gdGhyb3dSZWFkUHJlZmVyZW5jZUVycm9yKCkge1xuICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihcbiAgICAnTW9uZ29EQiBwcm9oaWJpdHMgaW5kZXggY3JlYXRpb24gb24gY29ubmVjdGlvbnMgdGhhdCByZWFkIGZyb20gJyArXG4gICAgICAgICAgICAnbm9uLXByaW1hcnkgcmVwbGljYXMuICBDb25uZWN0aW9ucyB0aGF0IHNldCBcInJlYWRQcmVmZXJlbmNlXCIgdG8gXCJzZWNvbmRhcnlcIiBvciAnICtcbiAgICAgICAgICAgICdcInNlY29uZGFyeVByZWZlcnJlZFwiIG1heSBub3Qgb3B0LWluIHRvIHRoZSBmb2xsb3dpbmcgY29ubmVjdGlvbiBvcHRpb25zOiAnICtcbiAgICAgICAgICAgICdhdXRvQ3JlYXRlLCBhdXRvSW5kZXgnXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc0Nvbm5lY3Rpb25PcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/processConnectionOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/projection/applyProjection.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/applyProjection.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst hasIncludedChildren = __webpack_require__(/*! ./hasIncludedChildren */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js\");\nconst isExclusive = __webpack_require__(/*! ./isExclusive */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst isInclusive = __webpack_require__(/*! ./isInclusive */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isInclusive.js\");\nconst isPOJO = (__webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\").isPOJO);\n\nmodule.exports = function applyProjection(doc, projection, _hasIncludedChildren) {\n  if (projection == null) {\n    return doc;\n  }\n  if (doc == null) {\n    return doc;\n  }\n\n  let exclude = null;\n  if (isInclusive(projection)) {\n    exclude = false;\n  } else if (isExclusive(projection)) {\n    exclude = true;\n  }\n\n  if (exclude == null) {\n    return doc;\n  } else if (exclude) {\n    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);\n    return applyExclusiveProjection(doc, projection, _hasIncludedChildren);\n  } else {\n    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);\n    return applyInclusiveProjection(doc, projection, _hasIncludedChildren);\n  }\n};\n\nfunction applyExclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {\n  if (doc == null || typeof doc !== 'object') {\n    return doc;\n  }\n  const ret = { ...doc };\n  projectionLimb = prefix ? (projectionLimb || {}) : projection;\n\n  for (const key of Object.keys(ret)) {\n    const fullPath = prefix ? prefix + '.' + key : key;\n    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {\n      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {\n        ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n      } else {\n        delete ret[key];\n      }\n    } else if (hasIncludedChildren[fullPath]) {\n      ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n    }\n  }\n  return ret;\n}\n\nfunction applyInclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {\n  if (doc == null || typeof doc !== 'object') {\n    return doc;\n  }\n  const ret = { ...doc };\n  projectionLimb = prefix ? (projectionLimb || {}) : projection;\n\n  for (const key of Object.keys(ret)) {\n    const fullPath = prefix ? prefix + '.' + key : key;\n    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {\n      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {\n        ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n      }\n      continue;\n    } else if (hasIncludedChildren[fullPath]) {\n      ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n    } else {\n      delete ret[key];\n    }\n  }\n  return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2FwcGx5UHJvamVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw0QkFBNEIsbUJBQU8sQ0FBQyxrSEFBdUI7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsa0dBQWU7QUFDM0Msb0JBQW9CLG1CQUFPLENBQUMsa0dBQWU7QUFDM0MsZUFBZSxxR0FBNkI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHByb2plY3Rpb25cXGFwcGx5UHJvamVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGhhc0luY2x1ZGVkQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2hhc0luY2x1ZGVkQ2hpbGRyZW4nKTtcbmNvbnN0IGlzRXhjbHVzaXZlID0gcmVxdWlyZSgnLi9pc0V4Y2x1c2l2ZScpO1xuY29uc3QgaXNJbmNsdXNpdmUgPSByZXF1aXJlKCcuL2lzSW5jbHVzaXZlJyk7XG5jb25zdCBpc1BPSk8gPSByZXF1aXJlKCcuLi8uLi91dGlscycpLmlzUE9KTztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBseVByb2plY3Rpb24oZG9jLCBwcm9qZWN0aW9uLCBfaGFzSW5jbHVkZWRDaGlsZHJlbikge1xuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGRvYztcbiAgfVxuICBpZiAoZG9jID09IG51bGwpIHtcbiAgICByZXR1cm4gZG9jO1xuICB9XG5cbiAgbGV0IGV4Y2x1ZGUgPSBudWxsO1xuICBpZiAoaXNJbmNsdXNpdmUocHJvamVjdGlvbikpIHtcbiAgICBleGNsdWRlID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNFeGNsdXNpdmUocHJvamVjdGlvbikpIHtcbiAgICBleGNsdWRlID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChleGNsdWRlID09IG51bGwpIHtcbiAgICByZXR1cm4gZG9jO1xuICB9IGVsc2UgaWYgKGV4Y2x1ZGUpIHtcbiAgICBfaGFzSW5jbHVkZWRDaGlsZHJlbiA9IF9oYXNJbmNsdWRlZENoaWxkcmVuIHx8IGhhc0luY2x1ZGVkQ2hpbGRyZW4ocHJvamVjdGlvbik7XG4gICAgcmV0dXJuIGFwcGx5RXhjbHVzaXZlUHJvamVjdGlvbihkb2MsIHByb2plY3Rpb24sIF9oYXNJbmNsdWRlZENoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICBfaGFzSW5jbHVkZWRDaGlsZHJlbiA9IF9oYXNJbmNsdWRlZENoaWxkcmVuIHx8IGhhc0luY2x1ZGVkQ2hpbGRyZW4ocHJvamVjdGlvbik7XG4gICAgcmV0dXJuIGFwcGx5SW5jbHVzaXZlUHJvamVjdGlvbihkb2MsIHByb2plY3Rpb24sIF9oYXNJbmNsdWRlZENoaWxkcmVuKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXBwbHlFeGNsdXNpdmVQcm9qZWN0aW9uKGRvYywgcHJvamVjdGlvbiwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgcHJvamVjdGlvbkxpbWIsIHByZWZpeCkge1xuICBpZiAoZG9jID09IG51bGwgfHwgdHlwZW9mIGRvYyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZG9jO1xuICB9XG4gIGNvbnN0IHJldCA9IHsgLi4uZG9jIH07XG4gIHByb2plY3Rpb25MaW1iID0gcHJlZml4ID8gKHByb2plY3Rpb25MaW1iIHx8IHt9KSA6IHByb2plY3Rpb247XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmV0KSkge1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gcHJlZml4ID8gcHJlZml4ICsgJy4nICsga2V5IDoga2V5O1xuICAgIGlmIChwcm9qZWN0aW9uLmhhc093blByb3BlcnR5KGZ1bGxQYXRoKSB8fCBwcm9qZWN0aW9uTGltYi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBpZiAoaXNQT0pPKHByb2plY3Rpb25bZnVsbFBhdGhdKSB8fCBpc1BPSk8ocHJvamVjdGlvbkxpbWJba2V5XSkpIHtcbiAgICAgICAgcmV0W2tleV0gPSBhcHBseUV4Y2x1c2l2ZVByb2plY3Rpb24ocmV0W2tleV0sIHByb2plY3Rpb24sIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIHByb2plY3Rpb25MaW1iW2tleV0sIGZ1bGxQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSByZXRba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc0luY2x1ZGVkQ2hpbGRyZW5bZnVsbFBhdGhdKSB7XG4gICAgICByZXRba2V5XSA9IGFwcGx5RXhjbHVzaXZlUHJvamVjdGlvbihyZXRba2V5XSwgcHJvamVjdGlvbiwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgcHJvamVjdGlvbkxpbWJba2V5XSwgZnVsbFBhdGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBhcHBseUluY2x1c2l2ZVByb2plY3Rpb24oZG9jLCBwcm9qZWN0aW9uLCBoYXNJbmNsdWRlZENoaWxkcmVuLCBwcm9qZWN0aW9uTGltYiwgcHJlZml4KSB7XG4gIGlmIChkb2MgPT0gbnVsbCB8fCB0eXBlb2YgZG9jICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBkb2M7XG4gIH1cbiAgY29uc3QgcmV0ID0geyAuLi5kb2MgfTtcbiAgcHJvamVjdGlvbkxpbWIgPSBwcmVmaXggPyAocHJvamVjdGlvbkxpbWIgfHwge30pIDogcHJvamVjdGlvbjtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyZXQpKSB7XG4gICAgY29uc3QgZnVsbFBhdGggPSBwcmVmaXggPyBwcmVmaXggKyAnLicgKyBrZXkgOiBrZXk7XG4gICAgaWYgKHByb2plY3Rpb24uaGFzT3duUHJvcGVydHkoZnVsbFBhdGgpIHx8IHByb2plY3Rpb25MaW1iLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGlmIChpc1BPSk8ocHJvamVjdGlvbltmdWxsUGF0aF0pIHx8IGlzUE9KTyhwcm9qZWN0aW9uTGltYltrZXldKSkge1xuICAgICAgICByZXRba2V5XSA9IGFwcGx5SW5jbHVzaXZlUHJvamVjdGlvbihyZXRba2V5XSwgcHJvamVjdGlvbiwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgcHJvamVjdGlvbkxpbWJba2V5XSwgZnVsbFBhdGgpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChoYXNJbmNsdWRlZENoaWxkcmVuW2Z1bGxQYXRoXSkge1xuICAgICAgcmV0W2tleV0gPSBhcHBseUluY2x1c2l2ZVByb2plY3Rpb24ocmV0W2tleV0sIHByb2plY3Rpb24sIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIHByb2plY3Rpb25MaW1iW2tleV0sIGZ1bGxQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHJldFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/projection/applyProjection.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js ***!
  \*************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Creates an object that precomputes whether a given path has child fields in\n * the projection.\n *\n * #### Example:\n *\n *     const res = hasIncludedChildren({ 'a.b.c': 0 });\n *     res.a; // 1\n *     res['a.b']; // 1\n *     res['a.b.c']; // 1\n *     res['a.c']; // undefined\n *\n * @param {Object} fields\n * @api private\n */\n\nmodule.exports = function hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n\n  for (const key of keys) {\n\n    if (key.indexOf('.') === -1) {\n      hasIncludedChildren[key] = 1;\n      continue;\n    }\n    const parts = key.split('.');\n    let c = parts[0];\n\n    for (let i = 0; i < parts.length; ++i) {\n      hasIncludedChildren[c] = 1;\n      if (i + 1 < parts.length) {\n        c = c + '.' + parts[i + 1];\n      }\n    }\n  }\n\n  return hasIncludedChildren;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2hhc0luY2x1ZGVkQ2hpbGRyZW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQsY0FBYztBQUNkLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccHJvamVjdGlvblxcaGFzSW5jbHVkZWRDaGlsZHJlbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBwcmVjb21wdXRlcyB3aGV0aGVyIGEgZ2l2ZW4gcGF0aCBoYXMgY2hpbGQgZmllbGRzIGluXG4gKiB0aGUgcHJvamVjdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGhhc0luY2x1ZGVkQ2hpbGRyZW4oeyAnYS5iLmMnOiAwIH0pO1xuICogICAgIHJlcy5hOyAvLyAxXG4gKiAgICAgcmVzWydhLmInXTsgLy8gMVxuICogICAgIHJlc1snYS5iLmMnXTsgLy8gMVxuICogICAgIHJlc1snYS5jJ107IC8vIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzSW5jbHVkZWRDaGlsZHJlbihmaWVsZHMpIHtcbiAgY29uc3QgaGFzSW5jbHVkZWRDaGlsZHJlbiA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG5cbiAgICBpZiAoa2V5LmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICAgIGhhc0luY2x1ZGVkQ2hpbGRyZW5ba2V5XSA9IDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICBsZXQgYyA9IHBhcnRzWzBdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgaGFzSW5jbHVkZWRDaGlsZHJlbltjXSA9IDE7XG4gICAgICBpZiAoaSArIDEgPCBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgYyA9IGMgKyAnLicgKyBwYXJ0c1tpICsgMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhc0luY2x1ZGVkQ2hpbGRyZW47XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js":
/*!**************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function isDefiningProjection(val) {\n  if (val == null) {\n    // `undefined` or `null` become exclusive projections\n    return true;\n  }\n  if (typeof val === 'object') {\n    // Only cases where a value does **not** define whether the whole projection\n    // is inclusive or exclusive are `$meta` and `$slice`.\n    return !('$meta' in val) && !('$slice' in val);\n  }\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzRGVmaW5pbmdQcm9qZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxwcm9qZWN0aW9uXFxpc0RlZmluaW5nUHJvamVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RlZmluaW5nUHJvamVjdGlvbih2YWwpIHtcbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgLy8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGJlY29tZSBleGNsdXNpdmUgcHJvamVjdGlvbnNcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBPbmx5IGNhc2VzIHdoZXJlIGEgdmFsdWUgZG9lcyAqKm5vdCoqIGRlZmluZSB3aGV0aGVyIHRoZSB3aG9sZSBwcm9qZWN0aW9uXG4gICAgLy8gaXMgaW5jbHVzaXZlIG9yIGV4Y2x1c2l2ZSBhcmUgYCRtZXRhYCBhbmQgYCRzbGljZWAuXG4gICAgcmV0dXJuICEoJyRtZXRhJyBpbiB2YWwpICYmICEoJyRzbGljZScgaW4gdmFsKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js":
/*!*****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isDefiningProjection = __webpack_require__(/*! ./isDefiningProjection */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\nconst isPOJO = __webpack_require__(/*! ../isPOJO */ \"(api)/../server/node_modules/mongoose/lib/helpers/isPOJO.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function isExclusive(projection) {\n  if (projection == null) {\n    return null;\n  }\n\n  const keys = Object.keys(projection);\n  let exclude = null;\n\n  if (keys.length === 1 && keys[0] === '_id') {\n    exclude = !projection._id;\n  } else {\n    for (let ki = 0; ki < keys.length; ++ki) {\n      // Does this projection explicitly define inclusion/exclusion?\n      // Explicitly avoid `$meta` and `$slice`\n      const key = keys[ki];\n      if (key !== '_id' && isDefiningProjection(projection[key])) {\n        exclude = isPOJO(projection[key]) ?\n          (isExclusive(projection[key]) ?? exclude) :\n          !projection[key];\n        if (exclude != null) {\n          break;\n        }\n      }\n    }\n  }\n\n  return exclude;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzRXhjbHVzaXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLG9IQUF3QjtBQUM3RCxlQUFlLG1CQUFPLENBQUMsOEVBQVc7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccHJvamVjdGlvblxcaXNFeGNsdXNpdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc0RlZmluaW5nUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4vaXNEZWZpbmluZ1Byb2plY3Rpb24nKTtcbmNvbnN0IGlzUE9KTyA9IHJlcXVpcmUoJy4uL2lzUE9KTycpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNFeGNsdXNpdmUocHJvamVjdGlvbikge1xuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvamVjdGlvbik7XG4gIGxldCBleGNsdWRlID0gbnVsbDtcblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ19pZCcpIHtcbiAgICBleGNsdWRlID0gIXByb2plY3Rpb24uX2lkO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGtpID0gMDsga2kgPCBrZXlzLmxlbmd0aDsgKytraSkge1xuICAgICAgLy8gRG9lcyB0aGlzIHByb2plY3Rpb24gZXhwbGljaXRseSBkZWZpbmUgaW5jbHVzaW9uL2V4Y2x1c2lvbj9cbiAgICAgIC8vIEV4cGxpY2l0bHkgYXZvaWQgYCRtZXRhYCBhbmQgYCRzbGljZWBcbiAgICAgIGNvbnN0IGtleSA9IGtleXNba2ldO1xuICAgICAgaWYgKGtleSAhPT0gJ19pZCcgJiYgaXNEZWZpbmluZ1Byb2plY3Rpb24ocHJvamVjdGlvbltrZXldKSkge1xuICAgICAgICBleGNsdWRlID0gaXNQT0pPKHByb2plY3Rpb25ba2V5XSkgP1xuICAgICAgICAgIChpc0V4Y2x1c2l2ZShwcm9qZWN0aW9uW2tleV0pID8/IGV4Y2x1ZGUpIDpcbiAgICAgICAgICAhcHJvamVjdGlvbltrZXldO1xuICAgICAgICBpZiAoZXhjbHVkZSAhPSBudWxsKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhjbHVkZTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/projection/isInclusive.js":
/*!*****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isInclusive.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isDefiningProjection = __webpack_require__(/*! ./isDefiningProjection */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\nconst isPOJO = __webpack_require__(/*! ../isPOJO */ \"(api)/../server/node_modules/mongoose/lib/helpers/isPOJO.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function isInclusive(projection) {\n  if (projection == null) {\n    return false;\n  }\n\n  const props = Object.keys(projection);\n  const numProps = props.length;\n  if (numProps === 0) {\n    return false;\n  }\n\n  for (let i = 0; i < numProps; ++i) {\n    const prop = props[i];\n    // Plus paths can't define the projection (see gh-7050)\n    if (prop.startsWith('+')) {\n      continue;\n    }\n    // If field is truthy (1, true, etc.) and not an object, then this\n    // projection must be inclusive. If object, assume its $meta, $slice, etc.\n    if (isDefiningProjection(projection[prop]) && !!projection[prop]) {\n      if (isPOJO(projection[prop])) {\n        return isInclusive(projection[prop]);\n      } else {\n        return !!projection[prop];\n      }\n    }\n  }\n\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzSW5jbHVzaXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLG9IQUF3QjtBQUM3RCxlQUFlLG1CQUFPLENBQUMsOEVBQVc7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxwcm9qZWN0aW9uXFxpc0luY2x1c2l2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzRGVmaW5pbmdQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9pc0RlZmluaW5nUHJvamVjdGlvbicpO1xuY29uc3QgaXNQT0pPID0gcmVxdWlyZSgnLi4vaXNQT0pPJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0luY2x1c2l2ZShwcm9qZWN0aW9uKSB7XG4gIGlmIChwcm9qZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHByb2plY3Rpb24pO1xuICBjb25zdCBudW1Qcm9wcyA9IHByb3BzLmxlbmd0aDtcbiAgaWYgKG51bVByb3BzID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qcm9wczsgKytpKSB7XG4gICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgIC8vIFBsdXMgcGF0aHMgY2FuJ3QgZGVmaW5lIHRoZSBwcm9qZWN0aW9uIChzZWUgZ2gtNzA1MClcbiAgICBpZiAocHJvcC5zdGFydHNXaXRoKCcrJykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBJZiBmaWVsZCBpcyB0cnV0aHkgKDEsIHRydWUsIGV0Yy4pIGFuZCBub3QgYW4gb2JqZWN0LCB0aGVuIHRoaXNcbiAgICAvLyBwcm9qZWN0aW9uIG11c3QgYmUgaW5jbHVzaXZlLiBJZiBvYmplY3QsIGFzc3VtZSBpdHMgJG1ldGEsICRzbGljZSwgZXRjLlxuICAgIGlmIChpc0RlZmluaW5nUHJvamVjdGlvbihwcm9qZWN0aW9uW3Byb3BdKSAmJiAhIXByb2plY3Rpb25bcHJvcF0pIHtcbiAgICAgIGlmIChpc1BPSk8ocHJvamVjdGlvbltwcm9wXSkpIHtcbiAgICAgICAgcmV0dXJuIGlzSW5jbHVzaXZlKHByb2plY3Rpb25bcHJvcF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICEhcHJvamVjdGlvbltwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/projection/isInclusive.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js":
/*!************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isNestedProjection(val) {\n  if (val == null || typeof val !== 'object') {\n    return false;\n  }\n  return val.$slice == null && val.$elemMatch == null && val.$meta == null && val.$ == null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzTmVzdGVkUHJvamVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxwcm9qZWN0aW9uXFxpc05lc3RlZFByb2plY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzTmVzdGVkUHJvamVjdGlvbih2YWwpIHtcbiAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWwuJHNsaWNlID09IG51bGwgJiYgdmFsLiRlbGVtTWF0Y2ggPT0gbnVsbCAmJiB2YWwuJG1ldGEgPT0gbnVsbCAmJiB2YWwuJCA9PSBudWxsO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js":
/*!********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isDefiningProjection = __webpack_require__(/*! ./isDefiningProjection */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\n\n/**\n * Determines if `path` is excluded by `projection`\n *\n * @param {Object} projection\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nmodule.exports = function isPathExcluded(projection, path) {\n  if (projection == null) {\n    return false;\n  }\n\n  if (path === '_id') {\n    return projection._id === 0;\n  }\n\n  const paths = Object.keys(projection);\n  let type = null;\n\n  for (const _path of paths) {\n    if (isDefiningProjection(projection[_path])) {\n      type = projection[path] === 1 ? 'inclusive' : 'exclusive';\n      break;\n    }\n  }\n\n  if (type === 'inclusive') {\n    return projection[path] !== 1;\n  }\n  if (type === 'exclusive') {\n    return projection[path] === 0;\n  }\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzUGF0aEV4Y2x1ZGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLG9IQUF3Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHByb2plY3Rpb25cXGlzUGF0aEV4Y2x1ZGVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNEZWZpbmluZ1Byb2plY3Rpb24gPSByZXF1aXJlKCcuL2lzRGVmaW5pbmdQcm9qZWN0aW9uJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgcGF0aGAgaXMgZXhjbHVkZWQgYnkgYHByb2plY3Rpb25gXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb2plY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1BhdGhFeGNsdWRlZChwcm9qZWN0aW9uLCBwYXRoKSB7XG4gIGlmIChwcm9qZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocGF0aCA9PT0gJ19pZCcpIHtcbiAgICByZXR1cm4gcHJvamVjdGlvbi5faWQgPT09IDA7XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHByb2plY3Rpb24pO1xuICBsZXQgdHlwZSA9IG51bGw7XG5cbiAgZm9yIChjb25zdCBfcGF0aCBvZiBwYXRocykge1xuICAgIGlmIChpc0RlZmluaW5nUHJvamVjdGlvbihwcm9qZWN0aW9uW19wYXRoXSkpIHtcbiAgICAgIHR5cGUgPSBwcm9qZWN0aW9uW3BhdGhdID09PSAxID8gJ2luY2x1c2l2ZScgOiAnZXhjbHVzaXZlJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSAnaW5jbHVzaXZlJykge1xuICAgIHJldHVybiBwcm9qZWN0aW9uW3BhdGhdICE9PSAxO1xuICB9XG4gIGlmICh0eXBlID09PSAnZXhjbHVzaXZlJykge1xuICAgIHJldHVybiBwcm9qZWN0aW9uW3BhdGhdID09PSAwO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js":
/*!*****************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js ***!
  \*****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function isPathSelectedInclusive(fields, path) {\n  const chunks = path.split('.');\n  let cur = '';\n  let j;\n  let keys;\n  let numKeys;\n  for (let i = 0; i < chunks.length; ++i) {\n    cur += cur.length ? '.' : '' + chunks[i];\n    if (fields[cur]) {\n      keys = Object.keys(fields);\n      numKeys = keys.length;\n      for (j = 0; j < numKeys; ++j) {\n        if (keys[i].indexOf(cur + '.') === 0 && keys[i].indexOf(path) !== 0) {\n          continue;\n        }\n      }\n      return true;\n    }\n  }\n\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzUGF0aFNlbGVjdGVkSW5jbHVzaXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHByb2plY3Rpb25cXGlzUGF0aFNlbGVjdGVkSW5jbHVzaXZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUGF0aFNlbGVjdGVkSW5jbHVzaXZlKGZpZWxkcywgcGF0aCkge1xuICBjb25zdCBjaHVua3MgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGxldCBjdXIgPSAnJztcbiAgbGV0IGo7XG4gIGxldCBrZXlzO1xuICBsZXQgbnVtS2V5cztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICBjdXIgKz0gY3VyLmxlbmd0aCA/ICcuJyA6ICcnICsgY2h1bmtzW2ldO1xuICAgIGlmIChmaWVsZHNbY3VyXSkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkcyk7XG4gICAgICBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbnVtS2V5czsgKytqKSB7XG4gICAgICAgIGlmIChrZXlzW2ldLmluZGV4T2YoY3VyICsgJy4nKSA9PT0gMCAmJiBrZXlzW2ldLmluZGV4T2YocGF0aCkgIT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/projection/isSubpath.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/isSubpath.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines if `path2` is a subpath of or equal to `path1`\n *\n * @param {string} path1\n * @param {string} path2\n * @return {Boolean}\n * @api private\n */\n\nmodule.exports = function isSubpath(path1, path2) {\n  return path1 === path2 || path2.startsWith(path1 + '.');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzU3VicGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHByb2plY3Rpb25cXGlzU3VicGF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgcGF0aDJgIGlzIGEgc3VicGF0aCBvZiBvciBlcXVhbCB0byBgcGF0aDFgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGgxXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aDJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU3VicGF0aChwYXRoMSwgcGF0aDIpIHtcbiAgcmV0dXJuIHBhdGgxID09PSBwYXRoMiB8fCBwYXRoMi5zdGFydHNXaXRoKHBhdGgxICsgJy4nKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/projection/isSubpath.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/projection/parseProjection.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/projection/parseProjection.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Convert a string or array into a projection object, retaining all\n * `-` and `+` paths.\n */\n\nmodule.exports = function parseProjection(v, retainMinusPaths) {\n  const type = typeof v;\n\n  if (type === 'string') {\n    v = v.split(/\\s+/);\n  }\n  if (!Array.isArray(v) && Object.prototype.toString.call(v) !== '[object Arguments]') {\n    return v;\n  }\n\n  const len = v.length;\n  const ret = {};\n  for (let i = 0; i < len; ++i) {\n    let field = v[i];\n    if (!field) {\n      continue;\n    }\n    const include = '-' == field[0] ? 0 : 1;\n    if (!retainMinusPaths && include === 0) {\n      field = field.substring(1);\n    }\n    ret[field] = include;\n  }\n\n  return ret;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL3BhcnNlUHJvamVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHByb2plY3Rpb25cXHBhcnNlUHJvamVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyBvciBhcnJheSBpbnRvIGEgcHJvamVjdGlvbiBvYmplY3QsIHJldGFpbmluZyBhbGxcbiAqIGAtYCBhbmQgYCtgIHBhdGhzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VQcm9qZWN0aW9uKHYsIHJldGFpbk1pbnVzUGF0aHMpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2O1xuXG4gIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHYgPSB2LnNwbGl0KC9cXHMrLyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHYpICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSAhPT0gJ1tvYmplY3QgQXJndW1lbnRzXScpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHYubGVuZ3RoO1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGxldCBmaWVsZCA9IHZbaV07XG4gICAgaWYgKCFmaWVsZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGluY2x1ZGUgPSAnLScgPT0gZmllbGRbMF0gPyAwIDogMTtcbiAgICBpZiAoIXJldGFpbk1pbnVzUGF0aHMgJiYgaW5jbHVkZSA9PT0gMCkge1xuICAgICAgZmllbGQgPSBmaWVsZC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHJldFtmaWVsZF0gPSBpbmNsdWRlO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/projection/parseProjection.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/promiseOrCallback.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/promiseOrCallback.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst immediate = __webpack_require__(/*! ./immediate */ \"(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\");\n\nconst emittedSymbol = Symbol('mongoose:emitted');\n\nmodule.exports = function promiseOrCallback(callback, fn, ee, Promise) {\n  if (typeof callback === 'function') {\n    try {\n      return fn(function(error) {\n        if (error != null) {\n          if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n            error[emittedSymbol] = true;\n            ee.emit('error', error);\n          }\n          try {\n            callback(error);\n          } catch (error) {\n            return immediate(() => {\n              throw error;\n            });\n          }\n          return;\n        }\n        callback.apply(this, arguments);\n      });\n    } catch (error) {\n      if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n        error[emittedSymbol] = true;\n        ee.emit('error', error);\n      }\n\n      return callback(error);\n    }\n  }\n\n  Promise = Promise || global.Promise;\n\n  return new Promise((resolve, reject) => {\n    fn(function(error, res) {\n      if (error != null) {\n        if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n          error[emittedSymbol] = true;\n          ee.emit('error', error);\n        }\n        return reject(error);\n      }\n      if (arguments.length > 2) {\n        return resolve(Array.prototype.slice.call(arguments, 1));\n      }\n      resolve(res);\n    });\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9taXNlT3JDYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBYTs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccHJvbWlzZU9yQ2FsbGJhY2suanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbW1lZGlhdGUgPSByZXF1aXJlKCcuL2ltbWVkaWF0ZScpO1xuXG5jb25zdCBlbWl0dGVkU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZTplbWl0dGVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJvbWlzZU9yQ2FsbGJhY2soY2FsbGJhY2ssIGZuLCBlZSwgUHJvbWlzZSkge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChlZSAhPSBudWxsICYmIGVlLmxpc3RlbmVycyAhPSBudWxsICYmIGVlLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmICFlcnJvcltlbWl0dGVkU3ltYm9sXSkge1xuICAgICAgICAgICAgZXJyb3JbZW1pdHRlZFN5bWJvbF0gPSB0cnVlO1xuICAgICAgICAgICAgZWUuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBpbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZWUgIT0gbnVsbCAmJiBlZS5saXN0ZW5lcnMgIT0gbnVsbCAmJiBlZS5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoID4gMCAmJiAhZXJyb3JbZW1pdHRlZFN5bWJvbF0pIHtcbiAgICAgICAgZXJyb3JbZW1pdHRlZFN5bWJvbF0gPSB0cnVlO1xuICAgICAgICBlZS5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBQcm9taXNlID0gUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZuKGZ1bmN0aW9uKGVycm9yLCByZXMpIHtcbiAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChlZSAhPSBudWxsICYmIGVlLmxpc3RlbmVycyAhPSBudWxsICYmIGVlLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmICFlcnJvcltlbWl0dGVkU3ltYm9sXSkge1xuICAgICAgICAgIGVycm9yW2VtaXR0ZWRTeW1ib2xdID0gdHJ1ZTtcbiAgICAgICAgICBlZS5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/promiseOrCallback.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js":
/*!******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nfunction applyGlobalMaxTimeMS(options, model) {\n  applyGlobalOption(options, model, 'maxTimeMS');\n}\n\nfunction applyGlobalDiskUse(options, model) {\n  applyGlobalOption(options, model, 'allowDiskUse');\n}\n\nmodule.exports = {\n  applyGlobalMaxTimeMS,\n  applyGlobalDiskUse\n};\n\n\nfunction applyGlobalOption(options, model, optionName) {\n  if (utils.hasUserDefinedProperty(options, optionName)) {\n    return;\n  }\n\n  if (utils.hasUserDefinedProperty(model.db.options, optionName)) {\n    options[optionName] = model.db.options[optionName];\n  } else if (utils.hasUserDefinedProperty(model.base.options, optionName)) {\n    options[optionName] = model.base.options[optionName];\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9hcHBseUdsb2JhbE9wdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsdUVBQWE7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccXVlcnlcXGFwcGx5R2xvYmFsT3B0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBhcHBseUdsb2JhbE1heFRpbWVNUyhvcHRpb25zLCBtb2RlbCkge1xuICBhcHBseUdsb2JhbE9wdGlvbihvcHRpb25zLCBtb2RlbCwgJ21heFRpbWVNUycpO1xufVxuXG5mdW5jdGlvbiBhcHBseUdsb2JhbERpc2tVc2Uob3B0aW9ucywgbW9kZWwpIHtcbiAgYXBwbHlHbG9iYWxPcHRpb24ob3B0aW9ucywgbW9kZWwsICdhbGxvd0Rpc2tVc2UnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFwcGx5R2xvYmFsTWF4VGltZU1TLFxuICBhcHBseUdsb2JhbERpc2tVc2Vcbn07XG5cblxuZnVuY3Rpb24gYXBwbHlHbG9iYWxPcHRpb24ob3B0aW9ucywgbW9kZWwsIG9wdGlvbk5hbWUpIHtcbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkob3B0aW9ucywgb3B0aW9uTmFtZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShtb2RlbC5kYi5vcHRpb25zLCBvcHRpb25OYW1lKSkge1xuICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSBtb2RlbC5kYi5vcHRpb25zW29wdGlvbk5hbWVdO1xuICB9IGVsc2UgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkobW9kZWwuYmFzZS5vcHRpb25zLCBvcHRpb25OYW1lKSkge1xuICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSBtb2RlbC5iYXNlLm9wdGlvbnNbb3B0aW9uTmFtZV07XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = applyQueryMiddleware;\n\nconst validOps = __webpack_require__(/*! ./validOps */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/validOps.js\");\n\n/*!\n * ignore\n */\n\napplyQueryMiddleware.middlewareFunctions = validOps.concat([\n  'validate'\n]);\n\n/**\n * Apply query middleware\n *\n * @param {Query} Query constructor\n * @param {Model} model\n * @api private\n */\n\nfunction applyQueryMiddleware(Query, model) {\n  const queryMiddleware = model.schema.s.hooks.filter(hook => {\n    const contexts = _getContexts(hook);\n    if (hook.name === 'validate') {\n      return !!contexts.query;\n    }\n    if (hook.name === 'deleteOne' || hook.name === 'updateOne') {\n      return !!contexts.query || Object.keys(contexts).length === 0;\n    }\n    if (hook.query != null || hook.document != null) {\n      return !!hook.query;\n    }\n    return true;\n  });\n\n  Query.prototype._queryMiddleware = queryMiddleware;\n}\n\nfunction _getContexts(hook) {\n  const ret = {};\n  if (hook.hasOwnProperty('query')) {\n    ret.query = hook.query;\n  }\n  if (hook.hasOwnProperty('document')) {\n    ret.document = hook.document;\n  }\n  return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9hcHBseVF1ZXJ5TWlkZGxld2FyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsdUZBQVk7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccXVlcnlcXGFwcGx5UXVlcnlNaWRkbGV3YXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5UXVlcnlNaWRkbGV3YXJlO1xuXG5jb25zdCB2YWxpZE9wcyA9IHJlcXVpcmUoJy4vdmFsaWRPcHMnKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5hcHBseVF1ZXJ5TWlkZGxld2FyZS5taWRkbGV3YXJlRnVuY3Rpb25zID0gdmFsaWRPcHMuY29uY2F0KFtcbiAgJ3ZhbGlkYXRlJ1xuXSk7XG5cbi8qKlxuICogQXBwbHkgcXVlcnkgbWlkZGxld2FyZVxuICpcbiAqIEBwYXJhbSB7UXVlcnl9IFF1ZXJ5IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlRdWVyeU1pZGRsZXdhcmUoUXVlcnksIG1vZGVsKSB7XG4gIGNvbnN0IHF1ZXJ5TWlkZGxld2FyZSA9IG1vZGVsLnNjaGVtYS5zLmhvb2tzLmZpbHRlcihob29rID0+IHtcbiAgICBjb25zdCBjb250ZXh0cyA9IF9nZXRDb250ZXh0cyhob29rKTtcbiAgICBpZiAoaG9vay5uYW1lID09PSAndmFsaWRhdGUnKSB7XG4gICAgICByZXR1cm4gISFjb250ZXh0cy5xdWVyeTtcbiAgICB9XG4gICAgaWYgKGhvb2submFtZSA9PT0gJ2RlbGV0ZU9uZScgfHwgaG9vay5uYW1lID09PSAndXBkYXRlT25lJykge1xuICAgICAgcmV0dXJuICEhY29udGV4dHMucXVlcnkgfHwgT2JqZWN0LmtleXMoY29udGV4dHMpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgaWYgKGhvb2sucXVlcnkgIT0gbnVsbCB8fCBob29rLmRvY3VtZW50ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiAhIWhvb2sucXVlcnk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICBRdWVyeS5wcm90b3R5cGUuX3F1ZXJ5TWlkZGxld2FyZSA9IHF1ZXJ5TWlkZGxld2FyZTtcbn1cblxuZnVuY3Rpb24gX2dldENvbnRleHRzKGhvb2spIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGlmIChob29rLmhhc093blByb3BlcnR5KCdxdWVyeScpKSB7XG4gICAgcmV0LnF1ZXJ5ID0gaG9vay5xdWVyeTtcbiAgfVxuICBpZiAoaG9vay5oYXNPd25Qcm9wZXJ0eSgnZG9jdW1lbnQnKSkge1xuICAgIHJldC5kb2N1bWVudCA9IGhvb2suZG9jdW1lbnQ7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/cast$expr.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/cast$expr.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"(api)/../server/node_modules/mongoose/lib/error/strict.js\");\nconst castNumber = __webpack_require__(/*! ../../cast/number */ \"(api)/../server/node_modules/mongoose/lib/cast/number.js\");\n\nconst booleanComparison = new Set(['$and', '$or']);\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\nconst arithmeticOperatorArray = new Set([\n  // avoid casting '$add' or '$subtract', because expressions can be either number or date,\n  // and we don't have a good way of inferring which arguments should be numbers and which should\n  // be dates.\n  '$multiply',\n  '$divide',\n  '$log',\n  '$mod',\n  '$trunc',\n  '$avg',\n  '$max',\n  '$min',\n  '$stdDevPop',\n  '$stdDevSamp',\n  '$sum'\n]);\nconst arithmeticOperatorNumber = new Set([\n  '$abs',\n  '$exp',\n  '$ceil',\n  '$floor',\n  '$ln',\n  '$log10',\n  '$sqrt',\n  '$sin',\n  '$cos',\n  '$tan',\n  '$asin',\n  '$acos',\n  '$atan',\n  '$atan2',\n  '$asinh',\n  '$acosh',\n  '$atanh',\n  '$sinh',\n  '$cosh',\n  '$tanh',\n  '$degreesToRadians',\n  '$radiansToDegrees'\n]);\nconst arrayElementOperators = new Set([\n  '$arrayElemAt',\n  '$first',\n  '$last'\n]);\nconst dateOperators = new Set([\n  '$year',\n  '$month',\n  '$week',\n  '$dayOfMonth',\n  '$dayOfYear',\n  '$hour',\n  '$minute',\n  '$second',\n  '$isoDayOfWeek',\n  '$isoWeekYear',\n  '$isoWeek',\n  '$millisecond'\n]);\nconst expressionOperator = new Set(['$not']);\n\nmodule.exports = function cast$expr(val, schema, strictQuery) {\n  if (typeof val !== 'object' || val === null) {\n    throw new Error('`$expr` must be an object');\n  }\n\n  return _castExpression(val, schema, strictQuery);\n};\n\nfunction _castExpression(val, schema, strictQuery) {\n  // Preserve the value if it represents a path or if it's null\n  if (isPath(val) || val === null) {\n    return val;\n  }\n\n  if (val.$cond != null) {\n    if (Array.isArray(val.$cond)) {\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\n    } else {\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\n    }\n  } else if (val.$ifNull != null) {\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\n  } else if (val.$switch != null) {\n    if (Array.isArray(val.$switch.branches)) {\n      val.$switch.branches = val.$switch.branches.map(v => _castExpression(v, schema, strictQuery));\n    }\n    if ('default' in val.$switch) {\n      val.$switch.default = _castExpression(val.$switch.default, schema, strictQuery);\n    }\n  }\n\n  const keys = Object.keys(val);\n  for (const key of keys) {\n    if (booleanComparison.has(key)) {\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\n    } else if (comparisonOperator.has(key)) {\n      val[key] = castComparison(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorArray.has(key)) {\n      val[key] = castArithmetic(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorNumber.has(key)) {\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\n    } else if (expressionOperator.has(key)) {\n      val[key] = _castExpression(val[key], schema, strictQuery);\n    }\n  }\n\n  if (val.$in) {\n    val.$in = castIn(val.$in, schema, strictQuery);\n  }\n  if (val.$size) {\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\n  }\n  if (val.$round) {\n    const $round = val.$round;\n    if (!Array.isArray($round) || $round.length < 1 || $round.length > 2) {\n      throw new CastError('Array', $round, '$round');\n    }\n    val.$round = $round.map(v => castNumberOperator(v, schema, strictQuery));\n  }\n\n  _omitUndefined(val);\n\n  return val;\n}\n\nfunction _omitUndefined(val) {\n  const keys = Object.keys(val);\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    (val[keys[i]] === void 0) && delete val[keys[i]];\n  }\n}\n\n// { $op: <number> }\nfunction castNumberOperator(val) {\n  if (!isLiteral(val)) {\n    return val;\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val);\n  }\n}\n\nfunction castIn(val, schema, strictQuery) {\n  const path = val[1];\n  if (!isPath(path)) {\n    return val;\n  }\n  const search = val[0];\n\n  const schematype = schema.path(path.slice(1));\n  if (schematype === null) {\n    if (strictQuery === false) {\n      return val;\n    } else if (strictQuery === 'throw') {\n      throw new StrictModeError('$in');\n    }\n\n    return void 0;\n  }\n\n  if (!schematype.$isMongooseArray) {\n    throw new Error('Path must be an array for $in');\n  }\n\n  return [\n    schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),\n    path\n  ];\n}\n\n// { $op: [<number>, <number>] }\nfunction castArithmetic(val) {\n  if (!Array.isArray(val)) {\n    if (!isLiteral(val)) {\n      return val;\n    }\n    try {\n      return castNumber(val);\n    } catch (err) {\n      throw new CastError('Number', val);\n    }\n  }\n\n  return val.map(v => {\n    if (!isLiteral(v)) {\n      return v;\n    }\n    try {\n      return castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v);\n    }\n  });\n}\n\n// { $op: [expression, expression] }\nfunction castComparison(val, schema, strictQuery) {\n  if (!Array.isArray(val) || val.length !== 2) {\n    throw new Error('Comparison operator must be an array of length 2');\n  }\n\n  val[0] = _castExpression(val[0], schema, strictQuery);\n  const lhs = val[0];\n\n  if (isLiteral(val[1])) {\n    let path = null;\n    let schematype = null;\n    let caster = null;\n    if (isPath(lhs)) {\n      path = lhs.slice(1);\n      schematype = schema.path(path);\n    } else if (typeof lhs === 'object' && lhs != null) {\n      for (const key of Object.keys(lhs)) {\n        if (dateOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          caster = castNumber;\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          schematype = schema.path(lhs[key].slice(1));\n          if (schematype != null) {\n            if (schematype.$isMongooseDocumentArray) {\n              schematype = schematype.$embeddedSchemaType;\n            } else if (schematype.$isMongooseArray) {\n              schematype = schematype.caster;\n            }\n          }\n        }\n      }\n    }\n\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\n    if (schematype != null) {\n      if (is$literal) {\n        val[1] = { $literal: schematype.cast(val[1].$literal) };\n      } else {\n        val[1] = schematype.cast(val[1]);\n      }\n    } else if (caster != null) {\n      if (is$literal) {\n        try {\n          val[1] = { $literal: caster(val[1].$literal) };\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\n        }\n      } else {\n        try {\n          val[1] = caster(val[1]);\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\n        }\n      }\n    } else if (path != null && strictQuery === true) {\n      return void 0;\n    } else if (path != null && strictQuery === 'throw') {\n      throw new StrictModeError(path);\n    }\n  } else {\n    val[1] = _castExpression(val[1]);\n  }\n\n  return val;\n}\n\nfunction isPath(val) {\n  return typeof val === 'string' && val[0] === '$';\n}\n\nfunction isLiteral(val) {\n  if (typeof val === 'string' && val[0] === '$') {\n    return false;\n  }\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\n    // The `$literal` expression can make an object a literal\n    // https://www.mongodb.com/docs/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\n    return val.$literal != null;\n  }\n  return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9jYXN0JGV4cHIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsaUZBQWtCO0FBQzVDLHdCQUF3QixtQkFBTyxDQUFDLHFGQUFvQjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBbUI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxxdWVyeVxcY2FzdCRleHByLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvY2FzdCcpO1xuY29uc3QgU3RyaWN0TW9kZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3Ivc3RyaWN0Jyk7XG5jb25zdCBjYXN0TnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vY2FzdC9udW1iZXInKTtcblxuY29uc3QgYm9vbGVhbkNvbXBhcmlzb24gPSBuZXcgU2V0KFsnJGFuZCcsICckb3InXSk7XG5jb25zdCBjb21wYXJpc29uT3BlcmF0b3IgPSBuZXcgU2V0KFsnJGNtcCcsICckZXEnLCAnJGx0JywgJyRsdGUnLCAnJGd0JywgJyRndGUnXSk7XG5jb25zdCBhcml0aG1ldGljT3BlcmF0b3JBcnJheSA9IG5ldyBTZXQoW1xuICAvLyBhdm9pZCBjYXN0aW5nICckYWRkJyBvciAnJHN1YnRyYWN0JywgYmVjYXVzZSBleHByZXNzaW9ucyBjYW4gYmUgZWl0aGVyIG51bWJlciBvciBkYXRlLFxuICAvLyBhbmQgd2UgZG9uJ3QgaGF2ZSBhIGdvb2Qgd2F5IG9mIGluZmVycmluZyB3aGljaCBhcmd1bWVudHMgc2hvdWxkIGJlIG51bWJlcnMgYW5kIHdoaWNoIHNob3VsZFxuICAvLyBiZSBkYXRlcy5cbiAgJyRtdWx0aXBseScsXG4gICckZGl2aWRlJyxcbiAgJyRsb2cnLFxuICAnJG1vZCcsXG4gICckdHJ1bmMnLFxuICAnJGF2ZycsXG4gICckbWF4JyxcbiAgJyRtaW4nLFxuICAnJHN0ZERldlBvcCcsXG4gICckc3RkRGV2U2FtcCcsXG4gICckc3VtJ1xuXSk7XG5jb25zdCBhcml0aG1ldGljT3BlcmF0b3JOdW1iZXIgPSBuZXcgU2V0KFtcbiAgJyRhYnMnLFxuICAnJGV4cCcsXG4gICckY2VpbCcsXG4gICckZmxvb3InLFxuICAnJGxuJyxcbiAgJyRsb2cxMCcsXG4gICckc3FydCcsXG4gICckc2luJyxcbiAgJyRjb3MnLFxuICAnJHRhbicsXG4gICckYXNpbicsXG4gICckYWNvcycsXG4gICckYXRhbicsXG4gICckYXRhbjInLFxuICAnJGFzaW5oJyxcbiAgJyRhY29zaCcsXG4gICckYXRhbmgnLFxuICAnJHNpbmgnLFxuICAnJGNvc2gnLFxuICAnJHRhbmgnLFxuICAnJGRlZ3JlZXNUb1JhZGlhbnMnLFxuICAnJHJhZGlhbnNUb0RlZ3JlZXMnXG5dKTtcbmNvbnN0IGFycmF5RWxlbWVudE9wZXJhdG9ycyA9IG5ldyBTZXQoW1xuICAnJGFycmF5RWxlbUF0JyxcbiAgJyRmaXJzdCcsXG4gICckbGFzdCdcbl0pO1xuY29uc3QgZGF0ZU9wZXJhdG9ycyA9IG5ldyBTZXQoW1xuICAnJHllYXInLFxuICAnJG1vbnRoJyxcbiAgJyR3ZWVrJyxcbiAgJyRkYXlPZk1vbnRoJyxcbiAgJyRkYXlPZlllYXInLFxuICAnJGhvdXInLFxuICAnJG1pbnV0ZScsXG4gICckc2Vjb25kJyxcbiAgJyRpc29EYXlPZldlZWsnLFxuICAnJGlzb1dlZWtZZWFyJyxcbiAgJyRpc29XZWVrJyxcbiAgJyRtaWxsaXNlY29uZCdcbl0pO1xuY29uc3QgZXhwcmVzc2lvbk9wZXJhdG9yID0gbmV3IFNldChbJyRub3QnXSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdCRleHByKHZhbCwgc2NoZW1hLCBzdHJpY3RRdWVyeSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcgfHwgdmFsID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgJGV4cHJgIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICByZXR1cm4gX2Nhc3RFeHByZXNzaW9uKHZhbCwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG59O1xuXG5mdW5jdGlvbiBfY2FzdEV4cHJlc3Npb24odmFsLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KSB7XG4gIC8vIFByZXNlcnZlIHRoZSB2YWx1ZSBpZiBpdCByZXByZXNlbnRzIGEgcGF0aCBvciBpZiBpdCdzIG51bGxcbiAgaWYgKGlzUGF0aCh2YWwpIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodmFsLiRjb25kICE9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwuJGNvbmQpKSB7XG4gICAgICB2YWwuJGNvbmQgPSB2YWwuJGNvbmQubWFwKGV4cHIgPT4gX2Nhc3RFeHByZXNzaW9uKGV4cHIsIHNjaGVtYSwgc3RyaWN0UXVlcnkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsLiRjb25kLmlmID0gX2Nhc3RFeHByZXNzaW9uKHZhbC4kY29uZC5pZiwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gICAgICB2YWwuJGNvbmQudGhlbiA9IF9jYXN0RXhwcmVzc2lvbih2YWwuJGNvbmQudGhlbiwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gICAgICB2YWwuJGNvbmQuZWxzZSA9IF9jYXN0RXhwcmVzc2lvbih2YWwuJGNvbmQuZWxzZSwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbC4kaWZOdWxsICE9IG51bGwpIHtcbiAgICB2YWwuJGlmTnVsbC5tYXAodiA9PiBfY2FzdEV4cHJlc3Npb24odiwgc2NoZW1hLCBzdHJpY3RRdWVyeSkpO1xuICB9IGVsc2UgaWYgKHZhbC4kc3dpdGNoICE9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwuJHN3aXRjaC5icmFuY2hlcykpIHtcbiAgICAgIHZhbC4kc3dpdGNoLmJyYW5jaGVzID0gdmFsLiRzd2l0Y2guYnJhbmNoZXMubWFwKHYgPT4gX2Nhc3RFeHByZXNzaW9uKHYsIHNjaGVtYSwgc3RyaWN0UXVlcnkpKTtcbiAgICB9XG4gICAgaWYgKCdkZWZhdWx0JyBpbiB2YWwuJHN3aXRjaCkge1xuICAgICAgdmFsLiRzd2l0Y2guZGVmYXVsdCA9IF9jYXN0RXhwcmVzc2lvbih2YWwuJHN3aXRjaC5kZWZhdWx0LCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmIChib29sZWFuQ29tcGFyaXNvbi5oYXMoa2V5KSkge1xuICAgICAgdmFsW2tleV0gPSB2YWxba2V5XS5tYXAodiA9PiBfY2FzdEV4cHJlc3Npb24odiwgc2NoZW1hLCBzdHJpY3RRdWVyeSkpO1xuICAgIH0gZWxzZSBpZiAoY29tcGFyaXNvbk9wZXJhdG9yLmhhcyhrZXkpKSB7XG4gICAgICB2YWxba2V5XSA9IGNhc3RDb21wYXJpc29uKHZhbFtrZXldLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICB9IGVsc2UgaWYgKGFyaXRobWV0aWNPcGVyYXRvckFycmF5LmhhcyhrZXkpKSB7XG4gICAgICB2YWxba2V5XSA9IGNhc3RBcml0aG1ldGljKHZhbFtrZXldLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICB9IGVsc2UgaWYgKGFyaXRobWV0aWNPcGVyYXRvck51bWJlci5oYXMoa2V5KSkge1xuICAgICAgdmFsW2tleV0gPSBjYXN0TnVtYmVyT3BlcmF0b3IodmFsW2tleV0sIHNjaGVtYSwgc3RyaWN0UXVlcnkpO1xuICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbk9wZXJhdG9yLmhhcyhrZXkpKSB7XG4gICAgICB2YWxba2V5XSA9IF9jYXN0RXhwcmVzc2lvbih2YWxba2V5XSwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbC4kaW4pIHtcbiAgICB2YWwuJGluID0gY2FzdEluKHZhbC4kaW4sIHNjaGVtYSwgc3RyaWN0UXVlcnkpO1xuICB9XG4gIGlmICh2YWwuJHNpemUpIHtcbiAgICB2YWwuJHNpemUgPSBjYXN0TnVtYmVyT3BlcmF0b3IodmFsLiRzaXplLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgfVxuICBpZiAodmFsLiRyb3VuZCkge1xuICAgIGNvbnN0ICRyb3VuZCA9IHZhbC4kcm91bmQ7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KCRyb3VuZCkgfHwgJHJvdW5kLmxlbmd0aCA8IDEgfHwgJHJvdW5kLmxlbmd0aCA+IDIpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ0FycmF5JywgJHJvdW5kLCAnJHJvdW5kJyk7XG4gICAgfVxuICAgIHZhbC4kcm91bmQgPSAkcm91bmQubWFwKHYgPT4gY2FzdE51bWJlck9wZXJhdG9yKHYsIHNjaGVtYSwgc3RyaWN0UXVlcnkpKTtcbiAgfVxuXG4gIF9vbWl0VW5kZWZpbmVkKHZhbCk7XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gX29taXRVbmRlZmluZWQodmFsKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICh2YWxba2V5c1tpXV0gPT09IHZvaWQgMCkgJiYgZGVsZXRlIHZhbFtrZXlzW2ldXTtcbiAgfVxufVxuXG4vLyB7ICRvcDogPG51bWJlcj4gfVxuZnVuY3Rpb24gY2FzdE51bWJlck9wZXJhdG9yKHZhbCkge1xuICBpZiAoIWlzTGl0ZXJhbCh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhc3ROdW1iZXIodmFsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignTnVtYmVyJywgdmFsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXN0SW4odmFsLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KSB7XG4gIGNvbnN0IHBhdGggPSB2YWxbMV07XG4gIGlmICghaXNQYXRoKHBhdGgpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBjb25zdCBzZWFyY2ggPSB2YWxbMF07XG5cbiAgY29uc3Qgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHBhdGguc2xpY2UoMSkpO1xuICBpZiAoc2NoZW1hdHlwZSA9PT0gbnVsbCkge1xuICAgIGlmIChzdHJpY3RRdWVyeSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSBlbHNlIGlmIChzdHJpY3RRdWVyeSA9PT0gJ3Rocm93Jykge1xuICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcignJGluJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuXG4gIGlmICghc2NoZW1hdHlwZS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIG11c3QgYmUgYW4gYXJyYXkgZm9yICRpbicpO1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICBzY2hlbWF0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSA/IHNjaGVtYXR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS5jYXN0KHNlYXJjaCkgOiBzY2hlbWF0eXBlLmNhc3Rlci5jYXN0KHNlYXJjaCksXG4gICAgcGF0aFxuICBdO1xufVxuXG4vLyB7ICRvcDogWzxudW1iZXI+LCA8bnVtYmVyPl0gfVxuZnVuY3Rpb24gY2FzdEFyaXRobWV0aWModmFsKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgaWYgKCFpc0xpdGVyYWwodmFsKSkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYXN0TnVtYmVyKHZhbCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdOdW1iZXInLCB2YWwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWwubWFwKHYgPT4ge1xuICAgIGlmICghaXNMaXRlcmFsKHYpKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYXN0TnVtYmVyKHYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignTnVtYmVyJywgdik7XG4gICAgfVxuICB9KTtcbn1cblxuLy8geyAkb3A6IFtleHByZXNzaW9uLCBleHByZXNzaW9uXSB9XG5mdW5jdGlvbiBjYXN0Q29tcGFyaXNvbih2YWwsIHNjaGVtYSwgc3RyaWN0UXVlcnkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkgfHwgdmFsLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29tcGFyaXNvbiBvcGVyYXRvciBtdXN0IGJlIGFuIGFycmF5IG9mIGxlbmd0aCAyJyk7XG4gIH1cblxuICB2YWxbMF0gPSBfY2FzdEV4cHJlc3Npb24odmFsWzBdLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgY29uc3QgbGhzID0gdmFsWzBdO1xuXG4gIGlmIChpc0xpdGVyYWwodmFsWzFdKSkge1xuICAgIGxldCBwYXRoID0gbnVsbDtcbiAgICBsZXQgc2NoZW1hdHlwZSA9IG51bGw7XG4gICAgbGV0IGNhc3RlciA9IG51bGw7XG4gICAgaWYgKGlzUGF0aChsaHMpKSB7XG4gICAgICBwYXRoID0gbGhzLnNsaWNlKDEpO1xuICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHBhdGgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxocyA9PT0gJ29iamVjdCcgJiYgbGhzICE9IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGxocykpIHtcbiAgICAgICAgaWYgKGRhdGVPcGVyYXRvcnMuaGFzKGtleSkgJiYgaXNQYXRoKGxoc1trZXldKSkge1xuICAgICAgICAgIHBhdGggPSBsaHNba2V5XS5zbGljZSgxKSArICcuJyArIGtleTtcbiAgICAgICAgICBjYXN0ZXIgPSBjYXN0TnVtYmVyO1xuICAgICAgICB9IGVsc2UgaWYgKGFycmF5RWxlbWVudE9wZXJhdG9ycy5oYXMoa2V5KSAmJiBpc1BhdGgobGhzW2tleV0pKSB7XG4gICAgICAgICAgcGF0aCA9IGxoc1trZXldLnNsaWNlKDEpICsgJy4nICsga2V5O1xuICAgICAgICAgIHNjaGVtYXR5cGUgPSBzY2hlbWEucGF0aChsaHNba2V5XS5zbGljZSgxKSk7XG4gICAgICAgICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgICAgICAgIHNjaGVtYXR5cGUgPSBzY2hlbWF0eXBlLiRlbWJlZGRlZFNjaGVtYVR5cGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VBcnJheSkge1xuICAgICAgICAgICAgICBzY2hlbWF0eXBlID0gc2NoZW1hdHlwZS5jYXN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaXMkbGl0ZXJhbCA9IHR5cGVvZiB2YWxbMV0gPT09ICdvYmplY3QnICYmIHZhbFsxXSAhPSBudWxsICYmIHZhbFsxXS4kbGl0ZXJhbCAhPSBudWxsO1xuICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICAgIGlmIChpcyRsaXRlcmFsKSB7XG4gICAgICAgIHZhbFsxXSA9IHsgJGxpdGVyYWw6IHNjaGVtYXR5cGUuY2FzdCh2YWxbMV0uJGxpdGVyYWwpIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxbMV0gPSBzY2hlbWF0eXBlLmNhc3QodmFsWzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhc3RlciAhPSBudWxsKSB7XG4gICAgICBpZiAoaXMkbGl0ZXJhbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbFsxXSA9IHsgJGxpdGVyYWw6IGNhc3Rlcih2YWxbMV0uJGxpdGVyYWwpIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoY2FzdGVyLm5hbWUucmVwbGFjZSgvXmNhc3QvLCAnJyksIHZhbFsxXSwgcGF0aCArICcuJGxpdGVyYWwnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWxbMV0gPSBjYXN0ZXIodmFsWzFdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcihjYXN0ZXIubmFtZS5yZXBsYWNlKC9eY2FzdC8sICcnKSwgdmFsWzFdLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF0aCAhPSBudWxsICYmIHN0cmljdFF1ZXJ5ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAocGF0aCAhPSBudWxsICYmIHN0cmljdFF1ZXJ5ID09PSAndGhyb3cnKSB7XG4gICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKHBhdGgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWxbMV0gPSBfY2FzdEV4cHJlc3Npb24odmFsWzFdKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGlzUGF0aCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbFswXSA9PT0gJyQnO1xufVxuXG5mdW5jdGlvbiBpc0xpdGVyYWwodmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWxbMF0gPT09ICckJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHZhbCkuZmluZChrZXkgPT4ga2V5WzBdID09PSAnJCcpKSB7XG4gICAgLy8gVGhlIGAkbGl0ZXJhbGAgZXhwcmVzc2lvbiBjYW4gbWFrZSBhbiBvYmplY3QgYSBsaXRlcmFsXG4gICAgLy8gaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2xpdGVyYWwvI21vbmdvZGItZXhwcmVzc2lvbi1leHAuLWxpdGVyYWxcbiAgICByZXR1cm4gdmFsLiRsaXRlcmFsICE9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/cast$expr.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/castFilterPath.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/castFilterPath.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isOperator = __webpack_require__(/*! ./isOperator */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/isOperator.js\");\n\nmodule.exports = function castFilterPath(query, schematype, val) {\n  const ctx = query;\n  const any$conditionals = Object.keys(val).some(isOperator);\n\n  if (!any$conditionals) {\n    return schematype.castForQuery(\n      null,\n      val,\n      ctx\n    );\n  }\n\n  const ks = Object.keys(val);\n\n  let k = ks.length;\n\n  while (k--) {\n    const $cond = ks[k];\n    const nested = val[$cond];\n\n    if ($cond === '$not') {\n      if (nested && schematype && !schematype.caster) {\n        const _keys = Object.keys(nested);\n        if (_keys.length && isOperator(_keys[0])) {\n          for (const key of Object.keys(nested)) {\n            nested[key] = schematype.castForQuery(\n              key,\n              nested[key],\n              ctx\n            );\n          }\n        } else {\n          val[$cond] = schematype.castForQuery(\n            $cond,\n            nested,\n            ctx\n          );\n        }\n        continue;\n      }\n    } else {\n      val[$cond] = schematype.castForQuery(\n        $cond,\n        nested,\n        ctx\n      );\n    }\n  }\n\n  return val;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9jYXN0RmlsdGVyUGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQywyRkFBYzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHF1ZXJ5XFxjYXN0RmlsdGVyUGF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzT3BlcmF0b3IgPSByZXF1aXJlKCcuL2lzT3BlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0RmlsdGVyUGF0aChxdWVyeSwgc2NoZW1hdHlwZSwgdmFsKSB7XG4gIGNvbnN0IGN0eCA9IHF1ZXJ5O1xuICBjb25zdCBhbnkkY29uZGl0aW9uYWxzID0gT2JqZWN0LmtleXModmFsKS5zb21lKGlzT3BlcmF0b3IpO1xuXG4gIGlmICghYW55JGNvbmRpdGlvbmFscykge1xuICAgIHJldHVybiBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgIG51bGwsXG4gICAgICB2YWwsXG4gICAgICBjdHhcbiAgICApO1xuICB9XG5cbiAgY29uc3Qga3MgPSBPYmplY3Qua2V5cyh2YWwpO1xuXG4gIGxldCBrID0ga3MubGVuZ3RoO1xuXG4gIHdoaWxlIChrLS0pIHtcbiAgICBjb25zdCAkY29uZCA9IGtzW2tdO1xuICAgIGNvbnN0IG5lc3RlZCA9IHZhbFskY29uZF07XG5cbiAgICBpZiAoJGNvbmQgPT09ICckbm90Jykge1xuICAgICAgaWYgKG5lc3RlZCAmJiBzY2hlbWF0eXBlICYmICFzY2hlbWF0eXBlLmNhc3Rlcikge1xuICAgICAgICBjb25zdCBfa2V5cyA9IE9iamVjdC5rZXlzKG5lc3RlZCk7XG4gICAgICAgIGlmIChfa2V5cy5sZW5ndGggJiYgaXNPcGVyYXRvcihfa2V5c1swXSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhuZXN0ZWQpKSB7XG4gICAgICAgICAgICBuZXN0ZWRba2V5XSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIG5lc3RlZFtrZXldLFxuICAgICAgICAgICAgICBjdHhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbFskY29uZF0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICRjb25kLFxuICAgICAgICAgICAgbmVzdGVkLFxuICAgICAgICAgICAgY3R4XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsWyRjb25kXSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAkY29uZCxcbiAgICAgICAgbmVzdGVkLFxuICAgICAgICBjdHhcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/castFilterPath.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/castUpdate.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/castUpdate.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"(api)/../server/node_modules/mongoose/lib/error/strict.js\");\nconst ValidationError = __webpack_require__(/*! ../../error/validation */ \"(api)/../server/node_modules/mongoose/lib/error/validation.js\");\nconst castNumber = __webpack_require__(/*! ../../cast/number */ \"(api)/../server/node_modules/mongoose/lib/cast/number.js\");\nconst cast = __webpack_require__(/*! ../../cast */ \"(api)/../server/node_modules/mongoose/lib/cast.js\");\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getEmbeddedDiscriminatorPath = __webpack_require__(/*! ./getEmbeddedDiscriminatorPath */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js\");\nconst handleImmutable = __webpack_require__(/*! ./handleImmutable */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/handleImmutable.js\");\nconst moveImmutableProperties = __webpack_require__(/*! ../update/moveImmutableProperties */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js\");\nconst schemaMixedSymbol = (__webpack_require__(/*! ../../schema/symbols */ \"(api)/../server/node_modules/mongoose/lib/schema/symbols.js\").schemaMixedSymbol);\nconst setDottedPath = __webpack_require__(/*! ../path/setDottedPath */ \"(api)/../server/node_modules/mongoose/lib/helpers/path/setDottedPath.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nconst mongodbUpdateOperators = new Set([\n  '$currentDate',\n  '$inc',\n  '$min',\n  '$max',\n  '$mul',\n  '$rename',\n  '$set',\n  '$setOnInsert',\n  '$unset',\n  '$addToSet',\n  '$pop',\n  '$pull',\n  '$push',\n  '$pullAll',\n  '$bit'\n]);\n\n/**\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean} [options.overwrite] defaults to false\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n * @api private\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n\n  if (options.upsert && !options.overwrite) {\n    moveImmutableProperties(schema, obj, context);\n  }\n\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n  const overwrite = options.overwrite;\n\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    // if overwrite is set, don't do any of the special $set stuff\n    if (!mongodbUpdateOperators.has(op) && !overwrite) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n\n    if (val &&\n        typeof val === 'object' &&\n        !Buffer.isBuffer(val) &&\n        (!overwrite || mongodbUpdateOperators.has(op))) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else if (overwrite && ret && typeof ret === 'object') {\n      walkUpdatePath(schema, ret, '$set', options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n\n  if (Object.keys(ret).length === 0 &&\n      options.upsert &&\n      Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    // Shallow clone to avoid passing defaults in re: gh-13962\n    return { $setOnInsert: { ...filter } };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' +\n        ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/**\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj part of a query\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {Object} filter\n * @param {String} pref path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\n  const strict = options.strict;\n  const prefix = pref ? pref + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n\n  let aggregatedError = null;\n\n  const strictMode = strict != null ? strict : schema.options.strict;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n\n    const discriminatorKey = (prefix ? prefix + key : key);\n    if (\n      schema.discriminatorMapping != null &&\n      discriminatorKey === schema.options.discriminatorKey &&\n      schema.discriminatorMapping.value !== obj[key] &&\n      !options.overwriteDiscriminatorKey\n    ) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n\n      if (op !== '$setOnInsert' &&\n          !options.overwrite &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(null, val, context, { strict: _strict });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n\n          hasKeys = true;\n        }\n      } else if ((op === '$currentDate') || (op in castOps && schematype)) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else {\n        const pathToCheck = (prefix + key);\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v && v.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) ||\n          (utils.isObject(val) && Object.keys(val).length === 0);\n      }\n    } else {\n      const checkPath = (key === '$each' || key === '$or' || key === '$and' || key === '$in') ?\n        pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' &&\n          !options.overwrite &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n\n      let isStrict = strict;\n      if (pathDetails && pathDetails.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      const skip = isStrict &&\n        !schematype &&\n        !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else if (isStrict !== false || schematype != null) {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype &&\n              schematype.caster &&\n              !schematype.caster.$isMongooseArray &&\n              !schematype.caster[schemaMixedSymbol]) {\n            obj[key] = { $each: obj[key] };\n          }\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      }\n    }\n  }\n\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/**\n * These operators should be cast to numbers instead\n * of their path schema type.\n * @api private\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/**\n * These ops require no casting because the RHS doesn't do anything.\n * @api private\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/**\n * These operators require casting docs\n * to real Documents for Update operations.\n * @api private\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/**\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @param {String} path\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch (err) {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n\n  // console.log('CastUpdateVal', path, op, val, schema);\n\n  const cond = schema.caster && op in castOps &&\n      (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.caster;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQuery(\n        null,\n        val,\n        context\n      );\n    }\n    try {\n      return castNumber(val);\n    } catch (error) {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return { $type: val.$type };\n    }\n    return Boolean(val);\n  }\n\n  if (mongodbUpdateOperators.has($conditional)) {\n    return schema.castForQuery(\n      $conditional,\n      val,\n      context\n    );\n  }\n\n  if (overwriteOps[op]) {\n    const skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/);\n    const applySetters = schema[schemaMixedSymbol] != null;\n    if (skipQueryCastForUpdate || applySetters) {\n      return schema.applySetters(val, context);\n    }\n    return schema.castForQuery(\n      null,\n      val,\n      context\n    );\n  }\n\n  return schema.castForQuery(null, val, context);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9jYXN0VXBkYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFrQjtBQUM1QyxzQkFBc0IsbUJBQU8sQ0FBQyxtR0FBMkI7QUFDekQsd0JBQXdCLG1CQUFPLENBQUMscUZBQW9CO0FBQ3BELHdCQUF3QixtQkFBTyxDQUFDLDZGQUF3QjtBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBbUI7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLHFFQUFZO0FBQ2pDLDJCQUEyQixtQkFBTyxDQUFDLHNHQUF1QjtBQUMxRCxxQ0FBcUMsbUJBQU8sQ0FBQywrSEFBZ0M7QUFDN0Usd0JBQXdCLG1CQUFPLENBQUMscUdBQW1CO0FBQ25ELGdDQUFnQyxtQkFBTyxDQUFDLDhIQUFtQztBQUMzRSwwQkFBMEIsa0lBQWlEO0FBQzNFLHNCQUFzQixtQkFBTyxDQUFDLHNHQUF1QjtBQUNyRCxjQUFjLG1CQUFPLENBQUMsdUVBQWE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsT0FBTztBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksTUFBTTtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxpQkFBaUI7QUFDeEYsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHF1ZXJ5XFxjYXN0VXBkYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvY2FzdCcpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFN0cmljdE1vZGVFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL3N0cmljdCcpO1xuY29uc3QgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvdmFsaWRhdGlvbicpO1xuY29uc3QgY2FzdE51bWJlciA9IHJlcXVpcmUoJy4uLy4uL2Nhc3QvbnVtYmVyJyk7XG5jb25zdCBjYXN0ID0gcmVxdWlyZSgnLi4vLi4vY2FzdCcpO1xuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi4vZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoID0gcmVxdWlyZSgnLi9nZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoJyk7XG5jb25zdCBoYW5kbGVJbW11dGFibGUgPSByZXF1aXJlKCcuL2hhbmRsZUltbXV0YWJsZScpO1xuY29uc3QgbW92ZUltbXV0YWJsZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi91cGRhdGUvbW92ZUltbXV0YWJsZVByb3BlcnRpZXMnKTtcbmNvbnN0IHNjaGVtYU1peGVkU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL3N5bWJvbHMnKS5zY2hlbWFNaXhlZFN5bWJvbDtcbmNvbnN0IHNldERvdHRlZFBhdGggPSByZXF1aXJlKCcuLi9wYXRoL3NldERvdHRlZFBhdGgnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuY29uc3QgbW9uZ29kYlVwZGF0ZU9wZXJhdG9ycyA9IG5ldyBTZXQoW1xuICAnJGN1cnJlbnREYXRlJyxcbiAgJyRpbmMnLFxuICAnJG1pbicsXG4gICckbWF4JyxcbiAgJyRtdWwnLFxuICAnJHJlbmFtZScsXG4gICckc2V0JyxcbiAgJyRzZXRPbkluc2VydCcsXG4gICckdW5zZXQnLFxuICAnJGFkZFRvU2V0JyxcbiAgJyRwb3AnLFxuICAnJHB1bGwnLFxuICAnJHB1c2gnLFxuICAnJHB1bGxBbGwnLFxuICAnJGJpdCdcbl0pO1xuXG4vKipcbiAqIENhc3RzIGFuIHVwZGF0ZSBvcCBiYXNlZCBvbiB0aGUgZ2l2ZW4gc2NoZW1hXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vdmVyd3JpdGVdIGRlZmF1bHRzIHRvIGZhbHNlXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIGRlZmF1bHRzIHRvIHRydWVcbiAqIEBwYXJhbSB7UXVlcnl9IGNvbnRleHQgcGFzc2VkIHRvIHNldHRlcnNcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWZmIHRoZSB1cGRhdGUgaXMgbm9uLWVtcHR5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0VXBkYXRlKHNjaGVtYSwgb2JqLCBvcHRpb25zLCBjb250ZXh0LCBmaWx0ZXIpIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgLy8gVXBkYXRlIHBpcGVsaW5lXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBvYmoubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG9wcyA9IE9iamVjdC5rZXlzKG9ialtpXSk7XG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICBvYmpbaV1bb3BdID0gY2FzdFBpcGVsaW5lT3BlcmF0b3Iob3AsIG9ialtpXVtvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudXBzZXJ0ICYmICFvcHRpb25zLm92ZXJ3cml0ZSkge1xuICAgIG1vdmVJbW11dGFibGVQcm9wZXJ0aWVzKHNjaGVtYSwgb2JqLCBjb250ZXh0KTtcbiAgfVxuXG4gIGNvbnN0IG9wcyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGxldCBpID0gb3BzLmxlbmd0aDtcbiAgY29uc3QgcmV0ID0ge307XG4gIGxldCB2YWw7XG4gIGxldCBoYXNEb2xsYXJLZXkgPSBmYWxzZTtcbiAgY29uc3Qgb3ZlcndyaXRlID0gb3B0aW9ucy5vdmVyd3JpdGU7XG5cbiAgZmlsdGVyID0gZmlsdGVyIHx8IHt9O1xuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qgb3AgPSBvcHNbaV07XG4gICAgLy8gaWYgb3ZlcndyaXRlIGlzIHNldCwgZG9uJ3QgZG8gYW55IG9mIHRoZSBzcGVjaWFsICRzZXQgc3R1ZmZcbiAgICBpZiAoIW1vbmdvZGJVcGRhdGVPcGVyYXRvcnMuaGFzKG9wKSAmJiAhb3ZlcndyaXRlKSB7XG4gICAgICAvLyBmaXggdXAgJHNldCBzdWdhclxuICAgICAgaWYgKCFyZXQuJHNldCkge1xuICAgICAgICBpZiAob2JqLiRzZXQpIHtcbiAgICAgICAgICByZXQuJHNldCA9IG9iai4kc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC4kc2V0ID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldC4kc2V0W29wXSA9IG9ialtvcF07XG4gICAgICBvcHMuc3BsaWNlKGksIDEpO1xuICAgICAgaWYgKCF+b3BzLmluZGV4T2YoJyRzZXQnKSkgb3BzLnB1c2goJyRzZXQnKTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSAnJHNldCcpIHtcbiAgICAgIGlmICghcmV0LiRzZXQpIHtcbiAgICAgICAgcmV0W29wXSA9IG9ialtvcF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFtvcF0gPSBvYmpbb3BdO1xuICAgIH1cbiAgfVxuICAvLyBjYXN0IGVhY2ggdmFsdWVcbiAgaSA9IG9wcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBvcCA9IG9wc1tpXTtcbiAgICB2YWwgPSByZXRbb3BdO1xuICAgIGhhc0RvbGxhcktleSA9IGhhc0RvbGxhcktleSB8fCBvcC5zdGFydHNXaXRoKCckJyk7XG5cbiAgICBpZiAodmFsICYmXG4gICAgICAgIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmXG4gICAgICAgICFCdWZmZXIuaXNCdWZmZXIodmFsKSAmJlxuICAgICAgICAoIW92ZXJ3cml0ZSB8fCBtb25nb2RiVXBkYXRlT3BlcmF0b3JzLmhhcyhvcCkpKSB7XG4gICAgICB3YWxrVXBkYXRlUGF0aChzY2hlbWEsIHZhbCwgb3AsIG9wdGlvbnMsIGNvbnRleHQsIGZpbHRlcik7XG4gICAgfSBlbHNlIGlmIChvdmVyd3JpdGUgJiYgcmV0ICYmIHR5cGVvZiByZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICB3YWxrVXBkYXRlUGF0aChzY2hlbWEsIHJldCwgJyRzZXQnLCBvcHRpb25zLCBjb250ZXh0LCBmaWx0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSAnSW52YWxpZCBhdG9taWMgdXBkYXRlIHZhbHVlIGZvciAnICsgb3AgKyAnLiAnXG4gICAgICAgICAgKyAnRXhwZWN0ZWQgYW4gb2JqZWN0LCByZWNlaXZlZCAnICsgdHlwZW9mIHZhbDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cblxuICAgIGlmIChvcC5zdGFydHNXaXRoKCckJykgJiYgdXRpbHMuaXNFbXB0eU9iamVjdCh2YWwpKSB7XG4gICAgICBkZWxldGUgcmV0W29wXTtcbiAgICB9XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMocmV0KS5sZW5ndGggPT09IDAgJiZcbiAgICAgIG9wdGlvbnMudXBzZXJ0ICYmXG4gICAgICBPYmplY3Qua2V5cyhmaWx0ZXIpLmxlbmd0aCA+IDApIHtcbiAgICAvLyBUcmljayB0aGUgZHJpdmVyIGludG8gYWxsb3dpbmcgZW1wdHkgdXBzZXJ0cyB0byB3b3JrIGFyb3VuZFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb25nb2RiL25vZGUtbW9uZ29kYi1uYXRpdmUvcHVsbC8yNDkwXG4gICAgLy8gU2hhbGxvdyBjbG9uZSB0byBhdm9pZCBwYXNzaW5nIGRlZmF1bHRzIGluIHJlOiBnaC0xMzk2MlxuICAgIHJldHVybiB7ICRzZXRPbkluc2VydDogeyAuLi5maWx0ZXIgfSB9O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGNhc3RQaXBlbGluZU9wZXJhdG9yKG9wLCB2YWwpIHtcbiAgaWYgKG9wID09PSAnJHVuc2V0Jykge1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJyAmJiAoIUFycmF5LmlzQXJyYXkodmFsKSB8fCB2YWwuZmluZCh2ID0+IHR5cGVvZiB2ICE9PSAnc3RyaW5nJykpKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignSW52YWxpZCAkdW5zZXQgaW4gcGlwZWxpbmUsIG11c3QgYmUgJyArXG4gICAgICAgICcgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChvcCA9PT0gJyRwcm9qZWN0Jykge1xuICAgIGlmICh2YWwgPT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0ludmFsaWQgJHByb2plY3QgaW4gcGlwZWxpbmUsIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKG9wID09PSAnJGFkZEZpZWxkcycgfHwgb3AgPT09ICckc2V0Jykge1xuICAgIGlmICh2YWwgPT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0ludmFsaWQgJyArIG9wICsgJyBpbiBwaXBlbGluZSwgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIGlmIChvcCA9PT0gJyRyZXBsYWNlUm9vdCcgfHwgb3AgPT09ICckcmVwbGFjZVdpdGgnKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignSW52YWxpZCAnICsgb3AgKyAnIGluIHBpcGVsaW5lLCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0ludmFsaWQgdXBkYXRlIHBpcGVsaW5lIG9wZXJhdG9yOiBcIicgKyBvcCArICdcIicpO1xufVxuXG4vKipcbiAqIFdhbGsgZWFjaCBwYXRoIG9mIG9iaiBhbmQgY2FzdCBpdHMgdmFsdWVzXG4gKiBhY2NvcmRpbmcgdG8gaXRzIHNjaGVtYS5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHBhcnQgb2YgYSBxdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IG9wIHRoZSBhdG9taWMgb3BlcmF0b3IgKCRwdWxsLCAkc2V0LCBldGMpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdXG4gKiBAcGFyYW0ge1F1ZXJ5fSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZiBwYXRoIHByZWZpeCAoaW50ZXJuYWwgb25seSlcbiAqIEByZXR1cm4ge0Jvb2x9IHRydWUgaWYgdGhpcyBwYXRoIGhhcyBrZXlzIHRvIHVwZGF0ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gd2Fsa1VwZGF0ZVBhdGgoc2NoZW1hLCBvYmosIG9wLCBvcHRpb25zLCBjb250ZXh0LCBmaWx0ZXIsIHByZWYpIHtcbiAgY29uc3Qgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIGNvbnN0IHByZWZpeCA9IHByZWYgPyBwcmVmICsgJy4nIDogJyc7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICBsZXQgaGFzS2V5cyA9IGZhbHNlO1xuICBsZXQgc2NoZW1hdHlwZTtcbiAgbGV0IGtleTtcbiAgbGV0IHZhbDtcblxuICBsZXQgYWdncmVnYXRlZEVycm9yID0gbnVsbDtcblxuICBjb25zdCBzdHJpY3RNb2RlID0gc3RyaWN0ICE9IG51bGwgPyBzdHJpY3QgOiBzY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdmFsID0gb2JqW2tleV07XG5cbiAgICAvLyBgJHB1bGxgIGlzIHNwZWNpYWwgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhc3QgdGhlIFJIUyBhcyBhIHF1ZXJ5LCBub3QgYXNcbiAgICAvLyBhbiB1cGRhdGUuXG4gICAgaWYgKG9wID09PSAnJHB1bGwnKSB7XG4gICAgICBzY2hlbWF0eXBlID0gc2NoZW1hLl9nZXRTY2hlbWEocHJlZml4ICsga2V5KTtcbiAgICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwgJiYgc2NoZW1hdHlwZS5zY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBvYmpba2V5XSA9IGNhc3Qoc2NoZW1hdHlwZS5zY2hlbWEsIG9ialtrZXldLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSAocHJlZml4ID8gcHJlZml4ICsga2V5IDoga2V5KTtcbiAgICBpZiAoXG4gICAgICBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgIT0gbnVsbCAmJlxuICAgICAgZGlzY3JpbWluYXRvcktleSA9PT0gc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSAmJlxuICAgICAgc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlICE9PSBvYmpba2V5XSAmJlxuICAgICAgIW9wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleVxuICAgICkge1xuICAgICAgaWYgKHN0cmljdE1vZGUgPT09ICd0aHJvdycpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdDYW5cXCd0IG1vZGlmeSBkaXNjcmltaW5hdG9yIGtleSBcIicgKyBkaXNjcmltaW5hdG9yS2V5ICsgJ1wiIG9uIGRpc2NyaW1pbmF0b3IgbW9kZWwnKTtcbiAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVyciwgY29udGV4dCwgZGlzY3JpbWluYXRvcktleSwgYWdncmVnYXRlZEVycm9yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0cmljdE1vZGUpIHtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2V0Q29uc3RydWN0b3JOYW1lKHZhbCkgPT09ICdPYmplY3QnKSB7XG4gICAgICAvLyB3YXRjaCBmb3IgZW1iZWRkZWQgZG9jIHNjaGVtYXNcbiAgICAgIHNjaGVtYXR5cGUgPSBzY2hlbWEuX2dldFNjaGVtYShwcmVmaXggKyBrZXkpO1xuXG4gICAgICBpZiAoc2NoZW1hdHlwZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IF9yZXMgPSBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoKHNjaGVtYSwgb2JqLCBmaWx0ZXIsIHByZWZpeCArIGtleSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChfcmVzLnNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgIHNjaGVtYXR5cGUgPSBfcmVzLnNjaGVtYXR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wICE9PSAnJHNldE9uSW5zZXJ0JyAmJlxuICAgICAgICAgICFvcHRpb25zLm92ZXJ3cml0ZSAmJlxuICAgICAgICAgIGhhbmRsZUltbXV0YWJsZShzY2hlbWF0eXBlLCBzdHJpY3QsIG9iaiwga2V5LCBwcmVmaXggKyBrZXksIGNvbnRleHQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hdHlwZSAmJiBzY2hlbWF0eXBlLmNhc3RlciAmJiBvcCBpbiBjYXN0T3BzKSB7XG4gICAgICAgIC8vIGVtYmVkZGVkIGRvYyBzY2hlbWFcbiAgICAgICAgaWYgKCckZWFjaCcgaW4gdmFsKSB7XG4gICAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ialtrZXldID0ge1xuICAgICAgICAgICAgICAkZWFjaDogY2FzdFVwZGF0ZVZhbChzY2hlbWF0eXBlLCB2YWwuJGVhY2gsIG9wLCBrZXksIGNvbnRleHQsIHByZWZpeCArIGtleSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRFcnJvciA9IF9hcHBlbmRFcnJvcihlcnJvciwgY29udGV4dCwga2V5LCBhZ2dyZWdhdGVkRXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwuJHNsaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9ialtrZXldLiRzbGljZSA9IHZhbC4kc2xpY2UgfCAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwuJHNvcnQpIHtcbiAgICAgICAgICAgIG9ialtrZXldLiRzb3J0ID0gdmFsLiRzb3J0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwuJHBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9ialtrZXldLiRwb3NpdGlvbiA9IGNhc3ROdW1iZXIodmFsLiRwb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwgJiYgc2NoZW1hdHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zdHJpY3QgPSBzdHJpY3QgPT0gbnVsbCA/IHNjaGVtYXR5cGUuc2NoZW1hLm9wdGlvbnMuc3RyaWN0IDogc3RyaWN0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgb2JqW2tleV0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQsIHsgc3RyaWN0OiBfc3RyaWN0IH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVycm9yLCBjb250ZXh0LCBrZXksIGFnZ3JlZ2F0ZWRFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG9ialtrZXldID0gY2FzdFVwZGF0ZVZhbChzY2hlbWF0eXBlLCB2YWwsIG9wLCBrZXksIGNvbnRleHQsIHByZWZpeCArIGtleSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBhZ2dyZWdhdGVkRXJyb3IgPSBfYXBwZW5kRXJyb3IoZXJyb3IsIGNvbnRleHQsIGtleSwgYWdncmVnYXRlZEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKG9wID09PSAnJGN1cnJlbnREYXRlJykgfHwgKG9wIGluIGNhc3RPcHMgJiYgc2NoZW1hdHlwZSkpIHtcbiAgICAgICAgLy8gJGN1cnJlbnREYXRlIGNhbiB0YWtlIGFuIG9iamVjdFxuICAgICAgICB0cnkge1xuICAgICAgICAgIG9ialtrZXldID0gY2FzdFVwZGF0ZVZhbChzY2hlbWF0eXBlLCB2YWwsIG9wLCBrZXksIGNvbnRleHQsIHByZWZpeCArIGtleSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVycm9yLCBjb250ZXh0LCBrZXksIGFnZ3JlZ2F0ZWRFcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc0tleXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGF0aFRvQ2hlY2sgPSAocHJlZml4ICsga2V5KTtcbiAgICAgICAgY29uc3QgdiA9IHNjaGVtYS5fZ2V0UGF0aFR5cGUocGF0aFRvQ2hlY2spO1xuICAgICAgICBsZXQgX3N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgaWYgKHYgJiYgdi5zY2hlbWEgJiYgX3N0cmljdCA9PSBudWxsKSB7XG4gICAgICAgICAgX3N0cmljdCA9IHYuc2NoZW1hLm9wdGlvbnMuc3RyaWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYucGF0aFR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKF9zdHJpY3QgPT09ICd0aHJvdycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aFRvQ2hlY2spO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3N0cmljdCkge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2gtMjMxNFxuICAgICAgICAvLyB3ZSBzaG91bGQgYmUgYWJsZSB0byBzZXQgYSBzY2hlbWEtbGVzcyBmaWVsZFxuICAgICAgICAvLyB0byBhbiBlbXB0eSBvYmplY3QgbGl0ZXJhbFxuICAgICAgICBoYXNLZXlzIHw9IHdhbGtVcGRhdGVQYXRoKHNjaGVtYSwgdmFsLCBvcCwgb3B0aW9ucywgY29udGV4dCwgZmlsdGVyLCBwcmVmaXggKyBrZXkpIHx8XG4gICAgICAgICAgKHV0aWxzLmlzT2JqZWN0KHZhbCkgJiYgT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGVja1BhdGggPSAoa2V5ID09PSAnJGVhY2gnIHx8IGtleSA9PT0gJyRvcicgfHwga2V5ID09PSAnJGFuZCcgfHwga2V5ID09PSAnJGluJykgP1xuICAgICAgICBwcmVmIDogcHJlZml4ICsga2V5O1xuICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5fZ2V0U2NoZW1hKGNoZWNrUGF0aCk7XG5cbiAgICAgIC8vIFlvdSBjYW4gdXNlIGAkc2V0T25JbnNlcnRgIHdpdGggaW1tdXRhYmxlIGtleXNcbiAgICAgIGlmIChvcCAhPT0gJyRzZXRPbkluc2VydCcgJiZcbiAgICAgICAgICAhb3B0aW9ucy5vdmVyd3JpdGUgJiZcbiAgICAgICAgICBoYW5kbGVJbW11dGFibGUoc2NoZW1hdHlwZSwgc3RyaWN0LCBvYmosIGtleSwgcHJlZml4ICsga2V5LCBjb250ZXh0KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IHBhdGhEZXRhaWxzID0gc2NoZW1hLl9nZXRQYXRoVHlwZShjaGVja1BhdGgpO1xuXG4gICAgICAvLyBJZiBubyBzY2hlbWEgdHlwZSwgY2hlY2sgZm9yIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3JzIGJlY2F1c2UgdGhlXG4gICAgICAvLyBmaWx0ZXIgb3IgdXBkYXRlIG1heSBpbXBseSBhbiBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIHR5cGUuIFNlZSAjODM3OFxuICAgICAgaWYgKHNjaGVtYXR5cGUgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBfcmVzID0gZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aChzY2hlbWEsIG9iaiwgZmlsdGVyLCBjaGVja1BhdGgsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoX3Jlcy5zY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICBzY2hlbWF0eXBlID0gX3Jlcy5zY2hlbWF0eXBlO1xuICAgICAgICAgIHBhdGhEZXRhaWxzID0gX3Jlcy50eXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBpc1N0cmljdCA9IHN0cmljdDtcbiAgICAgIGlmIChwYXRoRGV0YWlscyAmJiBwYXRoRGV0YWlscy5zY2hlbWEgJiYgc3RyaWN0ID09IG51bGwpIHtcbiAgICAgICAgaXNTdHJpY3QgPSBwYXRoRGV0YWlscy5zY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNraXAgPSBpc1N0cmljdCAmJlxuICAgICAgICAhc2NoZW1hdHlwZSAmJlxuICAgICAgICAhL3JlYWx8bmVzdGVkLy50ZXN0KHBhdGhEZXRhaWxzLnBhdGhUeXBlKTtcblxuICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgLy8gRXZlbiBpZiBzdHJpY3QgaXMgYHRocm93YCwgYXZvaWQgdGhyb3dpbmcgYW4gZXJyb3IgYmVjYXVzZSBvZlxuICAgICAgICAvLyB2aXJ0dWFscyBiZWNhdXNlIG9mICM2NzMxXG4gICAgICAgIGlmIChpc1N0cmljdCA9PT0gJ3Rocm93JyAmJiBzY2hlbWEudmlydHVhbHNbY2hlY2tQYXRoXSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcihwcmVmaXggKyBrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2gtMTg0NSB0ZW1wb3JhcnkgZml4OiBpZ25vcmUgJHJlbmFtZS4gU2VlIGdoLTMwMjcgZm9yIHRyYWNraW5nXG4gICAgICAgIC8vIGltcHJvdmluZyB0aGlzLlxuICAgICAgICBpZiAob3AgPT09ICckcmVuYW1lJykge1xuICAgICAgICAgIGhhc0tleXMgPSB0cnVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocHJlZml4Lmxlbmd0aCA9PT0gMCB8fCBrZXkuaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBjYXN0VXBkYXRlVmFsKHNjaGVtYXR5cGUsIHZhbCwgb3AsIGtleSwgY29udGV4dCwgcHJlZml4ICsga2V5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0ICE9PSBmYWxzZSB8fCBzY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgYSBuZXN0ZWQgZG90dGVkIHBhdGggdGhhdCdzIGluIHRoZSBzY2hlbWEuIFdlIGRvbid0IGFsbG93IHBhdGhzIHdpdGggJy4nIGluXG4gICAgICAgICAgICAvLyBhIHNjaGVtYSwgc28gcmVwbGFjZSB0aGUgZG90dGVkIHBhdGggd2l0aCBhIG5lc3RlZCBvYmplY3QgdG8gYXZvaWQgZW5kaW5nIHVwIHdpdGhcbiAgICAgICAgICAgIC8vIGRvdHRlZCBwcm9wZXJ0aWVzIGluIHRoZSB1cGRhdGVkIG9iamVjdC4gU2VlIChnaC0xMDIwMClcbiAgICAgICAgICAgIHNldERvdHRlZFBhdGgob2JqLCBrZXksIGNhc3RVcGRhdGVWYWwoc2NoZW1hdHlwZSwgdmFsLCBvcCwga2V5LCBjb250ZXh0LCBwcmVmaXggKyBrZXkpKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVycm9yLCBjb250ZXh0LCBrZXksIGFnZ3JlZ2F0ZWRFcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba2V5XSkgJiYgKG9wID09PSAnJGFkZFRvU2V0JyB8fCBvcCA9PT0gJyRwdXNoJykgJiYga2V5ICE9PSAnJGVhY2gnKSB7XG4gICAgICAgICAgaWYgKHNjaGVtYXR5cGUgJiZcbiAgICAgICAgICAgICAgc2NoZW1hdHlwZS5jYXN0ZXIgJiZcbiAgICAgICAgICAgICAgIXNjaGVtYXR5cGUuY2FzdGVyLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgICAgICAgICAgIXNjaGVtYXR5cGUuY2FzdGVyW3NjaGVtYU1peGVkU3ltYm9sXSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB7ICRlYWNoOiBvYmpba2V5XSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmpba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFnZ3JlZ2F0ZWRFcnJvciAhPSBudWxsKSB7XG4gICAgdGhyb3cgYWdncmVnYXRlZEVycm9yO1xuICB9XG5cbiAgcmV0dXJuIGhhc0tleXM7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2FwcGVuZEVycm9yKGVycm9yLCBxdWVyeSwga2V5LCBhZ2dyZWdhdGVkRXJyb3IpIHtcbiAgaWYgKHR5cGVvZiBxdWVyeSAhPT0gJ29iamVjdCcgfHwgIXF1ZXJ5Lm9wdGlvbnMubXVsdGlwbGVDYXN0RXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBhZ2dyZWdhdGVkRXJyb3IgPSBhZ2dyZWdhdGVkRXJyb3IgfHwgbmV3IFZhbGlkYXRpb25FcnJvcigpO1xuICBhZ2dyZWdhdGVkRXJyb3IuYWRkRXJyb3Ioa2V5LCBlcnJvcik7XG4gIHJldHVybiBhZ2dyZWdhdGVkRXJyb3I7XG59XG5cbi8qKlxuICogVGhlc2Ugb3BlcmF0b3JzIHNob3VsZCBiZSBjYXN0IHRvIG51bWJlcnMgaW5zdGVhZFxuICogb2YgdGhlaXIgcGF0aCBzY2hlbWEgdHlwZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IG51bWJlck9wcyA9IHtcbiAgJHBvcDogMSxcbiAgJGluYzogMVxufTtcblxuLyoqXG4gKiBUaGVzZSBvcHMgcmVxdWlyZSBubyBjYXN0aW5nIGJlY2F1c2UgdGhlIFJIUyBkb2Vzbid0IGRvIGFueXRoaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuY29uc3Qgbm9DYXN0T3BzID0ge1xuICAkdW5zZXQ6IDFcbn07XG5cbi8qKlxuICogVGhlc2Ugb3BlcmF0b3JzIHJlcXVpcmUgY2FzdGluZyBkb2NzXG4gKiB0byByZWFsIERvY3VtZW50cyBmb3IgVXBkYXRlIG9wZXJhdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jb25zdCBjYXN0T3BzID0ge1xuICAkcHVzaDogMSxcbiAgJGFkZFRvU2V0OiAxLFxuICAkc2V0OiAxLFxuICAkc2V0T25JbnNlcnQ6IDFcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3Qgb3ZlcndyaXRlT3BzID0ge1xuICAkc2V0OiAxLFxuICAkc2V0T25JbnNlcnQ6IDFcbn07XG5cbi8qKlxuICogQ2FzdHMgYHZhbGAgYWNjb3JkaW5nIHRvIGBzY2hlbWFgIGFuZCBhdG9taWMgYG9wYC5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYVR5cGV9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHBhcmFtIHtTdHJpbmd9IG9wIHRoZSBhdG9taWMgb3BlcmF0b3IgKCRwdWxsLCAkc2V0LCBldGMpXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge1F1ZXJ5fSBjb250ZXh0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY2FzdFVwZGF0ZVZhbChzY2hlbWEsIHZhbCwgb3AsICRjb25kaXRpb25hbCwgY29udGV4dCwgcGF0aCkge1xuICBpZiAoIXNjaGVtYSkge1xuICAgIC8vIG5vbi1leGlzdGluZyBzY2hlbWEgcGF0aFxuICAgIGlmIChvcCBpbiBudW1iZXJPcHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYXN0TnVtYmVyKHZhbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignbnVtYmVyJywgdmFsLCBwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKCdDYXN0VXBkYXRlVmFsJywgcGF0aCwgb3AsIHZhbCwgc2NoZW1hKTtcblxuICBjb25zdCBjb25kID0gc2NoZW1hLmNhc3RlciAmJiBvcCBpbiBjYXN0T3BzICYmXG4gICAgICAodXRpbHMuaXNPYmplY3QodmFsKSB8fCBBcnJheS5pc0FycmF5KHZhbCkpO1xuICBpZiAoY29uZCAmJiAhb3ZlcndyaXRlT3BzW29wXSkge1xuICAgIC8vIENhc3QgdmFsdWVzIGZvciBvcHMgdGhhdCBhZGQgZGF0YSB0byBNb25nb0RCLlxuICAgIC8vIEVuc3VyZXMgZW1iZWRkZWQgZG9jdW1lbnRzIGdldCBPYmplY3RJZHMgZXRjLlxuICAgIGxldCBzY2hlbWFBcnJheURlcHRoID0gMDtcbiAgICBsZXQgY3VyID0gc2NoZW1hO1xuICAgIHdoaWxlIChjdXIuJGlzTW9uZ29vc2VBcnJheSkge1xuICAgICAgKytzY2hlbWFBcnJheURlcHRoO1xuICAgICAgY3VyID0gY3VyLmNhc3RlcjtcbiAgICB9XG4gICAgbGV0IGFycmF5RGVwdGggPSAwO1xuICAgIGxldCBfdmFsID0gdmFsO1xuICAgIHdoaWxlIChBcnJheS5pc0FycmF5KF92YWwpKSB7XG4gICAgICArK2FycmF5RGVwdGg7XG4gICAgICBfdmFsID0gX3ZhbFswXTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRpdGlvbmFsTmVzdGluZyA9IHNjaGVtYUFycmF5RGVwdGggLSBhcnJheURlcHRoO1xuICAgIHdoaWxlIChhcnJheURlcHRoIDwgc2NoZW1hQXJyYXlEZXB0aCkge1xuICAgICAgdmFsID0gW3ZhbF07XG4gICAgICArK2FycmF5RGVwdGg7XG4gICAgfVxuXG4gICAgbGV0IHRtcCA9IHNjaGVtYS5hcHBseVNldHRlcnMoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0sIGNvbnRleHQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRpdGlvbmFsTmVzdGluZzsgKytpKSB7XG4gICAgICB0bXAgPSB0bXBbMF07XG4gICAgfVxuICAgIHJldHVybiB0bXA7XG4gIH1cblxuICBpZiAob3AgaW4gbm9DYXN0T3BzKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAob3AgaW4gbnVtYmVyT3BzKSB7XG4gICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIG5vdCBhbGxvd2VkIGZvciAkcG9wLCAkaW5jXG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdudW1iZXInLCB2YWwsIHNjaGVtYS5wYXRoKTtcbiAgICB9XG4gICAgaWYgKG9wID09PSAnJGluYycpIHtcbiAgICAgIC8vIFN1cHBvcnQgYCRpbmNgIHdpdGggbG9uZywgaW50MzIsIGV0Yy4gKGdoLTQyODMpXG4gICAgICByZXR1cm4gc2NoZW1hLmNhc3RGb3JRdWVyeShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdmFsLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhc3ROdW1iZXIodmFsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignbnVtYmVyJywgdmFsLCBzY2hlbWEucGF0aCk7XG4gICAgfVxuICB9XG4gIGlmIChvcCA9PT0gJyRjdXJyZW50RGF0ZScpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB7ICR0eXBlOiB2YWwuJHR5cGUgfTtcbiAgICB9XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsKTtcbiAgfVxuXG4gIGlmIChtb25nb2RiVXBkYXRlT3BlcmF0b3JzLmhhcygkY29uZGl0aW9uYWwpKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5jYXN0Rm9yUXVlcnkoXG4gICAgICAkY29uZGl0aW9uYWwsXG4gICAgICB2YWwsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxuXG4gIGlmIChvdmVyd3JpdGVPcHNbb3BdKSB7XG4gICAgY29uc3Qgc2tpcFF1ZXJ5Q2FzdEZvclVwZGF0ZSA9IHZhbCAhPSBudWxsICYmIHNjaGVtYS4kaXNNb25nb29zZUFycmF5ICYmIHNjaGVtYS4kZnVsbFBhdGggIT0gbnVsbCAmJiAhc2NoZW1hLiRmdWxsUGF0aC5tYXRjaCgvXFxkKyQvKTtcbiAgICBjb25zdCBhcHBseVNldHRlcnMgPSBzY2hlbWFbc2NoZW1hTWl4ZWRTeW1ib2xdICE9IG51bGw7XG4gICAgaWYgKHNraXBRdWVyeUNhc3RGb3JVcGRhdGUgfHwgYXBwbHlTZXR0ZXJzKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLmFwcGx5U2V0dGVycyh2YWwsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hLmNhc3RGb3JRdWVyeShcbiAgICAgIG51bGwsXG4gICAgICB2YWwsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWEuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbCwgY29udGV4dCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/castUpdate.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/completeMany.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/completeMany.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst helpers = __webpack_require__(/*! ../../queryhelpers */ \"(api)/../server/node_modules/mongoose/lib/queryhelpers.js\");\n\nmodule.exports = completeMany;\n\n/**\n * Given a model and an array of docs, hydrates all the docs to be instances\n * of the model. Used to initialize docs returned from the db from `find()`\n *\n * @param {Model} model\n * @param {Array} docs\n * @param {Object} fields the projection used, including `select` from schemas\n * @param {Object} userProvidedFields the user-specified projection\n * @param {Object} [opts]\n * @param {Array} [opts.populated]\n * @param {ClientSession} [opts.session]\n * @param {Function} callback\n * @api private\n */\n\nasync function completeMany(model, docs, fields, userProvidedFields, opts) {\n  return Promise.all(docs.map(doc => new Promise((resolve, reject) => {\n    const rawDoc = doc;\n    doc = helpers.createModel(model, doc, fields, userProvidedFields);\n    if (opts.session != null) {\n      doc.$session(opts.session);\n    }\n    doc.$init(rawDoc, opts, (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(doc);\n    });\n  })));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9jb21wbGV0ZU1hbnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMscUZBQW9COztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccXVlcnlcXGNvbXBsZXRlTWFueS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGhlbHBlcnMgPSByZXF1aXJlKCcuLi8uLi9xdWVyeWhlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wbGV0ZU1hbnk7XG5cbi8qKlxuICogR2l2ZW4gYSBtb2RlbCBhbmQgYW4gYXJyYXkgb2YgZG9jcywgaHlkcmF0ZXMgYWxsIHRoZSBkb2NzIHRvIGJlIGluc3RhbmNlc1xuICogb2YgdGhlIG1vZGVsLiBVc2VkIHRvIGluaXRpYWxpemUgZG9jcyByZXR1cm5lZCBmcm9tIHRoZSBkYiBmcm9tIGBmaW5kKClgXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7QXJyYXl9IGRvY3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHMgdGhlIHByb2plY3Rpb24gdXNlZCwgaW5jbHVkaW5nIGBzZWxlY3RgIGZyb20gc2NoZW1hc1xuICogQHBhcmFtIHtPYmplY3R9IHVzZXJQcm92aWRlZEZpZWxkcyB0aGUgdXNlci1zcGVjaWZpZWQgcHJvamVjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICogQHBhcmFtIHtBcnJheX0gW29wdHMucG9wdWxhdGVkXVxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0cy5zZXNzaW9uXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGNvbXBsZXRlTWFueShtb2RlbCwgZG9jcywgZmllbGRzLCB1c2VyUHJvdmlkZWRGaWVsZHMsIG9wdHMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKGRvY3MubWFwKGRvYyA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmF3RG9jID0gZG9jO1xuICAgIGRvYyA9IGhlbHBlcnMuY3JlYXRlTW9kZWwobW9kZWwsIGRvYywgZmllbGRzLCB1c2VyUHJvdmlkZWRGaWVsZHMpO1xuICAgIGlmIChvcHRzLnNlc3Npb24gIT0gbnVsbCkge1xuICAgICAgZG9jLiRzZXNzaW9uKG9wdHMuc2Vzc2lvbik7XG4gICAgfVxuICAgIGRvYy4kaW5pdChyYXdEb2MsIG9wdHMsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKGRvYyk7XG4gICAgfSk7XG4gIH0pKSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/completeMany.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js":
/*!*****************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst cleanPositionalOperators = __webpack_require__(/*! ../schema/cleanPositionalOperators */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst updatedPathsByArrayFilter = __webpack_require__(/*! ../update/updatedPathsByArrayFilter */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js\");\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n * @param {Schema} schema\n * @param {Object} [update]\n * @param {Object} [filter]\n * @param {String} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\n  const parts = path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n\n  filter = filter || {};\n  update = update || {};\n  const arrayFilters = options != null && Array.isArray(options.arrayFilters) ?\n    options.arrayFilters : [];\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join('.'));\n    schematype = schema.path(subpath);\n    if (schematype == null) {\n      continue;\n    }\n\n    type = schema.pathType(subpath);\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) &&\n        schematype.schema.discriminators != null) {\n      const key = get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorValuePath = subpath + '.' + key;\n      const discriminatorFilterPath =\n        discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\n      if (schematype.$isMongooseDocumentArrayElement &&\n          get(filter[wrapperPath], '$elemMatch.' + key) != null) {\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\n      }\n\n      if (discriminatorValuePath in update) {\n        discriminatorKey = update[discriminatorValuePath];\n      }\n\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\n        const arrayFilterKey = filterKey + '.' + key;\n        if (schemaKey === discriminatorFilterPath) {\n          const filter = arrayFilters.find(filter => filter.hasOwnProperty(arrayFilterKey));\n          if (filter != null) {\n            discriminatorKey = filter[arrayFilterKey];\n          }\n        }\n      }\n\n      if (discriminatorKey == null) {\n        continue;\n      }\n\n      const discriminator = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey);\n      const discriminatorSchema = discriminator && discriminator.schema;\n      if (discriminatorSchema == null) {\n        continue;\n      }\n\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminatorSchema.path(rest);\n      if (schematype != null) {\n        type = discriminatorSchema._getPathType(rest);\n        break;\n      }\n    }\n  }\n\n  return { type: type, schematype: schematype };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9nZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGlDQUFpQyxtQkFBTyxDQUFDLGdJQUFvQztBQUM3RSxZQUFZLG1CQUFPLENBQUMsd0VBQVE7QUFDNUIsZ0NBQWdDLG1CQUFPLENBQUMsNElBQTBDO0FBQ2xGLGtDQUFrQyxtQkFBTyxDQUFDLGtJQUFxQzs7QUFFL0U7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccXVlcnlcXGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMgPSByZXF1aXJlKCcuLi9zY2hlbWEvY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgdXBkYXRlZFBhdGhzQnlBcnJheUZpbHRlciA9IHJlcXVpcmUoJy4uL3VwZGF0ZS91cGRhdGVkUGF0aHNCeUFycmF5RmlsdGVyJyk7XG5cbi8qKlxuICogTGlrZSBgc2NoZW1hLnBhdGgoKWAsIGV4Y2VwdCB3aXRoIGEgZG9jdW1lbnQsIGJlY2F1c2UgaW1wb3NzaWJsZSB0b1xuICogZGV0ZXJtaW5lIHBhdGggdHlwZSB3aXRob3V0IGtub3dpbmcgdGhlIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3Iga2V5LlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IFt1cGRhdGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGgoc2NoZW1hLCB1cGRhdGUsIGZpbHRlciwgcGF0aCwgb3B0aW9ucykge1xuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgbGV0IHNjaGVtYXR5cGUgPSBudWxsO1xuICBsZXQgdHlwZSA9ICdhZGhvY09yVW5kZWZpbmVkJztcblxuICBmaWx0ZXIgPSBmaWx0ZXIgfHwge307XG4gIHVwZGF0ZSA9IHVwZGF0ZSB8fCB7fTtcbiAgY29uc3QgYXJyYXlGaWx0ZXJzID0gb3B0aW9ucyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5hcnJheUZpbHRlcnMpID9cbiAgICBvcHRpb25zLmFycmF5RmlsdGVycyA6IFtdO1xuICBjb25zdCB1cGRhdGVkUGF0aHNCeUZpbHRlciA9IHVwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXIodXBkYXRlKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qgc3VicGF0aCA9IGNsZWFuUG9zaXRpb25hbE9wZXJhdG9ycyhwYXJ0cy5zbGljZSgwLCBpICsgMSkuam9pbignLicpKTtcbiAgICBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGgoc3VicGF0aCk7XG4gICAgaWYgKHNjaGVtYXR5cGUgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdHlwZSA9IHNjaGVtYS5wYXRoVHlwZShzdWJwYXRoKTtcbiAgICBpZiAoKHNjaGVtYXR5cGUuJGlzU2luZ2xlTmVzdGVkIHx8IHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCkgJiZcbiAgICAgICAgc2NoZW1hdHlwZS5zY2hlbWEuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5ID0gZ2V0KHNjaGVtYXR5cGUsICdzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5Jyk7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVQYXRoID0gc3VicGF0aCArICcuJyArIGtleTtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JGaWx0ZXJQYXRoID1cbiAgICAgICAgZGlzY3JpbWluYXRvclZhbHVlUGF0aC5yZXBsYWNlKC9cXC5cXGQrXFwuLywgJy4nKTtcbiAgICAgIGxldCBkaXNjcmltaW5hdG9yS2V5ID0gbnVsbDtcblxuICAgICAgaWYgKGRpc2NyaW1pbmF0b3JWYWx1ZVBhdGggaW4gZmlsdGVyKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JLZXkgPSBmaWx0ZXJbZGlzY3JpbWluYXRvclZhbHVlUGF0aF07XG4gICAgICB9XG4gICAgICBpZiAoZGlzY3JpbWluYXRvckZpbHRlclBhdGggaW4gZmlsdGVyKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JLZXkgPSBmaWx0ZXJbZGlzY3JpbWluYXRvckZpbHRlclBhdGhdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3cmFwcGVyUGF0aCA9IHN1YnBhdGgucmVwbGFjZSgvXFwuXFxkKyQvLCAnJyk7XG4gICAgICBpZiAoc2NoZW1hdHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXlFbGVtZW50ICYmXG4gICAgICAgICAgZ2V0KGZpbHRlclt3cmFwcGVyUGF0aF0sICckZWxlbU1hdGNoLicgKyBrZXkpICE9IG51bGwpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvcktleSA9IGZpbHRlclt3cmFwcGVyUGF0aF0uJGVsZW1NYXRjaFtrZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlzY3JpbWluYXRvclZhbHVlUGF0aCBpbiB1cGRhdGUpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvcktleSA9IHVwZGF0ZVtkaXNjcmltaW5hdG9yVmFsdWVQYXRoXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBmaWx0ZXJLZXkgb2YgT2JqZWN0LmtleXModXBkYXRlZFBhdGhzQnlGaWx0ZXIpKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYUtleSA9IHVwZGF0ZWRQYXRoc0J5RmlsdGVyW2ZpbHRlcktleV0gKyAnLicgKyBrZXk7XG4gICAgICAgIGNvbnN0IGFycmF5RmlsdGVyS2V5ID0gZmlsdGVyS2V5ICsgJy4nICsga2V5O1xuICAgICAgICBpZiAoc2NoZW1hS2V5ID09PSBkaXNjcmltaW5hdG9yRmlsdGVyUGF0aCkge1xuICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGFycmF5RmlsdGVycy5maW5kKGZpbHRlciA9PiBmaWx0ZXIuaGFzT3duUHJvcGVydHkoYXJyYXlGaWx0ZXJLZXkpKTtcbiAgICAgICAgICBpZiAoZmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3JLZXkgPSBmaWx0ZXJbYXJyYXlGaWx0ZXJLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlzY3JpbWluYXRvcktleSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUoc2NoZW1hdHlwZS5jYXN0ZXIuZGlzY3JpbWluYXRvcnMsIGRpc2NyaW1pbmF0b3JLZXkpO1xuICAgICAgY29uc3QgZGlzY3JpbWluYXRvclNjaGVtYSA9IGRpc2NyaW1pbmF0b3IgJiYgZGlzY3JpbWluYXRvci5zY2hlbWE7XG4gICAgICBpZiAoZGlzY3JpbWluYXRvclNjaGVtYSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN0ID0gcGFydHMuc2xpY2UoaSArIDEpLmpvaW4oJy4nKTtcbiAgICAgIHNjaGVtYXR5cGUgPSBkaXNjcmltaW5hdG9yU2NoZW1hLnBhdGgocmVzdCk7XG4gICAgICBpZiAoc2NoZW1hdHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHR5cGUgPSBkaXNjcmltaW5hdG9yU2NoZW1hLl9nZXRQYXRoVHlwZShyZXN0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgc2NoZW1hdHlwZTogc2NoZW1hdHlwZSB9O1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/handleImmutable.js":
/*!****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/handleImmutable.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"(api)/../server/node_modules/mongoose/lib/error/strict.js\");\n\nmodule.exports = function handleImmutable(schematype, strict, obj, key, fullPath, ctx) {\n  if (schematype == null || !schematype.options || !schematype.options.immutable) {\n    return false;\n  }\n  let immutable = schematype.options.immutable;\n\n  if (typeof immutable === 'function') {\n    immutable = immutable.call(ctx, ctx);\n  }\n  if (!immutable) {\n    return false;\n  }\n\n  if (strict === false) {\n    return false;\n  }\n  if (strict === 'throw') {\n    throw new StrictModeError(null,\n      `Field ${fullPath} is immutable and strict = 'throw'`);\n  }\n\n  delete obj[key];\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9oYW5kbGVJbW11dGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsd0JBQXdCLG1CQUFPLENBQUMscUZBQW9COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHF1ZXJ5XFxoYW5kbGVJbW11dGFibGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTdHJpY3RNb2RlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9zdHJpY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYW5kbGVJbW11dGFibGUoc2NoZW1hdHlwZSwgc3RyaWN0LCBvYmosIGtleSwgZnVsbFBhdGgsIGN0eCkge1xuICBpZiAoc2NoZW1hdHlwZSA9PSBudWxsIHx8ICFzY2hlbWF0eXBlLm9wdGlvbnMgfHwgIXNjaGVtYXR5cGUub3B0aW9ucy5pbW11dGFibGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGltbXV0YWJsZSA9IHNjaGVtYXR5cGUub3B0aW9ucy5pbW11dGFibGU7XG5cbiAgaWYgKHR5cGVvZiBpbW11dGFibGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbW11dGFibGUgPSBpbW11dGFibGUuY2FsbChjdHgsIGN0eCk7XG4gIH1cbiAgaWYgKCFpbW11dGFibGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RyaWN0ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc3RyaWN0ID09PSAndGhyb3cnKSB7XG4gICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcihudWxsLFxuICAgICAgYEZpZWxkICR7ZnVsbFBhdGh9IGlzIGltbXV0YWJsZSBhbmQgc3RyaWN0ID0gJ3Rocm93J2ApO1xuICB9XG5cbiAgZGVsZXRlIG9ialtrZXldO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/handleImmutable.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js":
/*!****************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function handleReadPreferenceAliases(pref) {\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return pref;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9oYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxxdWVyeVxcaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMocHJlZikge1xuICBzd2l0Y2ggKHByZWYpIHtcbiAgICBjYXNlICdwJzpcbiAgICAgIHByZWYgPSAncHJpbWFyeSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcCc6XG4gICAgICBwcmVmID0gJ3ByaW1hcnlQcmVmZXJyZWQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncyc6XG4gICAgICBwcmVmID0gJ3NlY29uZGFyeSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzcCc6XG4gICAgICBwcmVmID0gJ3NlY29uZGFyeVByZWZlcnJlZCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICduJzpcbiAgICAgIHByZWYgPSAnbmVhcmVzdCc7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBwcmVmO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function hasDollarKeys(obj) {\n\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (keys[i][0] === '$') {\n      return true;\n    }\n  }\n\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9oYXNEb2xsYXJLZXlzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccXVlcnlcXGhhc0RvbGxhcktleXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzRG9sbGFyS2V5cyhvYmopIHtcblxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoa2V5c1tpXVswXSA9PT0gJyQnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/isOperator.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/isOperator.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst specialKeys = new Set([\n  '$ref',\n  '$id',\n  '$db'\n]);\n\nmodule.exports = function isOperator(path) {\n  return (\n    path[0] === '$' &&\n    !specialKeys.has(path)\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9pc09wZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccXVlcnlcXGlzT3BlcmF0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzcGVjaWFsS2V5cyA9IG5ldyBTZXQoW1xuICAnJHJlZicsXG4gICckaWQnLFxuICAnJGRiJ1xuXSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNPcGVyYXRvcihwYXRoKSB7XG4gIHJldHVybiAoXG4gICAgcGF0aFswXSA9PT0gJyQnICYmXG4gICAgIXNwZWNpYWxLZXlzLmhhcyhwYXRoKVxuICApO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/isOperator.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst hasDollarKeys = __webpack_require__(/*! ./hasDollarKeys */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\");\nconst { trustedSymbol } = __webpack_require__(/*! ./trusted */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/trusted.js\");\n\nmodule.exports = function sanitizeFilter(filter) {\n  if (filter == null || typeof filter !== 'object') {\n    return filter;\n  }\n  if (Array.isArray(filter)) {\n    for (const subfilter of filter) {\n      sanitizeFilter(subfilter);\n    }\n    return filter;\n  }\n\n  const filterKeys = Object.keys(filter);\n  for (const key of filterKeys) {\n    const value = filter[key];\n    if (value != null && value[trustedSymbol]) {\n      continue;\n    }\n    if (key === '$and' || key === '$or') {\n      sanitizeFilter(value);\n      continue;\n    }\n\n    if (hasDollarKeys(value)) {\n      const keys = Object.keys(value);\n      if (keys.length === 1 && keys[0] === '$eq') {\n        continue;\n      }\n      filter[key] = { $eq: filter[key] };\n    }\n  }\n\n  return filter;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9zYW5pdGl6ZUZpbHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxpR0FBaUI7QUFDL0MsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLHFGQUFXOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHF1ZXJ5XFxzYW5pdGl6ZUZpbHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGhhc0RvbGxhcktleXMgPSByZXF1aXJlKCcuL2hhc0RvbGxhcktleXMnKTtcbmNvbnN0IHsgdHJ1c3RlZFN5bWJvbCB9ID0gcmVxdWlyZSgnLi90cnVzdGVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2FuaXRpemVGaWx0ZXIoZmlsdGVyKSB7XG4gIGlmIChmaWx0ZXIgPT0gbnVsbCB8fCB0eXBlb2YgZmlsdGVyICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyKSkge1xuICAgIGZvciAoY29uc3Qgc3ViZmlsdGVyIG9mIGZpbHRlcikge1xuICAgICAgc2FuaXRpemVGaWx0ZXIoc3ViZmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuXG4gIGNvbnN0IGZpbHRlcktleXMgPSBPYmplY3Qua2V5cyhmaWx0ZXIpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBmaWx0ZXJLZXlzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBmaWx0ZXJba2V5XTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZVt0cnVzdGVkU3ltYm9sXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChrZXkgPT09ICckYW5kJyB8fCBrZXkgPT09ICckb3InKSB7XG4gICAgICBzYW5pdGl6ZUZpbHRlcih2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzRG9sbGFyS2V5cyh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJyRlcScpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmaWx0ZXJba2V5XSA9IHsgJGVxOiBmaWx0ZXJba2V5XSB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWx0ZXI7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function sanitizeProjection(projection) {\n  if (projection == null) {\n    return;\n  }\n\n  const keys = Object.keys(projection);\n  for (let i = 0; i < keys.length; ++i) {\n    if (typeof projection[keys[i]] === 'string') {\n      projection[keys[i]] = 1;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9zYW5pdGl6ZVByb2plY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxxdWVyeVxcc2FuaXRpemVQcm9qZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzYW5pdGl6ZVByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb2plY3Rpb24pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIHByb2plY3Rpb25ba2V5c1tpXV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBwcm9qZWN0aW9uW2tleXNbaV1dID0gMTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js":
/*!**********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isExclusive = __webpack_require__(/*! ../projection/isExclusive */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst isInclusive = __webpack_require__(/*! ../projection/isInclusive */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isInclusive.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {\n  if (populateOptions == null) {\n    return;\n  }\n\n  const paths = Object.keys(populateOptions);\n  userProvidedFields = userProvidedFields || {};\n  if (isInclusive(fields)) {\n    for (const path of paths) {\n      if (!isPathInFields(userProvidedFields, path)) {\n        fields[path] = 1;\n      } else if (userProvidedFields[path] === 0) {\n        delete fields[path];\n      }\n\n      const refPath = populateOptions[path]?.refPath;\n      if (typeof refPath === 'string') {\n        if (!isPathInFields(userProvidedFields, refPath)) {\n          fields[refPath] = 1;\n        } else if (userProvidedFields[refPath] === 0) {\n          delete fields[refPath];\n        }\n      }\n    }\n  } else if (isExclusive(fields)) {\n    for (const path of paths) {\n      if (userProvidedFields[path] == null) {\n        delete fields[path];\n      }\n      const refPath = populateOptions[path]?.refPath;\n      if (typeof refPath === 'string' && userProvidedFields[refPath] == null) {\n        delete fields[refPath];\n      }\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction isPathInFields(userProvidedFields, path) {\n  const pieces = path.split('.');\n  const len = pieces.length;\n  let cur = pieces[0];\n  for (let i = 1; i < len; ++i) {\n    if (userProvidedFields[cur] != null || userProvidedFields[cur + '.$'] != null) {\n      return true;\n    }\n    cur += '.' + pieces[i];\n  }\n  return userProvidedFields[cur] != null || userProvidedFields[cur + '.$'] != null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9zZWxlY3RQb3B1bGF0ZWRGaWVsZHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsOEdBQTJCO0FBQ3ZELG9CQUFvQixtQkFBTyxDQUFDLDhHQUEyQjs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxxdWVyeVxcc2VsZWN0UG9wdWxhdGVkRmllbGRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNFeGNsdXNpdmUgPSByZXF1aXJlKCcuLi9wcm9qZWN0aW9uL2lzRXhjbHVzaXZlJyk7XG5jb25zdCBpc0luY2x1c2l2ZSA9IHJlcXVpcmUoJy4uL3Byb2plY3Rpb24vaXNJbmNsdXNpdmUnKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNlbGVjdFBvcHVsYXRlZEZpZWxkcyhmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgcG9wdWxhdGVPcHRpb25zKSB7XG4gIGlmIChwb3B1bGF0ZU9wdGlvbnMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMocG9wdWxhdGVPcHRpb25zKTtcbiAgdXNlclByb3ZpZGVkRmllbGRzID0gdXNlclByb3ZpZGVkRmllbGRzIHx8IHt9O1xuICBpZiAoaXNJbmNsdXNpdmUoZmllbGRzKSkge1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgaWYgKCFpc1BhdGhJbkZpZWxkcyh1c2VyUHJvdmlkZWRGaWVsZHMsIHBhdGgpKSB7XG4gICAgICAgIGZpZWxkc1twYXRoXSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHVzZXJQcm92aWRlZEZpZWxkc1twYXRoXSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgZmllbGRzW3BhdGhdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWZQYXRoID0gcG9wdWxhdGVPcHRpb25zW3BhdGhdPy5yZWZQYXRoO1xuICAgICAgaWYgKHR5cGVvZiByZWZQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIWlzUGF0aEluRmllbGRzKHVzZXJQcm92aWRlZEZpZWxkcywgcmVmUGF0aCkpIHtcbiAgICAgICAgICBmaWVsZHNbcmVmUGF0aF0gPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHVzZXJQcm92aWRlZEZpZWxkc1tyZWZQYXRoXSA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBmaWVsZHNbcmVmUGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFeGNsdXNpdmUoZmllbGRzKSkge1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgaWYgKHVzZXJQcm92aWRlZEZpZWxkc1twYXRoXSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBmaWVsZHNbcGF0aF07XG4gICAgICB9XG4gICAgICBjb25zdCByZWZQYXRoID0gcG9wdWxhdGVPcHRpb25zW3BhdGhdPy5yZWZQYXRoO1xuICAgICAgaWYgKHR5cGVvZiByZWZQYXRoID09PSAnc3RyaW5nJyAmJiB1c2VyUHJvdmlkZWRGaWVsZHNbcmVmUGF0aF0gPT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgZmllbGRzW3JlZlBhdGhdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBpc1BhdGhJbkZpZWxkcyh1c2VyUHJvdmlkZWRGaWVsZHMsIHBhdGgpIHtcbiAgY29uc3QgcGllY2VzID0gcGF0aC5zcGxpdCgnLicpO1xuICBjb25zdCBsZW4gPSBwaWVjZXMubGVuZ3RoO1xuICBsZXQgY3VyID0gcGllY2VzWzBdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHVzZXJQcm92aWRlZEZpZWxkc1tjdXJdICE9IG51bGwgfHwgdXNlclByb3ZpZGVkRmllbGRzW2N1ciArICcuJCddICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjdXIgKz0gJy4nICsgcGllY2VzW2ldO1xuICB9XG4gIHJldHVybiB1c2VyUHJvdmlkZWRGaWVsZHNbY3VyXSAhPSBudWxsIHx8IHVzZXJQcm92aWRlZEZpZWxkc1tjdXIgKyAnLiQnXSAhPSBudWxsO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/trusted.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/trusted.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nconst trustedSymbol = Symbol('mongoose#trustedSymbol');\n\nexports.trustedSymbol = trustedSymbol;\n\nexports.trusted = function trusted(obj) {\n  if (obj == null || typeof obj !== 'object') {\n    return obj;\n  }\n  obj[trustedSymbol] = true;\n  return obj;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS90cnVzdGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBLHFCQUFxQjs7QUFFckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHF1ZXJ5XFx0cnVzdGVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdHJ1c3RlZFN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjdHJ1c3RlZFN5bWJvbCcpO1xuXG5leHBvcnRzLnRydXN0ZWRTeW1ib2wgPSB0cnVzdGVkU3ltYm9sO1xuXG5leHBvcnRzLnRydXN0ZWQgPSBmdW5jdGlvbiB0cnVzdGVkKG9iaikge1xuICBpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIG9ialt0cnVzdGVkU3ltYm9sXSA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/trusted.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/query/validOps.js":
/*!*********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/query/validOps.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = Object.freeze([\n  // Read\n  'count',\n  'countDocuments',\n  'distinct',\n  'estimatedDocumentCount',\n  'find',\n  'findOne',\n  // Update\n  'findOneAndReplace',\n  'findOneAndUpdate',\n  'replaceOne',\n  'updateMany',\n  'updateOne',\n  // Delete\n  'deleteMany',\n  'deleteOne',\n  'findOneAndDelete',\n  'findOneAndRemove'\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS92YWxpZE9wcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xccXVlcnlcXHZhbGlkT3BzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKFtcbiAgLy8gUmVhZFxuICAnY291bnQnLFxuICAnY291bnREb2N1bWVudHMnLFxuICAnZGlzdGluY3QnLFxuICAnZXN0aW1hdGVkRG9jdW1lbnRDb3VudCcsXG4gICdmaW5kJyxcbiAgJ2ZpbmRPbmUnLFxuICAvLyBVcGRhdGVcbiAgJ2ZpbmRPbmVBbmRSZXBsYWNlJyxcbiAgJ2ZpbmRPbmVBbmRVcGRhdGUnLFxuICAncmVwbGFjZU9uZScsXG4gICd1cGRhdGVNYW55JyxcbiAgJ3VwZGF0ZU9uZScsXG4gIC8vIERlbGV0ZVxuICAnZGVsZXRlTWFueScsXG4gICdkZWxldGVPbmUnLFxuICAnZmluZE9uZUFuZERlbGV0ZScsXG4gICdmaW5kT25lQW5kUmVtb3ZlJ1xuXSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/query/validOps.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/addAutoId.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/addAutoId.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function addAutoId(schema) {\n  const _obj = { _id: { auto: true } };\n  _obj._id[schema.options.typeKey] = 'ObjectId';\n  schema.add(_obj);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvYWRkQXV0b0lkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcc2NoZW1hXFxhZGRBdXRvSWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZEF1dG9JZChzY2hlbWEpIHtcbiAgY29uc3QgX29iaiA9IHsgX2lkOiB7IGF1dG86IHRydWUgfSB9O1xuICBfb2JqLl9pZFtzY2hlbWEub3B0aW9ucy50eXBlS2V5XSA9ICdPYmplY3RJZCc7XG4gIHNjaGVtYS5hZGQoX29iaik7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/addAutoId.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst builtinPlugins = __webpack_require__(/*! ../../plugins */ \"(api)/../server/node_modules/mongoose/lib/plugins/index.js\");\n\nmodule.exports = function applyBuiltinPlugins(schema) {\n  for (const plugin of Object.values(builtinPlugins)) {\n    plugin(schema, { deduplicate: true });\n  }\n  schema.plugins = Object.values(builtinPlugins).\n    map(fn => ({ fn, opts: { deduplicate: true } })).\n    concat(schema.plugins);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvYXBwbHlCdWlsdGluUGx1Z2lucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix1QkFBdUIsbUJBQU8sQ0FBQyxpRkFBZTs7QUFFOUM7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBLGlCQUFpQixZQUFZLHFCQUFxQjtBQUNsRDtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcc2NoZW1hXFxhcHBseUJ1aWx0aW5QbHVnaW5zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYnVpbHRpblBsdWdpbnMgPSByZXF1aXJlKCcuLi8uLi9wbHVnaW5zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBwbHlCdWlsdGluUGx1Z2lucyhzY2hlbWEpIHtcbiAgZm9yIChjb25zdCBwbHVnaW4gb2YgT2JqZWN0LnZhbHVlcyhidWlsdGluUGx1Z2lucykpIHtcbiAgICBwbHVnaW4oc2NoZW1hLCB7IGRlZHVwbGljYXRlOiB0cnVlIH0pO1xuICB9XG4gIHNjaGVtYS5wbHVnaW5zID0gT2JqZWN0LnZhbHVlcyhidWlsdGluUGx1Z2lucykuXG4gICAgbWFwKGZuID0+ICh7IGZuLCBvcHRzOiB7IGRlZHVwbGljYXRlOiB0cnVlIH0gfSkpLlxuICAgIGNvbmNhdChzY2hlbWEucGx1Z2lucyk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/applyPlugins.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/applyPlugins.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function applyPlugins(schema, plugins, options, cacheKey) {\n  if (schema[cacheKey]) {\n    return;\n  }\n  schema[cacheKey] = true;\n\n  if (!options || !options.skipTopLevel) {\n    let pluginTags = null;\n    for (const plugin of plugins) {\n      const tags = plugin[1] == null ? null : plugin[1].tags;\n      if (!Array.isArray(tags)) {\n        schema.plugin(plugin[0], plugin[1]);\n        continue;\n      }\n\n      pluginTags = pluginTags || new Set(schema.options.pluginTags || []);\n      if (!tags.find(tag => pluginTags.has(tag))) {\n        continue;\n      }\n      schema.plugin(plugin[0], plugin[1]);\n    }\n  }\n\n  options = Object.assign({}, options);\n  delete options.skipTopLevel;\n\n  if (options.applyPluginsToChildSchemas !== false) {\n    for (const path of Object.keys(schema.paths)) {\n      const type = schema.paths[path];\n      if (type.schema != null) {\n        applyPlugins(type.schema, plugins, options, cacheKey);\n\n        // Recompile schema because plugins may have changed it, see gh-7572\n        type.caster.prototype.$__setSchema(type.schema);\n      }\n    }\n  }\n\n  const discriminators = schema.discriminators;\n  if (discriminators == null) {\n    return;\n  }\n\n  const applyPluginsToDiscriminators = options.applyPluginsToDiscriminators;\n\n  const keys = Object.keys(discriminators);\n  for (const discriminatorKey of keys) {\n    const discriminatorSchema = discriminators[discriminatorKey];\n\n    applyPlugins(discriminatorSchema, plugins,\n      { skipTopLevel: !applyPluginsToDiscriminators }, cacheKey);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvYXBwbHlQbHVnaW5zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsNkNBQTZDO0FBQ3JEO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxzY2hlbWFcXGFwcGx5UGx1Z2lucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBwbHlQbHVnaW5zKHNjaGVtYSwgcGx1Z2lucywgb3B0aW9ucywgY2FjaGVLZXkpIHtcbiAgaWYgKHNjaGVtYVtjYWNoZUtleV0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2NoZW1hW2NhY2hlS2V5XSA9IHRydWU7XG5cbiAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnNraXBUb3BMZXZlbCkge1xuICAgIGxldCBwbHVnaW5UYWdzID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICBjb25zdCB0YWdzID0gcGx1Z2luWzFdID09IG51bGwgPyBudWxsIDogcGx1Z2luWzFdLnRhZ3M7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpIHtcbiAgICAgICAgc2NoZW1hLnBsdWdpbihwbHVnaW5bMF0sIHBsdWdpblsxXSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwbHVnaW5UYWdzID0gcGx1Z2luVGFncyB8fCBuZXcgU2V0KHNjaGVtYS5vcHRpb25zLnBsdWdpblRhZ3MgfHwgW10pO1xuICAgICAgaWYgKCF0YWdzLmZpbmQodGFnID0+IHBsdWdpblRhZ3MuaGFzKHRhZykpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc2NoZW1hLnBsdWdpbihwbHVnaW5bMF0sIHBsdWdpblsxXSk7XG4gICAgfVxuICB9XG5cbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICBkZWxldGUgb3B0aW9ucy5za2lwVG9wTGV2ZWw7XG5cbiAgaWYgKG9wdGlvbnMuYXBwbHlQbHVnaW5zVG9DaGlsZFNjaGVtYXMgIT09IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocykpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEucGF0aHNbcGF0aF07XG4gICAgICBpZiAodHlwZS5zY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBhcHBseVBsdWdpbnModHlwZS5zY2hlbWEsIHBsdWdpbnMsIG9wdGlvbnMsIGNhY2hlS2V5KTtcblxuICAgICAgICAvLyBSZWNvbXBpbGUgc2NoZW1hIGJlY2F1c2UgcGx1Z2lucyBtYXkgaGF2ZSBjaGFuZ2VkIGl0LCBzZWUgZ2gtNzU3MlxuICAgICAgICB0eXBlLmNhc3Rlci5wcm90b3R5cGUuJF9fc2V0U2NoZW1hKHR5cGUuc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBkaXNjcmltaW5hdG9ycyA9IHNjaGVtYS5kaXNjcmltaW5hdG9ycztcbiAgaWYgKGRpc2NyaW1pbmF0b3JzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBhcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzID0gb3B0aW9ucy5hcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzO1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkaXNjcmltaW5hdG9ycyk7XG4gIGZvciAoY29uc3QgZGlzY3JpbWluYXRvcktleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgZGlzY3JpbWluYXRvclNjaGVtYSA9IGRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JLZXldO1xuXG4gICAgYXBwbHlQbHVnaW5zKGRpc2NyaW1pbmF0b3JTY2hlbWEsIHBsdWdpbnMsXG4gICAgICB7IHNraXBUb3BMZXZlbDogIWFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnMgfSwgY2FjaGVLZXkpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/applyPlugins.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = function applyWriteConcern(schema, options) {\n  if (options.writeConcern != null) {\n    return;\n  }\n  const writeConcern = get(schema, 'options.writeConcern', {});\n  if (Object.keys(writeConcern).length != 0) {\n    options.writeConcern = {};\n    if (!('w' in options) && writeConcern.w != null) {\n      options.writeConcern.w = writeConcern.w;\n    }\n    if (!('j' in options) && writeConcern.j != null) {\n      options.writeConcern.j = writeConcern.j;\n    }\n    if (!('wtimeout' in options) && writeConcern.wtimeout != null) {\n      options.writeConcern.wtimeout = writeConcern.wtimeout;\n    }\n  }\n  else {\n    if (!('w' in options) && writeConcern.w != null) {\n      options.w = writeConcern.w;\n    }\n    if (!('j' in options) && writeConcern.j != null) {\n      options.j = writeConcern.j;\n    }\n    if (!('wtimeout' in options) && writeConcern.wtimeout != null) {\n      options.wtimeout = writeConcern.wtimeout;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvYXBwbHlXcml0ZUNvbmNlcm4uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHdFQUFROztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxzY2hlbWFcXGFwcGx5V3JpdGVDb25jZXJuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBwbHlXcml0ZUNvbmNlcm4oc2NoZW1hLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLndyaXRlQ29uY2VybiAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdyaXRlQ29uY2VybiA9IGdldChzY2hlbWEsICdvcHRpb25zLndyaXRlQ29uY2VybicsIHt9KTtcbiAgaWYgKE9iamVjdC5rZXlzKHdyaXRlQ29uY2VybikubGVuZ3RoICE9IDApIHtcbiAgICBvcHRpb25zLndyaXRlQ29uY2VybiA9IHt9O1xuICAgIGlmICghKCd3JyBpbiBvcHRpb25zKSAmJiB3cml0ZUNvbmNlcm4udyAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2Vybi53ID0gd3JpdGVDb25jZXJuLnc7XG4gICAgfVxuICAgIGlmICghKCdqJyBpbiBvcHRpb25zKSAmJiB3cml0ZUNvbmNlcm4uaiAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2Vybi5qID0gd3JpdGVDb25jZXJuLmo7XG4gICAgfVxuICAgIGlmICghKCd3dGltZW91dCcgaW4gb3B0aW9ucykgJiYgd3JpdGVDb25jZXJuLnd0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMud3JpdGVDb25jZXJuLnd0aW1lb3V0ID0gd3JpdGVDb25jZXJuLnd0aW1lb3V0O1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoISgndycgaW4gb3B0aW9ucykgJiYgd3JpdGVDb25jZXJuLncgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy53ID0gd3JpdGVDb25jZXJuLnc7XG4gICAgfVxuICAgIGlmICghKCdqJyBpbiBvcHRpb25zKSAmJiB3cml0ZUNvbmNlcm4uaiAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLmogPSB3cml0ZUNvbmNlcm4uajtcbiAgICB9XG4gICAgaWYgKCEoJ3d0aW1lb3V0JyBpbiBvcHRpb25zKSAmJiB3cml0ZUNvbmNlcm4ud3RpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy53dGltZW91dCA9IHdyaXRlQ29uY2Vybi53dGltZW91dDtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js":
/*!**************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * For consistency's sake, we replace positional operator `$` and array filters\n * `$[]` and `$[foo]` with `0` when looking up schema paths.\n */\n\nmodule.exports = function cleanPositionalOperators(path) {\n  return path.\n    replace(/\\.\\$(\\[[^\\]]*\\])?(?=\\.)/g, '.0').\n    replace(/\\.\\$(\\[[^\\]]*\\])?$/g, '.0');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxzY2hlbWFcXGNsZWFuUG9zaXRpb25hbE9wZXJhdG9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRm9yIGNvbnNpc3RlbmN5J3Mgc2FrZSwgd2UgcmVwbGFjZSBwb3NpdGlvbmFsIG9wZXJhdG9yIGAkYCBhbmQgYXJyYXkgZmlsdGVyc1xuICogYCRbXWAgYW5kIGAkW2Zvb11gIHdpdGggYDBgIHdoZW4gbG9va2luZyB1cCBzY2hlbWEgcGF0aHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMocGF0aCkge1xuICByZXR1cm4gcGF0aC5cbiAgICByZXBsYWNlKC9cXC5cXCQoXFxbW15cXF1dKlxcXSk/KD89XFwuKS9nLCAnLjAnKS5cbiAgICByZXBsYWNlKC9cXC5cXCQoXFxbW15cXF1dKlxcXSk/JC9nLCAnLjAnKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/getIndexes.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/getIndexes.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst helperIsObject = __webpack_require__(/*! ../isObject */ \"(api)/../server/node_modules/mongoose/lib/helpers/isObject.js\");\nconst decorateDiscriminatorIndexOptions = __webpack_require__(/*! ../indexes/decorateDiscriminatorIndexOptions */ \"(api)/../server/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js\");\n\n/**\n * Gather all indexes defined in the schema, including single nested,\n * document arrays, and embedded discriminators.\n * @param {Schema} schema\n * @api private\n */\n\nmodule.exports = function getIndexes(schema) {\n  let indexes = [];\n  const schemaStack = new WeakMap();\n  const indexTypes = schema.constructor.indexTypes;\n  const indexByName = new Map();\n\n  collectIndexes(schema);\n  return indexes;\n\n  function collectIndexes(schema, prefix, baseSchema) {\n    // Ignore infinitely nested schemas, if we've already seen this schema\n    // along this path there must be a cycle\n    if (schemaStack.has(schema)) {\n      return;\n    }\n    schemaStack.set(schema, true);\n\n    prefix = prefix || '';\n    const keys = Object.keys(schema.paths);\n\n    for (const key of keys) {\n      const path = schema.paths[key];\n      if (baseSchema != null && baseSchema.paths[key]) {\n        // If looking at an embedded discriminator schema, don't look at paths\n        // that the\n        continue;\n      }\n\n      if (path.$isMongooseDocumentArray || path.$isSingleNested) {\n        if (get(path, 'options.excludeIndexes') !== true &&\n            get(path, 'schemaOptions.excludeIndexes') !== true &&\n            get(path, 'schema.options.excludeIndexes') !== true) {\n          collectIndexes(path.schema, prefix + key + '.');\n        }\n\n        if (path.schema.discriminators != null) {\n          const discriminators = path.schema.discriminators;\n          const discriminatorKeys = Object.keys(discriminators);\n          for (const discriminatorKey of discriminatorKeys) {\n            collectIndexes(discriminators[discriminatorKey],\n              prefix + key + '.', path.schema);\n          }\n        }\n\n        // Retained to minimize risk of backwards breaking changes due to\n        // gh-6113\n        if (path.$isMongooseDocumentArray) {\n          continue;\n        }\n      }\n\n      const index = path._index || (path.caster && path.caster._index);\n\n      if (index !== false && index !== null && index !== undefined) {\n        const field = {};\n        const isObject = helperIsObject(index);\n        const options = isObject ? index : {};\n        const type = typeof index === 'string' ? index :\n          isObject ? index.type :\n            false;\n\n        if (type && indexTypes.indexOf(type) !== -1) {\n          field[prefix + key] = type;\n        } else if (options.text) {\n          field[prefix + key] = 'text';\n          delete options.text;\n        } else {\n          let isDescendingIndex = false;\n          if (index === 'descending' || index === 'desc') {\n            isDescendingIndex = true;\n          } else if (index === 'ascending' || index === 'asc') {\n            isDescendingIndex = false;\n          } else {\n            isDescendingIndex = Number(index) === -1;\n          }\n\n          field[prefix + key] = isDescendingIndex ? -1 : 1;\n        }\n\n        delete options.type;\n        if (!('background' in options)) {\n          options.background = true;\n        }\n        if (schema.options.autoIndex != null) {\n          options._autoIndex = schema.options.autoIndex;\n        }\n\n        const indexName = options && options.name;\n\n        if (typeof indexName === 'string') {\n          if (indexByName.has(indexName)) {\n            Object.assign(indexByName.get(indexName), field);\n          } else {\n            indexes.push([field, options]);\n            indexByName.set(indexName, field);\n          }\n        } else {\n          indexes.push([field, options]);\n          indexByName.set(indexName, field);\n        }\n      }\n    }\n\n    schemaStack.delete(schema);\n\n    if (prefix) {\n      fixSubIndexPaths(schema, prefix);\n    } else {\n      schema._indexes.forEach(function(index) {\n        const options = index[1];\n        if (!('background' in options)) {\n          options.background = true;\n        }\n        decorateDiscriminatorIndexOptions(schema, options);\n      });\n      indexes = indexes.concat(schema._indexes);\n    }\n  }\n\n  /**\n   * Checks for indexes added to subdocs using Schema.index().\n   * These indexes need their paths prefixed properly.\n   *\n   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]\n   * @param {Schema} schema\n   * @param {String} prefix\n   * @api private\n   */\n\n  function fixSubIndexPaths(schema, prefix) {\n    const subindexes = schema._indexes;\n    const len = subindexes.length;\n    for (let i = 0; i < len; ++i) {\n      const indexObj = subindexes[i][0];\n      const indexOptions = subindexes[i][1];\n      const keys = Object.keys(indexObj);\n      const klen = keys.length;\n      const newindex = {};\n\n      // use forward iteration, order matters\n      for (let j = 0; j < klen; ++j) {\n        const key = keys[j];\n        newindex[prefix + key] = indexObj[key];\n      }\n\n      const newIndexOptions = Object.assign({}, indexOptions);\n      if (indexOptions != null && indexOptions.partialFilterExpression != null) {\n        newIndexOptions.partialFilterExpression = {};\n        const partialFilterExpression = indexOptions.partialFilterExpression;\n        for (const key of Object.keys(partialFilterExpression)) {\n          newIndexOptions.partialFilterExpression[prefix + key] =\n            partialFilterExpression[key];\n        }\n      }\n\n      indexes.push([newindex, newIndexOptions]);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0SW5kZXhlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsd0VBQVE7QUFDNUIsdUJBQXVCLG1CQUFPLENBQUMsa0ZBQWE7QUFDNUMsMENBQTBDLG1CQUFPLENBQUMsb0pBQThDOztBQUVoRztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxzY2hlbWFcXGdldEluZGV4ZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IGhlbHBlcklzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaXNPYmplY3QnKTtcbmNvbnN0IGRlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucyA9IHJlcXVpcmUoJy4uL2luZGV4ZXMvZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zJyk7XG5cbi8qKlxuICogR2F0aGVyIGFsbCBpbmRleGVzIGRlZmluZWQgaW4gdGhlIHNjaGVtYSwgaW5jbHVkaW5nIHNpbmdsZSBuZXN0ZWQsXG4gKiBkb2N1bWVudCBhcnJheXMsIGFuZCBlbWJlZGRlZCBkaXNjcmltaW5hdG9ycy5cbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0SW5kZXhlcyhzY2hlbWEpIHtcbiAgbGV0IGluZGV4ZXMgPSBbXTtcbiAgY29uc3Qgc2NoZW1hU3RhY2sgPSBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBpbmRleFR5cGVzID0gc2NoZW1hLmNvbnN0cnVjdG9yLmluZGV4VHlwZXM7XG4gIGNvbnN0IGluZGV4QnlOYW1lID0gbmV3IE1hcCgpO1xuXG4gIGNvbGxlY3RJbmRleGVzKHNjaGVtYSk7XG4gIHJldHVybiBpbmRleGVzO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3RJbmRleGVzKHNjaGVtYSwgcHJlZml4LCBiYXNlU2NoZW1hKSB7XG4gICAgLy8gSWdub3JlIGluZmluaXRlbHkgbmVzdGVkIHNjaGVtYXMsIGlmIHdlJ3ZlIGFscmVhZHkgc2VlbiB0aGlzIHNjaGVtYVxuICAgIC8vIGFsb25nIHRoaXMgcGF0aCB0aGVyZSBtdXN0IGJlIGEgY3ljbGVcbiAgICBpZiAoc2NoZW1hU3RhY2suaGFzKHNjaGVtYSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZW1hU3RhY2suc2V0KHNjaGVtYSwgdHJ1ZSk7XG5cbiAgICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocyk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCBwYXRoID0gc2NoZW1hLnBhdGhzW2tleV07XG4gICAgICBpZiAoYmFzZVNjaGVtYSAhPSBudWxsICYmIGJhc2VTY2hlbWEucGF0aHNba2V5XSkge1xuICAgICAgICAvLyBJZiBsb29raW5nIGF0IGFuIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3Igc2NoZW1hLCBkb24ndCBsb29rIGF0IHBhdGhzXG4gICAgICAgIC8vIHRoYXQgdGhlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGF0aC4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgfHwgcGF0aC4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgaWYgKGdldChwYXRoLCAnb3B0aW9ucy5leGNsdWRlSW5kZXhlcycpICE9PSB0cnVlICYmXG4gICAgICAgICAgICBnZXQocGF0aCwgJ3NjaGVtYU9wdGlvbnMuZXhjbHVkZUluZGV4ZXMnKSAhPT0gdHJ1ZSAmJlxuICAgICAgICAgICAgZ2V0KHBhdGgsICdzY2hlbWEub3B0aW9ucy5leGNsdWRlSW5kZXhlcycpICE9PSB0cnVlKSB7XG4gICAgICAgICAgY29sbGVjdEluZGV4ZXMocGF0aC5zY2hlbWEsIHByZWZpeCArIGtleSArICcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aC5zY2hlbWEuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JzID0gcGF0aC5zY2hlbWEuZGlzY3JpbWluYXRvcnM7XG4gICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvcktleXMgPSBPYmplY3Qua2V5cyhkaXNjcmltaW5hdG9ycyk7XG4gICAgICAgICAgZm9yIChjb25zdCBkaXNjcmltaW5hdG9yS2V5IG9mIGRpc2NyaW1pbmF0b3JLZXlzKSB7XG4gICAgICAgICAgICBjb2xsZWN0SW5kZXhlcyhkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yS2V5XSxcbiAgICAgICAgICAgICAgcHJlZml4ICsga2V5ICsgJy4nLCBwYXRoLnNjaGVtYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0YWluZWQgdG8gbWluaW1pemUgcmlzayBvZiBiYWNrd2FyZHMgYnJlYWtpbmcgY2hhbmdlcyBkdWUgdG9cbiAgICAgICAgLy8gZ2gtNjExM1xuICAgICAgICBpZiAocGF0aC4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IHBhdGguX2luZGV4IHx8IChwYXRoLmNhc3RlciAmJiBwYXRoLmNhc3Rlci5faW5kZXgpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IGZhbHNlICYmIGluZGV4ICE9PSBudWxsICYmIGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSB7fTtcbiAgICAgICAgY29uc3QgaXNPYmplY3QgPSBoZWxwZXJJc09iamVjdChpbmRleCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBpc09iamVjdCA/IGluZGV4IDoge307XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgaW5kZXggPT09ICdzdHJpbmcnID8gaW5kZXggOlxuICAgICAgICAgIGlzT2JqZWN0ID8gaW5kZXgudHlwZSA6XG4gICAgICAgICAgICBmYWxzZTtcblxuICAgICAgICBpZiAodHlwZSAmJiBpbmRleFR5cGVzLmluZGV4T2YodHlwZSkgIT09IC0xKSB7XG4gICAgICAgICAgZmllbGRbcHJlZml4ICsga2V5XSA9IHR5cGU7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50ZXh0KSB7XG4gICAgICAgICAgZmllbGRbcHJlZml4ICsga2V5XSA9ICd0ZXh0JztcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpc0Rlc2NlbmRpbmdJbmRleCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gJ2Rlc2NlbmRpbmcnIHx8IGluZGV4ID09PSAnZGVzYycpIHtcbiAgICAgICAgICAgIGlzRGVzY2VuZGluZ0luZGV4ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAnYXNjZW5kaW5nJyB8fCBpbmRleCA9PT0gJ2FzYycpIHtcbiAgICAgICAgICAgIGlzRGVzY2VuZGluZ0luZGV4ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzRGVzY2VuZGluZ0luZGV4ID0gTnVtYmVyKGluZGV4KSA9PT0gLTE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmllbGRbcHJlZml4ICsga2V5XSA9IGlzRGVzY2VuZGluZ0luZGV4ID8gLTEgOiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIG9wdGlvbnMudHlwZTtcbiAgICAgICAgaWYgKCEoJ2JhY2tncm91bmQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgb3B0aW9ucy5iYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLm9wdGlvbnMuYXV0b0luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zLl9hdXRvSW5kZXggPSBzY2hlbWEub3B0aW9ucy5hdXRvSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbmRleE5hbWUgPSBvcHRpb25zICYmIG9wdGlvbnMubmFtZTtcblxuICAgICAgICBpZiAodHlwZW9mIGluZGV4TmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoaW5kZXhCeU5hbWUuaGFzKGluZGV4TmFtZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaW5kZXhCeU5hbWUuZ2V0KGluZGV4TmFtZSksIGZpZWxkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKFtmaWVsZCwgb3B0aW9uc10pO1xuICAgICAgICAgICAgaW5kZXhCeU5hbWUuc2V0KGluZGV4TmFtZSwgZmllbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleGVzLnB1c2goW2ZpZWxkLCBvcHRpb25zXSk7XG4gICAgICAgICAgaW5kZXhCeU5hbWUuc2V0KGluZGV4TmFtZSwgZmllbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2NoZW1hU3RhY2suZGVsZXRlKHNjaGVtYSk7XG5cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBmaXhTdWJJbmRleFBhdGhzKHNjaGVtYSwgcHJlZml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZW1hLl9pbmRleGVzLmZvckVhY2goZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGluZGV4WzFdO1xuICAgICAgICBpZiAoISgnYmFja2dyb3VuZCcgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICBvcHRpb25zLmJhY2tncm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucyhzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgICBpbmRleGVzID0gaW5kZXhlcy5jb25jYXQoc2NoZW1hLl9pbmRleGVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGZvciBpbmRleGVzIGFkZGVkIHRvIHN1YmRvY3MgdXNpbmcgU2NoZW1hLmluZGV4KCkuXG4gICAqIFRoZXNlIGluZGV4ZXMgbmVlZCB0aGVpciBwYXRocyBwcmVmaXhlZCBwcm9wZXJseS5cbiAgICpcbiAgICogc2NoZW1hLl9pbmRleGVzID0gWyBbaW5kZXhPYmosIG9wdGlvbnNdLCBbaW5kZXhPYmosIG9wdGlvbnNdIC4uXVxuICAgKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGZpeFN1YkluZGV4UGF0aHMoc2NoZW1hLCBwcmVmaXgpIHtcbiAgICBjb25zdCBzdWJpbmRleGVzID0gc2NoZW1hLl9pbmRleGVzO1xuICAgIGNvbnN0IGxlbiA9IHN1YmluZGV4ZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGluZGV4T2JqID0gc3ViaW5kZXhlc1tpXVswXTtcbiAgICAgIGNvbnN0IGluZGV4T3B0aW9ucyA9IHN1YmluZGV4ZXNbaV1bMV07XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaW5kZXhPYmopO1xuICAgICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgY29uc3QgbmV3aW5kZXggPSB7fTtcblxuICAgICAgLy8gdXNlIGZvcndhcmQgaXRlcmF0aW9uLCBvcmRlciBtYXR0ZXJzXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtsZW47ICsraikge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2pdO1xuICAgICAgICBuZXdpbmRleFtwcmVmaXggKyBrZXldID0gaW5kZXhPYmpba2V5XTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3SW5kZXhPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaW5kZXhPcHRpb25zKTtcbiAgICAgIGlmIChpbmRleE9wdGlvbnMgIT0gbnVsbCAmJiBpbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICBuZXdJbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb24gPSB7fTtcbiAgICAgICAgY29uc3QgcGFydGlhbEZpbHRlckV4cHJlc3Npb24gPSBpbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb247XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uKSkge1xuICAgICAgICAgIG5ld0luZGV4T3B0aW9ucy5wYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbltwcmVmaXggKyBrZXldID1cbiAgICAgICAgICAgIHBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5kZXhlcy5wdXNoKFtuZXdpbmRleCwgbmV3SW5kZXhPcHRpb25zXSk7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/getIndexes.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js":
/*!**********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = function getKeysInSchemaOrder(schema, val, path) {\n  const schemaKeys = path != null ? Object.keys(get(schema.tree, path, {})) : Object.keys(schema.tree);\n  const valKeys = new Set(Object.keys(val));\n\n  let keys;\n  if (valKeys.size > 1) {\n    keys = new Set();\n    for (const key of schemaKeys) {\n      if (valKeys.has(key)) {\n        keys.add(key);\n      }\n    }\n    for (const key of valKeys) {\n      if (!keys.has(key)) {\n        keys.add(key);\n      }\n    }\n    keys = Array.from(keys);\n  } else {\n    keys = Array.from(valKeys);\n  }\n\n  return keys;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0S2V5c0luU2NoZW1hT3JkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHdFQUFROztBQUU1QjtBQUNBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHNjaGVtYVxcZ2V0S2V5c0luU2NoZW1hT3JkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRLZXlzSW5TY2hlbWFPcmRlcihzY2hlbWEsIHZhbCwgcGF0aCkge1xuICBjb25zdCBzY2hlbWFLZXlzID0gcGF0aCAhPSBudWxsID8gT2JqZWN0LmtleXMoZ2V0KHNjaGVtYS50cmVlLCBwYXRoLCB7fSkpIDogT2JqZWN0LmtleXMoc2NoZW1hLnRyZWUpO1xuICBjb25zdCB2YWxLZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWwpKTtcblxuICBsZXQga2V5cztcbiAgaWYgKHZhbEtleXMuc2l6ZSA+IDEpIHtcbiAgICBrZXlzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHNjaGVtYUtleXMpIHtcbiAgICAgIGlmICh2YWxLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbEtleXMpIHtcbiAgICAgIGlmICgha2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBrZXlzID0gQXJyYXkuZnJvbShrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gQXJyYXkuZnJvbSh2YWxLZXlzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/getPath.js":
/*!*********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/getPath.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst numberRE = /^\\d+$/;\n\n/**\n * Behaves like `Schema#path()`, except for it also digs into arrays without\n * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.\n * @api private\n */\n\nmodule.exports = function getPath(schema, path) {\n  let schematype = schema.path(path);\n  if (schematype != null) {\n    return schematype;\n  }\n  const pieces = path.split('.');\n  let cur = '';\n  let isArray = false;\n\n  for (const piece of pieces) {\n    if (isArray && numberRE.test(piece)) {\n      continue;\n    }\n    cur = cur.length === 0 ? piece : cur + '.' + piece;\n\n    schematype = schema.path(cur);\n    if (schematype != null && schematype.schema) {\n      schema = schematype.schema;\n      cur = '';\n      if (!isArray && schematype.$isMongooseDocumentArray) {\n        isArray = true;\n      }\n    }\n  }\n\n  return schematype;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0UGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHNjaGVtYVxcZ2V0UGF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG51bWJlclJFID0gL15cXGQrJC87XG5cbi8qKlxuICogQmVoYXZlcyBsaWtlIGBTY2hlbWEjcGF0aCgpYCwgZXhjZXB0IGZvciBpdCBhbHNvIGRpZ3MgaW50byBhcnJheXMgd2l0aG91dFxuICogbmVlZGluZyB0byBwdXQgYC4wLmAsIHNvIGBnZXRQYXRoKHNjaGVtYSwgJ2RvY0Fyci5lbFByb3AnKWAgd29ya3MuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBhdGgoc2NoZW1hLCBwYXRoKSB7XG4gIGxldCBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gIGlmIChzY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICByZXR1cm4gc2NoZW1hdHlwZTtcbiAgfVxuICBjb25zdCBwaWVjZXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGxldCBjdXIgPSAnJztcbiAgbGV0IGlzQXJyYXkgPSBmYWxzZTtcblxuICBmb3IgKGNvbnN0IHBpZWNlIG9mIHBpZWNlcykge1xuICAgIGlmIChpc0FycmF5ICYmIG51bWJlclJFLnRlc3QocGllY2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY3VyID0gY3VyLmxlbmd0aCA9PT0gMCA/IHBpZWNlIDogY3VyICsgJy4nICsgcGllY2U7XG5cbiAgICBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGgoY3VyKTtcbiAgICBpZiAoc2NoZW1hdHlwZSAhPSBudWxsICYmIHNjaGVtYXR5cGUuc2NoZW1hKSB7XG4gICAgICBzY2hlbWEgPSBzY2hlbWF0eXBlLnNjaGVtYTtcbiAgICAgIGN1ciA9ICcnO1xuICAgICAgaWYgKCFpc0FycmF5ICYmIHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgIGlzQXJyYXkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzY2hlbWF0eXBlO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/getPath.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js":
/*!***************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Find the `strict` mode setting for the deepest subdocument along a given path\n * to ensure we have the correct default value for `strict`. When setting values\n * underneath a subdocument, we should use the subdocument's `strict` setting by\n * default, not the top-level document's.\n *\n * @param {Schema} schema\n * @param {String[]} parts\n * @returns {boolean | 'throw' | undefined}\n */\n\nmodule.exports = function getSubdocumentStrictValue(schema, parts) {\n  if (parts.length === 1) {\n    return undefined;\n  }\n  let cur = parts[0];\n  let strict = undefined;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const curSchemaType = schema.path(cur);\n    if (curSchemaType && curSchemaType.schema) {\n      strict = curSchemaType.schema.options.strict;\n      schema = curSchemaType.schema;\n      cur = curSchemaType.$isMongooseDocumentArray && !isNaN(parts[i + 1]) ? '' : parts[i + 1];\n    } else {\n      cur += cur.length ? ('.' + parts[i + 1]) : parts[i + 1];\n    }\n  }\n\n  return strict;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0U3ViZG9jdW1lbnRTdHJpY3RWYWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxzY2hlbWFcXGdldFN1YmRvY3VtZW50U3RyaWN0VmFsdWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEZpbmQgdGhlIGBzdHJpY3RgIG1vZGUgc2V0dGluZyBmb3IgdGhlIGRlZXBlc3Qgc3ViZG9jdW1lbnQgYWxvbmcgYSBnaXZlbiBwYXRoXG4gKiB0byBlbnN1cmUgd2UgaGF2ZSB0aGUgY29ycmVjdCBkZWZhdWx0IHZhbHVlIGZvciBgc3RyaWN0YC4gV2hlbiBzZXR0aW5nIHZhbHVlc1xuICogdW5kZXJuZWF0aCBhIHN1YmRvY3VtZW50LCB3ZSBzaG91bGQgdXNlIHRoZSBzdWJkb2N1bWVudCdzIGBzdHJpY3RgIHNldHRpbmcgYnlcbiAqIGRlZmF1bHQsIG5vdCB0aGUgdG9wLWxldmVsIGRvY3VtZW50J3MuXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtTdHJpbmdbXX0gcGFydHNcbiAqIEByZXR1cm5zIHtib29sZWFuIHwgJ3Rocm93JyB8IHVuZGVmaW5lZH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFN1YmRvY3VtZW50U3RyaWN0VmFsdWUoc2NoZW1hLCBwYXJ0cykge1xuICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgY3VyID0gcGFydHNbMF07XG4gIGxldCBzdHJpY3QgPSB1bmRlZmluZWQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgY29uc3QgY3VyU2NoZW1hVHlwZSA9IHNjaGVtYS5wYXRoKGN1cik7XG4gICAgaWYgKGN1clNjaGVtYVR5cGUgJiYgY3VyU2NoZW1hVHlwZS5zY2hlbWEpIHtcbiAgICAgIHN0cmljdCA9IGN1clNjaGVtYVR5cGUuc2NoZW1hLm9wdGlvbnMuc3RyaWN0O1xuICAgICAgc2NoZW1hID0gY3VyU2NoZW1hVHlwZS5zY2hlbWE7XG4gICAgICBjdXIgPSBjdXJTY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJiAhaXNOYU4ocGFydHNbaSArIDFdKSA/ICcnIDogcGFydHNbaSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXIgKz0gY3VyLmxlbmd0aCA/ICgnLicgKyBwYXJ0c1tpICsgMV0pIDogcGFydHNbaSArIDFdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJpY3Q7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/handleIdOption.js":
/*!****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/handleIdOption.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst addAutoId = __webpack_require__(/*! ./addAutoId */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/addAutoId.js\");\n\nmodule.exports = function handleIdOption(schema, options) {\n  if (options == null || options._id == null) {\n    return schema;\n  }\n\n  schema = schema.clone();\n  if (!options._id) {\n    schema.remove('_id');\n    schema.options._id = false;\n  } else if (!schema.paths['_id']) {\n    addAutoId(schema);\n    schema.options._id = true;\n  }\n\n  return schema;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvaGFuZGxlSWRPcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsMEZBQWE7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcc2NoZW1hXFxoYW5kbGVJZE9wdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFkZEF1dG9JZCA9IHJlcXVpcmUoJy4vYWRkQXV0b0lkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFuZGxlSWRPcHRpb24oc2NoZW1hLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwgfHwgb3B0aW9ucy5faWQgPT0gbnVsbCkge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cblxuICBzY2hlbWEgPSBzY2hlbWEuY2xvbmUoKTtcbiAgaWYgKCFvcHRpb25zLl9pZCkge1xuICAgIHNjaGVtYS5yZW1vdmUoJ19pZCcpO1xuICAgIHNjaGVtYS5vcHRpb25zLl9pZCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKCFzY2hlbWEucGF0aHNbJ19pZCddKSB7XG4gICAgYWRkQXV0b0lkKHNjaGVtYSk7XG4gICAgc2NoZW1hLm9wdGlvbnMuX2lkID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWE7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/handleIdOption.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js":
/*!***********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = handleTimestampOption;\n\n/*!\n * ignore\n */\n\nfunction handleTimestampOption(arg, prop) {\n  if (arg == null) {\n    return null;\n  }\n\n  if (typeof arg === 'boolean') {\n    return prop;\n  }\n  if (typeof arg[prop] === 'boolean') {\n    return arg[prop] ? prop : null;\n  }\n  if (!(prop in arg)) {\n    return prop;\n  }\n  return arg[prop];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvaGFuZGxlVGltZXN0YW1wT3B0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcc2NoZW1hXFxoYW5kbGVUaW1lc3RhbXBPcHRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbjtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVUaW1lc3RhbXBPcHRpb24oYXJnLCBwcm9wKSB7XG4gIGlmIChhcmcgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG4gIGlmICh0eXBlb2YgYXJnW3Byb3BdID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gYXJnW3Byb3BdID8gcHJvcCA6IG51bGw7XG4gIH1cbiAgaWYgKCEocHJvcCBpbiBhcmcpKSB7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbiAgcmV0dXJuIGFyZ1twcm9wXTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/idGetter.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/idGetter.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function addIdGetter(schema) {\n  // ensure the documents receive an id getter unless disabled\n  const autoIdGetter = !schema.paths['id'] &&\n    schema.paths['_id'] &&\n    schema.options.id;\n  if (!autoIdGetter) {\n    return schema;\n  }\n  if (schema.aliases && schema.aliases.id) {\n    return schema;\n  }\n  schema.virtual('id').get(idGetter);\n  schema.virtual('id').set(idSetter);\n\n  return schema;\n};\n\n/**\n * Returns this documents _id cast to a string.\n * @api private\n */\n\nfunction idGetter() {\n  if (this._id != null) {\n    return String(this._id);\n  }\n\n  return null;\n}\n\n/**\n *\n * @param {String} v the id to set\n * @api private\n */\n\nfunction idSetter(v) {\n  this._id = v;\n  return v;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvaWRHZXR0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFxzY2hlbWFcXGlkR2V0dGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZElkR2V0dGVyKHNjaGVtYSkge1xuICAvLyBlbnN1cmUgdGhlIGRvY3VtZW50cyByZWNlaXZlIGFuIGlkIGdldHRlciB1bmxlc3MgZGlzYWJsZWRcbiAgY29uc3QgYXV0b0lkR2V0dGVyID0gIXNjaGVtYS5wYXRoc1snaWQnXSAmJlxuICAgIHNjaGVtYS5wYXRoc1snX2lkJ10gJiZcbiAgICBzY2hlbWEub3B0aW9ucy5pZDtcbiAgaWYgKCFhdXRvSWRHZXR0ZXIpIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG4gIGlmIChzY2hlbWEuYWxpYXNlcyAmJiBzY2hlbWEuYWxpYXNlcy5pZCkge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbiAgc2NoZW1hLnZpcnR1YWwoJ2lkJykuZ2V0KGlkR2V0dGVyKTtcbiAgc2NoZW1hLnZpcnR1YWwoJ2lkJykuc2V0KGlkU2V0dGVyKTtcblxuICByZXR1cm4gc2NoZW1hO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgZG9jdW1lbnRzIF9pZCBjYXN0IHRvIGEgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaWRHZXR0ZXIoKSB7XG4gIGlmICh0aGlzLl9pZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLl9pZCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHYgdGhlIGlkIHRvIHNldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaWRTZXR0ZXIodikge1xuICB0aGlzLl9pZCA9IHY7XG4gIHJldHVybiB2O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/idGetter.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schema/merge.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schema/merge.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function merge(s1, s2, skipConflictingPaths) {\n  const paths = Object.keys(s2.tree);\n  const pathsToAdd = {};\n  for (const key of paths) {\n    if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {\n      continue;\n    }\n    pathsToAdd[key] = s2.tree[key];\n  }\n  s1.options._isMerging = true;\n  s1.add(pathsToAdd, null);\n  delete s1.options._isMerging;\n\n  s1.callQueue = s1.callQueue.concat(s2.callQueue);\n  s1.method(s2.methods);\n  s1.static(s2.statics);\n\n  for (const [option, value] of Object.entries(s2._userProvidedOptions)) {\n    if (!(option in s1._userProvidedOptions)) {\n      s1.set(option, value);\n    }\n  }\n\n  for (const query in s2.query) {\n    s1.query[query] = s2.query[query];\n  }\n\n  for (const virtual in s2.virtuals) {\n    s1.virtuals[virtual] = s2.virtuals[virtual].clone();\n  }\n\n  s1._indexes = s1._indexes.concat(s2._indexes || []);\n  s1.s.hooks.merge(s2.s.hooks, false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvbWVyZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcc2NoZW1hXFxtZXJnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2UoczEsIHMyLCBza2lwQ29uZmxpY3RpbmdQYXRocykge1xuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHMyLnRyZWUpO1xuICBjb25zdCBwYXRoc1RvQWRkID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIHBhdGhzKSB7XG4gICAgaWYgKHNraXBDb25mbGljdGluZ1BhdGhzICYmIChzMS5wYXRoc1trZXldIHx8IHMxLm5lc3RlZFtrZXldIHx8IHMxLnNpbmdsZU5lc3RlZFBhdGhzW2tleV0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcGF0aHNUb0FkZFtrZXldID0gczIudHJlZVtrZXldO1xuICB9XG4gIHMxLm9wdGlvbnMuX2lzTWVyZ2luZyA9IHRydWU7XG4gIHMxLmFkZChwYXRoc1RvQWRkLCBudWxsKTtcbiAgZGVsZXRlIHMxLm9wdGlvbnMuX2lzTWVyZ2luZztcblxuICBzMS5jYWxsUXVldWUgPSBzMS5jYWxsUXVldWUuY29uY2F0KHMyLmNhbGxRdWV1ZSk7XG4gIHMxLm1ldGhvZChzMi5tZXRob2RzKTtcbiAgczEuc3RhdGljKHMyLnN0YXRpY3MpO1xuXG4gIGZvciAoY29uc3QgW29wdGlvbiwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHMyLl91c2VyUHJvdmlkZWRPcHRpb25zKSkge1xuICAgIGlmICghKG9wdGlvbiBpbiBzMS5fdXNlclByb3ZpZGVkT3B0aW9ucykpIHtcbiAgICAgIHMxLnNldChvcHRpb24sIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHF1ZXJ5IGluIHMyLnF1ZXJ5KSB7XG4gICAgczEucXVlcnlbcXVlcnldID0gczIucXVlcnlbcXVlcnldO1xuICB9XG5cbiAgZm9yIChjb25zdCB2aXJ0dWFsIGluIHMyLnZpcnR1YWxzKSB7XG4gICAgczEudmlydHVhbHNbdmlydHVhbF0gPSBzMi52aXJ0dWFsc1t2aXJ0dWFsXS5jbG9uZSgpO1xuICB9XG5cbiAgczEuX2luZGV4ZXMgPSBzMS5faW5kZXhlcy5jb25jYXQoczIuX2luZGV4ZXMgfHwgW10pO1xuICBzMS5zLmhvb2tzLm1lcmdlKHMyLnMuaG9va3MsIGZhbHNlKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schema/merge.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"(api)/../server/node_modules/mongoose/lib/error/strict.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function(schematype) {\n  if (schematype.$immutable) {\n    schematype.$immutableSetter = createImmutableSetter(schematype.path,\n      schematype.options.immutable);\n    schematype.set(schematype.$immutableSetter);\n  } else if (schematype.$immutableSetter) {\n    schematype.setters = schematype.setters.\n      filter(fn => fn !== schematype.$immutableSetter);\n    delete schematype.$immutableSetter;\n  }\n};\n\nfunction createImmutableSetter(path, immutable) {\n  return function immutableSetter(v, _priorVal, _doc, options) {\n    if (this == null || this.$__ == null) {\n      return v;\n    }\n    if (this.isNew) {\n      return v;\n    }\n    if (options && options.overwriteImmutable) {\n      return v;\n    }\n\n    const _immutable = typeof immutable === 'function' ?\n      immutable.call(this, this) :\n      immutable;\n    if (!_immutable) {\n      return v;\n    }\n\n    const _value = this.$__.priorDoc != null ?\n      this.$__.priorDoc.$__getValue(path) :\n      this.$__getValue(path);\n    if (this.$__.strictMode === 'throw' && v !== _value) {\n      throw new StrictModeError(path, 'Path `' + path + '` is immutable ' +\n        'and strict mode is set to throw.', true);\n    }\n\n    return _value;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWF0eXBlL2hhbmRsZUltbXV0YWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix3QkFBd0IsbUJBQU8sQ0FBQyxxRkFBb0I7O0FBRXBEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcc2NoZW1hdHlwZVxcaGFuZGxlSW1tdXRhYmxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RyaWN0TW9kZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3Ivc3RyaWN0Jyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzY2hlbWF0eXBlKSB7XG4gIGlmIChzY2hlbWF0eXBlLiRpbW11dGFibGUpIHtcbiAgICBzY2hlbWF0eXBlLiRpbW11dGFibGVTZXR0ZXIgPSBjcmVhdGVJbW11dGFibGVTZXR0ZXIoc2NoZW1hdHlwZS5wYXRoLFxuICAgICAgc2NoZW1hdHlwZS5vcHRpb25zLmltbXV0YWJsZSk7XG4gICAgc2NoZW1hdHlwZS5zZXQoc2NoZW1hdHlwZS4kaW1tdXRhYmxlU2V0dGVyKTtcbiAgfSBlbHNlIGlmIChzY2hlbWF0eXBlLiRpbW11dGFibGVTZXR0ZXIpIHtcbiAgICBzY2hlbWF0eXBlLnNldHRlcnMgPSBzY2hlbWF0eXBlLnNldHRlcnMuXG4gICAgICBmaWx0ZXIoZm4gPT4gZm4gIT09IHNjaGVtYXR5cGUuJGltbXV0YWJsZVNldHRlcik7XG4gICAgZGVsZXRlIHNjaGVtYXR5cGUuJGltbXV0YWJsZVNldHRlcjtcbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlSW1tdXRhYmxlU2V0dGVyKHBhdGgsIGltbXV0YWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW1tdXRhYmxlU2V0dGVyKHYsIF9wcmlvclZhbCwgX2RvYywgb3B0aW9ucykge1xuICAgIGlmICh0aGlzID09IG51bGwgfHwgdGhpcy4kX18gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTmV3KSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vdmVyd3JpdGVJbW11dGFibGUpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIGNvbnN0IF9pbW11dGFibGUgPSB0eXBlb2YgaW1tdXRhYmxlID09PSAnZnVuY3Rpb24nID9cbiAgICAgIGltbXV0YWJsZS5jYWxsKHRoaXMsIHRoaXMpIDpcbiAgICAgIGltbXV0YWJsZTtcbiAgICBpZiAoIV9pbW11dGFibGUpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIGNvbnN0IF92YWx1ZSA9IHRoaXMuJF9fLnByaW9yRG9jICE9IG51bGwgP1xuICAgICAgdGhpcy4kX18ucHJpb3JEb2MuJF9fZ2V0VmFsdWUocGF0aCkgOlxuICAgICAgdGhpcy4kX19nZXRWYWx1ZShwYXRoKTtcbiAgICBpZiAodGhpcy4kX18uc3RyaWN0TW9kZSA9PT0gJ3Rocm93JyAmJiB2ICE9PSBfdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aCwgJ1BhdGggYCcgKyBwYXRoICsgJ2AgaXMgaW1tdXRhYmxlICcgK1xuICAgICAgICAnYW5kIHN0cmljdCBtb2RlIGlzIHNldCB0byB0aHJvdy4nLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3ZhbHVlO1xuICB9O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst modifiedPaths = (__webpack_require__(/*! ./common */ \"(api)/../server/node_modules/mongoose/lib/helpers/common.js\").modifiedPaths);\nconst get = __webpack_require__(/*! ./get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\n\n/**\n * Applies defaults to update and findOneAndUpdate operations.\n *\n * @param {Object} filter\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method setDefaultsOnInsert\n * @api private\n */\n\nmodule.exports = function(filter, schema, castedDoc, options) {\n  options = options || {};\n\n  const shouldSetDefaultsOnInsert =\n    options.setDefaultsOnInsert != null ?\n      options.setDefaultsOnInsert :\n      schema.base.options.setDefaultsOnInsert;\n\n  if (!options.upsert || shouldSetDefaultsOnInsert === false) {\n    return castedDoc;\n  }\n\n  const keys = Object.keys(castedDoc || {});\n  const updatedKeys = {};\n  const updatedValues = {};\n  const numKeys = keys.length;\n  const modified = {};\n\n  let hasDollarUpdate = false;\n\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      hasDollarUpdate = true;\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n  }\n\n  const paths = Object.keys(filter);\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    const path = paths[i];\n    const condition = filter[path];\n    if (condition && typeof condition === 'object') {\n      const conditionKeys = Object.keys(condition);\n      const numConditionKeys = conditionKeys.length;\n      let hasDollarKey = false;\n      for (let j = 0; j < numConditionKeys; ++j) {\n        if (conditionKeys[j].startsWith('$')) {\n          hasDollarKey = true;\n          break;\n        }\n      }\n      if (hasDollarKey) {\n        continue;\n      }\n    }\n    updatedKeys[path] = true;\n    modified[path] = true;\n  }\n\n  if (options && options.overwrite && !hasDollarUpdate) {\n    // Defaults will be set later, since we're overwriting we'll cast\n    // the whole update to a document\n    return castedDoc;\n  }\n\n  schema.eachPath(function(path, schemaType) {\n    // Skip single nested paths if underneath a map\n    if (schemaType.path === '_id' && schemaType.options.auto) {\n      return;\n    }\n    const def = schemaType.getDefault(null, true);\n    if (isModified(modified, path)) {\n      return;\n    }\n    if (typeof def === 'undefined') {\n      return;\n    }\n    if (schemaType.splitPath().includes('$*')) {\n      // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`\n      return;\n    }\n\n    castedDoc = castedDoc || {};\n    castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n    if (get(castedDoc, path) == null) {\n      castedDoc.$setOnInsert[path] = def;\n    }\n    updatedValues[path] = def;\n  });\n\n  return castedDoc;\n};\n\nfunction isModified(modified, path) {\n  if (modified[path]) {\n    return true;\n  }\n\n  // Is any parent path of `path` modified?\n  const sp = path.split('.');\n  let cur = sp[0];\n  for (let i = 1; i < sp.length; ++i) {\n    if (modified[cur]) {\n      return true;\n    }\n    cur += '.' + sp[i];\n  }\n\n  // Is any child of `path` modified?\n  const modifiedKeys = Object.keys(modified);\n  if (modifiedKeys.length) {\n    const parentPath = path + '.';\n\n    for (const modifiedPath of modifiedKeys) {\n      if (modifiedPath.slice(0, path.length + 1) === parentPath) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zZXREZWZhdWx0c09uSW5zZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isc0JBQXNCLGtIQUFpQztBQUN2RCxZQUFZLG1CQUFPLENBQUMsdUVBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcc2V0RGVmYXVsdHNPbkluc2VydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBtb2RpZmllZFBhdGhzID0gcmVxdWlyZSgnLi9jb21tb24nKS5tb2RpZmllZFBhdGhzO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi9nZXQnKTtcblxuLyoqXG4gKiBBcHBsaWVzIGRlZmF1bHRzIHRvIHVwZGF0ZSBhbmQgZmluZE9uZUFuZFVwZGF0ZSBvcGVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYXN0ZWREb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAbWV0aG9kIHNldERlZmF1bHRzT25JbnNlcnRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZmlsdGVyLCBzY2hlbWEsIGNhc3RlZERvYywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBzaG91bGRTZXREZWZhdWx0c09uSW5zZXJ0ID1cbiAgICBvcHRpb25zLnNldERlZmF1bHRzT25JbnNlcnQgIT0gbnVsbCA/XG4gICAgICBvcHRpb25zLnNldERlZmF1bHRzT25JbnNlcnQgOlxuICAgICAgc2NoZW1hLmJhc2Uub3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0O1xuXG4gIGlmICghb3B0aW9ucy51cHNlcnQgfHwgc2hvdWxkU2V0RGVmYXVsdHNPbkluc2VydCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gY2FzdGVkRG9jO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNhc3RlZERvYyB8fCB7fSk7XG4gIGNvbnN0IHVwZGF0ZWRLZXlzID0ge307XG4gIGNvbnN0IHVwZGF0ZWRWYWx1ZXMgPSB7fTtcbiAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICBjb25zdCBtb2RpZmllZCA9IHt9O1xuXG4gIGxldCBoYXNEb2xsYXJVcGRhdGUgPSBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgIGlmIChrZXlzW2ldLnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgbW9kaWZpZWRQYXRocyhjYXN0ZWREb2Nba2V5c1tpXV0sICcnLCBtb2RpZmllZCk7XG4gICAgICBoYXNEb2xsYXJVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaGFzRG9sbGFyVXBkYXRlKSB7XG4gICAgbW9kaWZpZWRQYXRocyhjYXN0ZWREb2MsICcnLCBtb2RpZmllZCk7XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKGZpbHRlcik7XG4gIGNvbnN0IG51bVBhdGhzID0gcGF0aHMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBhdGhzOyArK2kpIHtcbiAgICBjb25zdCBwYXRoID0gcGF0aHNbaV07XG4gICAgY29uc3QgY29uZGl0aW9uID0gZmlsdGVyW3BhdGhdO1xuICAgIGlmIChjb25kaXRpb24gJiYgdHlwZW9mIGNvbmRpdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbktleXMgPSBPYmplY3Qua2V5cyhjb25kaXRpb24pO1xuICAgICAgY29uc3QgbnVtQ29uZGl0aW9uS2V5cyA9IGNvbmRpdGlvbktleXMubGVuZ3RoO1xuICAgICAgbGV0IGhhc0RvbGxhcktleSA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1Db25kaXRpb25LZXlzOyArK2opIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbktleXNbal0uc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICAgICAgaGFzRG9sbGFyS2V5ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc0RvbGxhcktleSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlZEtleXNbcGF0aF0gPSB0cnVlO1xuICAgIG1vZGlmaWVkW3BhdGhdID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3ZlcndyaXRlICYmICFoYXNEb2xsYXJVcGRhdGUpIHtcbiAgICAvLyBEZWZhdWx0cyB3aWxsIGJlIHNldCBsYXRlciwgc2luY2Ugd2UncmUgb3ZlcndyaXRpbmcgd2UnbGwgY2FzdFxuICAgIC8vIHRoZSB3aG9sZSB1cGRhdGUgdG8gYSBkb2N1bWVudFxuICAgIHJldHVybiBjYXN0ZWREb2M7XG4gIH1cblxuICBzY2hlbWEuZWFjaFBhdGgoZnVuY3Rpb24ocGF0aCwgc2NoZW1hVHlwZSkge1xuICAgIC8vIFNraXAgc2luZ2xlIG5lc3RlZCBwYXRocyBpZiB1bmRlcm5lYXRoIGEgbWFwXG4gICAgaWYgKHNjaGVtYVR5cGUucGF0aCA9PT0gJ19pZCcgJiYgc2NoZW1hVHlwZS5vcHRpb25zLmF1dG8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gc2NoZW1hVHlwZS5nZXREZWZhdWx0KG51bGwsIHRydWUpO1xuICAgIGlmIChpc01vZGlmaWVkKG1vZGlmaWVkLCBwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVR5cGUuc3BsaXRQYXRoKCkuaW5jbHVkZXMoJyQqJykpIHtcbiAgICAgIC8vIFNraXAgZGVmYXVsdHMgdW5kZXJuZWF0aCBtYXBzLiBXZSBzaG91bGQgbmV2ZXIgZG8gYCRzZXRPbkluc2VydGAgb24gYSBwYXRoIHdpdGggYCQqYFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhc3RlZERvYyA9IGNhc3RlZERvYyB8fCB7fTtcbiAgICBjYXN0ZWREb2MuJHNldE9uSW5zZXJ0ID0gY2FzdGVkRG9jLiRzZXRPbkluc2VydCB8fCB7fTtcbiAgICBpZiAoZ2V0KGNhc3RlZERvYywgcGF0aCkgPT0gbnVsbCkge1xuICAgICAgY2FzdGVkRG9jLiRzZXRPbkluc2VydFtwYXRoXSA9IGRlZjtcbiAgICB9XG4gICAgdXBkYXRlZFZhbHVlc1twYXRoXSA9IGRlZjtcbiAgfSk7XG5cbiAgcmV0dXJuIGNhc3RlZERvYztcbn07XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWQobW9kaWZpZWQsIHBhdGgpIHtcbiAgaWYgKG1vZGlmaWVkW3BhdGhdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJcyBhbnkgcGFyZW50IHBhdGggb2YgYHBhdGhgIG1vZGlmaWVkP1xuICBjb25zdCBzcCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgbGV0IGN1ciA9IHNwWzBdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHNwLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG1vZGlmaWVkW2N1cl0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjdXIgKz0gJy4nICsgc3BbaV07XG4gIH1cblxuICAvLyBJcyBhbnkgY2hpbGQgb2YgYHBhdGhgIG1vZGlmaWVkP1xuICBjb25zdCBtb2RpZmllZEtleXMgPSBPYmplY3Qua2V5cyhtb2RpZmllZCk7XG4gIGlmIChtb2RpZmllZEtleXMubGVuZ3RoKSB7XG4gICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGggKyAnLic7XG5cbiAgICBmb3IgKGNvbnN0IG1vZGlmaWVkUGF0aCBvZiBtb2RpZmllZEtleXMpIHtcbiAgICAgIGlmIChtb2RpZmllZFBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggKyAxKSA9PT0gcGFyZW50UGF0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/specialProperties.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/specialProperties.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = new Set(['__proto__', 'constructor', 'prototype']);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zcGVjaWFsUHJvcGVydGllcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHNwZWNpYWxQcm9wZXJ0aWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2V0KFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/specialProperties.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/symbols.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/symbols.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.arrayAtomicsBackupSymbol = Symbol('mongoose#Array#atomicsBackup');\nexports.arrayAtomicsSymbol = Symbol('mongoose#Array#_atomics');\nexports.arrayParentSymbol = Symbol('mongoose#Array#_parent');\nexports.arrayPathSymbol = Symbol('mongoose#Array#_path');\nexports.arraySchemaSymbol = Symbol('mongoose#Array#_schema');\nexports.documentArrayParent = Symbol('mongoose:documentArrayParent');\nexports.documentIsSelected = Symbol('mongoose#Document#isSelected');\nexports.documentIsModified = Symbol('mongoose#Document#isModified');\nexports.documentModifiedPaths = Symbol('mongoose#Document#modifiedPaths');\nexports.documentSchemaSymbol = Symbol('mongoose#Document#schema');\nexports.getSymbol = Symbol('mongoose#Document#get');\nexports.modelSymbol = Symbol('mongoose#Model');\nexports.objectIdSymbol = Symbol('mongoose#ObjectId');\nexports.populateModelSymbol = Symbol('mongoose.PopulateOptions#Model');\nexports.schemaTypeSymbol = Symbol('mongoose#schemaType');\nexports.sessionNewDocuments = Symbol('mongoose:ClientSession#newDocuments');\nexports.scopeSymbol = Symbol('mongoose#Document#scope');\nexports.validatorErrorSymbol = Symbol('mongoose:validatorError');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdDQUFnQztBQUNoQywwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0Isd0JBQXdCO0FBQ3hCLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkIsNEJBQTRCIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcc3ltYm9scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNBcnJheSNhdG9taWNzQmFja3VwJyk7XG5leHBvcnRzLmFycmF5QXRvbWljc1N5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjQXJyYXkjX2F0b21pY3MnKTtcbmV4cG9ydHMuYXJyYXlQYXJlbnRTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI0FycmF5I19wYXJlbnQnKTtcbmV4cG9ydHMuYXJyYXlQYXRoU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNBcnJheSNfcGF0aCcpO1xuZXhwb3J0cy5hcnJheVNjaGVtYVN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjQXJyYXkjX3NjaGVtYScpO1xuZXhwb3J0cy5kb2N1bWVudEFycmF5UGFyZW50ID0gU3ltYm9sKCdtb25nb29zZTpkb2N1bWVudEFycmF5UGFyZW50Jyk7XG5leHBvcnRzLmRvY3VtZW50SXNTZWxlY3RlZCA9IFN5bWJvbCgnbW9uZ29vc2UjRG9jdW1lbnQjaXNTZWxlY3RlZCcpO1xuZXhwb3J0cy5kb2N1bWVudElzTW9kaWZpZWQgPSBTeW1ib2woJ21vbmdvb3NlI0RvY3VtZW50I2lzTW9kaWZpZWQnKTtcbmV4cG9ydHMuZG9jdW1lbnRNb2RpZmllZFBhdGhzID0gU3ltYm9sKCdtb25nb29zZSNEb2N1bWVudCNtb2RpZmllZFBhdGhzJyk7XG5leHBvcnRzLmRvY3VtZW50U2NoZW1hU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNEb2N1bWVudCNzY2hlbWEnKTtcbmV4cG9ydHMuZ2V0U3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNEb2N1bWVudCNnZXQnKTtcbmV4cG9ydHMubW9kZWxTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI01vZGVsJyk7XG5leHBvcnRzLm9iamVjdElkU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNPYmplY3RJZCcpO1xuZXhwb3J0cy5wb3B1bGF0ZU1vZGVsU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZS5Qb3B1bGF0ZU9wdGlvbnMjTW9kZWwnKTtcbmV4cG9ydHMuc2NoZW1hVHlwZVN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2Ujc2NoZW1hVHlwZScpO1xuZXhwb3J0cy5zZXNzaW9uTmV3RG9jdW1lbnRzID0gU3ltYm9sKCdtb25nb29zZTpDbGllbnRTZXNzaW9uI25ld0RvY3VtZW50cycpO1xuZXhwb3J0cy5zY29wZVN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjRG9jdW1lbnQjc2NvcGUnKTtcbmV4cG9ydHMudmFsaWRhdG9yRXJyb3JTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlOnZhbGlkYXRvckVycm9yJyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/timers.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/timers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.setTimeout = setTimeout;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90aW1lcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcdGltZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/timers.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js":
/*!***************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function setDocumentTimestamps(doc, timestampOption, currentTime, createdAt, updatedAt) {\n  const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;\n  const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;\n\n  const defaultTimestamp = currentTime != null ?\n    currentTime() :\n    doc.ownerDocument().constructor.base.now();\n\n  if (!skipCreatedAt &&\n      (doc.isNew || doc.$isSubdocument) &&\n      createdAt &&\n      !doc.$__getValue(createdAt) &&\n      doc.$__isSelected(createdAt)) {\n    doc.$set(createdAt, defaultTimestamp, undefined, { overwriteImmutable: true });\n  }\n\n  if (!skipUpdatedAt && updatedAt && (doc.isNew || doc.$isModified())) {\n    let ts = defaultTimestamp;\n    if (doc.isNew && createdAt != null) {\n      ts = doc.$__getValue(createdAt);\n    }\n    doc.$set(updatedAt, ts);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90aW1lc3RhbXBzL3NldERvY3VtZW50VGltZXN0YW1wcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMEJBQTBCO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFx0aW1lc3RhbXBzXFxzZXREb2N1bWVudFRpbWVzdGFtcHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldERvY3VtZW50VGltZXN0YW1wcyhkb2MsIHRpbWVzdGFtcE9wdGlvbiwgY3VycmVudFRpbWUsIGNyZWF0ZWRBdCwgdXBkYXRlZEF0KSB7XG4gIGNvbnN0IHNraXBVcGRhdGVkQXQgPSB0aW1lc3RhbXBPcHRpb24gIT0gbnVsbCAmJiB0aW1lc3RhbXBPcHRpb24udXBkYXRlZEF0ID09PSBmYWxzZTtcbiAgY29uc3Qgc2tpcENyZWF0ZWRBdCA9IHRpbWVzdGFtcE9wdGlvbiAhPSBudWxsICYmIHRpbWVzdGFtcE9wdGlvbi5jcmVhdGVkQXQgPT09IGZhbHNlO1xuXG4gIGNvbnN0IGRlZmF1bHRUaW1lc3RhbXAgPSBjdXJyZW50VGltZSAhPSBudWxsID9cbiAgICBjdXJyZW50VGltZSgpIDpcbiAgICBkb2Mub3duZXJEb2N1bWVudCgpLmNvbnN0cnVjdG9yLmJhc2Uubm93KCk7XG5cbiAgaWYgKCFza2lwQ3JlYXRlZEF0ICYmXG4gICAgICAoZG9jLmlzTmV3IHx8IGRvYy4kaXNTdWJkb2N1bWVudCkgJiZcbiAgICAgIGNyZWF0ZWRBdCAmJlxuICAgICAgIWRvYy4kX19nZXRWYWx1ZShjcmVhdGVkQXQpICYmXG4gICAgICBkb2MuJF9faXNTZWxlY3RlZChjcmVhdGVkQXQpKSB7XG4gICAgZG9jLiRzZXQoY3JlYXRlZEF0LCBkZWZhdWx0VGltZXN0YW1wLCB1bmRlZmluZWQsIHsgb3ZlcndyaXRlSW1tdXRhYmxlOiB0cnVlIH0pO1xuICB9XG5cbiAgaWYgKCFza2lwVXBkYXRlZEF0ICYmIHVwZGF0ZWRBdCAmJiAoZG9jLmlzTmV3IHx8IGRvYy4kaXNNb2RpZmllZCgpKSkge1xuICAgIGxldCB0cyA9IGRlZmF1bHRUaW1lc3RhbXA7XG4gICAgaWYgKGRvYy5pc05ldyAmJiBjcmVhdGVkQXQgIT0gbnVsbCkge1xuICAgICAgdHMgPSBkb2MuJF9fZ2V0VmFsdWUoY3JlYXRlZEF0KTtcbiAgICB9XG4gICAgZG9jLiRzZXQodXBkYXRlZEF0LCB0cyk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst applyTimestampsToChildren = __webpack_require__(/*! ../update/applyTimestampsToChildren */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js\");\nconst applyTimestampsToUpdate = __webpack_require__(/*! ../update/applyTimestampsToUpdate */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js\");\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst handleTimestampOption = __webpack_require__(/*! ../schema/handleTimestampOption */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js\");\nconst setDocumentTimestamps = __webpack_require__(/*! ./setDocumentTimestamps */ \"(api)/../server/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js\");\nconst symbols = __webpack_require__(/*! ../../schema/symbols */ \"(api)/../server/node_modules/mongoose/lib/schema/symbols.js\");\n\nconst replaceOps = new Set([\n  'replaceOne',\n  'findOneAndReplace'\n]);\n\nmodule.exports = function setupTimestamps(schema, timestamps) {\n  const childHasTimestamp = schema.childSchemas.find(withTimestamp);\n  function withTimestamp(s) {\n    const ts = s.schema.options.timestamps;\n    return !!ts;\n  }\n  if (!timestamps && !childHasTimestamp) {\n    return;\n  }\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  const currentTime = timestamps != null && timestamps.hasOwnProperty('currentTime') ?\n    timestamps.currentTime :\n    null;\n  const schemaAdditions = {};\n\n  schema.$timestamps = { createdAt: createdAt, updatedAt: updatedAt };\n\n  if (createdAt && !schema.paths[createdAt]) {\n    const baseImmutableCreatedAt = schema.base != null ? schema.base.get('timestamps.createdAt.immutable') : null;\n    const immutable = baseImmutableCreatedAt != null ? baseImmutableCreatedAt : true;\n    schemaAdditions[createdAt] = { [schema.options.typeKey || 'type']: Date, immutable };\n  }\n\n  if (updatedAt && !schema.paths[updatedAt]) {\n    schemaAdditions[updatedAt] = Date;\n  }\n\n  schema.add(schemaAdditions);\n\n  schema.pre('save', function timestampsPreSave(next) {\n    const timestampOption = get(this, '$__.saveOptions.timestamps');\n    if (timestampOption === false) {\n      return next();\n    }\n\n    setDocumentTimestamps(this, timestampOption, currentTime, createdAt, updatedAt);\n\n    next();\n  });\n\n  schema.methods.initializeTimestamps = function() {\n    const ts = currentTime != null ?\n      currentTime() : this.constructor.base.now();\n\n\n    if (createdAt && !this.get(createdAt)) {\n      this.$set(createdAt, ts);\n    }\n    if (updatedAt && !this.get(updatedAt)) {\n      this.$set(updatedAt, ts);\n    }\n    if (this.$isSubdocument) {\n      return this;\n    }\n\n    const subdocs = this.$getAllSubdocs();\n    for (const subdoc of subdocs) {\n      if (subdoc.initializeTimestamps) {\n        subdoc.initializeTimestamps();\n      }\n    }\n\n    return this;\n  };\n\n  _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;\n\n  const opts = { query: true, model: false };\n  schema.pre('findOneAndReplace', opts, _setTimestampsOnUpdate);\n  schema.pre('findOneAndUpdate', opts, _setTimestampsOnUpdate);\n  schema.pre('replaceOne', opts, _setTimestampsOnUpdate);\n  schema.pre('update', opts, _setTimestampsOnUpdate);\n  schema.pre('updateOne', opts, _setTimestampsOnUpdate);\n  schema.pre('updateMany', opts, _setTimestampsOnUpdate);\n\n  function _setTimestampsOnUpdate(next) {\n    const now = currentTime != null ?\n      currentTime() :\n      this.model.base.now();\n    // Replacing with null update should still trigger timestamps\n    if (replaceOps.has(this.op) && this.getUpdate() == null) {\n      this.setUpdate({});\n    }\n    applyTimestampsToUpdate(\n      now,\n      createdAt,\n      updatedAt,\n      this.getUpdate(),\n      this._mongooseOptions,\n      this.schema\n    );\n    applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);\n    next();\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90aW1lc3RhbXBzL3NldHVwVGltZXN0YW1wcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQ0FBa0MsbUJBQU8sQ0FBQyxrSUFBcUM7QUFDL0UsZ0NBQWdDLG1CQUFPLENBQUMsOEhBQW1DO0FBQzNFLFlBQVksbUJBQU8sQ0FBQyx3RUFBUTtBQUM1Qiw4QkFBOEIsbUJBQU8sQ0FBQywwSEFBaUM7QUFDdkUsOEJBQThCLG1CQUFPLENBQUMsc0hBQXlCO0FBQy9ELGdCQUFnQixtQkFBTyxDQUFDLHlGQUFzQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHRpbWVzdGFtcHNcXHNldHVwVGltZXN0YW1wcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4gPSByZXF1aXJlKCcuLi91cGRhdGUvYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbicpO1xuY29uc3QgYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGUgPSByZXF1aXJlKCcuLi91cGRhdGUvYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGUnKTtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuY29uc3QgaGFuZGxlVGltZXN0YW1wT3B0aW9uID0gcmVxdWlyZSgnLi4vc2NoZW1hL2hhbmRsZVRpbWVzdGFtcE9wdGlvbicpO1xuY29uc3Qgc2V0RG9jdW1lbnRUaW1lc3RhbXBzID0gcmVxdWlyZSgnLi9zZXREb2N1bWVudFRpbWVzdGFtcHMnKTtcbmNvbnN0IHN5bWJvbHMgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvc3ltYm9scycpO1xuXG5jb25zdCByZXBsYWNlT3BzID0gbmV3IFNldChbXG4gICdyZXBsYWNlT25lJyxcbiAgJ2ZpbmRPbmVBbmRSZXBsYWNlJ1xuXSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dXBUaW1lc3RhbXBzKHNjaGVtYSwgdGltZXN0YW1wcykge1xuICBjb25zdCBjaGlsZEhhc1RpbWVzdGFtcCA9IHNjaGVtYS5jaGlsZFNjaGVtYXMuZmluZCh3aXRoVGltZXN0YW1wKTtcbiAgZnVuY3Rpb24gd2l0aFRpbWVzdGFtcChzKSB7XG4gICAgY29uc3QgdHMgPSBzLnNjaGVtYS5vcHRpb25zLnRpbWVzdGFtcHM7XG4gICAgcmV0dXJuICEhdHM7XG4gIH1cbiAgaWYgKCF0aW1lc3RhbXBzICYmICFjaGlsZEhhc1RpbWVzdGFtcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjcmVhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ2NyZWF0ZWRBdCcpO1xuICBjb25zdCB1cGRhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ3VwZGF0ZWRBdCcpO1xuICBjb25zdCBjdXJyZW50VGltZSA9IHRpbWVzdGFtcHMgIT0gbnVsbCAmJiB0aW1lc3RhbXBzLmhhc093blByb3BlcnR5KCdjdXJyZW50VGltZScpID9cbiAgICB0aW1lc3RhbXBzLmN1cnJlbnRUaW1lIDpcbiAgICBudWxsO1xuICBjb25zdCBzY2hlbWFBZGRpdGlvbnMgPSB7fTtcblxuICBzY2hlbWEuJHRpbWVzdGFtcHMgPSB7IGNyZWF0ZWRBdDogY3JlYXRlZEF0LCB1cGRhdGVkQXQ6IHVwZGF0ZWRBdCB9O1xuXG4gIGlmIChjcmVhdGVkQXQgJiYgIXNjaGVtYS5wYXRoc1tjcmVhdGVkQXRdKSB7XG4gICAgY29uc3QgYmFzZUltbXV0YWJsZUNyZWF0ZWRBdCA9IHNjaGVtYS5iYXNlICE9IG51bGwgPyBzY2hlbWEuYmFzZS5nZXQoJ3RpbWVzdGFtcHMuY3JlYXRlZEF0LmltbXV0YWJsZScpIDogbnVsbDtcbiAgICBjb25zdCBpbW11dGFibGUgPSBiYXNlSW1tdXRhYmxlQ3JlYXRlZEF0ICE9IG51bGwgPyBiYXNlSW1tdXRhYmxlQ3JlYXRlZEF0IDogdHJ1ZTtcbiAgICBzY2hlbWFBZGRpdGlvbnNbY3JlYXRlZEF0XSA9IHsgW3NjaGVtYS5vcHRpb25zLnR5cGVLZXkgfHwgJ3R5cGUnXTogRGF0ZSwgaW1tdXRhYmxlIH07XG4gIH1cblxuICBpZiAodXBkYXRlZEF0ICYmICFzY2hlbWEucGF0aHNbdXBkYXRlZEF0XSkge1xuICAgIHNjaGVtYUFkZGl0aW9uc1t1cGRhdGVkQXRdID0gRGF0ZTtcbiAgfVxuXG4gIHNjaGVtYS5hZGQoc2NoZW1hQWRkaXRpb25zKTtcblxuICBzY2hlbWEucHJlKCdzYXZlJywgZnVuY3Rpb24gdGltZXN0YW1wc1ByZVNhdmUobmV4dCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcE9wdGlvbiA9IGdldCh0aGlzLCAnJF9fLnNhdmVPcHRpb25zLnRpbWVzdGFtcHMnKTtcbiAgICBpZiAodGltZXN0YW1wT3B0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG5cbiAgICBzZXREb2N1bWVudFRpbWVzdGFtcHModGhpcywgdGltZXN0YW1wT3B0aW9uLCBjdXJyZW50VGltZSwgY3JlYXRlZEF0LCB1cGRhdGVkQXQpO1xuXG4gICAgbmV4dCgpO1xuICB9KTtcblxuICBzY2hlbWEubWV0aG9kcy5pbml0aWFsaXplVGltZXN0YW1wcyA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHRzID0gY3VycmVudFRpbWUgIT0gbnVsbCA/XG4gICAgICBjdXJyZW50VGltZSgpIDogdGhpcy5jb25zdHJ1Y3Rvci5iYXNlLm5vdygpO1xuXG5cbiAgICBpZiAoY3JlYXRlZEF0ICYmICF0aGlzLmdldChjcmVhdGVkQXQpKSB7XG4gICAgICB0aGlzLiRzZXQoY3JlYXRlZEF0LCB0cyk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVkQXQgJiYgIXRoaXMuZ2V0KHVwZGF0ZWRBdCkpIHtcbiAgICAgIHRoaXMuJHNldCh1cGRhdGVkQXQsIHRzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuJGlzU3ViZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IHN1YmRvY3MgPSB0aGlzLiRnZXRBbGxTdWJkb2NzKCk7XG4gICAgZm9yIChjb25zdCBzdWJkb2Mgb2Ygc3ViZG9jcykge1xuICAgICAgaWYgKHN1YmRvYy5pbml0aWFsaXplVGltZXN0YW1wcykge1xuICAgICAgICBzdWJkb2MuaW5pdGlhbGl6ZVRpbWVzdGFtcHMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfc2V0VGltZXN0YW1wc09uVXBkYXRlW3N5bWJvbHMuYnVpbHRJbk1pZGRsZXdhcmVdID0gdHJ1ZTtcblxuICBjb25zdCBvcHRzID0geyBxdWVyeTogdHJ1ZSwgbW9kZWw6IGZhbHNlIH07XG4gIHNjaGVtYS5wcmUoJ2ZpbmRPbmVBbmRSZXBsYWNlJywgb3B0cywgX3NldFRpbWVzdGFtcHNPblVwZGF0ZSk7XG4gIHNjaGVtYS5wcmUoJ2ZpbmRPbmVBbmRVcGRhdGUnLCBvcHRzLCBfc2V0VGltZXN0YW1wc09uVXBkYXRlKTtcbiAgc2NoZW1hLnByZSgncmVwbGFjZU9uZScsIG9wdHMsIF9zZXRUaW1lc3RhbXBzT25VcGRhdGUpO1xuICBzY2hlbWEucHJlKCd1cGRhdGUnLCBvcHRzLCBfc2V0VGltZXN0YW1wc09uVXBkYXRlKTtcbiAgc2NoZW1hLnByZSgndXBkYXRlT25lJywgb3B0cywgX3NldFRpbWVzdGFtcHNPblVwZGF0ZSk7XG4gIHNjaGVtYS5wcmUoJ3VwZGF0ZU1hbnknLCBvcHRzLCBfc2V0VGltZXN0YW1wc09uVXBkYXRlKTtcblxuICBmdW5jdGlvbiBfc2V0VGltZXN0YW1wc09uVXBkYXRlKG5leHQpIHtcbiAgICBjb25zdCBub3cgPSBjdXJyZW50VGltZSAhPSBudWxsID9cbiAgICAgIGN1cnJlbnRUaW1lKCkgOlxuICAgICAgdGhpcy5tb2RlbC5iYXNlLm5vdygpO1xuICAgIC8vIFJlcGxhY2luZyB3aXRoIG51bGwgdXBkYXRlIHNob3VsZCBzdGlsbCB0cmlnZ2VyIHRpbWVzdGFtcHNcbiAgICBpZiAocmVwbGFjZU9wcy5oYXModGhpcy5vcCkgJiYgdGhpcy5nZXRVcGRhdGUoKSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnNldFVwZGF0ZSh7fSk7XG4gICAgfVxuICAgIGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlKFxuICAgICAgbm93LFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgdXBkYXRlZEF0LFxuICAgICAgdGhpcy5nZXRVcGRhdGUoKSxcbiAgICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucyxcbiAgICAgIHRoaXMuc2NoZW1hXG4gICAgKTtcbiAgICBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgdGhpcy5nZXRVcGRhdGUoKSwgdGhpcy5tb2RlbC5zY2hlbWEpO1xuICAgIG5leHQoKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\n\nmodule.exports = function allServersUnknown(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  const servers = Array.from(topologyDescription.servers.values());\n  return servers.length > 0 && servers.every(server => server.type === 'Unknown');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90b3BvbG9neS9hbGxTZXJ2ZXJzVW5rbm93bi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBdUI7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHRvcG9sb2d5XFxhbGxTZXJ2ZXJzVW5rbm93bi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2dldENvbnN0cnVjdG9yTmFtZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFsbFNlcnZlcnNVbmtub3duKHRvcG9sb2d5RGVzY3JpcHRpb24pIHtcbiAgaWYgKGdldENvbnN0cnVjdG9yTmFtZSh0b3BvbG9neURlc2NyaXB0aW9uKSAhPT0gJ1RvcG9sb2d5RGVzY3JpcHRpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgc2VydmVycyA9IEFycmF5LmZyb20odG9wb2xvZ3lEZXNjcmlwdGlvbi5zZXJ2ZXJzLnZhbHVlcygpKTtcbiAgcmV0dXJuIHNlcnZlcnMubGVuZ3RoID4gMCAmJiBzZXJ2ZXJzLmV2ZXJ5KHNlcnZlciA9PiBzZXJ2ZXIudHlwZSA9PT0gJ1Vua25vd24nKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/topology/isAtlas.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/topology/isAtlas.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\n\n/**\n * @typedef { import('mongodb').TopologyDescription } TopologyDescription\n */\n\n/**\n * Checks if topologyDescription contains servers connected to an atlas instance\n *\n * @param  {TopologyDescription} topologyDescription\n * @returns {boolean}\n */\nmodule.exports = function isAtlas(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  if (topologyDescription.servers.size === 0) {\n    return false;\n  }\n\n  for (const server of topologyDescription.servers.values()) {\n    if (server.host.endsWith('.mongodb.net') === false || server.port !== 27017) {\n      return false;\n    }\n  }\n\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90b3BvbG9neS9pc0F0bGFzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDJCQUEyQixtQkFBTyxDQUFDLHNHQUF1Qjs7QUFFMUQ7QUFDQSxjQUFjLHdDQUF3QztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcdG9wb2xvZ3lcXGlzQXRsYXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuLi9nZXRDb25zdHJ1Y3Rvck5hbWUnKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnbW9uZ29kYicpLlRvcG9sb2d5RGVzY3JpcHRpb24gfSBUb3BvbG9neURlc2NyaXB0aW9uXG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgdG9wb2xvZ3lEZXNjcmlwdGlvbiBjb250YWlucyBzZXJ2ZXJzIGNvbm5lY3RlZCB0byBhbiBhdGxhcyBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAge1RvcG9sb2d5RGVzY3JpcHRpb259IHRvcG9sb2d5RGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXRsYXModG9wb2xvZ3lEZXNjcmlwdGlvbikge1xuICBpZiAoZ2V0Q29uc3RydWN0b3JOYW1lKHRvcG9sb2d5RGVzY3JpcHRpb24pICE9PSAnVG9wb2xvZ3lEZXNjcmlwdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodG9wb2xvZ3lEZXNjcmlwdGlvbi5zZXJ2ZXJzLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IHNlcnZlciBvZiB0b3BvbG9neURlc2NyaXB0aW9uLnNlcnZlcnMudmFsdWVzKCkpIHtcbiAgICBpZiAoc2VydmVyLmhvc3QuZW5kc1dpdGgoJy5tb25nb2RiLm5ldCcpID09PSBmYWxzZSB8fCBzZXJ2ZXIucG9ydCAhPT0gMjcwMTcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/topology/isAtlas.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/topology/isSSLError.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/topology/isSSLError.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\n\nconst nonSSLMessage = 'Client network socket disconnected before secure TLS ' +\n  'connection was established';\n\nmodule.exports = function isSSLError(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  const descriptions = Array.from(topologyDescription.servers.values());\n  return descriptions.length > 0 &&\n    descriptions.every(descr => descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90b3BvbG9neS9pc1NTTEVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDJCQUEyQixtQkFBTyxDQUFDLHNHQUF1Qjs7QUFFMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHRvcG9sb2d5XFxpc1NTTEVycm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi4vZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5cbmNvbnN0IG5vblNTTE1lc3NhZ2UgPSAnQ2xpZW50IG5ldHdvcmsgc29ja2V0IGRpc2Nvbm5lY3RlZCBiZWZvcmUgc2VjdXJlIFRMUyAnICtcbiAgJ2Nvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1NTTEVycm9yKHRvcG9sb2d5RGVzY3JpcHRpb24pIHtcbiAgaWYgKGdldENvbnN0cnVjdG9yTmFtZSh0b3BvbG9neURlc2NyaXB0aW9uKSAhPT0gJ1RvcG9sb2d5RGVzY3JpcHRpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZGVzY3JpcHRpb25zID0gQXJyYXkuZnJvbSh0b3BvbG9neURlc2NyaXB0aW9uLnNlcnZlcnMudmFsdWVzKCkpO1xuICByZXR1cm4gZGVzY3JpcHRpb25zLmxlbmd0aCA+IDAgJiZcbiAgICBkZXNjcmlwdGlvbnMuZXZlcnkoZGVzY3IgPT4gZGVzY3IuZXJyb3IgJiYgZGVzY3IuZXJyb3IubWVzc2FnZS5pbmRleE9mKG5vblNTTE1lc3NhZ2UpICE9PSAtMSk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/topology/isSSLError.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/updateValidators.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/updateValidators.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ValidationError = __webpack_require__(/*! ../error/validation */ \"(api)/../server/node_modules/mongoose/lib/error/validation.js\");\nconst cleanPositionalOperators = __webpack_require__(/*! ./schema/cleanPositionalOperators */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst flatten = (__webpack_require__(/*! ./common */ \"(api)/../server/node_modules/mongoose/lib/helpers/common.js\").flatten);\nconst modifiedPaths = (__webpack_require__(/*! ./common */ \"(api)/../server/node_modules/mongoose/lib/helpers/common.js\").modifiedPaths);\n\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\nmodule.exports = function(query, schema, castedDoc, options, callback) {\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  const modified = {};\n  let currentUpdate;\n  let key;\n  let i;\n\n  for (i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      hasDollarUpdate = true;\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        const _keys = Object.keys(castedDoc[keys[i]]);\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n          if (currentUpdate && currentUpdate.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat([currentUpdate]);\n          }\n        }\n        continue;\n      }\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n      for (let j = 0; j < numPaths; ++j) {\n        const updatedPath = cleanPositionalOperators(paths[j]);\n        key = keys[i];\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n        if (updatedPath.includes('$')) {\n          continue;\n        }\n        if (key === '$set' || key === '$setOnInsert' ||\n            key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n    updatedValues = flatten(castedDoc, null, null, schema);\n    updatedKeys = Object.keys(updatedValues);\n  }\n\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n\n  const alreadyValidated = [];\n\n  const context = query;\n  function iter(i, v) {\n    const schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath == null) {\n      return;\n    }\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\n      return;\n    }\n\n    if (v && Array.isArray(v.$in)) {\n      v.$in.forEach((v, i) => {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            v,\n            function(err) {\n              if (err) {\n                err.path = updates[i] + '.$in.' + i;\n                validationErrors.push(err);\n              }\n              callback(null);\n            },\n            context,\n            { updateValidator: true });\n        });\n      });\n    } else {\n      if (isPull[updates[i]] &&\n          schemaPath.$isMongooseArray) {\n        return;\n      }\n\n      if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {\n        alreadyValidated.push(updates[i]);\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(v, function(err) {\n            if (err) {\n              if (err.errors) {\n                for (const key of Object.keys(err.errors)) {\n                  const _err = err.errors[key];\n                  _err.path = updates[i] + '.' + key;\n                  validationErrors.push(_err);\n                }\n              } else {\n                err.path = updates[i];\n                validationErrors.push(err);\n              }\n            }\n\n            return callback(null);\n          }, context, { updateValidator: true });\n        });\n      } else {\n        validatorsToExecute.push(function(callback) {\n          for (const path of alreadyValidated) {\n            if (updates[i].startsWith(path + '.')) {\n              return callback(null);\n            }\n          }\n\n          schemaPath.doValidate(v, function(err) {\n            if (schemaPath.schema != null &&\n                schemaPath.schema.options.storeSubdocValidationError === false &&\n                err instanceof ValidationError) {\n              return callback(null);\n            }\n\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n            }\n            callback(null);\n          }, context, { updateValidator: true });\n        });\n      }\n    }\n  }\n  for (i = 0; i < numUpdates; ++i) {\n    iter(i, updatedValues[updates[i]]);\n  }\n\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n  for (const arrayUpdate of arrayUpdates) {\n    let schemaPath = schema._getSchema(arrayUpdate);\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n      validatorsToExecute.push(function(callback) {\n        schemaPath.doValidate(\n          arrayAtomicUpdates[arrayUpdate],\n          getValidationCallback(arrayUpdate, validationErrors, callback),\n          options && options.context === 'query' ? query : null);\n      });\n    } else {\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            atomicUpdate,\n            getValidationCallback(arrayUpdate, validationErrors, callback),\n            options && options.context === 'query' ? query : null,\n            { updateValidator: true });\n        });\n      }\n    }\n  }\n\n  if (callback != null) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n\n    return;\n  }\n\n  return function(callback) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n  };\n\n  function _done(callback) {\n    if (validationErrors.length) {\n      const err = new ValidationError(null);\n\n      for (const validationError of validationErrors) {\n        err.addError(validationError.path, validationError);\n      }\n\n      return callback(err);\n    }\n    callback(null);\n  }\n\n  function getValidationCallback(arrayUpdate, validationErrors, callback) {\n    return function(err) {\n      if (err) {\n        err.path = arrayUpdate;\n        validationErrors.push(err);\n      }\n      callback(null);\n    };\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGVWYWxpZGF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQU8sQ0FBQywwRkFBcUI7QUFDckQsaUNBQWlDLG1CQUFPLENBQUMsK0hBQW1DO0FBQzVFLGdCQUFnQiw0R0FBMkI7QUFDM0Msc0JBQXNCLGtIQUFpQzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckMsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsYUFBYSx1QkFBdUI7QUFDL0MsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWEsdUJBQXVCO0FBQy9DLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcdXBkYXRlVmFsaWRhdG9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uJyk7XG5jb25zdCBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMgPSByZXF1aXJlKCcuL3NjaGVtYS9jbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMnKTtcbmNvbnN0IGZsYXR0ZW4gPSByZXF1aXJlKCcuL2NvbW1vbicpLmZsYXR0ZW47XG5jb25zdCBtb2RpZmllZFBhdGhzID0gcmVxdWlyZSgnLi9jb21tb24nKS5tb2RpZmllZFBhdGhzO1xuXG4vKipcbiAqIEFwcGxpZXMgdmFsaWRhdG9ycyBhbmQgZGVmYXVsdHMgdG8gdXBkYXRlIGFuZCBmaW5kT25lQW5kVXBkYXRlIG9wZXJhdGlvbnMsXG4gKiBzcGVjaWZpY2FsbHkgcGFzc2luZyBhIG51bGwgZG9jIGFzIGB0aGlzYCB0byB2YWxpZGF0b3JzIGFuZCBkZWZhdWx0c1xuICpcbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5XG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gY2FzdGVkRG9jXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQG1ldGhvZCBydW5WYWxpZGF0b3JzT25VcGRhdGVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXVlcnksIHNjaGVtYSwgY2FzdGVkRG9jLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2FzdGVkRG9jIHx8IHt9KTtcbiAgbGV0IHVwZGF0ZWRLZXlzID0ge307XG4gIGxldCB1cGRhdGVkVmFsdWVzID0ge307XG4gIGNvbnN0IGlzUHVsbCA9IHt9O1xuICBjb25zdCBhcnJheUF0b21pY1VwZGF0ZXMgPSB7fTtcbiAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICBsZXQgaGFzRG9sbGFyVXBkYXRlID0gZmFsc2U7XG4gIGNvbnN0IG1vZGlmaWVkID0ge307XG4gIGxldCBjdXJyZW50VXBkYXRlO1xuICBsZXQga2V5O1xuICBsZXQgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgaWYgKGtleXNbaV0uc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICBoYXNEb2xsYXJVcGRhdGUgPSB0cnVlO1xuICAgICAgaWYgKGtleXNbaV0gPT09ICckcHVzaCcgfHwga2V5c1tpXSA9PT0gJyRhZGRUb1NldCcpIHtcbiAgICAgICAgY29uc3QgX2tleXMgPSBPYmplY3Qua2V5cyhjYXN0ZWREb2Nba2V5c1tpXV0pO1xuICAgICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgX2tleXMubGVuZ3RoOyArK2lpKSB7XG4gICAgICAgICAgY3VycmVudFVwZGF0ZSA9IGNhc3RlZERvY1trZXlzW2ldXVtfa2V5c1tpaV1dO1xuICAgICAgICAgIGlmIChjdXJyZW50VXBkYXRlICYmIGN1cnJlbnRVcGRhdGUuJGVhY2gpIHtcbiAgICAgICAgICAgIGFycmF5QXRvbWljVXBkYXRlc1tfa2V5c1tpaV1dID0gKGFycmF5QXRvbWljVXBkYXRlc1tfa2V5c1tpaV1dIHx8IFtdKS5cbiAgICAgICAgICAgICAgY29uY2F0KGN1cnJlbnRVcGRhdGUuJGVhY2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheUF0b21pY1VwZGF0ZXNbX2tleXNbaWldXSA9IChhcnJheUF0b21pY1VwZGF0ZXNbX2tleXNbaWldXSB8fCBbXSkuXG4gICAgICAgICAgICAgIGNvbmNhdChbY3VycmVudFVwZGF0ZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1vZGlmaWVkUGF0aHMoY2FzdGVkRG9jW2tleXNbaV1dLCAnJywgbW9kaWZpZWQpO1xuICAgICAgY29uc3QgZmxhdCA9IGZsYXR0ZW4oY2FzdGVkRG9jW2tleXNbaV1dLCBudWxsLCBudWxsLCBzY2hlbWEpO1xuICAgICAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhmbGF0KTtcbiAgICAgIGNvbnN0IG51bVBhdGhzID0gcGF0aHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1QYXRoczsgKytqKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRQYXRoID0gY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzKHBhdGhzW2pdKTtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgLy8gV2l0aCBgJHB1bGxgIHdlIG1pZ2h0IGZsYXR0ZW4gYCRpbmAuIFNraXAgc3R1ZmYgbmVzdGVkIHVuZGVyIGAkaW5gXG4gICAgICAgIC8vIGZvciB0aGUgcmVzdCBvZiB0aGUgbG9naWMsIGl0IHdpbGwgZ2V0IGhhbmRsZWQgbGF0ZXIuXG4gICAgICAgIGlmICh1cGRhdGVkUGF0aC5pbmNsdWRlcygnJCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gJyRzZXQnIHx8IGtleSA9PT0gJyRzZXRPbkluc2VydCcgfHxcbiAgICAgICAgICAgIGtleSA9PT0gJyRwdWxsJyB8fCBrZXkgPT09ICckcHVsbEFsbCcpIHtcbiAgICAgICAgICB1cGRhdGVkVmFsdWVzW3VwZGF0ZWRQYXRoXSA9IGZsYXRbcGF0aHNbal1dO1xuICAgICAgICAgIGlzUHVsbFt1cGRhdGVkUGF0aF0gPSBrZXkgPT09ICckcHVsbCcgfHwga2V5ID09PSAnJHB1bGxBbGwnO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJyR1bnNldCcpIHtcbiAgICAgICAgICB1cGRhdGVkVmFsdWVzW3VwZGF0ZWRQYXRoXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkS2V5c1t1cGRhdGVkUGF0aF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghaGFzRG9sbGFyVXBkYXRlKSB7XG4gICAgbW9kaWZpZWRQYXRocyhjYXN0ZWREb2MsICcnLCBtb2RpZmllZCk7XG4gICAgdXBkYXRlZFZhbHVlcyA9IGZsYXR0ZW4oY2FzdGVkRG9jLCBudWxsLCBudWxsLCBzY2hlbWEpO1xuICAgIHVwZGF0ZWRLZXlzID0gT2JqZWN0LmtleXModXBkYXRlZFZhbHVlcyk7XG4gIH1cblxuICBjb25zdCB1cGRhdGVzID0gT2JqZWN0LmtleXModXBkYXRlZFZhbHVlcyk7XG4gIGNvbnN0IG51bVVwZGF0ZXMgPSB1cGRhdGVzLmxlbmd0aDtcbiAgY29uc3QgdmFsaWRhdG9yc1RvRXhlY3V0ZSA9IFtdO1xuICBjb25zdCB2YWxpZGF0aW9uRXJyb3JzID0gW107XG5cbiAgY29uc3QgYWxyZWFkeVZhbGlkYXRlZCA9IFtdO1xuXG4gIGNvbnN0IGNvbnRleHQgPSBxdWVyeTtcbiAgZnVuY3Rpb24gaXRlcihpLCB2KSB7XG4gICAgY29uc3Qgc2NoZW1hUGF0aCA9IHNjaGVtYS5fZ2V0U2NoZW1hKHVwZGF0ZXNbaV0pO1xuICAgIGlmIChzY2hlbWFQYXRoID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVBhdGguaW5zdGFuY2UgPT09ICdNaXhlZCcgJiYgc2NoZW1hUGF0aC5wYXRoICE9PSB1cGRhdGVzW2ldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHYgJiYgQXJyYXkuaXNBcnJheSh2LiRpbikpIHtcbiAgICAgIHYuJGluLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgdmFsaWRhdG9yc1RvRXhlY3V0ZS5wdXNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgc2NoZW1hUGF0aC5kb1ZhbGlkYXRlKFxuICAgICAgICAgICAgdixcbiAgICAgICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyLnBhdGggPSB1cGRhdGVzW2ldICsgJy4kaW4uJyArIGk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHsgdXBkYXRlVmFsaWRhdG9yOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNQdWxsW3VwZGF0ZXNbaV1dICYmXG4gICAgICAgICAgc2NoZW1hUGF0aC4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjaGVtYVBhdGguJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCAmJiB2ICE9IG51bGwgJiYgdi4kX18gIT0gbnVsbCkge1xuICAgICAgICBhbHJlYWR5VmFsaWRhdGVkLnB1c2godXBkYXRlc1tpXSk7XG4gICAgICAgIHZhbGlkYXRvcnNUb0V4ZWN1dGUucHVzaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIHNjaGVtYVBhdGguZG9WYWxpZGF0ZSh2LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGVyci5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhlcnIuZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgX2VyciA9IGVyci5lcnJvcnNba2V5XTtcbiAgICAgICAgICAgICAgICAgIF9lcnIucGF0aCA9IHVwZGF0ZXNbaV0gKyAnLicgKyBrZXk7XG4gICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goX2Vycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyci5wYXRoID0gdXBkYXRlc1tpXTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgfSwgY29udGV4dCwgeyB1cGRhdGVWYWxpZGF0b3I6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdG9yc1RvRXhlY3V0ZS5wdXNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIGFscmVhZHlWYWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGVzW2ldLnN0YXJ0c1dpdGgocGF0aCArICcuJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjaGVtYVBhdGguZG9WYWxpZGF0ZSh2LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFQYXRoLnNjaGVtYSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aC5zY2hlbWEub3B0aW9ucy5zdG9yZVN1YmRvY1ZhbGlkYXRpb25FcnJvciA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGVyci5wYXRoID0gdXBkYXRlc1tpXTtcbiAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICB9LCBjb250ZXh0LCB7IHVwZGF0ZVZhbGlkYXRvcjogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBudW1VcGRhdGVzOyArK2kpIHtcbiAgICBpdGVyKGksIHVwZGF0ZWRWYWx1ZXNbdXBkYXRlc1tpXV0pO1xuICB9XG5cbiAgY29uc3QgYXJyYXlVcGRhdGVzID0gT2JqZWN0LmtleXMoYXJyYXlBdG9taWNVcGRhdGVzKTtcbiAgZm9yIChjb25zdCBhcnJheVVwZGF0ZSBvZiBhcnJheVVwZGF0ZXMpIHtcbiAgICBsZXQgc2NoZW1hUGF0aCA9IHNjaGVtYS5fZ2V0U2NoZW1hKGFycmF5VXBkYXRlKTtcbiAgICBpZiAoc2NoZW1hUGF0aCAmJiBzY2hlbWFQYXRoLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgdmFsaWRhdG9yc1RvRXhlY3V0ZS5wdXNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHNjaGVtYVBhdGguZG9WYWxpZGF0ZShcbiAgICAgICAgICBhcnJheUF0b21pY1VwZGF0ZXNbYXJyYXlVcGRhdGVdLFxuICAgICAgICAgIGdldFZhbGlkYXRpb25DYWxsYmFjayhhcnJheVVwZGF0ZSwgdmFsaWRhdGlvbkVycm9ycywgY2FsbGJhY2spLFxuICAgICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID09PSAncXVlcnknID8gcXVlcnkgOiBudWxsKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlbWFQYXRoID0gc2NoZW1hLl9nZXRTY2hlbWEoYXJyYXlVcGRhdGUgKyAnLjAnKTtcbiAgICAgIGZvciAoY29uc3QgYXRvbWljVXBkYXRlIG9mIGFycmF5QXRvbWljVXBkYXRlc1thcnJheVVwZGF0ZV0pIHtcbiAgICAgICAgdmFsaWRhdG9yc1RvRXhlY3V0ZS5wdXNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgc2NoZW1hUGF0aC5kb1ZhbGlkYXRlKFxuICAgICAgICAgICAgYXRvbWljVXBkYXRlLFxuICAgICAgICAgICAgZ2V0VmFsaWRhdGlvbkNhbGxiYWNrKGFycmF5VXBkYXRlLCB2YWxpZGF0aW9uRXJyb3JzLCBjYWxsYmFjayksXG4gICAgICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA9PT0gJ3F1ZXJ5JyA/IHF1ZXJ5IDogbnVsbCxcbiAgICAgICAgICAgIHsgdXBkYXRlVmFsaWRhdG9yOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgIGxldCBudW1WYWxpZGF0b3JzID0gdmFsaWRhdG9yc1RvRXhlY3V0ZS5sZW5ndGg7XG4gICAgaWYgKG51bVZhbGlkYXRvcnMgPT09IDApIHtcbiAgICAgIHJldHVybiBfZG9uZShjYWxsYmFjayk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsaWRhdG9yIG9mIHZhbGlkYXRvcnNUb0V4ZWN1dGUpIHtcbiAgICAgIHZhbGlkYXRvcihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbnVtVmFsaWRhdG9ycyA8PSAwKSB7XG4gICAgICAgICAgX2RvbmUoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBsZXQgbnVtVmFsaWRhdG9ycyA9IHZhbGlkYXRvcnNUb0V4ZWN1dGUubGVuZ3RoO1xuICAgIGlmIChudW1WYWxpZGF0b3JzID09PSAwKSB7XG4gICAgICByZXR1cm4gX2RvbmUoY2FsbGJhY2spO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHZhbGlkYXRvciBvZiB2YWxpZGF0b3JzVG9FeGVjdXRlKSB7XG4gICAgICB2YWxpZGF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW51bVZhbGlkYXRvcnMgPD0gMCkge1xuICAgICAgICAgIF9kb25lKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIF9kb25lKGNhbGxiYWNrKSB7XG4gICAgaWYgKHZhbGlkYXRpb25FcnJvcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgVmFsaWRhdGlvbkVycm9yKG51bGwpO1xuXG4gICAgICBmb3IgKGNvbnN0IHZhbGlkYXRpb25FcnJvciBvZiB2YWxpZGF0aW9uRXJyb3JzKSB7XG4gICAgICAgIGVyci5hZGRFcnJvcih2YWxpZGF0aW9uRXJyb3IucGF0aCwgdmFsaWRhdGlvbkVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmFsaWRhdGlvbkNhbGxiYWNrKGFycmF5VXBkYXRlLCB2YWxpZGF0aW9uRXJyb3JzLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyLnBhdGggPSBhcnJheVVwZGF0ZTtcbiAgICAgICAgdmFsaWRhdGlvbkVycm9ycy5wdXNoKGVycik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9O1xuICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/updateValidators.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js":
/*!***************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst cleanPositionalOperators = __webpack_require__(/*! ../schema/cleanPositionalOperators */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst handleTimestampOption = __webpack_require__(/*! ../schema/handleTimestampOption */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js\");\n\nmodule.exports = applyTimestampsToChildren;\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToChildren(now, update, schema) {\n  if (update == null) {\n    return;\n  }\n\n  const keys = Object.keys(update);\n  const hasDollarKey = keys.some(key => key[0] === '$');\n\n  if (hasDollarKey) {\n    if (update.$push) {\n      _applyTimestampToUpdateOperator(update.$push);\n    }\n    if (update.$addToSet) {\n      _applyTimestampToUpdateOperator(update.$addToSet);\n    }\n    if (update.$set != null) {\n      const keys = Object.keys(update.$set);\n      for (const key of keys) {\n        applyTimestampsToUpdateKey(schema, key, update.$set, now);\n      }\n    }\n    if (update.$setOnInsert != null) {\n      const keys = Object.keys(update.$setOnInsert);\n      for (const key of keys) {\n        applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);\n      }\n    }\n  }\n\n  const updateKeys = Object.keys(update).filter(key => key[0] !== '$');\n  for (const key of updateKeys) {\n    applyTimestampsToUpdateKey(schema, key, update, now);\n  }\n\n  function _applyTimestampToUpdateOperator(op) {\n    for (const key of Object.keys(op)) {\n      const $path = schema.path(key.replace(/\\.\\$\\./i, '.').replace(/.\\$$/, ''));\n      if (op[key] &&\n          $path &&\n          $path.$isMongooseDocumentArray &&\n          $path.schema.options.timestamps) {\n        const timestamps = $path.schema.options.timestamps;\n        const createdAt = handleTimestampOption(timestamps, 'createdAt');\n        const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n        if (op[key].$each) {\n          op[key].$each.forEach(function(subdoc) {\n            if (updatedAt != null) {\n              subdoc[updatedAt] = now;\n            }\n            if (createdAt != null) {\n              subdoc[createdAt] = now;\n            }\n\n            applyTimestampsToChildren(now, subdoc, $path.schema);\n          });\n        } else {\n          if (updatedAt != null) {\n            op[key][updatedAt] = now;\n          }\n          if (createdAt != null) {\n            op[key][createdAt] = now;\n          }\n\n          applyTimestampsToChildren(now, op[key], $path.schema);\n        }\n      }\n    }\n  }\n}\n\nfunction applyTimestampsToDocumentArray(arr, schematype, now) {\n  const timestamps = schematype.schema.options.timestamps;\n\n  const len = arr.length;\n\n  if (!timestamps) {\n    for (let i = 0; i < len; ++i) {\n      applyTimestampsToChildren(now, arr[i], schematype.schema);\n    }\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  for (let i = 0; i < len; ++i) {\n    if (updatedAt != null) {\n      arr[i][updatedAt] = now;\n    }\n    if (createdAt != null) {\n      arr[i][createdAt] = now;\n    }\n\n    applyTimestampsToChildren(now, arr[i], schematype.schema);\n  }\n}\n\nfunction applyTimestampsToSingleNested(subdoc, schematype, now) {\n  const timestamps = schematype.schema.options.timestamps;\n  if (!timestamps) {\n    applyTimestampsToChildren(now, subdoc, schematype.schema);\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  if (updatedAt != null) {\n    subdoc[updatedAt] = now;\n  }\n  if (createdAt != null) {\n    subdoc[createdAt] = now;\n  }\n\n  applyTimestampsToChildren(now, subdoc, schematype.schema);\n}\n\nfunction applyTimestampsToUpdateKey(schema, key, update, now) {\n  // Replace positional operator `$` and array filters `$[]` and `$[.*]`\n  const keyToSearch = cleanPositionalOperators(key);\n  const path = schema.path(keyToSearch);\n  if (!path) {\n    return;\n  }\n\n  const parentSchemaTypes = [];\n  const pieces = keyToSearch.split('.');\n  for (let i = pieces.length - 1; i > 0; --i) {\n    const s = schema.path(pieces.slice(0, i).join('.'));\n    if (s != null &&\n      (s.$isMongooseDocumentArray || s.$isSingleNested)) {\n      parentSchemaTypes.push({ parentPath: key.split('.').slice(0, i).join('.'), parentSchemaType: s });\n    }\n  }\n\n  if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {\n    applyTimestampsToDocumentArray(update[key], path, now);\n  } else if (update[key] && path.$isSingleNested) {\n    applyTimestampsToSingleNested(update[key], path, now);\n  } else if (parentSchemaTypes.length > 0) {\n    for (const item of parentSchemaTypes) {\n      const parentPath = item.parentPath;\n      const parentSchemaType = item.parentSchemaType;\n      const timestamps = parentSchemaType.schema.options.timestamps;\n      const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n      if (!timestamps || updatedAt == null) {\n        continue;\n      }\n\n      if (parentSchemaType.$isSingleNested) {\n        // Single nested is easy\n        update[parentPath + '.' + updatedAt] = now;\n      } else if (parentSchemaType.$isMongooseDocumentArray) {\n        let childPath = key.substring(parentPath.length + 1);\n\n        if (/^\\d+$/.test(childPath)) {\n          update[parentPath + '.' + childPath][updatedAt] = now;\n          continue;\n        }\n\n        const firstDot = childPath.indexOf('.');\n        childPath = firstDot !== -1 ? childPath.substring(0, firstDot) : childPath;\n\n        update[parentPath + '.' + childPath + '.' + updatedAt] = now;\n      }\n    }\n  } else if (path.schema != null && path.schema != schema && update[key]) {\n    const timestamps = path.schema.options.timestamps;\n    const createdAt = handleTimestampOption(timestamps, 'createdAt');\n    const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n    if (!timestamps) {\n      return;\n    }\n\n    if (updatedAt != null) {\n      update[key][updatedAt] = now;\n    }\n    if (createdAt != null) {\n      update[key][createdAt] = now;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQ0FBaUMsbUJBQU8sQ0FBQyxnSUFBb0M7QUFDN0UsOEJBQThCLG1CQUFPLENBQUMsMEhBQWlDOztBQUV2RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVFQUF1RTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHVwZGF0ZVxcYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsZWFuUG9zaXRpb25hbE9wZXJhdG9ycyA9IHJlcXVpcmUoJy4uL3NjaGVtYS9jbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMnKTtcbmNvbnN0IGhhbmRsZVRpbWVzdGFtcE9wdGlvbiA9IHJlcXVpcmUoJy4uL3NjaGVtYS9oYW5kbGVUaW1lc3RhbXBPcHRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCB1cGRhdGUsIHNjaGVtYSkge1xuICBpZiAodXBkYXRlID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlKTtcbiAgY29uc3QgaGFzRG9sbGFyS2V5ID0ga2V5cy5zb21lKGtleSA9PiBrZXlbMF0gPT09ICckJyk7XG5cbiAgaWYgKGhhc0RvbGxhcktleSkge1xuICAgIGlmICh1cGRhdGUuJHB1c2gpIHtcbiAgICAgIF9hcHBseVRpbWVzdGFtcFRvVXBkYXRlT3BlcmF0b3IodXBkYXRlLiRwdXNoKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZS4kYWRkVG9TZXQpIHtcbiAgICAgIF9hcHBseVRpbWVzdGFtcFRvVXBkYXRlT3BlcmF0b3IodXBkYXRlLiRhZGRUb1NldCk7XG4gICAgfVxuICAgIGlmICh1cGRhdGUuJHNldCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlLiRzZXQpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBhcHBseVRpbWVzdGFtcHNUb1VwZGF0ZUtleShzY2hlbWEsIGtleSwgdXBkYXRlLiRzZXQsIG5vdyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGUuJHNldE9uSW5zZXJ0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUuJHNldE9uSW5zZXJ0KTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGVLZXkoc2NoZW1hLCBrZXksIHVwZGF0ZS4kc2V0T25JbnNlcnQsIG5vdyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdXBkYXRlS2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZSkuZmlsdGVyKGtleSA9PiBrZXlbMF0gIT09ICckJyk7XG4gIGZvciAoY29uc3Qga2V5IG9mIHVwZGF0ZUtleXMpIHtcbiAgICBhcHBseVRpbWVzdGFtcHNUb1VwZGF0ZUtleShzY2hlbWEsIGtleSwgdXBkYXRlLCBub3cpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FwcGx5VGltZXN0YW1wVG9VcGRhdGVPcGVyYXRvcihvcCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9wKSkge1xuICAgICAgY29uc3QgJHBhdGggPSBzY2hlbWEucGF0aChrZXkucmVwbGFjZSgvXFwuXFwkXFwuL2ksICcuJykucmVwbGFjZSgvLlxcJCQvLCAnJykpO1xuICAgICAgaWYgKG9wW2tleV0gJiZcbiAgICAgICAgICAkcGF0aCAmJlxuICAgICAgICAgICRwYXRoLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJlxuICAgICAgICAgICRwYXRoLnNjaGVtYS5vcHRpb25zLnRpbWVzdGFtcHMpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wcyA9ICRwYXRoLnNjaGVtYS5vcHRpb25zLnRpbWVzdGFtcHM7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAnY3JlYXRlZEF0Jyk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAndXBkYXRlZEF0Jyk7XG4gICAgICAgIGlmIChvcFtrZXldLiRlYWNoKSB7XG4gICAgICAgICAgb3Bba2V5XS4kZWFjaC5mb3JFYWNoKGZ1bmN0aW9uKHN1YmRvYykge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZWRBdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHN1YmRvY1t1cGRhdGVkQXRdID0gbm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNyZWF0ZWRBdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHN1YmRvY1tjcmVhdGVkQXRdID0gbm93O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgc3ViZG9jLCAkcGF0aC5zY2hlbWEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh1cGRhdGVkQXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3Bba2V5XVt1cGRhdGVkQXRdID0gbm93O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3JlYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9wW2tleV1bY3JlYXRlZEF0XSA9IG5vdztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgb3Bba2V5XSwgJHBhdGguc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRpbWVzdGFtcHNUb0RvY3VtZW50QXJyYXkoYXJyLCBzY2hlbWF0eXBlLCBub3cpIHtcbiAgY29uc3QgdGltZXN0YW1wcyA9IHNjaGVtYXR5cGUuc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcztcblxuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCBhcnJbaV0sIHNjaGVtYXR5cGUuc2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY3JlYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICdjcmVhdGVkQXQnKTtcbiAgY29uc3QgdXBkYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICd1cGRhdGVkQXQnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh1cGRhdGVkQXQgIT0gbnVsbCkge1xuICAgICAgYXJyW2ldW3VwZGF0ZWRBdF0gPSBub3c7XG4gICAgfVxuICAgIGlmIChjcmVhdGVkQXQgIT0gbnVsbCkge1xuICAgICAgYXJyW2ldW2NyZWF0ZWRBdF0gPSBub3c7XG4gICAgfVxuXG4gICAgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbihub3csIGFycltpXSwgc2NoZW1hdHlwZS5zY2hlbWEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VGltZXN0YW1wc1RvU2luZ2xlTmVzdGVkKHN1YmRvYywgc2NoZW1hdHlwZSwgbm93KSB7XG4gIGNvbnN0IHRpbWVzdGFtcHMgPSBzY2hlbWF0eXBlLnNjaGVtYS5vcHRpb25zLnRpbWVzdGFtcHM7XG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCBzdWJkb2MsIHNjaGVtYXR5cGUuc2NoZW1hKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBjcmVhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ2NyZWF0ZWRBdCcpO1xuICBjb25zdCB1cGRhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ3VwZGF0ZWRBdCcpO1xuICBpZiAodXBkYXRlZEF0ICE9IG51bGwpIHtcbiAgICBzdWJkb2NbdXBkYXRlZEF0XSA9IG5vdztcbiAgfVxuICBpZiAoY3JlYXRlZEF0ICE9IG51bGwpIHtcbiAgICBzdWJkb2NbY3JlYXRlZEF0XSA9IG5vdztcbiAgfVxuXG4gIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCBzdWJkb2MsIHNjaGVtYXR5cGUuc2NoZW1hKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGVLZXkoc2NoZW1hLCBrZXksIHVwZGF0ZSwgbm93KSB7XG4gIC8vIFJlcGxhY2UgcG9zaXRpb25hbCBvcGVyYXRvciBgJGAgYW5kIGFycmF5IGZpbHRlcnMgYCRbXWAgYW5kIGAkWy4qXWBcbiAgY29uc3Qga2V5VG9TZWFyY2ggPSBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMoa2V5KTtcbiAgY29uc3QgcGF0aCA9IHNjaGVtYS5wYXRoKGtleVRvU2VhcmNoKTtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGFyZW50U2NoZW1hVHlwZXMgPSBbXTtcbiAgY29uc3QgcGllY2VzID0ga2V5VG9TZWFyY2guc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IHBpZWNlcy5sZW5ndGggLSAxOyBpID4gMDsgLS1pKSB7XG4gICAgY29uc3QgcyA9IHNjaGVtYS5wYXRoKHBpZWNlcy5zbGljZSgwLCBpKS5qb2luKCcuJykpO1xuICAgIGlmIChzICE9IG51bGwgJiZcbiAgICAgIChzLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSB8fCBzLiRpc1NpbmdsZU5lc3RlZCkpIHtcbiAgICAgIHBhcmVudFNjaGVtYVR5cGVzLnB1c2goeyBwYXJlbnRQYXRoOiBrZXkuc3BsaXQoJy4nKS5zbGljZSgwLCBpKS5qb2luKCcuJyksIHBhcmVudFNjaGVtYVR5cGU6IHMgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlW2tleV0pICYmIHBhdGguJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgYXBwbHlUaW1lc3RhbXBzVG9Eb2N1bWVudEFycmF5KHVwZGF0ZVtrZXldLCBwYXRoLCBub3cpO1xuICB9IGVsc2UgaWYgKHVwZGF0ZVtrZXldICYmIHBhdGguJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgYXBwbHlUaW1lc3RhbXBzVG9TaW5nbGVOZXN0ZWQodXBkYXRlW2tleV0sIHBhdGgsIG5vdyk7XG4gIH0gZWxzZSBpZiAocGFyZW50U2NoZW1hVHlwZXMubGVuZ3RoID4gMCkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBwYXJlbnRTY2hlbWFUeXBlcykge1xuICAgICAgY29uc3QgcGFyZW50UGF0aCA9IGl0ZW0ucGFyZW50UGF0aDtcbiAgICAgIGNvbnN0IHBhcmVudFNjaGVtYVR5cGUgPSBpdGVtLnBhcmVudFNjaGVtYVR5cGU7XG4gICAgICBjb25zdCB0aW1lc3RhbXBzID0gcGFyZW50U2NoZW1hVHlwZS5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzO1xuICAgICAgY29uc3QgdXBkYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICd1cGRhdGVkQXQnKTtcblxuICAgICAgaWYgKCF0aW1lc3RhbXBzIHx8IHVwZGF0ZWRBdCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50U2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgLy8gU2luZ2xlIG5lc3RlZCBpcyBlYXN5XG4gICAgICAgIHVwZGF0ZVtwYXJlbnRQYXRoICsgJy4nICsgdXBkYXRlZEF0XSA9IG5vdztcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50U2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgbGV0IGNoaWxkUGF0aCA9IGtleS5zdWJzdHJpbmcocGFyZW50UGF0aC5sZW5ndGggKyAxKTtcblxuICAgICAgICBpZiAoL15cXGQrJC8udGVzdChjaGlsZFBhdGgpKSB7XG4gICAgICAgICAgdXBkYXRlW3BhcmVudFBhdGggKyAnLicgKyBjaGlsZFBhdGhdW3VwZGF0ZWRBdF0gPSBub3c7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaXJzdERvdCA9IGNoaWxkUGF0aC5pbmRleE9mKCcuJyk7XG4gICAgICAgIGNoaWxkUGF0aCA9IGZpcnN0RG90ICE9PSAtMSA/IGNoaWxkUGF0aC5zdWJzdHJpbmcoMCwgZmlyc3REb3QpIDogY2hpbGRQYXRoO1xuXG4gICAgICAgIHVwZGF0ZVtwYXJlbnRQYXRoICsgJy4nICsgY2hpbGRQYXRoICsgJy4nICsgdXBkYXRlZEF0XSA9IG5vdztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocGF0aC5zY2hlbWEgIT0gbnVsbCAmJiBwYXRoLnNjaGVtYSAhPSBzY2hlbWEgJiYgdXBkYXRlW2tleV0pIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gcGF0aC5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAnY3JlYXRlZEF0Jyk7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICd1cGRhdGVkQXQnKTtcblxuICAgIGlmICghdGltZXN0YW1wcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh1cGRhdGVkQXQgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlW2tleV1bdXBkYXRlZEF0XSA9IG5vdztcbiAgICB9XG4gICAgaWYgKGNyZWF0ZWRBdCAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVba2V5XVtjcmVhdGVkQXRdID0gbm93O1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = applyTimestampsToUpdate;\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options) {\n  const updates = currentUpdate;\n  let _updates = updates;\n  const overwrite = get(options, 'overwrite', false);\n  const timestamps = get(options, 'timestamps', true);\n\n  // Support skipping timestamps at the query level, see gh-6980\n  if (!timestamps || updates == null) {\n    return currentUpdate;\n  }\n\n  const skipCreatedAt = timestamps != null && timestamps.createdAt === false;\n  const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;\n\n  if (overwrite) {\n    if (currentUpdate && currentUpdate.$set) {\n      currentUpdate = currentUpdate.$set;\n      updates.$set = {};\n      _updates = updates.$set;\n    }\n    if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {\n      _updates[updatedAt] = now;\n    }\n    if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {\n      _updates[createdAt] = now;\n    }\n    return updates;\n  }\n  currentUpdate = currentUpdate || {};\n\n  if (Array.isArray(updates)) {\n    // Update with aggregation pipeline\n    if (updatedAt == null) {\n      return updates;\n    }\n    updates.push({ $set: { [updatedAt]: now } });\n    return updates;\n  }\n  updates.$set = updates.$set || {};\n  if (!skipUpdatedAt && updatedAt &&\n      (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {\n    let timestampSet = false;\n    if (updatedAt.indexOf('.') !== -1) {\n      const pieces = updatedAt.split('.');\n      for (let i = 1; i < pieces.length; ++i) {\n        const remnant = pieces.slice(-i).join('.');\n        const start = pieces.slice(0, -i).join('.');\n        if (currentUpdate[start] != null) {\n          currentUpdate[start][remnant] = now;\n          timestampSet = true;\n          break;\n        } else if (currentUpdate.$set && currentUpdate.$set[start]) {\n          currentUpdate.$set[start][remnant] = now;\n          timestampSet = true;\n          break;\n        }\n      }\n    }\n\n    if (!timestampSet) {\n      updates.$set[updatedAt] = now;\n    }\n\n    if (updates.hasOwnProperty(updatedAt)) {\n      delete updates[updatedAt];\n    }\n  }\n\n  if (!skipCreatedAt && createdAt) {\n    if (currentUpdate[createdAt]) {\n      delete currentUpdate[createdAt];\n    }\n    if (currentUpdate.$set && currentUpdate.$set[createdAt]) {\n      delete currentUpdate.$set[createdAt];\n    }\n    let timestampSet = false;\n    if (createdAt.indexOf('.') !== -1) {\n      const pieces = createdAt.split('.');\n      for (let i = 1; i < pieces.length; ++i) {\n        const remnant = pieces.slice(-i).join('.');\n        const start = pieces.slice(0, -i).join('.');\n        if (currentUpdate[start] != null) {\n          currentUpdate[start][remnant] = now;\n          timestampSet = true;\n          break;\n        } else if (currentUpdate.$set && currentUpdate.$set[start]) {\n          currentUpdate.$set[start][remnant] = now;\n          timestampSet = true;\n          break;\n        }\n      }\n    }\n\n    if (!timestampSet) {\n      updates.$setOnInsert = updates.$setOnInsert || {};\n      updates.$setOnInsert[createdAt] = now;\n    }\n  }\n\n  if (Object.keys(updates.$set).length === 0) {\n    delete updates.$set;\n  }\n  return updates;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyx3RUFBUTs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxoZWxwZXJzXFx1cGRhdGVcXGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseVRpbWVzdGFtcHNUb1VwZGF0ZTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVRpbWVzdGFtcHNUb1VwZGF0ZShub3csIGNyZWF0ZWRBdCwgdXBkYXRlZEF0LCBjdXJyZW50VXBkYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHVwZGF0ZXMgPSBjdXJyZW50VXBkYXRlO1xuICBsZXQgX3VwZGF0ZXMgPSB1cGRhdGVzO1xuICBjb25zdCBvdmVyd3JpdGUgPSBnZXQob3B0aW9ucywgJ292ZXJ3cml0ZScsIGZhbHNlKTtcbiAgY29uc3QgdGltZXN0YW1wcyA9IGdldChvcHRpb25zLCAndGltZXN0YW1wcycsIHRydWUpO1xuXG4gIC8vIFN1cHBvcnQgc2tpcHBpbmcgdGltZXN0YW1wcyBhdCB0aGUgcXVlcnkgbGV2ZWwsIHNlZSBnaC02OTgwXG4gIGlmICghdGltZXN0YW1wcyB8fCB1cGRhdGVzID09IG51bGwpIHtcbiAgICByZXR1cm4gY3VycmVudFVwZGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHNraXBDcmVhdGVkQXQgPSB0aW1lc3RhbXBzICE9IG51bGwgJiYgdGltZXN0YW1wcy5jcmVhdGVkQXQgPT09IGZhbHNlO1xuICBjb25zdCBza2lwVXBkYXRlZEF0ID0gdGltZXN0YW1wcyAhPSBudWxsICYmIHRpbWVzdGFtcHMudXBkYXRlZEF0ID09PSBmYWxzZTtcblxuICBpZiAob3ZlcndyaXRlKSB7XG4gICAgaWYgKGN1cnJlbnRVcGRhdGUgJiYgY3VycmVudFVwZGF0ZS4kc2V0KSB7XG4gICAgICBjdXJyZW50VXBkYXRlID0gY3VycmVudFVwZGF0ZS4kc2V0O1xuICAgICAgdXBkYXRlcy4kc2V0ID0ge307XG4gICAgICBfdXBkYXRlcyA9IHVwZGF0ZXMuJHNldDtcbiAgICB9XG4gICAgaWYgKCFza2lwVXBkYXRlZEF0ICYmIHVwZGF0ZWRBdCAmJiAhY3VycmVudFVwZGF0ZVt1cGRhdGVkQXRdKSB7XG4gICAgICBfdXBkYXRlc1t1cGRhdGVkQXRdID0gbm93O1xuICAgIH1cbiAgICBpZiAoIXNraXBDcmVhdGVkQXQgJiYgY3JlYXRlZEF0ICYmICFjdXJyZW50VXBkYXRlW2NyZWF0ZWRBdF0pIHtcbiAgICAgIF91cGRhdGVzW2NyZWF0ZWRBdF0gPSBub3c7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVzO1xuICB9XG4gIGN1cnJlbnRVcGRhdGUgPSBjdXJyZW50VXBkYXRlIHx8IHt9O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHVwZGF0ZXMpKSB7XG4gICAgLy8gVXBkYXRlIHdpdGggYWdncmVnYXRpb24gcGlwZWxpbmVcbiAgICBpZiAodXBkYXRlZEF0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB1cGRhdGVzO1xuICAgIH1cbiAgICB1cGRhdGVzLnB1c2goeyAkc2V0OiB7IFt1cGRhdGVkQXRdOiBub3cgfSB9KTtcbiAgICByZXR1cm4gdXBkYXRlcztcbiAgfVxuICB1cGRhdGVzLiRzZXQgPSB1cGRhdGVzLiRzZXQgfHwge307XG4gIGlmICghc2tpcFVwZGF0ZWRBdCAmJiB1cGRhdGVkQXQgJiZcbiAgICAgICghY3VycmVudFVwZGF0ZS4kY3VycmVudERhdGUgfHwgIWN1cnJlbnRVcGRhdGUuJGN1cnJlbnREYXRlW3VwZGF0ZWRBdF0pKSB7XG4gICAgbGV0IHRpbWVzdGFtcFNldCA9IGZhbHNlO1xuICAgIGlmICh1cGRhdGVkQXQuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgY29uc3QgcGllY2VzID0gdXBkYXRlZEF0LnNwbGl0KCcuJyk7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBpZWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCByZW1uYW50ID0gcGllY2VzLnNsaWNlKC1pKS5qb2luKCcuJyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcGllY2VzLnNsaWNlKDAsIC1pKS5qb2luKCcuJyk7XG4gICAgICAgIGlmIChjdXJyZW50VXBkYXRlW3N0YXJ0XSAhPSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFVwZGF0ZVtzdGFydF1bcmVtbmFudF0gPSBub3c7XG4gICAgICAgICAgdGltZXN0YW1wU2V0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VXBkYXRlLiRzZXQgJiYgY3VycmVudFVwZGF0ZS4kc2V0W3N0YXJ0XSkge1xuICAgICAgICAgIGN1cnJlbnRVcGRhdGUuJHNldFtzdGFydF1bcmVtbmFudF0gPSBub3c7XG4gICAgICAgICAgdGltZXN0YW1wU2V0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGltZXN0YW1wU2V0KSB7XG4gICAgICB1cGRhdGVzLiRzZXRbdXBkYXRlZEF0XSA9IG5vdztcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlcy5oYXNPd25Qcm9wZXJ0eSh1cGRhdGVkQXQpKSB7XG4gICAgICBkZWxldGUgdXBkYXRlc1t1cGRhdGVkQXRdO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2tpcENyZWF0ZWRBdCAmJiBjcmVhdGVkQXQpIHtcbiAgICBpZiAoY3VycmVudFVwZGF0ZVtjcmVhdGVkQXRdKSB7XG4gICAgICBkZWxldGUgY3VycmVudFVwZGF0ZVtjcmVhdGVkQXRdO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFVwZGF0ZS4kc2V0ICYmIGN1cnJlbnRVcGRhdGUuJHNldFtjcmVhdGVkQXRdKSB7XG4gICAgICBkZWxldGUgY3VycmVudFVwZGF0ZS4kc2V0W2NyZWF0ZWRBdF07XG4gICAgfVxuICAgIGxldCB0aW1lc3RhbXBTZXQgPSBmYWxzZTtcbiAgICBpZiAoY3JlYXRlZEF0LmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHBpZWNlcyA9IGNyZWF0ZWRBdC5zcGxpdCgnLicpO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwaWVjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcmVtbmFudCA9IHBpZWNlcy5zbGljZSgtaSkuam9pbignLicpO1xuICAgICAgICBjb25zdCBzdGFydCA9IHBpZWNlcy5zbGljZSgwLCAtaSkuam9pbignLicpO1xuICAgICAgICBpZiAoY3VycmVudFVwZGF0ZVtzdGFydF0gIT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRVcGRhdGVbc3RhcnRdW3JlbW5hbnRdID0gbm93O1xuICAgICAgICAgIHRpbWVzdGFtcFNldCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFVwZGF0ZS4kc2V0ICYmIGN1cnJlbnRVcGRhdGUuJHNldFtzdGFydF0pIHtcbiAgICAgICAgICBjdXJyZW50VXBkYXRlLiRzZXRbc3RhcnRdW3JlbW5hbnRdID0gbm93O1xuICAgICAgICAgIHRpbWVzdGFtcFNldCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRpbWVzdGFtcFNldCkge1xuICAgICAgdXBkYXRlcy4kc2V0T25JbnNlcnQgPSB1cGRhdGVzLiRzZXRPbkluc2VydCB8fCB7fTtcbiAgICAgIHVwZGF0ZXMuJHNldE9uSW5zZXJ0W2NyZWF0ZWRBdF0gPSBub3c7XG4gICAgfVxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZXMuJHNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIHVwZGF0ZXMuJHNldDtcbiAgfVxuICByZXR1cm4gdXBkYXRlcztcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/update/castArrayFilters.js":
/*!******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/castArrayFilters.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst castFilterPath = __webpack_require__(/*! ../query/castFilterPath */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/castFilterPath.js\");\nconst cleanPositionalOperators = __webpack_require__(/*! ../schema/cleanPositionalOperators */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst getPath = __webpack_require__(/*! ../schema/getPath */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/getPath.js\");\nconst updatedPathsByArrayFilter = __webpack_require__(/*! ./updatedPathsByArrayFilter */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js\");\n\nmodule.exports = function castArrayFilters(query) {\n  const arrayFilters = query.options.arrayFilters;\n  const update = query.getUpdate();\n  const schema = query.schema;\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  let strictQuery = schema.options.strict;\n  if (query._mongooseOptions.strict != null) {\n    strictQuery = query._mongooseOptions.strict;\n  }\n  if (query.model && query.model.base.options.strictQuery != null) {\n    strictQuery = query.model.base.options.strictQuery;\n  }\n  if (schema._userProvidedOptions.strictQuery != null) {\n    strictQuery = schema._userProvidedOptions.strictQuery;\n  }\n  if (query._mongooseOptions.strictQuery != null) {\n    strictQuery = query._mongooseOptions.strictQuery;\n  }\n\n  _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);\n};\n\nfunction _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {\n  if (!Array.isArray(arrayFilters)) {\n    return;\n  }\n\n  for (const filter of arrayFilters) {\n    if (filter == null) {\n      throw new Error(`Got null array filter in ${arrayFilters}`);\n    }\n    const keys = Object.keys(filter).filter(key => filter[key] != null);\n    if (keys.length === 0) {\n      continue;\n    }\n\n    const firstKey = keys[0];\n    if (firstKey === '$and' || firstKey === '$or') {\n      for (const key of keys) {\n        _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);\n      }\n      continue;\n    }\n    const dot = firstKey.indexOf('.');\n    const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);\n    if (updatedPathsByFilter[filterWildcardPath] == null) {\n      continue;\n    }\n    const baseFilterPath = cleanPositionalOperators(\n      updatedPathsByFilter[filterWildcardPath]\n    );\n\n    const baseSchematype = getPath(schema, baseFilterPath);\n    let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;\n    if (filterBaseSchema != null &&\n        filterBaseSchema.discriminators != null &&\n        filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]) {\n      filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;\n    }\n\n    for (const key of keys) {\n      if (updatedPathsByFilter[key] === null) {\n        continue;\n      }\n      if (Object.keys(updatedPathsByFilter).length === 0) {\n        continue;\n      }\n      const dot = key.indexOf('.');\n\n      let filterPathRelativeToBase = dot === -1 ? null : key.substring(dot);\n      let schematype;\n      if (filterPathRelativeToBase == null || filterBaseSchema == null) {\n        schematype = baseSchematype;\n      } else {\n        // If there are multiple array filters in the path being updated, make sure\n        // to replace them so we can get the schema path.\n        filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);\n        schematype = getPath(filterBaseSchema, filterPathRelativeToBase);\n      }\n\n      if (schematype == null) {\n        if (!strictQuery) {\n          return;\n        }\n        const filterPath = filterPathRelativeToBase == null ?\n          baseFilterPath + '.0' :\n          baseFilterPath + '.0' + filterPathRelativeToBase;\n        // For now, treat `strictQuery = true` and `strictQuery = 'throw'` as\n        // equivalent for casting array filters. `strictQuery = true` doesn't\n        // quite work in this context because we never want to silently strip out\n        // array filters, even if the path isn't in the schema.\n        throw new Error(`Could not find path \"${filterPath}\" in schema`);\n      }\n      if (typeof filter[key] === 'object') {\n        filter[key] = castFilterPath(query, schematype, filter[key]);\n      } else {\n        filter[key] = schematype.castForQuery(null, filter[key]);\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvY2FzdEFycmF5RmlsdGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix1QkFBdUIsbUJBQU8sQ0FBQywwR0FBeUI7QUFDeEQsaUNBQWlDLG1CQUFPLENBQUMsZ0lBQW9DO0FBQzdFLGdCQUFnQixtQkFBTyxDQUFDLDhGQUFtQjtBQUMzQyxrQ0FBa0MsbUJBQU8sQ0FBQywwSEFBNkI7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHVwZGF0ZVxcY2FzdEFycmF5RmlsdGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNhc3RGaWx0ZXJQYXRoID0gcmVxdWlyZSgnLi4vcXVlcnkvY2FzdEZpbHRlclBhdGgnKTtcbmNvbnN0IGNsZWFuUG9zaXRpb25hbE9wZXJhdG9ycyA9IHJlcXVpcmUoJy4uL3NjaGVtYS9jbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMnKTtcbmNvbnN0IGdldFBhdGggPSByZXF1aXJlKCcuLi9zY2hlbWEvZ2V0UGF0aCcpO1xuY29uc3QgdXBkYXRlZFBhdGhzQnlBcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vdXBkYXRlZFBhdGhzQnlBcnJheUZpbHRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3RBcnJheUZpbHRlcnMocXVlcnkpIHtcbiAgY29uc3QgYXJyYXlGaWx0ZXJzID0gcXVlcnkub3B0aW9ucy5hcnJheUZpbHRlcnM7XG4gIGNvbnN0IHVwZGF0ZSA9IHF1ZXJ5LmdldFVwZGF0ZSgpO1xuICBjb25zdCBzY2hlbWEgPSBxdWVyeS5zY2hlbWE7XG4gIGNvbnN0IHVwZGF0ZWRQYXRoc0J5RmlsdGVyID0gdXBkYXRlZFBhdGhzQnlBcnJheUZpbHRlcih1cGRhdGUpO1xuXG4gIGxldCBzdHJpY3RRdWVyeSA9IHNjaGVtYS5vcHRpb25zLnN0cmljdDtcbiAgaWYgKHF1ZXJ5Ll9tb25nb29zZU9wdGlvbnMuc3RyaWN0ICE9IG51bGwpIHtcbiAgICBzdHJpY3RRdWVyeSA9IHF1ZXJ5Ll9tb25nb29zZU9wdGlvbnMuc3RyaWN0O1xuICB9XG4gIGlmIChxdWVyeS5tb2RlbCAmJiBxdWVyeS5tb2RlbC5iYXNlLm9wdGlvbnMuc3RyaWN0UXVlcnkgIT0gbnVsbCkge1xuICAgIHN0cmljdFF1ZXJ5ID0gcXVlcnkubW9kZWwuYmFzZS5vcHRpb25zLnN0cmljdFF1ZXJ5O1xuICB9XG4gIGlmIChzY2hlbWEuX3VzZXJQcm92aWRlZE9wdGlvbnMuc3RyaWN0UXVlcnkgIT0gbnVsbCkge1xuICAgIHN0cmljdFF1ZXJ5ID0gc2NoZW1hLl91c2VyUHJvdmlkZWRPcHRpb25zLnN0cmljdFF1ZXJ5O1xuICB9XG4gIGlmIChxdWVyeS5fbW9uZ29vc2VPcHRpb25zLnN0cmljdFF1ZXJ5ICE9IG51bGwpIHtcbiAgICBzdHJpY3RRdWVyeSA9IHF1ZXJ5Ll9tb25nb29zZU9wdGlvbnMuc3RyaWN0UXVlcnk7XG4gIH1cblxuICBfY2FzdEFycmF5RmlsdGVycyhhcnJheUZpbHRlcnMsIHNjaGVtYSwgc3RyaWN0UXVlcnksIHVwZGF0ZWRQYXRoc0J5RmlsdGVyLCBxdWVyeSk7XG59O1xuXG5mdW5jdGlvbiBfY2FzdEFycmF5RmlsdGVycyhhcnJheUZpbHRlcnMsIHNjaGVtYSwgc3RyaWN0UXVlcnksIHVwZGF0ZWRQYXRoc0J5RmlsdGVyLCBxdWVyeSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlGaWx0ZXJzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoY29uc3QgZmlsdGVyIG9mIGFycmF5RmlsdGVycykge1xuICAgIGlmIChmaWx0ZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgbnVsbCBhcnJheSBmaWx0ZXIgaW4gJHthcnJheUZpbHRlcnN9YCk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmaWx0ZXIpLmZpbHRlcihrZXkgPT4gZmlsdGVyW2tleV0gIT0gbnVsbCk7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEtleSA9IGtleXNbMF07XG4gICAgaWYgKGZpcnN0S2V5ID09PSAnJGFuZCcgfHwgZmlyc3RLZXkgPT09ICckb3InKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIF9jYXN0QXJyYXlGaWx0ZXJzKGZpbHRlcltrZXldLCBzY2hlbWEsIHN0cmljdFF1ZXJ5LCB1cGRhdGVkUGF0aHNCeUZpbHRlciwgcXVlcnkpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGRvdCA9IGZpcnN0S2V5LmluZGV4T2YoJy4nKTtcbiAgICBjb25zdCBmaWx0ZXJXaWxkY2FyZFBhdGggPSBkb3QgPT09IC0xID8gZmlyc3RLZXkgOiBmaXJzdEtleS5zdWJzdHJpbmcoMCwgZG90KTtcbiAgICBpZiAodXBkYXRlZFBhdGhzQnlGaWx0ZXJbZmlsdGVyV2lsZGNhcmRQYXRoXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYmFzZUZpbHRlclBhdGggPSBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMoXG4gICAgICB1cGRhdGVkUGF0aHNCeUZpbHRlcltmaWx0ZXJXaWxkY2FyZFBhdGhdXG4gICAgKTtcblxuICAgIGNvbnN0IGJhc2VTY2hlbWF0eXBlID0gZ2V0UGF0aChzY2hlbWEsIGJhc2VGaWx0ZXJQYXRoKTtcbiAgICBsZXQgZmlsdGVyQmFzZVNjaGVtYSA9IGJhc2VTY2hlbWF0eXBlICE9IG51bGwgPyBiYXNlU2NoZW1hdHlwZS5zY2hlbWEgOiBudWxsO1xuICAgIGlmIChmaWx0ZXJCYXNlU2NoZW1hICE9IG51bGwgJiZcbiAgICAgICAgZmlsdGVyQmFzZVNjaGVtYS5kaXNjcmltaW5hdG9ycyAhPSBudWxsICYmXG4gICAgICAgIGZpbHRlcltmaWx0ZXJXaWxkY2FyZFBhdGggKyAnLicgKyBmaWx0ZXJCYXNlU2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0pIHtcbiAgICAgIGZpbHRlckJhc2VTY2hlbWEgPSBmaWx0ZXJCYXNlU2NoZW1hLmRpc2NyaW1pbmF0b3JzW2ZpbHRlcltmaWx0ZXJXaWxkY2FyZFBhdGggKyAnLicgKyBmaWx0ZXJCYXNlU2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV1dIHx8IGZpbHRlckJhc2VTY2hlbWE7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgaWYgKHVwZGF0ZWRQYXRoc0J5RmlsdGVyW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXModXBkYXRlZFBhdGhzQnlGaWx0ZXIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRvdCA9IGtleS5pbmRleE9mKCcuJyk7XG5cbiAgICAgIGxldCBmaWx0ZXJQYXRoUmVsYXRpdmVUb0Jhc2UgPSBkb3QgPT09IC0xID8gbnVsbCA6IGtleS5zdWJzdHJpbmcoZG90KTtcbiAgICAgIGxldCBzY2hlbWF0eXBlO1xuICAgICAgaWYgKGZpbHRlclBhdGhSZWxhdGl2ZVRvQmFzZSA9PSBudWxsIHx8IGZpbHRlckJhc2VTY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICBzY2hlbWF0eXBlID0gYmFzZVNjaGVtYXR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgYXJyYXkgZmlsdGVycyBpbiB0aGUgcGF0aCBiZWluZyB1cGRhdGVkLCBtYWtlIHN1cmVcbiAgICAgICAgLy8gdG8gcmVwbGFjZSB0aGVtIHNvIHdlIGNhbiBnZXQgdGhlIHNjaGVtYSBwYXRoLlxuICAgICAgICBmaWx0ZXJQYXRoUmVsYXRpdmVUb0Jhc2UgPSBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMoZmlsdGVyUGF0aFJlbGF0aXZlVG9CYXNlKTtcbiAgICAgICAgc2NoZW1hdHlwZSA9IGdldFBhdGgoZmlsdGVyQmFzZVNjaGVtYSwgZmlsdGVyUGF0aFJlbGF0aXZlVG9CYXNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjaGVtYXR5cGUgPT0gbnVsbCkge1xuICAgICAgICBpZiAoIXN0cmljdFF1ZXJ5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlclBhdGggPSBmaWx0ZXJQYXRoUmVsYXRpdmVUb0Jhc2UgPT0gbnVsbCA/XG4gICAgICAgICAgYmFzZUZpbHRlclBhdGggKyAnLjAnIDpcbiAgICAgICAgICBiYXNlRmlsdGVyUGF0aCArICcuMCcgKyBmaWx0ZXJQYXRoUmVsYXRpdmVUb0Jhc2U7XG4gICAgICAgIC8vIEZvciBub3csIHRyZWF0IGBzdHJpY3RRdWVyeSA9IHRydWVgIGFuZCBgc3RyaWN0UXVlcnkgPSAndGhyb3cnYCBhc1xuICAgICAgICAvLyBlcXVpdmFsZW50IGZvciBjYXN0aW5nIGFycmF5IGZpbHRlcnMuIGBzdHJpY3RRdWVyeSA9IHRydWVgIGRvZXNuJ3RcbiAgICAgICAgLy8gcXVpdGUgd29yayBpbiB0aGlzIGNvbnRleHQgYmVjYXVzZSB3ZSBuZXZlciB3YW50IHRvIHNpbGVudGx5IHN0cmlwIG91dFxuICAgICAgICAvLyBhcnJheSBmaWx0ZXJzLCBldmVuIGlmIHRoZSBwYXRoIGlzbid0IGluIHRoZSBzY2hlbWEuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgcGF0aCBcIiR7ZmlsdGVyUGF0aH1cIiBpbiBzY2hlbWFgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZmlsdGVyW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZpbHRlcltrZXldID0gY2FzdEZpbHRlclBhdGgocXVlcnksIHNjaGVtYXR5cGUsIGZpbHRlcltrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbHRlcltrZXldID0gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkobnVsbCwgZmlsdGVyW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/update/castArrayFilters.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js":
/*!******************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst modifiedPaths = __webpack_require__(/*! ./modifiedPaths */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/modifiedPaths.js\");\n\n/**\n * Decorate the update with a version key, if necessary\n * @api private\n */\n\nmodule.exports = function decorateUpdateWithVersionKey(update, options, versionKey) {\n  if (!versionKey || !(options && options.upsert || false)) {\n    return;\n  }\n\n  const updatedPaths = modifiedPaths(update);\n  if (!updatedPaths[versionKey]) {\n    if (options.overwrite) {\n      update[versionKey] = 0;\n    } else {\n      if (!update.$setOnInsert) {\n        update.$setOnInsert = {};\n      }\n      update.$setOnInsert[versionKey] = 0;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxrR0FBaUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcdXBkYXRlXFxkZWNvcmF0ZVVwZGF0ZVdpdGhWZXJzaW9uS2V5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbW9kaWZpZWRQYXRocyA9IHJlcXVpcmUoJy4vbW9kaWZpZWRQYXRocycpO1xuXG4vKipcbiAqIERlY29yYXRlIHRoZSB1cGRhdGUgd2l0aCBhIHZlcnNpb24ga2V5LCBpZiBuZWNlc3NhcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleSh1cGRhdGUsIG9wdGlvbnMsIHZlcnNpb25LZXkpIHtcbiAgaWYgKCF2ZXJzaW9uS2V5IHx8ICEob3B0aW9ucyAmJiBvcHRpb25zLnVwc2VydCB8fCBmYWxzZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB1cGRhdGVkUGF0aHMgPSBtb2RpZmllZFBhdGhzKHVwZGF0ZSk7XG4gIGlmICghdXBkYXRlZFBhdGhzW3ZlcnNpb25LZXldKSB7XG4gICAgaWYgKG9wdGlvbnMub3ZlcndyaXRlKSB7XG4gICAgICB1cGRhdGVbdmVyc2lvbktleV0gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXVwZGF0ZS4kc2V0T25JbnNlcnQpIHtcbiAgICAgICAgdXBkYXRlLiRzZXRPbkluc2VydCA9IHt9O1xuICAgICAgfVxuICAgICAgdXBkYXRlLiRzZXRPbkluc2VydFt2ZXJzaW9uS2V5XSA9IDA7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/update/modifiedPaths.js":
/*!***************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/modifiedPaths.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst _modifiedPaths = (__webpack_require__(/*! ../common */ \"(api)/../server/node_modules/mongoose/lib/helpers/common.js\").modifiedPaths);\n\n/**\n * Given an update document with potential update operators (`$set`, etc.)\n * returns an object whose keys are the directly modified paths.\n *\n * If there are any top-level keys that don't start with `$`, we assume those\n * will get wrapped in a `$set`. The Mongoose Query is responsible for wrapping\n * top-level keys in `$set`.\n *\n * @param {Object} update\n * @return {Object} modified\n */\n\nmodule.exports = function modifiedPaths(update) {\n  const keys = Object.keys(update);\n  const res = {};\n\n  const withoutDollarKeys = {};\n  for (const key of keys) {\n    if (key.startsWith('$')) {\n      _modifiedPaths(update[key], '', res);\n      continue;\n    }\n    withoutDollarKeys[key] = update[key];\n  }\n\n  _modifiedPaths(withoutDollarKeys, '', res);\n\n  return res;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvbW9kaWZpZWRQYXRocy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix1QkFBdUIsbUhBQWtDOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcdXBkYXRlXFxtb2RpZmllZFBhdGhzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgX21vZGlmaWVkUGF0aHMgPSByZXF1aXJlKCcuLi9jb21tb24nKS5tb2RpZmllZFBhdGhzO1xuXG4vKipcbiAqIEdpdmVuIGFuIHVwZGF0ZSBkb2N1bWVudCB3aXRoIHBvdGVudGlhbCB1cGRhdGUgb3BlcmF0b3JzIChgJHNldGAsIGV0Yy4pXG4gKiByZXR1cm5zIGFuIG9iamVjdCB3aG9zZSBrZXlzIGFyZSB0aGUgZGlyZWN0bHkgbW9kaWZpZWQgcGF0aHMuXG4gKlxuICogSWYgdGhlcmUgYXJlIGFueSB0b3AtbGV2ZWwga2V5cyB0aGF0IGRvbid0IHN0YXJ0IHdpdGggYCRgLCB3ZSBhc3N1bWUgdGhvc2VcbiAqIHdpbGwgZ2V0IHdyYXBwZWQgaW4gYSBgJHNldGAuIFRoZSBNb25nb29zZSBRdWVyeSBpcyByZXNwb25zaWJsZSBmb3Igd3JhcHBpbmdcbiAqIHRvcC1sZXZlbCBrZXlzIGluIGAkc2V0YC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlXG4gKiBAcmV0dXJuIHtPYmplY3R9IG1vZGlmaWVkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtb2RpZmllZFBhdGhzKHVwZGF0ZSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlKTtcbiAgY29uc3QgcmVzID0ge307XG5cbiAgY29uc3Qgd2l0aG91dERvbGxhcktleXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICBfbW9kaWZpZWRQYXRocyh1cGRhdGVba2V5XSwgJycsIHJlcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgd2l0aG91dERvbGxhcktleXNba2V5XSA9IHVwZGF0ZVtrZXldO1xuICB9XG5cbiAgX21vZGlmaWVkUGF0aHMod2l0aG91dERvbGxhcktleXMsICcnLCByZXMpO1xuXG4gIHJldHVybiByZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/update/modifiedPaths.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js":
/*!*************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\n\n/**\n * Given an update, move all $set on immutable properties to $setOnInsert.\n * This should only be called for upserts, because $setOnInsert bypasses the\n * strictness check for immutable properties.\n */\n\nmodule.exports = function moveImmutableProperties(schema, update, ctx) {\n  if (update == null) {\n    return;\n  }\n\n  const keys = Object.keys(update);\n  for (const key of keys) {\n    const isDollarKey = key.startsWith('$');\n\n    if (key === '$set') {\n      const updatedPaths = Object.keys(update[key]);\n      for (const path of updatedPaths) {\n        _walkUpdatePath(schema, update[key], path, update, ctx);\n      }\n    } else if (!isDollarKey) {\n      _walkUpdatePath(schema, update, key, update, ctx);\n    }\n\n  }\n};\n\nfunction _walkUpdatePath(schema, op, path, update, ctx) {\n  const schematype = schema.path(path);\n  if (schematype == null) {\n    return;\n  }\n\n  let immutable = get(schematype, 'options.immutable', null);\n  if (immutable == null) {\n    return;\n  }\n  if (typeof immutable === 'function') {\n    immutable = immutable.call(ctx, ctx);\n  }\n\n  if (!immutable) {\n    return;\n  }\n\n  update.$setOnInsert = update.$setOnInsert || {};\n  update.$setOnInsert[path] = op[path];\n  delete op[path];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvbW92ZUltbXV0YWJsZVByb3BlcnRpZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHdFQUFROztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHVwZGF0ZVxcbW92ZUltbXV0YWJsZVByb3BlcnRpZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcblxuLyoqXG4gKiBHaXZlbiBhbiB1cGRhdGUsIG1vdmUgYWxsICRzZXQgb24gaW1tdXRhYmxlIHByb3BlcnRpZXMgdG8gJHNldE9uSW5zZXJ0LlxuICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgZm9yIHVwc2VydHMsIGJlY2F1c2UgJHNldE9uSW5zZXJ0IGJ5cGFzc2VzIHRoZVxuICogc3RyaWN0bmVzcyBjaGVjayBmb3IgaW1tdXRhYmxlIHByb3BlcnRpZXMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtb3ZlSW1tdXRhYmxlUHJvcGVydGllcyhzY2hlbWEsIHVwZGF0ZSwgY3R4KSB7XG4gIGlmICh1cGRhdGUgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgaXNEb2xsYXJLZXkgPSBrZXkuc3RhcnRzV2l0aCgnJCcpO1xuXG4gICAgaWYgKGtleSA9PT0gJyRzZXQnKSB7XG4gICAgICBjb25zdCB1cGRhdGVkUGF0aHMgPSBPYmplY3Qua2V5cyh1cGRhdGVba2V5XSk7XG4gICAgICBmb3IgKGNvbnN0IHBhdGggb2YgdXBkYXRlZFBhdGhzKSB7XG4gICAgICAgIF93YWxrVXBkYXRlUGF0aChzY2hlbWEsIHVwZGF0ZVtrZXldLCBwYXRoLCB1cGRhdGUsIGN0eCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNEb2xsYXJLZXkpIHtcbiAgICAgIF93YWxrVXBkYXRlUGF0aChzY2hlbWEsIHVwZGF0ZSwga2V5LCB1cGRhdGUsIGN0eCk7XG4gICAgfVxuXG4gIH1cbn07XG5cbmZ1bmN0aW9uIF93YWxrVXBkYXRlUGF0aChzY2hlbWEsIG9wLCBwYXRoLCB1cGRhdGUsIGN0eCkge1xuICBjb25zdCBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gIGlmIChzY2hlbWF0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgaW1tdXRhYmxlID0gZ2V0KHNjaGVtYXR5cGUsICdvcHRpb25zLmltbXV0YWJsZScsIG51bGwpO1xuICBpZiAoaW1tdXRhYmxlID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBpbW11dGFibGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbW11dGFibGUgPSBpbW11dGFibGUuY2FsbChjdHgsIGN0eCk7XG4gIH1cblxuICBpZiAoIWltbXV0YWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHVwZGF0ZS4kc2V0T25JbnNlcnQgPSB1cGRhdGUuJHNldE9uSW5zZXJ0IHx8IHt9O1xuICB1cGRhdGUuJHNldE9uSW5zZXJ0W3BhdGhdID0gb3BbcGF0aF07XG4gIGRlbGV0ZSBvcFtwYXRoXTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js":
/*!**************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * MongoDB throws an error if there's unused array filters. That is, if `options.arrayFilters` defines\n * a filter, but none of the `update` keys use it. This should be enough to filter out all unused array\n * filters.\n */\n\nmodule.exports = function removeUnusedArrayFilters(update, arrayFilters) {\n  const updateKeys = Object.keys(update).\n    map(key => Object.keys(update[key])).\n    reduce((cur, arr) => cur.concat(arr), []);\n  return arrayFilters.filter(obj => {\n    return _checkSingleFilterKey(obj, updateKeys);\n  });\n};\n\nfunction _checkSingleFilterKey(arrayFilter, updateKeys) {\n  const firstKey = Object.keys(arrayFilter)[0];\n\n  if (firstKey === '$and' || firstKey === '$or') {\n    if (!Array.isArray(arrayFilter[firstKey])) {\n      return false;\n    }\n    return arrayFilter[firstKey].find(filter => _checkSingleFilterKey(filter, updateKeys)) != null;\n  }\n\n  const firstDot = firstKey.indexOf('.');\n  const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);\n\n  return updateKeys.find(key => key.includes('$[' + arrayFilterKey + ']')) != null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvcmVtb3ZlVW51c2VkQXJyYXlGaWx0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGhlbHBlcnNcXHVwZGF0ZVxccmVtb3ZlVW51c2VkQXJyYXlGaWx0ZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb25nb0RCIHRocm93cyBhbiBlcnJvciBpZiB0aGVyZSdzIHVudXNlZCBhcnJheSBmaWx0ZXJzLiBUaGF0IGlzLCBpZiBgb3B0aW9ucy5hcnJheUZpbHRlcnNgIGRlZmluZXNcbiAqIGEgZmlsdGVyLCBidXQgbm9uZSBvZiB0aGUgYHVwZGF0ZWAga2V5cyB1c2UgaXQuIFRoaXMgc2hvdWxkIGJlIGVub3VnaCB0byBmaWx0ZXIgb3V0IGFsbCB1bnVzZWQgYXJyYXlcbiAqIGZpbHRlcnMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZW1vdmVVbnVzZWRBcnJheUZpbHRlcnModXBkYXRlLCBhcnJheUZpbHRlcnMpIHtcbiAgY29uc3QgdXBkYXRlS2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZSkuXG4gICAgbWFwKGtleSA9PiBPYmplY3Qua2V5cyh1cGRhdGVba2V5XSkpLlxuICAgIHJlZHVjZSgoY3VyLCBhcnIpID0+IGN1ci5jb25jYXQoYXJyKSwgW10pO1xuICByZXR1cm4gYXJyYXlGaWx0ZXJzLmZpbHRlcihvYmogPT4ge1xuICAgIHJldHVybiBfY2hlY2tTaW5nbGVGaWx0ZXJLZXkob2JqLCB1cGRhdGVLZXlzKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBfY2hlY2tTaW5nbGVGaWx0ZXJLZXkoYXJyYXlGaWx0ZXIsIHVwZGF0ZUtleXMpIHtcbiAgY29uc3QgZmlyc3RLZXkgPSBPYmplY3Qua2V5cyhhcnJheUZpbHRlcilbMF07XG5cbiAgaWYgKGZpcnN0S2V5ID09PSAnJGFuZCcgfHwgZmlyc3RLZXkgPT09ICckb3InKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5RmlsdGVyW2ZpcnN0S2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5RmlsdGVyW2ZpcnN0S2V5XS5maW5kKGZpbHRlciA9PiBfY2hlY2tTaW5nbGVGaWx0ZXJLZXkoZmlsdGVyLCB1cGRhdGVLZXlzKSkgIT0gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0RG90ID0gZmlyc3RLZXkuaW5kZXhPZignLicpO1xuICBjb25zdCBhcnJheUZpbHRlcktleSA9IGZpcnN0RG90ID09PSAtMSA/IGZpcnN0S2V5IDogZmlyc3RLZXkuc2xpY2UoMCwgZmlyc3REb3QpO1xuXG4gIHJldHVybiB1cGRhdGVLZXlzLmZpbmQoa2V5ID0+IGtleS5pbmNsdWRlcygnJFsnICsgYXJyYXlGaWx0ZXJLZXkgKyAnXScpKSAhPSBudWxsO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js":
/*!***************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst modifiedPaths = __webpack_require__(/*! ./modifiedPaths */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/modifiedPaths.js\");\n\nmodule.exports = function updatedPathsByArrayFilter(update) {\n  if (update == null) {\n    return {};\n  }\n  const updatedPaths = modifiedPaths(update);\n\n  return Object.keys(updatedPaths).reduce((cur, path) => {\n    const matches = path.match(/\\$\\[[^\\]]+\\]/g);\n    if (matches == null) {\n      return cur;\n    }\n    for (const match of matches) {\n      const firstMatch = path.indexOf(match);\n      if (firstMatch !== path.lastIndexOf(match)) {\n        throw new Error(`Path '${path}' contains the same array filter multiple times`);\n      }\n      cur[match.substring(2, match.length - 1)] = path.\n        substring(0, firstMatch - 1).\n        replace(/\\$\\[[^\\]]+\\]/g, '0');\n    }\n    return cur;\n  }, {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvdXBkYXRlZFBhdGhzQnlBcnJheUZpbHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxrR0FBaUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcaGVscGVyc1xcdXBkYXRlXFx1cGRhdGVkUGF0aHNCeUFycmF5RmlsdGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbW9kaWZpZWRQYXRocyA9IHJlcXVpcmUoJy4vbW9kaWZpZWRQYXRocycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXIodXBkYXRlKSB7XG4gIGlmICh1cGRhdGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCB1cGRhdGVkUGF0aHMgPSBtb2RpZmllZFBhdGhzKHVwZGF0ZSk7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHVwZGF0ZWRQYXRocykucmVkdWNlKChjdXIsIHBhdGgpID0+IHtcbiAgICBjb25zdCBtYXRjaGVzID0gcGF0aC5tYXRjaCgvXFwkXFxbW15cXF1dK1xcXS9nKTtcbiAgICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY3VyO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgIGNvbnN0IGZpcnN0TWF0Y2ggPSBwYXRoLmluZGV4T2YobWF0Y2gpO1xuICAgICAgaWYgKGZpcnN0TWF0Y2ggIT09IHBhdGgubGFzdEluZGV4T2YobWF0Y2gpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGF0aCAnJHtwYXRofScgY29udGFpbnMgdGhlIHNhbWUgYXJyYXkgZmlsdGVyIG11bHRpcGxlIHRpbWVzYCk7XG4gICAgICB9XG4gICAgICBjdXJbbWF0Y2guc3Vic3RyaW5nKDIsIG1hdGNoLmxlbmd0aCAtIDEpXSA9IHBhdGguXG4gICAgICAgIHN1YnN0cmluZygwLCBmaXJzdE1hdGNoIC0gMSkuXG4gICAgICAgIHJlcGxhY2UoL1xcJFxcW1teXFxdXStcXF0vZywgJzAnKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cjtcbiAgfSwge30pO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/index.js":
/*!****************************************************!*\
  !*** ../server/node_modules/mongoose/lib/index.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\n(__webpack_require__(/*! ./driver */ \"(api)/../server/node_modules/mongoose/lib/driver.js\").set)(__webpack_require__(/*! ./drivers/node-mongodb-native */ \"(api)/../server/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js\"));\n\nconst Document = __webpack_require__(/*! ./document */ \"(api)/../server/node_modules/mongoose/lib/document.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Kareem = __webpack_require__(/*! kareem */ \"(api)/../server/node_modules/kareem/index.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"(api)/../server/node_modules/mongoose/lib/schema.js\");\nconst SchemaType = __webpack_require__(/*! ./schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst SchemaTypes = __webpack_require__(/*! ./schema/index */ \"(api)/../server/node_modules/mongoose/lib/schema/index.js\");\nconst VirtualType = __webpack_require__(/*! ./virtualtype */ \"(api)/../server/node_modules/mongoose/lib/virtualtype.js\");\nconst STATES = __webpack_require__(/*! ./connectionstate */ \"(api)/../server/node_modules/mongoose/lib/connectionstate.js\");\nconst VALID_OPTIONS = __webpack_require__(/*! ./validoptions */ \"(api)/../server/node_modules/mongoose/lib/validoptions.js\");\nconst Types = __webpack_require__(/*! ./types */ \"(api)/../server/node_modules/mongoose/lib/types/index.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(api)/../server/node_modules/mongoose/lib/query.js\");\nconst Model = __webpack_require__(/*! ./model */ \"(api)/../server/node_modules/mongoose/lib/model.js\");\nconst applyPlugins = __webpack_require__(/*! ./helpers/schema/applyPlugins */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/applyPlugins.js\");\nconst builtinPlugins = __webpack_require__(/*! ./plugins */ \"(api)/../server/node_modules/mongoose/lib/plugins/index.js\");\nconst driver = __webpack_require__(/*! ./driver */ \"(api)/../server/node_modules/mongoose/lib/driver.js\");\nconst legacyPluralize = __webpack_require__(/*! ./helpers/pluralize */ \"(api)/../server/node_modules/mongoose/lib/helpers/pluralize.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst pkg = __webpack_require__(/*! ../package.json */ \"(api)/../server/node_modules/mongoose/package.json\");\nconst cast = __webpack_require__(/*! ./cast */ \"(api)/../server/node_modules/mongoose/lib/cast.js\");\n\nconst Aggregate = __webpack_require__(/*! ./aggregate */ \"(api)/../server/node_modules/mongoose/lib/aggregate.js\");\nconst trusted = (__webpack_require__(/*! ./helpers/query/trusted */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/trusted.js\").trusted);\nconst sanitizeFilter = __webpack_require__(/*! ./helpers/query/sanitizeFilter */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js\");\nconst isBsonType = __webpack_require__(/*! ./helpers/isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst SetOptionError = __webpack_require__(/*! ./error/setOptionError */ \"(api)/../server/node_modules/mongoose/lib/error/setOptionError.js\");\nconst applyEmbeddedDiscriminators = __webpack_require__(/*! ./helpers/discriminator/applyEmbeddedDiscriminators */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js\");\n\nconst defaultMongooseSymbol = Symbol.for('mongoose:default');\n\n__webpack_require__(/*! ./helpers/printJestWarning */ \"(api)/../server/node_modules/mongoose/lib/helpers/printJestWarning.js\");\n\nconst objectIdHexRegexp = /^[0-9A-Fa-f]{24}$/;\n\nconst { AsyncLocalStorage } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\n\n/**\n * Mongoose constructor.\n *\n * The exports object of the `mongoose` module is an instance of this class.\n * Most apps will only use this one instance.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose instanceof mongoose.Mongoose; // true\n *\n *     // Create a new Mongoose instance with its own `connect()`, `set()`, `model()`, etc.\n *     const m = new mongoose.Mongoose();\n *\n * @api public\n * @param {Object} options see [`Mongoose#set()` docs](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.set())\n */\nfunction Mongoose(options) {\n  this.connections = [];\n  this.nextConnectionId = 0;\n  this.models = {};\n  this.events = new EventEmitter();\n  this.__driver = driver.get();\n  // default global options\n  this.options = Object.assign({\n    pluralization: true,\n    autoIndex: true,\n    autoCreate: true\n  }, options);\n  const createInitialConnection = utils.getOption('createInitialConnection', this.options);\n  if (createInitialConnection == null || createInitialConnection) {\n    const conn = this.createConnection(); // default connection\n    conn.models = this.models;\n  }\n\n  if (this.options.pluralization) {\n    this._pluralize = legacyPluralize;\n  }\n\n  // If a user creates their own Mongoose instance, give them a separate copy\n  // of the `Schema` constructor so they get separate custom types. (gh-6933)\n  if (!options || !options[defaultMongooseSymbol]) {\n    const _this = this;\n    this.Schema = function() {\n      this.base = _this;\n      return Schema.apply(this, arguments);\n    };\n    this.Schema.prototype = Object.create(Schema.prototype);\n\n    Object.assign(this.Schema, Schema);\n    this.Schema.base = this;\n    this.Schema.Types = Object.assign({}, Schema.Types);\n  } else {\n    // Hack to work around babel's strange behavior with\n    // `import mongoose, { Schema } from 'mongoose'`. Because `Schema` is not\n    // an own property of a Mongoose global, Schema will be undefined. See gh-5648\n    for (const key of ['Schema', 'model']) {\n      this[key] = Mongoose.prototype[key];\n    }\n  }\n  this.Schema.prototype.base = this;\n\n  if (options?.transactionAsyncLocalStorage) {\n    this.transactionAsyncLocalStorage = new AsyncLocalStorage();\n  }\n\n  Object.defineProperty(this, 'plugins', {\n    configurable: false,\n    enumerable: true,\n    writable: false,\n    value: Object.values(builtinPlugins).map(plugin => ([plugin, { deduplicate: true }]))\n  });\n}\n\nMongoose.prototype.cast = cast;\n/**\n * Expose connection states for user-land\n *\n * @memberOf Mongoose\n * @property STATES\n * @api public\n */\nMongoose.prototype.STATES = STATES;\n\n/**\n * Expose connection states for user-land\n *\n * @memberOf Mongoose\n * @property ConnectionStates\n * @api public\n */\nMongoose.prototype.ConnectionStates = STATES;\n\n/**\n * Object with `get()` and `set()` containing the underlying driver this Mongoose instance\n * uses to communicate with the database. A driver is a Mongoose-specific interface that defines functions\n * like `find()`.\n *\n * @deprecated\n * @memberOf Mongoose\n * @property driver\n * @api public\n */\n\nMongoose.prototype.driver = driver;\n\n/**\n * Overwrites the current driver used by this Mongoose instance. A driver is a\n * Mongoose-specific interface that defines functions like `find()`.\n *\n * @memberOf Mongoose\n * @method setDriver\n * @api public\n */\n\nMongoose.prototype.setDriver = function setDriver(driver) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (_mongoose.__driver === driver) {\n    return _mongoose;\n  }\n\n  const openConnection = _mongoose.connections && _mongoose.connections.find(conn => conn.readyState !== STATES.disconnected);\n  if (openConnection) {\n    const msg = 'Cannot modify Mongoose driver if a connection is already open. ' +\n      'Call `mongoose.disconnect()` before modifying the driver';\n    throw new MongooseError(msg);\n  }\n  _mongoose.__driver = driver;\n\n  const Connection = driver.Connection;\n  _mongoose.connections = [new Connection(_mongoose)];\n  _mongoose.connections[0].models = _mongoose.models;\n\n  return _mongoose;\n};\n\n/**\n * Sets mongoose options\n *\n * `key` can be used a object to set multiple options at once.\n * If a error gets thrown for one option, other options will still be evaluated.\n *\n * #### Example:\n *\n *     mongoose.set('test', value) // sets the 'test' option to `value`\n *\n *     mongoose.set('debug', true) // enable logging collection methods + arguments to the console/file\n *\n *     mongoose.set('debug', function(collectionName, methodName, ...methodArgs) {}); // use custom function to log collection methods + arguments\n *\n *     mongoose.set({ debug: true, autoIndex: false }); // set multiple options at once\n *\n * Currently supported options are:\n * - `allowDiskUse`: Set to `true` to set `allowDiskUse` to true to all aggregation operations by default.\n * - `applyPluginsToChildSchemas`: `true` by default. Set to false to skip applying global plugins to child schemas\n * - `applyPluginsToDiscriminators`: `false` by default. Set to true to apply global plugins to discriminator schemas. This typically isn't necessary because plugins are applied to the base schema and discriminators copy all middleware, methods, statics, and properties from the base schema.\n * - `autoCreate`: Set to `true` to make Mongoose call [`Model.createCollection()`](https://mongoosejs.com/docs/api/model.html#Model.createCollection()) automatically when you create a model with `mongoose.model()` or `conn.model()`. This is useful for testing transactions, change streams, and other features that require the collection to exist.\n * - `autoIndex`: `true` by default. Set to false to disable automatic index creation for all models associated with this Mongoose instance.\n * - `bufferCommands`: enable/disable mongoose's buffering mechanism for all connections and models\n * - `bufferTimeoutMS`: If bufferCommands is on, this option sets the maximum amount of time Mongoose buffering will wait before throwing an error. If not specified, Mongoose will use 10000 (10 seconds).\n * - `cloneSchemas`: `false` by default. Set to `true` to `clone()` all schemas before compiling into a model.\n * - `debug`: If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arguments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n * - `id`: If `true`, adds a `id` virtual to all schemas unless overwritten on a per-schema basis.\n * - `timestamps.createdAt.immutable`: `true` by default. If `false`, it will change the `createdAt` field to be [`immutable: false`](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.immutable) which means you can update the `createdAt`\n * - `maxTimeMS`: If set, attaches [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/) to every query\n * - `objectIdGetter`: `true` by default. Mongoose adds a getter to MongoDB ObjectId's called `_id` that returns `this` for convenience with populate. Set this to false to remove the getter.\n * - `overwriteModels`: Set to `true` to default to overwriting models with the same name when calling `mongoose.model()`, as opposed to throwing an `OverwriteModelError`.\n * - `returnOriginal`: If `false`, changes the default `returnOriginal` option to `findOneAndUpdate()`, `findByIdAndUpdate`, and `findOneAndReplace()` to false. This is equivalent to setting the `new` option to `true` for `findOneAndX()` calls by default. Read our [`findOneAndUpdate()` tutorial](https://mongoosejs.com/docs/tutorials/findoneandupdate.html) for more information.\n * - `runValidators`: `false` by default. Set to true to enable [update validators](https://mongoosejs.com/docs/validation.html#update-validators) for all validators by default.\n * - `sanitizeFilter`: `false` by default. Set to true to enable the [sanitization of the query filters](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.sanitizeFilter()) against query selector injection attacks by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.\n * - `selectPopulatedPaths`: `true` by default. Set to false to opt out of Mongoose adding all fields that you `populate()` to your `select()`. The schema-level option `selectPopulatedPaths` overwrites this one.\n * - `strict`: `true` by default, may be `false`, `true`, or `'throw'`. Sets the default strict mode for schemas.\n * - `strictQuery`: `false` by default. May be `false`, `true`, or `'throw'`. Sets the default [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery) mode for schemas.\n * - `toJSON`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toJSON()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.toJSON()), for determining how Mongoose documents get serialized by `JSON.stringify()`\n * - `toObject`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toObject()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject())\n *\n * @param {String|Object} key The name of the option or a object of multiple key-value pairs\n * @param {String|Function|Boolean} value The value of the option, unused if \"key\" is a object\n * @returns {Mongoose} The used Mongoose instnace\n * @api public\n */\n\nMongoose.prototype.set = function(key, value) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (arguments.length === 1 && typeof key !== 'object') {\n    if (VALID_OPTIONS.indexOf(key) === -1) {\n      const error = new SetOptionError();\n      error.addError(key, new SetOptionError.SetOptionInnerError(key));\n      throw error;\n    }\n\n    return _mongoose.options[key];\n  }\n\n  let options = {};\n\n  if (arguments.length === 2) {\n    options = { [key]: value };\n  }\n\n  if (arguments.length === 1 && typeof key === 'object') {\n    options = key;\n  }\n\n  // array for errors to collect all errors for all key-value pairs, like \".validate\"\n  let error = undefined;\n\n  for (const [optionKey, optionValue] of Object.entries(options)) {\n    if (VALID_OPTIONS.indexOf(optionKey) === -1) {\n      if (!error) {\n        error = new SetOptionError();\n      }\n      error.addError(optionKey, new SetOptionError.SetOptionInnerError(optionKey));\n      continue;\n    }\n\n    _mongoose.options[optionKey] = optionValue;\n\n    if (optionKey === 'objectIdGetter') {\n      if (optionValue) {\n        Object.defineProperty(_mongoose.Types.ObjectId.prototype, '_id', {\n          enumerable: false,\n          configurable: true,\n          get: function() {\n            return this;\n          }\n        });\n      } else {\n        delete _mongoose.Types.ObjectId.prototype._id;\n      }\n    } else if (optionKey === 'transactionAsyncLocalStorage') {\n      if (optionValue && !_mongoose.transactionAsyncLocalStorage) {\n        _mongoose.transactionAsyncLocalStorage = new AsyncLocalStorage();\n      } else if (!optionValue && _mongoose.transactionAsyncLocalStorage) {\n        delete _mongoose.transactionAsyncLocalStorage;\n      }\n    }\n  }\n\n  if (error) {\n    throw error;\n  }\n\n  return _mongoose;\n};\n\n/**\n * Gets mongoose options\n *\n * #### Example:\n *\n *     mongoose.get('test') // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nMongoose.prototype.get = Mongoose.prototype.set;\n\n/**\n * Creates a Connection instance.\n *\n * Each `connection` instance maps to a single database. This method is helpful when managing multiple db connections.\n *\n *\n * _Options passed take precedence over options included in connection strings._\n *\n * #### Example:\n *\n *     // with mongodb:// URI\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database');\n *\n *     // and options\n *     const opts = { db: { native_parser: true }}\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database', opts);\n *\n *     // replica sets\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database');\n *\n *     // and options\n *     const opts = { replset: { strategy: 'ping', rs_name: 'testSet' }}\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database', opts);\n *\n *     // initialize now, connect later\n *     db = mongoose.createConnection();\n *     await db.openUri('mongodb://127.0.0.1:27017/database');\n *\n * @param {String} uri mongodb URI to connect to\n * @param {Object} [options] passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {String} [options.dbName] The name of the database you want to use. If not provided, Mongoose uses the database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.maxPoolSize=5] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=1] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. Defaults to 0, which means Node.js will not time out the socket due to inactivity. A socket may be inactive because of either no activity or a long-running operation. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @return {Connection} the created Connection object. Connections are not thenable, so you can't do `await mongoose.createConnection()`. To await use `mongoose.createConnection(uri).asPromise()` instead.\n * @api public\n */\n\nMongoose.prototype.createConnection = function(uri, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  const Connection = _mongoose.__driver.Connection;\n  const conn = new Connection(_mongoose);\n  _mongoose.connections.push(conn);\n  _mongoose.nextConnectionId++;\n  _mongoose.events.emit('createConnection', conn);\n\n  if (arguments.length > 0) {\n    conn.openUri(uri, { ...options, _fireAndForget: true });\n  }\n\n  return conn;\n};\n\n/**\n * Opens the default mongoose connection.\n *\n * #### Example:\n *\n *     mongoose.connect('mongodb://user:pass@127.0.0.1:port/database');\n *\n *     // replica sets\n *     const uri = 'mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/mydatabase';\n *     mongoose.connect(uri);\n *\n *     // with options\n *     mongoose.connect(uri, options);\n *\n *     // Using `await` throws \"MongooseServerSelectionError: Server selection timed out after 30000 ms\"\n *     // if Mongoose can't connect.\n *     const uri = 'mongodb://nonexistent.domain:27000';\n *     await mongoose.connect(uri);\n *\n * @param {String} uri mongodb URI to connect to\n * @param {Object} [options] passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {Number} [options.bufferTimeoutMS=10000] Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.\n * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Number} [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection.\n * @param {Number} [options.serverSelectionTimeoutMS] If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n * @param {Number} [options.heartbeatFrequencyMS] If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @param {Boolean} [options.autoCreate=false] Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.\n * @param {Function} [callback]\n * @see Mongoose#createConnection https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()\n * @api public\n * @return {Promise} resolves to `this` if connection succeeded\n */\n\nMongoose.prototype.connect = async function connect(uri, options) {\n  if (typeof options === 'function' || (arguments.length >= 3 && typeof arguments[2] === 'function')) {\n    throw new MongooseError('Mongoose.prototype.connect() no longer accepts a callback');\n  }\n\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n  const conn = _mongoose.connection;\n\n  return conn.openUri(uri, options).then(() => _mongoose);\n};\n\n/**\n * Runs `.close()` on all connections in parallel.\n *\n * @return {Promise} resolves when all connections are closed, or rejects with the first error that occurred.\n * @api public\n */\n\nMongoose.prototype.disconnect = async function disconnect() {\n  if (arguments.length >= 1 && typeof arguments[0] === 'function') {\n    throw new MongooseError('Mongoose.prototype.disconnect() no longer accepts a callback');\n  }\n\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  const remaining = _mongoose.connections.length;\n  if (remaining <= 0) {\n    return;\n  }\n  await Promise.all(_mongoose.connections.map(conn => conn.close()));\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `mongoose.startSession()` is equivalent to calling `mongoose.connection.startSession()`.\n * Sessions are scoped to a connection, so calling `mongoose.startSession()`\n * starts a session on the [default mongoose connection](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.connection).\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @param {Function} [callback]\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nMongoose.prototype.startSession = function() {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);\n};\n\n/**\n * Getter/setter around function for pluralizing collection names.\n *\n * @param {Function|null} [fn] overwrites the function used to pluralize collection names\n * @return {Function|null} the current function used to pluralize collection names, defaults to the legacy function from `mongoose-legacy-pluralize`.\n * @api public\n */\n\nMongoose.prototype.pluralize = function(fn) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (arguments.length > 0) {\n    _mongoose._pluralize = fn;\n  }\n  return _mongoose._pluralize;\n};\n\n/**\n * Defines a model or retrieves it.\n *\n * Models defined on the `mongoose` instance are available to all connection\n * created by the same `mongoose` instance.\n *\n * If you call `mongoose.model()` with twice the same name but a different schema,\n * you will get an `OverwriteModelError`. If you call `mongoose.model()` with\n * the same name and same schema, you'll get the same schema back.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *\n *     // define an Actor model with this mongoose instance\n *     const schema = new Schema({ name: String });\n *     mongoose.model('Actor', schema);\n *\n *     // create a new connection\n *     const conn = mongoose.createConnection(..);\n *\n *     // create Actor model\n *     const Actor = conn.model('Actor', schema);\n *     conn.model('Actor') === Actor; // true\n *     conn.model('Actor', schema) === Actor; // true, same schema\n *     conn.model('Actor', schema, 'actors') === Actor; // true, same schema and collection name\n *\n *     // This throws an `OverwriteModelError` because the schema is different.\n *     conn.model('Actor', new Schema({ name: String }));\n *\n * _When no `collection` argument is passed, Mongoose uses the model name. If you don't like this behavior, either pass a collection name, use `mongoose.pluralize()`, or set your schemas collection name option._\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     const collectionName = 'actor';\n *     const M = mongoose.model('Actor', schema, collectionName);\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} [schema] the schema to use.\n * @param {String} [collection] name (optional, inferred from model name)\n * @param {Object} [options]\n * @param {Boolean} [options.overwriteModels=false] If true, overwrite existing models with the same name to avoid `OverwriteModelError`\n * @return {Model} The model associated with `name`. Mongoose will create the model if it doesn't already exist.\n * @api public\n */\n\nMongoose.prototype.model = function(name, schema, collection, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (arguments.length === 1) {\n    const model = _mongoose.models[name];\n    if (!model) {\n      throw new MongooseError.MissingSchemaError(name);\n    }\n    return model;\n  }\n\n  if (utils.isObject(schema) && !(schema instanceof Schema)) {\n    schema = new Schema(schema);\n  }\n  if (schema && !(schema instanceof Schema)) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  // handle internal options from connection.model()\n  options = options || {};\n\n  const originalSchema = schema;\n  if (schema) {\n    if (_mongoose.get('cloneSchemas')) {\n      schema = schema.clone();\n    }\n    _mongoose._applyPlugins(schema);\n  }\n\n  // connection.model() may be passing a different schema for\n  // an existing model name. in this case don't read from cache.\n  const overwriteModels = _mongoose.options.hasOwnProperty('overwriteModels') ?\n    _mongoose.options.overwriteModels :\n    options.overwriteModels;\n  if (_mongoose.models.hasOwnProperty(name) && options.cache !== false && overwriteModels !== true) {\n    if (originalSchema &&\n        originalSchema.instanceOfSchema &&\n        originalSchema !== _mongoose.models[name].schema) {\n      throw new _mongoose.Error.OverwriteModelError(name);\n    }\n    if (collection && collection !== _mongoose.models[name].collection.name) {\n      // subclass current model with alternate collection\n      const model = _mongoose.models[name];\n      schema = model.prototype.schema;\n      const sub = model.__subclass(_mongoose.connection, schema, collection);\n      // do not cache the sub model\n      return sub;\n    }\n    return _mongoose.models[name];\n  }\n  if (schema == null) {\n    throw new _mongoose.Error.MissingSchemaError(name);\n  }\n\n  const model = _mongoose._model(name, schema, collection, options);\n  _mongoose.connection.models[name] = model;\n  _mongoose.models[name] = model;\n\n  return model;\n};\n\n/*!\n * ignore\n */\n\nMongoose.prototype._model = function(name, schema, collection, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = model.name;\n    if (!(model.prototype instanceof Model)) {\n      throw new _mongoose.Error('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  if (schema) {\n    if (_mongoose.get('cloneSchemas')) {\n      schema = schema.clone();\n    }\n    _mongoose._applyPlugins(schema);\n  }\n\n  // Apply relevant \"global\" options to the schema\n  if (schema == null || !('pluralization' in schema.options)) {\n    schema.options.pluralization = _mongoose.options.pluralization;\n  }\n\n  if (!collection) {\n    collection = schema.get('collection') ||\n      utils.toCollectionName(name, _mongoose.pluralize());\n  }\n\n  const connection = options.connection || _mongoose.connection;\n  model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);\n  // Errors handled internally, so safe to ignore error\n  model.init().catch(function $modelInitNoop() {});\n\n  connection.emit('model', model);\n\n  if (schema._applyDiscriminators != null) {\n    for (const disc of schema._applyDiscriminators.keys()) {\n      const {\n        schema: discriminatorSchema,\n        options\n      } = schema._applyDiscriminators.get(disc);\n      model.discriminator(disc, discriminatorSchema, options);\n    }\n  }\n\n  applyEmbeddedDiscriminators(schema);\n\n  return model;\n};\n\n/**\n * Removes the model named `name` from the default connection, if it exists.\n * You can use this function to clean up any models you created in your tests to\n * prevent OverwriteModelErrors.\n *\n * Equivalent to `mongoose.connection.deleteModel(name)`.\n *\n * #### Example:\n *\n *     mongoose.model('User', new Schema({ name: String }));\n *     console.log(mongoose.model('User')); // Model object\n *     mongoose.deleteModel('User');\n *     console.log(mongoose.model('User')); // undefined\n *\n *     // Usually useful in a Mocha `afterEach()` hook\n *     afterEach(function() {\n *       mongoose.deleteModel(/.+/); // Delete every model\n *     });\n *\n * @api public\n * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n * @return {Mongoose} this\n */\n\nMongoose.prototype.deleteModel = function(name) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  _mongoose.connection.deleteModel(name);\n  delete _mongoose.models[name];\n  return _mongoose;\n};\n\n/**\n * Returns an array of model names created on this instance of Mongoose.\n *\n * #### Note:\n *\n * _Does not include names of models created using `connection.model()`._\n *\n * @api public\n * @return {Array}\n */\n\nMongoose.prototype.modelNames = function() {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  const names = Object.keys(_mongoose.models);\n  return names;\n};\n\n/**\n * Applies global plugins to `schema`.\n *\n * @param {Schema} schema\n * @api private\n */\n\nMongoose.prototype._applyPlugins = function(schema, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  options = options || {};\n  options.applyPluginsToDiscriminators = _mongoose.options && _mongoose.options.applyPluginsToDiscriminators || false;\n  options.applyPluginsToChildSchemas = typeof (_mongoose.options && _mongoose.options.applyPluginsToChildSchemas) === 'boolean' ?\n    _mongoose.options.applyPluginsToChildSchemas :\n    true;\n  applyPlugins(schema, _mongoose.plugins, options, '$globalPluginsApplied');\n};\n\n/**\n * Declares a global plugin executed on all Schemas.\n *\n * Equivalent to calling `.plugin(fn)` on each Schema you create.\n *\n * @param {Function} fn plugin callback\n * @param {Object} [opts] optional options\n * @return {Mongoose} this\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nMongoose.prototype.plugin = function(fn, opts) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  _mongoose.plugins.push([fn, opts]);\n  return _mongoose;\n};\n\n/**\n * The Mongoose module's default connection. Equivalent to `mongoose.connections[0]`, see [`connections`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.connections).\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose.connect(...);\n *     mongoose.connection.on('error', cb);\n *\n * This is the connection used by default for every model created using [mongoose.model](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()).\n *\n * To create a new connection, use [`createConnection()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()).\n *\n * @memberOf Mongoose\n * @instance\n * @property {Connection} connection\n * @api public\n */\n\nMongoose.prototype.__defineGetter__('connection', function() {\n  return this.connections[0];\n});\n\nMongoose.prototype.__defineSetter__('connection', function(v) {\n  if (v instanceof this.__driver.Connection) {\n    this.connections[0] = v;\n    this.models = v.models;\n  }\n});\n\n/**\n * An array containing all [connections](connection.html) associated with this\n * Mongoose instance. By default, there is 1 connection. Calling\n * [`createConnection()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()) adds a connection\n * to this array.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose.connections.length; // 1, just the default connection\n *     mongoose.connections[0] === mongoose.connection; // true\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n *     mongoose.connections.length; // 2\n *\n * @memberOf Mongoose\n * @instance\n * @property {Array} connections\n * @api public\n */\n\nMongoose.prototype.connections;\n\n/**\n * An integer containing the value of the next connection id. Calling\n * [`createConnection()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()) increments\n * this value.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose.createConnection(); // id `0`, `nextConnectionId` becomes `1`\n *     mongoose.createConnection(); // id `1`, `nextConnectionId` becomes `2`\n *     mongoose.connections[0].destroy() // Removes connection with id `0`\n *     mongoose.createConnection(); // id `2`, `nextConnectionId` becomes `3`\n *\n * @memberOf Mongoose\n * @instance\n * @property {Number} nextConnectionId\n * @api private\n */\n\nMongoose.prototype.nextConnectionId;\n\n/**\n * The Mongoose Aggregate constructor\n *\n * @method Aggregate\n * @api public\n */\n\nMongoose.prototype.Aggregate = Aggregate;\n\n/**\n * The Mongoose Collection constructor\n *\n * @memberOf Mongoose\n * @instance\n * @method Collection\n * @api public\n */\n\nObject.defineProperty(Mongoose.prototype, 'Collection', {\n  get: function() {\n    return this.__driver.Collection;\n  },\n  set: function(Collection) {\n    this.__driver.Collection = Collection;\n  }\n});\n\n/**\n * The Mongoose [Connection](https://mongoosejs.com/docs/api/connection.html#Connection()) constructor\n *\n * @memberOf Mongoose\n * @instance\n * @method Connection\n * @api public\n */\n\nObject.defineProperty(Mongoose.prototype, 'Connection', {\n  get: function() {\n    return this.__driver.Connection;\n  },\n  set: function(Connection) {\n    if (Connection === this.__driver.Connection) {\n      return;\n    }\n\n    this.__driver.Connection = Connection;\n  }\n});\n\n/**\n * The Mongoose version\n *\n * #### Example:\n *\n *     console.log(mongoose.version); // '5.x.x'\n *\n * @property version\n * @api public\n */\n\nMongoose.prototype.version = pkg.version;\n\n/**\n * The Mongoose constructor\n *\n * The exports of the mongoose module is an instance of this class.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const mongoose2 = new mongoose.Mongoose();\n *\n * @method Mongoose\n * @api public\n */\n\nMongoose.prototype.Mongoose = Mongoose;\n\n/**\n * The Mongoose [Schema](https://mongoosejs.com/docs/api/schema.html#Schema()) constructor\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const Schema = mongoose.Schema;\n *     const CatSchema = new Schema(..);\n *\n * @method Schema\n * @api public\n */\n\nMongoose.prototype.Schema = Schema;\n\n/**\n * The Mongoose [SchemaType](https://mongoosejs.com/docs/api/schematype.html#SchemaType()) constructor\n *\n * @method SchemaType\n * @api public\n */\n\nMongoose.prototype.SchemaType = SchemaType;\n\n/**\n * The various Mongoose SchemaTypes.\n *\n * #### Note:\n *\n * _Alias of mongoose.Schema.Types for backwards compatibility._\n *\n * @property SchemaTypes\n * @see Schema.SchemaTypes https://mongoosejs.com/docs/schematypes.html\n * @api public\n */\n\nMongoose.prototype.SchemaTypes = Schema.Types;\n\n/**\n * The Mongoose [VirtualType](https://mongoosejs.com/docs/api/virtualtype.html#VirtualType()) constructor\n *\n * @method VirtualType\n * @api public\n */\n\nMongoose.prototype.VirtualType = VirtualType;\n\n/**\n * The various Mongoose Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const array = mongoose.Types.Array;\n *\n * #### Types:\n *\n * - [Array](https://mongoosejs.com/docs/schematypes.html#arrays)\n * - [Buffer](https://mongoosejs.com/docs/schematypes.html#buffers)\n * - [Embedded](https://mongoosejs.com/docs/schematypes.html#schemas)\n * - [DocumentArray](https://mongoosejs.com/docs/api/documentarraypath.html)\n * - [Decimal128](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.Decimal128)\n * - [ObjectId](https://mongoosejs.com/docs/schematypes.html#objectids)\n * - [Map](https://mongoosejs.com/docs/schematypes.html#maps)\n * - [Subdocument](https://mongoosejs.com/docs/schematypes.html#schemas)\n *\n * Using this exposed access to the `ObjectId` type, we can construct ids on demand.\n *\n *     const ObjectId = mongoose.Types.ObjectId;\n *     const id1 = new ObjectId;\n *\n * @property Types\n * @api public\n */\n\nMongoose.prototype.Types = Types;\n\n/**\n * The Mongoose [Query](https://mongoosejs.com/docs/api/query.html#Query()) constructor.\n *\n * @method Query\n * @api public\n */\n\nMongoose.prototype.Query = Query;\n\n/**\n * The Mongoose [Model](https://mongoosejs.com/docs/api/model.html#Model()) constructor.\n *\n * @method Model\n * @api public\n */\n\nMongoose.prototype.Model = Model;\n\n/**\n * The Mongoose [Document](https://mongoosejs.com/docs/api/document.html#Document()) constructor.\n *\n * @method Document\n * @api public\n */\n\nMongoose.prototype.Document = Document;\n\n/**\n * The Mongoose DocumentProvider constructor. Mongoose users should not have to\n * use this directly\n *\n * @method DocumentProvider\n * @api public\n */\n\nMongoose.prototype.DocumentProvider = __webpack_require__(/*! ./document_provider */ \"(api)/../server/node_modules/mongoose/lib/document_provider.js\");\n\n/**\n * The Mongoose ObjectId [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that should be\n * [MongoDB ObjectIds](https://www.mongodb.com/docs/manual/reference/method/ObjectId/).\n * Do not use this to create a new ObjectId instance, use `mongoose.Types.ObjectId`\n * instead.\n *\n * #### Example:\n *\n *     const childSchema = new Schema({ parentId: mongoose.ObjectId });\n *\n * @property ObjectId\n * @api public\n */\n\nMongoose.prototype.ObjectId = SchemaTypes.ObjectId;\n\n/**\n * Returns true if Mongoose can cast the given value to an ObjectId, or\n * false otherwise.\n *\n * #### Example:\n *\n *     mongoose.isValidObjectId(new mongoose.Types.ObjectId()); // true\n *     mongoose.isValidObjectId('0123456789ab'); // true\n *     mongoose.isValidObjectId(6); // true\n *     mongoose.isValidObjectId(new User({ name: 'test' })); // true\n *\n *     mongoose.isValidObjectId({ test: 42 }); // false\n *\n * @method isValidObjectId\n * @param {Any} v\n * @returns {boolean} true if `v` is something Mongoose can coerce to an ObjectId\n * @api public\n */\n\nMongoose.prototype.isValidObjectId = function(v) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n  return _mongoose.Types.ObjectId.isValid(v);\n};\n\n/**\n * Returns true if the given value is a Mongoose ObjectId (using `instanceof`) or if the\n * given value is a 24 character hex string, which is the most commonly used string representation\n * of an ObjectId.\n *\n * This function is similar to `isValidObjectId()`, but considerably more strict, because\n * `isValidObjectId()` will return `true` for _any_ value that Mongoose can convert to an\n * ObjectId. That includes Mongoose documents, any string of length 12, and any number.\n * `isObjectIdOrHexString()` returns true only for `ObjectId` instances or 24 character hex\n * strings, and will return false for numbers, documents, and strings of length 12.\n *\n * #### Example:\n *\n *     mongoose.isObjectIdOrHexString(new mongoose.Types.ObjectId()); // true\n *     mongoose.isObjectIdOrHexString('62261a65d66c6be0a63c051f'); // true\n *\n *     mongoose.isObjectIdOrHexString('0123456789ab'); // false\n *     mongoose.isObjectIdOrHexString(6); // false\n *     mongoose.isObjectIdOrHexString(new User({ name: 'test' })); // false\n *     mongoose.isObjectIdOrHexString({ test: 42 }); // false\n *\n * @method isObjectIdOrHexString\n * @param {Any} v\n * @returns {boolean} true if `v` is an ObjectId instance _or_ a 24 char hex string\n * @api public\n */\n\nMongoose.prototype.isObjectIdOrHexString = function(v) {\n  return isBsonType(v, 'ObjectId') || (typeof v === 'string' && objectIdHexRegexp.test(v));\n};\n\n/**\n *\n * Syncs all the indexes for the models registered with this connection.\n *\n * @param {Object} options\n * @param {Boolean} options.continueOnError `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n * @return {Promise} Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n */\nMongoose.prototype.syncIndexes = function(options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n  return _mongoose.connection.syncIndexes(options);\n};\n\n/**\n * The Mongoose Decimal128 [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that should be\n * [128-bit decimal floating points](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-decimal.html).\n * Do not use this to create a new Decimal128 instance, use `mongoose.Types.Decimal128`\n * instead.\n *\n * #### Example:\n *\n *     const vehicleSchema = new Schema({ fuelLevel: mongoose.Decimal128 });\n *\n * @property Decimal128\n * @api public\n */\n\nMongoose.prototype.Decimal128 = SchemaTypes.Decimal128;\n\n/**\n * The Mongoose Mixed [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that Mongoose's change tracking, casting,\n * and validation should ignore.\n *\n * #### Example:\n *\n *     const schema = new Schema({ arbitrary: mongoose.Mixed });\n *\n * @property Mixed\n * @api public\n */\n\nMongoose.prototype.Mixed = SchemaTypes.Mixed;\n\n/**\n * The Mongoose Date [SchemaType](https://mongoosejs.com/docs/schematypes.html).\n *\n * #### Example:\n *\n *     const schema = new Schema({ test: Date });\n *     schema.path('test') instanceof mongoose.Date; // true\n *\n * @property Date\n * @api public\n */\n\nMongoose.prototype.Date = SchemaTypes.Date;\n\n/**\n * The Mongoose Number [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that Mongoose should cast to numbers.\n *\n * #### Example:\n *\n *     const schema = new Schema({ num: mongoose.Number });\n *     // Equivalent to:\n *     const schema = new Schema({ num: 'number' });\n *\n * @property Number\n * @api public\n */\n\nMongoose.prototype.Number = SchemaTypes.Number;\n\n/**\n * The [MongooseError](https://mongoosejs.com/docs/api/error.html#Error()) constructor.\n *\n * @method Error\n * @api public\n */\n\nMongoose.prototype.Error = __webpack_require__(/*! ./error/index */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nMongoose.prototype.MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * Mongoose uses this function to get the current time when setting\n * [timestamps](https://mongoosejs.com/docs/guide.html#timestamps). You may stub out this function\n * using a tool like [Sinon](https://www.npmjs.com/package/sinon) for testing.\n *\n * @method now\n * @returns Date the current time\n * @api public\n */\n\nMongoose.prototype.now = function now() { return new Date(); };\n\n/**\n * The Mongoose CastError constructor\n *\n * @method CastError\n * @param {String} type The name of the type\n * @param {Any} value The value that failed to cast\n * @param {String} path The path `a.b.c` in the doc where this cast error occurred\n * @param {Error} [reason] The original error that was thrown\n * @api public\n */\n\nMongoose.prototype.CastError = __webpack_require__(/*! ./error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * The constructor used for schematype options\n *\n * @method SchemaTypeOptions\n * @api public\n */\n\nMongoose.prototype.SchemaTypeOptions = __webpack_require__(/*! ./options/SchemaTypeOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\");\n\n/**\n * The [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver Mongoose uses.\n *\n * @property mongo\n * @api public\n */\n\nMongoose.prototype.mongo = __webpack_require__(/*! mongodb */ \"(api)/../server/node_modules/mongodb/lib/index.js\");\n\n/**\n * The [mquery](https://github.com/aheckmann/mquery) query builder Mongoose uses.\n *\n * @property mquery\n * @api public\n */\n\nMongoose.prototype.mquery = __webpack_require__(/*! mquery */ \"(api)/../server/node_modules/mquery/lib/mquery.js\");\n\n/**\n * Sanitizes query filters against [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html)\n * by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.\n *\n * ```javascript\n * const obj = { username: 'val', pwd: { $ne: null } };\n * sanitizeFilter(obj);\n * obj; // { username: 'val', pwd: { $eq: { $ne: null } } });\n * ```\n *\n * @method sanitizeFilter\n * @param {Object} filter\n * @returns Object the sanitized object\n * @api public\n */\n\nMongoose.prototype.sanitizeFilter = sanitizeFilter;\n\n/**\n * Tells `sanitizeFilter()` to skip the given object when filtering out potential [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html).\n * Use this method when you have a known query selector that you want to use.\n *\n * ```javascript\n * const obj = { username: 'val', pwd: trusted({ $type: 'string', $eq: 'my secret' }) };\n * sanitizeFilter(obj);\n *\n * // Note that `sanitizeFilter()` did not add `$eq` around `$type`.\n * obj; // { username: 'val', pwd: { $type: 'string', $eq: 'my secret' } });\n * ```\n *\n * @method trusted\n * @param {Object} obj\n * @returns Object the passed in object\n * @api public\n */\n\nMongoose.prototype.trusted = trusted;\n\n/**\n * Use this function in `pre()` middleware to skip calling the wrapped function.\n *\n * #### Example:\n *\n *     schema.pre('save', function() {\n *       // Will skip executing `save()`, but will execute post hooks as if\n *       // `save()` had executed with the result `{ matchedCount: 0 }`\n *       return mongoose.skipMiddlewareFunction({ matchedCount: 0 });\n *     });\n *\n * @method skipMiddlewareFunction\n * @param {any} result\n * @api public\n */\n\nMongoose.prototype.skipMiddlewareFunction = Kareem.skipWrappedFunction;\n\n/**\n * Use this function in `post()` middleware to replace the result\n *\n * #### Example:\n *\n *     schema.post('find', function(res) {\n *       // Normally you have to modify `res` in place. But with\n *       // `overwriteMiddlewarResult()`, you can make `find()` return a\n *       // completely different value.\n *       return mongoose.overwriteMiddlewareResult(res.filter(doc => !doc.isDeleted));\n *     });\n *\n * @method overwriteMiddlewareResult\n * @param {any} result\n * @api public\n */\n\nMongoose.prototype.overwriteMiddlewareResult = Kareem.overwriteResult;\n\n/**\n * The exports object is an instance of Mongoose.\n *\n * @api private\n */\n\nconst mongoose = module.exports = exports = new Mongoose({\n  [defaultMongooseSymbol]: true\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGdHQUF1QixDQUFDLG1CQUFPLENBQUMscUhBQStCOztBQUUvRCxpQkFBaUIsbUJBQU8sQ0FBQyx5RUFBWTtBQUNyQyxxQkFBcUIsMERBQThCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyw0REFBUTtBQUMvQixlQUFlLG1CQUFPLENBQUMscUVBQVU7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsNkVBQWM7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsaUZBQWdCO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLCtFQUFlO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyx1RkFBbUI7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMsaUZBQWdCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyx5RUFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsbUVBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLG1FQUFTO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLCtHQUErQjtBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBVztBQUMxQyxlQUFlLG1CQUFPLENBQUMscUVBQVU7QUFDakMsd0JBQXdCLG1CQUFPLENBQUMsMkZBQXFCO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyxtRUFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsMkVBQWlCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxpRUFBUTs7QUFFN0Isa0JBQWtCLG1CQUFPLENBQUMsMkVBQWE7QUFDdkMsZ0JBQWdCLGtJQUEwQztBQUMxRCx1QkFBdUIsbUJBQU8sQ0FBQyxpSEFBZ0M7QUFDL0QsbUJBQW1CLG1CQUFPLENBQUMsNkZBQXNCO0FBQ2pELHNCQUFzQixtQkFBTyxDQUFDLCtGQUF1QjtBQUNyRCx1QkFBdUIsbUJBQU8sQ0FBQyxpR0FBd0I7QUFDdkQsb0NBQW9DLG1CQUFPLENBQUMsMkpBQXFEOztBQUVq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T0FBTztBQUNyQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LFFBQVEsS0FBSyx3QkFBd0IscUNBQXFDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCO0FBQ3RFLGtEQUFrRCxpQkFBaUI7QUFDbkUsUUFBUTtBQUNSO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnJlcXVpcmUoJy4vZHJpdmVyJykuc2V0KHJlcXVpcmUoJy4vZHJpdmVycy9ub2RlLW1vbmdvZGItbmF0aXZlJykpO1xuXG5jb25zdCBEb2N1bWVudCA9IHJlcXVpcmUoJy4vZG9jdW1lbnQnKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IEthcmVlbSA9IHJlcXVpcmUoJ2thcmVlbScpO1xuY29uc3QgU2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEnKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuL3NjaGVtYXR5cGUnKTtcbmNvbnN0IFNjaGVtYVR5cGVzID0gcmVxdWlyZSgnLi9zY2hlbWEvaW5kZXgnKTtcbmNvbnN0IFZpcnR1YWxUeXBlID0gcmVxdWlyZSgnLi92aXJ0dWFsdHlwZScpO1xuY29uc3QgU1RBVEVTID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uc3RhdGUnKTtcbmNvbnN0IFZBTElEX09QVElPTlMgPSByZXF1aXJlKCcuL3ZhbGlkb3B0aW9ucycpO1xuY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcbmNvbnN0IE1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbCcpO1xuY29uc3QgYXBwbHlQbHVnaW5zID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9hcHBseVBsdWdpbnMnKTtcbmNvbnN0IGJ1aWx0aW5QbHVnaW5zID0gcmVxdWlyZSgnLi9wbHVnaW5zJyk7XG5jb25zdCBkcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlcicpO1xuY29uc3QgbGVnYWN5UGx1cmFsaXplID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BsdXJhbGl6ZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBwa2cgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcbmNvbnN0IGNhc3QgPSByZXF1aXJlKCcuL2Nhc3QnKTtcblxuY29uc3QgQWdncmVnYXRlID0gcmVxdWlyZSgnLi9hZ2dyZWdhdGUnKTtcbmNvbnN0IHRydXN0ZWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvdHJ1c3RlZCcpLnRydXN0ZWQ7XG5jb25zdCBzYW5pdGl6ZUZpbHRlciA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9zYW5pdGl6ZUZpbHRlcicpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBTZXRPcHRpb25FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Ivc2V0T3B0aW9uRXJyb3InKTtcbmNvbnN0IGFwcGx5RW1iZWRkZWREaXNjcmltaW5hdG9ycyA9IHJlcXVpcmUoJy4vaGVscGVycy9kaXNjcmltaW5hdG9yL2FwcGx5RW1iZWRkZWREaXNjcmltaW5hdG9ycycpO1xuXG5jb25zdCBkZWZhdWx0TW9uZ29vc2VTeW1ib2wgPSBTeW1ib2wuZm9yKCdtb25nb29zZTpkZWZhdWx0Jyk7XG5cbnJlcXVpcmUoJy4vaGVscGVycy9wcmludEplc3RXYXJuaW5nJyk7XG5cbmNvbnN0IG9iamVjdElkSGV4UmVnZXhwID0gL15bMC05QS1GYS1mXXsyNH0kLztcblxuY29uc3QgeyBBc3luY0xvY2FsU3RvcmFnZSB9ID0gcmVxdWlyZSgnbm9kZTphc3luY19ob29rcycpO1xuXG4vKipcbiAqIE1vbmdvb3NlIGNvbnN0cnVjdG9yLlxuICpcbiAqIFRoZSBleHBvcnRzIG9iamVjdCBvZiB0aGUgYG1vbmdvb3NlYCBtb2R1bGUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqIE1vc3QgYXBwcyB3aWxsIG9ubHkgdXNlIHRoaXMgb25lIGluc3RhbmNlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIG1vbmdvb3NlIGluc3RhbmNlb2YgbW9uZ29vc2UuTW9uZ29vc2U7IC8vIHRydWVcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgbmV3IE1vbmdvb3NlIGluc3RhbmNlIHdpdGggaXRzIG93biBgY29ubmVjdCgpYCwgYHNldCgpYCwgYG1vZGVsKClgLCBldGMuXG4gKiAgICAgY29uc3QgbSA9IG5ldyBtb25nb29zZS5Nb25nb29zZSgpO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBzZWUgW2BNb25nb29zZSNzZXQoKWAgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5zZXQoKSlcbiAqL1xuZnVuY3Rpb24gTW9uZ29vc2Uob3B0aW9ucykge1xuICB0aGlzLmNvbm5lY3Rpb25zID0gW107XG4gIHRoaXMubmV4dENvbm5lY3Rpb25JZCA9IDA7XG4gIHRoaXMubW9kZWxzID0ge307XG4gIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICB0aGlzLl9fZHJpdmVyID0gZHJpdmVyLmdldCgpO1xuICAvLyBkZWZhdWx0IGdsb2JhbCBvcHRpb25zXG4gIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBsdXJhbGl6YXRpb246IHRydWUsXG4gICAgYXV0b0luZGV4OiB0cnVlLFxuICAgIGF1dG9DcmVhdGU6IHRydWVcbiAgfSwgb3B0aW9ucyk7XG4gIGNvbnN0IGNyZWF0ZUluaXRpYWxDb25uZWN0aW9uID0gdXRpbHMuZ2V0T3B0aW9uKCdjcmVhdGVJbml0aWFsQ29ubmVjdGlvbicsIHRoaXMub3B0aW9ucyk7XG4gIGlmIChjcmVhdGVJbml0aWFsQ29ubmVjdGlvbiA9PSBudWxsIHx8IGNyZWF0ZUluaXRpYWxDb25uZWN0aW9uKSB7XG4gICAgY29uc3QgY29ubiA9IHRoaXMuY3JlYXRlQ29ubmVjdGlvbigpOyAvLyBkZWZhdWx0IGNvbm5lY3Rpb25cbiAgICBjb25uLm1vZGVscyA9IHRoaXMubW9kZWxzO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5wbHVyYWxpemF0aW9uKSB7XG4gICAgdGhpcy5fcGx1cmFsaXplID0gbGVnYWN5UGx1cmFsaXplO1xuICB9XG5cbiAgLy8gSWYgYSB1c2VyIGNyZWF0ZXMgdGhlaXIgb3duIE1vbmdvb3NlIGluc3RhbmNlLCBnaXZlIHRoZW0gYSBzZXBhcmF0ZSBjb3B5XG4gIC8vIG9mIHRoZSBgU2NoZW1hYCBjb25zdHJ1Y3RvciBzbyB0aGV5IGdldCBzZXBhcmF0ZSBjdXN0b20gdHlwZXMuIChnaC02OTMzKVxuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnNbZGVmYXVsdE1vbmdvb3NlU3ltYm9sXSkge1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICB0aGlzLlNjaGVtYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5iYXNlID0gX3RoaXM7XG4gICAgICByZXR1cm4gU2NoZW1hLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICB0aGlzLlNjaGVtYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYS5wcm90b3R5cGUpO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLlNjaGVtYSwgU2NoZW1hKTtcbiAgICB0aGlzLlNjaGVtYS5iYXNlID0gdGhpcztcbiAgICB0aGlzLlNjaGVtYS5UeXBlcyA9IE9iamVjdC5hc3NpZ24oe30sIFNjaGVtYS5UeXBlcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFjayB0byB3b3JrIGFyb3VuZCBiYWJlbCdzIHN0cmFuZ2UgYmVoYXZpb3Igd2l0aFxuICAgIC8vIGBpbXBvcnQgbW9uZ29vc2UsIHsgU2NoZW1hIH0gZnJvbSAnbW9uZ29vc2UnYC4gQmVjYXVzZSBgU2NoZW1hYCBpcyBub3RcbiAgICAvLyBhbiBvd24gcHJvcGVydHkgb2YgYSBNb25nb29zZSBnbG9iYWwsIFNjaGVtYSB3aWxsIGJlIHVuZGVmaW5lZC4gU2VlIGdoLTU2NDhcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBbJ1NjaGVtYScsICdtb2RlbCddKSB7XG4gICAgICB0aGlzW2tleV0gPSBNb25nb29zZS5wcm90b3R5cGVba2V5XTtcbiAgICB9XG4gIH1cbiAgdGhpcy5TY2hlbWEucHJvdG90eXBlLmJhc2UgPSB0aGlzO1xuXG4gIGlmIChvcHRpb25zPy50cmFuc2FjdGlvbkFzeW5jTG9jYWxTdG9yYWdlKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbkFzeW5jTG9jYWxTdG9yYWdlID0gbmV3IEFzeW5jTG9jYWxTdG9yYWdlKCk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3BsdWdpbnMnLCB7XG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogT2JqZWN0LnZhbHVlcyhidWlsdGluUGx1Z2lucykubWFwKHBsdWdpbiA9PiAoW3BsdWdpbiwgeyBkZWR1cGxpY2F0ZTogdHJ1ZSB9XSkpXG4gIH0pO1xufVxuXG5Nb25nb29zZS5wcm90b3R5cGUuY2FzdCA9IGNhc3Q7XG4vKipcbiAqIEV4cG9zZSBjb25uZWN0aW9uIHN0YXRlcyBmb3IgdXNlci1sYW5kXG4gKlxuICogQG1lbWJlck9mIE1vbmdvb3NlXG4gKiBAcHJvcGVydHkgU1RBVEVTXG4gKiBAYXBpIHB1YmxpY1xuICovXG5Nb25nb29zZS5wcm90b3R5cGUuU1RBVEVTID0gU1RBVEVTO1xuXG4vKipcbiAqIEV4cG9zZSBjb25uZWN0aW9uIHN0YXRlcyBmb3IgdXNlci1sYW5kXG4gKlxuICogQG1lbWJlck9mIE1vbmdvb3NlXG4gKiBAcHJvcGVydHkgQ29ubmVjdGlvblN0YXRlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuTW9uZ29vc2UucHJvdG90eXBlLkNvbm5lY3Rpb25TdGF0ZXMgPSBTVEFURVM7XG5cbi8qKlxuICogT2JqZWN0IHdpdGggYGdldCgpYCBhbmQgYHNldCgpYCBjb250YWluaW5nIHRoZSB1bmRlcmx5aW5nIGRyaXZlciB0aGlzIE1vbmdvb3NlIGluc3RhbmNlXG4gKiB1c2VzIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIGRhdGFiYXNlLiBBIGRyaXZlciBpcyBhIE1vbmdvb3NlLXNwZWNpZmljIGludGVyZmFjZSB0aGF0IGRlZmluZXMgZnVuY3Rpb25zXG4gKiBsaWtlIGBmaW5kKClgLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VcbiAqIEBwcm9wZXJ0eSBkcml2ZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLmRyaXZlciA9IGRyaXZlcjtcblxuLyoqXG4gKiBPdmVyd3JpdGVzIHRoZSBjdXJyZW50IGRyaXZlciB1c2VkIGJ5IHRoaXMgTW9uZ29vc2UgaW5zdGFuY2UuIEEgZHJpdmVyIGlzIGFcbiAqIE1vbmdvb3NlLXNwZWNpZmljIGludGVyZmFjZSB0aGF0IGRlZmluZXMgZnVuY3Rpb25zIGxpa2UgYGZpbmQoKWAuXG4gKlxuICogQG1lbWJlck9mIE1vbmdvb3NlXG4gKiBAbWV0aG9kIHNldERyaXZlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuc2V0RHJpdmVyID0gZnVuY3Rpb24gc2V0RHJpdmVyKGRyaXZlcikge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgaWYgKF9tb25nb29zZS5fX2RyaXZlciA9PT0gZHJpdmVyKSB7XG4gICAgcmV0dXJuIF9tb25nb29zZTtcbiAgfVxuXG4gIGNvbnN0IG9wZW5Db25uZWN0aW9uID0gX21vbmdvb3NlLmNvbm5lY3Rpb25zICYmIF9tb25nb29zZS5jb25uZWN0aW9ucy5maW5kKGNvbm4gPT4gY29ubi5yZWFkeVN0YXRlICE9PSBTVEFURVMuZGlzY29ubmVjdGVkKTtcbiAgaWYgKG9wZW5Db25uZWN0aW9uKSB7XG4gICAgY29uc3QgbXNnID0gJ0Nhbm5vdCBtb2RpZnkgTW9uZ29vc2UgZHJpdmVyIGlmIGEgY29ubmVjdGlvbiBpcyBhbHJlYWR5IG9wZW4uICcgK1xuICAgICAgJ0NhbGwgYG1vbmdvb3NlLmRpc2Nvbm5lY3QoKWAgYmVmb3JlIG1vZGlmeWluZyB0aGUgZHJpdmVyJztcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihtc2cpO1xuICB9XG4gIF9tb25nb29zZS5fX2RyaXZlciA9IGRyaXZlcjtcblxuICBjb25zdCBDb25uZWN0aW9uID0gZHJpdmVyLkNvbm5lY3Rpb247XG4gIF9tb25nb29zZS5jb25uZWN0aW9ucyA9IFtuZXcgQ29ubmVjdGlvbihfbW9uZ29vc2UpXTtcbiAgX21vbmdvb3NlLmNvbm5lY3Rpb25zWzBdLm1vZGVscyA9IF9tb25nb29zZS5tb2RlbHM7XG5cbiAgcmV0dXJuIF9tb25nb29zZTtcbn07XG5cbi8qKlxuICogU2V0cyBtb25nb29zZSBvcHRpb25zXG4gKlxuICogYGtleWAgY2FuIGJlIHVzZWQgYSBvYmplY3QgdG8gc2V0IG11bHRpcGxlIG9wdGlvbnMgYXQgb25jZS5cbiAqIElmIGEgZXJyb3IgZ2V0cyB0aHJvd24gZm9yIG9uZSBvcHRpb24sIG90aGVyIG9wdGlvbnMgd2lsbCBzdGlsbCBiZSBldmFsdWF0ZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5zZXQoJ3Rlc3QnLCB2YWx1ZSkgLy8gc2V0cyB0aGUgJ3Rlc3QnIG9wdGlvbiB0byBgdmFsdWVgXG4gKlxuICogICAgIG1vbmdvb3NlLnNldCgnZGVidWcnLCB0cnVlKSAvLyBlbmFibGUgbG9nZ2luZyBjb2xsZWN0aW9uIG1ldGhvZHMgKyBhcmd1bWVudHMgdG8gdGhlIGNvbnNvbGUvZmlsZVxuICpcbiAqICAgICBtb25nb29zZS5zZXQoJ2RlYnVnJywgZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIG1ldGhvZE5hbWUsIC4uLm1ldGhvZEFyZ3MpIHt9KTsgLy8gdXNlIGN1c3RvbSBmdW5jdGlvbiB0byBsb2cgY29sbGVjdGlvbiBtZXRob2RzICsgYXJndW1lbnRzXG4gKlxuICogICAgIG1vbmdvb3NlLnNldCh7IGRlYnVnOiB0cnVlLCBhdXRvSW5kZXg6IGZhbHNlIH0pOyAvLyBzZXQgbXVsdGlwbGUgb3B0aW9ucyBhdCBvbmNlXG4gKlxuICogQ3VycmVudGx5IHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqIC0gYGFsbG93RGlza1VzZWA6IFNldCB0byBgdHJ1ZWAgdG8gc2V0IGBhbGxvd0Rpc2tVc2VgIHRvIHRydWUgdG8gYWxsIGFnZ3JlZ2F0aW9uIG9wZXJhdGlvbnMgYnkgZGVmYXVsdC5cbiAqIC0gYGFwcGx5UGx1Z2luc1RvQ2hpbGRTY2hlbWFzYDogYHRydWVgIGJ5IGRlZmF1bHQuIFNldCB0byBmYWxzZSB0byBza2lwIGFwcGx5aW5nIGdsb2JhbCBwbHVnaW5zIHRvIGNoaWxkIHNjaGVtYXNcbiAqIC0gYGFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnNgOiBgZmFsc2VgIGJ5IGRlZmF1bHQuIFNldCB0byB0cnVlIHRvIGFwcGx5IGdsb2JhbCBwbHVnaW5zIHRvIGRpc2NyaW1pbmF0b3Igc2NoZW1hcy4gVGhpcyB0eXBpY2FsbHkgaXNuJ3QgbmVjZXNzYXJ5IGJlY2F1c2UgcGx1Z2lucyBhcmUgYXBwbGllZCB0byB0aGUgYmFzZSBzY2hlbWEgYW5kIGRpc2NyaW1pbmF0b3JzIGNvcHkgYWxsIG1pZGRsZXdhcmUsIG1ldGhvZHMsIHN0YXRpY3MsIGFuZCBwcm9wZXJ0aWVzIGZyb20gdGhlIGJhc2Ugc2NoZW1hLlxuICogLSBgYXV0b0NyZWF0ZWA6IFNldCB0byBgdHJ1ZWAgdG8gbWFrZSBNb25nb29zZSBjYWxsIFtgTW9kZWwuY3JlYXRlQ29sbGVjdGlvbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLmNyZWF0ZUNvbGxlY3Rpb24oKSkgYXV0b21hdGljYWxseSB3aGVuIHlvdSBjcmVhdGUgYSBtb2RlbCB3aXRoIGBtb25nb29zZS5tb2RlbCgpYCBvciBgY29ubi5tb2RlbCgpYC4gVGhpcyBpcyB1c2VmdWwgZm9yIHRlc3RpbmcgdHJhbnNhY3Rpb25zLCBjaGFuZ2Ugc3RyZWFtcywgYW5kIG90aGVyIGZlYXR1cmVzIHRoYXQgcmVxdWlyZSB0aGUgY29sbGVjdGlvbiB0byBleGlzdC5cbiAqIC0gYGF1dG9JbmRleGA6IGB0cnVlYCBieSBkZWZhdWx0LiBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBhdXRvbWF0aWMgaW5kZXggY3JlYXRpb24gZm9yIGFsbCBtb2RlbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgTW9uZ29vc2UgaW5zdGFuY2UuXG4gKiAtIGBidWZmZXJDb21tYW5kc2A6IGVuYWJsZS9kaXNhYmxlIG1vbmdvb3NlJ3MgYnVmZmVyaW5nIG1lY2hhbmlzbSBmb3IgYWxsIGNvbm5lY3Rpb25zIGFuZCBtb2RlbHNcbiAqIC0gYGJ1ZmZlclRpbWVvdXRNU2A6IElmIGJ1ZmZlckNvbW1hbmRzIGlzIG9uLCB0aGlzIG9wdGlvbiBzZXRzIHRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIE1vbmdvb3NlIGJ1ZmZlcmluZyB3aWxsIHdhaXQgYmVmb3JlIHRocm93aW5nIGFuIGVycm9yLiBJZiBub3Qgc3BlY2lmaWVkLCBNb25nb29zZSB3aWxsIHVzZSAxMDAwMCAoMTAgc2Vjb25kcykuXG4gKiAtIGBjbG9uZVNjaGVtYXNgOiBgZmFsc2VgIGJ5IGRlZmF1bHQuIFNldCB0byBgdHJ1ZWAgdG8gYGNsb25lKClgIGFsbCBzY2hlbWFzIGJlZm9yZSBjb21waWxpbmcgaW50byBhIG1vZGVsLlxuICogLSBgZGVidWdgOiBJZiBgdHJ1ZWAsIHByaW50cyB0aGUgb3BlcmF0aW9ucyBtb25nb29zZSBzZW5kcyB0byBNb25nb0RCIHRvIHRoZSBjb25zb2xlLiBJZiBhIHdyaXRhYmxlIHN0cmVhbSBpcyBwYXNzZWQsIGl0IHdpbGwgbG9nIHRvIHRoYXQgc3RyZWFtLCB3aXRob3V0IGNvbG9yaXphdGlvbi4gSWYgYSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwYXNzZWQsIGl0IHdpbGwgcmVjZWl2ZSB0aGUgY29sbGVjdGlvbiBuYW1lLCB0aGUgbWV0aG9kIG5hbWUsIHRoZW4gYWxsIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1ldGhvZC4gRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50ZWQgdG8gcmVwbGljYXRlIHRoZSBkZWZhdWx0IGxvZ2dpbmcsIHlvdSBjb3VsZCBvdXRwdXQgZnJvbSB0aGUgY2FsbGJhY2sgYE1vbmdvb3NlOiAke2NvbGxlY3Rpb25OYW1lfS4ke21ldGhvZE5hbWV9KCR7bWV0aG9kQXJncy5qb2luKCcsICcpfSlgLlxuICogLSBgaWRgOiBJZiBgdHJ1ZWAsIGFkZHMgYSBgaWRgIHZpcnR1YWwgdG8gYWxsIHNjaGVtYXMgdW5sZXNzIG92ZXJ3cml0dGVuIG9uIGEgcGVyLXNjaGVtYSBiYXNpcy5cbiAqIC0gYHRpbWVzdGFtcHMuY3JlYXRlZEF0LmltbXV0YWJsZWA6IGB0cnVlYCBieSBkZWZhdWx0LiBJZiBgZmFsc2VgLCBpdCB3aWxsIGNoYW5nZSB0aGUgYGNyZWF0ZWRBdGAgZmllbGQgdG8gYmUgW2BpbW11dGFibGU6IGZhbHNlYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWF0eXBlLmh0bWwjU2NoZW1hVHlwZS5wcm90b3R5cGUuaW1tdXRhYmxlKSB3aGljaCBtZWFucyB5b3UgY2FuIHVwZGF0ZSB0aGUgYGNyZWF0ZWRBdGBcbiAqIC0gYG1heFRpbWVNU2A6IElmIHNldCwgYXR0YWNoZXMgW21heFRpbWVNU10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL21ldGEvbWF4VGltZU1TLykgdG8gZXZlcnkgcXVlcnlcbiAqIC0gYG9iamVjdElkR2V0dGVyYDogYHRydWVgIGJ5IGRlZmF1bHQuIE1vbmdvb3NlIGFkZHMgYSBnZXR0ZXIgdG8gTW9uZ29EQiBPYmplY3RJZCdzIGNhbGxlZCBgX2lkYCB0aGF0IHJldHVybnMgYHRoaXNgIGZvciBjb252ZW5pZW5jZSB3aXRoIHBvcHVsYXRlLiBTZXQgdGhpcyB0byBmYWxzZSB0byByZW1vdmUgdGhlIGdldHRlci5cbiAqIC0gYG92ZXJ3cml0ZU1vZGVsc2A6IFNldCB0byBgdHJ1ZWAgdG8gZGVmYXVsdCB0byBvdmVyd3JpdGluZyBtb2RlbHMgd2l0aCB0aGUgc2FtZSBuYW1lIHdoZW4gY2FsbGluZyBgbW9uZ29vc2UubW9kZWwoKWAsIGFzIG9wcG9zZWQgdG8gdGhyb3dpbmcgYW4gYE92ZXJ3cml0ZU1vZGVsRXJyb3JgLlxuICogLSBgcmV0dXJuT3JpZ2luYWxgOiBJZiBgZmFsc2VgLCBjaGFuZ2VzIHRoZSBkZWZhdWx0IGByZXR1cm5PcmlnaW5hbGAgb3B0aW9uIHRvIGBmaW5kT25lQW5kVXBkYXRlKClgLCBgZmluZEJ5SWRBbmRVcGRhdGVgLCBhbmQgYGZpbmRPbmVBbmRSZXBsYWNlKClgIHRvIGZhbHNlLiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gc2V0dGluZyB0aGUgYG5ld2Agb3B0aW9uIHRvIGB0cnVlYCBmb3IgYGZpbmRPbmVBbmRYKClgIGNhbGxzIGJ5IGRlZmF1bHQuIFJlYWQgb3VyIFtgZmluZE9uZUFuZFVwZGF0ZSgpYCB0dXRvcmlhbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9maW5kb25lYW5kdXBkYXRlLmh0bWwpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogLSBgcnVuVmFsaWRhdG9yc2A6IGBmYWxzZWAgYnkgZGVmYXVsdC4gU2V0IHRvIHRydWUgdG8gZW5hYmxlIFt1cGRhdGUgdmFsaWRhdG9yc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3ZhbGlkYXRpb24uaHRtbCN1cGRhdGUtdmFsaWRhdG9ycykgZm9yIGFsbCB2YWxpZGF0b3JzIGJ5IGRlZmF1bHQuXG4gKiAtIGBzYW5pdGl6ZUZpbHRlcmA6IGBmYWxzZWAgYnkgZGVmYXVsdC4gU2V0IHRvIHRydWUgdG8gZW5hYmxlIHRoZSBbc2FuaXRpemF0aW9uIG9mIHRoZSBxdWVyeSBmaWx0ZXJzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLnNhbml0aXplRmlsdGVyKCkpIGFnYWluc3QgcXVlcnkgc2VsZWN0b3IgaW5qZWN0aW9uIGF0dGFja3MgYnkgd3JhcHBpbmcgYW55IG5lc3RlZCBvYmplY3RzIHRoYXQgaGF2ZSBhIHByb3BlcnR5IHdob3NlIG5hbWUgc3RhcnRzIHdpdGggYCRgIGluIGEgYCRlcWAuXG4gKiAtIGBzZWxlY3RQb3B1bGF0ZWRQYXRoc2A6IGB0cnVlYCBieSBkZWZhdWx0LiBTZXQgdG8gZmFsc2UgdG8gb3B0IG91dCBvZiBNb25nb29zZSBhZGRpbmcgYWxsIGZpZWxkcyB0aGF0IHlvdSBgcG9wdWxhdGUoKWAgdG8geW91ciBgc2VsZWN0KClgLiBUaGUgc2NoZW1hLWxldmVsIG9wdGlvbiBgc2VsZWN0UG9wdWxhdGVkUGF0aHNgIG92ZXJ3cml0ZXMgdGhpcyBvbmUuXG4gKiAtIGBzdHJpY3RgOiBgdHJ1ZWAgYnkgZGVmYXVsdCwgbWF5IGJlIGBmYWxzZWAsIGB0cnVlYCwgb3IgYCd0aHJvdydgLiBTZXRzIHRoZSBkZWZhdWx0IHN0cmljdCBtb2RlIGZvciBzY2hlbWFzLlxuICogLSBgc3RyaWN0UXVlcnlgOiBgZmFsc2VgIGJ5IGRlZmF1bHQuIE1heSBiZSBgZmFsc2VgLCBgdHJ1ZWAsIG9yIGAndGhyb3cnYC4gU2V0cyB0aGUgZGVmYXVsdCBbc3RyaWN0UXVlcnldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdFF1ZXJ5KSBtb2RlIGZvciBzY2hlbWFzLlxuICogLSBgdG9KU09OYDogYHsgdHJhbnNmb3JtOiB0cnVlLCBmbGF0dGVuRGVjaW1hbHM6IHRydWUgfWAgYnkgZGVmYXVsdC4gT3ZlcndyaXRlcyBkZWZhdWx0IG9iamVjdHMgdG8gW2B0b0pTT04oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudG9KU09OKCkpLCBmb3IgZGV0ZXJtaW5pbmcgaG93IE1vbmdvb3NlIGRvY3VtZW50cyBnZXQgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnkoKWBcbiAqIC0gYHRvT2JqZWN0YDogYHsgdHJhbnNmb3JtOiB0cnVlLCBmbGF0dGVuRGVjaW1hbHM6IHRydWUgfWAgYnkgZGVmYXVsdC4gT3ZlcndyaXRlcyBkZWZhdWx0IG9iamVjdHMgdG8gW2B0b09iamVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS50b09iamVjdCgpKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IFRoZSBuYW1lIG9mIHRoZSBvcHRpb24gb3IgYSBvYmplY3Qgb2YgbXVsdGlwbGUga2V5LXZhbHVlIHBhaXJzXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbnxCb29sZWFufSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbiwgdW51c2VkIGlmIFwia2V5XCIgaXMgYSBvYmplY3RcbiAqIEByZXR1cm5zIHtNb25nb29zZX0gVGhlIHVzZWQgTW9uZ29vc2UgaW5zdG5hY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBrZXkgIT09ICdvYmplY3QnKSB7XG4gICAgaWYgKFZBTElEX09QVElPTlMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU2V0T3B0aW9uRXJyb3IoKTtcbiAgICAgIGVycm9yLmFkZEVycm9yKGtleSwgbmV3IFNldE9wdGlvbkVycm9yLlNldE9wdGlvbklubmVyRXJyb3Ioa2V5KSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gX21vbmdvb3NlLm9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIGxldCBvcHRpb25zID0ge307XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBvcHRpb25zID0geyBba2V5XTogdmFsdWUgfTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IGtleTtcbiAgfVxuXG4gIC8vIGFycmF5IGZvciBlcnJvcnMgdG8gY29sbGVjdCBhbGwgZXJyb3JzIGZvciBhbGwga2V5LXZhbHVlIHBhaXJzLCBsaWtlIFwiLnZhbGlkYXRlXCJcbiAgbGV0IGVycm9yID0gdW5kZWZpbmVkO1xuXG4gIGZvciAoY29uc3QgW29wdGlvbktleSwgb3B0aW9uVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpKSB7XG4gICAgaWYgKFZBTElEX09QVElPTlMuaW5kZXhPZihvcHRpb25LZXkpID09PSAtMSkge1xuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICBlcnJvciA9IG5ldyBTZXRPcHRpb25FcnJvcigpO1xuICAgICAgfVxuICAgICAgZXJyb3IuYWRkRXJyb3Iob3B0aW9uS2V5LCBuZXcgU2V0T3B0aW9uRXJyb3IuU2V0T3B0aW9uSW5uZXJFcnJvcihvcHRpb25LZXkpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIF9tb25nb29zZS5vcHRpb25zW29wdGlvbktleV0gPSBvcHRpb25WYWx1ZTtcblxuICAgIGlmIChvcHRpb25LZXkgPT09ICdvYmplY3RJZEdldHRlcicpIHtcbiAgICAgIGlmIChvcHRpb25WYWx1ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX21vbmdvb3NlLlR5cGVzLk9iamVjdElkLnByb3RvdHlwZSwgJ19pZCcsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgX21vbmdvb3NlLlR5cGVzLk9iamVjdElkLnByb3RvdHlwZS5faWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25LZXkgPT09ICd0cmFuc2FjdGlvbkFzeW5jTG9jYWxTdG9yYWdlJykge1xuICAgICAgaWYgKG9wdGlvblZhbHVlICYmICFfbW9uZ29vc2UudHJhbnNhY3Rpb25Bc3luY0xvY2FsU3RvcmFnZSkge1xuICAgICAgICBfbW9uZ29vc2UudHJhbnNhY3Rpb25Bc3luY0xvY2FsU3RvcmFnZSA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZSgpO1xuICAgICAgfSBlbHNlIGlmICghb3B0aW9uVmFsdWUgJiYgX21vbmdvb3NlLnRyYW5zYWN0aW9uQXN5bmNMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgZGVsZXRlIF9tb25nb29zZS50cmFuc2FjdGlvbkFzeW5jTG9jYWxTdG9yYWdlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIF9tb25nb29zZTtcbn07XG5cbi8qKlxuICogR2V0cyBtb25nb29zZSBvcHRpb25zXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5nZXQoJ3Rlc3QnKSAvLyByZXR1cm5zIHRoZSAndGVzdCcgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAbWV0aG9kIGdldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuZ2V0ID0gTW9uZ29vc2UucHJvdG90eXBlLnNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgQ29ubmVjdGlvbiBpbnN0YW5jZS5cbiAqXG4gKiBFYWNoIGBjb25uZWN0aW9uYCBpbnN0YW5jZSBtYXBzIHRvIGEgc2luZ2xlIGRhdGFiYXNlLiBUaGlzIG1ldGhvZCBpcyBoZWxwZnVsIHdoZW4gbWFuYWdpbmcgbXVsdGlwbGUgZGIgY29ubmVjdGlvbnMuXG4gKlxuICpcbiAqIF9PcHRpb25zIHBhc3NlZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBvcHRpb25zIGluY2x1ZGVkIGluIGNvbm5lY3Rpb24gc3RyaW5ncy5fXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyB3aXRoIG1vbmdvZGI6Ly8gVVJJXG4gKiAgICAgZGIgPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vdXNlcjpwYXNzQDEyNy4wLjAuMTpwb3J0L2RhdGFiYXNlJyk7XG4gKlxuICogICAgIC8vIGFuZCBvcHRpb25zXG4gKiAgICAgY29uc3Qgb3B0cyA9IHsgZGI6IHsgbmF0aXZlX3BhcnNlcjogdHJ1ZSB9fVxuICogICAgIGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovL3VzZXI6cGFzc0AxMjcuMC4wLjE6cG9ydC9kYXRhYmFzZScsIG9wdHMpO1xuICpcbiAqICAgICAvLyByZXBsaWNhIHNldHNcbiAqICAgICBkYiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly91c2VyOnBhc3NAMTI3LjAuMC4xOnBvcnQsYW5vdGhlcmhvc3Q6cG9ydCx5ZXRhbm90aGVyOnBvcnQvZGF0YWJhc2UnKTtcbiAqXG4gKiAgICAgLy8gYW5kIG9wdGlvbnNcbiAqICAgICBjb25zdCBvcHRzID0geyByZXBsc2V0OiB7IHN0cmF0ZWd5OiAncGluZycsIHJzX25hbWU6ICd0ZXN0U2V0JyB9fVxuICogICAgIGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovL3VzZXI6cGFzc0AxMjcuMC4wLjE6cG9ydCxhbm90aGVyaG9zdDpwb3J0LHlldGFub3RoZXI6cG9ydC9kYXRhYmFzZScsIG9wdHMpO1xuICpcbiAqICAgICAvLyBpbml0aWFsaXplIG5vdywgY29ubmVjdCBsYXRlclxuICogICAgIGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpO1xuICogICAgIGF3YWl0IGRiLm9wZW5VcmkoJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvZGF0YWJhc2UnKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpIG1vbmdvZGIgVVJJIHRvIGNvbm5lY3QgdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gcGFzc2VkIGRvd24gdG8gdGhlIFtNb25nb0RCIGRyaXZlcidzIGBjb25uZWN0KClgIGZ1bmN0aW9uXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9uZ29DbGllbnRPcHRpb25zLmh0bWwpLCBleGNlcHQgZm9yIDQgbW9uZ29vc2Utc3BlY2lmaWMgb3B0aW9ucyBleHBsYWluZWQgYmVsb3cuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJ1ZmZlckNvbW1hbmRzPXRydWVdIE1vbmdvb3NlIHNwZWNpZmljIG9wdGlvbi4gU2V0IHRvIGZhbHNlIHRvIFtkaXNhYmxlIGJ1ZmZlcmluZ10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2ZhcS5odG1sI2NhbGxiYWNrX25ldmVyX2V4ZWN1dGVzKSBvbiBhbGwgbW9kZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGJOYW1lXSBUaGUgbmFtZSBvZiB0aGUgZGF0YWJhc2UgeW91IHdhbnQgdG8gdXNlLiBJZiBub3QgcHJvdmlkZWQsIE1vbmdvb3NlIHVzZXMgdGhlIGRhdGFiYXNlIG5hbWUgZnJvbSBjb25uZWN0aW9uIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy51c2VyXSB1c2VybmFtZSBmb3IgYXV0aGVudGljYXRpb24sIGVxdWl2YWxlbnQgdG8gYG9wdGlvbnMuYXV0aC51c2VyYC4gTWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFzc10gcGFzc3dvcmQgZm9yIGF1dGhlbnRpY2F0aW9uLCBlcXVpdmFsZW50IHRvIGBvcHRpb25zLmF1dGgucGFzc3dvcmRgLiBNYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0luZGV4PXRydWVdIE1vbmdvb3NlLXNwZWNpZmljIG9wdGlvbi4gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgYXV0b21hdGljIGluZGV4IGNyZWF0aW9uIGZvciBhbGwgbW9kZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge0NsYXNzfSBbb3B0aW9ucy5wcm9taXNlTGlicmFyeV0gU2V0cyB0aGUgW3VuZGVybHlpbmcgZHJpdmVyJ3MgcHJvbWlzZSBsaWJyYXJ5XShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9uZ29DbGllbnRPcHRpb25zLmh0bWwjcHJvbWlzZUxpYnJhcnkpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBvb2xTaXplPTVdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzb2NrZXRzIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIGtlZXAgb3BlbiBmb3IgdGhpcyBjb25uZWN0aW9uLiBLZWVwIGluIG1pbmQgdGhhdCBNb25nb0RCIG9ubHkgYWxsb3dzIG9uZSBvcGVyYXRpb24gcGVyIHNvY2tldCBhdCBhIHRpbWUsIHNvIHlvdSBtYXkgd2FudCB0byBpbmNyZWFzZSB0aGlzIGlmIHlvdSBmaW5kIHlvdSBoYXZlIGEgZmV3IHNsb3cgcXVlcmllcyB0aGF0IGFyZSBibG9ja2luZyBmYXN0ZXIgcXVlcmllcyBmcm9tIHByb2NlZWRpbmcuIFNlZSBbU2xvdyBUcmFpbnMgaW4gTW9uZ29EQiBhbmQgTm9kZS5qc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9zbG93LXRyYWlucy1pbi1tb25nb2RiLWFuZC1ub2RlanMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblBvb2xTaXplPTFdIFRoZSBtaW5pbXVtIG51bWJlciBvZiBzb2NrZXRzIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIGtlZXAgb3BlbiBmb3IgdGhpcyBjb25uZWN0aW9uLiBLZWVwIGluIG1pbmQgdGhhdCBNb25nb0RCIG9ubHkgYWxsb3dzIG9uZSBvcGVyYXRpb24gcGVyIHNvY2tldCBhdCBhIHRpbWUsIHNvIHlvdSBtYXkgd2FudCB0byBpbmNyZWFzZSB0aGlzIGlmIHlvdSBmaW5kIHlvdSBoYXZlIGEgZmV3IHNsb3cgcXVlcmllcyB0aGF0IGFyZSBibG9ja2luZyBmYXN0ZXIgcXVlcmllcyBmcm9tIHByb2NlZWRpbmcuIFNlZSBbU2xvdyBUcmFpbnMgaW4gTW9uZ29EQiBhbmQgTm9kZS5qc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9zbG93LXRyYWlucy1pbi1tb25nb2RiLWFuZC1ub2RlanMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNvY2tldFRpbWVvdXRNUz0wXSBIb3cgbG9uZyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCB3YWl0IGJlZm9yZSBraWxsaW5nIGEgc29ja2V0IGR1ZSB0byBpbmFjdGl2aXR5IF9hZnRlciBpbml0aWFsIGNvbm5lY3Rpb25fLiBEZWZhdWx0cyB0byAwLCB3aGljaCBtZWFucyBOb2RlLmpzIHdpbGwgbm90IHRpbWUgb3V0IHRoZSBzb2NrZXQgZHVlIHRvIGluYWN0aXZpdHkuIEEgc29ja2V0IG1heSBiZSBpbmFjdGl2ZSBiZWNhdXNlIG9mIGVpdGhlciBubyBhY3Rpdml0eSBvciBhIGxvbmctcnVubmluZyBvcGVyYXRpb24uIFRoaXMgb3B0aW9uIGlzIHBhc3NlZCB0byBbTm9kZS5qcyBgc29ja2V0I3NldFRpbWVvdXQoKWAgZnVuY3Rpb25dKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9zZXR0aW1lb3V0X3RpbWVvdXRfY2FsbGJhY2spIGFmdGVyIHRoZSBNb25nb0RCIGRyaXZlciBzdWNjZXNzZnVsbHkgY29tcGxldGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZhbWlseT0wXSBQYXNzZWQgdHJhbnNwYXJlbnRseSB0byBbTm9kZS5qcycgYGRucy5sb29rdXAoKWBdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZG5zLmh0bWwjZG5zX2Ruc19sb29rdXBfaG9zdG5hbWVfb3B0aW9uc19jYWxsYmFjaykgZnVuY3Rpb24uIE1heSBiZSBlaXRoZXIgYDBgLCBgNGAsIG9yIGA2YC4gYDRgIG1lYW5zIHVzZSBJUHY0IG9ubHksIGA2YCBtZWFucyB1c2UgSVB2NiBvbmx5LCBgMGAgbWVhbnMgdHJ5IGJvdGguXG4gKiBAcmV0dXJuIHtDb25uZWN0aW9ufSB0aGUgY3JlYXRlZCBDb25uZWN0aW9uIG9iamVjdC4gQ29ubmVjdGlvbnMgYXJlIG5vdCB0aGVuYWJsZSwgc28geW91IGNhbid0IGRvIGBhd2FpdCBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKClgLiBUbyBhd2FpdCB1c2UgYG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24odXJpKS5hc1Byb21pc2UoKWAgaW5zdGVhZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbih1cmksIG9wdGlvbnMpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGNvbnN0IENvbm5lY3Rpb24gPSBfbW9uZ29vc2UuX19kcml2ZXIuQ29ubmVjdGlvbjtcbiAgY29uc3QgY29ubiA9IG5ldyBDb25uZWN0aW9uKF9tb25nb29zZSk7XG4gIF9tb25nb29zZS5jb25uZWN0aW9ucy5wdXNoKGNvbm4pO1xuICBfbW9uZ29vc2UubmV4dENvbm5lY3Rpb25JZCsrO1xuICBfbW9uZ29vc2UuZXZlbnRzLmVtaXQoJ2NyZWF0ZUNvbm5lY3Rpb24nLCBjb25uKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBjb25uLm9wZW5VcmkodXJpLCB7IC4uLm9wdGlvbnMsIF9maXJlQW5kRm9yZ2V0OiB0cnVlIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNvbm47XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSBkZWZhdWx0IG1vbmdvb3NlIGNvbm5lY3Rpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5jb25uZWN0KCdtb25nb2RiOi8vdXNlcjpwYXNzQDEyNy4wLjAuMTpwb3J0L2RhdGFiYXNlJyk7XG4gKlxuICogICAgIC8vIHJlcGxpY2Egc2V0c1xuICogICAgIGNvbnN0IHVyaSA9ICdtb25nb2RiOi8vdXNlcjpwYXNzQDEyNy4wLjAuMTpwb3J0LGFub3RoZXJob3N0OnBvcnQseWV0YW5vdGhlcjpwb3J0L215ZGF0YWJhc2UnO1xuICogICAgIG1vbmdvb3NlLmNvbm5lY3QodXJpKTtcbiAqXG4gKiAgICAgLy8gd2l0aCBvcHRpb25zXG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdCh1cmksIG9wdGlvbnMpO1xuICpcbiAqICAgICAvLyBVc2luZyBgYXdhaXRgIHRocm93cyBcIk1vbmdvb3NlU2VydmVyU2VsZWN0aW9uRXJyb3I6IFNlcnZlciBzZWxlY3Rpb24gdGltZWQgb3V0IGFmdGVyIDMwMDAwIG1zXCJcbiAqICAgICAvLyBpZiBNb25nb29zZSBjYW4ndCBjb25uZWN0LlxuICogICAgIGNvbnN0IHVyaSA9ICdtb25nb2RiOi8vbm9uZXhpc3RlbnQuZG9tYWluOjI3MDAwJztcbiAqICAgICBhd2FpdCBtb25nb29zZS5jb25uZWN0KHVyaSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaSBtb25nb2RiIFVSSSB0byBjb25uZWN0IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHBhc3NlZCBkb3duIHRvIHRoZSBbTW9uZ29EQiBkcml2ZXIncyBgY29ubmVjdCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vbmdvQ2xpZW50T3B0aW9ucy5odG1sKSwgZXhjZXB0IGZvciA0IG1vbmdvb3NlLXNwZWNpZmljIG9wdGlvbnMgZXhwbGFpbmVkIGJlbG93LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5idWZmZXJDb21tYW5kcz10cnVlXSBNb25nb29zZSBzcGVjaWZpYyBvcHRpb24uIFNldCB0byBmYWxzZSB0byBbZGlzYWJsZSBidWZmZXJpbmddKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9mYXEuaHRtbCNjYWxsYmFja19uZXZlcl9leGVjdXRlcykgb24gYWxsIG1vZGVscyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25uZWN0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1ZmZlclRpbWVvdXRNUz0xMDAwMF0gTW9uZ29vc2Ugc3BlY2lmaWMgb3B0aW9uLiBJZiBgYnVmZmVyQ29tbWFuZHNgIGlzIHRydWUsIE1vbmdvb3NlIHdpbGwgdGhyb3cgYW4gZXJyb3IgYWZ0ZXIgYGJ1ZmZlclRpbWVvdXRNU2AgaWYgdGhlIG9wZXJhdGlvbiBpcyBzdGlsbCBidWZmZXJlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5kYk5hbWVdIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZSB3ZSB3YW50IHRvIHVzZS4gSWYgbm90IHByb3ZpZGVkLCB1c2UgZGF0YWJhc2UgbmFtZSBmcm9tIGNvbm5lY3Rpb24gc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnVzZXJdIHVzZXJuYW1lIGZvciBhdXRoZW50aWNhdGlvbiwgZXF1aXZhbGVudCB0byBgb3B0aW9ucy5hdXRoLnVzZXJgLiBNYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXNzXSBwYXNzd29yZCBmb3IgYXV0aGVudGljYXRpb24sIGVxdWl2YWxlbnQgdG8gYG9wdGlvbnMuYXV0aC5wYXNzd29yZGAuIE1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBvb2xTaXplPTEwMF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNvY2tldHMgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwga2VlcCBvcGVuIGZvciB0aGlzIGNvbm5lY3Rpb24uIEtlZXAgaW4gbWluZCB0aGF0IE1vbmdvREIgb25seSBhbGxvd3Mgb25lIG9wZXJhdGlvbiBwZXIgc29ja2V0IGF0IGEgdGltZSwgc28geW91IG1heSB3YW50IHRvIGluY3JlYXNlIHRoaXMgaWYgeW91IGZpbmQgeW91IGhhdmUgYSBmZXcgc2xvdyBxdWVyaWVzIHRoYXQgYXJlIGJsb2NraW5nIGZhc3RlciBxdWVyaWVzIGZyb20gcHJvY2VlZGluZy4gU2VlIFtTbG93IFRyYWlucyBpbiBNb25nb0RCIGFuZCBOb2RlLmpzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3Nsb3ctdHJhaW5zLWluLW1vbmdvZGItYW5kLW5vZGVqcykuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluUG9vbFNpemU9MF0gVGhlIG1pbmltdW0gbnVtYmVyIG9mIHNvY2tldHMgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwga2VlcCBvcGVuIGZvciB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2VydmVyU2VsZWN0aW9uVGltZW91dE1TXSBJZiBgdXNlVW5pZmllZFRvcG9sb2d5ID0gdHJ1ZWAsIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIHRyeSB0byBmaW5kIGEgc2VydmVyIHRvIHNlbmQgYW55IGdpdmVuIG9wZXJhdGlvbiB0bywgYW5kIGtlZXAgcmV0cnlpbmcgZm9yIGBzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVNgIG1pbGxpc2Vjb25kcyBiZWZvcmUgZXJyb3Jpbmcgb3V0LiBJZiBub3Qgc2V0LCB0aGUgTW9uZ29EQiBkcml2ZXIgZGVmYXVsdHMgdG8gdXNpbmcgYDMwMDAwYCAoMzAgc2Vjb25kcykuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVhcnRiZWF0RnJlcXVlbmN5TVNdIElmIGB1c2VVbmlmaWVkVG9wb2xvZ3kgPSB0cnVlYCwgdGhlIE1vbmdvREIgZHJpdmVyIHNlbmRzIGEgaGVhcnRiZWF0IGV2ZXJ5IGBoZWFydGJlYXRGcmVxdWVuY3lNU2AgdG8gY2hlY2sgb24gdGhlIHN0YXR1cyBvZiB0aGUgY29ubmVjdGlvbi4gQSBoZWFydGJlYXQgaXMgc3ViamVjdCB0byBgc2VydmVyU2VsZWN0aW9uVGltZW91dE1TYCwgc28gdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwgcmV0cnkgZmFpbGVkIGhlYXJ0YmVhdHMgZm9yIHVwIHRvIDMwIHNlY29uZHMgYnkgZGVmYXVsdC4gTW9uZ29vc2Ugb25seSBlbWl0cyBhIGAnZGlzY29ubmVjdGVkJ2AgZXZlbnQgYWZ0ZXIgYSBoZWFydGJlYXQgaGFzIGZhaWxlZCwgc28geW91IG1heSB3YW50IHRvIGRlY3JlYXNlIHRoaXMgc2V0dGluZyB0byByZWR1Y2UgdGhlIHRpbWUgYmV0d2VlbiB3aGVuIHlvdXIgc2VydmVyIGdvZXMgZG93biBhbmQgd2hlbiBNb25nb29zZSBlbWl0cyBgJ2Rpc2Nvbm5lY3RlZCdgLiBXZSByZWNvbW1lbmQgeW91IGRvICoqbm90Kiogc2V0IHRoaXMgc2V0dGluZyBiZWxvdyAxMDAwLCB0b28gbWFueSBoZWFydGJlYXRzIGNhbiBsZWFkIHRvIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvSW5kZXg9dHJ1ZV0gTW9uZ29vc2Utc3BlY2lmaWMgb3B0aW9uLiBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBhdXRvbWF0aWMgaW5kZXggY3JlYXRpb24gZm9yIGFsbCBtb2RlbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7Q2xhc3N9IFtvcHRpb25zLnByb21pc2VMaWJyYXJ5XSBTZXRzIHRoZSBbdW5kZXJseWluZyBkcml2ZXIncyBwcm9taXNlIGxpYnJhcnldKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb25nb0NsaWVudE9wdGlvbnMuaHRtbCNwcm9taXNlTGlicmFyeSkuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc29ja2V0VGltZW91dE1TPTBdIEhvdyBsb25nIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIHdhaXQgYmVmb3JlIGtpbGxpbmcgYSBzb2NrZXQgZHVlIHRvIGluYWN0aXZpdHkgX2FmdGVyIGluaXRpYWwgY29ubmVjdGlvbl8uIEEgc29ja2V0IG1heSBiZSBpbmFjdGl2ZSBiZWNhdXNlIG9mIGVpdGhlciBubyBhY3Rpdml0eSBvciBhIGxvbmctcnVubmluZyBvcGVyYXRpb24uIGBzb2NrZXRUaW1lb3V0TVNgIGRlZmF1bHRzIHRvIDAsIHdoaWNoIG1lYW5zIE5vZGUuanMgd2lsbCBub3QgdGltZSBvdXQgdGhlIHNvY2tldCBkdWUgdG8gaW5hY3Rpdml0eS4gVGhpcyBvcHRpb24gaXMgcGFzc2VkIHRvIFtOb2RlLmpzIGBzb2NrZXQjc2V0VGltZW91dCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X3NldHRpbWVvdXRfdGltZW91dF9jYWxsYmFjaykgYWZ0ZXIgdGhlIE1vbmdvREIgZHJpdmVyIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmFtaWx5PTBdIFBhc3NlZCB0cmFuc3BhcmVudGx5IHRvIFtOb2RlLmpzJyBgZG5zLmxvb2t1cCgpYF0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9kbnMuaHRtbCNkbnNfZG5zX2xvb2t1cF9ob3N0bmFtZV9vcHRpb25zX2NhbGxiYWNrKSBmdW5jdGlvbi4gTWF5IGJlIGVpdGhlciBgMGAsIGA0YCwgb3IgYDZgLiBgNGAgbWVhbnMgdXNlIElQdjQgb25seSwgYDZgIG1lYW5zIHVzZSBJUHY2IG9ubHksIGAwYCBtZWFucyB0cnkgYm90aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0NyZWF0ZT1mYWxzZV0gU2V0IHRvIGB0cnVlYCB0byBtYWtlIE1vbmdvb3NlIGF1dG9tYXRpY2FsbHkgY2FsbCBgY3JlYXRlQ29sbGVjdGlvbigpYCBvbiBldmVyeSBtb2RlbCBjcmVhdGVkIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAqIEBzZWUgTW9uZ29vc2UjY3JlYXRlQ29ubmVjdGlvbiBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24oKVxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge1Byb21pc2V9IHJlc29sdmVzIHRvIGB0aGlzYCBpZiBjb25uZWN0aW9uIHN1Y2NlZWRlZFxuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5jb25uZWN0ID0gYXN5bmMgZnVuY3Rpb24gY29ubmVjdCh1cmksIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IChhcmd1bWVudHMubGVuZ3RoID49IDMgJiYgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9uZ29vc2UucHJvdG90eXBlLmNvbm5lY3QoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG4gIGNvbnN0IGNvbm4gPSBfbW9uZ29vc2UuY29ubmVjdGlvbjtcblxuICByZXR1cm4gY29ubi5vcGVuVXJpKHVyaSwgb3B0aW9ucykudGhlbigoKSA9PiBfbW9uZ29vc2UpO1xufTtcblxuLyoqXG4gKiBSdW5zIGAuY2xvc2UoKWAgb24gYWxsIGNvbm5lY3Rpb25zIGluIHBhcmFsbGVsLlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2V9IHJlc29sdmVzIHdoZW4gYWxsIGNvbm5lY3Rpb25zIGFyZSBjbG9zZWQsIG9yIHJlamVjdHMgd2l0aCB0aGUgZmlyc3QgZXJyb3IgdGhhdCBvY2N1cnJlZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBhc3luYyBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9uZ29vc2UucHJvdG90eXBlLmRpc2Nvbm5lY3QoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgY29uc3QgcmVtYWluaW5nID0gX21vbmdvb3NlLmNvbm5lY3Rpb25zLmxlbmd0aDtcbiAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGF3YWl0IFByb21pc2UuYWxsKF9tb25nb29zZS5jb25uZWN0aW9ucy5tYXAoY29ubiA9PiBjb25uLmNsb3NlKCkpKTtcbn07XG5cbi8qKlxuICogX1JlcXVpcmVzIE1vbmdvREIgPj0gMy42LjAuXyBTdGFydHMgYSBbTW9uZ29EQiBzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWxlYXNlLW5vdGVzLzMuNi8jY2xpZW50LXNlc3Npb25zKVxuICogZm9yIGJlbmVmaXRzIGxpa2UgY2F1c2FsIGNvbnNpc3RlbmN5LCBbcmV0cnlhYmxlIHdyaXRlc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9yZXRyeWFibGUtd3JpdGVzLyksXG4gKiBhbmQgW3RyYW5zYWN0aW9uc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGUtanMtcGVyc3BlY3RpdmUtb24tbW9uZ29kYi00LXRyYW5zYWN0aW9ucy5odG1sKS5cbiAqXG4gKiBDYWxsaW5nIGBtb25nb29zZS5zdGFydFNlc3Npb24oKWAgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIGBtb25nb29zZS5jb25uZWN0aW9uLnN0YXJ0U2Vzc2lvbigpYC5cbiAqIFNlc3Npb25zIGFyZSBzY29wZWQgdG8gYSBjb25uZWN0aW9uLCBzbyBjYWxsaW5nIGBtb25nb29zZS5zdGFydFNlc3Npb24oKWBcbiAqIHN0YXJ0cyBhIHNlc3Npb24gb24gdGhlIFtkZWZhdWx0IG1vbmdvb3NlIGNvbm5lY3Rpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuY29ubmVjdGlvbikuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgdGhlIFttb25nb2RiIGRyaXZlciBvcHRpb25zXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvTW9uZ29DbGllbnQuaHRtbCNzdGFydFNlc3Npb24pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNhdXNhbENvbnNpc3RlbmN5PXRydWVdIHNldCB0byBmYWxzZSB0byBkaXNhYmxlIGNhdXNhbCBjb25zaXN0ZW5jeVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICogQHJldHVybiB7UHJvbWlzZTxDbGllbnRTZXNzaW9uPn0gcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgTW9uZ29EQiBkcml2ZXIgYENsaWVudFNlc3Npb25gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5zdGFydFNlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIHJldHVybiBfbW9uZ29vc2UuY29ubmVjdGlvbi5zdGFydFNlc3Npb24uYXBwbHkoX21vbmdvb3NlLmNvbm5lY3Rpb24sIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIEdldHRlci9zZXR0ZXIgYXJvdW5kIGZ1bmN0aW9uIGZvciBwbHVyYWxpemluZyBjb2xsZWN0aW9uIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258bnVsbH0gW2ZuXSBvdmVyd3JpdGVzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIHBsdXJhbGl6ZSBjb2xsZWN0aW9uIG5hbWVzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfSB0aGUgY3VycmVudCBmdW5jdGlvbiB1c2VkIHRvIHBsdXJhbGl6ZSBjb2xsZWN0aW9uIG5hbWVzLCBkZWZhdWx0cyB0byB0aGUgbGVnYWN5IGZ1bmN0aW9uIGZyb20gYG1vbmdvb3NlLWxlZ2FjeS1wbHVyYWxpemVgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUucGx1cmFsaXplID0gZnVuY3Rpb24oZm4pIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIF9tb25nb29zZS5fcGx1cmFsaXplID0gZm47XG4gIH1cbiAgcmV0dXJuIF9tb25nb29zZS5fcGx1cmFsaXplO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGEgbW9kZWwgb3IgcmV0cmlldmVzIGl0LlxuICpcbiAqIE1vZGVscyBkZWZpbmVkIG9uIHRoZSBgbW9uZ29vc2VgIGluc3RhbmNlIGFyZSBhdmFpbGFibGUgdG8gYWxsIGNvbm5lY3Rpb25cbiAqIGNyZWF0ZWQgYnkgdGhlIHNhbWUgYG1vbmdvb3NlYCBpbnN0YW5jZS5cbiAqXG4gKiBJZiB5b3UgY2FsbCBgbW9uZ29vc2UubW9kZWwoKWAgd2l0aCB0d2ljZSB0aGUgc2FtZSBuYW1lIGJ1dCBhIGRpZmZlcmVudCBzY2hlbWEsXG4gKiB5b3Ugd2lsbCBnZXQgYW4gYE92ZXJ3cml0ZU1vZGVsRXJyb3JgLiBJZiB5b3UgY2FsbCBgbW9uZ29vc2UubW9kZWwoKWAgd2l0aFxuICogdGhlIHNhbWUgbmFtZSBhbmQgc2FtZSBzY2hlbWEsIHlvdSdsbCBnZXQgdGhlIHNhbWUgc2NoZW1hIGJhY2suXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKlxuICogICAgIC8vIGRlZmluZSBhbiBBY3RvciBtb2RlbCB3aXRoIHRoaXMgbW9uZ29vc2UgaW5zdGFuY2VcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIG1vbmdvb3NlLm1vZGVsKCdBY3RvcicsIHNjaGVtYSk7XG4gKlxuICogICAgIC8vIGNyZWF0ZSBhIG5ldyBjb25uZWN0aW9uXG4gKiAgICAgY29uc3QgY29ubiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oLi4pO1xuICpcbiAqICAgICAvLyBjcmVhdGUgQWN0b3IgbW9kZWxcbiAqICAgICBjb25zdCBBY3RvciA9IGNvbm4ubW9kZWwoJ0FjdG9yJywgc2NoZW1hKTtcbiAqICAgICBjb25uLm1vZGVsKCdBY3RvcicpID09PSBBY3RvcjsgLy8gdHJ1ZVxuICogICAgIGNvbm4ubW9kZWwoJ0FjdG9yJywgc2NoZW1hKSA9PT0gQWN0b3I7IC8vIHRydWUsIHNhbWUgc2NoZW1hXG4gKiAgICAgY29ubi5tb2RlbCgnQWN0b3InLCBzY2hlbWEsICdhY3RvcnMnKSA9PT0gQWN0b3I7IC8vIHRydWUsIHNhbWUgc2NoZW1hIGFuZCBjb2xsZWN0aW9uIG5hbWVcbiAqXG4gKiAgICAgLy8gVGhpcyB0aHJvd3MgYW4gYE92ZXJ3cml0ZU1vZGVsRXJyb3JgIGJlY2F1c2UgdGhlIHNjaGVtYSBpcyBkaWZmZXJlbnQuXG4gKiAgICAgY29ubi5tb2RlbCgnQWN0b3InLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqXG4gKiBfV2hlbiBubyBgY29sbGVjdGlvbmAgYXJndW1lbnQgaXMgcGFzc2VkLCBNb25nb29zZSB1c2VzIHRoZSBtb2RlbCBuYW1lLiBJZiB5b3UgZG9uJ3QgbGlrZSB0aGlzIGJlaGF2aW9yLCBlaXRoZXIgcGFzcyBhIGNvbGxlY3Rpb24gbmFtZSwgdXNlIGBtb25nb29zZS5wbHVyYWxpemUoKWAsIG9yIHNldCB5b3VyIHNjaGVtYXMgY29sbGVjdGlvbiBuYW1lIG9wdGlvbi5fXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgY29sbGVjdGlvbjogJ2FjdG9yJyB9KTtcbiAqXG4gKiAgICAgLy8gb3JcbiAqXG4gKiAgICAgc2NoZW1hLnNldCgnY29sbGVjdGlvbicsICdhY3RvcicpO1xuICpcbiAqICAgICAvLyBvclxuICpcbiAqICAgICBjb25zdCBjb2xsZWN0aW9uTmFtZSA9ICdhY3Rvcic7XG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKCdBY3RvcicsIHNjaGVtYSwgY29sbGVjdGlvbk5hbWUpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBuYW1lIG1vZGVsIG5hbWUgb3IgY2xhc3MgZXh0ZW5kaW5nIE1vZGVsXG4gKiBAcGFyYW0ge1NjaGVtYX0gW3NjaGVtYV0gdGhlIHNjaGVtYSB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NvbGxlY3Rpb25dIG5hbWUgKG9wdGlvbmFsLCBpbmZlcnJlZCBmcm9tIG1vZGVsIG5hbWUpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm92ZXJ3cml0ZU1vZGVscz1mYWxzZV0gSWYgdHJ1ZSwgb3ZlcndyaXRlIGV4aXN0aW5nIG1vZGVscyB3aXRoIHRoZSBzYW1lIG5hbWUgdG8gYXZvaWQgYE92ZXJ3cml0ZU1vZGVsRXJyb3JgXG4gKiBAcmV0dXJuIHtNb2RlbH0gVGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCBgbmFtZWAuIE1vbmdvb3NlIHdpbGwgY3JlYXRlIHRoZSBtb2RlbCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3QuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5tb2RlbCA9IGZ1bmN0aW9uKG5hbWUsIHNjaGVtYSwgY29sbGVjdGlvbiwgb3B0aW9ucykge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT09ICdzdHJpbmcnKSB7XG4gICAgY29sbGVjdGlvbiA9IHNjaGVtYTtcbiAgICBzY2hlbWEgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgbW9kZWwgPSBfbW9uZ29vc2UubW9kZWxzW25hbWVdO1xuICAgIGlmICghbW9kZWwpIHtcbiAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yLk1pc3NpbmdTY2hlbWFFcnJvcihuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KHNjaGVtYSkgJiYgIShzY2hlbWEgaW5zdGFuY2VvZiBTY2hlbWEpKSB7XG4gICAgc2NoZW1hID0gbmV3IFNjaGVtYShzY2hlbWEpO1xuICB9XG4gIGlmIChzY2hlbWEgJiYgIShzY2hlbWEgaW5zdGFuY2VvZiBTY2hlbWEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgMm5kIHBhcmFtZXRlciB0byBgbW9uZ29vc2UubW9kZWwoKWAgc2hvdWxkIGJlIGEgJyArXG4gICAgICAnc2NoZW1hIG9yIGEgUE9KTycpO1xuICB9XG5cbiAgLy8gaGFuZGxlIGludGVybmFsIG9wdGlvbnMgZnJvbSBjb25uZWN0aW9uLm1vZGVsKClcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3Qgb3JpZ2luYWxTY2hlbWEgPSBzY2hlbWE7XG4gIGlmIChzY2hlbWEpIHtcbiAgICBpZiAoX21vbmdvb3NlLmdldCgnY2xvbmVTY2hlbWFzJykpIHtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5jbG9uZSgpO1xuICAgIH1cbiAgICBfbW9uZ29vc2UuX2FwcGx5UGx1Z2lucyhzY2hlbWEpO1xuICB9XG5cbiAgLy8gY29ubmVjdGlvbi5tb2RlbCgpIG1heSBiZSBwYXNzaW5nIGEgZGlmZmVyZW50IHNjaGVtYSBmb3JcbiAgLy8gYW4gZXhpc3RpbmcgbW9kZWwgbmFtZS4gaW4gdGhpcyBjYXNlIGRvbid0IHJlYWQgZnJvbSBjYWNoZS5cbiAgY29uc3Qgb3ZlcndyaXRlTW9kZWxzID0gX21vbmdvb3NlLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ292ZXJ3cml0ZU1vZGVscycpID9cbiAgICBfbW9uZ29vc2Uub3B0aW9ucy5vdmVyd3JpdGVNb2RlbHMgOlxuICAgIG9wdGlvbnMub3ZlcndyaXRlTW9kZWxzO1xuICBpZiAoX21vbmdvb3NlLm1vZGVscy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBvcHRpb25zLmNhY2hlICE9PSBmYWxzZSAmJiBvdmVyd3JpdGVNb2RlbHMgIT09IHRydWUpIHtcbiAgICBpZiAob3JpZ2luYWxTY2hlbWEgJiZcbiAgICAgICAgb3JpZ2luYWxTY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSAmJlxuICAgICAgICBvcmlnaW5hbFNjaGVtYSAhPT0gX21vbmdvb3NlLm1vZGVsc1tuYW1lXS5zY2hlbWEpIHtcbiAgICAgIHRocm93IG5ldyBfbW9uZ29vc2UuRXJyb3IuT3ZlcndyaXRlTW9kZWxFcnJvcihuYW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbiAhPT0gX21vbmdvb3NlLm1vZGVsc1tuYW1lXS5jb2xsZWN0aW9uLm5hbWUpIHtcbiAgICAgIC8vIHN1YmNsYXNzIGN1cnJlbnQgbW9kZWwgd2l0aCBhbHRlcm5hdGUgY29sbGVjdGlvblxuICAgICAgY29uc3QgbW9kZWwgPSBfbW9uZ29vc2UubW9kZWxzW25hbWVdO1xuICAgICAgc2NoZW1hID0gbW9kZWwucHJvdG90eXBlLnNjaGVtYTtcbiAgICAgIGNvbnN0IHN1YiA9IG1vZGVsLl9fc3ViY2xhc3MoX21vbmdvb3NlLmNvbm5lY3Rpb24sIHNjaGVtYSwgY29sbGVjdGlvbik7XG4gICAgICAvLyBkbyBub3QgY2FjaGUgdGhlIHN1YiBtb2RlbFxuICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgcmV0dXJuIF9tb25nb29zZS5tb2RlbHNbbmFtZV07XG4gIH1cbiAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IF9tb25nb29zZS5FcnJvci5NaXNzaW5nU2NoZW1hRXJyb3IobmFtZSk7XG4gIH1cblxuICBjb25zdCBtb2RlbCA9IF9tb25nb29zZS5fbW9kZWwobmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uLCBvcHRpb25zKTtcbiAgX21vbmdvb3NlLmNvbm5lY3Rpb24ubW9kZWxzW25hbWVdID0gbW9kZWw7XG4gIF9tb25nb29zZS5tb2RlbHNbbmFtZV0gPSBtb2RlbDtcblxuICByZXR1cm4gbW9kZWw7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5fbW9kZWwgPSBmdW5jdGlvbihuYW1lLCBzY2hlbWEsIGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGxldCBtb2RlbDtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbW9kZWwgPSBuYW1lO1xuICAgIG5hbWUgPSBtb2RlbC5uYW1lO1xuICAgIGlmICghKG1vZGVsLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSkge1xuICAgICAgdGhyb3cgbmV3IF9tb25nb29zZS5FcnJvcignVGhlIHByb3ZpZGVkIGNsYXNzICcgKyBuYW1lICsgJyBtdXN0IGV4dGVuZCBNb2RlbCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzY2hlbWEpIHtcbiAgICBpZiAoX21vbmdvb3NlLmdldCgnY2xvbmVTY2hlbWFzJykpIHtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5jbG9uZSgpO1xuICAgIH1cbiAgICBfbW9uZ29vc2UuX2FwcGx5UGx1Z2lucyhzY2hlbWEpO1xuICB9XG5cbiAgLy8gQXBwbHkgcmVsZXZhbnQgXCJnbG9iYWxcIiBvcHRpb25zIHRvIHRoZSBzY2hlbWFcbiAgaWYgKHNjaGVtYSA9PSBudWxsIHx8ICEoJ3BsdXJhbGl6YXRpb24nIGluIHNjaGVtYS5vcHRpb25zKSkge1xuICAgIHNjaGVtYS5vcHRpb25zLnBsdXJhbGl6YXRpb24gPSBfbW9uZ29vc2Uub3B0aW9ucy5wbHVyYWxpemF0aW9uO1xuICB9XG5cbiAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgY29sbGVjdGlvbiA9IHNjaGVtYS5nZXQoJ2NvbGxlY3Rpb24nKSB8fFxuICAgICAgdXRpbHMudG9Db2xsZWN0aW9uTmFtZShuYW1lLCBfbW9uZ29vc2UucGx1cmFsaXplKCkpO1xuICB9XG5cbiAgY29uc3QgY29ubmVjdGlvbiA9IG9wdGlvbnMuY29ubmVjdGlvbiB8fCBfbW9uZ29vc2UuY29ubmVjdGlvbjtcbiAgbW9kZWwgPSBfbW9uZ29vc2UuTW9kZWwuY29tcGlsZShtb2RlbCB8fCBuYW1lLCBzY2hlbWEsIGNvbGxlY3Rpb24sIGNvbm5lY3Rpb24sIF9tb25nb29zZSk7XG4gIC8vIEVycm9ycyBoYW5kbGVkIGludGVybmFsbHksIHNvIHNhZmUgdG8gaWdub3JlIGVycm9yXG4gIG1vZGVsLmluaXQoKS5jYXRjaChmdW5jdGlvbiAkbW9kZWxJbml0Tm9vcCgpIHt9KTtcblxuICBjb25uZWN0aW9uLmVtaXQoJ21vZGVsJywgbW9kZWwpO1xuXG4gIGlmIChzY2hlbWEuX2FwcGx5RGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgIGZvciAoY29uc3QgZGlzYyBvZiBzY2hlbWEuX2FwcGx5RGlzY3JpbWluYXRvcnMua2V5cygpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNjaGVtYTogZGlzY3JpbWluYXRvclNjaGVtYSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSA9IHNjaGVtYS5fYXBwbHlEaXNjcmltaW5hdG9ycy5nZXQoZGlzYyk7XG4gICAgICBtb2RlbC5kaXNjcmltaW5hdG9yKGRpc2MsIGRpc2NyaW1pbmF0b3JTY2hlbWEsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGFwcGx5RW1iZWRkZWREaXNjcmltaW5hdG9ycyhzY2hlbWEpO1xuXG4gIHJldHVybiBtb2RlbDtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbW9kZWwgbmFtZWQgYG5hbWVgIGZyb20gdGhlIGRlZmF1bHQgY29ubmVjdGlvbiwgaWYgaXQgZXhpc3RzLlxuICogWW91IGNhbiB1c2UgdGhpcyBmdW5jdGlvbiB0byBjbGVhbiB1cCBhbnkgbW9kZWxzIHlvdSBjcmVhdGVkIGluIHlvdXIgdGVzdHMgdG9cbiAqIHByZXZlbnQgT3ZlcndyaXRlTW9kZWxFcnJvcnMuXG4gKlxuICogRXF1aXZhbGVudCB0byBgbW9uZ29vc2UuY29ubmVjdGlvbi5kZWxldGVNb2RlbChuYW1lKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5tb2RlbCgnVXNlcicsIG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSkpO1xuICogICAgIGNvbnNvbGUubG9nKG1vbmdvb3NlLm1vZGVsKCdVc2VyJykpOyAvLyBNb2RlbCBvYmplY3RcbiAqICAgICBtb25nb29zZS5kZWxldGVNb2RlbCgnVXNlcicpO1xuICogICAgIGNvbnNvbGUubG9nKG1vbmdvb3NlLm1vZGVsKCdVc2VyJykpOyAvLyB1bmRlZmluZWRcbiAqXG4gKiAgICAgLy8gVXN1YWxseSB1c2VmdWwgaW4gYSBNb2NoYSBgYWZ0ZXJFYWNoKClgIGhvb2tcbiAqICAgICBhZnRlckVhY2goZnVuY3Rpb24oKSB7XG4gKiAgICAgICBtb25nb29zZS5kZWxldGVNb2RlbCgvLisvKTsgLy8gRGVsZXRlIGV2ZXJ5IG1vZGVsXG4gKiAgICAgfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gbmFtZSBpZiBzdHJpbmcsIHRoZSBuYW1lIG9mIHRoZSBtb2RlbCB0byByZW1vdmUuIElmIHJlZ2V4cCwgcmVtb3ZlcyBhbGwgbW9kZWxzIHdob3NlIG5hbWUgbWF0Y2hlcyB0aGUgcmVnZXhwLlxuICogQHJldHVybiB7TW9uZ29vc2V9IHRoaXNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuZGVsZXRlTW9kZWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICBfbW9uZ29vc2UuY29ubmVjdGlvbi5kZWxldGVNb2RlbChuYW1lKTtcbiAgZGVsZXRlIF9tb25nb29zZS5tb2RlbHNbbmFtZV07XG4gIHJldHVybiBfbW9uZ29vc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgbW9kZWwgbmFtZXMgY3JlYXRlZCBvbiB0aGlzIGluc3RhbmNlIG9mIE1vbmdvb3NlLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBfRG9lcyBub3QgaW5jbHVkZSBuYW1lcyBvZiBtb2RlbHMgY3JlYXRlZCB1c2luZyBgY29ubmVjdGlvbi5tb2RlbCgpYC5fXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5tb2RlbE5hbWVzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKF9tb25nb29zZS5tb2RlbHMpO1xuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgZ2xvYmFsIHBsdWdpbnMgdG8gYHNjaGVtYWAuXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLl9hcHBseVBsdWdpbnMgPSBmdW5jdGlvbihzY2hlbWEsIG9wdGlvbnMpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnMgPSBfbW9uZ29vc2Uub3B0aW9ucyAmJiBfbW9uZ29vc2Uub3B0aW9ucy5hcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzIHx8IGZhbHNlO1xuICBvcHRpb25zLmFwcGx5UGx1Z2luc1RvQ2hpbGRTY2hlbWFzID0gdHlwZW9mIChfbW9uZ29vc2Uub3B0aW9ucyAmJiBfbW9uZ29vc2Uub3B0aW9ucy5hcHBseVBsdWdpbnNUb0NoaWxkU2NoZW1hcykgPT09ICdib29sZWFuJyA/XG4gICAgX21vbmdvb3NlLm9wdGlvbnMuYXBwbHlQbHVnaW5zVG9DaGlsZFNjaGVtYXMgOlxuICAgIHRydWU7XG4gIGFwcGx5UGx1Z2lucyhzY2hlbWEsIF9tb25nb29zZS5wbHVnaW5zLCBvcHRpb25zLCAnJGdsb2JhbFBsdWdpbnNBcHBsaWVkJyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGEgZ2xvYmFsIHBsdWdpbiBleGVjdXRlZCBvbiBhbGwgU2NoZW1hcy5cbiAqXG4gKiBFcXVpdmFsZW50IHRvIGNhbGxpbmcgYC5wbHVnaW4oZm4pYCBvbiBlYWNoIFNjaGVtYSB5b3UgY3JlYXRlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHBsdWdpbiBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBvcHRpb25hbCBvcHRpb25zXG4gKiBAcmV0dXJuIHtNb25nb29zZX0gdGhpc1xuICogQHNlZSBwbHVnaW5zIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wbHVnaW5zLmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLnBsdWdpbiA9IGZ1bmN0aW9uKGZuLCBvcHRzKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICBfbW9uZ29vc2UucGx1Z2lucy5wdXNoKFtmbiwgb3B0c10pO1xuICByZXR1cm4gX21vbmdvb3NlO1xufTtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgbW9kdWxlJ3MgZGVmYXVsdCBjb25uZWN0aW9uLiBFcXVpdmFsZW50IHRvIGBtb25nb29zZS5jb25uZWN0aW9uc1swXWAsIHNlZSBbYGNvbm5lY3Rpb25zYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5jb25uZWN0aW9ucykuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdCguLi4pO1xuICogICAgIG1vbmdvb3NlLmNvbm5lY3Rpb24ub24oJ2Vycm9yJywgY2IpO1xuICpcbiAqIFRoaXMgaXMgdGhlIGNvbm5lY3Rpb24gdXNlZCBieSBkZWZhdWx0IGZvciBldmVyeSBtb2RlbCBjcmVhdGVkIHVzaW5nIFttb25nb29zZS5tb2RlbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5tb2RlbCgpKS5cbiAqXG4gKiBUbyBjcmVhdGUgYSBuZXcgY29ubmVjdGlvbiwgdXNlIFtgY3JlYXRlQ29ubmVjdGlvbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uKCkpLlxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oJ2Nvbm5lY3Rpb24nLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbnNbMF07XG59KTtcblxuTW9uZ29vc2UucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18oJ2Nvbm5lY3Rpb24nLCBmdW5jdGlvbih2KSB7XG4gIGlmICh2IGluc3RhbmNlb2YgdGhpcy5fX2RyaXZlci5Db25uZWN0aW9uKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uc1swXSA9IHY7XG4gICAgdGhpcy5tb2RlbHMgPSB2Lm1vZGVscztcbiAgfVxufSk7XG5cbi8qKlxuICogQW4gYXJyYXkgY29udGFpbmluZyBhbGwgW2Nvbm5lY3Rpb25zXShjb25uZWN0aW9uLmh0bWwpIGFzc29jaWF0ZWQgd2l0aCB0aGlzXG4gKiBNb25nb29zZSBpbnN0YW5jZS4gQnkgZGVmYXVsdCwgdGhlcmUgaXMgMSBjb25uZWN0aW9uLiBDYWxsaW5nXG4gKiBbYGNyZWF0ZUNvbm5lY3Rpb24oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbigpKSBhZGRzIGEgY29ubmVjdGlvblxuICogdG8gdGhpcyBhcnJheS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbiAqICAgICBtb25nb29zZS5jb25uZWN0aW9ucy5sZW5ndGg7IC8vIDEsIGp1c3QgdGhlIGRlZmF1bHQgY29ubmVjdGlvblxuICogICAgIG1vbmdvb3NlLmNvbm5lY3Rpb25zWzBdID09PSBtb25nb29zZS5jb25uZWN0aW9uOyAvLyB0cnVlXG4gKlxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvdGVzdCcpO1xuICogICAgIG1vbmdvb3NlLmNvbm5lY3Rpb25zLmxlbmd0aDsgLy8gMlxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge0FycmF5fSBjb25uZWN0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuY29ubmVjdGlvbnM7XG5cbi8qKlxuICogQW4gaW50ZWdlciBjb250YWluaW5nIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCBjb25uZWN0aW9uIGlkLiBDYWxsaW5nXG4gKiBbYGNyZWF0ZUNvbm5lY3Rpb24oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbigpKSBpbmNyZW1lbnRzXG4gKiB0aGlzIHZhbHVlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oKTsgLy8gaWQgYDBgLCBgbmV4dENvbm5lY3Rpb25JZGAgYmVjb21lcyBgMWBcbiAqICAgICBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCk7IC8vIGlkIGAxYCwgYG5leHRDb25uZWN0aW9uSWRgIGJlY29tZXMgYDJgXG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdGlvbnNbMF0uZGVzdHJveSgpIC8vIFJlbW92ZXMgY29ubmVjdGlvbiB3aXRoIGlkIGAwYFxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oKTsgLy8gaWQgYDJgLCBgbmV4dENvbm5lY3Rpb25JZGAgYmVjb21lcyBgM2BcbiAqXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IG5leHRDb25uZWN0aW9uSWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5uZXh0Q29ubmVjdGlvbklkO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBBZ2dyZWdhdGUgY29uc3RydWN0b3JcbiAqXG4gKiBAbWV0aG9kIEFnZ3JlZ2F0ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuQWdncmVnYXRlID0gQWdncmVnYXRlO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBDb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gKlxuICogQG1lbWJlck9mIE1vbmdvb3NlXG4gKiBAaW5zdGFuY2VcbiAqIEBtZXRob2QgQ29sbGVjdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2UucHJvdG90eXBlLCAnQ29sbGVjdGlvbicsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX2RyaXZlci5Db2xsZWN0aW9uO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKENvbGxlY3Rpb24pIHtcbiAgICB0aGlzLl9fZHJpdmVyLkNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uO1xuICB9XG59KTtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgW0Nvbm5lY3Rpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvY29ubmVjdGlvbi5odG1sI0Nvbm5lY3Rpb24oKSkgY29uc3RydWN0b3JcbiAqXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VcbiAqIEBpbnN0YW5jZVxuICogQG1ldGhvZCBDb25uZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZS5wcm90b3R5cGUsICdDb25uZWN0aW9uJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9fZHJpdmVyLkNvbm5lY3Rpb247XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oQ29ubmVjdGlvbikge1xuICAgIGlmIChDb25uZWN0aW9uID09PSB0aGlzLl9fZHJpdmVyLkNvbm5lY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9fZHJpdmVyLkNvbm5lY3Rpb24gPSBDb25uZWN0aW9uO1xuICB9XG59KTtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgdmVyc2lvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc29sZS5sb2cobW9uZ29vc2UudmVyc2lvbik7IC8vICc1LngueCdcbiAqXG4gKiBAcHJvcGVydHkgdmVyc2lvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUudmVyc2lvbiA9IHBrZy52ZXJzaW9uO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBjb25zdHJ1Y3RvclxuICpcbiAqIFRoZSBleHBvcnRzIG9mIHRoZSBtb25nb29zZSBtb2R1bGUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbiAqICAgICBjb25zdCBtb25nb29zZTIgPSBuZXcgbW9uZ29vc2UuTW9uZ29vc2UoKTtcbiAqXG4gKiBAbWV0aG9kIE1vbmdvb3NlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5Nb25nb29zZSA9IE1vbmdvb3NlO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBbU2NoZW1hXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYS5odG1sI1NjaGVtYSgpKSBjb25zdHJ1Y3RvclxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIGNvbnN0IFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbiAqICAgICBjb25zdCBDYXRTY2hlbWEgPSBuZXcgU2NoZW1hKC4uKTtcbiAqXG4gKiBAbWV0aG9kIFNjaGVtYVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuU2NoZW1hID0gU2NoZW1hO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBbU2NoZW1hVHlwZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWF0eXBlLmh0bWwjU2NoZW1hVHlwZSgpKSBjb25zdHJ1Y3RvclxuICpcbiAqIEBtZXRob2QgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuU2NoZW1hVHlwZSA9IFNjaGVtYVR5cGU7XG5cbi8qKlxuICogVGhlIHZhcmlvdXMgTW9uZ29vc2UgU2NoZW1hVHlwZXMuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIF9BbGlhcyBvZiBtb25nb29zZS5TY2hlbWEuVHlwZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5Ll9cbiAqXG4gKiBAcHJvcGVydHkgU2NoZW1hVHlwZXNcbiAqIEBzZWUgU2NoZW1hLlNjaGVtYVR5cGVzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5TY2hlbWFUeXBlcyA9IFNjaGVtYS5UeXBlcztcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgW1ZpcnR1YWxUeXBlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3ZpcnR1YWx0eXBlLmh0bWwjVmlydHVhbFR5cGUoKSkgY29uc3RydWN0b3JcbiAqXG4gKiBAbWV0aG9kIFZpcnR1YWxUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5WaXJ0dWFsVHlwZSA9IFZpcnR1YWxUeXBlO1xuXG4vKipcbiAqIFRoZSB2YXJpb3VzIE1vbmdvb3NlIFR5cGVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIGNvbnN0IGFycmF5ID0gbW9uZ29vc2UuVHlwZXMuQXJyYXk7XG4gKlxuICogIyMjIyBUeXBlczpcbiAqXG4gKiAtIFtBcnJheV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjYXJyYXlzKVxuICogLSBbQnVmZmVyXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNidWZmZXJzKVxuICogLSBbRW1iZWRkZWRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI3NjaGVtYXMpXG4gKiAtIFtEb2N1bWVudEFycmF5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50YXJyYXlwYXRoLmh0bWwpXG4gKiAtIFtEZWNpbWFsMTI4XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLkRlY2ltYWwxMjgpXG4gKiAtIFtPYmplY3RJZF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjb2JqZWN0aWRzKVxuICogLSBbTWFwXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNtYXBzKVxuICogLSBbU3ViZG9jdW1lbnRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI3NjaGVtYXMpXG4gKlxuICogVXNpbmcgdGhpcyBleHBvc2VkIGFjY2VzcyB0byB0aGUgYE9iamVjdElkYCB0eXBlLCB3ZSBjYW4gY29uc3RydWN0IGlkcyBvbiBkZW1hbmQuXG4gKlxuICogICAgIGNvbnN0IE9iamVjdElkID0gbW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQ7XG4gKiAgICAgY29uc3QgaWQxID0gbmV3IE9iamVjdElkO1xuICpcbiAqIEBwcm9wZXJ0eSBUeXBlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuVHlwZXMgPSBUeXBlcztcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgW1F1ZXJ5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkoKSkgY29uc3RydWN0b3IuXG4gKlxuICogQG1ldGhvZCBRdWVyeVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgW01vZGVsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwoKSkgY29uc3RydWN0b3IuXG4gKlxuICogQG1ldGhvZCBNb2RlbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuTW9kZWwgPSBNb2RlbDtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgW0RvY3VtZW50XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQoKSkgY29uc3RydWN0b3IuXG4gKlxuICogQG1ldGhvZCBEb2N1bWVudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuRG9jdW1lbnQgPSBEb2N1bWVudDtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgRG9jdW1lbnRQcm92aWRlciBjb25zdHJ1Y3Rvci4gTW9uZ29vc2UgdXNlcnMgc2hvdWxkIG5vdCBoYXZlIHRvXG4gKiB1c2UgdGhpcyBkaXJlY3RseVxuICpcbiAqIEBtZXRob2QgRG9jdW1lbnRQcm92aWRlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuRG9jdW1lbnRQcm92aWRlciA9IHJlcXVpcmUoJy4vZG9jdW1lbnRfcHJvdmlkZXInKTtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgT2JqZWN0SWQgW1NjaGVtYVR5cGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sKS4gVXNlZCBmb3JcbiAqIGRlY2xhcmluZyBwYXRocyBpbiB5b3VyIHNjaGVtYSB0aGF0IHNob3VsZCBiZVxuICogW01vbmdvREIgT2JqZWN0SWRzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL09iamVjdElkLykuXG4gKiBEbyBub3QgdXNlIHRoaXMgdG8gY3JlYXRlIGEgbmV3IE9iamVjdElkIGluc3RhbmNlLCB1c2UgYG1vbmdvb3NlLlR5cGVzLk9iamVjdElkYFxuICogaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNoaWxkU2NoZW1hID0gbmV3IFNjaGVtYSh7IHBhcmVudElkOiBtb25nb29zZS5PYmplY3RJZCB9KTtcbiAqXG4gKiBAcHJvcGVydHkgT2JqZWN0SWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLk9iamVjdElkID0gU2NoZW1hVHlwZXMuT2JqZWN0SWQ7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIE1vbmdvb3NlIGNhbiBjYXN0IHRoZSBnaXZlbiB2YWx1ZSB0byBhbiBPYmplY3RJZCwgb3JcbiAqIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmlzVmFsaWRPYmplY3RJZChuZXcgbW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQoKSk7IC8vIHRydWVcbiAqICAgICBtb25nb29zZS5pc1ZhbGlkT2JqZWN0SWQoJzAxMjM0NTY3ODlhYicpOyAvLyB0cnVlXG4gKiAgICAgbW9uZ29vc2UuaXNWYWxpZE9iamVjdElkKDYpOyAvLyB0cnVlXG4gKiAgICAgbW9uZ29vc2UuaXNWYWxpZE9iamVjdElkKG5ldyBVc2VyKHsgbmFtZTogJ3Rlc3QnIH0pKTsgLy8gdHJ1ZVxuICpcbiAqICAgICBtb25nb29zZS5pc1ZhbGlkT2JqZWN0SWQoeyB0ZXN0OiA0MiB9KTsgLy8gZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzVmFsaWRPYmplY3RJZFxuICogQHBhcmFtIHtBbnl9IHZcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGB2YCBpcyBzb21ldGhpbmcgTW9uZ29vc2UgY2FuIGNvZXJjZSB0byBhbiBPYmplY3RJZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuaXNWYWxpZE9iamVjdElkID0gZnVuY3Rpb24odikge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG4gIHJldHVybiBfbW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQuaXNWYWxpZCh2KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIE1vbmdvb3NlIE9iamVjdElkICh1c2luZyBgaW5zdGFuY2VvZmApIG9yIGlmIHRoZVxuICogZ2l2ZW4gdmFsdWUgaXMgYSAyNCBjaGFyYWN0ZXIgaGV4IHN0cmluZywgd2hpY2ggaXMgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIG9mIGFuIE9iamVjdElkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgc2ltaWxhciB0byBgaXNWYWxpZE9iamVjdElkKClgLCBidXQgY29uc2lkZXJhYmx5IG1vcmUgc3RyaWN0LCBiZWNhdXNlXG4gKiBgaXNWYWxpZE9iamVjdElkKClgIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgX2FueV8gdmFsdWUgdGhhdCBNb25nb29zZSBjYW4gY29udmVydCB0byBhblxuICogT2JqZWN0SWQuIFRoYXQgaW5jbHVkZXMgTW9uZ29vc2UgZG9jdW1lbnRzLCBhbnkgc3RyaW5nIG9mIGxlbmd0aCAxMiwgYW5kIGFueSBudW1iZXIuXG4gKiBgaXNPYmplY3RJZE9ySGV4U3RyaW5nKClgIHJldHVybnMgdHJ1ZSBvbmx5IGZvciBgT2JqZWN0SWRgIGluc3RhbmNlcyBvciAyNCBjaGFyYWN0ZXIgaGV4XG4gKiBzdHJpbmdzLCBhbmQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIG51bWJlcnMsIGRvY3VtZW50cywgYW5kIHN0cmluZ3Mgb2YgbGVuZ3RoIDEyLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UuaXNPYmplY3RJZE9ySGV4U3RyaW5nKG5ldyBtb25nb29zZS5UeXBlcy5PYmplY3RJZCgpKTsgLy8gdHJ1ZVxuICogICAgIG1vbmdvb3NlLmlzT2JqZWN0SWRPckhleFN0cmluZygnNjIyNjFhNjVkNjZjNmJlMGE2M2MwNTFmJyk7IC8vIHRydWVcbiAqXG4gKiAgICAgbW9uZ29vc2UuaXNPYmplY3RJZE9ySGV4U3RyaW5nKCcwMTIzNDU2Nzg5YWInKTsgLy8gZmFsc2VcbiAqICAgICBtb25nb29zZS5pc09iamVjdElkT3JIZXhTdHJpbmcoNik7IC8vIGZhbHNlXG4gKiAgICAgbW9uZ29vc2UuaXNPYmplY3RJZE9ySGV4U3RyaW5nKG5ldyBVc2VyKHsgbmFtZTogJ3Rlc3QnIH0pKTsgLy8gZmFsc2VcbiAqICAgICBtb25nb29zZS5pc09iamVjdElkT3JIZXhTdHJpbmcoeyB0ZXN0OiA0MiB9KTsgLy8gZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzT2JqZWN0SWRPckhleFN0cmluZ1xuICogQHBhcmFtIHtBbnl9IHZcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGB2YCBpcyBhbiBPYmplY3RJZCBpbnN0YW5jZSBfb3JfIGEgMjQgY2hhciBoZXggc3RyaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5pc09iamVjdElkT3JIZXhTdHJpbmcgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBpc0Jzb25UeXBlKHYsICdPYmplY3RJZCcpIHx8ICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgb2JqZWN0SWRIZXhSZWdleHAudGVzdCh2KSk7XG59O1xuXG4vKipcbiAqXG4gKiBTeW5jcyBhbGwgdGhlIGluZGV4ZXMgZm9yIHRoZSBtb2RlbHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNvbnRpbnVlT25FcnJvciBgZmFsc2VgIGJ5IGRlZmF1bHQuIElmIHNldCB0byBgdHJ1ZWAsIG1vbmdvb3NlIHdpbGwgbm90IHRocm93IGFuIGVycm9yIGlmIG9uZSBtb2RlbCBzeW5jaW5nIGZhaWxlZCwgYW5kIHdpbGwgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgdGhlIG5hbWVzIG9mIHRoZSBtb2RlbHMsIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGUgcmVzdWx0cy9lcnJvcnMgZm9yIGVhY2ggbW9kZWwuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgUHJvbWlzZSwgd2hlbiB0aGUgUHJvbWlzZSByZXNvbHZlcyB0aGUgdmFsdWUgaXMgYSBsaXN0IG9mIHRoZSBkcm9wcGVkIGluZGV4ZXMuXG4gKi9cbk1vbmdvb3NlLnByb3RvdHlwZS5zeW5jSW5kZXhlcyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuICByZXR1cm4gX21vbmdvb3NlLmNvbm5lY3Rpb24uc3luY0luZGV4ZXMob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBEZWNpbWFsMTI4IFtTY2hlbWFUeXBlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCkuIFVzZWQgZm9yXG4gKiBkZWNsYXJpbmcgcGF0aHMgaW4geW91ciBzY2hlbWEgdGhhdCBzaG91bGQgYmVcbiAqIFsxMjgtYml0IGRlY2ltYWwgZmxvYXRpbmcgcG9pbnRzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2Etbm9kZWpzLXBlcnNwZWN0aXZlLW9uLW1vbmdvZGItMzQtZGVjaW1hbC5odG1sKS5cbiAqIERvIG5vdCB1c2UgdGhpcyB0byBjcmVhdGUgYSBuZXcgRGVjaW1hbDEyOCBpbnN0YW5jZSwgdXNlIGBtb25nb29zZS5UeXBlcy5EZWNpbWFsMTI4YFxuICogaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHZlaGljbGVTY2hlbWEgPSBuZXcgU2NoZW1hKHsgZnVlbExldmVsOiBtb25nb29zZS5EZWNpbWFsMTI4IH0pO1xuICpcbiAqIEBwcm9wZXJ0eSBEZWNpbWFsMTI4XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5EZWNpbWFsMTI4ID0gU2NoZW1hVHlwZXMuRGVjaW1hbDEyODtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgTWl4ZWQgW1NjaGVtYVR5cGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sKS4gVXNlZCBmb3JcbiAqIGRlY2xhcmluZyBwYXRocyBpbiB5b3VyIHNjaGVtYSB0aGF0IE1vbmdvb3NlJ3MgY2hhbmdlIHRyYWNraW5nLCBjYXN0aW5nLFxuICogYW5kIHZhbGlkYXRpb24gc2hvdWxkIGlnbm9yZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBhcmJpdHJhcnk6IG1vbmdvb3NlLk1peGVkIH0pO1xuICpcbiAqIEBwcm9wZXJ0eSBNaXhlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuTWl4ZWQgPSBTY2hlbWFUeXBlcy5NaXhlZDtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgRGF0ZSBbU2NoZW1hVHlwZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHRlc3Q6IERhdGUgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ3Rlc3QnKSBpbnN0YW5jZW9mIG1vbmdvb3NlLkRhdGU7IC8vIHRydWVcbiAqXG4gKiBAcHJvcGVydHkgRGF0ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuRGF0ZSA9IFNjaGVtYVR5cGVzLkRhdGU7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIE51bWJlciBbU2NoZW1hVHlwZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwpLiBVc2VkIGZvclxuICogZGVjbGFyaW5nIHBhdGhzIGluIHlvdXIgc2NoZW1hIHRoYXQgTW9uZ29vc2Ugc2hvdWxkIGNhc3QgdG8gbnVtYmVycy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBudW06IG1vbmdvb3NlLk51bWJlciB9KTtcbiAqICAgICAvLyBFcXVpdmFsZW50IHRvOlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBudW06ICdudW1iZXInIH0pO1xuICpcbiAqIEBwcm9wZXJ0eSBOdW1iZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLk51bWJlciA9IFNjaGVtYVR5cGVzLk51bWJlcjtcblxuLyoqXG4gKiBUaGUgW01vbmdvb3NlRXJyb3JdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvcigpKSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAbWV0aG9kIEVycm9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvaW5kZXgnKTtcbk1vbmdvb3NlLnByb3RvdHlwZS5Nb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5cbi8qKlxuICogTW9uZ29vc2UgdXNlcyB0aGlzIGZ1bmN0aW9uIHRvIGdldCB0aGUgY3VycmVudCB0aW1lIHdoZW4gc2V0dGluZ1xuICogW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpLiBZb3UgbWF5IHN0dWIgb3V0IHRoaXMgZnVuY3Rpb25cbiAqIHVzaW5nIGEgdG9vbCBsaWtlIFtTaW5vbl0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2lub24pIGZvciB0ZXN0aW5nLlxuICpcbiAqIEBtZXRob2Qgbm93XG4gKiBAcmV0dXJucyBEYXRlIHRoZSBjdXJyZW50IHRpbWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCk7IH07XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIENhc3RFcnJvciBjb25zdHJ1Y3RvclxuICpcbiAqIEBtZXRob2QgQ2FzdEVycm9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgdHlwZVxuICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IGZhaWxlZCB0byBjYXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCBgYS5iLmNgIGluIHRoZSBkb2Mgd2hlcmUgdGhpcyBjYXN0IGVycm9yIG9jY3VycmVkXG4gKiBAcGFyYW0ge0Vycm9yfSBbcmVhc29uXSBUaGUgb3JpZ2luYWwgZXJyb3IgdGhhdCB3YXMgdGhyb3duXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5DYXN0RXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2Nhc3QnKTtcblxuLyoqXG4gKiBUaGUgY29uc3RydWN0b3IgdXNlZCBmb3Igc2NoZW1hdHlwZSBvcHRpb25zXG4gKlxuICogQG1ldGhvZCBTY2hlbWFUeXBlT3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMvU2NoZW1hVHlwZU9wdGlvbnMnKTtcblxuLyoqXG4gKiBUaGUgW25vZGUtbW9uZ29kYi1uYXRpdmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb25nb2RiL25vZGUtbW9uZ29kYi1uYXRpdmUpIGRyaXZlciBNb25nb29zZSB1c2VzLlxuICpcbiAqIEBwcm9wZXJ0eSBtb25nb1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUubW9uZ28gPSByZXF1aXJlKCdtb25nb2RiJyk7XG5cbi8qKlxuICogVGhlIFttcXVlcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9haGVja21hbm4vbXF1ZXJ5KSBxdWVyeSBidWlsZGVyIE1vbmdvb3NlIHVzZXMuXG4gKlxuICogQHByb3BlcnR5IG1xdWVyeVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUubXF1ZXJ5ID0gcmVxdWlyZSgnbXF1ZXJ5Jyk7XG5cbi8qKlxuICogU2FuaXRpemVzIHF1ZXJ5IGZpbHRlcnMgYWdhaW5zdCBbcXVlcnkgc2VsZWN0b3IgaW5qZWN0aW9uIGF0dGFja3NdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vMjAxNC8wOS8wNC9kZWZlbmRpbmctYWdhaW5zdC1xdWVyeS1zZWxlY3Rvci1pbmplY3Rpb24tYXR0YWNrcy5odG1sKVxuICogYnkgd3JhcHBpbmcgYW55IG5lc3RlZCBvYmplY3RzIHRoYXQgaGF2ZSBhIHByb3BlcnR5IHdob3NlIG5hbWUgc3RhcnRzIHdpdGggYCRgIGluIGEgYCRlcWAuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3Qgb2JqID0geyB1c2VybmFtZTogJ3ZhbCcsIHB3ZDogeyAkbmU6IG51bGwgfSB9O1xuICogc2FuaXRpemVGaWx0ZXIob2JqKTtcbiAqIG9iajsgLy8geyB1c2VybmFtZTogJ3ZhbCcsIHB3ZDogeyAkZXE6IHsgJG5lOiBudWxsIH0gfSB9KTtcbiAqIGBgYFxuICpcbiAqIEBtZXRob2Qgc2FuaXRpemVGaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJcbiAqIEByZXR1cm5zIE9iamVjdCB0aGUgc2FuaXRpemVkIG9iamVjdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuc2FuaXRpemVGaWx0ZXIgPSBzYW5pdGl6ZUZpbHRlcjtcblxuLyoqXG4gKiBUZWxscyBgc2FuaXRpemVGaWx0ZXIoKWAgdG8gc2tpcCB0aGUgZ2l2ZW4gb2JqZWN0IHdoZW4gZmlsdGVyaW5nIG91dCBwb3RlbnRpYWwgW3F1ZXJ5IHNlbGVjdG9yIGluamVjdGlvbiBhdHRhY2tzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tLzIwMTQvMDkvMDQvZGVmZW5kaW5nLWFnYWluc3QtcXVlcnktc2VsZWN0b3ItaW5qZWN0aW9uLWF0dGFja3MuaHRtbCkuXG4gKiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB5b3UgaGF2ZSBhIGtub3duIHF1ZXJ5IHNlbGVjdG9yIHRoYXQgeW91IHdhbnQgdG8gdXNlLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IG9iaiA9IHsgdXNlcm5hbWU6ICd2YWwnLCBwd2Q6IHRydXN0ZWQoeyAkdHlwZTogJ3N0cmluZycsICRlcTogJ215IHNlY3JldCcgfSkgfTtcbiAqIHNhbml0aXplRmlsdGVyKG9iaik7XG4gKlxuICogLy8gTm90ZSB0aGF0IGBzYW5pdGl6ZUZpbHRlcigpYCBkaWQgbm90IGFkZCBgJGVxYCBhcm91bmQgYCR0eXBlYC5cbiAqIG9iajsgLy8geyB1c2VybmFtZTogJ3ZhbCcsIHB3ZDogeyAkdHlwZTogJ3N0cmluZycsICRlcTogJ215IHNlY3JldCcgfSB9KTtcbiAqIGBgYFxuICpcbiAqIEBtZXRob2QgdHJ1c3RlZFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMgT2JqZWN0IHRoZSBwYXNzZWQgaW4gb2JqZWN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS50cnVzdGVkID0gdHJ1c3RlZDtcblxuLyoqXG4gKiBVc2UgdGhpcyBmdW5jdGlvbiBpbiBgcHJlKClgIG1pZGRsZXdhcmUgdG8gc2tpcCBjYWxsaW5nIHRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLnByZSgnc2F2ZScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgLy8gV2lsbCBza2lwIGV4ZWN1dGluZyBgc2F2ZSgpYCwgYnV0IHdpbGwgZXhlY3V0ZSBwb3N0IGhvb2tzIGFzIGlmXG4gKiAgICAgICAvLyBgc2F2ZSgpYCBoYWQgZXhlY3V0ZWQgd2l0aCB0aGUgcmVzdWx0IGB7IG1hdGNoZWRDb3VudDogMCB9YFxuICogICAgICAgcmV0dXJuIG1vbmdvb3NlLnNraXBNaWRkbGV3YXJlRnVuY3Rpb24oeyBtYXRjaGVkQ291bnQ6IDAgfSk7XG4gKiAgICAgfSk7XG4gKlxuICogQG1ldGhvZCBza2lwTWlkZGxld2FyZUZ1bmN0aW9uXG4gKiBAcGFyYW0ge2FueX0gcmVzdWx0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5za2lwTWlkZGxld2FyZUZ1bmN0aW9uID0gS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb247XG5cbi8qKlxuICogVXNlIHRoaXMgZnVuY3Rpb24gaW4gYHBvc3QoKWAgbWlkZGxld2FyZSB0byByZXBsYWNlIHRoZSByZXN1bHRcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHNjaGVtYS5wb3N0KCdmaW5kJywgZnVuY3Rpb24ocmVzKSB7XG4gKiAgICAgICAvLyBOb3JtYWxseSB5b3UgaGF2ZSB0byBtb2RpZnkgYHJlc2AgaW4gcGxhY2UuIEJ1dCB3aXRoXG4gKiAgICAgICAvLyBgb3ZlcndyaXRlTWlkZGxld2FyUmVzdWx0KClgLCB5b3UgY2FuIG1ha2UgYGZpbmQoKWAgcmV0dXJuIGFcbiAqICAgICAgIC8vIGNvbXBsZXRlbHkgZGlmZmVyZW50IHZhbHVlLlxuICogICAgICAgcmV0dXJuIG1vbmdvb3NlLm92ZXJ3cml0ZU1pZGRsZXdhcmVSZXN1bHQocmVzLmZpbHRlcihkb2MgPT4gIWRvYy5pc0RlbGV0ZWQpKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAbWV0aG9kIG92ZXJ3cml0ZU1pZGRsZXdhcmVSZXN1bHRcbiAqIEBwYXJhbSB7YW55fSByZXN1bHRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLm92ZXJ3cml0ZU1pZGRsZXdhcmVSZXN1bHQgPSBLYXJlZW0ub3ZlcndyaXRlUmVzdWx0O1xuXG4vKipcbiAqIFRoZSBleHBvcnRzIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBNb25nb29zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jb25zdCBtb25nb29zZSA9IG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBNb25nb29zZSh7XG4gIFtkZWZhdWx0TW9uZ29vc2VTeW1ib2xdOiB0cnVlXG59KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/index.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/internal.js":
/*!*******************************************************!*\
  !*** ../server/node_modules/mongoose/lib/internal.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Dependencies\n */\n\n\n\nconst StateMachine = __webpack_require__(/*! ./statemachine */ \"(api)/../server/node_modules/mongoose/lib/statemachine.js\");\nconst ActiveRoster = StateMachine.ctor('require', 'modify', 'init', 'default', 'ignore');\n\nmodule.exports = exports = InternalCache;\n\nfunction InternalCache() {\n  this.activePaths = new ActiveRoster();\n}\n\nInternalCache.prototype.strictMode = true;\n\nInternalCache.prototype.fullPath = undefined;\nInternalCache.prototype.selected = undefined;\nInternalCache.prototype.shardval = undefined;\nInternalCache.prototype.saveError = undefined;\nInternalCache.prototype.validationError = undefined;\nInternalCache.prototype.adhocPaths = undefined;\nInternalCache.prototype.removing = undefined;\nInternalCache.prototype.inserting = undefined;\nInternalCache.prototype.saving = undefined;\nInternalCache.prototype.version = undefined;\nInternalCache.prototype._id = undefined;\nInternalCache.prototype.ownerDocument = undefined;\nInternalCache.prototype.populate = undefined; // what we want to populate in this doc\nInternalCache.prototype.populated = undefined;// the _ids that have been populated\nInternalCache.prototype.primitiveAtomics = undefined;\n\n/**\n * If `false`, this document was not the result of population.\n * If `true`, this document is a populated doc underneath another doc\n * If an object, this document is a populated doc and the `value` property of the\n * object contains the original depopulated value.\n */\nInternalCache.prototype.wasPopulated = false;\n\nInternalCache.prototype.scope = undefined;\n\nInternalCache.prototype.session = null;\nInternalCache.prototype.pathsToScopes = null;\nInternalCache.prototype.cachedRequired = null;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaW50ZXJuYWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLGlGQUFnQjtBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxpbnRlcm5hbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIERlcGVuZGVuY2llc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RhdGVNYWNoaW5lID0gcmVxdWlyZSgnLi9zdGF0ZW1hY2hpbmUnKTtcbmNvbnN0IEFjdGl2ZVJvc3RlciA9IFN0YXRlTWFjaGluZS5jdG9yKCdyZXF1aXJlJywgJ21vZGlmeScsICdpbml0JywgJ2RlZmF1bHQnLCAnaWdub3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEludGVybmFsQ2FjaGU7XG5cbmZ1bmN0aW9uIEludGVybmFsQ2FjaGUoKSB7XG4gIHRoaXMuYWN0aXZlUGF0aHMgPSBuZXcgQWN0aXZlUm9zdGVyKCk7XG59XG5cbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnN0cmljdE1vZGUgPSB0cnVlO1xuXG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5mdWxsUGF0aCA9IHVuZGVmaW5lZDtcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnNlbGVjdGVkID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuc2hhcmR2YWwgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5zYXZlRXJyb3IgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS52YWxpZGF0aW9uRXJyb3IgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5hZGhvY1BhdGhzID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUucmVtb3ZpbmcgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5pbnNlcnRpbmcgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5zYXZpbmcgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS52ZXJzaW9uID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuX2lkID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUub3duZXJEb2N1bWVudCA9IHVuZGVmaW5lZDtcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnBvcHVsYXRlID0gdW5kZWZpbmVkOyAvLyB3aGF0IHdlIHdhbnQgdG8gcG9wdWxhdGUgaW4gdGhpcyBkb2NcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnBvcHVsYXRlZCA9IHVuZGVmaW5lZDsvLyB0aGUgX2lkcyB0aGF0IGhhdmUgYmVlbiBwb3B1bGF0ZWRcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnByaW1pdGl2ZUF0b21pY3MgPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogSWYgYGZhbHNlYCwgdGhpcyBkb2N1bWVudCB3YXMgbm90IHRoZSByZXN1bHQgb2YgcG9wdWxhdGlvbi5cbiAqIElmIGB0cnVlYCwgdGhpcyBkb2N1bWVudCBpcyBhIHBvcHVsYXRlZCBkb2MgdW5kZXJuZWF0aCBhbm90aGVyIGRvY1xuICogSWYgYW4gb2JqZWN0LCB0aGlzIGRvY3VtZW50IGlzIGEgcG9wdWxhdGVkIGRvYyBhbmQgdGhlIGB2YWx1ZWAgcHJvcGVydHkgb2YgdGhlXG4gKiBvYmplY3QgY29udGFpbnMgdGhlIG9yaWdpbmFsIGRlcG9wdWxhdGVkIHZhbHVlLlxuICovXG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS53YXNQb3B1bGF0ZWQgPSBmYWxzZTtcblxuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuc2NvcGUgPSB1bmRlZmluZWQ7XG5cbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnNlc3Npb24gPSBudWxsO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUucGF0aHNUb1Njb3BlcyA9IG51bGw7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5jYWNoZWRSZXF1aXJlZCA9IG51bGw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/internal.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/model.js":
/*!****************************************************!*\
  !*** ../server/node_modules/mongoose/lib/model.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst Aggregate = __webpack_require__(/*! ./aggregate */ \"(api)/../server/node_modules/mongoose/lib/aggregate.js\");\nconst ChangeStream = __webpack_require__(/*! ./cursor/ChangeStream */ \"(api)/../server/node_modules/mongoose/lib/cursor/ChangeStream.js\");\nconst Document = __webpack_require__(/*! ./document */ \"(api)/../server/node_modules/mongoose/lib/document.js\");\nconst DocumentNotFoundError = __webpack_require__(/*! ./error/notFound */ \"(api)/../server/node_modules/mongoose/lib/error/notFound.js\");\nconst DivergentArrayError = __webpack_require__(/*! ./error/divergentArray */ \"(api)/../server/node_modules/mongoose/lib/error/divergentArray.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst MongooseBulkWriteError = __webpack_require__(/*! ./error/bulkWriteError */ \"(api)/../server/node_modules/mongoose/lib/error/bulkWriteError.js\");\nconst MongooseBuffer = __webpack_require__(/*! ./types/buffer */ \"(api)/../server/node_modules/mongoose/lib/types/buffer.js\");\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nconst OverwriteModelError = __webpack_require__(/*! ./error/overwriteModel */ \"(api)/../server/node_modules/mongoose/lib/error/overwriteModel.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(api)/../server/node_modules/mongoose/lib/query.js\");\nconst SaveOptions = __webpack_require__(/*! ./options/saveOptions */ \"(api)/../server/node_modules/mongoose/lib/options/saveOptions.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"(api)/../server/node_modules/mongoose/lib/schema.js\");\nconst ValidationError = __webpack_require__(/*! ./error/validation */ \"(api)/../server/node_modules/mongoose/lib/error/validation.js\");\nconst VersionError = __webpack_require__(/*! ./error/version */ \"(api)/../server/node_modules/mongoose/lib/error/version.js\");\nconst ParallelSaveError = __webpack_require__(/*! ./error/parallelSave */ \"(api)/../server/node_modules/mongoose/lib/error/parallelSave.js\");\nconst applyDefaultsHelper = __webpack_require__(/*! ./helpers/document/applyDefaults */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/applyDefaults.js\");\nconst applyDefaultsToPOJO = __webpack_require__(/*! ./helpers/model/applyDefaultsToPOJO */ \"(api)/../server/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js\");\nconst applyQueryMiddleware = __webpack_require__(/*! ./helpers/query/applyQueryMiddleware */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js\");\nconst applyHooks = __webpack_require__(/*! ./helpers/model/applyHooks */ \"(api)/../server/node_modules/mongoose/lib/helpers/model/applyHooks.js\");\nconst applyMethods = __webpack_require__(/*! ./helpers/model/applyMethods */ \"(api)/../server/node_modules/mongoose/lib/helpers/model/applyMethods.js\");\nconst applyProjection = __webpack_require__(/*! ./helpers/projection/applyProjection */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/applyProjection.js\");\nconst applySchemaCollation = __webpack_require__(/*! ./helpers/indexes/applySchemaCollation */ \"(api)/../server/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js\");\nconst applyStaticHooks = __webpack_require__(/*! ./helpers/model/applyStaticHooks */ \"(api)/../server/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js\");\nconst applyStatics = __webpack_require__(/*! ./helpers/model/applyStatics */ \"(api)/../server/node_modules/mongoose/lib/helpers/model/applyStatics.js\");\nconst applyWriteConcern = __webpack_require__(/*! ./helpers/schema/applyWriteConcern */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js\");\nconst assignVals = __webpack_require__(/*! ./helpers/populate/assignVals */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/assignVals.js\");\nconst castBulkWrite = __webpack_require__(/*! ./helpers/model/castBulkWrite */ \"(api)/../server/node_modules/mongoose/lib/helpers/model/castBulkWrite.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst createPopulateQueryFilter = __webpack_require__(/*! ./helpers/populate/createPopulateQueryFilter */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js\");\nconst decorateUpdateWithVersionKey = __webpack_require__(/*! ./helpers/update/decorateUpdateWithVersionKey */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js\");\nconst getDefaultBulkwriteResult = __webpack_require__(/*! ./helpers/getDefaultBulkwriteResult */ \"(api)/../server/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js\");\nconst getSchemaDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getSchemaDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\");\nconst discriminator = __webpack_require__(/*! ./helpers/model/discriminator */ \"(api)/../server/node_modules/mongoose/lib/helpers/model/discriminator.js\");\nconst firstKey = __webpack_require__(/*! ./helpers/firstKey */ \"(api)/../server/node_modules/mongoose/lib/helpers/firstKey.js\");\nconst each = __webpack_require__(/*! ./helpers/each */ \"(api)/../server/node_modules/mongoose/lib/helpers/each.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getConstructorName = __webpack_require__(/*! ./helpers/getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst getModelsMapForPopulate = __webpack_require__(/*! ./helpers/populate/getModelsMapForPopulate */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ./options */ \"(api)/../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst isDefaultIdIndex = __webpack_require__(/*! ./helpers/indexes/isDefaultIdIndex */ \"(api)/../server/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js\");\nconst isIndexEqual = __webpack_require__(/*! ./helpers/indexes/isIndexEqual */ \"(api)/../server/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js\");\nconst {\n  getRelatedDBIndexes,\n  getRelatedSchemaIndexes\n} = __webpack_require__(/*! ./helpers/indexes/getRelatedIndexes */ \"(api)/../server/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js\");\nconst isPathExcluded = __webpack_require__(/*! ./helpers/projection/isPathExcluded */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js\");\nconst decorateDiscriminatorIndexOptions = __webpack_require__(/*! ./helpers/indexes/decorateDiscriminatorIndexOptions */ \"(api)/../server/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js\");\nconst isPathSelectedInclusive = __webpack_require__(/*! ./helpers/projection/isPathSelectedInclusive */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./helpers/populate/leanPopulateMap */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst parallelLimit = __webpack_require__(/*! ./helpers/parallelLimit */ \"(api)/../server/node_modules/mongoose/lib/helpers/parallelLimit.js\");\nconst parentPaths = __webpack_require__(/*! ./helpers/path/parentPaths */ \"(api)/../server/node_modules/mongoose/lib/helpers/path/parentPaths.js\");\nconst prepareDiscriminatorPipeline = __webpack_require__(/*! ./helpers/aggregate/prepareDiscriminatorPipeline */ \"(api)/../server/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js\");\nconst pushNestedArrayPaths = __webpack_require__(/*! ./helpers/model/pushNestedArrayPaths */ \"(api)/../server/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js\");\nconst removeDeselectedForeignField = __webpack_require__(/*! ./helpers/populate/removeDeselectedForeignField */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js\");\nconst setDottedPath = __webpack_require__(/*! ./helpers/path/setDottedPath */ \"(api)/../server/node_modules/mongoose/lib/helpers/path/setDottedPath.js\");\nconst STATES = __webpack_require__(/*! ./connectionstate */ \"(api)/../server/node_modules/mongoose/lib/connectionstate.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nconst VERSION_WHERE = 1;\nconst VERSION_INC = 2;\nconst VERSION_ALL = VERSION_WHERE | VERSION_INC;\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst modelCollectionSymbol = Symbol('mongoose#Model#collection');\nconst modelDbSymbol = Symbol('mongoose#Model#db');\nconst modelSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").modelSymbol);\nconst subclassedSymbol = Symbol('mongoose#Model#subclassed');\n\nconst saveToObjectOptions = Object.assign({}, internalToObjectOptions, {\n  bson: true,\n  flattenObjectIds: false\n});\n\n/**\n * A Model is a class that's your primary tool for interacting with MongoDB.\n * An instance of a Model is called a [Document](https://mongoosejs.com/docs/api/document.html#Document).\n *\n * In Mongoose, the term \"Model\" refers to subclasses of the `mongoose.Model`\n * class. You should not use the `mongoose.Model` class directly. The\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) and\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()) functions\n * create subclasses of `mongoose.Model` as shown below.\n *\n * #### Example:\n *\n *     // `UserModel` is a \"Model\", a subclass of `mongoose.Model`.\n *     const UserModel = mongoose.model('User', new Schema({ name: String }));\n *\n *     // You can use a Model to create new documents using `new`:\n *     const userDoc = new UserModel({ name: 'Foo' });\n *     await userDoc.save();\n *\n *     // You also use a model to create queries:\n *     const userFromDb = await UserModel.findOne({ name: 'Foo' });\n *\n * @param {Object} doc values for initial set\n * @param {Object} [fields] optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()).\n * @param {Boolean} [skipId=false] optional boolean. If true, mongoose doesn't add an `_id` field to the document.\n * @inherits Document https://mongoosejs.com/docs/api/document.html\n * @event `error`: If listening to this event, 'error' is emitted when a document was saved and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.\n * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.\n * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.\n * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.\n * @api public\n */\n\nfunction Model(doc, fields, skipId) {\n  if (fields instanceof Schema) {\n    throw new TypeError('2nd argument to `Model` must be a POJO or string, ' +\n      '**not** a schema. Make sure you\\'re calling `mongoose.model()`, not ' +\n      '`mongoose.Model()`.');\n  }\n  Document.call(this, doc, fields, skipId);\n}\n\n/**\n * Inherits from Document.\n *\n * All Model.prototype features are available on\n * top level (non-sub) documents.\n * @api private\n */\n\nObject.setPrototypeOf(Model.prototype, Document.prototype);\nModel.prototype.$isMongooseModelPrototype = true;\n\n/**\n * Connection the model uses.\n *\n * @api public\n * @property db\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.db;\n\n/**\n * The collection instance this model uses.\n * A Mongoose collection is a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using `Model.collection` means you bypass Mongoose middleware, validation, and casting.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api public\n * @property collection\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.collection;\n\n/**\n * Internal collection the model uses.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api private\n * @property collection\n * @memberOf Model\n * @instance\n */\n\n\nModel.prototype.$__collection;\n\n/**\n * The name of the model\n *\n * @api public\n * @property modelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.modelName;\n\n/**\n * Additional properties to attach to the query when calling `save()` and\n * `isNew` is false.\n *\n * @api public\n * @property $where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$where;\n\n/**\n * If this is a discriminator model, `baseModelName` is the name of\n * the base model.\n *\n * @api public\n * @property baseModelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.baseModelName;\n\n/**\n * Event emitter that reports any errors that occurred. Useful for global error\n * handling.\n *\n * #### Example:\n *\n *     MyModel.events.on('error', err => console.log(err.message));\n *\n *     // Prints a 'CastError' because of the above handler\n *     await MyModel.findOne({ _id: 'Not a valid ObjectId' }).catch(noop);\n *\n * @api public\n * @property events\n * @fires error whenever any query or model function errors\n * @memberOf Model\n * @static\n */\n\nModel.events;\n\n/**\n * Compiled middleware for this model. Set in `applyHooks()`.\n *\n * @api private\n * @property _middleware\n * @memberOf Model\n * @static\n */\n\nModel._middleware;\n\n/*!\n * ignore\n */\n\nfunction _applyCustomWhere(doc, where) {\n  if (doc.$where == null) {\n    return;\n  }\n  for (const key of Object.keys(doc.$where)) {\n    where[key] = doc.$where[key];\n  }\n}\n\n/*!\n * ignore\n */\n\nModel.prototype.$__handleSave = function(options, callback) {\n  const saveOptions = {};\n\n  applyWriteConcern(this.$__schema, options);\n  if (typeof options.writeConcern !== 'undefined') {\n    saveOptions.writeConcern = {};\n    if ('w' in options.writeConcern) {\n      saveOptions.writeConcern.w = options.writeConcern.w;\n    }\n    if ('j' in options.writeConcern) {\n      saveOptions.writeConcern.j = options.writeConcern.j;\n    }\n    if ('wtimeout' in options.writeConcern) {\n      saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;\n    }\n  } else {\n    if ('w' in options) {\n      saveOptions.w = options.w;\n    }\n    if ('j' in options) {\n      saveOptions.j = options.j;\n    }\n    if ('wtimeout' in options) {\n      saveOptions.wtimeout = options.wtimeout;\n    }\n  }\n  if ('checkKeys' in options) {\n    saveOptions.checkKeys = options.checkKeys;\n  }\n\n  const session = this.$session();\n  const asyncLocalStorage = this[modelDbSymbol].base.transactionAsyncLocalStorage?.getStore();\n  if (session != null) {\n    saveOptions.session = session;\n  } else if (!options.hasOwnProperty('session') && asyncLocalStorage?.session != null) {\n    // Only set session from asyncLocalStorage if `session` option wasn't originally passed in options\n    saveOptions.session = asyncLocalStorage.session;\n  }\n\n  if (this.$isNew) {\n    // send entire doc\n    const obj = this.toObject(saveToObjectOptions);\n    if ((obj || {})._id === void 0) {\n      // documents must have an _id else mongoose won't know\n      // what to update later if more changes are made. the user\n      // wouldn't know what _id was generated by mongodb either\n      // nor would the ObjectId generated by mongodb necessarily\n      // match the schema definition.\n      immediate(function() {\n        callback(new MongooseError('document must have an _id before saving'));\n      });\n      return;\n    }\n\n    this.$__version(true, obj);\n    this[modelCollectionSymbol].insertOne(obj, saveOptions).then(\n      ret => callback(null, ret),\n      err => {\n        _setIsNew(this, true);\n\n        callback(err, null);\n      }\n    );\n\n    this.$__reset();\n    _setIsNew(this, false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n    return;\n  }\n\n  // Make sure we don't treat it as a new object on error,\n  // since it already exists\n  this.$__.inserting = false;\n  const delta = this.$__delta();\n  if (delta) {\n    if (delta instanceof MongooseError) {\n      callback(delta);\n      return;\n    }\n\n    const where = this.$__where(delta[0]);\n    if (where instanceof MongooseError) {\n      callback(where);\n      return;\n    }\n\n    _applyCustomWhere(this, where);\n    this[modelCollectionSymbol].updateOne(where, delta[1], saveOptions).then(\n      ret => {\n        ret.$where = where;\n        callback(null, ret);\n      },\n      err => {\n        this.$__undoReset();\n\n        callback(err);\n      }\n    );\n  } else {\n    const optionsWithCustomValues = Object.assign({}, options, saveOptions);\n    const where = this.$__where();\n    const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n    if (optimisticConcurrency && !Array.isArray(optimisticConcurrency)) {\n      const key = this.$__schema.options.versionKey;\n      const val = this.$__getValue(key);\n      if (val != null) {\n        where[key] = val;\n      }\n    }\n    this.constructor.collection.findOne(where, optionsWithCustomValues)\n      .then(documentExists => {\n        const matchedCount = !documentExists ? 0 : 1;\n        callback(null, { $where: where, matchedCount });\n      })\n      .catch(callback);\n    return;\n  }\n\n  // store the modified paths before the document is reset\n  this.$__.modifiedPaths = this.modifiedPaths();\n  this.$__reset();\n\n  _setIsNew(this, false);\n};\n\n/*!\n * ignore\n */\n\nModel.prototype.$__save = function(options, callback) {\n  this.$__handleSave(options, (error, result) => {\n    if (error) {\n      const hooks = this.$__schema.s.hooks;\n      return hooks.execPost('save:error', this, [this], { error: error }, (error) => {\n        callback(error, this);\n      });\n    }\n    let numAffected = 0;\n    const writeConcern = options != null ?\n      options.writeConcern != null ?\n        options.writeConcern.w :\n        options.w :\n      0;\n    if (writeConcern !== 0) {\n      // Skip checking if write succeeded if writeConcern is set to\n      // unacknowledged writes, because otherwise `numAffected` will always be 0\n      if (result != null) {\n        if (Array.isArray(result)) {\n          numAffected = result.length;\n        } else if (result.matchedCount != null) {\n          numAffected = result.matchedCount;\n        } else {\n          numAffected = result;\n        }\n      }\n\n      const versionBump = this.$__.version;\n      // was this an update that required a version bump?\n      if (versionBump && !this.$__.inserting) {\n        const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);\n        this.$__.version = undefined;\n        const key = this.$__schema.options.versionKey;\n        const version = this.$__getValue(key) || 0;\n        if (numAffected <= 0) {\n          // the update failed. pass an error back\n          this.$__undoReset();\n          const err = this.$__.$versionError ||\n            new VersionError(this, version, this.$__.modifiedPaths);\n          return callback(err);\n        }\n\n        // increment version if was successful\n        if (doIncrement) {\n          this.$__setValue(key, version + 1);\n        }\n      }\n      if (result != null && numAffected <= 0) {\n        this.$__undoReset();\n        error = new DocumentNotFoundError(result.$where,\n          this.constructor.modelName, numAffected, result);\n        const hooks = this.$__schema.s.hooks;\n        return hooks.execPost('save:error', this, [this], { error: error }, (error) => {\n          callback(error, this);\n        });\n      }\n    }\n    this.$__.saving = undefined;\n    this.$__.savedState = {};\n    this.$emit('save', this, numAffected);\n    this.constructor.emit('save', this, numAffected);\n    callback(null, this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction generateVersionError(doc, modifiedPaths) {\n  const key = doc.$__schema.options.versionKey;\n  if (!key) {\n    return null;\n  }\n  const version = doc.$__getValue(key) || 0;\n  return new VersionError(doc, version, modifiedPaths);\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation with just the modified paths if `isNew` is `false`.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] if `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#mongodb-limit-Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise}\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\nModel.prototype.save = async function save(options) {\n  if (typeof options === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.save() no longer accepts a callback');\n  }\n\n  let parallelSave;\n  this.$op = 'save';\n\n  if (this.$__.saving) {\n    parallelSave = new ParallelSaveError(this);\n  } else {\n    this.$__.saving = new ParallelSaveError(this);\n  }\n\n  options = new SaveOptions(options);\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n  if (this.$__.timestamps != null) {\n    options.timestamps = this.$__.timestamps;\n  }\n  this.$__.$versionError = generateVersionError(this, this.modifiedPaths());\n\n  if (parallelSave) {\n    this.$__handleReject(parallelSave);\n    throw parallelSave;\n  }\n\n  this.$__.saveOptions = options;\n\n  await new Promise((resolve, reject) => {\n    this.$__save(options, error => {\n      this.$__.saving = null;\n      this.$__.saveOptions = null;\n      this.$__.$versionError = null;\n      this.$op = null;\n      if (error != null) {\n        this.$__handleReject(error);\n        return reject(error);\n      }\n\n      resolve();\n    });\n  });\n\n  return this;\n};\n\nModel.prototype.$save = Model.prototype.save;\n\n/**\n * Determines whether versioning should be skipped for the given path\n *\n * @param {Document} self\n * @param {String} path\n * @return {Boolean} true if versioning should be skipped for the given path\n * @api private\n */\nfunction shouldSkipVersioning(self, path) {\n  const skipVersioning = self.$__schema.options.skipVersioning;\n  if (!skipVersioning) return false;\n\n  // Remove any array indexes from the path\n  path = path.replace(/\\.\\d+\\./, '.');\n\n  return skipVersioning[path];\n}\n\n/**\n * Apply the operation to the delta (update) clause as\n * well as track versioning for our where clause.\n *\n * @param {Document} self\n * @param {Object} where Unused\n * @param {Object} delta\n * @param {Object} data\n * @param {Mixed} val\n * @param {String} [op]\n * @api private\n */\n\nfunction operand(self, where, delta, data, val, op) {\n  // delta\n  op || (op = '$set');\n  if (!delta[op]) delta[op] = {};\n  delta[op][data.path] = val;\n  // disabled versioning?\n  if (self.$__schema.options.versionKey === false) return;\n\n  // path excluded from versioning?\n  if (shouldSkipVersioning(self, data.path)) return;\n\n  // already marked for versioning?\n  if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;\n\n  if (self.$__schema.options.optimisticConcurrency) {\n    return;\n  }\n\n  switch (op) {\n    case '$set':\n    case '$unset':\n    case '$pop':\n    case '$pull':\n    case '$pullAll':\n    case '$push':\n    case '$addToSet':\n    case '$inc':\n      break;\n    default:\n      // nothing to do\n      return;\n  }\n\n  // ensure updates sent with positional notation are\n  // editing the correct array element.\n  // only increment the version if an array position changes.\n  // modifying elements of an array is ok if position does not change.\n  if (op === '$push' || op === '$addToSet' || op === '$pullAll' || op === '$pull') {\n    if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n      increment.call(self);\n    } else {\n      self.$__.version = VERSION_INC;\n    }\n  } else if (/^\\$p/.test(op)) {\n    // potentially changing array positions\n    increment.call(self);\n  } else if (Array.isArray(val)) {\n    // $set an array\n    increment.call(self);\n  } else if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n    // now handling $set, $unset\n    // subpath of array\n    self.$__.version = VERSION_WHERE;\n  }\n}\n\n/**\n * Compiles an update and where clause for a `val` with _atomics.\n *\n * @param {Document} self\n * @param {Object} where\n * @param {Object} delta\n * @param {Object} data\n * @param {Array} value\n * @api private\n */\n\nfunction handleAtomics(self, where, delta, data, value) {\n  if (delta.$set && delta.$set[data.path]) {\n    // $set has precedence over other atomics\n    return;\n  }\n\n  if (typeof value.$__getAtomics === 'function') {\n    value.$__getAtomics().forEach(function(atomic) {\n      const op = atomic[0];\n      const val = atomic[1];\n      operand(self, where, delta, data, val, op);\n    });\n    return;\n  }\n\n  // legacy support for plugins\n\n  const atomics = value[arrayAtomicsSymbol];\n  const ops = Object.keys(atomics);\n  let i = ops.length;\n  let val;\n  let op;\n\n  if (i === 0) {\n    // $set\n\n    if (utils.isMongooseObject(value)) {\n      value = value.toObject({ depopulate: 1, _isNested: true });\n    } else if (value.valueOf) {\n      value = value.valueOf();\n    }\n\n    return operand(self, where, delta, data, value);\n  }\n\n  function iter(mem) {\n    return utils.isMongooseObject(mem)\n      ? mem.toObject({ depopulate: 1, _isNested: true })\n      : mem;\n  }\n\n  while (i--) {\n    op = ops[i];\n    val = atomics[op];\n\n    if (utils.isMongooseObject(val)) {\n      val = val.toObject({ depopulate: true, transform: false, _isNested: true });\n    } else if (Array.isArray(val)) {\n      val = val.map(iter);\n    } else if (val.valueOf) {\n      val = val.valueOf();\n    }\n\n    if (op === '$addToSet') {\n      val = { $each: val };\n    }\n\n    operand(self, where, delta, data, val, op);\n  }\n}\n\n/**\n * Produces a special query document of the modified properties used in updates.\n *\n * @api private\n * @method $__delta\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__delta = function() {\n  const dirty = this.$__dirty();\n\n  const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n  if (optimisticConcurrency) {\n    if (Array.isArray(optimisticConcurrency)) {\n      const optCon = new Set(optimisticConcurrency);\n      const modPaths = this.modifiedPaths();\n      if (modPaths.find(path => optCon.has(path))) {\n        this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;\n      }\n    } else {\n      this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;\n    }\n  }\n\n  if (!dirty.length && VERSION_ALL !== this.$__.version) {\n    return;\n  }\n  const where = {};\n  const delta = {};\n  const len = dirty.length;\n  const divergent = [];\n  let d = 0;\n\n  where._id = this._doc._id;\n  // If `_id` is an object, need to depopulate, but also need to be careful\n  // because `_id` can technically be null (see gh-6406)\n  if ((where && where._id && where._id.$__ || null) != null) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n  for (; d < len; ++d) {\n    const data = dirty[d];\n    let value = data.value;\n    const match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    const pop = this.$populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      const pathSplit = data.path.split('.');\n      const top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === 'undefined') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = '$';\n          data.path = pathSplit.join('.');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    // If this path is set to default, and either this path or one of\n    // its parents is excluded, don't treat this path as dirty.\n    if (this.$isDefault(data.path) && this.$__.selected) {\n      if (data.path.indexOf('.') === -1 && isPathExcluded(this.$__.selected, data.path)) {\n        continue;\n      }\n\n      const pathsToCheck = parentPaths(data.path);\n      if (pathsToCheck.find(path => isPathExcluded(this.$__.isSelected, path))) {\n        continue;\n      }\n    }\n\n    if (divergent.length) continue;\n    if (value === undefined) {\n      operand(this, where, delta, data, 1, '$unset');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (utils.isMongooseArray(value) && value.$path() && value[arrayAtomicsSymbol]) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[data.path] != null) {\n        const val = this.$__.primitiveAtomics[data.path];\n        const op = firstKey(val);\n        operand(this, where, delta, data, val[op], op);\n      } else {\n        value = clone(value, {\n          depopulate: true,\n          transform: false,\n          virtuals: false,\n          getters: false,\n          omitUndefined: true,\n          _isNested: true\n        });\n        operand(this, where, delta, data, value);\n      }\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  if (Object.keys(delta).length === 0) {\n    return [where, null];\n  }\n\n  return [where, delta];\n};\n\n/**\n * Determine if array was populated with some form of filter and is now\n * being updated in a manner which could overwrite data unintentionally.\n *\n * @see https://github.com/Automattic/mongoose/issues/1334\n * @param {Document} doc\n * @param {String} path\n * @param {Any} array\n * @return {String|undefined}\n * @api private\n */\n\nfunction checkDivergentArray(doc, path, array) {\n  // see if we populated this path\n  const pop = doc.$populated(path, true);\n\n  if (!pop && doc.$__.selected) {\n    // If any array was selected using an $elemMatch projection, we deny the update.\n    // NOTE: MongoDB only supports projected $elemMatch on top level array.\n    const top = path.split('.')[0];\n    if (doc.$__.selected[top + '.$']) {\n      return top;\n    }\n  }\n\n  if (!(pop && utils.isMongooseArray(array))) return;\n\n  // If the array was populated using options that prevented all\n  // documents from being returned (match, skip, limit) or they\n  // deselected the _id field, $pop and $set of the array are\n  // not safe operations. If _id was deselected, we do not know\n  // how to remove elements. $pop will pop off the _id from the end\n  // of the array in the db which is not guaranteed to be the\n  // same as the last element we have here. $set of the entire array\n  // would be similarly destructive as we never received all\n  // elements of the array and potentially would overwrite data.\n  const check = pop.options.match ||\n      pop.options.options && utils.object.hasOwnProperty(pop.options.options, 'limit') || // 0 is not permitted\n      pop.options.options && pop.options.options.skip || // 0 is permitted\n      pop.options.select && // deselected _id?\n      (pop.options.select._id === 0 ||\n      /\\s?-_id\\s?/.test(pop.options.select));\n\n  if (check) {\n    const atomics = array[arrayAtomicsSymbol];\n    if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {\n      return path;\n    }\n  }\n}\n\n/**\n * Appends versioning to the where and update clauses.\n *\n * @api private\n * @method $__version\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__version = function(where, delta) {\n  const key = this.$__schema.options.versionKey;\n  if (where === true) {\n    // this is an insert\n    if (key) {\n      setDottedPath(delta, key, 0);\n      this.$__setValue(key, 0);\n    }\n    return;\n  }\n\n  if (key === false) {\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n\n  if (!this.$__isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    const value = this.$__getValue(key);\n    if (value != null) where[key] = value;\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (get(delta.$set, key, null) != null) {\n      // Version key is getting set, means we'll increment the doc's version\n      // after a successful save, so we should set the incremented version so\n      // future saves don't fail (gh-5779)\n      ++delta.$set[key];\n    } else {\n      delta.$inc = delta.$inc || {};\n      delta.$inc[key] = 1;\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}\n\n/**\n * Signal that we desire an increment of this documents version.\n *\n * #### Example:\n *\n *     const doc = await Model.findById(id);\n *     doc.increment();\n *     await doc.save();\n *\n * @see versionKeys https://mongoosejs.com/docs/guide.html#versionKey\n * @memberOf Model\n * @method increment\n * @api public\n */\n\nModel.prototype.increment = increment;\n\n/**\n * Returns a query object\n *\n * @api private\n * @method $__where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__where = function _where(where) {\n  where || (where = {});\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this._doc._id === void 0) {\n    return new MongooseError('No _id found on document!');\n  }\n\n  return where;\n};\n\n/**\n * Removes this document from the db. Equivalent to `.remove()`.\n *\n * #### Example:\n *\n *     product = await product.deleteOne();\n *     await Product.findById(product._id); // null\n *\n * @return {Promise} Promise\n * @api public\n */\n\nModel.prototype.deleteOne = async function deleteOne(options) {\n  if (typeof options === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n\n  const res = await new Promise((resolve, reject) => {\n    this.$__deleteOne(options, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n\n  return res;\n};\n\n/*!\n * ignore\n */\n\nModel.prototype.$__deleteOne = function $__deleteOne(options, cb) {\n  if (this.$__.isDeleted) {\n    return immediate(() => cb(null, this));\n  }\n\n  const where = this.$__where();\n  if (where instanceof MongooseError) {\n    return cb(where);\n  }\n\n  _applyCustomWhere(this, where);\n\n  const session = this.$session();\n  if (!options.hasOwnProperty('session')) {\n    options.session = session;\n  }\n\n  this[modelCollectionSymbol].deleteOne(where, options).then(\n    () => {\n      this.$__.isDeleted = true;\n      this.$emit('deleteOne', this);\n      this.constructor.emit('deleteOne', this);\n      return cb(null, this);\n    },\n    err => {\n      this.$__.isDeleted = false;\n      cb(err);\n    }\n  );\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method $model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.$model = function $model(name) {\n  if (arguments.length === 0) {\n    return this.constructor;\n  }\n  return this[modelDbSymbol].model(name);\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.model = Model.prototype.$model;\n\n/**\n * Returns a document with `_id` only if at least one document exists in the database that matches\n * the given `filter`, and `null` otherwise.\n *\n * Under the hood, `MyModel.exists({ answer: 42 })` is equivalent to\n * `MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean()`\n *\n * #### Example:\n *\n *     await Character.deleteMany({});\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     await Character.exists({ name: /picard/i }); // { _id: ... }\n *     await Character.exists({ name: /riker/i }); // null\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * @param {Object} filter\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n */\n\nModel.exists = function exists(filter, options) {\n  _checkContext(this, 'exists');\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.exists() no longer accepts a callback');\n  }\n\n  const query = this.findOne(filter).\n    select({ _id: 1 }).\n    lean().\n    setOptions(options);\n\n  return query;\n};\n\n/**\n * Adds a discriminator type.\n *\n * #### Example:\n *\n *     function BaseSchema() {\n *       Schema.apply(this, arguments);\n *\n *       this.add({\n *         name: String,\n *         createdAt: Date\n *       });\n *     }\n *     util.inherits(BaseSchema, Schema);\n *\n *     const PersonSchema = new BaseSchema();\n *     const BossSchema = new BaseSchema({ department: String });\n *\n *     const Person = mongoose.model('Person', PersonSchema);\n *     const Boss = Person.discriminator('Boss', BossSchema);\n *     new Boss().__t; // \"Boss\". `__t` is the default `discriminatorKey`\n *\n *     const employeeSchema = new Schema({ boss: ObjectId });\n *     const Employee = Person.discriminator('Employee', employeeSchema, 'staff');\n *     new Employee().__t; // \"staff\" because of 3rd argument above\n *\n * @param {String} name discriminator model name\n * @param {Schema} schema discriminator model schema\n * @param {Object|String} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Model} The newly created discriminator model\n * @api public\n */\n\nModel.discriminator = function(name, schema, options) {\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = utils.getFunctionName(model);\n    if (!(model.prototype instanceof Model)) {\n      throw new MongooseError('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  const mergePlugins = typeof options.mergePlugins === 'boolean' ? options.mergePlugins : true;\n\n  _checkContext(this, 'discriminator');\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n  if (schema instanceof Schema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks);\n  if (this.db.models[name] && !schema.options.overwriteModels) {\n    throw new OverwriteModelError(name);\n  }\n\n  schema.$isRootDiscriminator = true;\n  schema.$globalPluginsApplied = true;\n\n  model = this.db.model(model || name, schema, this.$__collection.name);\n  this.discriminators[name] = model;\n  const d = this.discriminators[name];\n  Object.setPrototypeOf(d.prototype, this.prototype);\n  Object.defineProperty(d, 'baseModelName', {\n    value: this.modelName,\n    configurable: true,\n    writable: false\n  });\n\n  // apply methods and statics\n  applyMethods(d, schema);\n  applyStatics(d, schema);\n\n  if (this[subclassedSymbol] != null) {\n    for (const submodel of this[subclassedSymbol]) {\n      submodel.discriminators = submodel.discriminators || {};\n      submodel.discriminators[name] =\n        model.__subclass(model.db, schema, submodel.collection.name);\n    }\n  }\n\n  return d;\n};\n\n/**\n * Make sure `this` is a model\n * @api private\n */\n\nfunction _checkContext(ctx, fnName) {\n  // Check context, because it is easy to mistakenly type\n  // `new Model.discriminator()` and get an incomprehensible error\n  if (ctx == null || ctx === global) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are calling `MyModel.' + fnName + '()` ' +\n      'where `MyModel` is a Mongoose model.');\n  } else if (ctx[modelSymbol] == null) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are not calling ' +\n      '`new Model.' + fnName + '()`');\n  }\n}\n\n// Model (class) features\n\n/*!\n * Give the constructor the ability to emit events.\n */\n\nfor (const i in EventEmitter.prototype) {\n  Model[i] = EventEmitter.prototype[i];\n}\n\n/**\n * This function is responsible for building [indexes](https://www.mongodb.com/docs/manual/indexes/),\n * unless [`autoIndex`](https://mongoosejs.com/docs/guide.html#autoIndex) is turned off.\n *\n * Mongoose calls this function automatically when a model is created using\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) or\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()), so you\n * don't need to call `init()` to trigger index builds.\n *\n * However, you _may_ need to call `init()`  to get back a promise that will resolve when your indexes are finished.\n * Calling `await Model.init()` is helpful if you need to wait for indexes to build before continuing.\n * For example, if you want to wait for unique indexes to build before continuing with a test case.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     // This calls `Event.init()` implicitly, so you don't need to call\n *     // `Event.init()` on your own.\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     await Event.init();\n *     console.log('Indexes are done building!');\n *\n * @api public\n * @returns {Promise}\n */\n\nModel.init = function init() {\n  _checkContext(this, 'init');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.init() no longer accepts a callback');\n  }\n\n  this.schema.emit('init', this);\n\n  if (this.$init != null) {\n    return this.$init;\n  }\n\n  const conn = this.db;\n  const _ensureIndexes = async() => {\n    const autoIndex = utils.getOption(\n      'autoIndex',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoIndex) {\n      return;\n    }\n    return await this.ensureIndexes({ _automatic: true });\n  };\n  const _createCollection = async() => {\n    if ((conn.readyState === STATES.connecting || conn.readyState === STATES.disconnected) && conn._shouldBufferCommands()) {\n      await new Promise(resolve => {\n        conn._queue.push({ fn: resolve });\n      });\n    }\n    const autoCreate = utils.getOption(\n      'autoCreate',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoCreate) {\n      return;\n    }\n    return await this.createCollection();\n  };\n\n  this.$init = _createCollection().then(() => _ensureIndexes());\n\n  const _catch = this.$init.catch;\n  const _this = this;\n  this.$init.catch = function() {\n    _this.$caught = true;\n    return _catch.apply(_this.$init, arguments);\n  };\n\n  return this.$init;\n};\n\n\n/**\n * Create the collection for this model. By default, if no indexes are specified,\n * mongoose will not create the collection for the model until any documents are\n * created. Use this method to create the collection explicitly.\n *\n * Note 1: You may need to call this before starting a transaction\n * See https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-operations\n *\n * Note 2: You don't have to call this if your schema contains index or unique field.\n * In that case, just use `Model.init()`\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String })\n *     const User = mongoose.model('User', userSchema);\n *\n *     User.createCollection().then(function(collection) {\n *       console.log('Collection is created!');\n *     });\n *\n * @api public\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @returns {Promise}\n */\n\nModel.createCollection = async function createCollection(options) {\n  _checkContext(this, 'createCollection');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createCollection() no longer accepts a callback');\n  }\n\n  const collectionOptions = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collectionOptions;\n  if (collectionOptions != null) {\n    options = Object.assign({}, collectionOptions, options);\n  }\n\n  const schemaCollation = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collation;\n  if (schemaCollation != null) {\n    options = Object.assign({ collation: schemaCollation }, options);\n  }\n  const capped = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.capped;\n  if (capped != null) {\n    if (typeof capped === 'number') {\n      options = Object.assign({ capped: true, size: capped }, options);\n    } else if (typeof capped === 'object') {\n      options = Object.assign({ capped: true }, capped, options);\n    }\n  }\n  const timeseries = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.timeseries;\n  if (timeseries != null) {\n    options = Object.assign({ timeseries }, options);\n    if (options.expireAfterSeconds != null) {\n      // do nothing\n    } else if (options.expires != null) {\n      utils.expires(options);\n    } else if (this.schema.options.expireAfterSeconds != null) {\n      options.expireAfterSeconds = this.schema.options.expireAfterSeconds;\n    } else if (this.schema.options.expires != null) {\n      options.expires = this.schema.options.expires;\n      utils.expires(options);\n    }\n  }\n\n  const clusteredIndex = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.clusteredIndex;\n  if (clusteredIndex != null) {\n    options = Object.assign({ clusteredIndex: { ...clusteredIndex, unique: true } }, options);\n  }\n\n  try {\n    await this.db.createCollection(this.$__collection.collectionName, options);\n  } catch (err) {\n\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      throw err;\n    }\n  }\n  return this.$__collection;\n};\n\n/**\n * Makes the indexes in MongoDB match the indexes defined in this model's\n * schema. This function will drop any indexes that are not defined in\n * the model's schema except the `_id` index, and build any indexes that\n * are in your schema but not in MongoDB.\n *\n * See the [introductory blog post](https://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes)\n * for more information.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.collection.createIndex({ age: 1 }); // Index is not in schema\n *     // Will drop the 'age' index and create an index on `name`\n *     await Customer.syncIndexes();\n *\n * You should be careful about running `syncIndexes()` on production applications under heavy load,\n * because index builds are expensive operations, and unexpected index drops can lead to degraded\n * performance. Before running `syncIndexes()`, you can use the [`diffIndexes()` function](#Model.diffIndexes())\n * to check what indexes `syncIndexes()` will drop and create.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of strings containing names of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options] options to pass to `ensureIndexes()`\n * @param {Boolean} [options.background=null] if specified, overrides each index's `background` property\n * @return {Promise}\n * @api public\n */\n\nModel.syncIndexes = async function syncIndexes(options) {\n  _checkContext(this, 'syncIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const model = this;\n\n  try {\n    await model.createCollection();\n  } catch (err) {\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      throw err;\n    }\n  }\n\n  const diffIndexesResult = await model.diffIndexes();\n  const dropped = await model.cleanIndexes({ ...options, toDrop: diffIndexesResult.toDrop });\n  await model.createIndexes({ ...options, toCreate: diffIndexesResult.toCreate });\n\n  return dropped;\n};\n\n/**\n * Does a dry-run of `Model.syncIndexes()`, returning the indexes that `syncIndexes()` would drop and create if you were to run `syncIndexes()`.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of strings containing names of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options]\n * @return {Promise<Object>} contains the indexes that would be dropped in MongoDB and indexes that would be created in MongoDB as `{ toDrop: string[], toCreate: string[] }`.\n */\n\nModel.diffIndexes = async function diffIndexes() {\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const model = this;\n\n  let dbIndexes = await model.listIndexes().catch(err => {\n    if (err.codeName == 'NamespaceNotFound') {\n      return undefined;\n    }\n    throw err;\n  });\n  if (dbIndexes === undefined) {\n    dbIndexes = [];\n  }\n  dbIndexes = getRelatedDBIndexes(model, dbIndexes);\n\n  const schema = model.schema;\n  const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());\n\n  const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);\n  const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop);\n\n  return { toDrop, toCreate };\n};\n\nfunction getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop) {\n  const toCreate = [];\n\n  for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n    let found = false;\n\n    const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n\n    for (const index of dbIndexes) {\n      if (isDefaultIdIndex(index)) {\n        continue;\n      }\n      if (\n        isIndexEqual(schemaIndexKeysObject, options, index) &&\n        !toDrop.includes(index.name)\n      ) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      toCreate.push(schemaIndexKeysObject);\n    }\n  }\n\n  return toCreate;\n}\n\nfunction getIndexesToDrop(schema, schemaIndexes, dbIndexes) {\n  const toDrop = [];\n\n  for (const dbIndex of dbIndexes) {\n    let found = false;\n    // Never try to drop `_id` index, MongoDB server doesn't allow it\n    if (isDefaultIdIndex(dbIndex)) {\n      continue;\n    }\n\n    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n      const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n      applySchemaCollation(schemaIndexKeysObject, options, schema.options);\n\n      if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      toDrop.push(dbIndex.name);\n    }\n  }\n\n  return toDrop;\n}\n/**\n * Deletes all indexes that aren't defined in this model's schema. Used by\n * `syncIndexes()`.\n *\n * The returned promise resolves to a list of the dropped indexes' names as an array\n *\n * @param {Function} [callback] optional callback\n * @return {Promise|undefined} Returns `undefined` if callback is specified, returns a promise if no callback.\n * @api public\n */\n\nModel.cleanIndexes = async function cleanIndexes(options) {\n  _checkContext(this, 'cleanIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.cleanIndexes() no longer accepts a callback');\n  }\n  const model = this;\n\n  const collection = model.$__collection;\n\n  if (Array.isArray(options && options.toDrop)) {\n    const res = await _dropIndexes(options.toDrop, collection);\n    return res;\n  }\n\n  const res = await model.diffIndexes();\n  return await _dropIndexes(res.toDrop, collection);\n};\n\nasync function _dropIndexes(toDrop, collection) {\n  if (toDrop.length === 0) {\n    return [];\n  }\n\n  await Promise.all(toDrop.map(indexName => collection.dropIndex(indexName)));\n  return toDrop;\n}\n\n/**\n * Lists the indexes currently defined in MongoDB. This may or may not be\n * the same as the indexes defined in your schema depending on whether you\n * use the [`autoIndex` option](https://mongoosejs.com/docs/guide.html#autoIndex) and if you\n * build indexes manually.\n *\n * @return {Promise}\n * @api public\n */\n\nModel.listIndexes = async function listIndexes() {\n  _checkContext(this, 'listIndexes');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.listIndexes() no longer accepts a callback');\n  }\n\n  if (this.$__collection.buffer) {\n    await new Promise(resolve => {\n      this.$__collection.addQueue(resolve);\n    });\n  }\n\n  return this.$__collection.listIndexes().toArray();\n};\n\n/**\n * Sends `createIndex` commands to mongo for each index declared in the schema.\n * The `createIndex` commands are sent in series.\n *\n * #### Example:\n *\n *     Event.ensureIndexes(function (err) {\n *       if (err) return handleError(err);\n *     });\n *\n * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.on('index', function (err) {\n *       if (err) console.error(err); // error occurred during index creation\n *     })\n *\n * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.ensureIndexes = async function ensureIndexes(options) {\n  _checkContext(this, 'ensureIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.ensureIndexes() no longer accepts a callback');\n  }\n\n  await new Promise((resolve, reject) => {\n    _ensureIndexes(this, options, (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Similar to `ensureIndexes()`, except for it uses the [`createIndex`](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createIndex)\n * function.\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.createIndexes = async function createIndexes(options) {\n  _checkContext(this, 'createIndexes');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createIndexes() no longer accepts a callback');\n  }\n\n  return this.ensureIndexes(options);\n};\n\n\n/*!\n * ignore\n */\n\nfunction _ensureIndexes(model, options, callback) {\n  const indexes = model.schema.indexes();\n  let indexError;\n\n  options = options || {};\n  const done = function(err) {\n    if (err && !model.$caught) {\n      model.emit('error', err);\n    }\n    model.emit('index', err || indexError);\n    callback && callback(err || indexError);\n  };\n\n  for (const index of indexes) {\n    if (isDefaultIdIndex(index)) {\n      utils.warn('mongoose: Cannot specify a custom index on `_id` for ' +\n        'model name \"' + model.modelName + '\", ' +\n        'MongoDB does not allow overwriting the default `_id` index. See ' +\n        'https://bit.ly/mongodb-id-index');\n    }\n  }\n\n  if (!indexes.length) {\n    immediate(function() {\n      done();\n    });\n    return;\n  }\n  // Indexes are created one-by-one to support how MongoDB < 2.4 deals\n  // with background indexes.\n\n  const indexSingleDone = function(err, fields, options, name) {\n    model.emit('index-single-done', err, fields, options, name);\n  };\n  const indexSingleStart = function(fields, options) {\n    model.emit('index-single-start', fields, options);\n  };\n\n  const baseSchema = model.schema._baseSchema;\n  const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];\n\n  immediate(function() {\n    // If buffering is off, do this manually.\n    if (options._automatic && !model.collection.collection) {\n      model.collection.addQueue(create, []);\n    } else {\n      create();\n    }\n  });\n\n\n  function create() {\n    if (options._automatic) {\n      if (model.schema.options.autoIndex === false ||\n          (model.schema.options.autoIndex == null && model.db.config.autoIndex === false)) {\n        return done();\n      }\n    }\n\n    const index = indexes.shift();\n    if (!index) {\n      return done();\n    }\n    if (options._automatic && index[1]._autoIndex === false) {\n      return create();\n    }\n\n    if (baseSchemaIndexes.find(i => utils.deepEqual(i, index))) {\n      return create();\n    }\n\n    const indexFields = clone(index[0]);\n    const indexOptions = clone(index[1]);\n\n    delete indexOptions._autoIndex;\n    decorateDiscriminatorIndexOptions(model.schema, indexOptions);\n    applyWriteConcern(model.schema, indexOptions);\n    applySchemaCollation(indexFields, indexOptions, model.schema.options);\n\n    indexSingleStart(indexFields, options);\n\n    if ('background' in options) {\n      indexOptions.background = options.background;\n    }\n\n    if ('toCreate' in options) {\n      if (options.toCreate.length === 0) {\n        return done();\n      }\n    }\n\n    model.collection.createIndex(indexFields, indexOptions).then(\n      name => {\n        indexSingleDone(null, indexFields, indexOptions, name);\n        create();\n      },\n      err => {\n        if (!indexError) {\n          indexError = err;\n        }\n        if (!model.$caught) {\n          model.emit('error', err);\n        }\n\n        indexSingleDone(err, indexFields, indexOptions);\n        create();\n      }\n    );\n  }\n}\n\n/**\n * Schema the model uses.\n *\n * @property schema\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.schema;\n\n/**\n * Connection instance the model uses.\n *\n * @property db\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.db;\n\n/**\n * Collection the model uses.\n *\n * @property collection\n * @api public\n * @memberOf Model\n */\n\nModel.collection;\n\n/**\n * Internal collection the model uses.\n *\n * @property collection\n * @api private\n * @memberOf Model\n */\nModel.$__collection;\n\n/**\n * Base Mongoose instance the model uses.\n *\n * @property base\n * @api public\n * @memberOf Model\n */\n\nModel.base;\n\n/**\n * Registered discriminators for this model.\n *\n * @property discriminators\n * @api public\n * @memberOf Model\n */\n\nModel.discriminators;\n\n/**\n * Translate any aliases fields/conditions so the final query or document object is pure\n *\n * #### Example:\n *\n *     await Character.find(Character.translateAliases({\n *        '': 'Eddard Stark' // Alias for 'name'\n *     });\n *\n * By default, `translateAliases()` overwrites raw fields with aliased fields.\n * So if `n` is an alias for `name`, `{ n: 'alias', name: 'raw' }` will resolve to `{ name: 'alias' }`.\n * However, you can set the `errorOnDuplicates` option to throw an error if there are potentially conflicting paths.\n * The `translateAliases` option for queries uses `errorOnDuplicates`.\n *\n * #### Note:\n *\n * Only translate arguments of object type anything else is returned raw\n *\n * @param {Object} fields fields/conditions that may contain aliased keys\n * @param {Boolean} [errorOnDuplicates] if true, throw an error if there's both a key and an alias for that key in `fields`\n * @return {Object} the translated 'pure' fields/conditions\n */\nModel.translateAliases = function translateAliases(fields, errorOnDuplicates) {\n  _checkContext(this, 'translateAliases');\n\n  const translate = (key, value) => {\n    let alias;\n    const translated = [];\n    const fieldKeys = key.split('.');\n    let currentSchema = this.schema;\n    for (const i in fieldKeys) {\n      const name = fieldKeys[i];\n      if (currentSchema && currentSchema.aliases[name]) {\n        alias = currentSchema.aliases[name];\n        if (errorOnDuplicates && alias in fields) {\n          throw new MongooseError(`Provided object has both field \"${name}\" and its alias \"${alias}\"`);\n        }\n        // Alias found,\n        translated.push(alias);\n      } else {\n        alias = name;\n        // Alias not found, so treat as un-aliased key\n        translated.push(name);\n      }\n\n      // Check if aliased path is a schema\n      if (currentSchema && currentSchema.paths[alias]) {\n        currentSchema = currentSchema.paths[alias].schema;\n      }\n      else\n        currentSchema = null;\n    }\n\n    const translatedKey = translated.join('.');\n    if (fields instanceof Map)\n      fields.set(translatedKey, value);\n    else\n      fields[translatedKey] = value;\n\n    if (translatedKey !== key) {\n      // We'll be using the translated key instead\n      if (fields instanceof Map) {\n        // Delete from map\n        fields.delete(key);\n      } else {\n        // Delete from object\n        delete fields[key]; // We'll be using the translated key instead\n      }\n    }\n    return fields;\n  };\n\n  if (typeof fields === 'object') {\n    // Fields is an object (query conditions or document fields)\n    if (fields instanceof Map) {\n      // A Map was supplied\n      for (const field of new Map(fields)) {\n        fields = translate(field[0], field[1]);\n      }\n    } else {\n      // Infer a regular object was supplied\n      for (const key of Object.keys(fields)) {\n        fields = translate(key, fields[key]);\n        if (key[0] === '$') {\n          if (Array.isArray(fields[key])) {\n            for (const i in fields[key]) {\n              // Recursively translate nested queries\n              fields[key][i] = this.translateAliases(fields[key][i]);\n            }\n          } else {\n            this.translateAliases(fields[key]);\n          }\n        }\n      }\n    }\n\n    return fields;\n  } else {\n    // Don't know typeof fields\n    return fields;\n  }\n};\n\n/**\n * Deletes the first document that matches `conditions` from the collection.\n * It returns an object with the property `deletedCount` indicating how many documents were deleted.\n * Behaves like `remove()`, but deletes at most one document regardless of the\n * `single` option.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' }); // returns {deletedCount: 1}\n *\n * #### Note:\n *\n * This function triggers `deleteOne` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteOne = function deleteOne(conditions, options) {\n  _checkContext(this, 'deleteOne');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteOne(conditions);\n};\n\n/**\n * Deletes all of the documents that match `conditions` from the collection.\n * It returns an object with the property `deletedCount` containing the number of documents deleted.\n * Behaves like `remove()`, but deletes all documents that match `conditions`\n * regardless of the `single` option.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }); // returns {deletedCount: x} where x is the number of documents deleted.\n *\n * #### Note:\n *\n * This function triggers `deleteMany` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteMany = function deleteMany(conditions, options) {\n  _checkContext(this, 'deleteMany');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.deleteMany() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteMany(conditions);\n};\n\n/**\n * Finds documents.\n *\n * Mongoose casts the `filter` to match the model's schema before the command is sent.\n * See our [query casting tutorial](https://mongoosejs.com/docs/tutorials/query_casting.html) for\n * more information on how Mongoose casts `filter`.\n *\n * #### Example:\n *\n *     // find all documents\n *     await MyModel.find({});\n *\n *     // find all documents named john and at least 18\n *     await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec();\n *\n *     // executes, name LIKE john and only selecting the \"name\" and \"friends\" fields\n *     await MyModel.find({ name: /john/i }, 'name friends').exec();\n *\n *     // passing options\n *     await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec();\n *\n * @param {Object|ObjectId} filter\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see query casting https://mongoosejs.com/docs/tutorials/query_casting.html\n * @api public\n */\n\nModel.find = function find(conditions, projection, options) {\n  _checkContext(this, 'find');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.find() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.find(conditions);\n};\n\n/**\n * Finds a single document by its _id field. `findById(id)` is almost*\n * equivalent to `findOne({ _id: id })`. If you want to query by a document's\n * `_id`, use `findById()` instead of `findOne()`.\n *\n * The `id` is cast based on the Schema before sending the command.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * \\* Except for how it treats `undefined`. If you use `findOne()`, you'll see\n * that `findOne(undefined)` and `findOne({ _id: undefined })` are equivalent\n * to `findOne({})` and return arbitrary documents. However, mongoose\n * translates `findById(undefined)` into `findOne({ _id: null })`.\n *\n * #### Example:\n *\n *     // Find the adventure with the given `id`, or `null` if not found\n *     await Adventure.findById(id).exec();\n *\n *     // select only the adventures name and length\n *     await Adventure.findById(id, 'name length').exec();\n *\n * @param {Any} id value of `_id` to query by\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @see findById in Mongoose https://masteringjs.io/tutorials/mongoose/find-by-id\n * @api public\n */\n\nModel.findById = function findById(id, projection, options) {\n  _checkContext(this, 'findById');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findById() no longer accepts a callback');\n  }\n\n  if (typeof id === 'undefined') {\n    id = null;\n  }\n\n  return this.findOne({ _id: id }, projection, options);\n};\n\n/**\n * Finds one document.\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `findById()` instead.\n *\n * #### Example:\n *\n *     // Find one adventure whose `country` is 'Croatia', otherwise `null`\n *     await Adventure.findOne({ country: 'Croatia' }).exec();\n *\n *     // Model.findOne() no longer accepts a callback\n *\n *     // Select only the adventures name and length\n *     await Adventure.findOne({ country: 'Croatia' }, 'name length').exec();\n *\n * @param {Object} [conditions]\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @api public\n */\n\nModel.findOne = function findOne(conditions, projection, options) {\n  _checkContext(this, 'findOne');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.findOne(conditions);\n};\n\n/**\n * Estimates the number of documents in the MongoDB collection. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * #### Example:\n *\n *     const numAdventures = await Adventure.estimatedDocumentCount();\n *\n * @param {Object} [options]\n * @return {Query}\n * @api public\n */\n\nModel.estimatedDocumentCount = function estimatedDocumentCount(options) {\n  _checkContext(this, 'estimatedDocumentCount');\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.estimatedDocumentCount(options);\n};\n\n/**\n * Counts number of documents matching `filter` in a database collection.\n *\n * #### Example:\n *\n *     Adventure.countDocuments({ type: 'jungle' }, function (err, count) {\n *       console.log('there are %d jungle adventures', count);\n *     });\n *\n * If you want to count all documents in a large collection,\n * use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/model.html#Model.estimatedDocumentCount())\n * instead. If you call `countDocuments({})`, MongoDB will always execute\n * a full collection scan and **not** use any indexes.\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} filter\n * @return {Query}\n * @api public\n */\n\nModel.countDocuments = function countDocuments(conditions, options) {\n  _checkContext(this, 'countDocuments');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.countDocuments() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  if (options != null) {\n    mq.setOptions(options);\n  }\n\n  return mq.countDocuments(conditions);\n};\n\n/**\n * Counts number of documents that match `filter` in a database collection.\n *\n * This method is deprecated. If you want to count the number of documents in\n * a collection, e.g. `count({})`, use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/model.html#Model.estimatedDocumentCount())\n * instead. Otherwise, use the [`countDocuments()`](https://mongoosejs.com/docs/api/model.html#Model.countDocuments()) function instead.\n *\n * #### Example:\n *\n *     const count = await Adventure.count({ type: 'jungle' });\n *     console.log('there are %d jungle adventures', count);\n *\n * @deprecated\n * @param {Object} [filter]\n * @return {Query}\n * @api public\n */\n\nModel.count = function count(conditions) {\n  _checkContext(this, 'count');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.count() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.count(conditions);\n};\n\n/**\n * Creates a Query for a `distinct` operation.\n *\n * #### Example:\n *\n *     const query = Link.distinct('url');\n *     query.exec();\n *\n * @param {String} field\n * @param {Object} [conditions] optional\n * @return {Query}\n * @api public\n */\n\nModel.distinct = function distinct(field, conditions) {\n  _checkContext(this, 'distinct');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.distinct() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.distinct(field, conditions);\n};\n\n/**\n * Creates a Query, applies the passed conditions, and returns the Query.\n *\n * For example, instead of writing:\n *\n *     User.find({ age: { $gte: 21, $lte: 65 } });\n *\n * we can instead write:\n *\n *     User.where('age').gte(21).lte(65).exec();\n *\n * Since the Query class also supports `where` you can continue chaining\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     ... etc\n *\n * @param {String} path\n * @param {Object} [val] optional value\n * @return {Query}\n * @api public\n */\n\nModel.where = function where(path, val) {\n  _checkContext(this, 'where');\n\n  void val; // eslint\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.where.apply(mq, arguments);\n};\n\n/**\n * Creates a `Query` and specifies a `$where` condition.\n *\n * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n *\n *     Blog.$where('this.username.indexOf(\"val\") !== -1').exec(function (err, docs) {});\n *\n * @param {String|Function} argument is a javascript string or anonymous function\n * @method $where\n * @memberOf Model\n * @return {Query}\n * @see Query.$where https://mongoosejs.com/docs/api/query.html#Query.prototype.$where\n * @api public\n */\n\nModel.$where = function $where() {\n  _checkContext(this, '$where');\n\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.$where.apply(mq, arguments);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes if `callback` is passed else a Query object is returned.\n *\n * #### Example:\n *\n *     A.findOneAndUpdate(conditions, update, options)  // returns Query\n *     A.findOneAndUpdate(conditions, update)           // returns Query\n *     A.findOneAndUpdate()                             // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     const query = { name: 'borne' };\n *     Model.findOneAndUpdate(query, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options)\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation that\n * you can enable by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id);\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} [conditions]\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.overwrite=false] If set to `true`, Mongoose will convert this `findOneAndUpdate()` to a `findOneAndReplace()`. This option is deprecated and only supported for backwards compatiblity.\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.fields] Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findOneAndUpdate = function(conditions, update, options) {\n  _checkContext(this, 'findOneAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndUpdate() no longer accepts a callback');\n  }\n\n  if (arguments.length === 1) {\n    update = conditions;\n    conditions = null;\n    options = null;\n  }\n\n  let fields;\n  if (options) {\n    fields = options.fields || options.projection;\n  }\n\n  update = clone(update, {\n    depopulate: true,\n    _isNested: true\n  });\n\n  decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndUpdate(conditions, update, options);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command by a document's _id field.\n * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.\n *\n * Finds a matching document, updates it according to the `update` arg,\n * passing any `options`, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Example:\n *\n *     A.findByIdAndUpdate(id, update, options)  // returns Query\n *     A.findByIdAndUpdate(id, update)           // returns Query\n *     A.findByIdAndUpdate()                     // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options)\n *\n * This helps prevent accidentally overwriting your document with `{ name: 'jason bourne' }`.\n * To prevent this behaviour, see the `overwrite` option\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.overwrite=false] If set to `true`, Mongoose will convert this `findByIdAndUpdate()` to a `findByIdAndReplace()`. This option is deprecated and only supported for backwards compatiblity.\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Model.findOneAndUpdate https://mongoosejs.com/docs/api/model.html#Model.findOneAndUpdate()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findByIdAndUpdate = function(id, update, options) {\n  _checkContext(this, 'findByIdAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findByIdAndUpdate() no longer accepts a callback');\n  }\n\n  // if a model is passed in instead of an id\n  if (id instanceof Document) {\n    id = id._id;\n  }\n\n  return this.findOneAndUpdate.call(this, { _id: id }, update, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * This function differs slightly from `Model.findOneAndRemove()` in that\n * `findOneAndRemove()` becomes a [MongoDB `findAndModify()` command](https://www.mongodb.com/docs/manual/reference/method/db.collection.findAndModify/),\n * as opposed to a `findOneAndDelete()` command. For most mongoose use cases,\n * this distinction is purely pedantic. You should use `findOneAndDelete()`\n * unless you have a good reason not to.\n *\n * #### Example:\n *\n *     A.findOneAndDelete(conditions, options)  // return Query\n *     A.findOneAndDelete(conditions) // returns Query\n *     A.findOneAndDelete()           // returns Query\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndDelete = function(conditions, options) {\n  _checkContext(this, 'findOneAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOneAndDelete() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndDelete(conditions, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command by a document's _id field.\n * In other words, `findByIdAndDelete(id)` is a shorthand for\n * `findOneAndDelete({ _id: id })`.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Model.findOneAndRemove https://mongoosejs.com/docs/api/model.html#Model.findOneAndRemove()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n */\n\nModel.findByIdAndDelete = function(id, options) {\n  _checkContext(this, 'findByIdAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findByIdAndDelete() no longer accepts a callback');\n  }\n\n  return this.findOneAndDelete({ _id: id }, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndReplace()` command.\n *\n * Finds a matching document, replaces it with the provided doc, and returns the document.\n *\n * This function triggers the following query middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Example:\n *\n *     A.findOneAndReplace(filter, replacement, options)  // return Query\n *     A.findOneAndReplace(filter, replacement) // returns Query\n *     A.findOneAndReplace()                    // returns Query\n *\n * @param {Object} filter Replace the first document that matches this filter\n * @param {Object} [replacement] Replace with this document\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndReplace = function(filter, replacement, options) {\n  _checkContext(this, 'findOneAndReplace');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndReplace() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndReplace(filter, replacement, options);\n};\n\n/**\n * Issue a mongodb findOneAndRemove command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndRemove()`\n *\n * #### Example:\n *\n *     A.findOneAndRemove(conditions, options)  // return Query\n *     A.findOneAndRemove(conditions) // returns Query\n *     A.findOneAndRemove()           // returns Query\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id);\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findOneAndRemove = function(conditions, options) {\n  _checkContext(this, 'findOneAndRemove');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndRemove() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndRemove(conditions, options);\n};\n\n/**\n * Issue a mongodb findOneAndRemove command by a document's _id field. `findByIdAndRemove(id, ...)` is equivalent to `findOneAndRemove({ _id: id }, ...)`.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndRemove()`\n *\n * #### Example:\n *\n *     A.findByIdAndRemove(id, options)  // return Query\n *     A.findByIdAndRemove(id) // returns Query\n *     A.findByIdAndRemove()           // returns Query\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Model.findOneAndRemove https://mongoosejs.com/docs/api/model.html#Model.findOneAndRemove()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n */\n\nModel.findByIdAndRemove = function(id, options) {\n  _checkContext(this, 'findByIdAndRemove');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findByIdAndRemove() no longer accepts a callback');\n  }\n\n  return this.findOneAndRemove({ _id: id }, options);\n};\n\n/**\n * Shortcut for saving one or more documents to the database.\n * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in\n * docs.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * #### Example:\n *\n *     // Insert one new `Character` document\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     // Insert multiple new `Character` documents\n *     await Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);\n *\n *     // Create a new character within a transaction. Note that you **must**\n *     // pass an array as the first parameter to `create()` if you want to\n *     // specify options.\n *     await Character.create([{ name: 'Jean-Luc Picard' }], { session });\n *\n * @param {Array|Object} docs Documents to insert, as a spread or array\n * @param {Object} [options] Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread. See [Model.save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) for available options.\n * @param {Boolean} [options.ordered] saves the docs in series rather than parallel.\n * @param {Boolean} [options.aggregateErrors] Aggregate Errors instead of throwing the first one that occurs. Default: false\n * @return {Promise}\n * @api public\n */\n\nModel.create = async function create(doc, options) {\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.create() no longer accepts a callback');\n  }\n\n  _checkContext(this, 'create');\n\n  let args;\n  const discriminatorKey = this.schema.options.discriminatorKey;\n\n  if (Array.isArray(doc)) {\n    args = doc;\n    options = options != null && typeof options === 'object' ? options : {};\n  } else {\n    const last = arguments[arguments.length - 1];\n    options = {};\n    const hasCallback = typeof last === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function';\n    if (hasCallback) {\n      throw new MongooseError('Model.create() no longer accepts a callback');\n    } else {\n      args = [...arguments];\n      // For backwards compatibility with 6.x, because of gh-5061 Mongoose 6.x and\n      // older would treat a falsy last arg as a callback. We don't want to throw\n      // an error here, because it would look strange if `Test.create({}, void 0)`\n      // threw a callback error. But we also don't want to create an unnecessary document.\n      if (args.length > 1 && !last) {\n        args.pop();\n      }\n    }\n\n    if (args.length === 2 &&\n        args[0] != null &&\n        args[1] != null &&\n        args[0].session == null &&\n        last &&\n        getConstructorName(last.session) === 'ClientSession' &&\n        !this.schema.path('session')) {\n      // Probably means the user is running into the common mistake of trying\n      // to use a spread to specify options, see gh-7535\n      utils.warn('WARNING: to pass a `session` to `Model.create()` in ' +\n        'Mongoose, you **must** pass an array as the first argument. See: ' +\n        'https://mongoosejs.com/docs/api/model.html#Model.create()');\n    }\n  }\n\n  if (args.length === 0) {\n    return Array.isArray(doc) ? [] : null;\n  }\n  let res = [];\n  const immediateError = typeof options.aggregateErrors === 'boolean' ? !options.aggregateErrors : true;\n\n  delete options.aggregateErrors; // dont pass on the option to \"$save\"\n\n  if (options.ordered) {\n    for (let i = 0; i < args.length; i++) {\n      try {\n        const doc = args[i];\n        const Model = this.discriminators && doc[discriminatorKey] != null ?\n          this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n          this;\n        if (Model == null) {\n          throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n          `found for model \"${this.modelName}\"`);\n        }\n        let toSave = doc;\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n\n        await toSave.$save(options);\n        res.push(toSave);\n      } catch (err) {\n        if (!immediateError) {\n          res.push(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n    return res;\n  } else {\n    // \".bind(Promise)\" is required, otherwise results in \"TypeError: Promise.allSettled called on non-object\"\n    const promiseType = !immediateError ? Promise.allSettled.bind(Promise) : Promise.all.bind(Promise);\n    let p = promiseType(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ?\n        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n        this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n          `found for model \"${this.modelName}\"`);\n      }\n      let toSave = doc;\n\n      if (!(toSave instanceof Model)) {\n        toSave = new Model(toSave);\n      }\n\n      await toSave.$save(options);\n\n      return toSave;\n    }));\n\n    // chain the mapper, only if \"allSettled\" is used\n    if (!immediateError) {\n      p = p.then(presult => presult.map(v => v.status === 'fulfilled' ? v.value : v.reason));\n    }\n\n    res = await p;\n  }\n\n\n  if (!Array.isArray(doc) && args.length === 1) {\n    return res[0];\n  }\n\n  return res;\n};\n\n/**\n * _Requires a replica set running MongoDB >= 3.6.0._ Watches the\n * underlying collection for changes using\n * [MongoDB change streams](https://www.mongodb.com/docs/manual/changeStreams/).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const doc = await Person.create({ name: 'Ned Stark' });\n *     const changeStream = Person.watch().on('change', change => console.log(change));\n *     // Will print from the above `console.log()`:\n *     // { _id: { _data: ... },\n *     //   operationType: 'delete',\n *     //   ns: { db: 'mydb', coll: 'Person' },\n *     //   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }\n *     await doc.remove();\n *\n * @param {Array} [pipeline]\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#watch)\n * @param {Boolean} [options.hydrate=false] if true and `fullDocument: 'updateLookup'` is set, Mongoose will automatically hydrate `fullDocument` into a fully fledged Mongoose document\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n * @api public\n */\n\nModel.watch = function(pipeline, options) {\n  _checkContext(this, 'watch');\n\n  const changeStreamThunk = cb => {\n    pipeline = pipeline || [];\n    prepareDiscriminatorPipeline(pipeline, this.schema, 'fullDocument');\n    if (this.$__collection.buffer) {\n      this.$__collection.addQueue(() => {\n        if (this.closed) {\n          return;\n        }\n        const driverChangeStream = this.$__collection.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      });\n    } else {\n      const driverChangeStream = this.$__collection.watch(pipeline, options);\n      cb(null, driverChangeStream);\n    }\n  };\n\n  options = options || {};\n  options.model = this;\n\n  return new ChangeStream(changeStreamThunk, pipeline, options);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     const session = await Person.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.remove();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nModel.startSession = function() {\n  _checkContext(this, 'startSession');\n\n  return this.db.startSession.apply(this.db, arguments);\n};\n\n/**\n * Shortcut for validating an array of documents and inserting them into\n * MongoDB if they're all valid. This function is faster than `.create()`\n * because it only sends one operation to the server, rather than one for each\n * document.\n *\n * Mongoose always validates each document **before** sending `insertMany`\n * to MongoDB. So if one document has a validation error, no documents will\n * be saved, unless you set\n * [the `ordered` option to false](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertMany/#error-handling).\n *\n * This function does **not** trigger save middleware.\n *\n * This function triggers the following middleware.\n *\n * - `insertMany()`\n *\n * #### Example:\n *\n *     await Movies.insertMany([\n *       { name: 'Star Wars' },\n *       { name: 'The Empire Strikes Back' }\n *     ]);\n *\n * @param {Array|Object|*} doc(s)\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#insertMany)\n * @param {Boolean} [options.ordered=true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an \"unordered\" `insertMany()`.\n * @param {Boolean} [options.rawResult=false] if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/InsertManyResult.html) with a `mongoose` property that contains `validationErrors` and `results` if this is an unordered `insertMany`.\n * @param {Boolean} [options.lean=false] if `true`, skips hydrating the documents. This means Mongoose will **not** cast or validate any of the documents passed to `insertMany()`. This option is useful if you need the extra performance, but comes with data integrity risk. Consider using with [`castObject()`](https://mongoosejs.com/docs/api/model.html#Model.castObject()).\n * @param {Number} [options.limit=null] this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does **NOT** send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.\n * @param {String|Object|Array} [options.populate=null] populates the result documents. This option is a no-op if `rawResult` is set.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n * @return {Promise} resolving to the raw result from the MongoDB driver if `options.rawResult` was `true`, or the documents that passed validation, otherwise\n * @api public\n */\n\nModel.insertMany = async function insertMany(arr, options) {\n  _checkContext(this, 'insertMany');\n  if (typeof options === 'function' ||\n    typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.insertMany() no longer accepts a callback');\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__insertMany(arr, options, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * ignore\n *\n * @param {Array} arr\n * @param {Object} options\n * @param {Function} callback\n * @api private\n * @memberOf Model\n * @method $__insertMany\n * @static\n */\n\nModel.$__insertMany = function(arr, options, callback) {\n  const _this = this;\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  callback = callback || utils.noop;\n  options = options || {};\n  const limit = options.limit || 1000;\n  const rawResult = !!options.rawResult;\n  const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  const throwOnValidationError = typeof options.throwOnValidationError === 'boolean' ? options.throwOnValidationError : false;\n  const lean = !!options.lean;\n\n  const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();\n  if ((!options || !options.hasOwnProperty('session')) && asyncLocalStorage?.session != null) {\n    options = { ...options, session: asyncLocalStorage.session };\n  }\n\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n\n  const validationErrors = [];\n  const validationErrorsToOriginalOrder = new Map();\n  const results = ordered ? null : new Array(arr.length);\n  const toExecute = arr.map((doc, index) =>\n    callback => {\n      // If option `lean` is set to true bypass validation and hydration\n      if (lean) {\n        // we have to execute callback at the nextTick to be compatible\n        // with parallelLimit, as `results` variable has TDZ issue if we\n        // execute the callback synchronously\n        return immediate(() => callback(null, doc));\n      }\n      if (!(doc instanceof _this)) {\n        try {\n          doc = new _this(doc);\n        } catch (err) {\n          return callback(err);\n        }\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      // If option `lean` is set to true bypass validation\n      if (lean) {\n        // we have to execute callback at the nextTick to be compatible\n        // with parallelLimit, as `results` variable has TDZ issue if we\n        // execute the callback synchronously\n        return immediate(() => callback(null, doc));\n      }\n      doc.$validate().then(\n        () => { callback(null, doc); },\n        error => {\n          if (ordered === false) {\n            validationErrors.push(error);\n            validationErrorsToOriginalOrder.set(error, index);\n            results[index] = error;\n            return callback(null, null);\n          }\n          callback(error);\n        }\n      );\n    });\n\n  parallelLimit(toExecute, limit, function(error, docs) {\n    if (error) {\n      callback(error, null);\n      return;\n    }\n\n    const originalDocIndex = new Map();\n    const validDocIndexToOriginalIndex = new Map();\n    for (let i = 0; i < docs.length; ++i) {\n      originalDocIndex.set(docs[i], i);\n    }\n\n    // We filter all failed pre-validations by removing nulls\n    const docAttributes = docs.filter(function(doc) {\n      return doc != null;\n    });\n    for (let i = 0; i < docAttributes.length; ++i) {\n      validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));\n    }\n\n    // Make sure validation errors are in the same order as the\n    // original documents, so if both doc1 and doc2 both fail validation,\n    // `Model.insertMany([doc1, doc2])` will always have doc1's validation\n    // error before doc2's. Re: gh-12791.\n    if (validationErrors.length > 0) {\n      validationErrors.sort((err1, err2) => {\n        return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);\n      });\n    }\n\n    // Quickly escape while there aren't any valid docAttributes\n    if (docAttributes.length === 0) {\n      if (throwOnValidationError) {\n        return callback(new MongooseBulkWriteError(\n          validationErrors,\n          results,\n          null,\n          'insertMany'\n        ));\n      }\n      if (rawResult) {\n        const res = {\n          acknowledged: true,\n          insertedCount: 0,\n          insertedIds: {},\n          mongoose: {\n            validationErrors: validationErrors\n          }\n        };\n        return callback(null, res);\n      }\n      callback(null, []);\n      return;\n    }\n    const docObjects = lean ? docAttributes : docAttributes.map(function(doc) {\n      if (doc.$__schema.options.versionKey) {\n        doc[doc.$__schema.options.versionKey] = 0;\n      }\n      const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);\n      if (shouldSetTimestamps) {\n        return doc.initializeTimestamps().toObject(internalToObjectOptions);\n      }\n      return doc.toObject(internalToObjectOptions);\n    });\n\n    _this.$__collection.insertMany(docObjects, options).then(\n      res => {\n        if (!lean) {\n          for (const attribute of docAttributes) {\n            attribute.$__reset();\n            _setIsNew(attribute, false);\n          }\n        }\n\n        if (ordered === false && throwOnValidationError && validationErrors.length > 0) {\n          for (let i = 0; i < results.length; ++i) {\n            if (results[i] === void 0) {\n              results[i] = docs[i];\n            }\n          }\n          return callback(new MongooseBulkWriteError(\n            validationErrors,\n            results,\n            res,\n            'insertMany'\n          ));\n        }\n\n        if (rawResult) {\n          if (ordered === false) {\n            for (let i = 0; i < results.length; ++i) {\n              if (results[i] === void 0) {\n                results[i] = docs[i];\n              }\n            }\n\n            // Decorate with mongoose validation errors in case of unordered,\n            // because then still do `insertMany()`\n            res.mongoose = {\n              validationErrors: validationErrors,\n              results: results\n            };\n          }\n          return callback(null, res);\n        }\n\n        if (options.populate != null) {\n          return _this.populate(docAttributes, options.populate).then(\n            docs => { callback(null, docs); },\n            err => {\n              if (err != null) {\n                err.insertedDocs = docAttributes;\n              }\n              throw err;\n            }\n          );\n        }\n\n        callback(null, docAttributes);\n      },\n      error => {\n        // `writeErrors` is a property reported by the MongoDB driver,\n        // just not if there's only 1 error.\n        if (error.writeErrors == null &&\n            (error.result && error.result.result && error.result.result.writeErrors) != null) {\n          error.writeErrors = error.result.result.writeErrors;\n        }\n\n        // `insertedDocs` is a Mongoose-specific property\n        const hasWriteErrors = error && error.writeErrors;\n        const erroredIndexes = new Set((error && error.writeErrors || []).map(err => err.index));\n\n        if (error.writeErrors != null) {\n          for (let i = 0; i < error.writeErrors.length; ++i) {\n            const originalIndex = validDocIndexToOriginalIndex.get(error.writeErrors[i].index);\n            error.writeErrors[i] = {\n              ...error.writeErrors[i],\n              index: originalIndex\n            };\n            if (!ordered) {\n              results[originalIndex] = error.writeErrors[i];\n            }\n          }\n        }\n\n        if (!ordered) {\n          for (let i = 0; i < results.length; ++i) {\n            if (results[i] === void 0) {\n              results[i] = docs[i];\n            }\n          }\n\n          error.results = results;\n        }\n\n        let firstErroredIndex = -1;\n        error.insertedDocs = docAttributes.\n          filter((doc, i) => {\n            const isErrored = !hasWriteErrors || erroredIndexes.has(i);\n\n            if (ordered) {\n              if (firstErroredIndex > -1) {\n                return i < firstErroredIndex;\n              }\n\n              if (isErrored) {\n                firstErroredIndex = i;\n              }\n            }\n\n            return !isErrored;\n          }).\n          map(function setIsNewForInsertedDoc(doc) {\n            if (lean) {\n              return doc;\n            }\n            doc.$__reset();\n            _setIsNew(doc, false);\n            return doc;\n          });\n\n        if (rawResult && ordered === false) {\n          error.mongoose = {\n            validationErrors: validationErrors,\n            results: results\n          };\n        }\n\n        callback(error, null);\n      }\n    );\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction _setIsNew(doc, val) {\n  doc.$isNew = val;\n  doc.$emit('isNew', val);\n  doc.constructor.emit('isNew', val);\n\n  const subdocs = doc.$getAllSubdocs();\n  for (const subdoc of subdocs) {\n    subdoc.$isNew = val;\n    subdoc.$emit('isNew', val);\n  }\n}\n\n/**\n * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,\n * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one\n * command. This is faster than sending multiple independent operations (e.g.\n * if you use `create()`) because with `bulkWrite()` there is only one round\n * trip to MongoDB.\n *\n * Mongoose will perform casting on all operations you provide.\n *\n * This function does **not** trigger any middleware, neither `save()`, nor `update()`.\n * If you need to trigger\n * `save()` middleware for every document use [`create()`](https://mongoosejs.com/docs/api/model.html#Model.create()) instead.\n *\n * #### Example:\n *\n *     Character.bulkWrite([\n *       {\n *         insertOne: {\n *           document: {\n *             name: 'Eddard Stark',\n *             title: 'Warden of the North'\n *           }\n *         }\n *       },\n *       {\n *         updateOne: {\n *           filter: { name: 'Eddard Stark' },\n *           // If you were using the MongoDB driver directly, you'd need to do\n *           // `update: { $set: { title: ... } }` but mongoose adds $set for\n *           // you.\n *           update: { title: 'Hand of the King' }\n *         }\n *       },\n *       {\n *         deleteOne: {\n *           filter: { name: 'Eddard Stark' }\n *         }\n *       }\n *     ]).then(res => {\n *      // Prints \"1 1 1\"\n *      console.log(res.insertedCount, res.modifiedCount, res.deletedCount);\n *     });\n *\n * The [supported operations](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite) are:\n *\n * - `insertOne`\n * - `updateOne`\n * - `updateMany`\n * - `deleteOne`\n * - `deleteMany`\n * - `replaceOne`\n *\n * @param {Array} ops\n * @param {Object} [ops.insertOne.document] The document to insert\n * @param {Object} [ops.updateOne.filter] Update the first document that matches this filter\n * @param {Object} [ops.updateOne.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateOne.upsert=false] If true, insert a doc if none match\n * @param {Boolean} [ops.updateOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateOne.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateOne.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.updateMany.filter] Update all the documents that match this filter\n * @param {Object} [ops.updateMany.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateMany.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Boolean} [ops.updateMany.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateMany.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateMany.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.deleteOne.filter] Delete the first document that matches this filter\n * @param {Object} [ops.deleteMany.filter] Delete all documents that match this filter\n * @param {Object} [ops.replaceOne.filter] Replace the first document that matches this filter\n * @param {Object} [ops.replaceOne.replacement] The replacement document\n * @param {Boolean} [ops.replaceOne.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Object} [options]\n * @param {Boolean} [options.ordered=true] If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n * @param {Boolean} [options.skipValidation=false] Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on `insertOne` and `replaceOne` operations by default.\n * @param {Boolean} [options.bypassDocumentValidation=false] If true, disable [MongoDB server-side schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/) for all writes in this bulk.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n * @param {Boolean} [options.strict=null] Overwrites the [`strict` option](https://mongoosejs.com/docs/guide.html#strict) on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.\n * @return {Promise} resolves to a [`BulkWriteOpResult`](https://mongodb.github.io/node-mongodb-native/4.9/classes/BulkWriteResult.html) if the operation succeeds\n * @api public\n */\n\nModel.bulkWrite = async function bulkWrite(ops, options) {\n  _checkContext(this, 'bulkWrite');\n\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.bulkWrite() no longer accepts a callback');\n  }\n  options = options || {};\n  const ordered = options.ordered == null ? true : options.ordered;\n\n  const validations = ops.map(op => castBulkWrite(this, op, options));\n  const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();\n  if ((!options || !options.hasOwnProperty('session')) && asyncLocalStorage?.session != null) {\n    options = { ...options, session: asyncLocalStorage.session };\n  }\n\n  return new Promise((resolve, reject) => {\n    if (ordered) {\n      each(validations, (fn, cb) => fn(cb), error => {\n        if (error) {\n          return reject(error);\n        }\n\n        if (ops.length === 0) {\n          return resolve(getDefaultBulkwriteResult());\n        }\n\n        try {\n          this.$__collection.bulkWrite(ops, options, (error, res) => {\n            if (error) {\n              return reject(error);\n            }\n\n            resolve(res);\n          });\n        } catch (err) {\n          return reject(err);\n        }\n      });\n\n      return;\n    }\n\n    let remaining = validations.length;\n    let validOps = [];\n    let validationErrors = [];\n    const results = [];\n    if (remaining === 0) {\n      completeUnorderedValidation.call(this);\n    } else {\n      for (let i = 0; i < validations.length; ++i) {\n        validations[i]((err) => {\n          if (err == null) {\n            validOps.push(i);\n          } else {\n            validationErrors.push({ index: i, error: err });\n            results[i] = err;\n          }\n          if (--remaining <= 0) {\n            completeUnorderedValidation.call(this);\n          }\n        });\n      }\n    }\n\n    validationErrors = validationErrors.\n      sort((v1, v2) => v1.index - v2.index).\n      map(v => v.error);\n\n    function completeUnorderedValidation() {\n      const validOpIndexes = validOps;\n      validOps = validOps.sort().map(index => ops[index]);\n\n      if (validOps.length === 0) {\n        if (options.throwOnValidationError) {\n          validationErrors = validationErrors.\n            sort((v1, v2) => v1.index - v2.index).\n            map(v => v.error);\n          return reject(new MongooseBulkWriteError(\n            validationErrors,\n            results,\n            null,\n            'bulkWrite'\n          ));\n        }\n        return resolve(getDefaultBulkwriteResult());\n      }\n\n      this.$__collection.bulkWrite(validOps, options, (error, res) => {\n        if (error) {\n          if (validationErrors.length > 0) {\n            error.mongoose = error.mongoose || {};\n            error.mongoose.validationErrors = validationErrors;\n          }\n\n          return reject(error);\n        }\n\n        for (let i = 0; i < validOpIndexes.length; ++i) {\n          results[validOpIndexes[i]] = null;\n        }\n        if (validationErrors.length > 0) {\n          if (options.throwOnValidationError) {\n            return reject(new MongooseBulkWriteError(\n              validationErrors,\n              results,\n              res,\n              'bulkWrite'\n            ));\n          } else {\n            res.mongoose = res.mongoose || {};\n            res.mongoose.validationErrors = validationErrors;\n            res.mongoose.results = results;\n          }\n        }\n\n        resolve(res);\n      });\n    }\n  });\n};\n\n/**\n *  takes an array of documents, gets the changes and inserts/updates documents in the database\n *  according to whether or not the document is new, or whether it has changes or not.\n *\n * `bulkSave` uses `bulkWrite` under the hood, so it's mostly useful when dealing with many documents (10K+)\n *\n * @param {Array<Document>} documents\n * @param {Object} [options] options passed to the underlying `bulkWrite()`\n * @param {Boolean} [options.timestamps] defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n *\n */\nModel.bulkSave = async function bulkSave(documents, options) {\n  options = options || {};\n\n  if (options.timestamps != null) {\n    for (const document of documents) {\n      document.$__.saveOptions = document.$__.saveOptions || {};\n      document.$__.saveOptions.timestamps = options.timestamps;\n    }\n  } else {\n    for (const document of documents) {\n      if (document.$__.timestamps != null) {\n        document.$__.saveOptions = document.$__.saveOptions || {};\n        document.$__.saveOptions.timestamps = document.$__.timestamps;\n      }\n    }\n  }\n\n  await Promise.all(documents.map(buildPreSavePromise));\n\n  const writeOperations = this.buildBulkWriteOperations(documents, { skipValidation: true, timestamps: options.timestamps });\n\n  const { bulkWriteResult, bulkWriteError } = await this.bulkWrite(writeOperations, options).then(\n    (res) => ({ bulkWriteResult: res, bulkWriteError: null }),\n    (err) => ({ bulkWriteResult: null, bulkWriteError: err })\n  );\n\n  await Promise.all(\n    documents.map(async(document) => {\n      const documentError = bulkWriteError && bulkWriteError.writeErrors.find(writeError => {\n        const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;\n        return writeErrorDocumentId.toString() === document._id.toString();\n      });\n\n      if (documentError == null) {\n        await handleSuccessfulWrite(document);\n      }\n    })\n  );\n\n  if (bulkWriteError && bulkWriteError.writeErrors && bulkWriteError.writeErrors.length) {\n    throw bulkWriteError;\n  }\n\n  return bulkWriteResult;\n};\n\nfunction buildPreSavePromise(document) {\n  return new Promise((resolve, reject) => {\n    document.schema.s.hooks.execPre('save', document, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n  });\n}\n\nfunction handleSuccessfulWrite(document) {\n  return new Promise((resolve, reject) => {\n    if (document.$isNew) {\n      _setIsNew(document, false);\n    }\n\n    document.$__reset();\n    document.schema.s.hooks.execPost('save', document, [document], {}, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n\n  });\n}\n\n/**\n * Apply defaults to the given document or POJO.\n *\n * @param {Object|Document} obj object or document to apply defaults on\n * @returns {Object|Document}\n * @api public\n */\n\nModel.applyDefaults = function applyDefaults(doc) {\n  if (doc.$__ != null) {\n    applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);\n\n    for (const subdoc of doc.$getAllSubdocs()) {\n      applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);\n    }\n\n    return doc;\n  }\n\n  applyDefaultsToPOJO(doc, this.schema);\n\n  return doc;\n};\n\n/**\n * Cast the given POJO to the model's schema\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', Schema({ num: Number }));\n *\n *     const obj = Test.castObject({ num: '42' });\n *     obj.num; // 42 as a number\n *\n *     Test.castObject({ num: 'not a number' }); // Throws a ValidationError\n *\n * @param {Object} obj object or document to cast\n * @param {Object} options options passed to castObject\n * @param {Boolean} options.ignoreCastErrors If set to `true` will not throw a ValidationError and only return values that were successfully cast.\n * @returns {Object} POJO casted to the model's schema\n * @throws {ValidationError} if casting failed for at least one path\n * @api public\n */\n\nModel.castObject = function castObject(obj, options) {\n  options = options || {};\n  const ret = {};\n\n  const schema = this.schema;\n  const paths = Object.keys(schema.paths);\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let error = null;\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (schemaType == null) {\n      continue;\n    }\n\n    let val = get(obj, path, void 0);\n\n    if (val == null) {\n      continue;\n    }\n\n    const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = ret;\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      if (cur[pieces[i]] == null) {\n        cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];\n      }\n      cur = cur[pieces[i]];\n    }\n\n    if (schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n    if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {\n      try {\n        val = Model.castObject.call(schemaType.caster, val);\n      } catch (err) {\n        if (!options.ignoreCastErrors) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        continue;\n      }\n\n      cur[pieces[pieces.length - 1]] = val;\n      continue;\n    }\n\n    try {\n      val = schemaType.cast(val);\n      cur[pieces[pieces.length - 1]] = val;\n    } catch (err) {\n      if (!options.ignoreCastErrors) {\n        error = error || new ValidationError();\n        error.addError(path, err);\n      }\n\n      continue;\n    }\n  }\n\n  if (error != null) {\n    throw error;\n  }\n\n  return ret;\n};\n\n/**\n * Build bulk write operations for `bulkSave()`.\n *\n * @param {Array<Document>} documents The array of documents to build write operations of\n * @param {Object} options\n * @param {Boolean} options.skipValidation defaults to `false`, when set to true, building the write operations will bypass validating the documents.\n * @param {Boolean} options.timestamps defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @return {Array<Promise>} Returns a array of all Promises the function executes to be awaited.\n * @api private\n */\n\nModel.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {\n  if (!Array.isArray(documents)) {\n    throw new Error(`bulkSave expects an array of documents to be passed, received \\`${documents}\\` instead`);\n  }\n\n  setDefaultOptions();\n  const discriminatorKey = this.schema.options.discriminatorKey;\n\n  const writeOperations = documents.reduce((accumulator, document, i) => {\n    if (!options.skipValidation) {\n      if (!(document instanceof Document)) {\n        throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);\n      }\n      const validationError = document.validateSync();\n      if (validationError) {\n        throw validationError;\n      }\n    }\n\n    const isANewDocument = document.isNew;\n    if (isANewDocument) {\n      const writeOperation = { insertOne: { document } };\n      utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);\n      accumulator.push(writeOperation);\n\n      return accumulator;\n    }\n\n    const delta = document.$__delta();\n    const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);\n\n    if (isDocumentWithChanges) {\n      const where = document.$__where(delta[0]);\n      const changes = delta[1];\n\n      _applyCustomWhere(document, where);\n\n      // Set the discriminator key, so bulk write casting knows which\n      // schema to use re: gh-13907\n      if (document[discriminatorKey] != null && !(discriminatorKey in where)) {\n        where[discriminatorKey] = document[discriminatorKey];\n      }\n\n      document.$__version(where, delta);\n      const writeOperation = { updateOne: { filter: where, update: changes } };\n      utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);\n      accumulator.push(writeOperation);\n\n      return accumulator;\n    }\n\n    return accumulator;\n  }, []);\n\n  return writeOperations;\n\n\n  function setDefaultOptions() {\n    options = options || {};\n    if (options.skipValidation == null) {\n      options.skipValidation = false;\n    }\n  }\n};\n\n\n/**\n * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.\n * The document returned has no paths marked as modified initially.\n *\n * #### Example:\n *\n *     // hydrate previous data into a Mongoose document\n *     const mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });\n *\n * @param {Object} obj\n * @param {Object|String|String[]} [projection] optional projection containing which fields should be selected for this document\n * @param {Object} [options] optional options\n * @param {Boolean} [options.setters=false] if true, apply schema setters when hydrating\n * @return {Document} document instance\n * @api public\n */\n\nModel.hydrate = function(obj, projection, options) {\n  _checkContext(this, 'hydrate');\n\n  if (projection != null) {\n    if (obj != null && obj.$__ != null) {\n      obj = obj.toObject(internalToObjectOptions);\n    }\n    obj = applyProjection(obj, projection);\n  }\n\n  const document = (__webpack_require__(/*! ./queryhelpers */ \"(api)/../server/node_modules/mongoose/lib/queryhelpers.js\").createModel)(this, obj, projection);\n  document.$init(obj, options);\n  return document;\n};\n\n/**\n * Same as `updateOne()`, except MongoDB will update _all_ documents that match\n * `filter` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} filter\n * @param {Object|Array} update\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateMany = function updateMany(conditions, doc, options) {\n  _checkContext(this, 'updateMany');\n\n  return _update(this, 'updateMany', conditions, doc, options);\n};\n\n/**\n * Update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} filter\n * @param {Object|Array} update\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateOne = function updateOne(conditions, doc, options) {\n  _checkContext(this, 'updateOne');\n\n  return _update(this, 'updateOne', conditions, doc, options);\n};\n\n/**\n * Replace the existing document with the given document (no atomic operators like `$set`).\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} filter\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @return {Query}\n * @api public\n */\n\nModel.replaceOne = function replaceOne(conditions, doc, options) {\n  _checkContext(this, 'replaceOne');\n\n  const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;\n  if (versionKey && !doc[versionKey]) {\n    doc[versionKey] = 0;\n  }\n\n  return _update(this, 'replaceOne', conditions, doc, options);\n};\n\n/**\n * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`\n * because they need to do the same thing\n * @api private\n */\n\nfunction _update(model, op, conditions, doc, options) {\n  const mq = new model.Query({}, {}, model, model.collection);\n\n  // gh-2406\n  // make local deep copy of conditions\n  if (conditions instanceof Document) {\n    conditions = conditions.toObject();\n  } else {\n    conditions = clone(conditions);\n  }\n  options = typeof options === 'function' ? options : clone(options);\n\n  const versionKey = model &&\n  model.schema &&\n  model.schema.options &&\n  model.schema.options.versionKey || null;\n  decorateUpdateWithVersionKey(doc, options, versionKey);\n\n  return mq[op](conditions, doc, options);\n}\n\n/**\n * Performs [aggregations](https://www.mongodb.com/docs/manual/aggregation/) on the models collection.\n *\n * If a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.\n *\n * This function triggers the following middleware.\n *\n * - `aggregate()`\n *\n * #### Example:\n *\n *     // Find the max balance of all accounts\n *     const res = await Users.aggregate([\n *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},\n *       { $project: { _id: 0, maxBalance: 1 }}\n *     ]);\n *\n *     console.log(res); // [ { maxBalance: 98000 } ]\n *\n *     // Or use the aggregation pipeline builder.\n *     const res = await Users.aggregate().\n *       group({ _id: null, maxBalance: { $max: '$balance' } }).\n *       project('-id maxBalance').\n *       exec();\n *     console.log(res); // [ { maxBalance: 98 } ]\n *\n * #### Note:\n *\n * - Mongoose does **not** cast aggregation pipelines to the model's schema because `$project` and `$group` operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. You can use the [mongoose-cast-aggregation plugin](https://github.com/AbdelrahmanHafez/mongoose-cast-aggregation) to enable minimal casting for aggregation pipelines.\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n *\n * #### More About Aggregations:\n *\n * - [Mongoose `Aggregate`](https://mongoosejs.com/docs/api/aggregate.html)\n * - [An Introduction to Mongoose Aggregate](https://masteringjs.io/tutorials/mongoose/aggregate)\n * - [MongoDB Aggregation docs](https://www.mongodb.com/docs/manual/applications/aggregation/)\n *\n * @see Aggregate https://mongoosejs.com/docs/api/aggregate.html#Aggregate()\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Object} [options] aggregation options\n * @return {Aggregate}\n * @api public\n */\n\nModel.aggregate = function aggregate(pipeline, options) {\n  _checkContext(this, 'aggregate');\n\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.aggregate() no longer accepts a callback');\n  }\n\n  const aggregate = new Aggregate(pipeline || []);\n  aggregate.model(this);\n  if (options != null) {\n    aggregate.option(options);\n  }\n\n  if (typeof callback === 'undefined') {\n    return aggregate;\n  }\n\n  return aggregate;\n};\n\n/**\n * Casts and validates the given object against this model's schema, passing the\n * given `context` to custom validators.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', Schema({\n *       name: { type: String, required: true },\n *       age: { type: Number, required: true }\n *     });\n *\n *     try {\n *       await Model.validate({ name: null }, ['name'])\n *     } catch (err) {\n *       err instanceof mongoose.Error.ValidationError; // true\n *       Object.keys(err.errors); // ['name']\n *     }\n *\n * @param {Object} obj\n * @param {Object|Array|String} pathsOrOptions\n * @param {Object} [context]\n * @return {Promise|undefined}\n * @api public\n */\n\nModel.validate = async function validate(obj, pathsOrOptions, context) {\n  if ((arguments.length < 3) || (arguments.length === 3 && typeof arguments[2] === 'function')) {\n    // For convenience, if we're validating a document or an object, make `context` default to\n    // the model so users don't have to always pass `context`, re: gh-10132, gh-10346\n    context = obj;\n  }\n  if (typeof context === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.validate() no longer accepts a callback');\n  }\n\n  let schema = this.schema;\n  const discriminatorKey = schema.options.discriminatorKey;\n  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;\n  }\n  let paths = Object.keys(schema.paths);\n\n  if (pathsOrOptions != null) {\n    const _pathsToValidate = typeof pathsOrOptions === 'string' ? new Set(pathsOrOptions.split(' ')) : Array.isArray(pathsOrOptions) ? new Set(pathsOrOptions) : new Set(paths);\n    paths = paths.filter(p => {\n      if (pathsOrOptions.pathsToSkip) {\n        if (Array.isArray(pathsOrOptions.pathsToSkip)) {\n          if (pathsOrOptions.pathsToSkip.find(x => x == p)) {\n            return false;\n          }\n        } else if (typeof pathsOrOptions.pathsToSkip == 'string') {\n          if (pathsOrOptions.pathsToSkip.includes(p)) {\n            return false;\n          }\n        }\n      }\n      const pieces = p.split('.');\n      let cur = pieces[0];\n\n      for (const piece of pieces) {\n        if (_pathsToValidate.has(cur)) {\n          return true;\n        }\n        cur += '.' + piece;\n      }\n\n      return _pathsToValidate.has(p);\n    });\n  }\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let remaining = paths.length;\n  let error = null;\n\n  return new Promise((resolve, reject) => {\n    for (const path of paths) {\n      const schemaType = schema.path(path);\n      if (schemaType == null) {\n        _checkDone();\n        continue;\n      }\n\n      const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n      let cur = obj;\n      for (let i = 0; i < pieces.length - 1; ++i) {\n        cur = cur[pieces[i]];\n      }\n\n      let val = get(obj, path, void 0);\n\n      if (val != null) {\n        try {\n          val = schemaType.cast(val);\n          cur[pieces[pieces.length - 1]] = val;\n        } catch (err) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n\n          _checkDone();\n          continue;\n        }\n      }\n\n      schemaType.doValidate(val, err => {\n        if (err) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        _checkDone();\n      }, context, { path: path });\n    }\n\n    function _checkDone() {\n      if (--remaining <= 0) {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      }\n    }\n  });\n};\n\n/**\n * Populates document references.\n *\n * Changed in Mongoose 6: the model you call `populate()` on should be the\n * \"local field\" model, **not** the \"foreign field\" model.\n *\n * #### Available top-level options:\n *\n * - path: space delimited path(s) to populate\n * - select: optional fields to select\n * - match: optional query conditions to match\n * - model: optional name of the model to use for population\n * - options: optional query options like sort, limit, etc\n * - justOne: optional boolean, if true Mongoose will always set `path` to a document, or `null` if no document was found. If false, Mongoose will always set `path` to an array, which will be empty if no documents are found. Inferred from schema by default.\n * - strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.\n *\n * #### Example:\n *\n *     const Dog = mongoose.model('Dog', new Schema({ name: String, breed: String }));\n *     const Person = mongoose.model('Person', new Schema({\n *       name: String,\n *       pet: { type: mongoose.ObjectId, ref: 'Dog' }\n *     }));\n *\n *     const pets = await Pet.create([\n *       { name: 'Daisy', breed: 'Beagle' },\n *       { name: 'Einstein', breed: 'Catalan Sheepdog' }\n *     ]);\n *\n *     // populate many plain objects\n *     const users = [\n *       { name: 'John Wick', dog: pets[0]._id },\n *       { name: 'Doc Brown', dog: pets[1]._id }\n *     ];\n *     await User.populate(users, { path: 'dog', select: 'name' });\n *     users[0].dog.name; // 'Daisy'\n *     users[0].dog.breed; // undefined because of `select`\n *\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object|String} options Either the paths to populate or an object specifying all parameters\n * @param {string} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] By default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] If true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Boolean} [options.skipInvalidIds=false] By default, Mongoose throws a cast error if `localField` and `foreignField` schemas don't line up. If you enable this option, Mongoose will instead filter out any `localField` properties that cannot be casted to `foreignField`'s schema type.\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Boolean} [options.strictPopulate=true] Set to false to allow populating paths that aren't defined in the given model's schema.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Function} [callback(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Promise}\n * @api public\n */\n\nModel.populate = async function populate(docs, paths) {\n  _checkContext(this, 'populate');\n  if (typeof paths === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.populate() no longer accepts a callback');\n  }\n  const _this = this;\n  // normalized paths\n  paths = utils.populate(paths);\n  // data that should persist across subPopulate calls\n  const cache = {};\n\n  return new Promise((resolve, reject) => {\n    _populate(_this, docs, paths, cache, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Populate helper\n *\n * @param {Model} model the model to use\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object} paths\n * @param {never} cache Unused\n * @param {Function} [callback] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Function}\n * @api private\n */\n\nfunction _populate(model, docs, paths, cache, callback) {\n  let pending = paths.length;\n  if (paths.length === 0) {\n    return callback(null, docs);\n  }\n  // each path has its own query options and must be executed separately\n  for (const path of paths) {\n    populate(model, docs, path, next);\n  }\n\n  function next(err) {\n    if (err) {\n      return callback(err, null);\n    }\n    if (--pending) {\n      return;\n    }\n    callback(null, docs);\n  }\n}\n\n/*!\n * Populates `docs`\n */\nconst excludeIdReg = /\\s?-_id\\s?/;\nconst excludeIdRegGlobal = /\\s?-_id\\s?/g;\n\nfunction populate(model, docs, options, callback) {\n  const populateOptions = options;\n  if (options.strictPopulate == null) {\n    if (options._localModel != null && options._localModel.schema._userProvidedOptions.strictPopulate != null) {\n      populateOptions.strictPopulate = options._localModel.schema._userProvidedOptions.strictPopulate;\n    } else if (options._localModel != null && model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    } else if (model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    }\n  }\n\n  // normalize single / multiple docs passed\n  if (!Array.isArray(docs)) {\n    docs = [docs];\n  }\n  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {\n    return callback();\n  }\n\n  const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);\n\n  if (modelsMap instanceof MongooseError) {\n    return immediate(function() {\n      callback(modelsMap);\n    });\n  }\n  const len = modelsMap.length;\n  let vals = [];\n\n  function flatten(item) {\n    // no need to include undefined values in our query\n    return undefined !== item;\n  }\n\n  let _remaining = len;\n  let hasOne = false;\n  const params = [];\n  for (let i = 0; i < len; ++i) {\n    const mod = modelsMap[i];\n    let select = mod.options.select;\n    let ids = utils.array.flatten(mod.ids, flatten);\n    ids = utils.array.unique(ids);\n\n    const assignmentOpts = {};\n    assignmentOpts.sort = mod &&\n      mod.options &&\n      mod.options.options &&\n      mod.options.options.sort || void 0;\n    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && select._id === 0);\n\n    // Lean transform may delete `_id`, which would cause assignment\n    // to fail. So delay running lean transform until _after_\n    // `_assign()`\n    if (mod.options &&\n        mod.options.options &&\n        mod.options.options.lean &&\n        mod.options.options.lean.transform) {\n      mod.options.options._leanTransform = mod.options.options.lean.transform;\n      mod.options.options.lean = true;\n    }\n\n    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {\n      // Ensure that we set to 0 or empty array even\n      // if we don't actually execute a query to make sure there's a value\n      // and we know this path was populated for future sets. See gh-7731, gh-8230\n      --_remaining;\n      _assign(model, [], mod, assignmentOpts);\n      continue;\n    }\n\n    hasOne = true;\n    if (typeof populateOptions.foreignField === 'string') {\n      mod.foreignField.clear();\n      mod.foreignField.add(populateOptions.foreignField);\n    }\n    const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);\n    if (assignmentOpts.excludeId) {\n      // override the exclusion from the query so we can use the _id\n      // for document matching during assignment. we'll delete the\n      // _id back off before returning the result.\n      if (typeof select === 'string') {\n        select = select.replace(excludeIdRegGlobal, ' ');\n      } else {\n        // preserve original select conditions by copying\n        select = { ...select };\n        delete select._id;\n      }\n    }\n\n    if (mod.options.options && mod.options.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.options.limit;\n    } else if (mod.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.limit;\n    }\n    params.push([mod, match, select, assignmentOpts, _next]);\n  }\n  if (!hasOne) {\n    // If models but no docs, skip further deep populate.\n    if (modelsMap.length !== 0) {\n      return callback();\n    }\n    // If no models to populate but we have a nested populate,\n    // keep trying, re: gh-8946\n    if (populateOptions.populate != null) {\n      const opts = utils.populate(populateOptions.populate).map(pop => Object.assign({}, pop, {\n        path: populateOptions.path + '.' + pop.path\n      }));\n      model.populate(docs, opts).then(res => { callback(null, res); }, err => { callback(err); });\n      return;\n    }\n    return callback();\n  }\n\n  for (const arr of params) {\n    _execPopulateQuery.apply(null, arr);\n  }\n  function _next(err, valsFromDb) {\n    if (err != null) {\n      return callback(err, null);\n    }\n    vals = vals.concat(valsFromDb);\n    if (--_remaining === 0) {\n      _done();\n    }\n  }\n\n  function _done() {\n    for (const arr of params) {\n      const mod = arr[0];\n      const assignmentOpts = arr[3];\n      for (const val of vals) {\n        mod.options._childDocs.push(val);\n      }\n      try {\n        _assign(model, vals, mod, assignmentOpts);\n      } catch (err) {\n        return callback(err);\n      }\n    }\n\n    for (const arr of params) {\n      removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);\n    }\n    for (const arr of params) {\n      const mod = arr[0];\n      if (mod.options && mod.options.options && mod.options.options._leanTransform) {\n        for (const doc of vals) {\n          mod.options.options._leanTransform(doc);\n        }\n      }\n    }\n    callback();\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _execPopulateQuery(mod, match, select, assignmentOpts, callback) {\n  let subPopulate = clone(mod.options.populate);\n  const queryOptions = Object.assign({\n    skip: mod.options.skip,\n    limit: mod.options.limit,\n    perDocumentLimit: mod.options.perDocumentLimit\n  }, mod.options.options);\n\n  if (mod.count) {\n    delete queryOptions.skip;\n  }\n\n  if (queryOptions.perDocumentLimit != null) {\n    queryOptions.limit = queryOptions.perDocumentLimit;\n    delete queryOptions.perDocumentLimit;\n  } else if (queryOptions.limit != null) {\n    queryOptions.limit = queryOptions.limit * mod.ids.length;\n  }\n\n  const query = mod.model.find(match, select, queryOptions);\n  // If we're doing virtual populate and projection is inclusive and foreign\n  // field is not selected, automatically select it because mongoose needs it.\n  // If projection is exclusive and client explicitly unselected the foreign\n  // field, that's the client's fault.\n  for (const foreignField of mod.foreignField) {\n    if (foreignField !== '_id' &&\n        query.selectedInclusively() &&\n        !isPathSelectedInclusive(query._fields, foreignField)) {\n      query.select(foreignField);\n    }\n  }\n\n  // If using count, still need the `foreignField` so we can match counts\n  // to documents, otherwise we would need a separate `count()` for every doc.\n  if (mod.count) {\n    for (const foreignField of mod.foreignField) {\n      query.select(foreignField);\n    }\n  }\n\n  // If we need to sub-populate, call populate recursively\n  if (subPopulate) {\n    // If subpopulating on a discriminator, skip check for non-existent\n    // paths. Because the discriminator may not have the path defined.\n    if (mod.model.baseModelName != null) {\n      if (Array.isArray(subPopulate)) {\n        subPopulate.forEach(pop => { pop.strictPopulate = false; });\n      } else if (typeof subPopulate === 'string') {\n        subPopulate = { path: subPopulate, strictPopulate: false };\n      } else {\n        subPopulate.strictPopulate = false;\n      }\n    }\n    const basePath = mod.options._fullPath || mod.options.path;\n\n    if (Array.isArray(subPopulate)) {\n      for (const pop of subPopulate) {\n        pop._fullPath = basePath + '.' + pop.path;\n      }\n    } else if (typeof subPopulate === 'object') {\n      subPopulate._fullPath = basePath + '.' + subPopulate.path;\n    }\n\n    query.populate(subPopulate);\n  }\n\n  query.exec().then(\n    docs => {\n      for (const val of docs) {\n        leanPopulateMap.set(val, mod.model);\n      }\n      callback(null, docs);\n    },\n    err => {\n      callback(err);\n    }\n  );\n}\n\n/*!\n * ignore\n */\n\nfunction _assign(model, vals, mod, assignmentOpts) {\n  const options = mod.options;\n  const isVirtual = mod.isVirtual;\n  const justOne = mod.justOne;\n  let _val;\n  const lean = options &&\n    options.options &&\n    options.options.lean || false;\n  const len = vals.length;\n  const rawOrder = {};\n  const rawDocs = {};\n  let key;\n  let val;\n\n  // Clone because `assignRawDocsToIdStructure` will mutate the array\n  const allIds = clone(mod.allIds);\n  // optimization:\n  // record the document positions as returned by\n  // the query result.\n  for (let i = 0; i < len; i++) {\n    val = vals[i];\n    if (val == null) {\n      continue;\n    }\n    for (const foreignField of mod.foreignField) {\n      _val = utils.getValue(foreignField, val);\n      if (Array.isArray(_val)) {\n        _val = utils.array.unique(utils.array.flatten(_val));\n\n        for (let __val of _val) {\n          if (__val instanceof Document) {\n            __val = __val._id;\n          }\n          key = String(__val);\n          if (rawDocs[key]) {\n            if (Array.isArray(rawDocs[key])) {\n              rawDocs[key].push(val);\n              rawOrder[key].push(i);\n            } else {\n              rawDocs[key] = [rawDocs[key], val];\n              rawOrder[key] = [rawOrder[key], i];\n            }\n          } else {\n            if (isVirtual && !justOne) {\n              rawDocs[key] = [val];\n              rawOrder[key] = [i];\n            } else {\n              rawDocs[key] = val;\n              rawOrder[key] = i;\n            }\n          }\n        }\n      } else {\n        if (_val instanceof Document) {\n          _val = _val._id;\n        }\n        key = String(_val);\n        if (rawDocs[key]) {\n          if (Array.isArray(rawDocs[key])) {\n            rawDocs[key].push(val);\n            rawOrder[key].push(i);\n          } else if (isVirtual ||\n            rawDocs[key].constructor !== val.constructor ||\n            String(rawDocs[key]._id) !== String(val._id)) {\n            // May need to store multiple docs with the same id if there's multiple models\n            // if we have discriminators or a ref function. But avoid converting to an array\n            // if we have multiple queries on the same model because of `perDocumentLimit` re: gh-9906\n            rawDocs[key] = [rawDocs[key], val];\n            rawOrder[key] = [rawOrder[key], i];\n          }\n        } else {\n          rawDocs[key] = val;\n          rawOrder[key] = i;\n        }\n      }\n      // flag each as result of population\n      if (!lean) {\n        val.$__.wasPopulated = val.$__.wasPopulated || { value: _val };\n      }\n    }\n  }\n\n  assignVals({\n    originalModel: model,\n    // If virtual, make sure to not mutate original field\n    rawIds: mod.isVirtual ? allIds : mod.allIds,\n    allIds: allIds,\n    unpopulatedValues: mod.unpopulatedValues,\n    foreignField: mod.foreignField,\n    rawDocs: rawDocs,\n    rawOrder: rawOrder,\n    docs: mod.docs,\n    path: options.path,\n    options: assignmentOpts,\n    justOne: mod.justOne,\n    isVirtual: mod.isVirtual,\n    allOptions: mod,\n    populatedModel: mod.model,\n    lean: lean,\n    virtual: mod.virtual,\n    count: mod.count,\n    match: mod.match\n  });\n}\n\n/**\n * Compiler utility.\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} schema\n * @param {String} collectionName\n * @param {Connection} connection\n * @param {Mongoose} base mongoose instance\n * @api private\n */\n\nModel.compile = function compile(name, schema, collectionName, connection, base) {\n  const versioningEnabled = schema.options.versionKey !== false;\n\n  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n    // add versioning to top level documents only\n    const o = {};\n    o[schema.options.versionKey] = Number;\n    schema.add(o);\n  }\n  let model;\n  if (typeof name === 'function' && name.prototype instanceof Model) {\n    model = name;\n    name = model.name;\n    schema.loadClass(model, false);\n    model.prototype.$isMongooseModelPrototype = true;\n  } else {\n    // generate new class\n    model = function model(doc, fields, skipId) {\n      model.hooks.execPreSync('createModel', doc);\n      if (!(this instanceof model)) {\n        return new model(doc, fields, skipId);\n      }\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {\n        Model.call(this, doc, fields, skipId);\n        return;\n      }\n\n      // If discriminator key is set, use the discriminator instead (gh-7586)\n      const Discriminator = model.discriminators[doc[discriminatorKey]] ||\n        getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      if (Discriminator != null) {\n        return new Discriminator(doc, fields, skipId);\n      }\n\n      // Otherwise, just use the top-level model\n      Model.call(this, doc, fields, skipId);\n    };\n  }\n\n  model.hooks = schema.s.hooks.clone();\n  model.base = base;\n  model.modelName = name;\n\n  if (!(model.prototype instanceof Model)) {\n    Object.setPrototypeOf(model, Model);\n    Object.setPrototypeOf(model.prototype, Model.prototype);\n  }\n  model.model = function model(name) {\n    return this.db.model(name);\n  };\n\n  model.db = connection;\n  model.prototype.db = connection;\n  model.prototype[modelDbSymbol] = connection;\n  model.discriminators = model.prototype.discriminators = undefined;\n  model[modelSymbol] = true;\n  model.events = new EventEmitter();\n\n  schema._preCompile();\n\n  const _userProvidedOptions = schema._userProvidedOptions || {};\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: schema.options.capped,\n    Promise: model.base.Promise,\n    modelName: name\n  };\n  if (schema.options.autoCreate !== void 0) {\n    collectionOptions.autoCreate = schema.options.autoCreate;\n  }\n\n  const collection = connection.collection(\n    collectionName,\n    collectionOptions\n  );\n\n  model.prototype.collection = collection;\n  model.prototype.$collection = collection;\n  model.prototype[modelCollectionSymbol] = collection;\n\n  model.prototype.$__setSchema(schema);\n\n  // apply methods and statics\n  applyMethods(model, schema);\n  applyStatics(model, schema);\n  applyHooks(model, schema);\n  applyStaticHooks(model, schema.s.hooks, schema.statics);\n\n  model.schema = model.prototype.$__schema;\n  model.collection = collection;\n  model.$__collection = collection;\n\n  // Create custom query constructor\n  model.Query = function() {\n    Query.apply(this, arguments);\n  };\n  Object.setPrototypeOf(model.Query.prototype, Query.prototype);\n  model.Query.base = Query.base;\n  model.Query.prototype.constructor = Query;\n  applyQueryMiddleware(model.Query, model);\n  applyQueryMethods(model, schema.query);\n\n  return model;\n};\n\n/**\n * Register custom query methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nfunction applyQueryMethods(model, methods) {\n  for (const i in methods) {\n    model.Query.prototype[i] = methods[i];\n  }\n}\n\n/**\n * Subclass this model with `conn`, `schema`, and `collection` settings.\n *\n * @param {Connection} conn\n * @param {Schema} [schema]\n * @param {String} [collection]\n * @return {Model}\n * @api private\n * @memberOf Model\n * @static\n * @method __subclass\n */\n\nModel.__subclass = function subclass(conn, schema, collection) {\n  // subclass model using this connection and collection name\n  const _this = this;\n\n  const Model = function Model(doc, fields, skipId) {\n    if (!(this instanceof Model)) {\n      return new Model(doc, fields, skipId);\n    }\n    _this.call(this, doc, fields, skipId);\n  };\n\n  Object.setPrototypeOf(Model, _this);\n  Object.setPrototypeOf(Model.prototype, _this.prototype);\n  Model.db = conn;\n  Model.prototype.db = conn;\n  Model.prototype[modelDbSymbol] = conn;\n\n  _this[subclassedSymbol] = _this[subclassedSymbol] || [];\n  _this[subclassedSymbol].push(Model);\n  if (_this.discriminators != null) {\n    Model.discriminators = {};\n    for (const key of Object.keys(_this.discriminators)) {\n      Model.discriminators[key] = _this.discriminators[key].\n        __subclass(_this.db, _this.discriminators[key].schema, collection);\n    }\n  }\n\n  const s = schema && typeof schema !== 'string'\n    ? schema\n    : _this.prototype.$__schema;\n\n  const options = s.options || {};\n  const _userProvidedOptions = s._userProvidedOptions || {};\n\n  if (!collection) {\n    collection = _this.prototype.$__schema.get('collection') ||\n      utils.toCollectionName(_this.modelName, this.base.pluralize());\n  }\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: s && options.capped\n  };\n\n  Model.prototype.collection = conn.collection(collection, collectionOptions);\n  Model.prototype.$collection = Model.prototype.collection;\n  Model.prototype[modelCollectionSymbol] = Model.prototype.collection;\n  Model.collection = Model.prototype.collection;\n  Model.$__collection = Model.collection;\n  // Errors handled internally, so ignore\n  Model.init().catch(() => {});\n  return Model;\n};\n\n/**\n * Helper for console.log. Given a model named 'MyModel', returns the string\n * `'Model { MyModel }'`.\n *\n * #### Example:\n *\n *     const MyModel = mongoose.model('Test', Schema({ name: String }));\n *     MyModel.inspect(); // 'Model { Test }'\n *     console.log(MyModel); // Prints 'Model { Test }'\n *\n * @api public\n */\n\nModel.inspect = function() {\n  return `Model { ${this.modelName} }`;\n};\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Model[util.inspect.custom] = Model.inspect;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Model;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvbW9kZWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLDJFQUFhO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLCtGQUF1QjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyx5RUFBWTtBQUNyQyw4QkFBOEIsbUJBQU8sQ0FBQyxxRkFBa0I7QUFDeEQsNEJBQTRCLG1CQUFPLENBQUMsaUdBQXdCO0FBQzVELHFCQUFxQiwwREFBOEI7QUFDbkQsK0JBQStCLG1CQUFPLENBQUMsaUdBQXdCO0FBQy9ELHVCQUF1QixtQkFBTyxDQUFDLGlGQUFnQjtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQywrRUFBZTtBQUM3Qyw0QkFBNEIsbUJBQU8sQ0FBQyxpR0FBd0I7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLG1FQUFTO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLCtGQUF1QjtBQUNuRCxlQUFlLG1CQUFPLENBQUMscUVBQVU7QUFDakMsd0JBQXdCLG1CQUFPLENBQUMseUZBQW9CO0FBQ3BELHFCQUFxQixtQkFBTyxDQUFDLG1GQUFpQjtBQUM5QywwQkFBMEIsbUJBQU8sQ0FBQyw2RkFBc0I7QUFDeEQsNEJBQTRCLG1CQUFPLENBQUMscUhBQWtDO0FBQ3RFLDRCQUE0QixtQkFBTyxDQUFDLDJIQUFxQztBQUN6RSw2QkFBNkIsbUJBQU8sQ0FBQyw2SEFBc0M7QUFDM0UsbUJBQW1CLG1CQUFPLENBQUMseUdBQTRCO0FBQ3ZELHFCQUFxQixtQkFBTyxDQUFDLDZHQUE4QjtBQUMzRCx3QkFBd0IsbUJBQU8sQ0FBQyw2SEFBc0M7QUFDdEUsNkJBQTZCLG1CQUFPLENBQUMsaUlBQXdDO0FBQzdFLHlCQUF5QixtQkFBTyxDQUFDLHFIQUFrQztBQUNuRSxxQkFBcUIsbUJBQU8sQ0FBQyw2R0FBOEI7QUFDM0QsMEJBQTBCLG1CQUFPLENBQUMseUhBQW9DO0FBQ3RFLG1C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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRSwwQkFBMEIsWUFBWSxNQUFNO0FBQzVDLDZCQUE2QixtQkFBbUIsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsRUFBRSxpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcbW9kZWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQWdncmVnYXRlID0gcmVxdWlyZSgnLi9hZ2dyZWdhdGUnKTtcbmNvbnN0IENoYW5nZVN0cmVhbSA9IHJlcXVpcmUoJy4vY3Vyc29yL0NoYW5nZVN0cmVhbScpO1xuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuL2RvY3VtZW50Jyk7XG5jb25zdCBEb2N1bWVudE5vdEZvdW5kRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL25vdEZvdW5kJyk7XG5jb25zdCBEaXZlcmdlbnRBcnJheUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9kaXZlcmdlbnRBcnJheScpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgTW9uZ29vc2VCdWxrV3JpdGVFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvYnVsa1dyaXRlRXJyb3InKTtcbmNvbnN0IE1vbmdvb3NlQnVmZmVyID0gcmVxdWlyZSgnLi90eXBlcy9idWZmZXInKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2luZGV4Jyk7XG5jb25zdCBPdmVyd3JpdGVNb2RlbEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9vdmVyd3JpdGVNb2RlbCcpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5Jyk7XG5jb25zdCBTYXZlT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9ucy9zYXZlT3B0aW9ucycpO1xuY29uc3QgU2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEnKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvdmFsaWRhdGlvbicpO1xuY29uc3QgVmVyc2lvbkVycm9yID0gcmVxdWlyZSgnLi9lcnJvci92ZXJzaW9uJyk7XG5jb25zdCBQYXJhbGxlbFNhdmVFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvcGFyYWxsZWxTYXZlJyk7XG5jb25zdCBhcHBseURlZmF1bHRzSGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RvY3VtZW50L2FwcGx5RGVmYXVsdHMnKTtcbmNvbnN0IGFwcGx5RGVmYXVsdHNUb1BPSk8gPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kZWwvYXBwbHlEZWZhdWx0c1RvUE9KTycpO1xuY29uc3QgYXBwbHlRdWVyeU1pZGRsZXdhcmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvYXBwbHlRdWVyeU1pZGRsZXdhcmUnKTtcbmNvbnN0IGFwcGx5SG9va3MgPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kZWwvYXBwbHlIb29rcycpO1xuY29uc3QgYXBwbHlNZXRob2RzID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL2FwcGx5TWV0aG9kcycpO1xuY29uc3QgYXBwbHlQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vYXBwbHlQcm9qZWN0aW9uJyk7XG5jb25zdCBhcHBseVNjaGVtYUNvbGxhdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9pbmRleGVzL2FwcGx5U2NoZW1hQ29sbGF0aW9uJyk7XG5jb25zdCBhcHBseVN0YXRpY0hvb2tzID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL2FwcGx5U3RhdGljSG9va3MnKTtcbmNvbnN0IGFwcGx5U3RhdGljcyA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9hcHBseVN0YXRpY3MnKTtcbmNvbnN0IGFwcGx5V3JpdGVDb25jZXJuID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9hcHBseVdyaXRlQ29uY2VybicpO1xuY29uc3QgYXNzaWduVmFscyA9IHJlcXVpcmUoJy4vaGVscGVycy9wb3B1bGF0ZS9hc3NpZ25WYWxzJyk7XG5jb25zdCBjYXN0QnVsa1dyaXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL2Nhc3RCdWxrV3JpdGUnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBjcmVhdGVQb3B1bGF0ZVF1ZXJ5RmlsdGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL2NyZWF0ZVBvcHVsYXRlUXVlcnlGaWx0ZXInKTtcbmNvbnN0IGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkgPSByZXF1aXJlKCcuL2hlbHBlcnMvdXBkYXRlL2RlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXknKTtcbmNvbnN0IGdldERlZmF1bHRCdWxrd3JpdGVSZXN1bHQgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0RGVmYXVsdEJ1bGt3cml0ZVJlc3VsdCcpO1xuY29uc3QgZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgZGlzY3JpbWluYXRvciA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9kaXNjcmltaW5hdG9yJyk7XG5jb25zdCBmaXJzdEtleSA9IHJlcXVpcmUoJy4vaGVscGVycy9maXJzdEtleScpO1xuY29uc3QgZWFjaCA9IHJlcXVpcmUoJy4vaGVscGVycy9lYWNoJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Jyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBnZXRNb2RlbHNNYXBGb3JQb3B1bGF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wb3B1bGF0ZS9nZXRNb2RlbHNNYXBGb3JQb3B1bGF0ZScpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3QgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IGlzRGVmYXVsdElkSW5kZXggPSByZXF1aXJlKCcuL2hlbHBlcnMvaW5kZXhlcy9pc0RlZmF1bHRJZEluZGV4Jyk7XG5jb25zdCBpc0luZGV4RXF1YWwgPSByZXF1aXJlKCcuL2hlbHBlcnMvaW5kZXhlcy9pc0luZGV4RXF1YWwnKTtcbmNvbnN0IHtcbiAgZ2V0UmVsYXRlZERCSW5kZXhlcyxcbiAgZ2V0UmVsYXRlZFNjaGVtYUluZGV4ZXNcbn0gPSByZXF1aXJlKCcuL2hlbHBlcnMvaW5kZXhlcy9nZXRSZWxhdGVkSW5kZXhlcycpO1xuY29uc3QgaXNQYXRoRXhjbHVkZWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvamVjdGlvbi9pc1BhdGhFeGNsdWRlZCcpO1xuY29uc3QgZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zID0gcmVxdWlyZSgnLi9oZWxwZXJzL2luZGV4ZXMvZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zJyk7XG5jb25zdCBpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzUGF0aFNlbGVjdGVkSW5jbHVzaXZlJyk7XG5jb25zdCBsZWFuUG9wdWxhdGVNYXAgPSByZXF1aXJlKCcuL2hlbHBlcnMvcG9wdWxhdGUvbGVhblBvcHVsYXRlTWFwJyk7XG5jb25zdCBwYXJhbGxlbExpbWl0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BhcmFsbGVsTGltaXQnKTtcbmNvbnN0IHBhcmVudFBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BhdGgvcGFyZW50UGF0aHMnKTtcbmNvbnN0IHByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvYWdncmVnYXRlL3ByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUnKTtcbmNvbnN0IHB1c2hOZXN0ZWRBcnJheVBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL3B1c2hOZXN0ZWRBcnJheVBhdGhzJyk7XG5jb25zdCByZW1vdmVEZXNlbGVjdGVkRm9yZWlnbkZpZWxkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL3JlbW92ZURlc2VsZWN0ZWRGb3JlaWduRmllbGQnKTtcbmNvbnN0IHNldERvdHRlZFBhdGggPSByZXF1aXJlKCcuL2hlbHBlcnMvcGF0aC9zZXREb3R0ZWRQYXRoJyk7XG5jb25zdCBTVEFURVMgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb25zdGF0ZScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5jb25zdCBWRVJTSU9OX1dIRVJFID0gMTtcbmNvbnN0IFZFUlNJT05fSU5DID0gMjtcbmNvbnN0IFZFUlNJT05fQUxMID0gVkVSU0lPTl9XSEVSRSB8IFZFUlNJT05fSU5DO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc1N5bWJvbDtcbmNvbnN0IG1vZGVsQ29sbGVjdGlvblN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjTW9kZWwjY29sbGVjdGlvbicpO1xuY29uc3QgbW9kZWxEYlN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjTW9kZWwjZGInKTtcbmNvbnN0IG1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS5tb2RlbFN5bWJvbDtcbmNvbnN0IHN1YmNsYXNzZWRTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI01vZGVsI3N1YmNsYXNzZWQnKTtcblxuY29uc3Qgc2F2ZVRvT2JqZWN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGludGVybmFsVG9PYmplY3RPcHRpb25zLCB7XG4gIGJzb246IHRydWUsXG4gIGZsYXR0ZW5PYmplY3RJZHM6IGZhbHNlXG59KTtcblxuLyoqXG4gKiBBIE1vZGVsIGlzIGEgY2xhc3MgdGhhdCdzIHlvdXIgcHJpbWFyeSB0b29sIGZvciBpbnRlcmFjdGluZyB3aXRoIE1vbmdvREIuXG4gKiBBbiBpbnN0YW5jZSBvZiBhIE1vZGVsIGlzIGNhbGxlZCBhIFtEb2N1bWVudF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50KS5cbiAqXG4gKiBJbiBNb25nb29zZSwgdGhlIHRlcm0gXCJNb2RlbFwiIHJlZmVycyB0byBzdWJjbGFzc2VzIG9mIHRoZSBgbW9uZ29vc2UuTW9kZWxgXG4gKiBjbGFzcy4gWW91IHNob3VsZCBub3QgdXNlIHRoZSBgbW9uZ29vc2UuTW9kZWxgIGNsYXNzIGRpcmVjdGx5LiBUaGVcbiAqIFtgbW9uZ29vc2UubW9kZWwoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUubW9kZWwoKSkgYW5kXG4gKiBbYGNvbm5lY3Rpb24ubW9kZWwoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvY29ubmVjdGlvbi5odG1sI0Nvbm5lY3Rpb24ucHJvdG90eXBlLm1vZGVsKCkpIGZ1bmN0aW9uc1xuICogY3JlYXRlIHN1YmNsYXNzZXMgb2YgYG1vbmdvb3NlLk1vZGVsYCBhcyBzaG93biBiZWxvdy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGBVc2VyTW9kZWxgIGlzIGEgXCJNb2RlbFwiLCBhIHN1YmNsYXNzIG9mIGBtb25nb29zZS5Nb2RlbGAuXG4gKiAgICAgY29uc3QgVXNlck1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqXG4gKiAgICAgLy8gWW91IGNhbiB1c2UgYSBNb2RlbCB0byBjcmVhdGUgbmV3IGRvY3VtZW50cyB1c2luZyBgbmV3YDpcbiAqICAgICBjb25zdCB1c2VyRG9jID0gbmV3IFVzZXJNb2RlbCh7IG5hbWU6ICdGb28nIH0pO1xuICogICAgIGF3YWl0IHVzZXJEb2Muc2F2ZSgpO1xuICpcbiAqICAgICAvLyBZb3UgYWxzbyB1c2UgYSBtb2RlbCB0byBjcmVhdGUgcXVlcmllczpcbiAqICAgICBjb25zdCB1c2VyRnJvbURiID0gYXdhaXQgVXNlck1vZGVsLmZpbmRPbmUoeyBuYW1lOiAnRm9vJyB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIHZhbHVlcyBmb3IgaW5pdGlhbCBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmllbGRzXSBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyB0aGUgZmllbGRzIHRoYXQgd2VyZSBzZWxlY3RlZCBpbiB0aGUgcXVlcnkgd2hpY2ggcmV0dXJuZWQgdGhpcyBkb2N1bWVudC4gWW91IGRvICoqbm90KiogbmVlZCB0byBzZXQgdGhpcyBwYXJhbWV0ZXIgdG8gZW5zdXJlIE1vbmdvb3NlIGhhbmRsZXMgeW91ciBbcXVlcnkgcHJvamVjdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKSkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwSWQ9ZmFsc2VdIG9wdGlvbmFsIGJvb2xlYW4uIElmIHRydWUsIG1vbmdvb3NlIGRvZXNuJ3QgYWRkIGFuIGBfaWRgIGZpZWxkIHRvIHRoZSBkb2N1bWVudC5cbiAqIEBpbmhlcml0cyBEb2N1bWVudCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWxcbiAqIEBldmVudCBgZXJyb3JgOiBJZiBsaXN0ZW5pbmcgdG8gdGhpcyBldmVudCwgJ2Vycm9yJyBpcyBlbWl0dGVkIHdoZW4gYSBkb2N1bWVudCB3YXMgc2F2ZWQgYW5kIGFuIGBlcnJvcmAgb2NjdXJyZWQuIElmIG5vdCBsaXN0ZW5pbmcsIHRoZSBldmVudCBidWJibGVzIHRvIHRoZSBjb25uZWN0aW9uIHVzZWQgdG8gY3JlYXRlIHRoaXMgTW9kZWwuXG4gKiBAZXZlbnQgYGluZGV4YDogRW1pdHRlZCBhZnRlciBgTW9kZWwjZW5zdXJlSW5kZXhlc2AgY29tcGxldGVzLiBJZiBhbiBlcnJvciBvY2N1cnJlZCBpdCBpcyBwYXNzZWQgd2l0aCB0aGUgZXZlbnQuXG4gKiBAZXZlbnQgYGluZGV4LXNpbmdsZS1zdGFydGA6IEVtaXR0ZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGluZGV4IHN0YXJ0cyB3aXRoaW4gYE1vZGVsI2Vuc3VyZUluZGV4ZXNgLiBUaGUgZmllbGRzIGFuZCBvcHRpb25zIGJlaW5nIHVzZWQgdG8gYnVpbGQgdGhlIGluZGV4IGFyZSBhbHNvIHBhc3NlZCB3aXRoIHRoZSBldmVudC5cbiAqIEBldmVudCBgaW5kZXgtc2luZ2xlLWRvbmVgOiBFbWl0dGVkIHdoZW4gYW4gaW5kaXZpZHVhbCBpbmRleCBmaW5pc2hlcyB3aXRoaW4gYE1vZGVsI2Vuc3VyZUluZGV4ZXNgLiBJZiBhbiBlcnJvciBvY2N1cnJlZCBpdCBpcyBwYXNzZWQgd2l0aCB0aGUgZXZlbnQuIFRoZSBmaWVsZHMsIG9wdGlvbnMsIGFuZCBpbmRleCBuYW1lIGFyZSBhbHNvIHBhc3NlZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTW9kZWwoZG9jLCBmaWVsZHMsIHNraXBJZCkge1xuICBpZiAoZmllbGRzIGluc3RhbmNlb2YgU2NoZW1hKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMm5kIGFyZ3VtZW50IHRvIGBNb2RlbGAgbXVzdCBiZSBhIFBPSk8gb3Igc3RyaW5nLCAnICtcbiAgICAgICcqKm5vdCoqIGEgc2NoZW1hLiBNYWtlIHN1cmUgeW91XFwncmUgY2FsbGluZyBgbW9uZ29vc2UubW9kZWwoKWAsIG5vdCAnICtcbiAgICAgICdgbW9uZ29vc2UuTW9kZWwoKWAuJyk7XG4gIH1cbiAgRG9jdW1lbnQuY2FsbCh0aGlzLCBkb2MsIGZpZWxkcywgc2tpcElkKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIERvY3VtZW50LlxuICpcbiAqIEFsbCBNb2RlbC5wcm90b3R5cGUgZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBvblxuICogdG9wIGxldmVsIChub24tc3ViKSBkb2N1bWVudHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoTW9kZWwucHJvdG90eXBlLCBEb2N1bWVudC5wcm90b3R5cGUpO1xuTW9kZWwucHJvdG90eXBlLiRpc01vbmdvb3NlTW9kZWxQcm90b3R5cGUgPSB0cnVlO1xuXG4vKipcbiAqIENvbm5lY3Rpb24gdGhlIG1vZGVsIHVzZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBkYlxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuZGI7XG5cbi8qKlxuICogVGhlIGNvbGxlY3Rpb24gaW5zdGFuY2UgdGhpcyBtb2RlbCB1c2VzLlxuICogQSBNb25nb29zZSBjb2xsZWN0aW9uIGlzIGEgdGhpbiB3cmFwcGVyIGFyb3VuZCBhIFtNb25nb0RCIE5vZGUuanMgZHJpdmVyIGNvbGxlY3Rpb25dKFtNb25nb0RCIE5vZGUuanMgZHJpdmVyIGNvbGxlY3Rpb25dKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS9OZXh0L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sKSkuXG4gKiBVc2luZyBgTW9kZWwuY29sbGVjdGlvbmAgbWVhbnMgeW91IGJ5cGFzcyBNb25nb29zZSBtaWRkbGV3YXJlLCB2YWxpZGF0aW9uLCBhbmQgY2FzdGluZy5cbiAqXG4gKiBUaGlzIHByb3BlcnR5IGlzIHJlYWQtb25seS4gTW9kaWZ5aW5nIHRoaXMgcHJvcGVydHkgaXMgYSBuby1vcC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNvbGxlY3Rpb25cbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQGluc3RhbmNlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLmNvbGxlY3Rpb247XG5cbi8qKlxuICogSW50ZXJuYWwgY29sbGVjdGlvbiB0aGUgbW9kZWwgdXNlcy5cbiAqXG4gKiBUaGlzIHByb3BlcnR5IGlzIHJlYWQtb25seS4gTW9kaWZ5aW5nIHRoaXMgcHJvcGVydHkgaXMgYSBuby1vcC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBwcm9wZXJ0eSBjb2xsZWN0aW9uXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBpbnN0YW5jZVxuICovXG5cblxuTW9kZWwucHJvdG90eXBlLiRfX2NvbGxlY3Rpb247XG5cbi8qKlxuICogVGhlIG5hbWUgb2YgdGhlIG1vZGVsXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBtb2RlbE5hbWVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQGluc3RhbmNlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLm1vZGVsTmFtZTtcblxuLyoqXG4gKiBBZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYXR0YWNoIHRvIHRoZSBxdWVyeSB3aGVuIGNhbGxpbmcgYHNhdmUoKWAgYW5kXG4gKiBgaXNOZXdgIGlzIGZhbHNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJHdoZXJlXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBpbnN0YW5jZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS4kd2hlcmU7XG5cbi8qKlxuICogSWYgdGhpcyBpcyBhIGRpc2NyaW1pbmF0b3IgbW9kZWwsIGBiYXNlTW9kZWxOYW1lYCBpcyB0aGUgbmFtZSBvZlxuICogdGhlIGJhc2UgbW9kZWwuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBiYXNlTW9kZWxOYW1lXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBpbnN0YW5jZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS5iYXNlTW9kZWxOYW1lO1xuXG4vKipcbiAqIEV2ZW50IGVtaXR0ZXIgdGhhdCByZXBvcnRzIGFueSBlcnJvcnMgdGhhdCBvY2N1cnJlZC4gVXNlZnVsIGZvciBnbG9iYWwgZXJyb3JcbiAqIGhhbmRsaW5nLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTXlNb2RlbC5ldmVudHMub24oJ2Vycm9yJywgZXJyID0+IGNvbnNvbGUubG9nKGVyci5tZXNzYWdlKSk7XG4gKlxuICogICAgIC8vIFByaW50cyBhICdDYXN0RXJyb3InIGJlY2F1c2Ugb2YgdGhlIGFib3ZlIGhhbmRsZXJcbiAqICAgICBhd2FpdCBNeU1vZGVsLmZpbmRPbmUoeyBfaWQ6ICdOb3QgYSB2YWxpZCBPYmplY3RJZCcgfSkuY2F0Y2gobm9vcCk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBldmVudHNcbiAqIEBmaXJlcyBlcnJvciB3aGVuZXZlciBhbnkgcXVlcnkgb3IgbW9kZWwgZnVuY3Rpb24gZXJyb3JzXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb2RlbC5ldmVudHM7XG5cbi8qKlxuICogQ29tcGlsZWQgbWlkZGxld2FyZSBmb3IgdGhpcyBtb2RlbC4gU2V0IGluIGBhcHBseUhvb2tzKClgLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHByb3BlcnR5IF9taWRkbGV3YXJlXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb2RlbC5fbWlkZGxld2FyZTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfYXBwbHlDdXN0b21XaGVyZShkb2MsIHdoZXJlKSB7XG4gIGlmIChkb2MuJHdoZXJlID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZG9jLiR3aGVyZSkpIHtcbiAgICB3aGVyZVtrZXldID0gZG9jLiR3aGVyZVtrZXldO1xuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLiRfX2hhbmRsZVNhdmUgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBzYXZlT3B0aW9ucyA9IHt9O1xuXG4gIGFwcGx5V3JpdGVDb25jZXJuKHRoaXMuJF9fc2NoZW1hLCBvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlQ29uY2VybiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzYXZlT3B0aW9ucy53cml0ZUNvbmNlcm4gPSB7fTtcbiAgICBpZiAoJ3cnIGluIG9wdGlvbnMud3JpdGVDb25jZXJuKSB7XG4gICAgICBzYXZlT3B0aW9ucy53cml0ZUNvbmNlcm4udyA9IG9wdGlvbnMud3JpdGVDb25jZXJuLnc7XG4gICAgfVxuICAgIGlmICgnaicgaW4gb3B0aW9ucy53cml0ZUNvbmNlcm4pIHtcbiAgICAgIHNhdmVPcHRpb25zLndyaXRlQ29uY2Vybi5qID0gb3B0aW9ucy53cml0ZUNvbmNlcm4uajtcbiAgICB9XG4gICAgaWYgKCd3dGltZW91dCcgaW4gb3B0aW9ucy53cml0ZUNvbmNlcm4pIHtcbiAgICAgIHNhdmVPcHRpb25zLndyaXRlQ29uY2Vybi53dGltZW91dCA9IG9wdGlvbnMud3JpdGVDb25jZXJuLnd0aW1lb3V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoJ3cnIGluIG9wdGlvbnMpIHtcbiAgICAgIHNhdmVPcHRpb25zLncgPSBvcHRpb25zLnc7XG4gICAgfVxuICAgIGlmICgnaicgaW4gb3B0aW9ucykge1xuICAgICAgc2F2ZU9wdGlvbnMuaiA9IG9wdGlvbnMuajtcbiAgICB9XG4gICAgaWYgKCd3dGltZW91dCcgaW4gb3B0aW9ucykge1xuICAgICAgc2F2ZU9wdGlvbnMud3RpbWVvdXQgPSBvcHRpb25zLnd0aW1lb3V0O1xuICAgIH1cbiAgfVxuICBpZiAoJ2NoZWNrS2V5cycgaW4gb3B0aW9ucykge1xuICAgIHNhdmVPcHRpb25zLmNoZWNrS2V5cyA9IG9wdGlvbnMuY2hlY2tLZXlzO1xuICB9XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuJHNlc3Npb24oKTtcbiAgY29uc3QgYXN5bmNMb2NhbFN0b3JhZ2UgPSB0aGlzW21vZGVsRGJTeW1ib2xdLmJhc2UudHJhbnNhY3Rpb25Bc3luY0xvY2FsU3RvcmFnZT8uZ2V0U3RvcmUoKTtcbiAgaWYgKHNlc3Npb24gIT0gbnVsbCkge1xuICAgIHNhdmVPcHRpb25zLnNlc3Npb24gPSBzZXNzaW9uO1xuICB9IGVsc2UgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KCdzZXNzaW9uJykgJiYgYXN5bmNMb2NhbFN0b3JhZ2U/LnNlc3Npb24gIT0gbnVsbCkge1xuICAgIC8vIE9ubHkgc2V0IHNlc3Npb24gZnJvbSBhc3luY0xvY2FsU3RvcmFnZSBpZiBgc2Vzc2lvbmAgb3B0aW9uIHdhc24ndCBvcmlnaW5hbGx5IHBhc3NlZCBpbiBvcHRpb25zXG4gICAgc2F2ZU9wdGlvbnMuc2Vzc2lvbiA9IGFzeW5jTG9jYWxTdG9yYWdlLnNlc3Npb247XG4gIH1cblxuICBpZiAodGhpcy4kaXNOZXcpIHtcbiAgICAvLyBzZW5kIGVudGlyZSBkb2NcbiAgICBjb25zdCBvYmogPSB0aGlzLnRvT2JqZWN0KHNhdmVUb09iamVjdE9wdGlvbnMpO1xuICAgIGlmICgob2JqIHx8IHt9KS5faWQgPT09IHZvaWQgMCkge1xuICAgICAgLy8gZG9jdW1lbnRzIG11c3QgaGF2ZSBhbiBfaWQgZWxzZSBtb25nb29zZSB3b24ndCBrbm93XG4gICAgICAvLyB3aGF0IHRvIHVwZGF0ZSBsYXRlciBpZiBtb3JlIGNoYW5nZXMgYXJlIG1hZGUuIHRoZSB1c2VyXG4gICAgICAvLyB3b3VsZG4ndCBrbm93IHdoYXQgX2lkIHdhcyBnZW5lcmF0ZWQgYnkgbW9uZ29kYiBlaXRoZXJcbiAgICAgIC8vIG5vciB3b3VsZCB0aGUgT2JqZWN0SWQgZ2VuZXJhdGVkIGJ5IG1vbmdvZGIgbmVjZXNzYXJpbHlcbiAgICAgIC8vIG1hdGNoIHRoZSBzY2hlbWEgZGVmaW5pdGlvbi5cbiAgICAgIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IE1vbmdvb3NlRXJyb3IoJ2RvY3VtZW50IG11c3QgaGF2ZSBhbiBfaWQgYmVmb3JlIHNhdmluZycpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuJF9fdmVyc2lvbih0cnVlLCBvYmopO1xuICAgIHRoaXNbbW9kZWxDb2xsZWN0aW9uU3ltYm9sXS5pbnNlcnRPbmUob2JqLCBzYXZlT3B0aW9ucykudGhlbihcbiAgICAgIHJldCA9PiBjYWxsYmFjayhudWxsLCByZXQpLFxuICAgICAgZXJyID0+IHtcbiAgICAgICAgX3NldElzTmV3KHRoaXMsIHRydWUpO1xuXG4gICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMuJF9fcmVzZXQoKTtcbiAgICBfc2V0SXNOZXcodGhpcywgZmFsc2UpO1xuICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gcmV0cnkgdGhlIGluc2VydFxuICAgIHRoaXMuJF9fLmluc2VydGluZyA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHRyZWF0IGl0IGFzIGEgbmV3IG9iamVjdCBvbiBlcnJvcixcbiAgLy8gc2luY2UgaXQgYWxyZWFkeSBleGlzdHNcbiAgdGhpcy4kX18uaW5zZXJ0aW5nID0gZmFsc2U7XG4gIGNvbnN0IGRlbHRhID0gdGhpcy4kX19kZWx0YSgpO1xuICBpZiAoZGVsdGEpIHtcbiAgICBpZiAoZGVsdGEgaW5zdGFuY2VvZiBNb25nb29zZUVycm9yKSB7XG4gICAgICBjYWxsYmFjayhkZWx0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgd2hlcmUgPSB0aGlzLiRfX3doZXJlKGRlbHRhWzBdKTtcbiAgICBpZiAod2hlcmUgaW5zdGFuY2VvZiBNb25nb29zZUVycm9yKSB7XG4gICAgICBjYWxsYmFjayh3aGVyZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2FwcGx5Q3VzdG9tV2hlcmUodGhpcywgd2hlcmUpO1xuICAgIHRoaXNbbW9kZWxDb2xsZWN0aW9uU3ltYm9sXS51cGRhdGVPbmUod2hlcmUsIGRlbHRhWzFdLCBzYXZlT3B0aW9ucykudGhlbihcbiAgICAgIHJldCA9PiB7XG4gICAgICAgIHJldC4kd2hlcmUgPSB3aGVyZTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmV0KTtcbiAgICAgIH0sXG4gICAgICBlcnIgPT4ge1xuICAgICAgICB0aGlzLiRfX3VuZG9SZXNldCgpO1xuXG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvcHRpb25zV2l0aEN1c3RvbVZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHNhdmVPcHRpb25zKTtcbiAgICBjb25zdCB3aGVyZSA9IHRoaXMuJF9fd2hlcmUoKTtcbiAgICBjb25zdCBvcHRpbWlzdGljQ29uY3VycmVuY3kgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLm9wdGltaXN0aWNDb25jdXJyZW5jeTtcbiAgICBpZiAob3B0aW1pc3RpY0NvbmN1cnJlbmN5ICYmICFBcnJheS5pc0FycmF5KG9wdGltaXN0aWNDb25jdXJyZW5jeSkpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleTtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMuJF9fZ2V0VmFsdWUoa2V5KTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICB3aGVyZVtrZXldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNvbGxlY3Rpb24uZmluZE9uZSh3aGVyZSwgb3B0aW9uc1dpdGhDdXN0b21WYWx1ZXMpXG4gICAgICAudGhlbihkb2N1bWVudEV4aXN0cyA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRDb3VudCA9ICFkb2N1bWVudEV4aXN0cyA/IDAgOiAxO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB7ICR3aGVyZTogd2hlcmUsIG1hdGNoZWRDb3VudCB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goY2FsbGJhY2spO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHN0b3JlIHRoZSBtb2RpZmllZCBwYXRocyBiZWZvcmUgdGhlIGRvY3VtZW50IGlzIHJlc2V0XG4gIHRoaXMuJF9fLm1vZGlmaWVkUGF0aHMgPSB0aGlzLm1vZGlmaWVkUGF0aHMoKTtcbiAgdGhpcy4kX19yZXNldCgpO1xuXG4gIF9zZXRJc05ldyh0aGlzLCBmYWxzZSk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS4kX19zYXZlID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdGhpcy4kX19oYW5kbGVTYXZlKG9wdGlvbnMsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zdCBob29rcyA9IHRoaXMuJF9fc2NoZW1hLnMuaG9va3M7XG4gICAgICByZXR1cm4gaG9va3MuZXhlY1Bvc3QoJ3NhdmU6ZXJyb3InLCB0aGlzLCBbdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIChlcnJvcikgPT4ge1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IG51bUFmZmVjdGVkID0gMDtcbiAgICBjb25zdCB3cml0ZUNvbmNlcm4gPSBvcHRpb25zICE9IG51bGwgP1xuICAgICAgb3B0aW9ucy53cml0ZUNvbmNlcm4gIT0gbnVsbCA/XG4gICAgICAgIG9wdGlvbnMud3JpdGVDb25jZXJuLncgOlxuICAgICAgICBvcHRpb25zLncgOlxuICAgICAgMDtcbiAgICBpZiAod3JpdGVDb25jZXJuICE9PSAwKSB7XG4gICAgICAvLyBTa2lwIGNoZWNraW5nIGlmIHdyaXRlIHN1Y2NlZWRlZCBpZiB3cml0ZUNvbmNlcm4gaXMgc2V0IHRvXG4gICAgICAvLyB1bmFja25vd2xlZGdlZCB3cml0ZXMsIGJlY2F1c2Ugb3RoZXJ3aXNlIGBudW1BZmZlY3RlZGAgd2lsbCBhbHdheXMgYmUgMFxuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICBudW1BZmZlY3RlZCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0Lm1hdGNoZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgICAgbnVtQWZmZWN0ZWQgPSByZXN1bHQubWF0Y2hlZENvdW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG51bUFmZmVjdGVkID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZlcnNpb25CdW1wID0gdGhpcy4kX18udmVyc2lvbjtcbiAgICAgIC8vIHdhcyB0aGlzIGFuIHVwZGF0ZSB0aGF0IHJlcXVpcmVkIGEgdmVyc2lvbiBidW1wP1xuICAgICAgaWYgKHZlcnNpb25CdW1wICYmICF0aGlzLiRfXy5pbnNlcnRpbmcpIHtcbiAgICAgICAgY29uc3QgZG9JbmNyZW1lbnQgPSBWRVJTSU9OX0lOQyA9PT0gKFZFUlNJT05fSU5DICYgdGhpcy4kX18udmVyc2lvbik7XG4gICAgICAgIHRoaXMuJF9fLnZlcnNpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMuJF9fZ2V0VmFsdWUoa2V5KSB8fCAwO1xuICAgICAgICBpZiAobnVtQWZmZWN0ZWQgPD0gMCkge1xuICAgICAgICAgIC8vIHRoZSB1cGRhdGUgZmFpbGVkLiBwYXNzIGFuIGVycm9yIGJhY2tcbiAgICAgICAgICB0aGlzLiRfX3VuZG9SZXNldCgpO1xuICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuJF9fLiR2ZXJzaW9uRXJyb3IgfHxcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uRXJyb3IodGhpcywgdmVyc2lvbiwgdGhpcy4kX18ubW9kaWZpZWRQYXRocyk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbmNyZW1lbnQgdmVyc2lvbiBpZiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICBpZiAoZG9JbmNyZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLiRfX3NldFZhbHVlKGtleSwgdmVyc2lvbiArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwgJiYgbnVtQWZmZWN0ZWQgPD0gMCkge1xuICAgICAgICB0aGlzLiRfX3VuZG9SZXNldCgpO1xuICAgICAgICBlcnJvciA9IG5ldyBEb2N1bWVudE5vdEZvdW5kRXJyb3IocmVzdWx0LiR3aGVyZSxcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLm1vZGVsTmFtZSwgbnVtQWZmZWN0ZWQsIHJlc3VsdCk7XG4gICAgICAgIGNvbnN0IGhvb2tzID0gdGhpcy4kX19zY2hlbWEucy5ob29rcztcbiAgICAgICAgcmV0dXJuIGhvb2tzLmV4ZWNQb3N0KCdzYXZlOmVycm9yJywgdGhpcywgW3RoaXNdLCB7IGVycm9yOiBlcnJvciB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiRfXy5zYXZpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kX18uc2F2ZWRTdGF0ZSA9IHt9O1xuICAgIHRoaXMuJGVtaXQoJ3NhdmUnLCB0aGlzLCBudW1BZmZlY3RlZCk7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5lbWl0KCdzYXZlJywgdGhpcywgbnVtQWZmZWN0ZWQpO1xuICAgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuICB9KTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdGVWZXJzaW9uRXJyb3IoZG9jLCBtb2RpZmllZFBhdGhzKSB7XG4gIGNvbnN0IGtleSA9IGRvYy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5O1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHZlcnNpb24gPSBkb2MuJF9fZ2V0VmFsdWUoa2V5KSB8fCAwO1xuICByZXR1cm4gbmV3IFZlcnNpb25FcnJvcihkb2MsIHZlcnNpb24sIG1vZGlmaWVkUGF0aHMpO1xufVxuXG4vKipcbiAqIFNhdmVzIHRoaXMgZG9jdW1lbnQgYnkgaW5zZXJ0aW5nIGEgbmV3IGRvY3VtZW50IGludG8gdGhlIGRhdGFiYXNlIGlmIFtkb2N1bWVudC5pc05ld10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5pc05ldykgaXMgYHRydWVgLFxuICogb3Igc2VuZHMgYW4gW3VwZGF0ZU9uZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS51cGRhdGVPbmUoKSkgb3BlcmF0aW9uIHdpdGgganVzdCB0aGUgbW9kaWZpZWQgcGF0aHMgaWYgYGlzTmV3YCBpcyBgZmFsc2VgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcHJvZHVjdC5zb2xkID0gRGF0ZS5ub3coKTtcbiAqICAgICBwcm9kdWN0ID0gYXdhaXQgcHJvZHVjdC5zYXZlKCk7XG4gKlxuICogSWYgc2F2ZSBpcyBzdWNjZXNzZnVsLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGZ1bGZpbGwgd2l0aCB0aGUgZG9jdW1lbnRcbiAqIHNhdmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbmV3UHJvZHVjdCA9IGF3YWl0IHByb2R1Y3Quc2F2ZSgpO1xuICogICAgIG5ld1Byb2R1Y3QgPT09IHByb2R1Y3Q7IC8vIHRydWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgb3B0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIHRoZSBbc2Vzc2lvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3NlcnZlci1zZXNzaW9ucy8pIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNhdmUgb3BlcmF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB0aGUgW2RvY3VtZW50J3MgYXNzb2NpYXRlZCBzZXNzaW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnNlc3Npb24oKSkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc2FmZV0gKERFUFJFQ0FURUQpIG92ZXJyaWRlcyBbc2NoZW1hJ3Mgc2FmZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NhZmUpLiBVc2UgdGhlIGB3YCBvcHRpb24gaW5zdGVhZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmFsaWRhdGVCZWZvcmVTYXZlXSBzZXQgdG8gZmFsc2UgdG8gc2F2ZSB3aXRob3V0IHZhbGlkYXRpbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5PWZhbHNlXSBpZiBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgb25seSB2YWxpZGF0ZSBtb2RpZmllZCBwYXRocywgYXMgb3Bwb3NlZCB0byBtb2RpZmllZCBwYXRocyBhbmQgYHJlcXVpcmVkYCBwYXRocy5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbnMud10gc2V0IHRoZSBbd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3ctb3B0aW9uKS4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIGB3cml0ZUNvbmNlcm5gIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5qXSBzZXQgdG8gdHJ1ZSBmb3IgTW9uZ29EQiB0byB3YWl0IHVudGlsIHRoaXMgYHNhdmUoKWAgaGFzIGJlZW4gW2pvdXJuYWxlZCBiZWZvcmUgcmVzb2x2aW5nIHRoZSByZXR1cm5lZCBwcm9taXNlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jai1vcHRpb24pLiBPdmVycmlkZXMgdGhlIFtzY2hlbWEtbGV2ZWwgYHdyaXRlQ29uY2VybmAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud3RpbWVvdXRdIHNldHMgYSBbdGltZW91dCBmb3IgdGhlIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3dGltZW91dCkuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCBgd3JpdGVDb25jZXJuYCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybikuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNoZWNrS2V5cz10cnVlXSB0aGUgTW9uZ29EQiBkcml2ZXIgcHJldmVudHMgeW91IGZyb20gc2F2aW5nIGtleXMgdGhhdCBzdGFydCB3aXRoICckJyBvciBjb250YWluICcuJyBieSBkZWZhdWx0LiBTZXQgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB0byBza2lwIHRoYXQgY2hlY2suIFNlZSBbcmVzdHJpY3Rpb25zIG9uIGZpZWxkIG5hbWVzXShodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS9saW1pdHMvI21vbmdvZGItbGltaXQtUmVzdHJpY3Rpb25zLW9uLUZpZWxkLU5hbWVzKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPXRydWVdIGlmIGBmYWxzZWAgYW5kIFt0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIGBzYXZlKClgLlxuICogQHRocm93cyB7RG9jdW1lbnROb3RGb3VuZEVycm9yfSBpZiB0aGlzIFtzYXZlIHVwZGF0ZXMgYW4gZXhpc3RpbmcgZG9jdW1lbnRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuaXNOZXcpIGJ1dCB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdCBpbiB0aGUgZGF0YWJhc2UuIEZvciBleGFtcGxlLCB5b3Ugd2lsbCBnZXQgdGhpcyBlcnJvciBpZiB0aGUgZG9jdW1lbnQgaXMgW2RlbGV0ZWQgYmV0d2VlbiB3aGVuIHlvdSByZXRyaWV2ZWQgdGhlIGRvY3VtZW50IGFuZCB3aGVuIHlvdSBzYXZlZCBpdF0oZG9jdW1lbnRzLmh0bWwjdXBkYXRpbmcpLlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIG1pZGRsZXdhcmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL21pZGRsZXdhcmUuaHRtbFxuICovXG5cbk1vZGVsLnByb3RvdHlwZS5zYXZlID0gYXN5bmMgZnVuY3Rpb24gc2F2ZShvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnByb3RvdHlwZS5zYXZlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgbGV0IHBhcmFsbGVsU2F2ZTtcbiAgdGhpcy4kb3AgPSAnc2F2ZSc7XG5cbiAgaWYgKHRoaXMuJF9fLnNhdmluZykge1xuICAgIHBhcmFsbGVsU2F2ZSA9IG5ldyBQYXJhbGxlbFNhdmVFcnJvcih0aGlzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLiRfXy5zYXZpbmcgPSBuZXcgUGFyYWxsZWxTYXZlRXJyb3IodGhpcyk7XG4gIH1cblxuICBvcHRpb25zID0gbmV3IFNhdmVPcHRpb25zKG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2Vzc2lvbicpKSB7XG4gICAgdGhpcy4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICB9XG4gIGlmICh0aGlzLiRfXy50aW1lc3RhbXBzICE9IG51bGwpIHtcbiAgICBvcHRpb25zLnRpbWVzdGFtcHMgPSB0aGlzLiRfXy50aW1lc3RhbXBzO1xuICB9XG4gIHRoaXMuJF9fLiR2ZXJzaW9uRXJyb3IgPSBnZW5lcmF0ZVZlcnNpb25FcnJvcih0aGlzLCB0aGlzLm1vZGlmaWVkUGF0aHMoKSk7XG5cbiAgaWYgKHBhcmFsbGVsU2F2ZSkge1xuICAgIHRoaXMuJF9faGFuZGxlUmVqZWN0KHBhcmFsbGVsU2F2ZSk7XG4gICAgdGhyb3cgcGFyYWxsZWxTYXZlO1xuICB9XG5cbiAgdGhpcy4kX18uc2F2ZU9wdGlvbnMgPSBvcHRpb25zO1xuXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLiRfX3NhdmUob3B0aW9ucywgZXJyb3IgPT4ge1xuICAgICAgdGhpcy4kX18uc2F2aW5nID0gbnVsbDtcbiAgICAgIHRoaXMuJF9fLnNhdmVPcHRpb25zID0gbnVsbDtcbiAgICAgIHRoaXMuJF9fLiR2ZXJzaW9uRXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy4kb3AgPSBudWxsO1xuICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy4kX19oYW5kbGVSZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk1vZGVsLnByb3RvdHlwZS4kc2F2ZSA9IE1vZGVsLnByb3RvdHlwZS5zYXZlO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB2ZXJzaW9uaW5nIHNob3VsZCBiZSBza2lwcGVkIGZvciB0aGUgZ2l2ZW4gcGF0aFxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IHNlbGZcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHZlcnNpb25pbmcgc2hvdWxkIGJlIHNraXBwZWQgZm9yIHRoZSBnaXZlbiBwYXRoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2hvdWxkU2tpcFZlcnNpb25pbmcoc2VsZiwgcGF0aCkge1xuICBjb25zdCBza2lwVmVyc2lvbmluZyA9IHNlbGYuJF9fc2NoZW1hLm9wdGlvbnMuc2tpcFZlcnNpb25pbmc7XG4gIGlmICghc2tpcFZlcnNpb25pbmcpIHJldHVybiBmYWxzZTtcblxuICAvLyBSZW1vdmUgYW55IGFycmF5IGluZGV4ZXMgZnJvbSB0aGUgcGF0aFxuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC5cXGQrXFwuLywgJy4nKTtcblxuICByZXR1cm4gc2tpcFZlcnNpb25pbmdbcGF0aF07XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIG9wZXJhdGlvbiB0byB0aGUgZGVsdGEgKHVwZGF0ZSkgY2xhdXNlIGFzXG4gKiB3ZWxsIGFzIHRyYWNrIHZlcnNpb25pbmcgZm9yIG91ciB3aGVyZSBjbGF1c2UuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gc2VsZlxuICogQHBhcmFtIHtPYmplY3R9IHdoZXJlIFVudXNlZFxuICogQHBhcmFtIHtPYmplY3R9IGRlbHRhXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gb3BlcmFuZChzZWxmLCB3aGVyZSwgZGVsdGEsIGRhdGEsIHZhbCwgb3ApIHtcbiAgLy8gZGVsdGFcbiAgb3AgfHwgKG9wID0gJyRzZXQnKTtcbiAgaWYgKCFkZWx0YVtvcF0pIGRlbHRhW29wXSA9IHt9O1xuICBkZWx0YVtvcF1bZGF0YS5wYXRoXSA9IHZhbDtcbiAgLy8gZGlzYWJsZWQgdmVyc2lvbmluZz9cbiAgaWYgKHNlbGYuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSA9PT0gZmFsc2UpIHJldHVybjtcblxuICAvLyBwYXRoIGV4Y2x1ZGVkIGZyb20gdmVyc2lvbmluZz9cbiAgaWYgKHNob3VsZFNraXBWZXJzaW9uaW5nKHNlbGYsIGRhdGEucGF0aCkpIHJldHVybjtcblxuICAvLyBhbHJlYWR5IG1hcmtlZCBmb3IgdmVyc2lvbmluZz9cbiAgaWYgKFZFUlNJT05fQUxMID09PSAoVkVSU0lPTl9BTEwgJiBzZWxmLiRfXy52ZXJzaW9uKSkgcmV0dXJuO1xuXG4gIGlmIChzZWxmLiRfX3NjaGVtYS5vcHRpb25zLm9wdGltaXN0aWNDb25jdXJyZW5jeSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICckc2V0JzpcbiAgICBjYXNlICckdW5zZXQnOlxuICAgIGNhc2UgJyRwb3AnOlxuICAgIGNhc2UgJyRwdWxsJzpcbiAgICBjYXNlICckcHVsbEFsbCc6XG4gICAgY2FzZSAnJHB1c2gnOlxuICAgIGNhc2UgJyRhZGRUb1NldCc6XG4gICAgY2FzZSAnJGluYyc6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZW5zdXJlIHVwZGF0ZXMgc2VudCB3aXRoIHBvc2l0aW9uYWwgbm90YXRpb24gYXJlXG4gIC8vIGVkaXRpbmcgdGhlIGNvcnJlY3QgYXJyYXkgZWxlbWVudC5cbiAgLy8gb25seSBpbmNyZW1lbnQgdGhlIHZlcnNpb24gaWYgYW4gYXJyYXkgcG9zaXRpb24gY2hhbmdlcy5cbiAgLy8gbW9kaWZ5aW5nIGVsZW1lbnRzIG9mIGFuIGFycmF5IGlzIG9rIGlmIHBvc2l0aW9uIGRvZXMgbm90IGNoYW5nZS5cbiAgaWYgKG9wID09PSAnJHB1c2gnIHx8IG9wID09PSAnJGFkZFRvU2V0JyB8fCBvcCA9PT0gJyRwdWxsQWxsJyB8fCBvcCA9PT0gJyRwdWxsJykge1xuICAgIGlmICgvXFwuXFxkK1xcLnxcXC5cXGQrJC8udGVzdChkYXRhLnBhdGgpKSB7XG4gICAgICBpbmNyZW1lbnQuY2FsbChzZWxmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi4kX18udmVyc2lvbiA9IFZFUlNJT05fSU5DO1xuICAgIH1cbiAgfSBlbHNlIGlmICgvXlxcJHAvLnRlc3Qob3ApKSB7XG4gICAgLy8gcG90ZW50aWFsbHkgY2hhbmdpbmcgYXJyYXkgcG9zaXRpb25zXG4gICAgaW5jcmVtZW50LmNhbGwoc2VsZik7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgLy8gJHNldCBhbiBhcnJheVxuICAgIGluY3JlbWVudC5jYWxsKHNlbGYpO1xuICB9IGVsc2UgaWYgKC9cXC5cXGQrXFwufFxcLlxcZCskLy50ZXN0KGRhdGEucGF0aCkpIHtcbiAgICAvLyBub3cgaGFuZGxpbmcgJHNldCwgJHVuc2V0XG4gICAgLy8gc3VicGF0aCBvZiBhcnJheVxuICAgIHNlbGYuJF9fLnZlcnNpb24gPSBWRVJTSU9OX1dIRVJFO1xuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZXMgYW4gdXBkYXRlIGFuZCB3aGVyZSBjbGF1c2UgZm9yIGEgYHZhbGAgd2l0aCBfYXRvbWljcy5cbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBzZWxmXG4gKiBAcGFyYW0ge09iamVjdH0gd2hlcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWx0YVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVBdG9taWNzKHNlbGYsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsdWUpIHtcbiAgaWYgKGRlbHRhLiRzZXQgJiYgZGVsdGEuJHNldFtkYXRhLnBhdGhdKSB7XG4gICAgLy8gJHNldCBoYXMgcHJlY2VkZW5jZSBvdmVyIG90aGVyIGF0b21pY3NcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlLiRfX2dldEF0b21pY3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZS4kX19nZXRBdG9taWNzKCkuZm9yRWFjaChmdW5jdGlvbihhdG9taWMpIHtcbiAgICAgIGNvbnN0IG9wID0gYXRvbWljWzBdO1xuICAgICAgY29uc3QgdmFsID0gYXRvbWljWzFdO1xuICAgICAgb3BlcmFuZChzZWxmLCB3aGVyZSwgZGVsdGEsIGRhdGEsIHZhbCwgb3ApO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGxlZ2FjeSBzdXBwb3J0IGZvciBwbHVnaW5zXG5cbiAgY29uc3QgYXRvbWljcyA9IHZhbHVlW2FycmF5QXRvbWljc1N5bWJvbF07XG4gIGNvbnN0IG9wcyA9IE9iamVjdC5rZXlzKGF0b21pY3MpO1xuICBsZXQgaSA9IG9wcy5sZW5ndGg7XG4gIGxldCB2YWw7XG4gIGxldCBvcDtcblxuICBpZiAoaSA9PT0gMCkge1xuICAgIC8vICRzZXRcblxuICAgIGlmICh1dGlscy5pc01vbmdvb3NlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b09iamVjdCh7IGRlcG9wdWxhdGU6IDEsIF9pc05lc3RlZDogdHJ1ZSB9KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnZhbHVlT2YpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgIH1cblxuICAgIHJldHVybiBvcGVyYW5kKHNlbGYsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcihtZW0pIHtcbiAgICByZXR1cm4gdXRpbHMuaXNNb25nb29zZU9iamVjdChtZW0pXG4gICAgICA/IG1lbS50b09iamVjdCh7IGRlcG9wdWxhdGU6IDEsIF9pc05lc3RlZDogdHJ1ZSB9KVxuICAgICAgOiBtZW07XG4gIH1cblxuICB3aGlsZSAoaS0tKSB7XG4gICAgb3AgPSBvcHNbaV07XG4gICAgdmFsID0gYXRvbWljc1tvcF07XG5cbiAgICBpZiAodXRpbHMuaXNNb25nb29zZU9iamVjdCh2YWwpKSB7XG4gICAgICB2YWwgPSB2YWwudG9PYmplY3QoeyBkZXBvcHVsYXRlOiB0cnVlLCB0cmFuc2Zvcm06IGZhbHNlLCBfaXNOZXN0ZWQ6IHRydWUgfSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbCA9IHZhbC5tYXAoaXRlcik7XG4gICAgfSBlbHNlIGlmICh2YWwudmFsdWVPZikge1xuICAgICAgdmFsID0gdmFsLnZhbHVlT2YoKTtcbiAgICB9XG5cbiAgICBpZiAob3AgPT09ICckYWRkVG9TZXQnKSB7XG4gICAgICB2YWwgPSB7ICRlYWNoOiB2YWwgfTtcbiAgICB9XG5cbiAgICBvcGVyYW5kKHNlbGYsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsLCBvcCk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9kdWNlcyBhIHNwZWNpYWwgcXVlcnkgZG9jdW1lbnQgb2YgdGhlIG1vZGlmaWVkIHByb3BlcnRpZXMgdXNlZCBpbiB1cGRhdGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19kZWx0YVxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuJF9fZGVsdGEgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZGlydHkgPSB0aGlzLiRfX2RpcnR5KCk7XG5cbiAgY29uc3Qgb3B0aW1pc3RpY0NvbmN1cnJlbmN5ID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy5vcHRpbWlzdGljQ29uY3VycmVuY3k7XG4gIGlmIChvcHRpbWlzdGljQ29uY3VycmVuY3kpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpbWlzdGljQ29uY3VycmVuY3kpKSB7XG4gICAgICBjb25zdCBvcHRDb24gPSBuZXcgU2V0KG9wdGltaXN0aWNDb25jdXJyZW5jeSk7XG4gICAgICBjb25zdCBtb2RQYXRocyA9IHRoaXMubW9kaWZpZWRQYXRocygpO1xuICAgICAgaWYgKG1vZFBhdGhzLmZpbmQocGF0aCA9PiBvcHRDb24uaGFzKHBhdGgpKSkge1xuICAgICAgICB0aGlzLiRfXy52ZXJzaW9uID0gZGlydHkubGVuZ3RoID8gVkVSU0lPTl9BTEwgOiBWRVJTSU9OX1dIRVJFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRfXy52ZXJzaW9uID0gZGlydHkubGVuZ3RoID8gVkVSU0lPTl9BTEwgOiBWRVJTSU9OX1dIRVJFO1xuICAgIH1cbiAgfVxuXG4gIGlmICghZGlydHkubGVuZ3RoICYmIFZFUlNJT05fQUxMICE9PSB0aGlzLiRfXy52ZXJzaW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdoZXJlID0ge307XG4gIGNvbnN0IGRlbHRhID0ge307XG4gIGNvbnN0IGxlbiA9IGRpcnR5Lmxlbmd0aDtcbiAgY29uc3QgZGl2ZXJnZW50ID0gW107XG4gIGxldCBkID0gMDtcblxuICB3aGVyZS5faWQgPSB0aGlzLl9kb2MuX2lkO1xuICAvLyBJZiBgX2lkYCBpcyBhbiBvYmplY3QsIG5lZWQgdG8gZGVwb3B1bGF0ZSwgYnV0IGFsc28gbmVlZCB0byBiZSBjYXJlZnVsXG4gIC8vIGJlY2F1c2UgYF9pZGAgY2FuIHRlY2huaWNhbGx5IGJlIG51bGwgKHNlZSBnaC02NDA2KVxuICBpZiAoKHdoZXJlICYmIHdoZXJlLl9pZCAmJiB3aGVyZS5faWQuJF9fIHx8IG51bGwpICE9IG51bGwpIHtcbiAgICB3aGVyZS5faWQgPSB3aGVyZS5faWQudG9PYmplY3QoeyB0cmFuc2Zvcm06IGZhbHNlLCBkZXBvcHVsYXRlOiB0cnVlIH0pO1xuICB9XG4gIGZvciAoOyBkIDwgbGVuOyArK2QpIHtcbiAgICBjb25zdCBkYXRhID0gZGlydHlbZF07XG4gICAgbGV0IHZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICBjb25zdCBtYXRjaCA9IGNoZWNrRGl2ZXJnZW50QXJyYXkodGhpcywgZGF0YS5wYXRoLCB2YWx1ZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBkaXZlcmdlbnQucHVzaChtYXRjaCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3AgPSB0aGlzLiRwb3B1bGF0ZWQoZGF0YS5wYXRoLCB0cnVlKTtcbiAgICBpZiAoIXBvcCAmJiB0aGlzLiRfXy5zZWxlY3RlZCkge1xuICAgICAgLy8gSWYgYW55IGFycmF5IHdhcyBzZWxlY3RlZCB1c2luZyBhbiAkZWxlbU1hdGNoIHByb2plY3Rpb24sIHdlIGFsdGVyIHRoZSBwYXRoIGFuZCB3aGVyZSBjbGF1c2VcbiAgICAgIC8vIE5PVEU6IE1vbmdvREIgb25seSBzdXBwb3J0cyBwcm9qZWN0ZWQgJGVsZW1NYXRjaCBvbiB0b3AgbGV2ZWwgYXJyYXkuXG4gICAgICBjb25zdCBwYXRoU3BsaXQgPSBkYXRhLnBhdGguc3BsaXQoJy4nKTtcbiAgICAgIGNvbnN0IHRvcCA9IHBhdGhTcGxpdFswXTtcbiAgICAgIGlmICh0aGlzLiRfXy5zZWxlY3RlZFt0b3BdICYmIHRoaXMuJF9fLnNlbGVjdGVkW3RvcF0uJGVsZW1NYXRjaCkge1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0ZWQgYXJyYXkgZW50cnkgd2FzIG1vZGlmaWVkXG4gICAgICAgIGlmIChwYXRoU3BsaXQubGVuZ3RoID4gMSAmJiBwYXRoU3BsaXRbMV0gPT0gMCAmJiB0eXBlb2Ygd2hlcmVbdG9wXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB3aGVyZVt0b3BdID0gdGhpcy4kX18uc2VsZWN0ZWRbdG9wXTtcbiAgICAgICAgICBwYXRoU3BsaXRbMV0gPSAnJCc7XG4gICAgICAgICAgZGF0YS5wYXRoID0gcGF0aFNwbGl0LmpvaW4oJy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgc2VsZWN0ZWQgYXJyYXkgd2FzIG1vZGlmaWVkIGluIGFueSBvdGhlciB3YXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGl2ZXJnZW50LnB1c2goZGF0YS5wYXRoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoaXMgcGF0aCBpcyBzZXQgdG8gZGVmYXVsdCwgYW5kIGVpdGhlciB0aGlzIHBhdGggb3Igb25lIG9mXG4gICAgLy8gaXRzIHBhcmVudHMgaXMgZXhjbHVkZWQsIGRvbid0IHRyZWF0IHRoaXMgcGF0aCBhcyBkaXJ0eS5cbiAgICBpZiAodGhpcy4kaXNEZWZhdWx0KGRhdGEucGF0aCkgJiYgdGhpcy4kX18uc2VsZWN0ZWQpIHtcbiAgICAgIGlmIChkYXRhLnBhdGguaW5kZXhPZignLicpID09PSAtMSAmJiBpc1BhdGhFeGNsdWRlZCh0aGlzLiRfXy5zZWxlY3RlZCwgZGF0YS5wYXRoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGF0aHNUb0NoZWNrID0gcGFyZW50UGF0aHMoZGF0YS5wYXRoKTtcbiAgICAgIGlmIChwYXRoc1RvQ2hlY2suZmluZChwYXRoID0+IGlzUGF0aEV4Y2x1ZGVkKHRoaXMuJF9fLmlzU2VsZWN0ZWQsIHBhdGgpKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGl2ZXJnZW50Lmxlbmd0aCkgY29udGludWU7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wZXJhbmQodGhpcywgd2hlcmUsIGRlbHRhLCBkYXRhLCAxLCAnJHVuc2V0Jyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgb3BlcmFuZCh0aGlzLCB3aGVyZSwgZGVsdGEsIGRhdGEsIG51bGwpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNNb25nb29zZUFycmF5KHZhbHVlKSAmJiB2YWx1ZS4kcGF0aCgpICYmIHZhbHVlW2FycmF5QXRvbWljc1N5bWJvbF0pIHtcbiAgICAgIC8vIGFycmF5cyBhbmQgb3RoZXIgY3VzdG9tIHR5cGVzIChzdXBwb3J0IHBsdWdpbnMgZXRjKVxuICAgICAgaGFuZGxlQXRvbWljcyh0aGlzLCB3aGVyZSwgZGVsdGEsIGRhdGEsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlW01vbmdvb3NlQnVmZmVyLnBhdGhTeW1ib2xdICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIC8vIE1vbmdvb3NlQnVmZmVyXG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvT2JqZWN0KCk7XG4gICAgICBvcGVyYW5kKHRoaXMsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy4kX18ucHJpbWl0aXZlQXRvbWljcyAmJiB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzW2RhdGEucGF0aF0gIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzW2RhdGEucGF0aF07XG4gICAgICAgIGNvbnN0IG9wID0gZmlyc3RLZXkodmFsKTtcbiAgICAgICAgb3BlcmFuZCh0aGlzLCB3aGVyZSwgZGVsdGEsIGRhdGEsIHZhbFtvcF0sIG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gY2xvbmUodmFsdWUsIHtcbiAgICAgICAgICBkZXBvcHVsYXRlOiB0cnVlLFxuICAgICAgICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgdmlydHVhbHM6IGZhbHNlLFxuICAgICAgICAgIGdldHRlcnM6IGZhbHNlLFxuICAgICAgICAgIG9taXRVbmRlZmluZWQ6IHRydWUsXG4gICAgICAgICAgX2lzTmVzdGVkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBvcGVyYW5kKHRoaXMsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXZlcmdlbnQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBEaXZlcmdlbnRBcnJheUVycm9yKGRpdmVyZ2VudCk7XG4gIH1cblxuICBpZiAodGhpcy4kX18udmVyc2lvbikge1xuICAgIHRoaXMuJF9fdmVyc2lvbih3aGVyZSwgZGVsdGEpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKGRlbHRhKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW3doZXJlLCBudWxsXTtcbiAgfVxuXG4gIHJldHVybiBbd2hlcmUsIGRlbHRhXTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFycmF5IHdhcyBwb3B1bGF0ZWQgd2l0aCBzb21lIGZvcm0gb2YgZmlsdGVyIGFuZCBpcyBub3dcbiAqIGJlaW5nIHVwZGF0ZWQgaW4gYSBtYW5uZXIgd2hpY2ggY291bGQgb3ZlcndyaXRlIGRhdGEgdW5pbnRlbnRpb25hbGx5LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvaXNzdWVzLzEzMzRcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7QW55fSBhcnJheVxuICogQHJldHVybiB7U3RyaW5nfHVuZGVmaW5lZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNoZWNrRGl2ZXJnZW50QXJyYXkoZG9jLCBwYXRoLCBhcnJheSkge1xuICAvLyBzZWUgaWYgd2UgcG9wdWxhdGVkIHRoaXMgcGF0aFxuICBjb25zdCBwb3AgPSBkb2MuJHBvcHVsYXRlZChwYXRoLCB0cnVlKTtcblxuICBpZiAoIXBvcCAmJiBkb2MuJF9fLnNlbGVjdGVkKSB7XG4gICAgLy8gSWYgYW55IGFycmF5IHdhcyBzZWxlY3RlZCB1c2luZyBhbiAkZWxlbU1hdGNoIHByb2plY3Rpb24sIHdlIGRlbnkgdGhlIHVwZGF0ZS5cbiAgICAvLyBOT1RFOiBNb25nb0RCIG9ubHkgc3VwcG9ydHMgcHJvamVjdGVkICRlbGVtTWF0Y2ggb24gdG9wIGxldmVsIGFycmF5LlxuICAgIGNvbnN0IHRvcCA9IHBhdGguc3BsaXQoJy4nKVswXTtcbiAgICBpZiAoZG9jLiRfXy5zZWxlY3RlZFt0b3AgKyAnLiQnXSkge1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG4gIH1cblxuICBpZiAoIShwb3AgJiYgdXRpbHMuaXNNb25nb29zZUFycmF5KGFycmF5KSkpIHJldHVybjtcblxuICAvLyBJZiB0aGUgYXJyYXkgd2FzIHBvcHVsYXRlZCB1c2luZyBvcHRpb25zIHRoYXQgcHJldmVudGVkIGFsbFxuICAvLyBkb2N1bWVudHMgZnJvbSBiZWluZyByZXR1cm5lZCAobWF0Y2gsIHNraXAsIGxpbWl0KSBvciB0aGV5XG4gIC8vIGRlc2VsZWN0ZWQgdGhlIF9pZCBmaWVsZCwgJHBvcCBhbmQgJHNldCBvZiB0aGUgYXJyYXkgYXJlXG4gIC8vIG5vdCBzYWZlIG9wZXJhdGlvbnMuIElmIF9pZCB3YXMgZGVzZWxlY3RlZCwgd2UgZG8gbm90IGtub3dcbiAgLy8gaG93IHRvIHJlbW92ZSBlbGVtZW50cy4gJHBvcCB3aWxsIHBvcCBvZmYgdGhlIF9pZCBmcm9tIHRoZSBlbmRcbiAgLy8gb2YgdGhlIGFycmF5IGluIHRoZSBkYiB3aGljaCBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSB0aGVcbiAgLy8gc2FtZSBhcyB0aGUgbGFzdCBlbGVtZW50IHdlIGhhdmUgaGVyZS4gJHNldCBvZiB0aGUgZW50aXJlIGFycmF5XG4gIC8vIHdvdWxkIGJlIHNpbWlsYXJseSBkZXN0cnVjdGl2ZSBhcyB3ZSBuZXZlciByZWNlaXZlZCBhbGxcbiAgLy8gZWxlbWVudHMgb2YgdGhlIGFycmF5IGFuZCBwb3RlbnRpYWxseSB3b3VsZCBvdmVyd3JpdGUgZGF0YS5cbiAgY29uc3QgY2hlY2sgPSBwb3Aub3B0aW9ucy5tYXRjaCB8fFxuICAgICAgcG9wLm9wdGlvbnMub3B0aW9ucyAmJiB1dGlscy5vYmplY3QuaGFzT3duUHJvcGVydHkocG9wLm9wdGlvbnMub3B0aW9ucywgJ2xpbWl0JykgfHwgLy8gMCBpcyBub3QgcGVybWl0dGVkXG4gICAgICBwb3Aub3B0aW9ucy5vcHRpb25zICYmIHBvcC5vcHRpb25zLm9wdGlvbnMuc2tpcCB8fCAvLyAwIGlzIHBlcm1pdHRlZFxuICAgICAgcG9wLm9wdGlvbnMuc2VsZWN0ICYmIC8vIGRlc2VsZWN0ZWQgX2lkP1xuICAgICAgKHBvcC5vcHRpb25zLnNlbGVjdC5faWQgPT09IDAgfHxcbiAgICAgIC9cXHM/LV9pZFxccz8vLnRlc3QocG9wLm9wdGlvbnMuc2VsZWN0KSk7XG5cbiAgaWYgKGNoZWNrKSB7XG4gICAgY29uc3QgYXRvbWljcyA9IGFycmF5W2FycmF5QXRvbWljc1N5bWJvbF07XG4gICAgaWYgKE9iamVjdC5rZXlzKGF0b21pY3MpLmxlbmd0aCA9PT0gMCB8fCBhdG9taWNzLiRzZXQgfHwgYXRvbWljcy4kcG9wKSB7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBcHBlbmRzIHZlcnNpb25pbmcgdG8gdGhlIHdoZXJlIGFuZCB1cGRhdGUgY2xhdXNlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fdmVyc2lvblxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuJF9fdmVyc2lvbiA9IGZ1bmN0aW9uKHdoZXJlLCBkZWx0YSkge1xuICBjb25zdCBrZXkgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXk7XG4gIGlmICh3aGVyZSA9PT0gdHJ1ZSkge1xuICAgIC8vIHRoaXMgaXMgYW4gaW5zZXJ0XG4gICAgaWYgKGtleSkge1xuICAgICAgc2V0RG90dGVkUGF0aChkZWx0YSwga2V5LCAwKTtcbiAgICAgIHRoaXMuJF9fc2V0VmFsdWUoa2V5LCAwKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB1cGRhdGVzXG5cbiAgLy8gb25seSBhcHBseSB2ZXJzaW9uaW5nIGlmIG91ciB2ZXJzaW9uS2V5IHdhcyBzZWxlY3RlZC4gZWxzZVxuICAvLyB0aGVyZSBpcyBubyB3YXkgdG8gc2VsZWN0IHRoZSBjb3JyZWN0IHZlcnNpb24uIHdlIGNvdWxkIGZhaWxcbiAgLy8gZmFzdCBoZXJlIGFuZCBmb3JjZSB0aGVtIHRvIGluY2x1ZGUgdGhlIHZlcnNpb25LZXkgYnV0XG4gIC8vIHRoYXRzIGEgYml0IGludHJ1c2l2ZS4gY2FuIHdlIGRvIHRoaXMgYXV0b21hdGljYWxseT9cblxuICBpZiAoIXRoaXMuJF9faXNTZWxlY3RlZChrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gJHB1c2ggJGFkZFRvU2V0IGRvbid0IG5lZWQgdGhlIHdoZXJlIGNsYXVzZSBzZXRcbiAgaWYgKFZFUlNJT05fV0hFUkUgPT09IChWRVJTSU9OX1dIRVJFICYgdGhpcy4kX18udmVyc2lvbikpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuJF9fZ2V0VmFsdWUoa2V5KTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgd2hlcmVba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKFZFUlNJT05fSU5DID09PSAoVkVSU0lPTl9JTkMgJiB0aGlzLiRfXy52ZXJzaW9uKSkge1xuICAgIGlmIChnZXQoZGVsdGEuJHNldCwga2V5LCBudWxsKSAhPSBudWxsKSB7XG4gICAgICAvLyBWZXJzaW9uIGtleSBpcyBnZXR0aW5nIHNldCwgbWVhbnMgd2UnbGwgaW5jcmVtZW50IHRoZSBkb2MncyB2ZXJzaW9uXG4gICAgICAvLyBhZnRlciBhIHN1Y2Nlc3NmdWwgc2F2ZSwgc28gd2Ugc2hvdWxkIHNldCB0aGUgaW5jcmVtZW50ZWQgdmVyc2lvbiBzb1xuICAgICAgLy8gZnV0dXJlIHNhdmVzIGRvbid0IGZhaWwgKGdoLTU3NzkpXG4gICAgICArK2RlbHRhLiRzZXRba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsdGEuJGluYyA9IGRlbHRhLiRpbmMgfHwge307XG4gICAgICBkZWx0YS4kaW5jW2tleV0gPSAxO1xuICAgIH1cbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBpbmNyZW1lbnQoKSB7XG4gIHRoaXMuJF9fLnZlcnNpb24gPSBWRVJTSU9OX0FMTDtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogU2lnbmFsIHRoYXQgd2UgZGVzaXJlIGFuIGluY3JlbWVudCBvZiB0aGlzIGRvY3VtZW50cyB2ZXJzaW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZEJ5SWQoaWQpO1xuICogICAgIGRvYy5pbmNyZW1lbnQoKTtcbiAqICAgICBhd2FpdCBkb2Muc2F2ZSgpO1xuICpcbiAqIEBzZWUgdmVyc2lvbktleXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdmVyc2lvbktleVxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAbWV0aG9kIGluY3JlbWVudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuaW5jcmVtZW50ID0gaW5jcmVtZW50O1xuXG4vKipcbiAqIFJldHVybnMgYSBxdWVyeSBvYmplY3RcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fd2hlcmVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQGluc3RhbmNlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLiRfX3doZXJlID0gZnVuY3Rpb24gX3doZXJlKHdoZXJlKSB7XG4gIHdoZXJlIHx8ICh3aGVyZSA9IHt9KTtcblxuICBpZiAoIXdoZXJlLl9pZCkge1xuICAgIHdoZXJlLl9pZCA9IHRoaXMuX2RvYy5faWQ7XG4gIH1cblxuICBpZiAodGhpcy5fZG9jLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIG5ldyBNb25nb29zZUVycm9yKCdObyBfaWQgZm91bmQgb24gZG9jdW1lbnQhJyk7XG4gIH1cblxuICByZXR1cm4gd2hlcmU7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhpcyBkb2N1bWVudCBmcm9tIHRoZSBkYi4gRXF1aXZhbGVudCB0byBgLnJlbW92ZSgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHByb2R1Y3QgPSBhd2FpdCBwcm9kdWN0LmRlbGV0ZU9uZSgpO1xuICogICAgIGF3YWl0IFByb2R1Y3QuZmluZEJ5SWQocHJvZHVjdC5faWQpOyAvLyBudWxsXG4gKlxuICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuZGVsZXRlT25lID0gYXN5bmMgZnVuY3Rpb24gZGVsZXRlT25lKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnByb3RvdHlwZS5kZWxldGVPbmUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2Vzc2lvbicpKSB7XG4gICAgdGhpcy4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICB9XG5cbiAgY29uc3QgcmVzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRoaXMuJF9fZGVsZXRlT25lKG9wdGlvbnMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLiRfX2RlbGV0ZU9uZSA9IGZ1bmN0aW9uICRfX2RlbGV0ZU9uZShvcHRpb25zLCBjYikge1xuICBpZiAodGhpcy4kX18uaXNEZWxldGVkKSB7XG4gICAgcmV0dXJuIGltbWVkaWF0ZSgoKSA9PiBjYihudWxsLCB0aGlzKSk7XG4gIH1cblxuICBjb25zdCB3aGVyZSA9IHRoaXMuJF9fd2hlcmUoKTtcbiAgaWYgKHdoZXJlIGluc3RhbmNlb2YgTW9uZ29vc2VFcnJvcikge1xuICAgIHJldHVybiBjYih3aGVyZSk7XG4gIH1cblxuICBfYXBwbHlDdXN0b21XaGVyZSh0aGlzLCB3aGVyZSk7XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuJHNlc3Npb24oKTtcbiAgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KCdzZXNzaW9uJykpIHtcbiAgICBvcHRpb25zLnNlc3Npb24gPSBzZXNzaW9uO1xuICB9XG5cbiAgdGhpc1ttb2RlbENvbGxlY3Rpb25TeW1ib2xdLmRlbGV0ZU9uZSh3aGVyZSwgb3B0aW9ucykudGhlbihcbiAgICAoKSA9PiB7XG4gICAgICB0aGlzLiRfXy5pc0RlbGV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy4kZW1pdCgnZGVsZXRlT25lJywgdGhpcyk7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmVtaXQoJ2RlbGV0ZU9uZScsIHRoaXMpO1xuICAgICAgcmV0dXJuIGNiKG51bGwsIHRoaXMpO1xuICAgIH0sXG4gICAgZXJyID0+IHtcbiAgICAgIHRoaXMuJF9fLmlzRGVsZXRlZCA9IGZhbHNlO1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gICk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1vZGVsIGluc3RhbmNlIHVzZWQgdG8gY3JlYXRlIHRoaXMgZG9jdW1lbnQgaWYgbm8gYG5hbWVgIHNwZWNpZmllZC5cbiAqIElmIGBuYW1lYCBzcGVjaWZpZWQsIHJldHVybnMgdGhlIG1vZGVsIHdpdGggdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IG5ldyBUYW5rKHt9KTtcbiAqICAgICBkb2MuJG1vZGVsKCkgPT09IFRhbms7IC8vIHRydWVcbiAqICAgICBhd2FpdCBkb2MuJG1vZGVsKCdVc2VyJykuZmluZEJ5SWQoaWQpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gbW9kZWwgbmFtZVxuICogQG1ldGhvZCAkbW9kZWxcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtNb2RlbH1cbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuJG1vZGVsID0gZnVuY3Rpb24gJG1vZGVsKG5hbWUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgfVxuICByZXR1cm4gdGhpc1ttb2RlbERiU3ltYm9sXS5tb2RlbChuYW1lKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbW9kZWwgaW5zdGFuY2UgdXNlZCB0byBjcmVhdGUgdGhpcyBkb2N1bWVudCBpZiBubyBgbmFtZWAgc3BlY2lmaWVkLlxuICogSWYgYG5hbWVgIHNwZWNpZmllZCwgcmV0dXJucyB0aGUgbW9kZWwgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gbmV3IFRhbmsoe30pO1xuICogICAgIGRvYy4kbW9kZWwoKSA9PT0gVGFuazsgLy8gdHJ1ZVxuICogICAgIGF3YWl0IGRvYy4kbW9kZWwoJ1VzZXInKS5maW5kQnlJZChpZCk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSBtb2RlbCBuYW1lXG4gKiBAbWV0aG9kIG1vZGVsXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7TW9kZWx9XG4gKi9cblxuTW9kZWwucHJvdG90eXBlLm1vZGVsID0gTW9kZWwucHJvdG90eXBlLiRtb2RlbDtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZG9jdW1lbnQgd2l0aCBgX2lkYCBvbmx5IGlmIGF0IGxlYXN0IG9uZSBkb2N1bWVudCBleGlzdHMgaW4gdGhlIGRhdGFiYXNlIHRoYXQgbWF0Y2hlc1xuICogdGhlIGdpdmVuIGBmaWx0ZXJgLCBhbmQgYG51bGxgIG90aGVyd2lzZS5cbiAqXG4gKiBVbmRlciB0aGUgaG9vZCwgYE15TW9kZWwuZXhpc3RzKHsgYW5zd2VyOiA0MiB9KWAgaXMgZXF1aXZhbGVudCB0b1xuICogYE15TW9kZWwuZmluZE9uZSh7IGFuc3dlcjogNDIgfSkuc2VsZWN0KHsgX2lkOiAxIH0pLmxlYW4oKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IENoYXJhY3Rlci5kZWxldGVNYW55KHt9KTtcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuY3JlYXRlKHsgbmFtZTogJ0plYW4tTHVjIFBpY2FyZCcgfSk7XG4gKlxuICogICAgIGF3YWl0IENoYXJhY3Rlci5leGlzdHMoeyBuYW1lOiAvcGljYXJkL2kgfSk7IC8vIHsgX2lkOiAuLi4gfVxuICogICAgIGF3YWl0IENoYXJhY3Rlci5leGlzdHMoeyBuYW1lOiAvcmlrZXIvaSB9KTsgLy8gbnVsbFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmUoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICovXG5cbk1vZGVsLmV4aXN0cyA9IGZ1bmN0aW9uIGV4aXN0cyhmaWx0ZXIsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZXhpc3RzJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmV4aXN0cygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IHF1ZXJ5ID0gdGhpcy5maW5kT25lKGZpbHRlcikuXG4gICAgc2VsZWN0KHsgX2lkOiAxIH0pLlxuICAgIGxlYW4oKS5cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiBxdWVyeTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGRpc2NyaW1pbmF0b3IgdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGZ1bmN0aW9uIEJhc2VTY2hlbWEoKSB7XG4gKiAgICAgICBTY2hlbWEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAqXG4gKiAgICAgICB0aGlzLmFkZCh7XG4gKiAgICAgICAgIG5hbWU6IFN0cmluZyxcbiAqICAgICAgICAgY3JlYXRlZEF0OiBEYXRlXG4gKiAgICAgICB9KTtcbiAqICAgICB9XG4gKiAgICAgdXRpbC5pbmhlcml0cyhCYXNlU2NoZW1hLCBTY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBQZXJzb25TY2hlbWEgPSBuZXcgQmFzZVNjaGVtYSgpO1xuICogICAgIGNvbnN0IEJvc3NTY2hlbWEgPSBuZXcgQmFzZVNjaGVtYSh7IGRlcGFydG1lbnQ6IFN0cmluZyB9KTtcbiAqXG4gKiAgICAgY29uc3QgUGVyc29uID0gbW9uZ29vc2UubW9kZWwoJ1BlcnNvbicsIFBlcnNvblNjaGVtYSk7XG4gKiAgICAgY29uc3QgQm9zcyA9IFBlcnNvbi5kaXNjcmltaW5hdG9yKCdCb3NzJywgQm9zc1NjaGVtYSk7XG4gKiAgICAgbmV3IEJvc3MoKS5fX3Q7IC8vIFwiQm9zc1wiLiBgX190YCBpcyB0aGUgZGVmYXVsdCBgZGlzY3JpbWluYXRvcktleWBcbiAqXG4gKiAgICAgY29uc3QgZW1wbG95ZWVTY2hlbWEgPSBuZXcgU2NoZW1hKHsgYm9zczogT2JqZWN0SWQgfSk7XG4gKiAgICAgY29uc3QgRW1wbG95ZWUgPSBQZXJzb24uZGlzY3JpbWluYXRvcignRW1wbG95ZWUnLCBlbXBsb3llZVNjaGVtYSwgJ3N0YWZmJyk7XG4gKiAgICAgbmV3IEVtcGxveWVlKCkuX190OyAvLyBcInN0YWZmXCIgYmVjYXVzZSBvZiAzcmQgYXJndW1lbnQgYWJvdmVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBkaXNjcmltaW5hdG9yIG1vZGVsIG5hbWVcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWEgZGlzY3JpbWluYXRvciBtb2RlbCBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnNdIElmIHN0cmluZywgc2FtZSBhcyBgb3B0aW9ucy52YWx1ZWAuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudmFsdWVdIHRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBgZGlzY3JpbWluYXRvcktleWAgcHJvcGVydHkuIElmIG5vdCBzcGVjaWZpZWQsIE1vbmdvb3NlIHVzZXMgdGhlIGBuYW1lYCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsb25lPXRydWVdIEJ5IGRlZmF1bHQsIGBkaXNjcmltaW5hdG9yKClgIGNsb25lcyB0aGUgZ2l2ZW4gYHNjaGVtYWAuIFNldCB0byBgZmFsc2VgIHRvIHNraXAgY2xvbmluZy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlTW9kZWxzPWZhbHNlXSBieSBkZWZhdWx0LCBNb25nb29zZSBkb2VzIG5vdCBhbGxvdyB5b3UgdG8gZGVmaW5lIGEgZGlzY3JpbWluYXRvciB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgYW5vdGhlciBkaXNjcmltaW5hdG9yLiBTZXQgdGhpcyB0byBhbGxvdyBvdmVyd3JpdGluZyBkaXNjcmltaW5hdG9ycyB3aXRoIHRoZSBzYW1lIG5hbWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1lcmdlSG9va3M9dHJ1ZV0gQnkgZGVmYXVsdCwgTW9uZ29vc2UgbWVyZ2VzIHRoZSBiYXNlIHNjaGVtYSdzIGhvb2tzIHdpdGggdGhlIGRpc2NyaW1pbmF0b3Igc2NoZW1hJ3MgaG9va3MuIFNldCB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHRvIG1ha2UgTW9uZ29vc2UgdXNlIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSdzIGhvb2tzIGluc3RlYWQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1lcmdlUGx1Z2lucz10cnVlXSBCeSBkZWZhdWx0LCBNb25nb29zZSBtZXJnZXMgdGhlIGJhc2Ugc2NoZW1hJ3MgcGx1Z2lucyB3aXRoIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSdzIHBsdWdpbnMuIFNldCB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHRvIG1ha2UgTW9uZ29vc2UgdXNlIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSdzIHBsdWdpbnMgaW5zdGVhZC5cbiAqIEByZXR1cm4ge01vZGVsfSBUaGUgbmV3bHkgY3JlYXRlZCBkaXNjcmltaW5hdG9yIG1vZGVsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmRpc2NyaW1pbmF0b3IgPSBmdW5jdGlvbihuYW1lLCBzY2hlbWEsIG9wdGlvbnMpIHtcbiAgbGV0IG1vZGVsO1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBtb2RlbCA9IG5hbWU7XG4gICAgbmFtZSA9IHV0aWxzLmdldEZ1bmN0aW9uTmFtZShtb2RlbCk7XG4gICAgaWYgKCEobW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignVGhlIHByb3ZpZGVkIGNsYXNzICcgKyBuYW1lICsgJyBtdXN0IGV4dGVuZCBNb2RlbCcpO1xuICAgIH1cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCB2YWx1ZSA9IHV0aWxzLmlzUE9KTyhvcHRpb25zKSA/IG9wdGlvbnMudmFsdWUgOiBvcHRpb25zO1xuICBjb25zdCBjbG9uZSA9IHR5cGVvZiBvcHRpb25zLmNsb25lID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNsb25lIDogdHJ1ZTtcbiAgY29uc3QgbWVyZ2VQbHVnaW5zID0gdHlwZW9mIG9wdGlvbnMubWVyZ2VQbHVnaW5zID09PSAnYm9vbGVhbicgPyBvcHRpb25zLm1lcmdlUGx1Z2lucyA6IHRydWU7XG5cbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZGlzY3JpbWluYXRvcicpO1xuXG4gIGlmICh1dGlscy5pc09iamVjdChzY2hlbWEpICYmICFzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgIHNjaGVtYSA9IG5ldyBTY2hlbWEoc2NoZW1hKTtcbiAgfVxuICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hICYmIGNsb25lKSB7XG4gICAgc2NoZW1hID0gc2NoZW1hLmNsb25lKCk7XG4gIH1cblxuICBzY2hlbWEgPSBkaXNjcmltaW5hdG9yKHRoaXMsIG5hbWUsIHNjaGVtYSwgdmFsdWUsIG1lcmdlUGx1Z2lucywgb3B0aW9ucy5tZXJnZUhvb2tzKTtcbiAgaWYgKHRoaXMuZGIubW9kZWxzW25hbWVdICYmICFzY2hlbWEub3B0aW9ucy5vdmVyd3JpdGVNb2RlbHMpIHtcbiAgICB0aHJvdyBuZXcgT3ZlcndyaXRlTW9kZWxFcnJvcihuYW1lKTtcbiAgfVxuXG4gIHNjaGVtYS4kaXNSb290RGlzY3JpbWluYXRvciA9IHRydWU7XG4gIHNjaGVtYS4kZ2xvYmFsUGx1Z2luc0FwcGxpZWQgPSB0cnVlO1xuXG4gIG1vZGVsID0gdGhpcy5kYi5tb2RlbChtb2RlbCB8fCBuYW1lLCBzY2hlbWEsIHRoaXMuJF9fY29sbGVjdGlvbi5uYW1lKTtcbiAgdGhpcy5kaXNjcmltaW5hdG9yc1tuYW1lXSA9IG1vZGVsO1xuICBjb25zdCBkID0gdGhpcy5kaXNjcmltaW5hdG9yc1tuYW1lXTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGQucHJvdG90eXBlLCB0aGlzLnByb3RvdHlwZSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkLCAnYmFzZU1vZGVsTmFtZScsIHtcbiAgICB2YWx1ZTogdGhpcy5tb2RlbE5hbWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcblxuICAvLyBhcHBseSBtZXRob2RzIGFuZCBzdGF0aWNzXG4gIGFwcGx5TWV0aG9kcyhkLCBzY2hlbWEpO1xuICBhcHBseVN0YXRpY3MoZCwgc2NoZW1hKTtcblxuICBpZiAodGhpc1tzdWJjbGFzc2VkU3ltYm9sXSAhPSBudWxsKSB7XG4gICAgZm9yIChjb25zdCBzdWJtb2RlbCBvZiB0aGlzW3N1YmNsYXNzZWRTeW1ib2xdKSB7XG4gICAgICBzdWJtb2RlbC5kaXNjcmltaW5hdG9ycyA9IHN1Ym1vZGVsLmRpc2NyaW1pbmF0b3JzIHx8IHt9O1xuICAgICAgc3VibW9kZWwuZGlzY3JpbWluYXRvcnNbbmFtZV0gPVxuICAgICAgICBtb2RlbC5fX3N1YmNsYXNzKG1vZGVsLmRiLCBzY2hlbWEsIHN1Ym1vZGVsLmNvbGxlY3Rpb24ubmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGQ7XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSBgdGhpc2AgaXMgYSBtb2RlbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2NoZWNrQ29udGV4dChjdHgsIGZuTmFtZSkge1xuICAvLyBDaGVjayBjb250ZXh0LCBiZWNhdXNlIGl0IGlzIGVhc3kgdG8gbWlzdGFrZW5seSB0eXBlXG4gIC8vIGBuZXcgTW9kZWwuZGlzY3JpbWluYXRvcigpYCBhbmQgZ2V0IGFuIGluY29tcHJlaGVuc2libGUgZXJyb3JcbiAgaWYgKGN0eCA9PSBudWxsIHx8IGN0eCA9PT0gZ2xvYmFsKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ2BNb2RlbC4nICsgZm5OYW1lICsgJygpYCBjYW5ub3QgcnVuIHdpdGhvdXQgYSAnICtcbiAgICAgICdtb2RlbCBhcyBgdGhpc2AuIE1ha2Ugc3VyZSB5b3UgYXJlIGNhbGxpbmcgYE15TW9kZWwuJyArIGZuTmFtZSArICcoKWAgJyArXG4gICAgICAnd2hlcmUgYE15TW9kZWxgIGlzIGEgTW9uZ29vc2UgbW9kZWwuJyk7XG4gIH0gZWxzZSBpZiAoY3R4W21vZGVsU3ltYm9sXSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ2BNb2RlbC4nICsgZm5OYW1lICsgJygpYCBjYW5ub3QgcnVuIHdpdGhvdXQgYSAnICtcbiAgICAgICdtb2RlbCBhcyBgdGhpc2AuIE1ha2Ugc3VyZSB5b3UgYXJlIG5vdCBjYWxsaW5nICcgK1xuICAgICAgJ2BuZXcgTW9kZWwuJyArIGZuTmFtZSArICcoKWAnKTtcbiAgfVxufVxuXG4vLyBNb2RlbCAoY2xhc3MpIGZlYXR1cmVzXG5cbi8qIVxuICogR2l2ZSB0aGUgY29uc3RydWN0b3IgdGhlIGFiaWxpdHkgdG8gZW1pdCBldmVudHMuXG4gKi9cblxuZm9yIChjb25zdCBpIGluIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpIHtcbiAgTW9kZWxbaV0gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlW2ldO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIGJ1aWxkaW5nIFtpbmRleGVzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9pbmRleGVzLyksXG4gKiB1bmxlc3MgW2BhdXRvSW5kZXhgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNhdXRvSW5kZXgpIGlzIHR1cm5lZCBvZmYuXG4gKlxuICogTW9uZ29vc2UgY2FsbHMgdGhpcyBmdW5jdGlvbiBhdXRvbWF0aWNhbGx5IHdoZW4gYSBtb2RlbCBpcyBjcmVhdGVkIHVzaW5nXG4gKiBbYG1vbmdvb3NlLm1vZGVsKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLm1vZGVsKCkpIG9yXG4gKiBbYGNvbm5lY3Rpb24ubW9kZWwoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvY29ubmVjdGlvbi5odG1sI0Nvbm5lY3Rpb24ucHJvdG90eXBlLm1vZGVsKCkpLCBzbyB5b3VcbiAqIGRvbid0IG5lZWQgdG8gY2FsbCBgaW5pdCgpYCB0byB0cmlnZ2VyIGluZGV4IGJ1aWxkcy5cbiAqXG4gKiBIb3dldmVyLCB5b3UgX21heV8gbmVlZCB0byBjYWxsIGBpbml0KClgICB0byBnZXQgYmFjayBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiB5b3VyIGluZGV4ZXMgYXJlIGZpbmlzaGVkLlxuICogQ2FsbGluZyBgYXdhaXQgTW9kZWwuaW5pdCgpYCBpcyBoZWxwZnVsIGlmIHlvdSBuZWVkIHRvIHdhaXQgZm9yIGluZGV4ZXMgdG8gYnVpbGQgYmVmb3JlIGNvbnRpbnVpbmcuXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gd2FpdCBmb3IgdW5pcXVlIGluZGV4ZXMgdG8gYnVpbGQgYmVmb3JlIGNvbnRpbnVpbmcgd2l0aCBhIHRlc3QgY2FzZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGV2ZW50U2NoZW1hID0gbmV3IFNjaGVtYSh7IHRoaW5nOiB7IHR5cGU6ICdzdHJpbmcnLCB1bmlxdWU6IHRydWUgfSB9KVxuICogICAgIC8vIFRoaXMgY2FsbHMgYEV2ZW50LmluaXQoKWAgaW1wbGljaXRseSwgc28geW91IGRvbid0IG5lZWQgdG8gY2FsbFxuICogICAgIC8vIGBFdmVudC5pbml0KClgIG9uIHlvdXIgb3duLlxuICogICAgIGNvbnN0IEV2ZW50ID0gbW9uZ29vc2UubW9kZWwoJ0V2ZW50JywgZXZlbnRTY2hlbWEpO1xuICpcbiAqICAgICBhd2FpdCBFdmVudC5pbml0KCk7XG4gKiAgICAgY29uc29sZS5sb2coJ0luZGV4ZXMgYXJlIGRvbmUgYnVpbGRpbmchJyk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5cbk1vZGVsLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdpbml0Jyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmluaXQoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICB0aGlzLnNjaGVtYS5lbWl0KCdpbml0JywgdGhpcyk7XG5cbiAgaWYgKHRoaXMuJGluaXQgIT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLiRpbml0O1xuICB9XG5cbiAgY29uc3QgY29ubiA9IHRoaXMuZGI7XG4gIGNvbnN0IF9lbnN1cmVJbmRleGVzID0gYXN5bmMoKSA9PiB7XG4gICAgY29uc3QgYXV0b0luZGV4ID0gdXRpbHMuZ2V0T3B0aW9uKFxuICAgICAgJ2F1dG9JbmRleCcsXG4gICAgICB0aGlzLnNjaGVtYS5vcHRpb25zLFxuICAgICAgY29ubi5jb25maWcsXG4gICAgICBjb25uLmJhc2Uub3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFhdXRvSW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5zdXJlSW5kZXhlcyh7IF9hdXRvbWF0aWM6IHRydWUgfSk7XG4gIH07XG4gIGNvbnN0IF9jcmVhdGVDb2xsZWN0aW9uID0gYXN5bmMoKSA9PiB7XG4gICAgaWYgKChjb25uLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nIHx8IGNvbm4ucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmRpc2Nvbm5lY3RlZCkgJiYgY29ubi5fc2hvdWxkQnVmZmVyQ29tbWFuZHMoKSkge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbm4uX3F1ZXVlLnB1c2goeyBmbjogcmVzb2x2ZSB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhdXRvQ3JlYXRlID0gdXRpbHMuZ2V0T3B0aW9uKFxuICAgICAgJ2F1dG9DcmVhdGUnLFxuICAgICAgdGhpcy5zY2hlbWEub3B0aW9ucyxcbiAgICAgIGNvbm4uY29uZmlnLFxuICAgICAgY29ubi5iYXNlLm9wdGlvbnNcbiAgICApO1xuICAgIGlmICghYXV0b0NyZWF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVDb2xsZWN0aW9uKCk7XG4gIH07XG5cbiAgdGhpcy4kaW5pdCA9IF9jcmVhdGVDb2xsZWN0aW9uKCkudGhlbigoKSA9PiBfZW5zdXJlSW5kZXhlcygpKTtcblxuICBjb25zdCBfY2F0Y2ggPSB0aGlzLiRpbml0LmNhdGNoO1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIHRoaXMuJGluaXQuY2F0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICBfdGhpcy4kY2F1Z2h0ID0gdHJ1ZTtcbiAgICByZXR1cm4gX2NhdGNoLmFwcGx5KF90aGlzLiRpbml0LCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHJldHVybiB0aGlzLiRpbml0O1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSB0aGUgY29sbGVjdGlvbiBmb3IgdGhpcyBtb2RlbC4gQnkgZGVmYXVsdCwgaWYgbm8gaW5kZXhlcyBhcmUgc3BlY2lmaWVkLFxuICogbW9uZ29vc2Ugd2lsbCBub3QgY3JlYXRlIHRoZSBjb2xsZWN0aW9uIGZvciB0aGUgbW9kZWwgdW50aWwgYW55IGRvY3VtZW50cyBhcmVcbiAqIGNyZWF0ZWQuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgdGhlIGNvbGxlY3Rpb24gZXhwbGljaXRseS5cbiAqXG4gKiBOb3RlIDE6IFlvdSBtYXkgbmVlZCB0byBjYWxsIHRoaXMgYmVmb3JlIHN0YXJ0aW5nIGEgdHJhbnNhY3Rpb25cbiAqIFNlZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL3RyYW5zYWN0aW9ucy8jdHJhbnNhY3Rpb25zLWFuZC1vcGVyYXRpb25zXG4gKlxuICogTm90ZSAyOiBZb3UgZG9uJ3QgaGF2ZSB0byBjYWxsIHRoaXMgaWYgeW91ciBzY2hlbWEgY29udGFpbnMgaW5kZXggb3IgdW5pcXVlIGZpZWxkLlxuICogSW4gdGhhdCBjYXNlLCBqdXN0IHVzZSBgTW9kZWwuaW5pdCgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSlcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCB1c2VyU2NoZW1hKTtcbiAqXG4gKiAgICAgVXNlci5jcmVhdGVDb2xsZWN0aW9uKCkudGhlbihmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygnQ29sbGVjdGlvbiBpcyBjcmVhdGVkIScpO1xuICogICAgIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNlZSBbTW9uZ29EQiBkcml2ZXIgZG9jc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0RiLmh0bWwjY3JlYXRlQ29sbGVjdGlvbilcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5cbk1vZGVsLmNyZWF0ZUNvbGxlY3Rpb24gPSBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9uKG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnY3JlYXRlQ29sbGVjdGlvbicpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmNyZWF0ZUNvbGxlY3Rpb24oKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBjb2xsZWN0aW9uT3B0aW9ucyA9IHRoaXMgJiZcbiAgICB0aGlzLnNjaGVtYSAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zLmNvbGxlY3Rpb25PcHRpb25zO1xuICBpZiAoY29sbGVjdGlvbk9wdGlvbnMgIT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBjb2xsZWN0aW9uT3B0aW9ucywgb3B0aW9ucyk7XG4gIH1cblxuICBjb25zdCBzY2hlbWFDb2xsYXRpb24gPSB0aGlzICYmXG4gICAgdGhpcy5zY2hlbWEgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucy5jb2xsYXRpb247XG4gIGlmIChzY2hlbWFDb2xsYXRpb24gIT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY29sbGF0aW9uOiBzY2hlbWFDb2xsYXRpb24gfSwgb3B0aW9ucyk7XG4gIH1cbiAgY29uc3QgY2FwcGVkID0gdGhpcyAmJlxuICAgIHRoaXMuc2NoZW1hICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucyAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMuY2FwcGVkO1xuICBpZiAoY2FwcGVkICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGNhcHBlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY2FwcGVkOiB0cnVlLCBzaXplOiBjYXBwZWQgfSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2FwcGVkID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBjYXBwZWQ6IHRydWUgfSwgY2FwcGVkLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdGltZXNlcmllcyA9IHRoaXMgJiZcbiAgICB0aGlzLnNjaGVtYSAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zLnRpbWVzZXJpZXM7XG4gIGlmICh0aW1lc2VyaWVzICE9IG51bGwpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHRpbWVzZXJpZXMgfSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuZXhwaXJlQWZ0ZXJTZWNvbmRzICE9IG51bGwpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZXhwaXJlcyAhPSBudWxsKSB7XG4gICAgICB1dGlscy5leHBpcmVzKG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zY2hlbWEub3B0aW9ucy5leHBpcmVBZnRlclNlY29uZHMgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5leHBpcmVBZnRlclNlY29uZHMgPSB0aGlzLnNjaGVtYS5vcHRpb25zLmV4cGlyZUFmdGVyU2Vjb25kcztcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2NoZW1hLm9wdGlvbnMuZXhwaXJlcyAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLmV4cGlyZXMgPSB0aGlzLnNjaGVtYS5vcHRpb25zLmV4cGlyZXM7XG4gICAgICB1dGlscy5leHBpcmVzKG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNsdXN0ZXJlZEluZGV4ID0gdGhpcyAmJlxuICAgIHRoaXMuc2NoZW1hICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucyAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMuY2x1c3RlcmVkSW5kZXg7XG4gIGlmIChjbHVzdGVyZWRJbmRleCAhPSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBjbHVzdGVyZWRJbmRleDogeyAuLi5jbHVzdGVyZWRJbmRleCwgdW5pcXVlOiB0cnVlIH0gfSwgb3B0aW9ucyk7XG4gIH1cblxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuZGIuY3JlYXRlQ29sbGVjdGlvbih0aGlzLiRfX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlcnIpIHtcblxuICAgIGlmIChlcnIgIT0gbnVsbCAmJiAoZXJyLm5hbWUgIT09ICdNb25nb1NlcnZlckVycm9yJyB8fCBlcnIuY29kZSAhPT0gNDgpKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLiRfX2NvbGxlY3Rpb247XG59O1xuXG4vKipcbiAqIE1ha2VzIHRoZSBpbmRleGVzIGluIE1vbmdvREIgbWF0Y2ggdGhlIGluZGV4ZXMgZGVmaW5lZCBpbiB0aGlzIG1vZGVsJ3NcbiAqIHNjaGVtYS4gVGhpcyBmdW5jdGlvbiB3aWxsIGRyb3AgYW55IGluZGV4ZXMgdGhhdCBhcmUgbm90IGRlZmluZWQgaW5cbiAqIHRoZSBtb2RlbCdzIHNjaGVtYSBleGNlcHQgdGhlIGBfaWRgIGluZGV4LCBhbmQgYnVpbGQgYW55IGluZGV4ZXMgdGhhdFxuICogYXJlIGluIHlvdXIgc2NoZW1hIGJ1dCBub3QgaW4gTW9uZ29EQi5cbiAqXG4gKiBTZWUgdGhlIFtpbnRyb2R1Y3RvcnkgYmxvZyBwb3N0XShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3doYXRzLW5ldy1pbi1tb25nb29zZS01LTItc3luY2luZGV4ZXMpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgdW5pcXVlOiB0cnVlIH0gfSk7XG4gKiAgICAgY29uc3QgQ3VzdG9tZXIgPSBtb25nb29zZS5tb2RlbCgnQ3VzdG9tZXInLCBzY2hlbWEpO1xuICogICAgIGF3YWl0IEN1c3RvbWVyLmNvbGxlY3Rpb24uY3JlYXRlSW5kZXgoeyBhZ2U6IDEgfSk7IC8vIEluZGV4IGlzIG5vdCBpbiBzY2hlbWFcbiAqICAgICAvLyBXaWxsIGRyb3AgdGhlICdhZ2UnIGluZGV4IGFuZCBjcmVhdGUgYW4gaW5kZXggb24gYG5hbWVgXG4gKiAgICAgYXdhaXQgQ3VzdG9tZXIuc3luY0luZGV4ZXMoKTtcbiAqXG4gKiBZb3Ugc2hvdWxkIGJlIGNhcmVmdWwgYWJvdXQgcnVubmluZyBgc3luY0luZGV4ZXMoKWAgb24gcHJvZHVjdGlvbiBhcHBsaWNhdGlvbnMgdW5kZXIgaGVhdnkgbG9hZCxcbiAqIGJlY2F1c2UgaW5kZXggYnVpbGRzIGFyZSBleHBlbnNpdmUgb3BlcmF0aW9ucywgYW5kIHVuZXhwZWN0ZWQgaW5kZXggZHJvcHMgY2FuIGxlYWQgdG8gZGVncmFkZWRcbiAqIHBlcmZvcm1hbmNlLiBCZWZvcmUgcnVubmluZyBgc3luY0luZGV4ZXMoKWAsIHlvdSBjYW4gdXNlIHRoZSBbYGRpZmZJbmRleGVzKClgIGZ1bmN0aW9uXSgjTW9kZWwuZGlmZkluZGV4ZXMoKSlcbiAqIHRvIGNoZWNrIHdoYXQgaW5kZXhlcyBgc3luY0luZGV4ZXMoKWAgd2lsbCBkcm9wIGFuZCBjcmVhdGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB7IHRvRHJvcCwgdG9DcmVhdGUgfSA9IGF3YWl0IE1vZGVsLmRpZmZJbmRleGVzKCk7XG4gKiAgICAgdG9Ecm9wOyAvLyBBcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgbmFtZXMgb2YgaW5kZXhlcyB0aGF0IGBzeW5jSW5kZXhlcygpYCB3aWxsIGRyb3BcbiAqICAgICB0b0NyZWF0ZTsgLy8gQXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIG5hbWVzIG9mIGluZGV4ZXMgdGhhdCBgc3luY0luZGV4ZXMoKWAgd2lsbCBjcmVhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgdG8gcGFzcyB0byBgZW5zdXJlSW5kZXhlcygpYFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iYWNrZ3JvdW5kPW51bGxdIGlmIHNwZWNpZmllZCwgb3ZlcnJpZGVzIGVhY2ggaW5kZXgncyBgYmFja2dyb3VuZGAgcHJvcGVydHlcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnN5bmNJbmRleGVzID0gYXN5bmMgZnVuY3Rpb24gc3luY0luZGV4ZXMob3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdzeW5jSW5kZXhlcycpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnN5bmNJbmRleGVzKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbW9kZWwgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgbW9kZWwuY3JlYXRlQ29sbGVjdGlvbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyICE9IG51bGwgJiYgKGVyci5uYW1lICE9PSAnTW9uZ29TZXJ2ZXJFcnJvcicgfHwgZXJyLmNvZGUgIT09IDQ4KSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRpZmZJbmRleGVzUmVzdWx0ID0gYXdhaXQgbW9kZWwuZGlmZkluZGV4ZXMoKTtcbiAgY29uc3QgZHJvcHBlZCA9IGF3YWl0IG1vZGVsLmNsZWFuSW5kZXhlcyh7IC4uLm9wdGlvbnMsIHRvRHJvcDogZGlmZkluZGV4ZXNSZXN1bHQudG9Ecm9wIH0pO1xuICBhd2FpdCBtb2RlbC5jcmVhdGVJbmRleGVzKHsgLi4ub3B0aW9ucywgdG9DcmVhdGU6IGRpZmZJbmRleGVzUmVzdWx0LnRvQ3JlYXRlIH0pO1xuXG4gIHJldHVybiBkcm9wcGVkO1xufTtcblxuLyoqXG4gKiBEb2VzIGEgZHJ5LXJ1biBvZiBgTW9kZWwuc3luY0luZGV4ZXMoKWAsIHJldHVybmluZyB0aGUgaW5kZXhlcyB0aGF0IGBzeW5jSW5kZXhlcygpYCB3b3VsZCBkcm9wIGFuZCBjcmVhdGUgaWYgeW91IHdlcmUgdG8gcnVuIGBzeW5jSW5kZXhlcygpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHsgdG9Ecm9wLCB0b0NyZWF0ZSB9ID0gYXdhaXQgTW9kZWwuZGlmZkluZGV4ZXMoKTtcbiAqICAgICB0b0Ryb3A7IC8vIEFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyBuYW1lcyBvZiBpbmRleGVzIHRoYXQgYHN5bmNJbmRleGVzKClgIHdpbGwgZHJvcFxuICogICAgIHRvQ3JlYXRlOyAvLyBBcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgbmFtZXMgb2YgaW5kZXhlcyB0aGF0IGBzeW5jSW5kZXhlcygpYCB3aWxsIGNyZWF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gY29udGFpbnMgdGhlIGluZGV4ZXMgdGhhdCB3b3VsZCBiZSBkcm9wcGVkIGluIE1vbmdvREIgYW5kIGluZGV4ZXMgdGhhdCB3b3VsZCBiZSBjcmVhdGVkIGluIE1vbmdvREIgYXMgYHsgdG9Ecm9wOiBzdHJpbmdbXSwgdG9DcmVhdGU6IHN0cmluZ1tdIH1gLlxuICovXG5cbk1vZGVsLmRpZmZJbmRleGVzID0gYXN5bmMgZnVuY3Rpb24gZGlmZkluZGV4ZXMoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuc3luY0luZGV4ZXMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBtb2RlbCA9IHRoaXM7XG5cbiAgbGV0IGRiSW5kZXhlcyA9IGF3YWl0IG1vZGVsLmxpc3RJbmRleGVzKCkuY2F0Y2goZXJyID0+IHtcbiAgICBpZiAoZXJyLmNvZGVOYW1lID09ICdOYW1lc3BhY2VOb3RGb3VuZCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfSk7XG4gIGlmIChkYkluZGV4ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIGRiSW5kZXhlcyA9IFtdO1xuICB9XG4gIGRiSW5kZXhlcyA9IGdldFJlbGF0ZWREQkluZGV4ZXMobW9kZWwsIGRiSW5kZXhlcyk7XG5cbiAgY29uc3Qgc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuICBjb25zdCBzY2hlbWFJbmRleGVzID0gZ2V0UmVsYXRlZFNjaGVtYUluZGV4ZXMobW9kZWwsIHNjaGVtYS5pbmRleGVzKCkpO1xuXG4gIGNvbnN0IHRvRHJvcCA9IGdldEluZGV4ZXNUb0Ryb3Aoc2NoZW1hLCBzY2hlbWFJbmRleGVzLCBkYkluZGV4ZXMpO1xuICBjb25zdCB0b0NyZWF0ZSA9IGdldEluZGV4ZXNUb0NyZWF0ZShzY2hlbWEsIHNjaGVtYUluZGV4ZXMsIGRiSW5kZXhlcywgdG9Ecm9wKTtcblxuICByZXR1cm4geyB0b0Ryb3AsIHRvQ3JlYXRlIH07XG59O1xuXG5mdW5jdGlvbiBnZXRJbmRleGVzVG9DcmVhdGUoc2NoZW1hLCBzY2hlbWFJbmRleGVzLCBkYkluZGV4ZXMsIHRvRHJvcCkge1xuICBjb25zdCB0b0NyZWF0ZSA9IFtdO1xuXG4gIGZvciAoY29uc3QgW3NjaGVtYUluZGV4S2V5c09iamVjdCwgc2NoZW1hSW5kZXhPcHRpb25zXSBvZiBzY2hlbWFJbmRleGVzKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICBjb25zdCBvcHRpb25zID0gZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zKHNjaGVtYSwgY2xvbmUoc2NoZW1hSW5kZXhPcHRpb25zKSk7XG5cbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGRiSW5kZXhlcykge1xuICAgICAgaWYgKGlzRGVmYXVsdElkSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBpc0luZGV4RXF1YWwoc2NoZW1hSW5kZXhLZXlzT2JqZWN0LCBvcHRpb25zLCBpbmRleCkgJiZcbiAgICAgICAgIXRvRHJvcC5pbmNsdWRlcyhpbmRleC5uYW1lKVxuICAgICAgKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgdG9DcmVhdGUucHVzaChzY2hlbWFJbmRleEtleXNPYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b0NyZWF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhlc1RvRHJvcChzY2hlbWEsIHNjaGVtYUluZGV4ZXMsIGRiSW5kZXhlcykge1xuICBjb25zdCB0b0Ryb3AgPSBbXTtcblxuICBmb3IgKGNvbnN0IGRiSW5kZXggb2YgZGJJbmRleGVzKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgLy8gTmV2ZXIgdHJ5IHRvIGRyb3AgYF9pZGAgaW5kZXgsIE1vbmdvREIgc2VydmVyIGRvZXNuJ3QgYWxsb3cgaXRcbiAgICBpZiAoaXNEZWZhdWx0SWRJbmRleChkYkluZGV4KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbc2NoZW1hSW5kZXhLZXlzT2JqZWN0LCBzY2hlbWFJbmRleE9wdGlvbnNdIG9mIHNjaGVtYUluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBkZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMoc2NoZW1hLCBjbG9uZShzY2hlbWFJbmRleE9wdGlvbnMpKTtcbiAgICAgIGFwcGx5U2NoZW1hQ29sbGF0aW9uKHNjaGVtYUluZGV4S2V5c09iamVjdCwgb3B0aW9ucywgc2NoZW1hLm9wdGlvbnMpO1xuXG4gICAgICBpZiAoaXNJbmRleEVxdWFsKHNjaGVtYUluZGV4S2V5c09iamVjdCwgb3B0aW9ucywgZGJJbmRleCkpIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZvdW5kKSB7XG4gICAgICB0b0Ryb3AucHVzaChkYkluZGV4Lm5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b0Ryb3A7XG59XG4vKipcbiAqIERlbGV0ZXMgYWxsIGluZGV4ZXMgdGhhdCBhcmVuJ3QgZGVmaW5lZCBpbiB0aGlzIG1vZGVsJ3Mgc2NoZW1hLiBVc2VkIGJ5XG4gKiBgc3luY0luZGV4ZXMoKWAuXG4gKlxuICogVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgdG8gYSBsaXN0IG9mIHRoZSBkcm9wcGVkIGluZGV4ZXMnIG5hbWVzIGFzIGFuIGFycmF5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBvcHRpb25hbCBjYWxsYmFja1xuICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYHVuZGVmaW5lZGAgaWYgY2FsbGJhY2sgaXMgc3BlY2lmaWVkLCByZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjay5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuY2xlYW5JbmRleGVzID0gYXN5bmMgZnVuY3Rpb24gY2xlYW5JbmRleGVzKG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnY2xlYW5JbmRleGVzJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuY2xlYW5JbmRleGVzKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIGNvbnN0IG1vZGVsID0gdGhpcztcblxuICBjb25zdCBjb2xsZWN0aW9uID0gbW9kZWwuJF9fY29sbGVjdGlvbjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zICYmIG9wdGlvbnMudG9Ecm9wKSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9kcm9wSW5kZXhlcyhvcHRpb25zLnRvRHJvcCwgY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGNvbnN0IHJlcyA9IGF3YWl0IG1vZGVsLmRpZmZJbmRleGVzKCk7XG4gIHJldHVybiBhd2FpdCBfZHJvcEluZGV4ZXMocmVzLnRvRHJvcCwgY29sbGVjdGlvbik7XG59O1xuXG5hc3luYyBmdW5jdGlvbiBfZHJvcEluZGV4ZXModG9Ecm9wLCBjb2xsZWN0aW9uKSB7XG4gIGlmICh0b0Ryb3AubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXdhaXQgUHJvbWlzZS5hbGwodG9Ecm9wLm1hcChpbmRleE5hbWUgPT4gY29sbGVjdGlvbi5kcm9wSW5kZXgoaW5kZXhOYW1lKSkpO1xuICByZXR1cm4gdG9Ecm9wO1xufVxuXG4vKipcbiAqIExpc3RzIHRoZSBpbmRleGVzIGN1cnJlbnRseSBkZWZpbmVkIGluIE1vbmdvREIuIFRoaXMgbWF5IG9yIG1heSBub3QgYmVcbiAqIHRoZSBzYW1lIGFzIHRoZSBpbmRleGVzIGRlZmluZWQgaW4geW91ciBzY2hlbWEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgeW91XG4gKiB1c2UgdGhlIFtgYXV0b0luZGV4YCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2F1dG9JbmRleCkgYW5kIGlmIHlvdVxuICogYnVpbGQgaW5kZXhlcyBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5saXN0SW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIGxpc3RJbmRleGVzKCkge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdsaXN0SW5kZXhlcycpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5saXN0SW5kZXhlcygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICh0aGlzLiRfX2NvbGxlY3Rpb24uYnVmZmVyKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLiRfX2NvbGxlY3Rpb24uYWRkUXVldWUocmVzb2x2ZSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy4kX19jb2xsZWN0aW9uLmxpc3RJbmRleGVzKCkudG9BcnJheSgpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBgY3JlYXRlSW5kZXhgIGNvbW1hbmRzIHRvIG1vbmdvIGZvciBlYWNoIGluZGV4IGRlY2xhcmVkIGluIHRoZSBzY2hlbWEuXG4gKiBUaGUgYGNyZWF0ZUluZGV4YCBjb21tYW5kcyBhcmUgc2VudCBpbiBzZXJpZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBFdmVudC5lbnN1cmVJbmRleGVzKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGlmIChlcnIpIHJldHVybiBoYW5kbGVFcnJvcihlcnIpO1xuICogICAgIH0pO1xuICpcbiAqIEFmdGVyIGNvbXBsZXRpb24sIGFuIGBpbmRleGAgZXZlbnQgaXMgZW1pdHRlZCBvbiB0aGlzIGBNb2RlbGAgcGFzc2luZyBhbiBlcnJvciBpZiBvbmUgb2NjdXJyZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBldmVudFNjaGVtYSA9IG5ldyBTY2hlbWEoeyB0aGluZzogeyB0eXBlOiAnc3RyaW5nJywgdW5pcXVlOiB0cnVlIH0gfSlcbiAqICAgICBjb25zdCBFdmVudCA9IG1vbmdvb3NlLm1vZGVsKCdFdmVudCcsIGV2ZW50U2NoZW1hKTtcbiAqXG4gKiAgICAgRXZlbnQub24oJ2luZGV4JywgZnVuY3Rpb24gKGVycikge1xuICogICAgICAgaWYgKGVycikgY29uc29sZS5lcnJvcihlcnIpOyAvLyBlcnJvciBvY2N1cnJlZCBkdXJpbmcgaW5kZXggY3JlYXRpb25cbiAqICAgICB9KVxuICpcbiAqIF9OT1RFOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCB5b3UgcnVuIHRoaXMgaW4gcHJvZHVjdGlvbi4gSW5kZXggY3JlYXRpb24gbWF5IGltcGFjdCBkYXRhYmFzZSBwZXJmb3JtYW5jZSBkZXBlbmRpbmcgb24geW91ciBsb2FkLiBVc2Ugd2l0aCBjYXV0aW9uLl9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGludGVybmFsIG9wdGlvbnNcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmVuc3VyZUluZGV4ZXMgPSBhc3luYyBmdW5jdGlvbiBlbnN1cmVJbmRleGVzKG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZW5zdXJlSW5kZXhlcycpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmVuc3VyZUluZGV4ZXMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgX2Vuc3VyZUluZGV4ZXModGhpcywgb3B0aW9ucywgKGVycikgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gYGVuc3VyZUluZGV4ZXMoKWAsIGV4Y2VwdCBmb3IgaXQgdXNlcyB0aGUgW2BjcmVhdGVJbmRleGBdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9EYi5odG1sI2NyZWF0ZUluZGV4KVxuICogZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBpbnRlcm5hbCBvcHRpb25zXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5jcmVhdGVJbmRleGVzID0gYXN5bmMgZnVuY3Rpb24gY3JlYXRlSW5kZXhlcyhvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2NyZWF0ZUluZGV4ZXMnKTtcblxuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmNyZWF0ZUluZGV4ZXMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lbnN1cmVJbmRleGVzKG9wdGlvbnMpO1xufTtcblxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9lbnN1cmVJbmRleGVzKG1vZGVsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBpbmRleGVzID0gbW9kZWwuc2NoZW1hLmluZGV4ZXMoKTtcbiAgbGV0IGluZGV4RXJyb3I7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGRvbmUgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoZXJyICYmICFtb2RlbC4kY2F1Z2h0KSB7XG4gICAgICBtb2RlbC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIG1vZGVsLmVtaXQoJ2luZGV4JywgZXJyIHx8IGluZGV4RXJyb3IpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVyciB8fCBpbmRleEVycm9yKTtcbiAgfTtcblxuICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICBpZiAoaXNEZWZhdWx0SWRJbmRleChpbmRleCkpIHtcbiAgICAgIHV0aWxzLndhcm4oJ21vbmdvb3NlOiBDYW5ub3Qgc3BlY2lmeSBhIGN1c3RvbSBpbmRleCBvbiBgX2lkYCBmb3IgJyArXG4gICAgICAgICdtb2RlbCBuYW1lIFwiJyArIG1vZGVsLm1vZGVsTmFtZSArICdcIiwgJyArXG4gICAgICAgICdNb25nb0RCIGRvZXMgbm90IGFsbG93IG92ZXJ3cml0aW5nIHRoZSBkZWZhdWx0IGBfaWRgIGluZGV4LiBTZWUgJyArXG4gICAgICAgICdodHRwczovL2JpdC5seS9tb25nb2RiLWlkLWluZGV4Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpbmRleGVzLmxlbmd0aCkge1xuICAgIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gSW5kZXhlcyBhcmUgY3JlYXRlZCBvbmUtYnktb25lIHRvIHN1cHBvcnQgaG93IE1vbmdvREIgPCAyLjQgZGVhbHNcbiAgLy8gd2l0aCBiYWNrZ3JvdW5kIGluZGV4ZXMuXG5cbiAgY29uc3QgaW5kZXhTaW5nbGVEb25lID0gZnVuY3Rpb24oZXJyLCBmaWVsZHMsIG9wdGlvbnMsIG5hbWUpIHtcbiAgICBtb2RlbC5lbWl0KCdpbmRleC1zaW5nbGUtZG9uZScsIGVyciwgZmllbGRzLCBvcHRpb25zLCBuYW1lKTtcbiAgfTtcbiAgY29uc3QgaW5kZXhTaW5nbGVTdGFydCA9IGZ1bmN0aW9uKGZpZWxkcywgb3B0aW9ucykge1xuICAgIG1vZGVsLmVtaXQoJ2luZGV4LXNpbmdsZS1zdGFydCcsIGZpZWxkcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgY29uc3QgYmFzZVNjaGVtYSA9IG1vZGVsLnNjaGVtYS5fYmFzZVNjaGVtYTtcbiAgY29uc3QgYmFzZVNjaGVtYUluZGV4ZXMgPSBiYXNlU2NoZW1hID8gYmFzZVNjaGVtYS5pbmRleGVzKCkgOiBbXTtcblxuICBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgLy8gSWYgYnVmZmVyaW5nIGlzIG9mZiwgZG8gdGhpcyBtYW51YWxseS5cbiAgICBpZiAob3B0aW9ucy5fYXV0b21hdGljICYmICFtb2RlbC5jb2xsZWN0aW9uLmNvbGxlY3Rpb24pIHtcbiAgICAgIG1vZGVsLmNvbGxlY3Rpb24uYWRkUXVldWUoY3JlYXRlLCBbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZSgpO1xuICAgIH1cbiAgfSk7XG5cblxuICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgaWYgKG9wdGlvbnMuX2F1dG9tYXRpYykge1xuICAgICAgaWYgKG1vZGVsLnNjaGVtYS5vcHRpb25zLmF1dG9JbmRleCA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAobW9kZWwuc2NoZW1hLm9wdGlvbnMuYXV0b0luZGV4ID09IG51bGwgJiYgbW9kZWwuZGIuY29uZmlnLmF1dG9JbmRleCA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXggPSBpbmRleGVzLnNoaWZ0KCk7XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuX2F1dG9tYXRpYyAmJiBpbmRleFsxXS5fYXV0b0luZGV4ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZSgpO1xuICAgIH1cblxuICAgIGlmIChiYXNlU2NoZW1hSW5kZXhlcy5maW5kKGkgPT4gdXRpbHMuZGVlcEVxdWFsKGksIGluZGV4KSkpIHtcbiAgICAgIHJldHVybiBjcmVhdGUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleEZpZWxkcyA9IGNsb25lKGluZGV4WzBdKTtcbiAgICBjb25zdCBpbmRleE9wdGlvbnMgPSBjbG9uZShpbmRleFsxXSk7XG5cbiAgICBkZWxldGUgaW5kZXhPcHRpb25zLl9hdXRvSW5kZXg7XG4gICAgZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zKG1vZGVsLnNjaGVtYSwgaW5kZXhPcHRpb25zKTtcbiAgICBhcHBseVdyaXRlQ29uY2Vybihtb2RlbC5zY2hlbWEsIGluZGV4T3B0aW9ucyk7XG4gICAgYXBwbHlTY2hlbWFDb2xsYXRpb24oaW5kZXhGaWVsZHMsIGluZGV4T3B0aW9ucywgbW9kZWwuc2NoZW1hLm9wdGlvbnMpO1xuXG4gICAgaW5kZXhTaW5nbGVTdGFydChpbmRleEZpZWxkcywgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ2JhY2tncm91bmQnIGluIG9wdGlvbnMpIHtcbiAgICAgIGluZGV4T3B0aW9ucy5iYWNrZ3JvdW5kID0gb3B0aW9ucy5iYWNrZ3JvdW5kO1xuICAgIH1cblxuICAgIGlmICgndG9DcmVhdGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLnRvQ3JlYXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZGVsLmNvbGxlY3Rpb24uY3JlYXRlSW5kZXgoaW5kZXhGaWVsZHMsIGluZGV4T3B0aW9ucykudGhlbihcbiAgICAgIG5hbWUgPT4ge1xuICAgICAgICBpbmRleFNpbmdsZURvbmUobnVsbCwgaW5kZXhGaWVsZHMsIGluZGV4T3B0aW9ucywgbmFtZSk7XG4gICAgICAgIGNyZWF0ZSgpO1xuICAgICAgfSxcbiAgICAgIGVyciA9PiB7XG4gICAgICAgIGlmICghaW5kZXhFcnJvcikge1xuICAgICAgICAgIGluZGV4RXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb2RlbC4kY2F1Z2h0KSB7XG4gICAgICAgICAgbW9kZWwuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXhTaW5nbGVEb25lKGVyciwgaW5kZXhGaWVsZHMsIGluZGV4T3B0aW9ucyk7XG4gICAgICAgIGNyZWF0ZSgpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBTY2hlbWEgdGhlIG1vZGVsIHVzZXMuXG4gKlxuICogQHByb3BlcnR5IHNjaGVtYVxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICovXG5cbk1vZGVsLnNjaGVtYTtcblxuLyoqXG4gKiBDb25uZWN0aW9uIGluc3RhbmNlIHRoZSBtb2RlbCB1c2VzLlxuICpcbiAqIEBwcm9wZXJ0eSBkYlxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICovXG5cbk1vZGVsLmRiO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gdGhlIG1vZGVsIHVzZXMuXG4gKlxuICogQHByb3BlcnR5IGNvbGxlY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqL1xuXG5Nb2RlbC5jb2xsZWN0aW9uO1xuXG4vKipcbiAqIEludGVybmFsIGNvbGxlY3Rpb24gdGhlIG1vZGVsIHVzZXMuXG4gKlxuICogQHByb3BlcnR5IGNvbGxlY3Rpb25cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1lbWJlck9mIE1vZGVsXG4gKi9cbk1vZGVsLiRfX2NvbGxlY3Rpb247XG5cbi8qKlxuICogQmFzZSBNb25nb29zZSBpbnN0YW5jZSB0aGUgbW9kZWwgdXNlcy5cbiAqXG4gKiBAcHJvcGVydHkgYmFzZVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICovXG5cbk1vZGVsLmJhc2U7XG5cbi8qKlxuICogUmVnaXN0ZXJlZCBkaXNjcmltaW5hdG9ycyBmb3IgdGhpcyBtb2RlbC5cbiAqXG4gKiBAcHJvcGVydHkgZGlzY3JpbWluYXRvcnNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqL1xuXG5Nb2RlbC5kaXNjcmltaW5hdG9ycztcblxuLyoqXG4gKiBUcmFuc2xhdGUgYW55IGFsaWFzZXMgZmllbGRzL2NvbmRpdGlvbnMgc28gdGhlIGZpbmFsIHF1ZXJ5IG9yIGRvY3VtZW50IG9iamVjdCBpcyBwdXJlXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuZmluZChDaGFyYWN0ZXIudHJhbnNsYXRlQWxpYXNlcyh7XG4gKiAgICAgICAgJ+WQjSc6ICdFZGRhcmQgU3RhcmsnIC8vIEFsaWFzIGZvciAnbmFtZSdcbiAqICAgICB9KTtcbiAqXG4gKiBCeSBkZWZhdWx0LCBgdHJhbnNsYXRlQWxpYXNlcygpYCBvdmVyd3JpdGVzIHJhdyBmaWVsZHMgd2l0aCBhbGlhc2VkIGZpZWxkcy5cbiAqIFNvIGlmIGBuYCBpcyBhbiBhbGlhcyBmb3IgYG5hbWVgLCBgeyBuOiAnYWxpYXMnLCBuYW1lOiAncmF3JyB9YCB3aWxsIHJlc29sdmUgdG8gYHsgbmFtZTogJ2FsaWFzJyB9YC5cbiAqIEhvd2V2ZXIsIHlvdSBjYW4gc2V0IHRoZSBgZXJyb3JPbkR1cGxpY2F0ZXNgIG9wdGlvbiB0byB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgcG90ZW50aWFsbHkgY29uZmxpY3RpbmcgcGF0aHMuXG4gKiBUaGUgYHRyYW5zbGF0ZUFsaWFzZXNgIG9wdGlvbiBmb3IgcXVlcmllcyB1c2VzIGBlcnJvck9uRHVwbGljYXRlc2AuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIE9ubHkgdHJhbnNsYXRlIGFyZ3VtZW50cyBvZiBvYmplY3QgdHlwZSBhbnl0aGluZyBlbHNlIGlzIHJldHVybmVkIHJhd1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHMgZmllbGRzL2NvbmRpdGlvbnMgdGhhdCBtYXkgY29udGFpbiBhbGlhc2VkIGtleXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Vycm9yT25EdXBsaWNhdGVzXSBpZiB0cnVlLCB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSdzIGJvdGggYSBrZXkgYW5kIGFuIGFsaWFzIGZvciB0aGF0IGtleSBpbiBgZmllbGRzYFxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgdHJhbnNsYXRlZCAncHVyZScgZmllbGRzL2NvbmRpdGlvbnNcbiAqL1xuTW9kZWwudHJhbnNsYXRlQWxpYXNlcyA9IGZ1bmN0aW9uIHRyYW5zbGF0ZUFsaWFzZXMoZmllbGRzLCBlcnJvck9uRHVwbGljYXRlcykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICd0cmFuc2xhdGVBbGlhc2VzJyk7XG5cbiAgY29uc3QgdHJhbnNsYXRlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBsZXQgYWxpYXM7XG4gICAgY29uc3QgdHJhbnNsYXRlZCA9IFtdO1xuICAgIGNvbnN0IGZpZWxkS2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgIGxldCBjdXJyZW50U2NoZW1hID0gdGhpcy5zY2hlbWE7XG4gICAgZm9yIChjb25zdCBpIGluIGZpZWxkS2V5cykge1xuICAgICAgY29uc3QgbmFtZSA9IGZpZWxkS2V5c1tpXTtcbiAgICAgIGlmIChjdXJyZW50U2NoZW1hICYmIGN1cnJlbnRTY2hlbWEuYWxpYXNlc1tuYW1lXSkge1xuICAgICAgICBhbGlhcyA9IGN1cnJlbnRTY2hlbWEuYWxpYXNlc1tuYW1lXTtcbiAgICAgICAgaWYgKGVycm9yT25EdXBsaWNhdGVzICYmIGFsaWFzIGluIGZpZWxkcykge1xuICAgICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBQcm92aWRlZCBvYmplY3QgaGFzIGJvdGggZmllbGQgXCIke25hbWV9XCIgYW5kIGl0cyBhbGlhcyBcIiR7YWxpYXN9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGlhcyBmb3VuZCxcbiAgICAgICAgdHJhbnNsYXRlZC5wdXNoKGFsaWFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsaWFzID0gbmFtZTtcbiAgICAgICAgLy8gQWxpYXMgbm90IGZvdW5kLCBzbyB0cmVhdCBhcyB1bi1hbGlhc2VkIGtleVxuICAgICAgICB0cmFuc2xhdGVkLnB1c2gobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGFsaWFzZWQgcGF0aCBpcyBhIHNjaGVtYVxuICAgICAgaWYgKGN1cnJlbnRTY2hlbWEgJiYgY3VycmVudFNjaGVtYS5wYXRoc1thbGlhc10pIHtcbiAgICAgICAgY3VycmVudFNjaGVtYSA9IGN1cnJlbnRTY2hlbWEucGF0aHNbYWxpYXNdLnNjaGVtYTtcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgY3VycmVudFNjaGVtYSA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNsYXRlZEtleSA9IHRyYW5zbGF0ZWQuam9pbignLicpO1xuICAgIGlmIChmaWVsZHMgaW5zdGFuY2VvZiBNYXApXG4gICAgICBmaWVsZHMuc2V0KHRyYW5zbGF0ZWRLZXksIHZhbHVlKTtcbiAgICBlbHNlXG4gICAgICBmaWVsZHNbdHJhbnNsYXRlZEtleV0gPSB2YWx1ZTtcblxuICAgIGlmICh0cmFuc2xhdGVkS2V5ICE9PSBrZXkpIHtcbiAgICAgIC8vIFdlJ2xsIGJlIHVzaW5nIHRoZSB0cmFuc2xhdGVkIGtleSBpbnN0ZWFkXG4gICAgICBpZiAoZmllbGRzIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIC8vIERlbGV0ZSBmcm9tIG1hcFxuICAgICAgICBmaWVsZHMuZGVsZXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEZWxldGUgZnJvbSBvYmplY3RcbiAgICAgICAgZGVsZXRlIGZpZWxkc1trZXldOyAvLyBXZSdsbCBiZSB1c2luZyB0aGUgdHJhbnNsYXRlZCBrZXkgaW5zdGVhZFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZmllbGRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIEZpZWxkcyBpcyBhbiBvYmplY3QgKHF1ZXJ5IGNvbmRpdGlvbnMgb3IgZG9jdW1lbnQgZmllbGRzKVxuICAgIGlmIChmaWVsZHMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIC8vIEEgTWFwIHdhcyBzdXBwbGllZFxuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBuZXcgTWFwKGZpZWxkcykpIHtcbiAgICAgICAgZmllbGRzID0gdHJhbnNsYXRlKGZpZWxkWzBdLCBmaWVsZFsxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluZmVyIGEgcmVndWxhciBvYmplY3Qgd2FzIHN1cHBsaWVkXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWVsZHMpKSB7XG4gICAgICAgIGZpZWxkcyA9IHRyYW5zbGF0ZShrZXksIGZpZWxkc1trZXldKTtcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzW2tleV0pKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gZmllbGRzW2tleV0pIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgdHJhbnNsYXRlIG5lc3RlZCBxdWVyaWVzXG4gICAgICAgICAgICAgIGZpZWxkc1trZXldW2ldID0gdGhpcy50cmFuc2xhdGVBbGlhc2VzKGZpZWxkc1trZXldW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGVBbGlhc2VzKGZpZWxkc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzO1xuICB9IGVsc2Uge1xuICAgIC8vIERvbid0IGtub3cgdHlwZW9mIGZpZWxkc1xuICAgIHJldHVybiBmaWVsZHM7XG4gIH1cbn07XG5cbi8qKlxuICogRGVsZXRlcyB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIGBjb25kaXRpb25zYCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICogSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydHkgYGRlbGV0ZWRDb3VudGAgaW5kaWNhdGluZyBob3cgbWFueSBkb2N1bWVudHMgd2VyZSBkZWxldGVkLlxuICogQmVoYXZlcyBsaWtlIGByZW1vdmUoKWAsIGJ1dCBkZWxldGVzIGF0IG1vc3Qgb25lIGRvY3VtZW50IHJlZ2FyZGxlc3Mgb2YgdGhlXG4gKiBgc2luZ2xlYCBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuZGVsZXRlT25lKHsgbmFtZTogJ0VkZGFyZCBTdGFyaycgfSk7IC8vIHJldHVybnMge2RlbGV0ZWRDb3VudDogMX1cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyBgZGVsZXRlT25lYCBxdWVyeSBob29rcy4gUmVhZCB0aGVcbiAqIFttaWRkbGV3YXJlIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWwjbmFtaW5nKSB0byBsZWFybiBtb3JlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZGVsZXRlT25lID0gZnVuY3Rpb24gZGVsZXRlT25lKGNvbmRpdGlvbnMsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZGVsZXRlT25lJyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnByb3RvdHlwZS5kZWxldGVPbmUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcbiAgbXEuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gbXEuZGVsZXRlT25lKGNvbmRpdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWxldGVzIGFsbCBvZiB0aGUgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggYGNvbmRpdGlvbnNgIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gKiBJdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0eSBgZGVsZXRlZENvdW50YCBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGRlbGV0ZWQuXG4gKiBCZWhhdmVzIGxpa2UgYHJlbW92ZSgpYCwgYnV0IGRlbGV0ZXMgYWxsIGRvY3VtZW50cyB0aGF0IG1hdGNoIGBjb25kaXRpb25zYFxuICogcmVnYXJkbGVzcyBvZiB0aGUgYHNpbmdsZWAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmRlbGV0ZU1hbnkoeyBuYW1lOiAvU3RhcmsvLCBhZ2U6IHsgJGd0ZTogMTggfSB9KTsgLy8gcmV0dXJucyB7ZGVsZXRlZENvdW50OiB4fSB3aGVyZSB4IGlzIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGRlbGV0ZWQuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgYGRlbGV0ZU1hbnlgIHF1ZXJ5IGhvb2tzLiBSZWFkIHRoZVxuICogW21pZGRsZXdhcmUgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL21pZGRsZXdhcmUuaHRtbCNuYW1pbmcpIHRvIGxlYXJuIG1vcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmRpdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5kZWxldGVNYW55ID0gZnVuY3Rpb24gZGVsZXRlTWFueShjb25kaXRpb25zLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2RlbGV0ZU1hbnknKTtcblxuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZGVsZXRlTWFueSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pO1xuICBtcS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiBtcS5kZWxldGVNYW55KGNvbmRpdGlvbnMpO1xufTtcblxuLyoqXG4gKiBGaW5kcyBkb2N1bWVudHMuXG4gKlxuICogTW9uZ29vc2UgY2FzdHMgdGhlIGBmaWx0ZXJgIHRvIG1hdGNoIHRoZSBtb2RlbCdzIHNjaGVtYSBiZWZvcmUgdGhlIGNvbW1hbmQgaXMgc2VudC5cbiAqIFNlZSBvdXIgW3F1ZXJ5IGNhc3RpbmcgdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvcXVlcnlfY2FzdGluZy5odG1sKSBmb3JcbiAqIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IE1vbmdvb3NlIGNhc3RzIGBmaWx0ZXJgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gZmluZCBhbGwgZG9jdW1lbnRzXG4gKiAgICAgYXdhaXQgTXlNb2RlbC5maW5kKHt9KTtcbiAqXG4gKiAgICAgLy8gZmluZCBhbGwgZG9jdW1lbnRzIG5hbWVkIGpvaG4gYW5kIGF0IGxlYXN0IDE4XG4gKiAgICAgYXdhaXQgTXlNb2RlbC5maW5kKHsgbmFtZTogJ2pvaG4nLCBhZ2U6IHsgJGd0ZTogMTggfSB9KS5leGVjKCk7XG4gKlxuICogICAgIC8vIGV4ZWN1dGVzLCBuYW1lIExJS0Ugam9obiBhbmQgb25seSBzZWxlY3RpbmcgdGhlIFwibmFtZVwiIGFuZCBcImZyaWVuZHNcIiBmaWVsZHNcbiAqICAgICBhd2FpdCBNeU1vZGVsLmZpbmQoeyBuYW1lOiAvam9obi9pIH0sICduYW1lIGZyaWVuZHMnKS5leGVjKCk7XG4gKlxuICogICAgIC8vIHBhc3Npbmcgb3B0aW9uc1xuICogICAgIGF3YWl0IE15TW9kZWwuZmluZCh7IG5hbWU6IC9qb2huL2kgfSwgbnVsbCwgeyBza2lwOiAxMCB9KS5leGVjKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R8T2JqZWN0SWR9IGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBbcHJvamVjdGlvbl0gb3B0aW9uYWwgZmllbGRzIHRvIHJldHVybiwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBmaWVsZCBzZWxlY3Rpb24gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKVxuICogQHNlZSBxdWVyeSBjYXN0aW5nIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvcXVlcnlfY2FzdGluZy5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmQgPSBmdW5jdGlvbiBmaW5kKGNvbmRpdGlvbnMsIHByb2plY3Rpb24sIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZmluZCcpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNlbGVjdChwcm9qZWN0aW9uKTtcbiAgbXEuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gbXEuZmluZChjb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogRmluZHMgYSBzaW5nbGUgZG9jdW1lbnQgYnkgaXRzIF9pZCBmaWVsZC4gYGZpbmRCeUlkKGlkKWAgaXMgYWxtb3N0KlxuICogZXF1aXZhbGVudCB0byBgZmluZE9uZSh7IF9pZDogaWQgfSlgLiBJZiB5b3Ugd2FudCB0byBxdWVyeSBieSBhIGRvY3VtZW50J3NcbiAqIGBfaWRgLCB1c2UgYGZpbmRCeUlkKClgIGluc3RlYWQgb2YgYGZpbmRPbmUoKWAuXG4gKlxuICogVGhlIGBpZGAgaXMgY2FzdCBiYXNlZCBvbiB0aGUgU2NoZW1hIGJlZm9yZSBzZW5kaW5nIHRoZSBjb21tYW5kLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmUoKWBcbiAqXG4gKiBcXCogRXhjZXB0IGZvciBob3cgaXQgdHJlYXRzIGB1bmRlZmluZWRgLiBJZiB5b3UgdXNlIGBmaW5kT25lKClgLCB5b3UnbGwgc2VlXG4gKiB0aGF0IGBmaW5kT25lKHVuZGVmaW5lZClgIGFuZCBgZmluZE9uZSh7IF9pZDogdW5kZWZpbmVkIH0pYCBhcmUgZXF1aXZhbGVudFxuICogdG8gYGZpbmRPbmUoe30pYCBhbmQgcmV0dXJuIGFyYml0cmFyeSBkb2N1bWVudHMuIEhvd2V2ZXIsIG1vbmdvb3NlXG4gKiB0cmFuc2xhdGVzIGBmaW5kQnlJZCh1bmRlZmluZWQpYCBpbnRvIGBmaW5kT25lKHsgX2lkOiBudWxsIH0pYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEZpbmQgdGhlIGFkdmVudHVyZSB3aXRoIHRoZSBnaXZlbiBgaWRgLCBvciBgbnVsbGAgaWYgbm90IGZvdW5kXG4gKiAgICAgYXdhaXQgQWR2ZW50dXJlLmZpbmRCeUlkKGlkKS5leGVjKCk7XG4gKlxuICogICAgIC8vIHNlbGVjdCBvbmx5IHRoZSBhZHZlbnR1cmVzIG5hbWUgYW5kIGxlbmd0aFxuICogICAgIGF3YWl0IEFkdmVudHVyZS5maW5kQnlJZChpZCwgJ25hbWUgbGVuZ3RoJykuZXhlYygpO1xuICpcbiAqIEBwYXJhbSB7QW55fSBpZCB2YWx1ZSBvZiBgX2lkYCB0byBxdWVyeSBieVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBbcHJvamVjdGlvbl0gb3B0aW9uYWwgZmllbGRzIHRvIHJldHVybiwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAc2VlIGZpZWxkIHNlbGVjdGlvbiBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpXG4gKiBAc2VlIGxlYW4gcXVlcmllcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2xlYW4uaHRtbFxuICogQHNlZSBmaW5kQnlJZCBpbiBNb25nb29zZSBodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9tb25nb29zZS9maW5kLWJ5LWlkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmRCeUlkID0gZnVuY3Rpb24gZmluZEJ5SWQoaWQsIHByb2plY3Rpb24sIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZmluZEJ5SWQnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmZpbmRCeUlkKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZCA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5maW5kT25lKHsgX2lkOiBpZCB9LCBwcm9qZWN0aW9uLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRmluZHMgb25lIGRvY3VtZW50LlxuICpcbiAqIFRoZSBgY29uZGl0aW9uc2AgYXJlIGNhc3QgdG8gdGhlaXIgcmVzcGVjdGl2ZSBTY2hlbWFUeXBlcyBiZWZvcmUgdGhlIGNvbW1hbmQgaXMgc2VudC5cbiAqXG4gKiAqTm90ZToqIGBjb25kaXRpb25zYCBpcyBvcHRpb25hbCwgYW5kIGlmIGBjb25kaXRpb25zYCBpcyBudWxsIG9yIHVuZGVmaW5lZCxcbiAqIG1vbmdvb3NlIHdpbGwgc2VuZCBhbiBlbXB0eSBgZmluZE9uZWAgY29tbWFuZCB0byBNb25nb0RCLCB3aGljaCB3aWxsIHJldHVyblxuICogYW4gYXJiaXRyYXJ5IGRvY3VtZW50LiBJZiB5b3UncmUgcXVlcnlpbmcgYnkgYF9pZGAsIHVzZSBgZmluZEJ5SWQoKWAgaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEZpbmQgb25lIGFkdmVudHVyZSB3aG9zZSBgY291bnRyeWAgaXMgJ0Nyb2F0aWEnLCBvdGhlcndpc2UgYG51bGxgXG4gKiAgICAgYXdhaXQgQWR2ZW50dXJlLmZpbmRPbmUoeyBjb3VudHJ5OiAnQ3JvYXRpYScgfSkuZXhlYygpO1xuICpcbiAqICAgICAvLyBNb2RlbC5maW5kT25lKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFja1xuICpcbiAqICAgICAvLyBTZWxlY3Qgb25seSB0aGUgYWR2ZW50dXJlcyBuYW1lIGFuZCBsZW5ndGhcbiAqICAgICBhd2FpdCBBZHZlbnR1cmUuZmluZE9uZSh7IGNvdW50cnk6ICdDcm9hdGlhJyB9LCAnbmFtZSBsZW5ndGgnKS5leGVjKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25kaXRpb25zXVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBbcHJvamVjdGlvbl0gb3B0aW9uYWwgZmllbGRzIHRvIHJldHVybiwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBmaWVsZCBzZWxlY3Rpb24gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKVxuICogQHNlZSBsZWFuIHF1ZXJpZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9sZWFuLmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZmluZE9uZSA9IGZ1bmN0aW9uIGZpbmRPbmUoY29uZGl0aW9ucywgcHJvamVjdGlvbiwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdmaW5kT25lJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kT25lKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNlbGVjdChwcm9qZWN0aW9uKTtcbiAgbXEuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gbXEuZmluZE9uZShjb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogRXN0aW1hdGVzIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGluIHRoZSBNb25nb0RCIGNvbGxlY3Rpb24uIEZhc3RlciB0aGFuXG4gKiB1c2luZyBgY291bnREb2N1bWVudHMoKWAgZm9yIGxhcmdlIGNvbGxlY3Rpb25zIGJlY2F1c2VcbiAqIGBlc3RpbWF0ZWREb2N1bWVudENvdW50KClgIHVzZXMgY29sbGVjdGlvbiBtZXRhZGF0YSByYXRoZXIgdGhhbiBzY2FubmluZ1xuICogdGhlIGVudGlyZSBjb2xsZWN0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbnVtQWR2ZW50dXJlcyA9IGF3YWl0IEFkdmVudHVyZS5lc3RpbWF0ZWREb2N1bWVudENvdW50KCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmVzdGltYXRlZERvY3VtZW50Q291bnQgPSBmdW5jdGlvbiBlc3RpbWF0ZWREb2N1bWVudENvdW50KG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZXN0aW1hdGVkRG9jdW1lbnRDb3VudCcpO1xuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pO1xuXG4gIHJldHVybiBtcS5lc3RpbWF0ZWREb2N1bWVudENvdW50KG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb3VudHMgbnVtYmVyIG9mIGRvY3VtZW50cyBtYXRjaGluZyBgZmlsdGVyYCBpbiBhIGRhdGFiYXNlIGNvbGxlY3Rpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBBZHZlbnR1cmUuY291bnREb2N1bWVudHMoeyB0eXBlOiAnanVuZ2xlJyB9LCBmdW5jdGlvbiAoZXJyLCBjb3VudCkge1xuICogICAgICAgY29uc29sZS5sb2coJ3RoZXJlIGFyZSAlZCBqdW5nbGUgYWR2ZW50dXJlcycsIGNvdW50KTtcbiAqICAgICB9KTtcbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBjb3VudCBhbGwgZG9jdW1lbnRzIGluIGEgbGFyZ2UgY29sbGVjdGlvbixcbiAqIHVzZSB0aGUgW2Blc3RpbWF0ZWREb2N1bWVudENvdW50KClgIGZ1bmN0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpKVxuICogaW5zdGVhZC4gSWYgeW91IGNhbGwgYGNvdW50RG9jdW1lbnRzKHt9KWAsIE1vbmdvREIgd2lsbCBhbHdheXMgZXhlY3V0ZVxuICogYSBmdWxsIGNvbGxlY3Rpb24gc2NhbiBhbmQgKipub3QqKiB1c2UgYW55IGluZGV4ZXMuXG4gKlxuICogVGhlIGBjb3VudERvY3VtZW50cygpYCBmdW5jdGlvbiBpcyBzaW1pbGFyIHRvIGBjb3VudCgpYCwgYnV0IHRoZXJlIGFyZSBhXG4gKiBbZmV3IG9wZXJhdG9ycyB0aGF0IGBjb3VudERvY3VtZW50cygpYCBkb2VzIG5vdCBzdXBwb3J0XShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2NvdW50RG9jdW1lbnRzKS5cbiAqIEJlbG93IGFyZSB0aGUgb3BlcmF0b3JzIHRoYXQgYGNvdW50KClgIHN1cHBvcnRzIGJ1dCBgY291bnREb2N1bWVudHMoKWAgZG9lcyBub3QsXG4gKiBhbmQgdGhlIHN1Z2dlc3RlZCByZXBsYWNlbWVudDpcbiAqXG4gKiAtIGAkd2hlcmVgOiBbYCRleHByYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2V4cHIvKVxuICogLSBgJG5lYXJgOiBbYCRnZW9XaXRoaW5gXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvZ2VvV2l0aGluLykgd2l0aCBbYCRjZW50ZXJgXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvY2VudGVyLyNvcC5fU19jZW50ZXIpXG4gKiAtIGAkbmVhclNwaGVyZWA6IFtgJGdlb1dpdGhpbmBdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9nZW9XaXRoaW4vKSB3aXRoIFtgJGNlbnRlclNwaGVyZWBdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9jZW50ZXJTcGhlcmUvI29wLl9TX2NlbnRlclNwaGVyZSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuY291bnREb2N1bWVudHMgPSBmdW5jdGlvbiBjb3VudERvY3VtZW50cyhjb25kaXRpb25zLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2NvdW50RG9jdW1lbnRzJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5jb3VudERvY3VtZW50cygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pO1xuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgbXEuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBtcS5jb3VudERvY3VtZW50cyhjb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogQ291bnRzIG51bWJlciBvZiBkb2N1bWVudHMgdGhhdCBtYXRjaCBgZmlsdGVyYCBpbiBhIGRhdGFiYXNlIGNvbGxlY3Rpb24uXG4gKlxuICogVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZC4gSWYgeW91IHdhbnQgdG8gY291bnQgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgaW5cbiAqIGEgY29sbGVjdGlvbiwgZS5nLiBgY291bnQoe30pYCwgdXNlIHRoZSBbYGVzdGltYXRlZERvY3VtZW50Q291bnQoKWAgZnVuY3Rpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5lc3RpbWF0ZWREb2N1bWVudENvdW50KCkpXG4gKiBpbnN0ZWFkLiBPdGhlcndpc2UsIHVzZSB0aGUgW2Bjb3VudERvY3VtZW50cygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLmNvdW50RG9jdW1lbnRzKCkpIGZ1bmN0aW9uIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjb3VudCA9IGF3YWl0IEFkdmVudHVyZS5jb3VudCh7IHR5cGU6ICdqdW5nbGUnIH0pO1xuICogICAgIGNvbnNvbGUubG9nKCd0aGVyZSBhcmUgJWQganVuZ2xlIGFkdmVudHVyZXMnLCBjb3VudCk7XG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmNvdW50ID0gZnVuY3Rpb24gY291bnQoY29uZGl0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdjb3VudCcpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmNvdW50KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG5cbiAgcmV0dXJuIG1xLmNvdW50KGNvbmRpdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUXVlcnkgZm9yIGEgYGRpc3RpbmN0YCBvcGVyYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IExpbmsuZGlzdGluY3QoJ3VybCcpO1xuICogICAgIHF1ZXJ5LmV4ZWMoKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZGl0aW9uc10gb3B0aW9uYWxcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5kaXN0aW5jdCA9IGZ1bmN0aW9uIGRpc3RpbmN0KGZpZWxkLCBjb25kaXRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2Rpc3RpbmN0Jyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZGlzdGluY3QoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcblxuICByZXR1cm4gbXEuZGlzdGluY3QoZmllbGQsIGNvbmRpdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUXVlcnksIGFwcGxpZXMgdGhlIHBhc3NlZCBjb25kaXRpb25zLCBhbmQgcmV0dXJucyB0aGUgUXVlcnkuXG4gKlxuICogRm9yIGV4YW1wbGUsIGluc3RlYWQgb2Ygd3JpdGluZzpcbiAqXG4gKiAgICAgVXNlci5maW5kKHsgYWdlOiB7ICRndGU6IDIxLCAkbHRlOiA2NSB9IH0pO1xuICpcbiAqIHdlIGNhbiBpbnN0ZWFkIHdyaXRlOlxuICpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnKS5ndGUoMjEpLmx0ZSg2NSkuZXhlYygpO1xuICpcbiAqIFNpbmNlIHRoZSBRdWVyeSBjbGFzcyBhbHNvIHN1cHBvcnRzIGB3aGVyZWAgeW91IGNhbiBjb250aW51ZSBjaGFpbmluZ1xuICpcbiAqICAgICBVc2VyXG4gKiAgICAgLndoZXJlKCdhZ2UnKS5ndGUoMjEpLmx0ZSg2NSlcbiAqICAgICAud2hlcmUoJ25hbWUnLCAvXmIvaSlcbiAqICAgICAuLi4gZXRjXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsXSBvcHRpb25hbCB2YWx1ZVxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLndoZXJlID0gZnVuY3Rpb24gd2hlcmUocGF0aCwgdmFsKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ3doZXJlJyk7XG5cbiAgdm9pZCB2YWw7IC8vIGVzbGludFxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKS5maW5kKHt9KTtcbiAgcmV0dXJuIG1xLndoZXJlLmFwcGx5KG1xLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5YCBhbmQgc3BlY2lmaWVzIGEgYCR3aGVyZWAgY29uZGl0aW9uLlxuICpcbiAqIFNvbWV0aW1lcyB5b3UgbmVlZCB0byBxdWVyeSBmb3IgdGhpbmdzIGluIG1vbmdvZGIgdXNpbmcgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24uIFlvdSBjYW4gZG8gc28gdmlhIGBmaW5kKHsgJHdoZXJlOiBqYXZhc2NyaXB0IH0pYCwgb3IgeW91IGNhbiB1c2UgdGhlIG1vbmdvb3NlIHNob3J0Y3V0IG1ldGhvZCAkd2hlcmUgdmlhIGEgUXVlcnkgY2hhaW4gb3IgZnJvbSB5b3VyIG1vbmdvb3NlIE1vZGVsLlxuICpcbiAqICAgICBCbG9nLiR3aGVyZSgndGhpcy51c2VybmFtZS5pbmRleE9mKFwidmFsXCIpICE9PSAtMScpLmV4ZWMoZnVuY3Rpb24gKGVyciwgZG9jcykge30pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBhcmd1bWVudCBpcyBhIGphdmFzY3JpcHQgc3RyaW5nIG9yIGFub255bW91cyBmdW5jdGlvblxuICogQG1ldGhvZCAkd2hlcmVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAc2VlIFF1ZXJ5LiR3aGVyZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLiR3aGVyZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC4kd2hlcmUgPSBmdW5jdGlvbiAkd2hlcmUoKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJyR3aGVyZScpO1xuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pLmZpbmQoe30pO1xuICByZXR1cm4gbXEuJHdoZXJlLmFwcGx5KG1xLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgYSBtb25nb2RiIGZpbmRPbmVBbmRVcGRhdGUgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCB1cGRhdGVzIGl0IGFjY29yZGluZyB0byB0aGUgYHVwZGF0ZWAgYXJnLCBwYXNzaW5nIGFueSBgb3B0aW9uc2AsIGFuZCByZXR1cm5zIHRoZSBmb3VuZCBkb2N1bWVudCAoaWYgYW55KSB0byB0aGUgY2FsbGJhY2suIFRoZSBxdWVyeSBleGVjdXRlcyBpZiBgY2FsbGJhY2tgIGlzIHBhc3NlZCBlbHNlIGEgUXVlcnkgb2JqZWN0IGlzIHJldHVybmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSwgb3B0aW9ucykgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlKSAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIEEuZmluZE9uZUFuZFVwZGF0ZSgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIEFsbCB0b3AgbGV2ZWwgdXBkYXRlIGtleXMgd2hpY2ggYXJlIG5vdCBgYXRvbWljYCBvcGVyYXRpb24gbmFtZXMgYXJlIHRyZWF0ZWQgYXMgc2V0IG9wZXJhdGlvbnM6XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IHsgbmFtZTogJ2Jvcm5lJyB9O1xuICogICAgIE1vZGVsLmZpbmRPbmVBbmRVcGRhdGUocXVlcnksIHsgbmFtZTogJ2phc29uIGJvdXJuZScgfSwgb3B0aW9ucylcbiAqXG4gKiAgICAgLy8gaXMgc2VudCBhc1xuICogICAgIE1vZGVsLmZpbmRPbmVBbmRVcGRhdGUocXVlcnksIHsgJHNldDogeyBuYW1lOiAnamFzb24gYm91cm5lJyB9fSwgb3B0aW9ucylcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogYGZpbmRPbmVBbmRYYCBhbmQgYGZpbmRCeUlkQW5kWGAgZnVuY3Rpb25zIHN1cHBvcnQgbGltaXRlZCB2YWxpZGF0aW9uIHRoYXRcbiAqIHlvdSBjYW4gZW5hYmxlIGJ5IHNldHRpbmcgdGhlIGBydW5WYWxpZGF0b3JzYCBvcHRpb24uXG4gKlxuICogSWYgeW91IG5lZWQgZnVsbC1mbGVkZ2VkIHZhbGlkYXRpb24sIHVzZSB0aGUgdHJhZGl0aW9uYWwgYXBwcm9hY2ggb2YgZmlyc3RcbiAqIHJldHJpZXZpbmcgdGhlIGRvY3VtZW50LlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNb2RlbC5maW5kQnlJZChpZCk7XG4gKiAgICAgZG9jLm5hbWUgPSAnamFzb24gYm91cm5lJztcbiAqICAgICBhd2FpdCBkb2Muc2F2ZSgpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZGl0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdXBkYXRlXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmV0dXJuRG9jdW1lbnQ9J2JlZm9yZSddIEhhcyB0d28gcG9zc2libGUgdmFsdWVzLCBgJ2JlZm9yZSdgIGFuZCBgJ2FmdGVyJ2AuIEJ5IGRlZmF1bHQsIGl0IHdpbGwgcmV0dXJuIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHVwZGF0ZSB3YXMgYXBwbGllZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5sZWFuXSBpZiB0cnV0aHksIG1vbmdvb3NlIHdpbGwgcmV0dXJuIHRoZSBkb2N1bWVudCBhcyBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IHJhdGhlciB0aGFuIGEgbW9uZ29vc2UgZG9jdW1lbnQuIFNlZSBbYFF1ZXJ5LmxlYW4oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubGVhbigpKSBhbmQgW3RoZSBNb25nb29zZSBsZWFuIHR1dG9yaWFsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2xlYW4uaHRtbCkuXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzIHlvdSB0byBvdmVyd3JpdGUgdGltZXN0YW1wcy4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vdmVyd3JpdGU9ZmFsc2VdIElmIHNldCB0byBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgY29udmVydCB0aGlzIGBmaW5kT25lQW5kVXBkYXRlKClgIHRvIGEgYGZpbmRPbmVBbmRSZXBsYWNlKClgLiBUaGlzIG9wdGlvbiBpcyBkZXByZWNhdGVkIGFuZCBvbmx5IHN1cHBvcnRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGlibGl0eS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gW29wdGlvbnMucHJvamVjdGlvbj1udWxsXSBvcHRpb25hbCBmaWVsZHMgdG8gcmV0dXJuLCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5uZXc9ZmFsc2VdIGlmIHRydWUsIHJldHVybiB0aGUgbW9kaWZpZWQgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdGhlIG9yaWdpbmFsXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLmZpZWxkc10gRmllbGQgc2VsZWN0aW9uLiBFcXVpdmFsZW50IHRvIGAuc2VsZWN0KGZpZWxkcykuZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFRpbWVNU10gcHV0cyBhIHRpbWUgbGltaXQgb24gdGhlIHF1ZXJ5IC0gcmVxdWlyZXMgbW9uZ29kYiA+PSAyLjYuMFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5zb3J0XSBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnVuVmFsaWRhdG9yc10gaWYgdHJ1ZSwgcnVucyBbdXBkYXRlIHZhbGlkYXRvcnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy92YWxpZGF0aW9uLmh0bWwjdXBkYXRlLXZhbGlkYXRvcnMpIG9uIHRoaXMgY29tbWFuZC4gVXBkYXRlIHZhbGlkYXRvcnMgdmFsaWRhdGUgdGhlIHVwZGF0ZSBvcGVyYXRpb24gYWdhaW5zdCB0aGUgbW9kZWwncyBzY2hlbWFcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydD10cnVlXSBJZiBgc2V0RGVmYXVsdHNPbkluc2VydGAgYW5kIGB1cHNlcnRgIGFyZSB0cnVlLCBtb25nb29zZSB3aWxsIGFwcGx5IHRoZSBbZGVmYXVsdHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9kZWZhdWx0cy5odG1sKSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsJ3Mgc2NoZW1hIGlmIGEgbmV3IGRvY3VtZW50IGlzIGNyZWF0ZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmF3UmVzdWx0XSBpZiB0cnVlLCByZXR1cm5zIHRoZSBbcmF3IHJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleT1mYWxzZV0gTW9uZ29vc2UgcmVtb3ZlcyBkaXNjcmltaW5hdG9yIGtleSB1cGRhdGVzIGZyb20gYHVwZGF0ZWAgYnkgZGVmYXVsdCwgc2V0IGBvdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5YCB0byBgdHJ1ZWAgdG8gYWxsb3cgdXBkYXRpbmcgdGhlIGRpc2NyaW1pbmF0b3Iga2V5XG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgVHV0b3JpYWwgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9maW5kb25lYW5kdXBkYXRlLmh0bWxcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9maW5kQW5kTW9kaWZ5L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5maW5kT25lQW5kVXBkYXRlID0gZnVuY3Rpb24oY29uZGl0aW9ucywgdXBkYXRlLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmRPbmVBbmRVcGRhdGUnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZmluZE9uZUFuZFVwZGF0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdXBkYXRlID0gY29uZGl0aW9ucztcbiAgICBjb25kaXRpb25zID0gbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGxldCBmaWVsZHM7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgZmllbGRzID0gb3B0aW9ucy5maWVsZHMgfHwgb3B0aW9ucy5wcm9qZWN0aW9uO1xuICB9XG5cbiAgdXBkYXRlID0gY2xvbmUodXBkYXRlLCB7XG4gICAgZGVwb3B1bGF0ZTogdHJ1ZSxcbiAgICBfaXNOZXN0ZWQ6IHRydWVcbiAgfSk7XG5cbiAgZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleSh1cGRhdGUsIG9wdGlvbnMsIHRoaXMuc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSk7XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNlbGVjdChmaWVsZHMpO1xuXG4gIHJldHVybiBtcS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIElzc3VlcyBhIG1vbmdvZGIgZmluZE9uZUFuZFVwZGF0ZSBjb21tYW5kIGJ5IGEgZG9jdW1lbnQncyBfaWQgZmllbGQuXG4gKiBgZmluZEJ5SWRBbmRVcGRhdGUoaWQsIC4uLilgIGlzIGVxdWl2YWxlbnQgdG8gYGZpbmRPbmVBbmRVcGRhdGUoeyBfaWQ6IGlkIH0sIC4uLilgLlxuICpcbiAqIEZpbmRzIGEgbWF0Y2hpbmcgZG9jdW1lbnQsIHVwZGF0ZXMgaXQgYWNjb3JkaW5nIHRvIHRoZSBgdXBkYXRlYCBhcmcsXG4gKiBwYXNzaW5nIGFueSBgb3B0aW9uc2AsIGFuZCByZXR1cm5zIHRoZSBmb3VuZCBkb2N1bWVudCAoaWYgYW55KS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lQW5kVXBkYXRlKClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBBLmZpbmRCeUlkQW5kVXBkYXRlKGlkLCB1cGRhdGUsIG9wdGlvbnMpICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS5maW5kQnlJZEFuZFVwZGF0ZShpZCwgdXBkYXRlKSAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIEEuZmluZEJ5SWRBbmRVcGRhdGUoKSAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQWxsIHRvcCBsZXZlbCB1cGRhdGUga2V5cyB3aGljaCBhcmUgbm90IGBhdG9taWNgIG9wZXJhdGlvbiBuYW1lcyBhcmUgdHJlYXRlZCBhcyBzZXQgb3BlcmF0aW9uczpcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKGlkLCB7IG5hbWU6ICdqYXNvbiBib3VybmUnIH0sIG9wdGlvbnMpXG4gKlxuICogICAgIC8vIGlzIHNlbnQgYXNcbiAqICAgICBNb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShpZCwgeyAkc2V0OiB7IG5hbWU6ICdqYXNvbiBib3VybmUnIH19LCBvcHRpb25zKVxuICpcbiAqIFRoaXMgaGVscHMgcHJldmVudCBhY2NpZGVudGFsbHkgb3ZlcndyaXRpbmcgeW91ciBkb2N1bWVudCB3aXRoIGB7IG5hbWU6ICdqYXNvbiBib3VybmUnIH1gLlxuICogVG8gcHJldmVudCB0aGlzIGJlaGF2aW91ciwgc2VlIHRoZSBgb3ZlcndyaXRlYCBvcHRpb25cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogYGZpbmRPbmVBbmRYYCBhbmQgYGZpbmRCeUlkQW5kWGAgZnVuY3Rpb25zIHN1cHBvcnQgbGltaXRlZCB2YWxpZGF0aW9uLiBZb3UgY2FuXG4gKiBlbmFibGUgdmFsaWRhdGlvbiBieSBzZXR0aW5nIHRoZSBgcnVuVmFsaWRhdG9yc2Agb3B0aW9uLlxuICpcbiAqIElmIHlvdSBuZWVkIGZ1bGwtZmxlZGdlZCB2YWxpZGF0aW9uLCB1c2UgdGhlIHRyYWRpdGlvbmFsIGFwcHJvYWNoIG9mIGZpcnN0XG4gKiByZXRyaWV2aW5nIHRoZSBkb2N1bWVudC5cbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZEJ5SWQoaWQpXG4gKiAgICAgZG9jLm5hbWUgPSAnamFzb24gYm91cm5lJztcbiAqICAgICBhd2FpdCBkb2Muc2F2ZSgpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fE51bWJlcnxTdHJpbmd9IGlkIHZhbHVlIG9mIGBfaWRgIHRvIHF1ZXJ5IGJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW3VwZGF0ZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJldHVybkRvY3VtZW50PSdiZWZvcmUnXSBIYXMgdHdvIHBvc3NpYmxlIHZhbHVlcywgYCdiZWZvcmUnYCBhbmQgYCdhZnRlcidgLiBCeSBkZWZhdWx0LCBpdCB3aWxsIHJldHVybiB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSB1cGRhdGUgd2FzIGFwcGxpZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGVhbl0gaWYgdHJ1dGh5LCBtb25nb29zZSB3aWxsIHJldHVybiB0aGUgZG9jdW1lbnQgYXMgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCByYXRoZXIgdGhhbiBhIG1vbmdvb3NlIGRvY3VtZW50LiBTZWUgW2BRdWVyeS5sZWFuKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmxlYW4oKSkgYW5kIFt0aGUgTW9uZ29vc2UgbGVhbiB0dXRvcmlhbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9sZWFuLmh0bWwpLlxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIE5vdGUgdGhhdCB0aGlzIGFsbG93cyB5b3UgdG8gb3ZlcndyaXRlIHRpbWVzdGFtcHMuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlPWZhbHNlXSBJZiBzZXQgdG8gYHRydWVgLCBNb25nb29zZSB3aWxsIGNvbnZlcnQgdGhpcyBgZmluZEJ5SWRBbmRVcGRhdGUoKWAgdG8gYSBgZmluZEJ5SWRBbmRSZXBsYWNlKClgLiBUaGlzIG9wdGlvbiBpcyBkZXByZWNhdGVkIGFuZCBvbmx5IHN1cHBvcnRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGlibGl0eS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnMuc29ydF0gaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJ1blZhbGlkYXRvcnNdIGlmIHRydWUsIHJ1bnMgW3VwZGF0ZSB2YWxpZGF0b3JzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdmFsaWRhdGlvbi5odG1sI3VwZGF0ZS12YWxpZGF0b3JzKSBvbiB0aGlzIGNvbW1hbmQuIFVwZGF0ZSB2YWxpZGF0b3JzIHZhbGlkYXRlIHRoZSB1cGRhdGUgb3BlcmF0aW9uIGFnYWluc3QgdGhlIG1vZGVsJ3Mgc2NoZW1hXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNldERlZmF1bHRzT25JbnNlcnQ9dHJ1ZV0gSWYgYHNldERlZmF1bHRzT25JbnNlcnRgIGFuZCBgdXBzZXJ0YCBhcmUgdHJ1ZSwgbW9uZ29vc2Ugd2lsbCBhcHBseSB0aGUgW2RlZmF1bHRzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZGVmYXVsdHMuaHRtbCkgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCdzIHNjaGVtYSBpZiBhIG5ldyBkb2N1bWVudCBpcyBjcmVhdGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJhd1Jlc3VsdF0gaWYgdHJ1ZSwgcmV0dXJucyB0aGUgW3JhdyByZXN1bHQgZnJvbSB0aGUgTW9uZ29EQiBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb2RpZnlSZXN1bHQuaHRtbClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubmV3PWZhbHNlXSBpZiB0cnVlLCByZXR1cm4gdGhlIG1vZGlmaWVkIGRvY3VtZW50IHJhdGhlciB0aGFuIHRoZSBvcmlnaW5hbFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RdIHNldHMgdGhlIGRvY3VtZW50IGZpZWxkcyB0byByZXR1cm4uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5PWZhbHNlXSBNb25nb29zZSByZW1vdmVzIGRpc2NyaW1pbmF0b3Iga2V5IHVwZGF0ZXMgZnJvbSBgdXBkYXRlYCBieSBkZWZhdWx0LCBzZXQgYG92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXlgIHRvIGB0cnVlYCB0byBhbGxvdyB1cGRhdGluZyB0aGUgZGlzY3JpbWluYXRvciBrZXlcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBNb2RlbC5maW5kT25lQW5kVXBkYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5maW5kT25lQW5kVXBkYXRlKClcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9maW5kQW5kTW9kaWZ5L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5maW5kQnlJZEFuZFVwZGF0ZSA9IGZ1bmN0aW9uKGlkLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZmluZEJ5SWRBbmRVcGRhdGUnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICAvLyBpZiBhIG1vZGVsIGlzIHBhc3NlZCBpbiBpbnN0ZWFkIG9mIGFuIGlkXG4gIGlmIChpZCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgaWQgPSBpZC5faWQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5maW5kT25lQW5kVXBkYXRlLmNhbGwodGhpcywgeyBfaWQ6IGlkIH0sIHVwZGF0ZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIElzc3VlIGEgTW9uZ29EQiBgZmluZE9uZUFuZERlbGV0ZSgpYCBjb21tYW5kLlxuICpcbiAqIEZpbmRzIGEgbWF0Y2hpbmcgZG9jdW1lbnQsIHJlbW92ZXMgaXQsIGFuZCByZXR1cm5zIHRoZSBmb3VuZCBkb2N1bWVudCAoaWYgYW55KS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkaWZmZXJzIHNsaWdodGx5IGZyb20gYE1vZGVsLmZpbmRPbmVBbmRSZW1vdmUoKWAgaW4gdGhhdFxuICogYGZpbmRPbmVBbmRSZW1vdmUoKWAgYmVjb21lcyBhIFtNb25nb0RCIGBmaW5kQW5kTW9kaWZ5KClgIGNvbW1hbmRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5maW5kQW5kTW9kaWZ5LyksXG4gKiBhcyBvcHBvc2VkIHRvIGEgYGZpbmRPbmVBbmREZWxldGUoKWAgY29tbWFuZC4gRm9yIG1vc3QgbW9uZ29vc2UgdXNlIGNhc2VzLFxuICogdGhpcyBkaXN0aW5jdGlvbiBpcyBwdXJlbHkgcGVkYW50aWMuIFlvdSBzaG91bGQgdXNlIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiB1bmxlc3MgeW91IGhhdmUgYSBnb29kIHJlYXNvbiBub3QgdG8uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBBLmZpbmRPbmVBbmREZWxldGUoY29uZGl0aW9ucywgb3B0aW9ucykgIC8vIHJldHVybiBRdWVyeVxuICogICAgIEEuZmluZE9uZUFuZERlbGV0ZShjb25kaXRpb25zKSAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS5maW5kT25lQW5kRGVsZXRlKCkgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqXG4gKiBgZmluZE9uZUFuZFhgIGFuZCBgZmluZEJ5SWRBbmRYYCBmdW5jdGlvbnMgc3VwcG9ydCBsaW1pdGVkIHZhbGlkYXRpb24uIFlvdSBjYW5cbiAqIGVuYWJsZSB2YWxpZGF0aW9uIGJ5IHNldHRpbmcgdGhlIGBydW5WYWxpZGF0b3JzYCBvcHRpb24uXG4gKlxuICogSWYgeW91IG5lZWQgZnVsbC1mbGVkZ2VkIHZhbGlkYXRpb24sIHVzZSB0aGUgdHJhZGl0aW9uYWwgYXBwcm9hY2ggb2YgZmlyc3RcbiAqIHJldHJpZXZpbmcgdGhlIGRvY3VtZW50LlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNb2RlbC5maW5kQnlJZChpZClcbiAqICAgICBkb2MubmFtZSA9ICdqYXNvbiBib3VybmUnO1xuICogICAgIGF3YWl0IGRvYy5zYXZlKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmRpdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8U3RyaW5nW119IFtvcHRpb25zLnByb2plY3Rpb249bnVsbF0gb3B0aW9uYWwgZmllbGRzIHRvIHJldHVybiwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKSlcbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmF3UmVzdWx0XSBpZiB0cnVlLCByZXR1cm5zIHRoZSBbcmF3IHJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5zb3J0XSBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnMuc2VsZWN0XSBzZXRzIHRoZSBkb2N1bWVudCBmaWVsZHMgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFRpbWVNU10gcHV0cyBhIHRpbWUgbGltaXQgb24gdGhlIHF1ZXJ5IC0gcmVxdWlyZXMgbW9uZ29kYiA+PSAyLjYuMFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5maW5kT25lQW5kRGVsZXRlID0gZnVuY3Rpb24oY29uZGl0aW9ucywgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdmaW5kT25lQW5kRGVsZXRlJyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmZpbmRPbmVBbmREZWxldGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBsZXQgZmllbGRzO1xuICBpZiAob3B0aW9ucykge1xuICAgIGZpZWxkcyA9IG9wdGlvbnMuc2VsZWN0O1xuICAgIG9wdGlvbnMuc2VsZWN0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNlbGVjdChmaWVsZHMpO1xuXG4gIHJldHVybiBtcS5maW5kT25lQW5kRGVsZXRlKGNvbmRpdGlvbnMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZSBhIE1vbmdvREIgYGZpbmRPbmVBbmREZWxldGUoKWAgY29tbWFuZCBieSBhIGRvY3VtZW50J3MgX2lkIGZpZWxkLlxuICogSW4gb3RoZXIgd29yZHMsIGBmaW5kQnlJZEFuZERlbGV0ZShpZClgIGlzIGEgc2hvcnRoYW5kIGZvclxuICogYGZpbmRPbmVBbmREZWxldGUoeyBfaWQ6IGlkIH0pYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R8TnVtYmVyfFN0cmluZ30gaWQgdmFsdWUgb2YgYF9pZGAgdG8gcXVlcnkgYnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAc2VlIE1vZGVsLmZpbmRPbmVBbmRSZW1vdmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLmZpbmRPbmVBbmRSZW1vdmUoKVxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2ZpbmRBbmRNb2RpZnkvXG4gKi9cblxuTW9kZWwuZmluZEJ5SWRBbmREZWxldGUgPSBmdW5jdGlvbihpZCwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdmaW5kQnlJZEFuZERlbGV0ZScpO1xuXG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kQnlJZEFuZERlbGV0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmRPbmVBbmREZWxldGUoeyBfaWQ6IGlkIH0sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZSBhIE1vbmdvREIgYGZpbmRPbmVBbmRSZXBsYWNlKClgIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgcmVwbGFjZXMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgZG9jLCBhbmQgcmV0dXJucyB0aGUgZG9jdW1lbnQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIHF1ZXJ5IG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZUFuZFJlcGxhY2UoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIEEuZmluZE9uZUFuZFJlcGxhY2UoZmlsdGVyLCByZXBsYWNlbWVudCwgb3B0aW9ucykgIC8vIHJldHVybiBRdWVyeVxuICogICAgIEEuZmluZE9uZUFuZFJlcGxhY2UoZmlsdGVyLCByZXBsYWNlbWVudCkgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIEEuZmluZE9uZUFuZFJlcGxhY2UoKSAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXIgUmVwbGFjZSB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIHRoaXMgZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcGxhY2VtZW50XSBSZXBsYWNlIHdpdGggdGhpcyBkb2N1bWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmV0dXJuRG9jdW1lbnQ9J2JlZm9yZSddIEhhcyB0d28gcG9zc2libGUgdmFsdWVzLCBgJ2JlZm9yZSdgIGFuZCBgJ2FmdGVyJ2AuIEJ5IGRlZmF1bHQsIGl0IHdpbGwgcmV0dXJuIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHVwZGF0ZSB3YXMgYXBwbGllZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5sZWFuXSBpZiB0cnV0aHksIG1vbmdvb3NlIHdpbGwgcmV0dXJuIHRoZSBkb2N1bWVudCBhcyBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IHJhdGhlciB0aGFuIGEgbW9uZ29vc2UgZG9jdW1lbnQuIFNlZSBbYFF1ZXJ5LmxlYW4oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubGVhbigpKSBhbmQgW3RoZSBNb25nb29zZSBsZWFuIHR1dG9yaWFsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2xlYW4uaHRtbCkuXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzIHlvdSB0byBvdmVyd3JpdGUgdGltZXN0YW1wcy4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBbb3B0aW9ucy5wcm9qZWN0aW9uPW51bGxdIG9wdGlvbmFsIGZpZWxkcyB0byByZXR1cm4sIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNvcnRdIGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yYXdSZXN1bHRdIGlmIHRydWUsIHJldHVybnMgdGhlIFtyYXcgcmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNlbGVjdF0gc2V0cyB0aGUgZG9jdW1lbnQgZmllbGRzIHRvIHJldHVybi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhUaW1lTVNdIHB1dHMgYSB0aW1lIGxpbWl0IG9uIHRoZSBxdWVyeSAtIHJlcXVpcmVzIG1vbmdvZGIgPj0gMi42LjBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZmluZE9uZUFuZFJlcGxhY2UgPSBmdW5jdGlvbihmaWx0ZXIsIHJlcGxhY2VtZW50LCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmRPbmVBbmRSZXBsYWNlJyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZmluZE9uZUFuZFJlcGxhY2UoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBsZXQgZmllbGRzO1xuICBpZiAob3B0aW9ucykge1xuICAgIGZpZWxkcyA9IG9wdGlvbnMuc2VsZWN0O1xuICAgIG9wdGlvbnMuc2VsZWN0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNlbGVjdChmaWVsZHMpO1xuXG4gIHJldHVybiBtcS5maW5kT25lQW5kUmVwbGFjZShmaWx0ZXIsIHJlcGxhY2VtZW50LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSXNzdWUgYSBtb25nb2RiIGZpbmRPbmVBbmRSZW1vdmUgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCByZW1vdmVzIGl0LCBhbmQgcmV0dXJucyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZUFuZFJlbW92ZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQS5maW5kT25lQW5kUmVtb3ZlKGNvbmRpdGlvbnMsIG9wdGlvbnMpICAvLyByZXR1cm4gUXVlcnlcbiAqICAgICBBLmZpbmRPbmVBbmRSZW1vdmUoY29uZGl0aW9ucykgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIEEuZmluZE9uZUFuZFJlbW92ZSgpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogYGZpbmRPbmVBbmRYYCBhbmQgYGZpbmRCeUlkQW5kWGAgZnVuY3Rpb25zIHN1cHBvcnQgbGltaXRlZCB2YWxpZGF0aW9uLiBZb3UgY2FuXG4gKiBlbmFibGUgdmFsaWRhdGlvbiBieSBzZXR0aW5nIHRoZSBgcnVuVmFsaWRhdG9yc2Agb3B0aW9uLlxuICpcbiAqIElmIHlvdSBuZWVkIGZ1bGwtZmxlZGdlZCB2YWxpZGF0aW9uLCB1c2UgdGhlIHRyYWRpdGlvbmFsIGFwcHJvYWNoIG9mIGZpcnN0XG4gKiByZXRyaWV2aW5nIHRoZSBkb2N1bWVudC5cbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZEJ5SWQoaWQpO1xuICogICAgIGRvYy5uYW1lID0gJ2phc29uIGJvdXJuZSc7XG4gKiAgICAgYXdhaXQgZG9jLnNhdmUoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZGl0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gW29wdGlvbnMucHJvamVjdGlvbj1udWxsXSBvcHRpb25hbCBmaWVsZHMgdG8gcmV0dXJuLCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpKVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5zb3J0XSBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmF3UmVzdWx0XSBpZiB0cnVlLCByZXR1cm5zIHRoZSBbcmF3IHJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RdIHNldHMgdGhlIGRvY3VtZW50IGZpZWxkcyB0byByZXR1cm4uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4VGltZU1TXSBwdXRzIGEgdGltZSBsaW1pdCBvbiB0aGUgcXVlcnkgLSByZXF1aXJlcyBtb25nb2RiID49IDIuNi4wXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvZmluZEFuZE1vZGlmeS9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZmluZE9uZUFuZFJlbW92ZSA9IGZ1bmN0aW9uKGNvbmRpdGlvbnMsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZmluZE9uZUFuZFJlbW92ZScpO1xuXG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmZpbmRPbmVBbmRSZW1vdmUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBsZXQgZmllbGRzO1xuICBpZiAob3B0aW9ucykge1xuICAgIGZpZWxkcyA9IG9wdGlvbnMuc2VsZWN0O1xuICAgIG9wdGlvbnMuc2VsZWN0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNlbGVjdChmaWVsZHMpO1xuXG4gIHJldHVybiBtcS5maW5kT25lQW5kUmVtb3ZlKGNvbmRpdGlvbnMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZSBhIG1vbmdvZGIgZmluZE9uZUFuZFJlbW92ZSBjb21tYW5kIGJ5IGEgZG9jdW1lbnQncyBfaWQgZmllbGQuIGBmaW5kQnlJZEFuZFJlbW92ZShpZCwgLi4uKWAgaXMgZXF1aXZhbGVudCB0byBgZmluZE9uZUFuZFJlbW92ZSh7IF9pZDogaWQgfSwgLi4uKWAuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgcmVtb3ZlcyBpdCwgYW5kIHJldHVybnMgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmVBbmRSZW1vdmUoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIEEuZmluZEJ5SWRBbmRSZW1vdmUoaWQsIG9wdGlvbnMpICAvLyByZXR1cm4gUXVlcnlcbiAqICAgICBBLmZpbmRCeUlkQW5kUmVtb3ZlKGlkKSAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS5maW5kQnlJZEFuZFJlbW92ZSgpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogQHBhcmFtIHtPYmplY3R8TnVtYmVyfFN0cmluZ30gaWQgdmFsdWUgb2YgYF9pZGAgdG8gcXVlcnkgYnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8U3RyaW5nW119IFtvcHRpb25zLnByb2plY3Rpb249bnVsbF0gb3B0aW9uYWwgZmllbGRzIHRvIHJldHVybiwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKSlcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnMuc29ydF0gaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJhd1Jlc3VsdF0gaWYgdHJ1ZSwgcmV0dXJucyB0aGUgW3JhdyByZXN1bHQgZnJvbSB0aGUgTW9uZ29EQiBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb2RpZnlSZXN1bHQuaHRtbClcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnMuc2VsZWN0XSBzZXRzIHRoZSBkb2N1bWVudCBmaWVsZHMgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBNb2RlbC5maW5kT25lQW5kUmVtb3ZlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5maW5kT25lQW5kUmVtb3ZlKClcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9maW5kQW5kTW9kaWZ5L1xuICovXG5cbk1vZGVsLmZpbmRCeUlkQW5kUmVtb3ZlID0gZnVuY3Rpb24oaWQsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZmluZEJ5SWRBbmRSZW1vdmUnKTtcblxuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kQnlJZEFuZFJlbW92ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmRPbmVBbmRSZW1vdmUoeyBfaWQ6IGlkIH0sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTaG9ydGN1dCBmb3Igc2F2aW5nIG9uZSBvciBtb3JlIGRvY3VtZW50cyB0byB0aGUgZGF0YWJhc2UuXG4gKiBgTXlNb2RlbC5jcmVhdGUoZG9jcylgIGRvZXMgYG5ldyBNeU1vZGVsKGRvYykuc2F2ZSgpYCBmb3IgZXZlcnkgZG9jIGluXG4gKiBkb2NzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYHNhdmUoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEluc2VydCBvbmUgbmV3IGBDaGFyYWN0ZXJgIGRvY3VtZW50XG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmNyZWF0ZSh7IG5hbWU6ICdKZWFuLUx1YyBQaWNhcmQnIH0pO1xuICpcbiAqICAgICAvLyBJbnNlcnQgbXVsdGlwbGUgbmV3IGBDaGFyYWN0ZXJgIGRvY3VtZW50c1xuICogICAgIGF3YWl0IENoYXJhY3Rlci5jcmVhdGUoW3sgbmFtZTogJ1dpbGwgUmlrZXInIH0sIHsgbmFtZTogJ0dlb3JkaSBMYUZvcmdlJyB9XSk7XG4gKlxuICogICAgIC8vIENyZWF0ZSBhIG5ldyBjaGFyYWN0ZXIgd2l0aGluIGEgdHJhbnNhY3Rpb24uIE5vdGUgdGhhdCB5b3UgKiptdXN0KipcbiAqICAgICAvLyBwYXNzIGFuIGFycmF5IGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgdG8gYGNyZWF0ZSgpYCBpZiB5b3Ugd2FudCB0b1xuICogICAgIC8vIHNwZWNpZnkgb3B0aW9ucy5cbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuY3JlYXRlKFt7IG5hbWU6ICdKZWFuLUx1YyBQaWNhcmQnIH1dLCB7IHNlc3Npb24gfSk7XG4gKlxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGRvY3MgRG9jdW1lbnRzIHRvIGluc2VydCwgYXMgYSBzcHJlYWQgb3IgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBwYXNzZWQgZG93biB0byBgc2F2ZSgpYC4gVG8gc3BlY2lmeSBgb3B0aW9uc2AsIGBkb2NzYCAqKm11c3QqKiBiZSBhbiBhcnJheSwgbm90IGEgc3ByZWFkLiBTZWUgW01vZGVsLnNhdmVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5wcm90b3R5cGUuc2F2ZSgpKSBmb3IgYXZhaWxhYmxlIG9wdGlvbnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9yZGVyZWRdIHNhdmVzIHRoZSBkb2NzIGluIHNlcmllcyByYXRoZXIgdGhhbiBwYXJhbGxlbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWdncmVnYXRlRXJyb3JzXSBBZ2dyZWdhdGUgRXJyb3JzIGluc3RlYWQgb2YgdGhyb3dpbmcgdGhlIGZpcnN0IG9uZSB0aGF0IG9jY3Vycy4gRGVmYXVsdDogZmFsc2VcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmNyZWF0ZSA9IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZShkb2MsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmNyZWF0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2NyZWF0ZScpO1xuXG4gIGxldCBhcmdzO1xuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gdGhpcy5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGRvYykpIHtcbiAgICBhcmdzID0gZG9jO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnID8gb3B0aW9ucyA6IHt9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3QgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgICBjb25zdCBoYXNDYWxsYmFjayA9IHR5cGVvZiBsYXN0ID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5jcmVhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MgPSBbLi4uYXJndW1lbnRzXTtcbiAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDYueCwgYmVjYXVzZSBvZiBnaC01MDYxIE1vbmdvb3NlIDYueCBhbmRcbiAgICAgIC8vIG9sZGVyIHdvdWxkIHRyZWF0IGEgZmFsc3kgbGFzdCBhcmcgYXMgYSBjYWxsYmFjay4gV2UgZG9uJ3Qgd2FudCB0byB0aHJvd1xuICAgICAgLy8gYW4gZXJyb3IgaGVyZSwgYmVjYXVzZSBpdCB3b3VsZCBsb29rIHN0cmFuZ2UgaWYgYFRlc3QuY3JlYXRlKHt9LCB2b2lkIDApYFxuICAgICAgLy8gdGhyZXcgYSBjYWxsYmFjayBlcnJvci4gQnV0IHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjcmVhdGUgYW4gdW5uZWNlc3NhcnkgZG9jdW1lbnQuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAxICYmICFsYXN0KSB7XG4gICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyICYmXG4gICAgICAgIGFyZ3NbMF0gIT0gbnVsbCAmJlxuICAgICAgICBhcmdzWzFdICE9IG51bGwgJiZcbiAgICAgICAgYXJnc1swXS5zZXNzaW9uID09IG51bGwgJiZcbiAgICAgICAgbGFzdCAmJlxuICAgICAgICBnZXRDb25zdHJ1Y3Rvck5hbWUobGFzdC5zZXNzaW9uKSA9PT0gJ0NsaWVudFNlc3Npb24nICYmXG4gICAgICAgICF0aGlzLnNjaGVtYS5wYXRoKCdzZXNzaW9uJykpIHtcbiAgICAgIC8vIFByb2JhYmx5IG1lYW5zIHRoZSB1c2VyIGlzIHJ1bm5pbmcgaW50byB0aGUgY29tbW9uIG1pc3Rha2Ugb2YgdHJ5aW5nXG4gICAgICAvLyB0byB1c2UgYSBzcHJlYWQgdG8gc3BlY2lmeSBvcHRpb25zLCBzZWUgZ2gtNzUzNVxuICAgICAgdXRpbHMud2FybignV0FSTklORzogdG8gcGFzcyBhIGBzZXNzaW9uYCB0byBgTW9kZWwuY3JlYXRlKClgIGluICcgK1xuICAgICAgICAnTW9uZ29vc2UsIHlvdSAqKm11c3QqKiBwYXNzIGFuIGFycmF5IGFzIHRoZSBmaXJzdCBhcmd1bWVudC4gU2VlOiAnICtcbiAgICAgICAgJ2h0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5jcmVhdGUoKScpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGRvYykgPyBbXSA6IG51bGw7XG4gIH1cbiAgbGV0IHJlcyA9IFtdO1xuICBjb25zdCBpbW1lZGlhdGVFcnJvciA9IHR5cGVvZiBvcHRpb25zLmFnZ3JlZ2F0ZUVycm9ycyA9PT0gJ2Jvb2xlYW4nID8gIW9wdGlvbnMuYWdncmVnYXRlRXJyb3JzIDogdHJ1ZTtcblxuICBkZWxldGUgb3B0aW9ucy5hZ2dyZWdhdGVFcnJvcnM7IC8vIGRvbnQgcGFzcyBvbiB0aGUgb3B0aW9uIHRvIFwiJHNhdmVcIlxuXG4gIGlmIChvcHRpb25zLm9yZGVyZWQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRvYyA9IGFyZ3NbaV07XG4gICAgICAgIGNvbnN0IE1vZGVsID0gdGhpcy5kaXNjcmltaW5hdG9ycyAmJiBkb2NbZGlzY3JpbWluYXRvcktleV0gIT0gbnVsbCA/XG4gICAgICAgICAgdGhpcy5kaXNjcmltaW5hdG9yc1tkb2NbZGlzY3JpbWluYXRvcktleV1dIHx8IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKHRoaXMuZGlzY3JpbWluYXRvcnMsIGRvY1tkaXNjcmltaW5hdG9yS2V5XSkgOlxuICAgICAgICAgIHRoaXM7XG4gICAgICAgIGlmIChNb2RlbCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoYERpc2NyaW1pbmF0b3IgXCIke2RvY1tkaXNjcmltaW5hdG9yS2V5XX1cIiBub3QgYCArXG4gICAgICAgICAgYGZvdW5kIGZvciBtb2RlbCBcIiR7dGhpcy5tb2RlbE5hbWV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9TYXZlID0gZG9jO1xuICAgICAgICBpZiAoISh0b1NhdmUgaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICAgICAgICB0b1NhdmUgPSBuZXcgTW9kZWwodG9TYXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRvU2F2ZS4kc2F2ZShvcHRpb25zKTtcbiAgICAgICAgcmVzLnB1c2godG9TYXZlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWltbWVkaWF0ZUVycm9yKSB7XG4gICAgICAgICAgcmVzLnB1c2goZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIHtcbiAgICAvLyBcIi5iaW5kKFByb21pc2UpXCIgaXMgcmVxdWlyZWQsIG90aGVyd2lzZSByZXN1bHRzIGluIFwiVHlwZUVycm9yOiBQcm9taXNlLmFsbFNldHRsZWQgY2FsbGVkIG9uIG5vbi1vYmplY3RcIlxuICAgIGNvbnN0IHByb21pc2VUeXBlID0gIWltbWVkaWF0ZUVycm9yID8gUHJvbWlzZS5hbGxTZXR0bGVkLmJpbmQoUHJvbWlzZSkgOiBQcm9taXNlLmFsbC5iaW5kKFByb21pc2UpO1xuICAgIGxldCBwID0gcHJvbWlzZVR5cGUoYXJncy5tYXAoYXN5bmMgZG9jID0+IHtcbiAgICAgIGNvbnN0IE1vZGVsID0gdGhpcy5kaXNjcmltaW5hdG9ycyAmJiBkb2NbZGlzY3JpbWluYXRvcktleV0gIT0gbnVsbCA/XG4gICAgICAgIHRoaXMuZGlzY3JpbWluYXRvcnNbZG9jW2Rpc2NyaW1pbmF0b3JLZXldXSB8fCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSh0aGlzLmRpc2NyaW1pbmF0b3JzLCBkb2NbZGlzY3JpbWluYXRvcktleV0pIDpcbiAgICAgICAgdGhpcztcbiAgICAgIGlmIChNb2RlbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBEaXNjcmltaW5hdG9yIFwiJHtkb2NbZGlzY3JpbWluYXRvcktleV19XCIgbm90IGAgK1xuICAgICAgICAgIGBmb3VuZCBmb3IgbW9kZWwgXCIke3RoaXMubW9kZWxOYW1lfVwiYCk7XG4gICAgICB9XG4gICAgICBsZXQgdG9TYXZlID0gZG9jO1xuXG4gICAgICBpZiAoISh0b1NhdmUgaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICAgICAgdG9TYXZlID0gbmV3IE1vZGVsKHRvU2F2ZSk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRvU2F2ZS4kc2F2ZShvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIHRvU2F2ZTtcbiAgICB9KSk7XG5cbiAgICAvLyBjaGFpbiB0aGUgbWFwcGVyLCBvbmx5IGlmIFwiYWxsU2V0dGxlZFwiIGlzIHVzZWRcbiAgICBpZiAoIWltbWVkaWF0ZUVycm9yKSB7XG4gICAgICBwID0gcC50aGVuKHByZXN1bHQgPT4gcHJlc3VsdC5tYXAodiA9PiB2LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgPyB2LnZhbHVlIDogdi5yZWFzb24pKTtcbiAgICB9XG5cbiAgICByZXMgPSBhd2FpdCBwO1xuICB9XG5cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoZG9jKSAmJiBhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiByZXNbMF07XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBfUmVxdWlyZXMgYSByZXBsaWNhIHNldCBydW5uaW5nIE1vbmdvREIgPj0gMy42LjAuXyBXYXRjaGVzIHRoZVxuICogdW5kZXJseWluZyBjb2xsZWN0aW9uIGZvciBjaGFuZ2VzIHVzaW5nXG4gKiBbTW9uZ29EQiBjaGFuZ2Ugc3RyZWFtc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY2hhbmdlU3RyZWFtcy8pLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyAqKm5vdCoqIHRyaWdnZXIgYW55IG1pZGRsZXdhcmUuIEluIHBhcnRpY3VsYXIsIGl0XG4gKiBkb2VzICoqbm90KiogdHJpZ2dlciBhZ2dyZWdhdGUgbWlkZGxld2FyZS5cbiAqXG4gKiBUaGUgQ2hhbmdlU3RyZWFtIG9iamVjdCBpcyBhbiBldmVudCBlbWl0dGVyIHRoYXQgZW1pdHMgdGhlIGZvbGxvd2luZyBldmVudHM6XG4gKlxuICogLSAnY2hhbmdlJzogQSBjaGFuZ2Ugb2NjdXJyZWQsIHNlZSBiZWxvdyBleGFtcGxlXG4gKiAtICdlcnJvcic6IEFuIHVucmVjb3ZlcmFibGUgZXJyb3Igb2NjdXJyZWQuIEluIHBhcnRpY3VsYXIsIGNoYW5nZSBzdHJlYW1zIGN1cnJlbnRseSBlcnJvciBvdXQgaWYgdGhleSBsb3NlIGNvbm5lY3Rpb24gdG8gdGhlIHJlcGxpY2Egc2V0IHByaW1hcnkuIEZvbGxvdyBbdGhpcyBHaXRIdWIgaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL21vbmdvb3NlL2lzc3Vlcy82Nzk5KSBmb3IgdXBkYXRlcy5cbiAqIC0gJ2VuZCc6IEVtaXR0ZWQgaWYgdGhlIHVuZGVybHlpbmcgc3RyZWFtIGlzIGNsb3NlZFxuICogLSAnY2xvc2UnOiBFbWl0dGVkIGlmIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBpcyBjbG9zZWRcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IFBlcnNvbi5jcmVhdGUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9KTtcbiAqICAgICBjb25zdCBjaGFuZ2VTdHJlYW0gPSBQZXJzb24ud2F0Y2goKS5vbignY2hhbmdlJywgY2hhbmdlID0+IGNvbnNvbGUubG9nKGNoYW5nZSkpO1xuICogICAgIC8vIFdpbGwgcHJpbnQgZnJvbSB0aGUgYWJvdmUgYGNvbnNvbGUubG9nKClgOlxuICogICAgIC8vIHsgX2lkOiB7IF9kYXRhOiAuLi4gfSxcbiAqICAgICAvLyAgIG9wZXJhdGlvblR5cGU6ICdkZWxldGUnLFxuICogICAgIC8vICAgbnM6IHsgZGI6ICdteWRiJywgY29sbDogJ1BlcnNvbicgfSxcbiAqICAgICAvLyAgIGRvY3VtZW50S2V5OiB7IF9pZDogNWE1MWIxMjVjNTUwMGY1YWEwOTRjN2JkIH0gfVxuICogICAgIGF3YWl0IGRvYy5yZW1vdmUoKTtcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBbcGlwZWxpbmVdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNlZSB0aGUgW21vbmdvZGIgZHJpdmVyIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjd2F0Y2gpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmh5ZHJhdGU9ZmFsc2VdIGlmIHRydWUgYW5kIGBmdWxsRG9jdW1lbnQ6ICd1cGRhdGVMb29rdXAnYCBpcyBzZXQsIE1vbmdvb3NlIHdpbGwgYXV0b21hdGljYWxseSBoeWRyYXRlIGBmdWxsRG9jdW1lbnRgIGludG8gYSBmdWxseSBmbGVkZ2VkIE1vbmdvb3NlIGRvY3VtZW50XG4gKiBAcmV0dXJuIHtDaGFuZ2VTdHJlYW19IG1vbmdvb3NlLXNwZWNpZmljIGNoYW5nZSBzdHJlYW0gd3JhcHBlciwgaW5oZXJpdHMgZnJvbSBFdmVudEVtaXR0ZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwud2F0Y2ggPSBmdW5jdGlvbihwaXBlbGluZSwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICd3YXRjaCcpO1xuXG4gIGNvbnN0IGNoYW5nZVN0cmVhbVRodW5rID0gY2IgPT4ge1xuICAgIHBpcGVsaW5lID0gcGlwZWxpbmUgfHwgW107XG4gICAgcHJlcGFyZURpc2NyaW1pbmF0b3JQaXBlbGluZShwaXBlbGluZSwgdGhpcy5zY2hlbWEsICdmdWxsRG9jdW1lbnQnKTtcbiAgICBpZiAodGhpcy4kX19jb2xsZWN0aW9uLmJ1ZmZlcikge1xuICAgICAgdGhpcy4kX19jb2xsZWN0aW9uLmFkZFF1ZXVlKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyaXZlckNoYW5nZVN0cmVhbSA9IHRoaXMuJF9fY29sbGVjdGlvbi53YXRjaChwaXBlbGluZSwgb3B0aW9ucyk7XG4gICAgICAgIGNiKG51bGwsIGRyaXZlckNoYW5nZVN0cmVhbSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZHJpdmVyQ2hhbmdlU3RyZWFtID0gdGhpcy4kX19jb2xsZWN0aW9uLndhdGNoKHBpcGVsaW5lLCBvcHRpb25zKTtcbiAgICAgIGNiKG51bGwsIGRyaXZlckNoYW5nZVN0cmVhbSk7XG4gICAgfVxuICB9O1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLm1vZGVsID0gdGhpcztcblxuICByZXR1cm4gbmV3IENoYW5nZVN0cmVhbShjaGFuZ2VTdHJlYW1UaHVuaywgcGlwZWxpbmUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBfUmVxdWlyZXMgTW9uZ29EQiA+PSAzLjYuMC5fIFN0YXJ0cyBhIFtNb25nb0RCIHNlc3Npb25dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlbGVhc2Utbm90ZXMvMy42LyNjbGllbnQtc2Vzc2lvbnMpXG4gKiBmb3IgYmVuZWZpdHMgbGlrZSBjYXVzYWwgY29uc2lzdGVuY3ksIFtyZXRyeWFibGUgd3JpdGVzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL3JldHJ5YWJsZS13cml0ZXMvKSxcbiAqIGFuZCBbdHJhbnNhY3Rpb25zXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2Etbm9kZS1qcy1wZXJzcGVjdGl2ZS1vbi1tb25nb2RiLTQtdHJhbnNhY3Rpb25zLmh0bWwpLlxuICpcbiAqIENhbGxpbmcgYE15TW9kZWwuc3RhcnRTZXNzaW9uKClgIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBgTXlNb2RlbC5kYi5zdGFydFNlc3Npb24oKWAuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB0cmlnZ2VyIGFueSBtaWRkbGV3YXJlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IFBlcnNvbi5zdGFydFNlc3Npb24oKTtcbiAqICAgICBsZXQgZG9jID0gYXdhaXQgUGVyc29uLmZpbmRPbmUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9LCBudWxsLCB7IHNlc3Npb24gfSk7XG4gKiAgICAgYXdhaXQgZG9jLnJlbW92ZSgpO1xuICogICAgIC8vIGBkb2NgIHdpbGwgYWx3YXlzIGJlIG51bGwsIGV2ZW4gaWYgcmVhZGluZyBmcm9tIGEgcmVwbGljYSBzZXRcbiAqICAgICAvLyBzZWNvbmRhcnkuIFdpdGhvdXQgY2F1c2FsIGNvbnNpc3RlbmN5LCBpdCBpcyBwb3NzaWJsZSB0b1xuICogICAgIC8vIGdldCBhIGRvYyBiYWNrIGZyb20gdGhlIGJlbG93IHF1ZXJ5IGlmIHRoZSBxdWVyeSByZWFkcyBmcm9tIGFcbiAqICAgICAvLyBzZWNvbmRhcnkgdGhhdCBpcyBleHBlcmllbmNpbmcgcmVwbGljYXRpb24gbGFnLlxuICogICAgIGRvYyA9IGF3YWl0IFBlcnNvbi5maW5kT25lKHsgbmFtZTogJ05lZCBTdGFyaycgfSwgbnVsbCwgeyBzZXNzaW9uLCByZWFkUHJlZmVyZW5jZTogJ3NlY29uZGFyeScgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgdGhlIFttb25nb2RiIGRyaXZlciBvcHRpb25zXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvTW9uZ29DbGllbnQuaHRtbCNzdGFydFNlc3Npb24pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNhdXNhbENvbnNpc3RlbmN5PXRydWVdIHNldCB0byBmYWxzZSB0byBkaXNhYmxlIGNhdXNhbCBjb25zaXN0ZW5jeVxuICogQHJldHVybiB7UHJvbWlzZTxDbGllbnRTZXNzaW9uPn0gcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgTW9uZ29EQiBkcml2ZXIgYENsaWVudFNlc3Npb25gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnN0YXJ0U2Vzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdzdGFydFNlc3Npb24nKTtcblxuICByZXR1cm4gdGhpcy5kYi5zdGFydFNlc3Npb24uYXBwbHkodGhpcy5kYiwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgZm9yIHZhbGlkYXRpbmcgYW4gYXJyYXkgb2YgZG9jdW1lbnRzIGFuZCBpbnNlcnRpbmcgdGhlbSBpbnRvXG4gKiBNb25nb0RCIGlmIHRoZXkncmUgYWxsIHZhbGlkLiBUaGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIGAuY3JlYXRlKClgXG4gKiBiZWNhdXNlIGl0IG9ubHkgc2VuZHMgb25lIG9wZXJhdGlvbiB0byB0aGUgc2VydmVyLCByYXRoZXIgdGhhbiBvbmUgZm9yIGVhY2hcbiAqIGRvY3VtZW50LlxuICpcbiAqIE1vbmdvb3NlIGFsd2F5cyB2YWxpZGF0ZXMgZWFjaCBkb2N1bWVudCAqKmJlZm9yZSoqIHNlbmRpbmcgYGluc2VydE1hbnlgXG4gKiB0byBNb25nb0RCLiBTbyBpZiBvbmUgZG9jdW1lbnQgaGFzIGEgdmFsaWRhdGlvbiBlcnJvciwgbm8gZG9jdW1lbnRzIHdpbGxcbiAqIGJlIHNhdmVkLCB1bmxlc3MgeW91IHNldFxuICogW3RoZSBgb3JkZXJlZGAgb3B0aW9uIHRvIGZhbHNlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNvbGxlY3Rpb24uaW5zZXJ0TWFueS8jZXJyb3ItaGFuZGxpbmcpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyAqKm5vdCoqIHRyaWdnZXIgc2F2ZSBtaWRkbGV3YXJlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGluc2VydE1hbnkoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IE1vdmllcy5pbnNlcnRNYW55KFtcbiAqICAgICAgIHsgbmFtZTogJ1N0YXIgV2FycycgfSxcbiAqICAgICAgIHsgbmFtZTogJ1RoZSBFbXBpcmUgU3RyaWtlcyBCYWNrJyB9XG4gKiAgICAgXSk7XG4gKlxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8Kn0gZG9jKHMpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNlZSB0aGUgW21vbmdvZGIgZHJpdmVyIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjaW5zZXJ0TWFueSlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3JkZXJlZD10cnVlXSBpZiB0cnVlLCB3aWxsIGZhaWwgZmFzdCBvbiB0aGUgZmlyc3QgZXJyb3IgZW5jb3VudGVyZWQuIElmIGZhbHNlLCB3aWxsIGluc2VydCBhbGwgdGhlIGRvY3VtZW50cyBpdCBjYW4gYW5kIHJlcG9ydCBlcnJvcnMgbGF0ZXIuIEFuIGBpbnNlcnRNYW55KClgIHdpdGggYG9yZGVyZWQgPSBmYWxzZWAgaXMgY2FsbGVkIGFuIFwidW5vcmRlcmVkXCIgYGluc2VydE1hbnkoKWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJhd1Jlc3VsdD1mYWxzZV0gaWYgZmFsc2UsIHRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHRvIHRoZSBkb2N1bWVudHMgdGhhdCBwYXNzZWQgbW9uZ29vc2UgZG9jdW1lbnQgdmFsaWRhdGlvbi4gSWYgYHRydWVgLCB3aWxsIHJldHVybiB0aGUgW3JhdyByZXN1bHQgZnJvbSB0aGUgTW9uZ29EQiBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9JbnNlcnRNYW55UmVzdWx0Lmh0bWwpIHdpdGggYSBgbW9uZ29vc2VgIHByb3BlcnR5IHRoYXQgY29udGFpbnMgYHZhbGlkYXRpb25FcnJvcnNgIGFuZCBgcmVzdWx0c2AgaWYgdGhpcyBpcyBhbiB1bm9yZGVyZWQgYGluc2VydE1hbnlgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5sZWFuPWZhbHNlXSBpZiBgdHJ1ZWAsIHNraXBzIGh5ZHJhdGluZyB0aGUgZG9jdW1lbnRzLiBUaGlzIG1lYW5zIE1vbmdvb3NlIHdpbGwgKipub3QqKiBjYXN0IG9yIHZhbGlkYXRlIGFueSBvZiB0aGUgZG9jdW1lbnRzIHBhc3NlZCB0byBgaW5zZXJ0TWFueSgpYC4gVGhpcyBvcHRpb24gaXMgdXNlZnVsIGlmIHlvdSBuZWVkIHRoZSBleHRyYSBwZXJmb3JtYW5jZSwgYnV0IGNvbWVzIHdpdGggZGF0YSBpbnRlZ3JpdHkgcmlzay4gQ29uc2lkZXIgdXNpbmcgd2l0aCBbYGNhc3RPYmplY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5jYXN0T2JqZWN0KCkpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbWl0PW51bGxdIHRoaXMgbGltaXRzIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGJlaW5nIHByb2Nlc3NlZCAodmFsaWRhdGlvbi9jYXN0aW5nKSBieSBtb25nb29zZSBpbiBwYXJhbGxlbCwgdGhpcyBkb2VzICoqTk9UKiogc2VuZCB0aGUgZG9jdW1lbnRzIGluIGJhdGNoZXMgdG8gTW9uZ29EQi4gVXNlIHRoaXMgb3B0aW9uIGlmIHlvdSdyZSBwcm9jZXNzaW5nIGEgbGFyZ2UgbnVtYmVyIG9mIGRvY3VtZW50cyBhbmQgeW91ciBhcHAgaXMgcnVubmluZyBvdXQgb2YgbWVtb3J5LlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEFycmF5fSBbb3B0aW9ucy5wb3B1bGF0ZT1udWxsXSBwb3B1bGF0ZXMgdGhlIHJlc3VsdCBkb2N1bWVudHMuIFRoaXMgb3B0aW9uIGlzIGEgbm8tb3AgaWYgYHJhd1Jlc3VsdGAgaXMgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aHJvd09uVmFsaWRhdGlvbkVycm9yPWZhbHNlXSBJZiB0cnVlIGFuZCBgb3JkZXJlZDogZmFsc2VgLCB0aHJvdyBhbiBlcnJvciBpZiBvbmUgb2YgdGhlIG9wZXJhdGlvbnMgZmFpbGVkIHZhbGlkYXRpb24sIGJ1dCBhbGwgdmFsaWQgb3BlcmF0aW9ucyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICogQHJldHVybiB7UHJvbWlzZX0gcmVzb2x2aW5nIHRvIHRoZSByYXcgcmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyIGlmIGBvcHRpb25zLnJhd1Jlc3VsdGAgd2FzIGB0cnVlYCwgb3IgdGhlIGRvY3VtZW50cyB0aGF0IHBhc3NlZCB2YWxpZGF0aW9uLCBvdGhlcndpc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuaW5zZXJ0TWFueSA9IGFzeW5jIGZ1bmN0aW9uIGluc2VydE1hbnkoYXJyLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2luc2VydE1hbnknKTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5pbnNlcnRNYW55KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLiRfX2luc2VydE1hbnkoYXJyLCBvcHRpb25zLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBpZ25vcmVcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBtZXRob2QgJF9faW5zZXJ0TWFueVxuICogQHN0YXRpY1xuICovXG5cbk1vZGVsLiRfX2luc2VydE1hbnkgPSBmdW5jdGlvbihhcnIsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCB1dGlscy5ub29wO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgbGltaXQgPSBvcHRpb25zLmxpbWl0IHx8IDEwMDA7XG4gIGNvbnN0IHJhd1Jlc3VsdCA9ICEhb3B0aW9ucy5yYXdSZXN1bHQ7XG4gIGNvbnN0IG9yZGVyZWQgPSB0eXBlb2Ygb3B0aW9ucy5vcmRlcmVkID09PSAnYm9vbGVhbicgPyBvcHRpb25zLm9yZGVyZWQgOiB0cnVlO1xuICBjb25zdCB0aHJvd09uVmFsaWRhdGlvbkVycm9yID0gdHlwZW9mIG9wdGlvbnMudGhyb3dPblZhbGlkYXRpb25FcnJvciA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy50aHJvd09uVmFsaWRhdGlvbkVycm9yIDogZmFsc2U7XG4gIGNvbnN0IGxlYW4gPSAhIW9wdGlvbnMubGVhbjtcblxuICBjb25zdCBhc3luY0xvY2FsU3RvcmFnZSA9IHRoaXMuZGIuYmFzZS50cmFuc2FjdGlvbkFzeW5jTG9jYWxTdG9yYWdlPy5nZXRTdG9yZSgpO1xuICBpZiAoKCFvcHRpb25zIHx8ICFvcHRpb25zLmhhc093blByb3BlcnR5KCdzZXNzaW9uJykpICYmIGFzeW5jTG9jYWxTdG9yYWdlPy5zZXNzaW9uICE9IG51bGwpIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCBzZXNzaW9uOiBhc3luY0xvY2FsU3RvcmFnZS5zZXNzaW9uIH07XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyciA9IFthcnJdO1xuICB9XG5cbiAgY29uc3QgdmFsaWRhdGlvbkVycm9ycyA9IFtdO1xuICBjb25zdCB2YWxpZGF0aW9uRXJyb3JzVG9PcmlnaW5hbE9yZGVyID0gbmV3IE1hcCgpO1xuICBjb25zdCByZXN1bHRzID0gb3JkZXJlZCA/IG51bGwgOiBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGNvbnN0IHRvRXhlY3V0ZSA9IGFyci5tYXAoKGRvYywgaW5kZXgpID0+XG4gICAgY2FsbGJhY2sgPT4ge1xuICAgICAgLy8gSWYgb3B0aW9uIGBsZWFuYCBpcyBzZXQgdG8gdHJ1ZSBieXBhc3MgdmFsaWRhdGlvbiBhbmQgaHlkcmF0aW9uXG4gICAgICBpZiAobGVhbikge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIGV4ZWN1dGUgY2FsbGJhY2sgYXQgdGhlIG5leHRUaWNrIHRvIGJlIGNvbXBhdGlibGVcbiAgICAgICAgLy8gd2l0aCBwYXJhbGxlbExpbWl0LCBhcyBgcmVzdWx0c2AgdmFyaWFibGUgaGFzIFREWiBpc3N1ZSBpZiB3ZVxuICAgICAgICAvLyBleGVjdXRlIHRoZSBjYWxsYmFjayBzeW5jaHJvbm91c2x5XG4gICAgICAgIHJldHVybiBpbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgZG9jKSk7XG4gICAgICB9XG4gICAgICBpZiAoIShkb2MgaW5zdGFuY2VvZiBfdGhpcykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkb2MgPSBuZXcgX3RoaXMoZG9jKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICBkb2MuJHNlc3Npb24ob3B0aW9ucy5zZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG9wdGlvbiBgbGVhbmAgaXMgc2V0IHRvIHRydWUgYnlwYXNzIHZhbGlkYXRpb25cbiAgICAgIGlmIChsZWFuKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gZXhlY3V0ZSBjYWxsYmFjayBhdCB0aGUgbmV4dFRpY2sgdG8gYmUgY29tcGF0aWJsZVxuICAgICAgICAvLyB3aXRoIHBhcmFsbGVsTGltaXQsIGFzIGByZXN1bHRzYCB2YXJpYWJsZSBoYXMgVERaIGlzc3VlIGlmIHdlXG4gICAgICAgIC8vIGV4ZWN1dGUgdGhlIGNhbGxiYWNrIHN5bmNocm9ub3VzbHlcbiAgICAgICAgcmV0dXJuIGltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhudWxsLCBkb2MpKTtcbiAgICAgIH1cbiAgICAgIGRvYy4kdmFsaWRhdGUoKS50aGVuKFxuICAgICAgICAoKSA9PiB7IGNhbGxiYWNrKG51bGwsIGRvYyk7IH0sXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICBpZiAob3JkZXJlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzVG9PcmlnaW5hbE9yZGVyLnNldChlcnJvciwgaW5kZXgpO1xuICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBlcnJvcjtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gIHBhcmFsbGVsTGltaXQodG9FeGVjdXRlLCBsaW1pdCwgZnVuY3Rpb24oZXJyb3IsIGRvY3MpIHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcmlnaW5hbERvY0luZGV4ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHZhbGlkRG9jSW5kZXhUb09yaWdpbmFsSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb2NzLmxlbmd0aDsgKytpKSB7XG4gICAgICBvcmlnaW5hbERvY0luZGV4LnNldChkb2NzW2ldLCBpKTtcbiAgICB9XG5cbiAgICAvLyBXZSBmaWx0ZXIgYWxsIGZhaWxlZCBwcmUtdmFsaWRhdGlvbnMgYnkgcmVtb3ZpbmcgbnVsbHNcbiAgICBjb25zdCBkb2NBdHRyaWJ1dGVzID0gZG9jcy5maWx0ZXIoZnVuY3Rpb24oZG9jKSB7XG4gICAgICByZXR1cm4gZG9jICE9IG51bGw7XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb2NBdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YWxpZERvY0luZGV4VG9PcmlnaW5hbEluZGV4LnNldChpLCBvcmlnaW5hbERvY0luZGV4LmdldChkb2NBdHRyaWJ1dGVzW2ldKSk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHZhbGlkYXRpb24gZXJyb3JzIGFyZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbiAgICAvLyBvcmlnaW5hbCBkb2N1bWVudHMsIHNvIGlmIGJvdGggZG9jMSBhbmQgZG9jMiBib3RoIGZhaWwgdmFsaWRhdGlvbixcbiAgICAvLyBgTW9kZWwuaW5zZXJ0TWFueShbZG9jMSwgZG9jMl0pYCB3aWxsIGFsd2F5cyBoYXZlIGRvYzEncyB2YWxpZGF0aW9uXG4gICAgLy8gZXJyb3IgYmVmb3JlIGRvYzIncy4gUmU6IGdoLTEyNzkxLlxuICAgIGlmICh2YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhbGlkYXRpb25FcnJvcnMuc29ydCgoZXJyMSwgZXJyMikgPT4ge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGlvbkVycm9yc1RvT3JpZ2luYWxPcmRlci5nZXQoZXJyMSkgLSB2YWxpZGF0aW9uRXJyb3JzVG9PcmlnaW5hbE9yZGVyLmdldChlcnIyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFF1aWNrbHkgZXNjYXBlIHdoaWxlIHRoZXJlIGFyZW4ndCBhbnkgdmFsaWQgZG9jQXR0cmlidXRlc1xuICAgIGlmIChkb2NBdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRocm93T25WYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBNb25nb29zZUJ1bGtXcml0ZUVycm9yKFxuICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnMsXG4gICAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgICdpbnNlcnRNYW55J1xuICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIGlmIChyYXdSZXN1bHQpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgIGFja25vd2xlZGdlZDogdHJ1ZSxcbiAgICAgICAgICBpbnNlcnRlZENvdW50OiAwLFxuICAgICAgICAgIGluc2VydGVkSWRzOiB7fSxcbiAgICAgICAgICBtb25nb29zZToge1xuICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yczogdmFsaWRhdGlvbkVycm9yc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRvY09iamVjdHMgPSBsZWFuID8gZG9jQXR0cmlidXRlcyA6IGRvY0F0dHJpYnV0ZXMubWFwKGZ1bmN0aW9uKGRvYykge1xuICAgICAgaWYgKGRvYy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5KSB7XG4gICAgICAgIGRvY1tkb2MuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleV0gPSAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvdWxkU2V0VGltZXN0YW1wcyA9ICghb3B0aW9ucyB8fCBvcHRpb25zLnRpbWVzdGFtcHMgIT09IGZhbHNlKSAmJiBkb2MuaW5pdGlhbGl6ZVRpbWVzdGFtcHMgJiYgKCFkb2MuJF9fIHx8IGRvYy4kX18udGltZXN0YW1wcyAhPT0gZmFsc2UpO1xuICAgICAgaWYgKHNob3VsZFNldFRpbWVzdGFtcHMpIHtcbiAgICAgICAgcmV0dXJuIGRvYy5pbml0aWFsaXplVGltZXN0YW1wcygpLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb2MudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMuJF9fY29sbGVjdGlvbi5pbnNlcnRNYW55KGRvY09iamVjdHMsIG9wdGlvbnMpLnRoZW4oXG4gICAgICByZXMgPT4ge1xuICAgICAgICBpZiAoIWxlYW4pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBkb2NBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUuJF9fcmVzZXQoKTtcbiAgICAgICAgICAgIF9zZXRJc05ldyhhdHRyaWJ1dGUsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3JkZXJlZCA9PT0gZmFsc2UgJiYgdGhyb3dPblZhbGlkYXRpb25FcnJvciAmJiB2YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGRvY3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgTW9uZ29vc2VCdWxrV3JpdGVFcnJvcihcbiAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnMsXG4gICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgcmVzLFxuICAgICAgICAgICAgJ2luc2VydE1hbnknXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmF3UmVzdWx0KSB7XG4gICAgICAgICAgaWYgKG9yZGVyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBkb2NzW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlY29yYXRlIHdpdGggbW9uZ29vc2UgdmFsaWRhdGlvbiBlcnJvcnMgaW4gY2FzZSBvZiB1bm9yZGVyZWQsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZW4gc3RpbGwgZG8gYGluc2VydE1hbnkoKWBcbiAgICAgICAgICAgIHJlcy5tb25nb29zZSA9IHtcbiAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yczogdmFsaWRhdGlvbkVycm9ycyxcbiAgICAgICAgICAgICAgcmVzdWx0czogcmVzdWx0c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wb3B1bGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnBvcHVsYXRlKGRvY0F0dHJpYnV0ZXMsIG9wdGlvbnMucG9wdWxhdGUpLnRoZW4oXG4gICAgICAgICAgICBkb2NzID0+IHsgY2FsbGJhY2sobnVsbCwgZG9jcyk7IH0sXG4gICAgICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlcnIuaW5zZXJ0ZWREb2NzID0gZG9jQXR0cmlidXRlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRvY0F0dHJpYnV0ZXMpO1xuICAgICAgfSxcbiAgICAgIGVycm9yID0+IHtcbiAgICAgICAgLy8gYHdyaXRlRXJyb3JzYCBpcyBhIHByb3BlcnR5IHJlcG9ydGVkIGJ5IHRoZSBNb25nb0RCIGRyaXZlcixcbiAgICAgICAgLy8ganVzdCBub3QgaWYgdGhlcmUncyBvbmx5IDEgZXJyb3IuXG4gICAgICAgIGlmIChlcnJvci53cml0ZUVycm9ycyA9PSBudWxsICYmXG4gICAgICAgICAgICAoZXJyb3IucmVzdWx0ICYmIGVycm9yLnJlc3VsdC5yZXN1bHQgJiYgZXJyb3IucmVzdWx0LnJlc3VsdC53cml0ZUVycm9ycykgIT0gbnVsbCkge1xuICAgICAgICAgIGVycm9yLndyaXRlRXJyb3JzID0gZXJyb3IucmVzdWx0LnJlc3VsdC53cml0ZUVycm9ycztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGBpbnNlcnRlZERvY3NgIGlzIGEgTW9uZ29vc2Utc3BlY2lmaWMgcHJvcGVydHlcbiAgICAgICAgY29uc3QgaGFzV3JpdGVFcnJvcnMgPSBlcnJvciAmJiBlcnJvci53cml0ZUVycm9ycztcbiAgICAgICAgY29uc3QgZXJyb3JlZEluZGV4ZXMgPSBuZXcgU2V0KChlcnJvciAmJiBlcnJvci53cml0ZUVycm9ycyB8fCBbXSkubWFwKGVyciA9PiBlcnIuaW5kZXgpKTtcblxuICAgICAgICBpZiAoZXJyb3Iud3JpdGVFcnJvcnMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3Iud3JpdGVFcnJvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSW5kZXggPSB2YWxpZERvY0luZGV4VG9PcmlnaW5hbEluZGV4LmdldChlcnJvci53cml0ZUVycm9yc1tpXS5pbmRleCk7XG4gICAgICAgICAgICBlcnJvci53cml0ZUVycm9yc1tpXSA9IHtcbiAgICAgICAgICAgICAgLi4uZXJyb3Iud3JpdGVFcnJvcnNbaV0sXG4gICAgICAgICAgICAgIGluZGV4OiBvcmlnaW5hbEluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFvcmRlcmVkKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHNbb3JpZ2luYWxJbmRleF0gPSBlcnJvci53cml0ZUVycm9yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9yZGVyZWQpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGRvY3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IucmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmlyc3RFcnJvcmVkSW5kZXggPSAtMTtcbiAgICAgICAgZXJyb3IuaW5zZXJ0ZWREb2NzID0gZG9jQXR0cmlidXRlcy5cbiAgICAgICAgICBmaWx0ZXIoKGRvYywgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNFcnJvcmVkID0gIWhhc1dyaXRlRXJyb3JzIHx8IGVycm9yZWRJbmRleGVzLmhhcyhpKTtcblxuICAgICAgICAgICAgaWYgKG9yZGVyZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3JlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IGZpcnN0RXJyb3JlZEluZGV4O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGlzRXJyb3JlZCkge1xuICAgICAgICAgICAgICAgIGZpcnN0RXJyb3JlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gIWlzRXJyb3JlZDtcbiAgICAgICAgICB9KS5cbiAgICAgICAgICBtYXAoZnVuY3Rpb24gc2V0SXNOZXdGb3JJbnNlcnRlZERvYyhkb2MpIHtcbiAgICAgICAgICAgIGlmIChsZWFuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2MuJF9fcmVzZXQoKTtcbiAgICAgICAgICAgIF9zZXRJc05ldyhkb2MsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJhd1Jlc3VsdCAmJiBvcmRlcmVkID09PSBmYWxzZSkge1xuICAgICAgICAgIGVycm9yLm1vbmdvb3NlID0ge1xuICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yczogdmFsaWRhdGlvbkVycm9ycyxcbiAgICAgICAgICAgIHJlc3VsdHM6IHJlc3VsdHNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgfVxuICAgICk7XG4gIH0pO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfc2V0SXNOZXcoZG9jLCB2YWwpIHtcbiAgZG9jLiRpc05ldyA9IHZhbDtcbiAgZG9jLiRlbWl0KCdpc05ldycsIHZhbCk7XG4gIGRvYy5jb25zdHJ1Y3Rvci5lbWl0KCdpc05ldycsIHZhbCk7XG5cbiAgY29uc3Qgc3ViZG9jcyA9IGRvYy4kZ2V0QWxsU3ViZG9jcygpO1xuICBmb3IgKGNvbnN0IHN1YmRvYyBvZiBzdWJkb2NzKSB7XG4gICAgc3ViZG9jLiRpc05ldyA9IHZhbDtcbiAgICBzdWJkb2MuJGVtaXQoJ2lzTmV3JywgdmFsKTtcbiAgfVxufVxuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIGBpbnNlcnRPbmVgLCBgdXBkYXRlT25lYCwgYHVwZGF0ZU1hbnlgLCBgcmVwbGFjZU9uZWAsXG4gKiBgZGVsZXRlT25lYCwgYW5kL29yIGBkZWxldGVNYW55YCBvcGVyYXRpb25zIHRvIHRoZSBNb25nb0RCIHNlcnZlciBpbiBvbmVcbiAqIGNvbW1hbmQuIFRoaXMgaXMgZmFzdGVyIHRoYW4gc2VuZGluZyBtdWx0aXBsZSBpbmRlcGVuZGVudCBvcGVyYXRpb25zIChlLmcuXG4gKiBpZiB5b3UgdXNlIGBjcmVhdGUoKWApIGJlY2F1c2Ugd2l0aCBgYnVsa1dyaXRlKClgIHRoZXJlIGlzIG9ubHkgb25lIHJvdW5kXG4gKiB0cmlwIHRvIE1vbmdvREIuXG4gKlxuICogTW9uZ29vc2Ugd2lsbCBwZXJmb3JtIGNhc3Rpbmcgb24gYWxsIG9wZXJhdGlvbnMgeW91IHByb3ZpZGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzICoqbm90KiogdHJpZ2dlciBhbnkgbWlkZGxld2FyZSwgbmVpdGhlciBgc2F2ZSgpYCwgbm9yIGB1cGRhdGUoKWAuXG4gKiBJZiB5b3UgbmVlZCB0byB0cmlnZ2VyXG4gKiBgc2F2ZSgpYCBtaWRkbGV3YXJlIGZvciBldmVyeSBkb2N1bWVudCB1c2UgW2BjcmVhdGUoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5jcmVhdGUoKSkgaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIENoYXJhY3Rlci5idWxrV3JpdGUoW1xuICogICAgICAge1xuICogICAgICAgICBpbnNlcnRPbmU6IHtcbiAqICAgICAgICAgICBkb2N1bWVudDoge1xuICogICAgICAgICAgICAgbmFtZTogJ0VkZGFyZCBTdGFyaycsXG4gKiAgICAgICAgICAgICB0aXRsZTogJ1dhcmRlbiBvZiB0aGUgTm9ydGgnXG4gKiAgICAgICAgICAgfVxuICogICAgICAgICB9XG4gKiAgICAgICB9LFxuICogICAgICAge1xuICogICAgICAgICB1cGRhdGVPbmU6IHtcbiAqICAgICAgICAgICBmaWx0ZXI6IHsgbmFtZTogJ0VkZGFyZCBTdGFyaycgfSxcbiAqICAgICAgICAgICAvLyBJZiB5b3Ugd2VyZSB1c2luZyB0aGUgTW9uZ29EQiBkcml2ZXIgZGlyZWN0bHksIHlvdSdkIG5lZWQgdG8gZG9cbiAqICAgICAgICAgICAvLyBgdXBkYXRlOiB7ICRzZXQ6IHsgdGl0bGU6IC4uLiB9IH1gIGJ1dCBtb25nb29zZSBhZGRzICRzZXQgZm9yXG4gKiAgICAgICAgICAgLy8geW91LlxuICogICAgICAgICAgIHVwZGF0ZTogeyB0aXRsZTogJ0hhbmQgb2YgdGhlIEtpbmcnIH1cbiAqICAgICAgICAgfVxuICogICAgICAgfSxcbiAqICAgICAgIHtcbiAqICAgICAgICAgZGVsZXRlT25lOiB7XG4gKiAgICAgICAgICAgZmlsdGVyOiB7IG5hbWU6ICdFZGRhcmQgU3RhcmsnIH1cbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIF0pLnRoZW4ocmVzID0+IHtcbiAqICAgICAgLy8gUHJpbnRzIFwiMSAxIDFcIlxuICogICAgICBjb25zb2xlLmxvZyhyZXMuaW5zZXJ0ZWRDb3VudCwgcmVzLm1vZGlmaWVkQ291bnQsIHJlcy5kZWxldGVkQ291bnQpO1xuICogICAgIH0pO1xuICpcbiAqIFRoZSBbc3VwcG9ydGVkIG9wZXJhdGlvbnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5idWxrV3JpdGUvI2RiLmNvbGxlY3Rpb24uYnVsa1dyaXRlKSBhcmU6XG4gKlxuICogLSBgaW5zZXJ0T25lYFxuICogLSBgdXBkYXRlT25lYFxuICogLSBgdXBkYXRlTWFueWBcbiAqIC0gYGRlbGV0ZU9uZWBcbiAqIC0gYGRlbGV0ZU1hbnlgXG4gKiAtIGByZXBsYWNlT25lYFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG9wc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHMuaW5zZXJ0T25lLmRvY3VtZW50XSBUaGUgZG9jdW1lbnQgdG8gaW5zZXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy51cGRhdGVPbmUuZmlsdGVyXSBVcGRhdGUgdGhlIGZpcnN0IGRvY3VtZW50IHRoYXQgbWF0Y2hlcyB0aGlzIGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMudXBkYXRlT25lLnVwZGF0ZV0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgW3VwZGF0ZSBvcGVyYXRvcnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci91cGRhdGUvKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3BzLnVwZGF0ZU9uZS51cHNlcnQ9ZmFsc2VdIElmIHRydWUsIGluc2VydCBhIGRvYyBpZiBub25lIG1hdGNoXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHMudXBkYXRlT25lLnRpbWVzdGFtcHM9dHJ1ZV0gSWYgZmFsc2UsIGRvIG5vdCBhcHBseSBbdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgdG8gdGhlIG9wZXJhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMudXBkYXRlT25lLmNvbGxhdGlvbl0gVGhlIFtNb25nb0RCIGNvbGxhdGlvbl0oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGVqcy1wZXJzcGVjdGl2ZS1vbi1tb25nb2RiLTM0LWNvbGxhdGlvbnMpIHRvIHVzZVxuICogQHBhcmFtIHtBcnJheX0gW29wcy51cGRhdGVPbmUuYXJyYXlGaWx0ZXJzXSBUaGUgW2FycmF5IGZpbHRlcnNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vYS1ub2RlanMtcGVyc3BlY3RpdmUtb24tbW9uZ29kYi0zNi1hcnJheS1maWx0ZXJzLmh0bWwpIHVzZWQgaW4gYHVwZGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLnVwZGF0ZU1hbnkuZmlsdGVyXSBVcGRhdGUgYWxsIHRoZSBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGlzIGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMudXBkYXRlTWFueS51cGRhdGVdIEFuIG9iamVjdCBjb250YWluaW5nIFt1cGRhdGUgb3BlcmF0b3JzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlLylcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wcy51cGRhdGVNYW55LnVwc2VydD1mYWxzZV0gSWYgdHJ1ZSwgaW5zZXJ0IGEgZG9jIGlmIG5vIGRvY3VtZW50cyBtYXRjaCBgZmlsdGVyYFxuICogQHBhcmFtIHtCb29sZWFufSBbb3BzLnVwZGF0ZU1hbnkudGltZXN0YW1wcz10cnVlXSBJZiBmYWxzZSwgZG8gbm90IGFwcGx5IFt0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSB0byB0aGUgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy51cGRhdGVNYW55LmNvbGxhdGlvbl0gVGhlIFtNb25nb0RCIGNvbGxhdGlvbl0oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGVqcy1wZXJzcGVjdGl2ZS1vbi1tb25nb2RiLTM0LWNvbGxhdGlvbnMpIHRvIHVzZVxuICogQHBhcmFtIHtBcnJheX0gW29wcy51cGRhdGVNYW55LmFycmF5RmlsdGVyc10gVGhlIFthcnJheSBmaWx0ZXJzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2Etbm9kZWpzLXBlcnNwZWN0aXZlLW9uLW1vbmdvZGItMzYtYXJyYXktZmlsdGVycy5odG1sKSB1c2VkIGluIGB1cGRhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy5kZWxldGVPbmUuZmlsdGVyXSBEZWxldGUgdGhlIGZpcnN0IGRvY3VtZW50IHRoYXQgbWF0Y2hlcyB0aGlzIGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMuZGVsZXRlTWFueS5maWx0ZXJdIERlbGV0ZSBhbGwgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhpcyBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLnJlcGxhY2VPbmUuZmlsdGVyXSBSZXBsYWNlIHRoZSBmaXJzdCBkb2N1bWVudCB0aGF0IG1hdGNoZXMgdGhpcyBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLnJlcGxhY2VPbmUucmVwbGFjZW1lbnRdIFRoZSByZXBsYWNlbWVudCBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3BzLnJlcGxhY2VPbmUudXBzZXJ0PWZhbHNlXSBJZiB0cnVlLCBpbnNlcnQgYSBkb2MgaWYgbm8gZG9jdW1lbnRzIG1hdGNoIGBmaWx0ZXJgXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9yZGVyZWQ9dHJ1ZV0gSWYgdHJ1ZSwgZXhlY3V0ZSB3cml0ZXMgaW4gb3JkZXIgYW5kIHN0b3AgYXQgdGhlIGZpcnN0IGVycm9yLiBJZiBmYWxzZSwgZXhlY3V0ZSB3cml0ZXMgaW4gcGFyYWxsZWwgYW5kIGNvbnRpbnVlIHVudGlsIGFsbCB3cml0ZXMgaGF2ZSBlaXRoZXIgc3VjY2VlZGVkIG9yIGVycm9yZWQuXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgYnVsayB3cml0ZS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7U3RyaW5nfG51bWJlcn0gW29wdGlvbnMudz0xXSBUaGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykuIFNlZSBbYFF1ZXJ5I3coKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUudygpKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53dGltZW91dD1udWxsXSBUaGUgW3dyaXRlIGNvbmNlcm4gdGltZW91dF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3d0aW1lb3V0KS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaj10cnVlXSBJZiBmYWxzZSwgZGlzYWJsZSBbam91cm5hbCBhY2tub3dsZWRnZW1lbnRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyNqLW9wdGlvbilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFZhbGlkYXRpb249ZmFsc2VdIFNldCB0byB0cnVlIHRvIHNraXAgTW9uZ29vc2Ugc2NoZW1hIHZhbGlkYXRpb24gb24gYnVsayB3cml0ZSBvcGVyYXRpb25zLiBNb25nb29zZSBjdXJyZW50bHkgcnVucyB2YWxpZGF0aW9uIG9uIGBpbnNlcnRPbmVgIGFuZCBgcmVwbGFjZU9uZWAgb3BlcmF0aW9ucyBieSBkZWZhdWx0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ieXBhc3NEb2N1bWVudFZhbGlkYXRpb249ZmFsc2VdIElmIHRydWUsIGRpc2FibGUgW01vbmdvREIgc2VydmVyLXNpZGUgc2NoZW1hIHZhbGlkYXRpb25dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvc2NoZW1hLXZhbGlkYXRpb24vKSBmb3IgYWxsIHdyaXRlcyBpbiB0aGlzIGJ1bGsuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRocm93T25WYWxpZGF0aW9uRXJyb3I9ZmFsc2VdIElmIHRydWUgYW5kIGBvcmRlcmVkOiBmYWxzZWAsIHRocm93IGFuIGVycm9yIGlmIG9uZSBvZiB0aGUgb3BlcmF0aW9ucyBmYWlsZWQgdmFsaWRhdGlvbiwgYnV0IGFsbCB2YWxpZCBvcGVyYXRpb25zIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0cmljdD1udWxsXSBPdmVyd3JpdGVzIHRoZSBbYHN0cmljdGAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpIG9uIHNjaGVtYS4gSWYgZmFsc2UsIGFsbG93cyBmaWx0ZXJpbmcgYW5kIHdyaXRpbmcgZmllbGRzIG5vdCBkZWZpbmVkIGluIHRoZSBzY2hlbWEgZm9yIGFsbCB3cml0ZXMgaW4gdGhpcyBidWxrLlxuICogQHJldHVybiB7UHJvbWlzZX0gcmVzb2x2ZXMgdG8gYSBbYEJ1bGtXcml0ZU9wUmVzdWx0YF0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0J1bGtXcml0ZVJlc3VsdC5odG1sKSBpZiB0aGUgb3BlcmF0aW9uIHN1Y2NlZWRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmJ1bGtXcml0ZSA9IGFzeW5jIGZ1bmN0aW9uIGJ1bGtXcml0ZShvcHMsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnYnVsa1dyaXRlJyk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmJ1bGtXcml0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgb3JkZXJlZCA9IG9wdGlvbnMub3JkZXJlZCA9PSBudWxsID8gdHJ1ZSA6IG9wdGlvbnMub3JkZXJlZDtcblxuICBjb25zdCB2YWxpZGF0aW9ucyA9IG9wcy5tYXAob3AgPT4gY2FzdEJ1bGtXcml0ZSh0aGlzLCBvcCwgb3B0aW9ucykpO1xuICBjb25zdCBhc3luY0xvY2FsU3RvcmFnZSA9IHRoaXMuZGIuYmFzZS50cmFuc2FjdGlvbkFzeW5jTG9jYWxTdG9yYWdlPy5nZXRTdG9yZSgpO1xuICBpZiAoKCFvcHRpb25zIHx8ICFvcHRpb25zLmhhc093blByb3BlcnR5KCdzZXNzaW9uJykpICYmIGFzeW5jTG9jYWxTdG9yYWdlPy5zZXNzaW9uICE9IG51bGwpIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCBzZXNzaW9uOiBhc3luY0xvY2FsU3RvcmFnZS5zZXNzaW9uIH07XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChvcmRlcmVkKSB7XG4gICAgICBlYWNoKHZhbGlkYXRpb25zLCAoZm4sIGNiKSA9PiBmbihjYiksIGVycm9yID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGdldERlZmF1bHRCdWxrd3JpdGVSZXN1bHQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuJF9fY29sbGVjdGlvbi5idWxrV3JpdGUob3BzLCBvcHRpb25zLCAoZXJyb3IsIHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcmVtYWluaW5nID0gdmFsaWRhdGlvbnMubGVuZ3RoO1xuICAgIGxldCB2YWxpZE9wcyA9IFtdO1xuICAgIGxldCB2YWxpZGF0aW9uRXJyb3JzID0gW107XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIGNvbXBsZXRlVW5vcmRlcmVkVmFsaWRhdGlvbi5jYWxsKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkYXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhbGlkYXRpb25zW2ldKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbGlkT3BzLnB1c2goaSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnMucHVzaCh7IGluZGV4OiBpLCBlcnJvcjogZXJyIH0pO1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKC0tcmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgIGNvbXBsZXRlVW5vcmRlcmVkVmFsaWRhdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRpb25FcnJvcnMuXG4gICAgICBzb3J0KCh2MSwgdjIpID0+IHYxLmluZGV4IC0gdjIuaW5kZXgpLlxuICAgICAgbWFwKHYgPT4gdi5lcnJvcik7XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVVub3JkZXJlZFZhbGlkYXRpb24oKSB7XG4gICAgICBjb25zdCB2YWxpZE9wSW5kZXhlcyA9IHZhbGlkT3BzO1xuICAgICAgdmFsaWRPcHMgPSB2YWxpZE9wcy5zb3J0KCkubWFwKGluZGV4ID0+IG9wc1tpbmRleF0pO1xuXG4gICAgICBpZiAodmFsaWRPcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnRocm93T25WYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzID0gdmFsaWRhdGlvbkVycm9ycy5cbiAgICAgICAgICAgIHNvcnQoKHYxLCB2MikgPT4gdjEuaW5kZXggLSB2Mi5pbmRleCkuXG4gICAgICAgICAgICBtYXAodiA9PiB2LmVycm9yKTtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBNb25nb29zZUJ1bGtXcml0ZUVycm9yKFxuICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9ycyxcbiAgICAgICAgICAgIHJlc3VsdHMsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgJ2J1bGtXcml0ZSdcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShnZXREZWZhdWx0QnVsa3dyaXRlUmVzdWx0KCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRfX2NvbGxlY3Rpb24uYnVsa1dyaXRlKHZhbGlkT3BzLCBvcHRpb25zLCAoZXJyb3IsIHJlcykgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlcnJvci5tb25nb29zZSA9IGVycm9yLm1vbmdvb3NlIHx8IHt9O1xuICAgICAgICAgICAgZXJyb3IubW9uZ29vc2UudmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRpb25FcnJvcnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkT3BJbmRleGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcmVzdWx0c1t2YWxpZE9wSW5kZXhlc1tpXV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy50aHJvd09uVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBNb25nb29zZUJ1bGtXcml0ZUVycm9yKFxuICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLFxuICAgICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgICByZXMsXG4gICAgICAgICAgICAgICdidWxrV3JpdGUnXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLm1vbmdvb3NlID0gcmVzLm1vbmdvb3NlIHx8IHt9O1xuICAgICAgICAgICAgcmVzLm1vbmdvb3NlLnZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0aW9uRXJyb3JzO1xuICAgICAgICAgICAgcmVzLm1vbmdvb3NlLnJlc3VsdHMgPSByZXN1bHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqICB0YWtlcyBhbiBhcnJheSBvZiBkb2N1bWVudHMsIGdldHMgdGhlIGNoYW5nZXMgYW5kIGluc2VydHMvdXBkYXRlcyBkb2N1bWVudHMgaW4gdGhlIGRhdGFiYXNlXG4gKiAgYWNjb3JkaW5nIHRvIHdoZXRoZXIgb3Igbm90IHRoZSBkb2N1bWVudCBpcyBuZXcsIG9yIHdoZXRoZXIgaXQgaGFzIGNoYW5nZXMgb3Igbm90LlxuICpcbiAqIGBidWxrU2F2ZWAgdXNlcyBgYnVsa1dyaXRlYCB1bmRlciB0aGUgaG9vZCwgc28gaXQncyBtb3N0bHkgdXNlZnVsIHdoZW4gZGVhbGluZyB3aXRoIG1hbnkgZG9jdW1lbnRzICgxMEsrKVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8RG9jdW1lbnQ+fSBkb2N1bWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHVuZGVybHlpbmcgYGJ1bGtXcml0ZSgpYFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzXSBkZWZhdWx0cyB0byBgbnVsbGAsIHdoZW4gc2V0IHRvIGZhbHNlLCBtb25nb29zZSB3aWxsIG5vdCBhZGQvdXBkYXRlIHRpbWVzdGFtcHMgdG8gdGhlIGRvY3VtZW50cy5cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBidWxrIHdyaXRlLiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtTdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy53PTFdIFRoZSBbd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vKS4gU2VlIFtgUXVlcnkjdygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS53KCkpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnd0aW1lb3V0PW51bGxdIFRoZSBbd3JpdGUgY29uY2VybiB0aW1lb3V0XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jd3RpbWVvdXQpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5qPXRydWVdIElmIGZhbHNlLCBkaXNhYmxlIFtqb3VybmFsIGFja25vd2xlZGdlbWVudF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI2otb3B0aW9uKVxuICpcbiAqL1xuTW9kZWwuYnVsa1NhdmUgPSBhc3luYyBmdW5jdGlvbiBidWxrU2F2ZShkb2N1bWVudHMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKG9wdGlvbnMudGltZXN0YW1wcyAhPSBudWxsKSB7XG4gICAgZm9yIChjb25zdCBkb2N1bWVudCBvZiBkb2N1bWVudHMpIHtcbiAgICAgIGRvY3VtZW50LiRfXy5zYXZlT3B0aW9ucyA9IGRvY3VtZW50LiRfXy5zYXZlT3B0aW9ucyB8fCB7fTtcbiAgICAgIGRvY3VtZW50LiRfXy5zYXZlT3B0aW9ucy50aW1lc3RhbXBzID0gb3B0aW9ucy50aW1lc3RhbXBzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGRvY3VtZW50IG9mIGRvY3VtZW50cykge1xuICAgICAgaWYgKGRvY3VtZW50LiRfXy50aW1lc3RhbXBzICE9IG51bGwpIHtcbiAgICAgICAgZG9jdW1lbnQuJF9fLnNhdmVPcHRpb25zID0gZG9jdW1lbnQuJF9fLnNhdmVPcHRpb25zIHx8IHt9O1xuICAgICAgICBkb2N1bWVudC4kX18uc2F2ZU9wdGlvbnMudGltZXN0YW1wcyA9IGRvY3VtZW50LiRfXy50aW1lc3RhbXBzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGF3YWl0IFByb21pc2UuYWxsKGRvY3VtZW50cy5tYXAoYnVpbGRQcmVTYXZlUHJvbWlzZSkpO1xuXG4gIGNvbnN0IHdyaXRlT3BlcmF0aW9ucyA9IHRoaXMuYnVpbGRCdWxrV3JpdGVPcGVyYXRpb25zKGRvY3VtZW50cywgeyBza2lwVmFsaWRhdGlvbjogdHJ1ZSwgdGltZXN0YW1wczogb3B0aW9ucy50aW1lc3RhbXBzIH0pO1xuXG4gIGNvbnN0IHsgYnVsa1dyaXRlUmVzdWx0LCBidWxrV3JpdGVFcnJvciB9ID0gYXdhaXQgdGhpcy5idWxrV3JpdGUod3JpdGVPcGVyYXRpb25zLCBvcHRpb25zKS50aGVuKFxuICAgIChyZXMpID0+ICh7IGJ1bGtXcml0ZVJlc3VsdDogcmVzLCBidWxrV3JpdGVFcnJvcjogbnVsbCB9KSxcbiAgICAoZXJyKSA9PiAoeyBidWxrV3JpdGVSZXN1bHQ6IG51bGwsIGJ1bGtXcml0ZUVycm9yOiBlcnIgfSlcbiAgKTtcblxuICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBkb2N1bWVudHMubWFwKGFzeW5jKGRvY3VtZW50KSA9PiB7XG4gICAgICBjb25zdCBkb2N1bWVudEVycm9yID0gYnVsa1dyaXRlRXJyb3IgJiYgYnVsa1dyaXRlRXJyb3Iud3JpdGVFcnJvcnMuZmluZCh3cml0ZUVycm9yID0+IHtcbiAgICAgICAgY29uc3Qgd3JpdGVFcnJvckRvY3VtZW50SWQgPSB3cml0ZUVycm9yLmVyci5vcC5faWQgfHwgd3JpdGVFcnJvci5lcnIub3AucS5faWQ7XG4gICAgICAgIHJldHVybiB3cml0ZUVycm9yRG9jdW1lbnRJZC50b1N0cmluZygpID09PSBkb2N1bWVudC5faWQudG9TdHJpbmcoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZG9jdW1lbnRFcnJvciA9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZVN1Y2Nlc3NmdWxXcml0ZShkb2N1bWVudCk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcblxuICBpZiAoYnVsa1dyaXRlRXJyb3IgJiYgYnVsa1dyaXRlRXJyb3Iud3JpdGVFcnJvcnMgJiYgYnVsa1dyaXRlRXJyb3Iud3JpdGVFcnJvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgYnVsa1dyaXRlRXJyb3I7XG4gIH1cblxuICByZXR1cm4gYnVsa1dyaXRlUmVzdWx0O1xufTtcblxuZnVuY3Rpb24gYnVpbGRQcmVTYXZlUHJvbWlzZShkb2N1bWVudCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGRvY3VtZW50LnNjaGVtYS5zLmhvb2tzLmV4ZWNQcmUoJ3NhdmUnLCBkb2N1bWVudCwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU3VjY2Vzc2Z1bFdyaXRlKGRvY3VtZW50KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKGRvY3VtZW50LiRpc05ldykge1xuICAgICAgX3NldElzTmV3KGRvY3VtZW50LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuJF9fcmVzZXQoKTtcbiAgICBkb2N1bWVudC5zY2hlbWEucy5ob29rcy5leGVjUG9zdCgnc2F2ZScsIGRvY3VtZW50LCBbZG9jdW1lbnRdLCB7fSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuXG4gIH0pO1xufVxuXG4vKipcbiAqIEFwcGx5IGRlZmF1bHRzIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBvciBQT0pPLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fERvY3VtZW50fSBvYmogb2JqZWN0IG9yIGRvY3VtZW50IHRvIGFwcGx5IGRlZmF1bHRzIG9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fERvY3VtZW50fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5hcHBseURlZmF1bHRzID0gZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhkb2MpIHtcbiAgaWYgKGRvYy4kX18gIT0gbnVsbCkge1xuICAgIGFwcGx5RGVmYXVsdHNIZWxwZXIoZG9jLCBkb2MuJF9fLmZpZWxkcywgZG9jLiRfXy5leGNsdWRlKTtcblxuICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIGRvYy4kZ2V0QWxsU3ViZG9jcygpKSB7XG4gICAgICBhcHBseURlZmF1bHRzKHN1YmRvYywgc3ViZG9jLiRfXy5maWVsZHMsIHN1YmRvYy4kX18uZXhjbHVkZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvYztcbiAgfVxuXG4gIGFwcGx5RGVmYXVsdHNUb1BPSk8oZG9jLCB0aGlzLnNjaGVtYSk7XG5cbiAgcmV0dXJuIGRvYztcbn07XG5cbi8qKlxuICogQ2FzdCB0aGUgZ2l2ZW4gUE9KTyB0byB0aGUgbW9kZWwncyBzY2hlbWFcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRlc3QgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIFNjaGVtYSh7IG51bTogTnVtYmVyIH0pKTtcbiAqXG4gKiAgICAgY29uc3Qgb2JqID0gVGVzdC5jYXN0T2JqZWN0KHsgbnVtOiAnNDInIH0pO1xuICogICAgIG9iai5udW07IC8vIDQyIGFzIGEgbnVtYmVyXG4gKlxuICogICAgIFRlc3QuY2FzdE9iamVjdCh7IG51bTogJ25vdCBhIG51bWJlcicgfSk7IC8vIFRocm93cyBhIFZhbGlkYXRpb25FcnJvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogb2JqZWN0IG9yIGRvY3VtZW50IHRvIGNhc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgcGFzc2VkIHRvIGNhc3RPYmplY3RcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5pZ25vcmVDYXN0RXJyb3JzIElmIHNldCB0byBgdHJ1ZWAgd2lsbCBub3QgdGhyb3cgYSBWYWxpZGF0aW9uRXJyb3IgYW5kIG9ubHkgcmV0dXJuIHZhbHVlcyB0aGF0IHdlcmUgc3VjY2Vzc2Z1bGx5IGNhc3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQT0pPIGNhc3RlZCB0byB0aGUgbW9kZWwncyBzY2hlbWFcbiAqIEB0aHJvd3Mge1ZhbGlkYXRpb25FcnJvcn0gaWYgY2FzdGluZyBmYWlsZWQgZm9yIGF0IGxlYXN0IG9uZSBwYXRoXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmNhc3RPYmplY3QgPSBmdW5jdGlvbiBjYXN0T2JqZWN0KG9iaiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV0ID0ge307XG5cbiAgY29uc3Qgc2NoZW1hID0gdGhpcy5zY2hlbWE7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKTtcblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgaWYgKCFzY2hlbWFUeXBlIHx8ICFzY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbCA9IGdldChvYmosIHBhdGgpO1xuICAgIHB1c2hOZXN0ZWRBcnJheVBhdGhzKHBhdGhzLCB2YWwsIHBhdGgpO1xuICB9XG5cbiAgbGV0IGVycm9yID0gbnVsbDtcblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgaWYgKHNjaGVtYVR5cGUgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IHZhbCA9IGdldChvYmosIHBhdGgsIHZvaWQgMCk7XG5cbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHBpZWNlcyA9IHBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICBsZXQgY3VyID0gcmV0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgaWYgKGN1cltwaWVjZXNbaV1dID09IG51bGwpIHtcbiAgICAgICAgY3VyW3BpZWNlc1tpXV0gPSBpc05hTihwaWVjZXNbaSArIDFdKSA/IHt9IDogW107XG4gICAgICB9XG4gICAgICBjdXIgPSBjdXJbcGllY2VzW2ldXTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQgfHwgc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXlFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YWwgPSBNb2RlbC5jYXN0T2JqZWN0LmNhbGwoc2NoZW1hVHlwZS5jYXN0ZXIsIHZhbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmlnbm9yZUNhc3RFcnJvcnMpIHtcbiAgICAgICAgICBlcnJvciA9IGVycm9yIHx8IG5ldyBWYWxpZGF0aW9uRXJyb3IoKTtcbiAgICAgICAgICBlcnJvci5hZGRFcnJvcihwYXRoLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjdXJbcGllY2VzW3BpZWNlcy5sZW5ndGggLSAxXV0gPSB2YWw7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFsID0gc2NoZW1hVHlwZS5jYXN0KHZhbCk7XG4gICAgICBjdXJbcGllY2VzW3BpZWNlcy5sZW5ndGggLSAxXV0gPSB2YWw7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuaWdub3JlQ2FzdEVycm9ycykge1xuICAgICAgICBlcnJvciA9IGVycm9yIHx8IG5ldyBWYWxpZGF0aW9uRXJyb3IoKTtcbiAgICAgICAgZXJyb3IuYWRkRXJyb3IocGF0aCwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEJ1aWxkIGJ1bGsgd3JpdGUgb3BlcmF0aW9ucyBmb3IgYGJ1bGtTYXZlKClgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8RG9jdW1lbnQ+fSBkb2N1bWVudHMgVGhlIGFycmF5IG9mIGRvY3VtZW50cyB0byBidWlsZCB3cml0ZSBvcGVyYXRpb25zIG9mXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnNraXBWYWxpZGF0aW9uIGRlZmF1bHRzIHRvIGBmYWxzZWAsIHdoZW4gc2V0IHRvIHRydWUsIGJ1aWxkaW5nIHRoZSB3cml0ZSBvcGVyYXRpb25zIHdpbGwgYnlwYXNzIHZhbGlkYXRpbmcgdGhlIGRvY3VtZW50cy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy50aW1lc3RhbXBzIGRlZmF1bHRzIHRvIGBudWxsYCwgd2hlbiBzZXQgdG8gZmFsc2UsIG1vbmdvb3NlIHdpbGwgbm90IGFkZC91cGRhdGUgdGltZXN0YW1wcyB0byB0aGUgZG9jdW1lbnRzLlxuICogQHJldHVybiB7QXJyYXk8UHJvbWlzZT59IFJldHVybnMgYSBhcnJheSBvZiBhbGwgUHJvbWlzZXMgdGhlIGZ1bmN0aW9uIGV4ZWN1dGVzIHRvIGJlIGF3YWl0ZWQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb2RlbC5idWlsZEJ1bGtXcml0ZU9wZXJhdGlvbnMgPSBmdW5jdGlvbiBidWlsZEJ1bGtXcml0ZU9wZXJhdGlvbnMoZG9jdW1lbnRzLCBvcHRpb25zKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShkb2N1bWVudHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBidWxrU2F2ZSBleHBlY3RzIGFuIGFycmF5IG9mIGRvY3VtZW50cyB0byBiZSBwYXNzZWQsIHJlY2VpdmVkIFxcYCR7ZG9jdW1lbnRzfVxcYCBpbnN0ZWFkYCk7XG4gIH1cblxuICBzZXREZWZhdWx0T3B0aW9ucygpO1xuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gdGhpcy5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuXG4gIGNvbnN0IHdyaXRlT3BlcmF0aW9ucyA9IGRvY3VtZW50cy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBkb2N1bWVudCwgaSkgPT4ge1xuICAgIGlmICghb3B0aW9ucy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgaWYgKCEoZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkb2N1bWVudHMuJHtpfSB3YXMgbm90IGEgbW9uZ29vc2UgZG9jdW1lbnQsIGRvY3VtZW50cyBtdXN0IGJlIGFuIGFycmF5IG9mIG1vbmdvb3NlIGRvY3VtZW50cyAoaW5zdGFuY2VvZiBtb25nb29zZS5Eb2N1bWVudCkuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBkb2N1bWVudC52YWxpZGF0ZVN5bmMoKTtcbiAgICAgIGlmICh2YWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdmFsaWRhdGlvbkVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlzQU5ld0RvY3VtZW50ID0gZG9jdW1lbnQuaXNOZXc7XG4gICAgaWYgKGlzQU5ld0RvY3VtZW50KSB7XG4gICAgICBjb25zdCB3cml0ZU9wZXJhdGlvbiA9IHsgaW5zZXJ0T25lOiB7IGRvY3VtZW50IH0gfTtcbiAgICAgIHV0aWxzLmluamVjdFRpbWVzdGFtcHNPcHRpb24od3JpdGVPcGVyYXRpb24uaW5zZXJ0T25lLCBvcHRpb25zLnRpbWVzdGFtcHMpO1xuICAgICAgYWNjdW11bGF0b3IucHVzaCh3cml0ZU9wZXJhdGlvbik7XG5cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICBjb25zdCBkZWx0YSA9IGRvY3VtZW50LiRfX2RlbHRhKCk7XG4gICAgY29uc3QgaXNEb2N1bWVudFdpdGhDaGFuZ2VzID0gZGVsdGEgIT0gbnVsbCAmJiAhdXRpbHMuaXNFbXB0eU9iamVjdChkZWx0YVswXSk7XG5cbiAgICBpZiAoaXNEb2N1bWVudFdpdGhDaGFuZ2VzKSB7XG4gICAgICBjb25zdCB3aGVyZSA9IGRvY3VtZW50LiRfX3doZXJlKGRlbHRhWzBdKTtcbiAgICAgIGNvbnN0IGNoYW5nZXMgPSBkZWx0YVsxXTtcblxuICAgICAgX2FwcGx5Q3VzdG9tV2hlcmUoZG9jdW1lbnQsIHdoZXJlKTtcblxuICAgICAgLy8gU2V0IHRoZSBkaXNjcmltaW5hdG9yIGtleSwgc28gYnVsayB3cml0ZSBjYXN0aW5nIGtub3dzIHdoaWNoXG4gICAgICAvLyBzY2hlbWEgdG8gdXNlIHJlOiBnaC0xMzkwN1xuICAgICAgaWYgKGRvY3VtZW50W2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwgJiYgIShkaXNjcmltaW5hdG9yS2V5IGluIHdoZXJlKSkge1xuICAgICAgICB3aGVyZVtkaXNjcmltaW5hdG9yS2V5XSA9IGRvY3VtZW50W2Rpc2NyaW1pbmF0b3JLZXldO1xuICAgICAgfVxuXG4gICAgICBkb2N1bWVudC4kX192ZXJzaW9uKHdoZXJlLCBkZWx0YSk7XG4gICAgICBjb25zdCB3cml0ZU9wZXJhdGlvbiA9IHsgdXBkYXRlT25lOiB7IGZpbHRlcjogd2hlcmUsIHVwZGF0ZTogY2hhbmdlcyB9IH07XG4gICAgICB1dGlscy5pbmplY3RUaW1lc3RhbXBzT3B0aW9uKHdyaXRlT3BlcmF0aW9uLnVwZGF0ZU9uZSwgb3B0aW9ucy50aW1lc3RhbXBzKTtcbiAgICAgIGFjY3VtdWxhdG9yLnB1c2god3JpdGVPcGVyYXRpb24pO1xuXG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHdyaXRlT3BlcmF0aW9ucztcblxuXG4gIGZ1bmN0aW9uIHNldERlZmF1bHRPcHRpb25zKCkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChvcHRpb25zLnNraXBWYWxpZGF0aW9uID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuc2tpcFZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTaG9ydGN1dCBmb3IgY3JlYXRpbmcgYSBuZXcgRG9jdW1lbnQgZnJvbSBleGlzdGluZyByYXcgZGF0YSwgcHJlLXNhdmVkIGluIHRoZSBEQi5cbiAqIFRoZSBkb2N1bWVudCByZXR1cm5lZCBoYXMgbm8gcGF0aHMgbWFya2VkIGFzIG1vZGlmaWVkIGluaXRpYWxseS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGh5ZHJhdGUgcHJldmlvdXMgZGF0YSBpbnRvIGEgTW9uZ29vc2UgZG9jdW1lbnRcbiAqICAgICBjb25zdCBtb25nb29zZUNhbmR5ID0gQ2FuZHkuaHlkcmF0ZSh7IF9pZDogJzU0MTA4MzM3MjEyZmZiNmQ0NTlmODU0YycsIHR5cGU6ICdqZWxseSBiZWFuJyB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8U3RyaW5nW119IFtwcm9qZWN0aW9uXSBvcHRpb25hbCBwcm9qZWN0aW9uIGNvbnRhaW5pbmcgd2hpY2ggZmllbGRzIHNob3VsZCBiZSBzZWxlY3RlZCBmb3IgdGhpcyBkb2N1bWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNldHRlcnM9ZmFsc2VdIGlmIHRydWUsIGFwcGx5IHNjaGVtYSBzZXR0ZXJzIHdoZW4gaHlkcmF0aW5nXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gZG9jdW1lbnQgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuaHlkcmF0ZSA9IGZ1bmN0aW9uKG9iaiwgcHJvamVjdGlvbiwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdoeWRyYXRlJyk7XG5cbiAgaWYgKHByb2plY3Rpb24gIT0gbnVsbCkge1xuICAgIGlmIChvYmogIT0gbnVsbCAmJiBvYmouJF9fICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IG9iai50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gICAgfVxuICAgIG9iaiA9IGFwcGx5UHJvamVjdGlvbihvYmosIHByb2plY3Rpb24pO1xuICB9XG5cbiAgY29uc3QgZG9jdW1lbnQgPSByZXF1aXJlKCcuL3F1ZXJ5aGVscGVycycpLmNyZWF0ZU1vZGVsKHRoaXMsIG9iaiwgcHJvamVjdGlvbik7XG4gIGRvY3VtZW50LiRpbml0KG9iaiwgb3B0aW9ucyk7XG4gIHJldHVybiBkb2N1bWVudDtcbn07XG5cbi8qKlxuICogU2FtZSBhcyBgdXBkYXRlT25lKClgLCBleGNlcHQgTW9uZ29EQiB3aWxsIHVwZGF0ZSBfYWxsXyBkb2N1bWVudHMgdGhhdCBtYXRjaFxuICogYGZpbHRlcmAgKGFzIG9wcG9zZWQgdG8ganVzdCB0aGUgZmlyc3Qgb25lKSByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZlxuICogdGhlIGBtdWx0aWAgb3B0aW9uLlxuICpcbiAqICoqTm90ZSoqIHVwZGF0ZU1hbnkgd2lsbCBfbm90XyBmaXJlIHVwZGF0ZSBtaWRkbGV3YXJlLiBVc2UgYHByZSgndXBkYXRlTWFueScpYFxuICogYW5kIGBwb3N0KCd1cGRhdGVNYW55JylgIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBQZXJzb24udXBkYXRlTWFueSh7IG5hbWU6IC9TdGFyayQvIH0sIHsgaXNEZWxldGVkOiB0cnVlIH0pO1xuICogICAgIHJlcy5tYXRjaGVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbWF0Y2hlZFxuICogICAgIHJlcy5tb2RpZmllZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1vZGlmaWVkXG4gKiAgICAgcmVzLmFja25vd2xlZGdlZDsgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIGV2ZXJ5dGhpbmcgd2VudCBzbW9vdGhseS5cbiAqICAgICByZXMudXBzZXJ0ZWRJZDsgLy8gbnVsbCBvciBhbiBpZCBjb250YWluaW5nIGEgZG9jdW1lbnQgdGhhdCBoYWQgdG8gYmUgdXBzZXJ0ZWQuXG4gKiAgICAgcmVzLnVwc2VydGVkQ291bnQ7IC8vIE51bWJlciBpbmRpY2F0aW5nIGhvdyBtYW55IGRvY3VtZW50cyBoYWQgdG8gYmUgdXBzZXJ0ZWQuIFdpbGwgZWl0aGVyIGJlIDAgb3IgMS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZUNvbmNlcm49bnVsbF0gc2V0cyB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykgZm9yIHJlcGxpY2Egc2V0cy4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleT1mYWxzZV0gTW9uZ29vc2UgcmVtb3ZlcyBkaXNjcmltaW5hdG9yIGtleSB1cGRhdGVzIGZyb20gYHVwZGF0ZWAgYnkgZGVmYXVsdCwgc2V0IGBvdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5YCB0byBgdHJ1ZWAgdG8gYWxsb3cgdXBkYXRpbmcgdGhlIGRpc2NyaW1pbmF0b3Iga2V5XG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgUXVlcnkgZG9jcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sXG4gKiBAc2VlIE1vbmdvREIgZG9jcyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC91cGRhdGUvI3VwZGF0ZS1jb21tYW5kLW91dHB1dFxuICogQHNlZSBVcGRhdGVSZXN1bHQgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL1VwZGF0ZVJlc3VsdC5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnVwZGF0ZU1hbnkgPSBmdW5jdGlvbiB1cGRhdGVNYW55KGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICd1cGRhdGVNYW55Jyk7XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3VwZGF0ZU1hbnknLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgX29ubHlfIHRoZSBmaXJzdCBkb2N1bWVudCB0aGF0IG1hdGNoZXMgYGZpbHRlcmAuXG4gKlxuICogLSBVc2UgYHJlcGxhY2VPbmUoKWAgaWYgeW91IHdhbnQgdG8gb3ZlcndyaXRlIGFuIGVudGlyZSBkb2N1bWVudCByYXRoZXIgdGhhbiB1c2luZyBhdG9taWMgb3BlcmF0b3JzIGxpa2UgYCRzZXRgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgUGVyc29uLnVwZGF0ZU9uZSh7IG5hbWU6ICdKZWFuLUx1YyBQaWNhcmQnIH0sIHsgc2hpcDogJ1VTUyBFbnRlcnByaXNlJyB9KTtcbiAqICAgICByZXMubWF0Y2hlZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1hdGNoZWRcbiAqICAgICByZXMubW9kaWZpZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyBtb2RpZmllZFxuICogICAgIHJlcy5hY2tub3dsZWRnZWQ7IC8vIEJvb2xlYW4gaW5kaWNhdGluZyBldmVyeXRoaW5nIHdlbnQgc21vb3RobHkuXG4gKiAgICAgcmVzLnVwc2VydGVkSWQ7IC8vIG51bGwgb3IgYW4gaWQgY29udGFpbmluZyBhIGRvY3VtZW50IHRoYXQgaGFkIHRvIGJlIHVwc2VydGVkLlxuICogICAgIHJlcy51cHNlcnRlZENvdW50OyAvLyBOdW1iZXIgaW5kaWNhdGluZyBob3cgbWFueSBkb2N1bWVudHMgaGFkIHRvIGJlIHVwc2VydGVkLiBXaWxsIGVpdGhlciBiZSAwIG9yIDEuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgdXBkYXRlT25lKClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZUNvbmNlcm49bnVsbF0gc2V0cyB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykgZm9yIHJlcGxpY2Egc2V0cy4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzIHlvdSB0byBvdmVyd3JpdGUgdGltZXN0YW1wcy4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleT1mYWxzZV0gTW9uZ29vc2UgcmVtb3ZlcyBkaXNjcmltaW5hdG9yIGtleSB1cGRhdGVzIGZyb20gYHVwZGF0ZWAgYnkgZGVmYXVsdCwgc2V0IGBvdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5YCB0byBgdHJ1ZWAgdG8gYWxsb3cgdXBkYXRpbmcgdGhlIGRpc2NyaW1pbmF0b3Iga2V5XG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgUXVlcnkgZG9jcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sXG4gKiBAc2VlIE1vbmdvREIgZG9jcyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC91cGRhdGUvI3VwZGF0ZS1jb21tYW5kLW91dHB1dFxuICogQHNlZSBVcGRhdGVSZXN1bHQgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL1VwZGF0ZVJlc3VsdC5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAndXBkYXRlT25lJyk7XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3VwZGF0ZU9uZScsIGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgdGhlIGV4aXN0aW5nIGRvY3VtZW50IHdpdGggdGhlIGdpdmVuIGRvY3VtZW50IChubyBhdG9taWMgb3BlcmF0b3JzIGxpa2UgYCRzZXRgKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IFBlcnNvbi5yZXBsYWNlT25lKHsgX2lkOiAyNDYwMSB9LCB7IG5hbWU6ICdKZWFuIFZhbGplYW4nIH0pO1xuICogICAgIHJlcy5tYXRjaGVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbWF0Y2hlZFxuICogICAgIHJlcy5tb2RpZmllZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1vZGlmaWVkXG4gKiAgICAgcmVzLmFja25vd2xlZGdlZDsgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIGV2ZXJ5dGhpbmcgd2VudCBzbW9vdGhseS5cbiAqICAgICByZXMudXBzZXJ0ZWRJZDsgLy8gbnVsbCBvciBhbiBpZCBjb250YWluaW5nIGEgZG9jdW1lbnQgdGhhdCBoYWQgdG8gYmUgdXBzZXJ0ZWQuXG4gKiAgICAgcmVzLnVwc2VydGVkQ291bnQ7IC8vIE51bWJlciBpbmRpY2F0aW5nIGhvdyBtYW55IGRvY3VtZW50cyBoYWQgdG8gYmUgdXBzZXJ0ZWQuIFdpbGwgZWl0aGVyIGJlIDAgb3IgMS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGByZXBsYWNlT25lKClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZUNvbmNlcm49bnVsbF0gc2V0cyB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykgZm9yIHJlcGxpY2Egc2V0cy4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBRdWVyeSBkb2NzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWxcbiAqIEBzZWUgVXBkYXRlUmVzdWx0IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9VcGRhdGVSZXN1bHQuaHRtbFxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnJlcGxhY2VPbmUgPSBmdW5jdGlvbiByZXBsYWNlT25lKGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdyZXBsYWNlT25lJyk7XG5cbiAgY29uc3QgdmVyc2lvbktleSA9IHRoaXMgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEub3B0aW9ucyAmJiB0aGlzLnNjaGVtYS5vcHRpb25zLnZlcnNpb25LZXkgfHwgbnVsbDtcbiAgaWYgKHZlcnNpb25LZXkgJiYgIWRvY1t2ZXJzaW9uS2V5XSkge1xuICAgIGRvY1t2ZXJzaW9uS2V5XSA9IDA7XG4gIH1cblxuICByZXR1cm4gX3VwZGF0ZSh0aGlzLCAncmVwbGFjZU9uZScsIGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENvbW1vbiBjb2RlIGZvciBgdXBkYXRlT25lKClgLCBgdXBkYXRlTWFueSgpYCwgYHJlcGxhY2VPbmUoKWAsIGFuZCBgdXBkYXRlKClgXG4gKiBiZWNhdXNlIHRoZXkgbmVlZCB0byBkbyB0aGUgc2FtZSB0aGluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX3VwZGF0ZShtb2RlbCwgb3AsIGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucykge1xuICBjb25zdCBtcSA9IG5ldyBtb2RlbC5RdWVyeSh7fSwge30sIG1vZGVsLCBtb2RlbC5jb2xsZWN0aW9uKTtcblxuICAvLyBnaC0yNDA2XG4gIC8vIG1ha2UgbG9jYWwgZGVlcCBjb3B5IG9mIGNvbmRpdGlvbnNcbiAgaWYgKGNvbmRpdGlvbnMgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgIGNvbmRpdGlvbnMgPSBjb25kaXRpb25zLnRvT2JqZWN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZGl0aW9ucyA9IGNsb25lKGNvbmRpdGlvbnMpO1xuICB9XG4gIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMgOiBjbG9uZShvcHRpb25zKTtcblxuICBjb25zdCB2ZXJzaW9uS2V5ID0gbW9kZWwgJiZcbiAgbW9kZWwuc2NoZW1hICYmXG4gIG1vZGVsLnNjaGVtYS5vcHRpb25zICYmXG4gIG1vZGVsLnNjaGVtYS5vcHRpb25zLnZlcnNpb25LZXkgfHwgbnVsbDtcbiAgZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleShkb2MsIG9wdGlvbnMsIHZlcnNpb25LZXkpO1xuXG4gIHJldHVybiBtcVtvcF0oY29uZGl0aW9ucywgZG9jLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBbYWdncmVnYXRpb25zXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hZ2dyZWdhdGlvbi8pIG9uIHRoZSBtb2RlbHMgY29sbGVjdGlvbi5cbiAqXG4gKiBJZiBhIGBjYWxsYmFja2AgaXMgcGFzc2VkLCB0aGUgYGFnZ3JlZ2F0ZWAgaXMgZXhlY3V0ZWQgYW5kIGEgYFByb21pc2VgIGlzIHJldHVybmVkLiBJZiBhIGNhbGxiYWNrIGlzIG5vdCBwYXNzZWQsIHRoZSBgYWdncmVnYXRlYCBpdHNlbGYgaXMgcmV0dXJuZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgYWdncmVnYXRlKClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBGaW5kIHRoZSBtYXggYmFsYW5jZSBvZiBhbGwgYWNjb3VudHNcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBVc2Vycy5hZ2dyZWdhdGUoW1xuICogICAgICAgeyAkZ3JvdXA6IHsgX2lkOiBudWxsLCBtYXhCYWxhbmNlOiB7ICRtYXg6ICckYmFsYW5jZScgfX19LFxuICogICAgICAgeyAkcHJvamVjdDogeyBfaWQ6IDAsIG1heEJhbGFuY2U6IDEgfX1cbiAqICAgICBdKTtcbiAqXG4gKiAgICAgY29uc29sZS5sb2cocmVzKTsgLy8gWyB7IG1heEJhbGFuY2U6IDk4MDAwIH0gXVxuICpcbiAqICAgICAvLyBPciB1c2UgdGhlIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lIGJ1aWxkZXIuXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgVXNlcnMuYWdncmVnYXRlKCkuXG4gKiAgICAgICBncm91cCh7IF9pZDogbnVsbCwgbWF4QmFsYW5jZTogeyAkbWF4OiAnJGJhbGFuY2UnIH0gfSkuXG4gKiAgICAgICBwcm9qZWN0KCctaWQgbWF4QmFsYW5jZScpLlxuICogICAgICAgZXhlYygpO1xuICogICAgIGNvbnNvbGUubG9nKHJlcyk7IC8vIFsgeyBtYXhCYWxhbmNlOiA5OCB9IF1cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogLSBNb25nb29zZSBkb2VzICoqbm90KiogY2FzdCBhZ2dyZWdhdGlvbiBwaXBlbGluZXMgdG8gdGhlIG1vZGVsJ3Mgc2NoZW1hIGJlY2F1c2UgYCRwcm9qZWN0YCBhbmQgYCRncm91cGAgb3BlcmF0b3JzIGFsbG93IHJlZGVmaW5pbmcgdGhlIFwic2hhcGVcIiBvZiB0aGUgZG9jdW1lbnRzIGF0IGFueSBzdGFnZSBvZiB0aGUgcGlwZWxpbmUsIHdoaWNoIG1heSBsZWF2ZSBkb2N1bWVudHMgaW4gYW4gaW5jb21wYXRpYmxlIGZvcm1hdC4gWW91IGNhbiB1c2UgdGhlIFttb25nb29zZS1jYXN0LWFnZ3JlZ2F0aW9uIHBsdWdpbl0oaHR0cHM6Ly9naXRodWIuY29tL0FiZGVscmFobWFuSGFmZXovbW9uZ29vc2UtY2FzdC1hZ2dyZWdhdGlvbikgdG8gZW5hYmxlIG1pbmltYWwgY2FzdGluZyBmb3IgYWdncmVnYXRpb24gcGlwZWxpbmVzLlxuICogLSBUaGUgZG9jdW1lbnRzIHJldHVybmVkIGFyZSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdHMsIG5vdCBtb25nb29zZSBkb2N1bWVudHMgKHNpbmNlIGFueSBzaGFwZSBvZiBkb2N1bWVudCBjYW4gYmUgcmV0dXJuZWQpLlxuICpcbiAqICMjIyMgTW9yZSBBYm91dCBBZ2dyZWdhdGlvbnM6XG4gKlxuICogLSBbTW9uZ29vc2UgYEFnZ3JlZ2F0ZWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwpXG4gKiAtIFtBbiBJbnRyb2R1Y3Rpb24gdG8gTW9uZ29vc2UgQWdncmVnYXRlXShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9tb25nb29zZS9hZ2dyZWdhdGUpXG4gKiAtIFtNb25nb0RCIEFnZ3JlZ2F0aW9uIGRvY3NdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2FwcGxpY2F0aW9ucy9hZ2dyZWdhdGlvbi8pXG4gKlxuICogQHNlZSBBZ2dyZWdhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUoKVxuICogQHNlZSBNb25nb0RCIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2FwcGxpY2F0aW9ucy9hZ2dyZWdhdGlvbi9cbiAqIEBwYXJhbSB7QXJyYXl9IFtwaXBlbGluZV0gYWdncmVnYXRpb24gcGlwZWxpbmUgYXMgYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBhZ2dyZWdhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uIGFnZ3JlZ2F0ZShwaXBlbGluZSwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdhZ2dyZWdhdGUnKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5hZ2dyZWdhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBhZ2dyZWdhdGUgPSBuZXcgQWdncmVnYXRlKHBpcGVsaW5lIHx8IFtdKTtcbiAgYWdncmVnYXRlLm1vZGVsKHRoaXMpO1xuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgYWdncmVnYXRlLm9wdGlvbihvcHRpb25zKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGFnZ3JlZ2F0ZTtcbiAgfVxuXG4gIHJldHVybiBhZ2dyZWdhdGU7XG59O1xuXG4vKipcbiAqIENhc3RzIGFuZCB2YWxpZGF0ZXMgdGhlIGdpdmVuIG9iamVjdCBhZ2FpbnN0IHRoaXMgbW9kZWwncyBzY2hlbWEsIHBhc3NpbmcgdGhlXG4gKiBnaXZlbiBgY29udGV4dGAgdG8gY3VzdG9tIHZhbGlkYXRvcnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgU2NoZW1hKHtcbiAqICAgICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9LFxuICogICAgICAgYWdlOiB7IHR5cGU6IE51bWJlciwgcmVxdWlyZWQ6IHRydWUgfVxuICogICAgIH0pO1xuICpcbiAqICAgICB0cnkge1xuICogICAgICAgYXdhaXQgTW9kZWwudmFsaWRhdGUoeyBuYW1lOiBudWxsIH0sIFsnbmFtZSddKVxuICogICAgIH0gY2F0Y2ggKGVycikge1xuICogICAgICAgZXJyIGluc3RhbmNlb2YgbW9uZ29vc2UuRXJyb3IuVmFsaWRhdGlvbkVycm9yOyAvLyB0cnVlXG4gKiAgICAgICBPYmplY3Qua2V5cyhlcnIuZXJyb3JzKTsgLy8gWyduYW1lJ11cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfSBwYXRoc09yT3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnZhbGlkYXRlID0gYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGUob2JqLCBwYXRoc09yT3B0aW9ucywgY29udGV4dCkge1xuICBpZiAoKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB8fCAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSkge1xuICAgIC8vIEZvciBjb252ZW5pZW5jZSwgaWYgd2UncmUgdmFsaWRhdGluZyBhIGRvY3VtZW50IG9yIGFuIG9iamVjdCwgbWFrZSBgY29udGV4dGAgZGVmYXVsdCB0b1xuICAgIC8vIHRoZSBtb2RlbCBzbyB1c2VycyBkb24ndCBoYXZlIHRvIGFsd2F5cyBwYXNzIGBjb250ZXh0YCwgcmU6IGdoLTEwMTMyLCBnaC0xMDM0NlxuICAgIGNvbnRleHQgPSBvYmo7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwudmFsaWRhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBsZXQgc2NoZW1hID0gdGhpcy5zY2hlbWE7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICBpZiAoc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwgJiYgb2JqICE9IG51bGwgJiYgb2JqW2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwpIHtcbiAgICBzY2hlbWEgPSBnZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZShzY2hlbWEsIG9ialtkaXNjcmltaW5hdG9yS2V5XSkgfHwgc2NoZW1hO1xuICB9XG4gIGxldCBwYXRocyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocyk7XG5cbiAgaWYgKHBhdGhzT3JPcHRpb25zICE9IG51bGwpIHtcbiAgICBjb25zdCBfcGF0aHNUb1ZhbGlkYXRlID0gdHlwZW9mIHBhdGhzT3JPcHRpb25zID09PSAnc3RyaW5nJyA/IG5ldyBTZXQocGF0aHNPck9wdGlvbnMuc3BsaXQoJyAnKSkgOiBBcnJheS5pc0FycmF5KHBhdGhzT3JPcHRpb25zKSA/IG5ldyBTZXQocGF0aHNPck9wdGlvbnMpIDogbmV3IFNldChwYXRocyk7XG4gICAgcGF0aHMgPSBwYXRocy5maWx0ZXIocCA9PiB7XG4gICAgICBpZiAocGF0aHNPck9wdGlvbnMucGF0aHNUb1NraXApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aHNPck9wdGlvbnMucGF0aHNUb1NraXApKSB7XG4gICAgICAgICAgaWYgKHBhdGhzT3JPcHRpb25zLnBhdGhzVG9Ta2lwLmZpbmQoeCA9PiB4ID09IHApKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXRoc09yT3B0aW9ucy5wYXRoc1RvU2tpcCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChwYXRoc09yT3B0aW9ucy5wYXRoc1RvU2tpcC5pbmNsdWRlcyhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcGllY2VzID0gcC5zcGxpdCgnLicpO1xuICAgICAgbGV0IGN1ciA9IHBpZWNlc1swXTtcblxuICAgICAgZm9yIChjb25zdCBwaWVjZSBvZiBwaWVjZXMpIHtcbiAgICAgICAgaWYgKF9wYXRoc1RvVmFsaWRhdGUuaGFzKGN1cikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXIgKz0gJy4nICsgcGllY2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcGF0aHNUb1ZhbGlkYXRlLmhhcyhwKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBzY2hlbWEucGF0aChwYXRoKTtcbiAgICBpZiAoIXNjaGVtYVR5cGUgfHwgIXNjaGVtYVR5cGUuJGlzTW9uZ29vc2VBcnJheSB8fCBzY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsID0gZ2V0KG9iaiwgcGF0aCk7XG4gICAgcHVzaE5lc3RlZEFycmF5UGF0aHMocGF0aHMsIHZhbCwgcGF0aCk7XG4gIH1cblxuICBsZXQgcmVtYWluaW5nID0gcGF0aHMubGVuZ3RoO1xuICBsZXQgZXJyb3IgPSBudWxsO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgICBpZiAoc2NoZW1hVHlwZSA9PSBudWxsKSB7XG4gICAgICAgIF9jaGVja0RvbmUoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBpZWNlcyA9IHBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgIGxldCBjdXIgPSBvYmo7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY3VyID0gY3VyW3BpZWNlc1tpXV07XG4gICAgICB9XG5cbiAgICAgIGxldCB2YWwgPSBnZXQob2JqLCBwYXRoLCB2b2lkIDApO1xuXG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWwgPSBzY2hlbWFUeXBlLmNhc3QodmFsKTtcbiAgICAgICAgICBjdXJbcGllY2VzW3BpZWNlcy5sZW5ndGggLSAxXV0gPSB2YWw7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGVycm9yID0gZXJyb3IgfHwgbmV3IFZhbGlkYXRpb25FcnJvcigpO1xuICAgICAgICAgIGVycm9yLmFkZEVycm9yKHBhdGgsIGVycik7XG5cbiAgICAgICAgICBfY2hlY2tEb25lKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2NoZW1hVHlwZS5kb1ZhbGlkYXRlKHZhbCwgZXJyID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGVycm9yID0gZXJyb3IgfHwgbmV3IFZhbGlkYXRpb25FcnJvcigpO1xuICAgICAgICAgIGVycm9yLmFkZEVycm9yKHBhdGgsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgX2NoZWNrRG9uZSgpO1xuICAgICAgfSwgY29udGV4dCwgeyBwYXRoOiBwYXRoIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jaGVja0RvbmUoKSB7XG4gICAgICBpZiAoLS1yZW1haW5pbmcgPD0gMCkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFBvcHVsYXRlcyBkb2N1bWVudCByZWZlcmVuY2VzLlxuICpcbiAqIENoYW5nZWQgaW4gTW9uZ29vc2UgNjogdGhlIG1vZGVsIHlvdSBjYWxsIGBwb3B1bGF0ZSgpYCBvbiBzaG91bGQgYmUgdGhlXG4gKiBcImxvY2FsIGZpZWxkXCIgbW9kZWwsICoqbm90KiogdGhlIFwiZm9yZWlnbiBmaWVsZFwiIG1vZGVsLlxuICpcbiAqICMjIyMgQXZhaWxhYmxlIHRvcC1sZXZlbCBvcHRpb25zOlxuICpcbiAqIC0gcGF0aDogc3BhY2UgZGVsaW1pdGVkIHBhdGgocykgdG8gcG9wdWxhdGVcbiAqIC0gc2VsZWN0OiBvcHRpb25hbCBmaWVsZHMgdG8gc2VsZWN0XG4gKiAtIG1hdGNoOiBvcHRpb25hbCBxdWVyeSBjb25kaXRpb25zIHRvIG1hdGNoXG4gKiAtIG1vZGVsOiBvcHRpb25hbCBuYW1lIG9mIHRoZSBtb2RlbCB0byB1c2UgZm9yIHBvcHVsYXRpb25cbiAqIC0gb3B0aW9uczogb3B0aW9uYWwgcXVlcnkgb3B0aW9ucyBsaWtlIHNvcnQsIGxpbWl0LCBldGNcbiAqIC0ganVzdE9uZTogb3B0aW9uYWwgYm9vbGVhbiwgaWYgdHJ1ZSBNb25nb29zZSB3aWxsIGFsd2F5cyBzZXQgYHBhdGhgIHRvIGEgZG9jdW1lbnQsIG9yIGBudWxsYCBpZiBubyBkb2N1bWVudCB3YXMgZm91bmQuIElmIGZhbHNlLCBNb25nb29zZSB3aWxsIGFsd2F5cyBzZXQgYHBhdGhgIHRvIGFuIGFycmF5LCB3aGljaCB3aWxsIGJlIGVtcHR5IGlmIG5vIGRvY3VtZW50cyBhcmUgZm91bmQuIEluZmVycmVkIGZyb20gc2NoZW1hIGJ5IGRlZmF1bHQuXG4gKiAtIHN0cmljdFBvcHVsYXRlOiBvcHRpb25hbCBib29sZWFuLCBzZXQgdG8gYGZhbHNlYCB0byBhbGxvdyBwb3B1bGF0aW5nIHBhdGhzIHRoYXQgYXJlbid0IGluIHRoZSBzY2hlbWEuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBEb2cgPSBtb25nb29zZS5tb2RlbCgnRG9nJywgbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZywgYnJlZWQ6IFN0cmluZyB9KSk7XG4gKiAgICAgY29uc3QgUGVyc29uID0gbW9uZ29vc2UubW9kZWwoJ1BlcnNvbicsIG5ldyBTY2hlbWEoe1xuICogICAgICAgbmFtZTogU3RyaW5nLFxuICogICAgICAgcGV0OiB7IHR5cGU6IG1vbmdvb3NlLk9iamVjdElkLCByZWY6ICdEb2cnIH1cbiAqICAgICB9KSk7XG4gKlxuICogICAgIGNvbnN0IHBldHMgPSBhd2FpdCBQZXQuY3JlYXRlKFtcbiAqICAgICAgIHsgbmFtZTogJ0RhaXN5JywgYnJlZWQ6ICdCZWFnbGUnIH0sXG4gKiAgICAgICB7IG5hbWU6ICdFaW5zdGVpbicsIGJyZWVkOiAnQ2F0YWxhbiBTaGVlcGRvZycgfVxuICogICAgIF0pO1xuICpcbiAqICAgICAvLyBwb3B1bGF0ZSBtYW55IHBsYWluIG9iamVjdHNcbiAqICAgICBjb25zdCB1c2VycyA9IFtcbiAqICAgICAgIHsgbmFtZTogJ0pvaG4gV2ljaycsIGRvZzogcGV0c1swXS5faWQgfSxcbiAqICAgICAgIHsgbmFtZTogJ0RvYyBCcm93bicsIGRvZzogcGV0c1sxXS5faWQgfVxuICogICAgIF07XG4gKiAgICAgYXdhaXQgVXNlci5wb3B1bGF0ZSh1c2VycywgeyBwYXRoOiAnZG9nJywgc2VsZWN0OiAnbmFtZScgfSk7XG4gKiAgICAgdXNlcnNbMF0uZG9nLm5hbWU7IC8vICdEYWlzeSdcbiAqICAgICB1c2Vyc1swXS5kb2cuYnJlZWQ7IC8vIHVuZGVmaW5lZCBiZWNhdXNlIG9mIGBzZWxlY3RgXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudHxBcnJheX0gZG9jcyBFaXRoZXIgYSBzaW5nbGUgZG9jdW1lbnQgb3IgYXJyYXkgb2YgZG9jdW1lbnRzIHRvIHBvcHVsYXRlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRpb25zIEVpdGhlciB0aGUgcGF0aHMgdG8gcG9wdWxhdGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgYWxsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wYXRoPW51bGxdIFRoZSBwYXRoIHRvIHBvcHVsYXRlLlxuICogQHBhcmFtIHtzdHJpbmd8UG9wdWxhdGVPcHRpb25zfSBbb3B0aW9ucy5wb3B1bGF0ZT1udWxsXSBSZWN1cnNpdmVseSBwb3B1bGF0ZSBwYXRocyBpbiB0aGUgcG9wdWxhdGVkIGRvY3VtZW50cy4gU2VlIFtkZWVwIHBvcHVsYXRlIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI2RlZXAtcG9wdWxhdGUpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXRhaW5OdWxsVmFsdWVzPWZhbHNlXSBCeSBkZWZhdWx0LCBNb25nb29zZSByZW1vdmVzIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSBwb3B1bGF0ZWQgYXJyYXlzLiBVc2UgdGhpcyBvcHRpb24gdG8gbWFrZSBgcG9wdWxhdGUoKWAgcmV0YWluIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJyYXkgZW50cmllcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZ2V0dGVycz1mYWxzZV0gSWYgdHJ1ZSwgTW9uZ29vc2Ugd2lsbCBjYWxsIGFueSBnZXR0ZXJzIGRlZmluZWQgb24gdGhlIGBsb2NhbEZpZWxkYC4gQnkgZGVmYXVsdCwgTW9uZ29vc2UgZ2V0cyB0aGUgcmF3IHZhbHVlIG9mIGBsb2NhbEZpZWxkYC4gRm9yIGV4YW1wbGUsIHlvdSB3b3VsZCBuZWVkIHRvIHNldCB0aGlzIG9wdGlvbiB0byBgdHJ1ZWAgaWYgeW91IHdhbnRlZCB0byBbYWRkIGEgYGxvd2VyY2FzZWAgZ2V0dGVyIHRvIHlvdXIgYGxvY2FsRmllbGRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNzY2hlbWF0eXBlLW9wdGlvbnMpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbG9uZT1mYWxzZV0gV2hlbiB5b3UgZG8gYEJsb2dQb3N0LmZpbmQoKS5wb3B1bGF0ZSgnYXV0aG9yJylgLCBibG9nIHBvc3RzIHdpdGggdGhlIHNhbWUgYXV0aG9yIHdpbGwgc2hhcmUgMSBjb3B5IG9mIGFuIGBhdXRob3JgIGRvYy4gRW5hYmxlIHRoaXMgb3B0aW9uIHRvIG1ha2UgTW9uZ29vc2UgY2xvbmUgcG9wdWxhdGVkIGRvY3MgYmVmb3JlIGFzc2lnbmluZyB0aGVtLlxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFtvcHRpb25zLm1hdGNoPW51bGxdIEFkZCBhbiBhZGRpdGlvbmFsIGZpbHRlciB0byB0aGUgcG9wdWxhdGUgcXVlcnkuIENhbiBiZSBhIGZpbHRlciBvYmplY3QgY29udGFpbmluZyBbTW9uZ29EQiBxdWVyeSBzeW50YXhdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3R1dG9yaWFsL3F1ZXJ5LWRvY3VtZW50cy8pLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZpbHRlciBvYmplY3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBJbnZhbGlkSWRzPWZhbHNlXSBCeSBkZWZhdWx0LCBNb25nb29zZSB0aHJvd3MgYSBjYXN0IGVycm9yIGlmIGBsb2NhbEZpZWxkYCBhbmQgYGZvcmVpZ25GaWVsZGAgc2NoZW1hcyBkb24ndCBsaW5lIHVwLiBJZiB5b3UgZW5hYmxlIHRoaXMgb3B0aW9uLCBNb25nb29zZSB3aWxsIGluc3RlYWQgZmlsdGVyIG91dCBhbnkgYGxvY2FsRmllbGRgIHByb3BlcnRpZXMgdGhhdCBjYW5ub3QgYmUgY2FzdGVkIHRvIGBmb3JlaWduRmllbGRgJ3Mgc2NoZW1hIHR5cGUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyRG9jdW1lbnRMaW1pdD1udWxsXSBGb3IgbGVnYWN5IHJlYXNvbnMsIGBsaW1pdGAgd2l0aCBgcG9wdWxhdGUoKWAgbWF5IGdpdmUgaW5jb3JyZWN0IHJlc3VsdHMgYmVjYXVzZSBpdCBvbmx5IGV4ZWN1dGVzIGEgc2luZ2xlIHF1ZXJ5IGZvciBldmVyeSBkb2N1bWVudCBiZWluZyBwb3B1bGF0ZWQuIElmIHlvdSBzZXQgYHBlckRvY3VtZW50TGltaXRgLCBNb25nb29zZSB3aWxsIGVuc3VyZSBjb3JyZWN0IGBsaW1pdGAgcGVyIGRvY3VtZW50IGJ5IGV4ZWN1dGluZyBhIHNlcGFyYXRlIHF1ZXJ5IGZvciBlYWNoIGRvY3VtZW50IHRvIGBwb3B1bGF0ZSgpYC4gRm9yIGV4YW1wbGUsIGAuZmluZCgpLnBvcHVsYXRlKHsgcGF0aDogJ3Rlc3QnLCBwZXJEb2N1bWVudExpbWl0OiAyIH0pYCB3aWxsIGV4ZWN1dGUgMiBhZGRpdGlvbmFsIHF1ZXJpZXMgaWYgYC5maW5kKClgIHJldHVybnMgMiBkb2N1bWVudHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0cmljdFBvcHVsYXRlPXRydWVdIFNldCB0byBmYWxzZSB0byBhbGxvdyBwb3B1bGF0aW5nIHBhdGhzIHRoYXQgYXJlbid0IGRlZmluZWQgaW4gdGhlIGdpdmVuIG1vZGVsJ3Mgc2NoZW1hLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm9wdGlvbnM9bnVsbF0gQWRkaXRpb25hbCBvcHRpb25zIGxpa2UgYGxpbWl0YCBhbmQgYGxlYW5gLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudHJhbnNmb3JtPW51bGxdIEZ1bmN0aW9uIHRoYXQgTW9uZ29vc2Ugd2lsbCBjYWxsIG9uIGV2ZXJ5IHBvcHVsYXRlZCBkb2N1bWVudCB0aGF0IGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIHRoZSBwb3B1bGF0ZWQgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2soZXJyLGRvYyldIE9wdGlvbmFsIGNhbGxiYWNrLCBleGVjdXRlZCB1cG9uIGNvbXBsZXRpb24uIFJlY2VpdmVzIGBlcnJgIGFuZCB0aGUgYGRvYyhzKWAuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5wb3B1bGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIHBvcHVsYXRlKGRvY3MsIHBhdGhzKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ3BvcHVsYXRlJyk7XG4gIGlmICh0eXBlb2YgcGF0aHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5wb3B1bGF0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIC8vIG5vcm1hbGl6ZWQgcGF0aHNcbiAgcGF0aHMgPSB1dGlscy5wb3B1bGF0ZShwYXRocyk7XG4gIC8vIGRhdGEgdGhhdCBzaG91bGQgcGVyc2lzdCBhY3Jvc3Mgc3ViUG9wdWxhdGUgY2FsbHNcbiAgY29uc3QgY2FjaGUgPSB7fTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIF9wb3B1bGF0ZShfdGhpcywgZG9jcywgcGF0aHMsIGNhY2hlLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogUG9wdWxhdGUgaGVscGVyXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWwgdGhlIG1vZGVsIHRvIHVzZVxuICogQHBhcmFtIHtEb2N1bWVudHxBcnJheX0gZG9jcyBFaXRoZXIgYSBzaW5nbGUgZG9jdW1lbnQgb3IgYXJyYXkgb2YgZG9jdW1lbnRzIHRvIHBvcHVsYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IHBhdGhzXG4gKiBAcGFyYW0ge25ldmVyfSBjYWNoZSBVbnVzZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9uYWwgY2FsbGJhY2ssIGV4ZWN1dGVkIHVwb24gY29tcGxldGlvbi4gUmVjZWl2ZXMgYGVycmAgYW5kIHRoZSBgZG9jKHMpYC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX3BvcHVsYXRlKG1vZGVsLCBkb2NzLCBwYXRocywgY2FjaGUsIGNhbGxiYWNrKSB7XG4gIGxldCBwZW5kaW5nID0gcGF0aHMubGVuZ3RoO1xuICBpZiAocGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRvY3MpO1xuICB9XG4gIC8vIGVhY2ggcGF0aCBoYXMgaXRzIG93biBxdWVyeSBvcHRpb25zIGFuZCBtdXN0IGJlIGV4ZWN1dGVkIHNlcGFyYXRlbHlcbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgcG9wdWxhdGUobW9kZWwsIGRvY3MsIHBhdGgsIG5leHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICB9XG4gICAgaWYgKC0tcGVuZGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCBkb2NzKTtcbiAgfVxufVxuXG4vKiFcbiAqIFBvcHVsYXRlcyBgZG9jc2BcbiAqL1xuY29uc3QgZXhjbHVkZUlkUmVnID0gL1xccz8tX2lkXFxzPy87XG5jb25zdCBleGNsdWRlSWRSZWdHbG9iYWwgPSAvXFxzPy1faWRcXHM/L2c7XG5cbmZ1bmN0aW9uIHBvcHVsYXRlKG1vZGVsLCBkb2NzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBwb3B1bGF0ZU9wdGlvbnMgPSBvcHRpb25zO1xuICBpZiAob3B0aW9ucy5zdHJpY3RQb3B1bGF0ZSA9PSBudWxsKSB7XG4gICAgaWYgKG9wdGlvbnMuX2xvY2FsTW9kZWwgIT0gbnVsbCAmJiBvcHRpb25zLl9sb2NhbE1vZGVsLnNjaGVtYS5fdXNlclByb3ZpZGVkT3B0aW9ucy5zdHJpY3RQb3B1bGF0ZSAhPSBudWxsKSB7XG4gICAgICBwb3B1bGF0ZU9wdGlvbnMuc3RyaWN0UG9wdWxhdGUgPSBvcHRpb25zLl9sb2NhbE1vZGVsLnNjaGVtYS5fdXNlclByb3ZpZGVkT3B0aW9ucy5zdHJpY3RQb3B1bGF0ZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuX2xvY2FsTW9kZWwgIT0gbnVsbCAmJiBtb2RlbC5iYXNlLm9wdGlvbnMuc3RyaWN0UG9wdWxhdGUgIT0gbnVsbCkge1xuICAgICAgcG9wdWxhdGVPcHRpb25zLnN0cmljdFBvcHVsYXRlID0gbW9kZWwuYmFzZS5vcHRpb25zLnN0cmljdFBvcHVsYXRlO1xuICAgIH0gZWxzZSBpZiAobW9kZWwuYmFzZS5vcHRpb25zLnN0cmljdFBvcHVsYXRlICE9IG51bGwpIHtcbiAgICAgIHBvcHVsYXRlT3B0aW9ucy5zdHJpY3RQb3B1bGF0ZSA9IG1vZGVsLmJhc2Uub3B0aW9ucy5zdHJpY3RQb3B1bGF0ZTtcbiAgICB9XG4gIH1cblxuICAvLyBub3JtYWxpemUgc2luZ2xlIC8gbXVsdGlwbGUgZG9jcyBwYXNzZWRcbiAgaWYgKCFBcnJheS5pc0FycmF5KGRvY3MpKSB7XG4gICAgZG9jcyA9IFtkb2NzXTtcbiAgfVxuICBpZiAoZG9jcy5sZW5ndGggPT09IDAgfHwgZG9jcy5ldmVyeSh1dGlscy5pc051bGxPclVuZGVmaW5lZCkpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuXG4gIGNvbnN0IG1vZGVsc01hcCA9IGdldE1vZGVsc01hcEZvclBvcHVsYXRlKG1vZGVsLCBkb2NzLCBwb3B1bGF0ZU9wdGlvbnMpO1xuXG4gIGlmIChtb2RlbHNNYXAgaW5zdGFuY2VvZiBNb25nb29zZUVycm9yKSB7XG4gICAgcmV0dXJuIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGNhbGxiYWNrKG1vZGVsc01hcCk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbGVuID0gbW9kZWxzTWFwLmxlbmd0aDtcbiAgbGV0IHZhbHMgPSBbXTtcblxuICBmdW5jdGlvbiBmbGF0dGVuKGl0ZW0pIHtcbiAgICAvLyBubyBuZWVkIHRvIGluY2x1ZGUgdW5kZWZpbmVkIHZhbHVlcyBpbiBvdXIgcXVlcnlcbiAgICByZXR1cm4gdW5kZWZpbmVkICE9PSBpdGVtO1xuICB9XG5cbiAgbGV0IF9yZW1haW5pbmcgPSBsZW47XG4gIGxldCBoYXNPbmUgPSBmYWxzZTtcbiAgY29uc3QgcGFyYW1zID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjb25zdCBtb2QgPSBtb2RlbHNNYXBbaV07XG4gICAgbGV0IHNlbGVjdCA9IG1vZC5vcHRpb25zLnNlbGVjdDtcbiAgICBsZXQgaWRzID0gdXRpbHMuYXJyYXkuZmxhdHRlbihtb2QuaWRzLCBmbGF0dGVuKTtcbiAgICBpZHMgPSB1dGlscy5hcnJheS51bmlxdWUoaWRzKTtcblxuICAgIGNvbnN0IGFzc2lnbm1lbnRPcHRzID0ge307XG4gICAgYXNzaWdubWVudE9wdHMuc29ydCA9IG1vZCAmJlxuICAgICAgbW9kLm9wdGlvbnMgJiZcbiAgICAgIG1vZC5vcHRpb25zLm9wdGlvbnMgJiZcbiAgICAgIG1vZC5vcHRpb25zLm9wdGlvbnMuc29ydCB8fCB2b2lkIDA7XG4gICAgYXNzaWdubWVudE9wdHMuZXhjbHVkZUlkID0gZXhjbHVkZUlkUmVnLnRlc3Qoc2VsZWN0KSB8fCAoc2VsZWN0ICYmIHNlbGVjdC5faWQgPT09IDApO1xuXG4gICAgLy8gTGVhbiB0cmFuc2Zvcm0gbWF5IGRlbGV0ZSBgX2lkYCwgd2hpY2ggd291bGQgY2F1c2UgYXNzaWdubWVudFxuICAgIC8vIHRvIGZhaWwuIFNvIGRlbGF5IHJ1bm5pbmcgbGVhbiB0cmFuc2Zvcm0gdW50aWwgX2FmdGVyX1xuICAgIC8vIGBfYXNzaWduKClgXG4gICAgaWYgKG1vZC5vcHRpb25zICYmXG4gICAgICAgIG1vZC5vcHRpb25zLm9wdGlvbnMgJiZcbiAgICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucy5sZWFuICYmXG4gICAgICAgIG1vZC5vcHRpb25zLm9wdGlvbnMubGVhbi50cmFuc2Zvcm0pIHtcbiAgICAgIG1vZC5vcHRpb25zLm9wdGlvbnMuX2xlYW5UcmFuc2Zvcm0gPSBtb2Qub3B0aW9ucy5vcHRpb25zLmxlYW4udHJhbnNmb3JtO1xuICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucy5sZWFuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCB8fCBpZHMuZXZlcnkodXRpbHMuaXNOdWxsT3JVbmRlZmluZWQpKSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBzZXQgdG8gMCBvciBlbXB0eSBhcnJheSBldmVuXG4gICAgICAvLyBpZiB3ZSBkb24ndCBhY3R1YWxseSBleGVjdXRlIGEgcXVlcnkgdG8gbWFrZSBzdXJlIHRoZXJlJ3MgYSB2YWx1ZVxuICAgICAgLy8gYW5kIHdlIGtub3cgdGhpcyBwYXRoIHdhcyBwb3B1bGF0ZWQgZm9yIGZ1dHVyZSBzZXRzLiBTZWUgZ2gtNzczMSwgZ2gtODIzMFxuICAgICAgLS1fcmVtYWluaW5nO1xuICAgICAgX2Fzc2lnbihtb2RlbCwgW10sIG1vZCwgYXNzaWdubWVudE9wdHMpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaGFzT25lID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIHBvcHVsYXRlT3B0aW9ucy5mb3JlaWduRmllbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtb2QuZm9yZWlnbkZpZWxkLmNsZWFyKCk7XG4gICAgICBtb2QuZm9yZWlnbkZpZWxkLmFkZChwb3B1bGF0ZU9wdGlvbnMuZm9yZWlnbkZpZWxkKTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBjcmVhdGVQb3B1bGF0ZVF1ZXJ5RmlsdGVyKGlkcywgbW9kLm1hdGNoLCBtb2QuZm9yZWlnbkZpZWxkLCBtb2QubW9kZWwsIG1vZC5vcHRpb25zLnNraXBJbnZhbGlkSWRzKTtcbiAgICBpZiAoYXNzaWdubWVudE9wdHMuZXhjbHVkZUlkKSB7XG4gICAgICAvLyBvdmVycmlkZSB0aGUgZXhjbHVzaW9uIGZyb20gdGhlIHF1ZXJ5IHNvIHdlIGNhbiB1c2UgdGhlIF9pZFxuICAgICAgLy8gZm9yIGRvY3VtZW50IG1hdGNoaW5nIGR1cmluZyBhc3NpZ25tZW50LiB3ZSdsbCBkZWxldGUgdGhlXG4gICAgICAvLyBfaWQgYmFjayBvZmYgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNlbGVjdCA9IHNlbGVjdC5yZXBsYWNlKGV4Y2x1ZGVJZFJlZ0dsb2JhbCwgJyAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIHNlbGVjdCBjb25kaXRpb25zIGJ5IGNvcHlpbmdcbiAgICAgICAgc2VsZWN0ID0geyAuLi5zZWxlY3QgfTtcbiAgICAgICAgZGVsZXRlIHNlbGVjdC5faWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZC5vcHRpb25zLm9wdGlvbnMgJiYgbW9kLm9wdGlvbnMub3B0aW9ucy5saW1pdCAhPSBudWxsKSB7XG4gICAgICBhc3NpZ25tZW50T3B0cy5vcmlnaW5hbExpbWl0ID0gbW9kLm9wdGlvbnMub3B0aW9ucy5saW1pdDtcbiAgICB9IGVsc2UgaWYgKG1vZC5vcHRpb25zLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGFzc2lnbm1lbnRPcHRzLm9yaWdpbmFsTGltaXQgPSBtb2Qub3B0aW9ucy5saW1pdDtcbiAgICB9XG4gICAgcGFyYW1zLnB1c2goW21vZCwgbWF0Y2gsIHNlbGVjdCwgYXNzaWdubWVudE9wdHMsIF9uZXh0XSk7XG4gIH1cbiAgaWYgKCFoYXNPbmUpIHtcbiAgICAvLyBJZiBtb2RlbHMgYnV0IG5vIGRvY3MsIHNraXAgZnVydGhlciBkZWVwIHBvcHVsYXRlLlxuICAgIGlmIChtb2RlbHNNYXAubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gSWYgbm8gbW9kZWxzIHRvIHBvcHVsYXRlIGJ1dCB3ZSBoYXZlIGEgbmVzdGVkIHBvcHVsYXRlLFxuICAgIC8vIGtlZXAgdHJ5aW5nLCByZTogZ2gtODk0NlxuICAgIGlmIChwb3B1bGF0ZU9wdGlvbnMucG9wdWxhdGUgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgb3B0cyA9IHV0aWxzLnBvcHVsYXRlKHBvcHVsYXRlT3B0aW9ucy5wb3B1bGF0ZSkubWFwKHBvcCA9PiBPYmplY3QuYXNzaWduKHt9LCBwb3AsIHtcbiAgICAgICAgcGF0aDogcG9wdWxhdGVPcHRpb25zLnBhdGggKyAnLicgKyBwb3AucGF0aFxuICAgICAgfSkpO1xuICAgICAgbW9kZWwucG9wdWxhdGUoZG9jcywgb3B0cykudGhlbihyZXMgPT4geyBjYWxsYmFjayhudWxsLCByZXMpOyB9LCBlcnIgPT4geyBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGFyciBvZiBwYXJhbXMpIHtcbiAgICBfZXhlY1BvcHVsYXRlUXVlcnkuYXBwbHkobnVsbCwgYXJyKTtcbiAgfVxuICBmdW5jdGlvbiBfbmV4dChlcnIsIHZhbHNGcm9tRGIpIHtcbiAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgIH1cbiAgICB2YWxzID0gdmFscy5jb25jYXQodmFsc0Zyb21EYik7XG4gICAgaWYgKC0tX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgX2RvbmUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZG9uZSgpIHtcbiAgICBmb3IgKGNvbnN0IGFyciBvZiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IG1vZCA9IGFyclswXTtcbiAgICAgIGNvbnN0IGFzc2lnbm1lbnRPcHRzID0gYXJyWzNdO1xuICAgICAgZm9yIChjb25zdCB2YWwgb2YgdmFscykge1xuICAgICAgICBtb2Qub3B0aW9ucy5fY2hpbGREb2NzLnB1c2godmFsKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIF9hc3NpZ24obW9kZWwsIHZhbHMsIG1vZCwgYXNzaWdubWVudE9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgYXJyIG9mIHBhcmFtcykge1xuICAgICAgcmVtb3ZlRGVzZWxlY3RlZEZvcmVpZ25GaWVsZChhcnJbMF0uZm9yZWlnbkZpZWxkLCBhcnJbMF0ub3B0aW9ucywgdmFscyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXJyIG9mIHBhcmFtcykge1xuICAgICAgY29uc3QgbW9kID0gYXJyWzBdO1xuICAgICAgaWYgKG1vZC5vcHRpb25zICYmIG1vZC5vcHRpb25zLm9wdGlvbnMgJiYgbW9kLm9wdGlvbnMub3B0aW9ucy5fbGVhblRyYW5zZm9ybSkge1xuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiB2YWxzKSB7XG4gICAgICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucy5fbGVhblRyYW5zZm9ybShkb2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXhlY1BvcHVsYXRlUXVlcnkobW9kLCBtYXRjaCwgc2VsZWN0LCBhc3NpZ25tZW50T3B0cywgY2FsbGJhY2spIHtcbiAgbGV0IHN1YlBvcHVsYXRlID0gY2xvbmUobW9kLm9wdGlvbnMucG9wdWxhdGUpO1xuICBjb25zdCBxdWVyeU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBza2lwOiBtb2Qub3B0aW9ucy5za2lwLFxuICAgIGxpbWl0OiBtb2Qub3B0aW9ucy5saW1pdCxcbiAgICBwZXJEb2N1bWVudExpbWl0OiBtb2Qub3B0aW9ucy5wZXJEb2N1bWVudExpbWl0XG4gIH0sIG1vZC5vcHRpb25zLm9wdGlvbnMpO1xuXG4gIGlmIChtb2QuY291bnQpIHtcbiAgICBkZWxldGUgcXVlcnlPcHRpb25zLnNraXA7XG4gIH1cblxuICBpZiAocXVlcnlPcHRpb25zLnBlckRvY3VtZW50TGltaXQgIT0gbnVsbCkge1xuICAgIHF1ZXJ5T3B0aW9ucy5saW1pdCA9IHF1ZXJ5T3B0aW9ucy5wZXJEb2N1bWVudExpbWl0O1xuICAgIGRlbGV0ZSBxdWVyeU9wdGlvbnMucGVyRG9jdW1lbnRMaW1pdDtcbiAgfSBlbHNlIGlmIChxdWVyeU9wdGlvbnMubGltaXQgIT0gbnVsbCkge1xuICAgIHF1ZXJ5T3B0aW9ucy5saW1pdCA9IHF1ZXJ5T3B0aW9ucy5saW1pdCAqIG1vZC5pZHMubGVuZ3RoO1xuICB9XG5cbiAgY29uc3QgcXVlcnkgPSBtb2QubW9kZWwuZmluZChtYXRjaCwgc2VsZWN0LCBxdWVyeU9wdGlvbnMpO1xuICAvLyBJZiB3ZSdyZSBkb2luZyB2aXJ0dWFsIHBvcHVsYXRlIGFuZCBwcm9qZWN0aW9uIGlzIGluY2x1c2l2ZSBhbmQgZm9yZWlnblxuICAvLyBmaWVsZCBpcyBub3Qgc2VsZWN0ZWQsIGF1dG9tYXRpY2FsbHkgc2VsZWN0IGl0IGJlY2F1c2UgbW9uZ29vc2UgbmVlZHMgaXQuXG4gIC8vIElmIHByb2plY3Rpb24gaXMgZXhjbHVzaXZlIGFuZCBjbGllbnQgZXhwbGljaXRseSB1bnNlbGVjdGVkIHRoZSBmb3JlaWduXG4gIC8vIGZpZWxkLCB0aGF0J3MgdGhlIGNsaWVudCdzIGZhdWx0LlxuICBmb3IgKGNvbnN0IGZvcmVpZ25GaWVsZCBvZiBtb2QuZm9yZWlnbkZpZWxkKSB7XG4gICAgaWYgKGZvcmVpZ25GaWVsZCAhPT0gJ19pZCcgJiZcbiAgICAgICAgcXVlcnkuc2VsZWN0ZWRJbmNsdXNpdmVseSgpICYmXG4gICAgICAgICFpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZShxdWVyeS5fZmllbGRzLCBmb3JlaWduRmllbGQpKSB7XG4gICAgICBxdWVyeS5zZWxlY3QoZm9yZWlnbkZpZWxkKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB1c2luZyBjb3VudCwgc3RpbGwgbmVlZCB0aGUgYGZvcmVpZ25GaWVsZGAgc28gd2UgY2FuIG1hdGNoIGNvdW50c1xuICAvLyB0byBkb2N1bWVudHMsIG90aGVyd2lzZSB3ZSB3b3VsZCBuZWVkIGEgc2VwYXJhdGUgYGNvdW50KClgIGZvciBldmVyeSBkb2MuXG4gIGlmIChtb2QuY291bnQpIHtcbiAgICBmb3IgKGNvbnN0IGZvcmVpZ25GaWVsZCBvZiBtb2QuZm9yZWlnbkZpZWxkKSB7XG4gICAgICBxdWVyeS5zZWxlY3QoZm9yZWlnbkZpZWxkKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBuZWVkIHRvIHN1Yi1wb3B1bGF0ZSwgY2FsbCBwb3B1bGF0ZSByZWN1cnNpdmVseVxuICBpZiAoc3ViUG9wdWxhdGUpIHtcbiAgICAvLyBJZiBzdWJwb3B1bGF0aW5nIG9uIGEgZGlzY3JpbWluYXRvciwgc2tpcCBjaGVjayBmb3Igbm9uLWV4aXN0ZW50XG4gICAgLy8gcGF0aHMuIEJlY2F1c2UgdGhlIGRpc2NyaW1pbmF0b3IgbWF5IG5vdCBoYXZlIHRoZSBwYXRoIGRlZmluZWQuXG4gICAgaWYgKG1vZC5tb2RlbC5iYXNlTW9kZWxOYW1lICE9IG51bGwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YlBvcHVsYXRlKSkge1xuICAgICAgICBzdWJQb3B1bGF0ZS5mb3JFYWNoKHBvcCA9PiB7IHBvcC5zdHJpY3RQb3B1bGF0ZSA9IGZhbHNlOyB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1YlBvcHVsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBzdWJQb3B1bGF0ZSA9IHsgcGF0aDogc3ViUG9wdWxhdGUsIHN0cmljdFBvcHVsYXRlOiBmYWxzZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ViUG9wdWxhdGUuc3RyaWN0UG9wdWxhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmFzZVBhdGggPSBtb2Qub3B0aW9ucy5fZnVsbFBhdGggfHwgbW9kLm9wdGlvbnMucGF0aDtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHN1YlBvcHVsYXRlKSkge1xuICAgICAgZm9yIChjb25zdCBwb3Agb2Ygc3ViUG9wdWxhdGUpIHtcbiAgICAgICAgcG9wLl9mdWxsUGF0aCA9IGJhc2VQYXRoICsgJy4nICsgcG9wLnBhdGg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3ViUG9wdWxhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBzdWJQb3B1bGF0ZS5fZnVsbFBhdGggPSBiYXNlUGF0aCArICcuJyArIHN1YlBvcHVsYXRlLnBhdGg7XG4gICAgfVxuXG4gICAgcXVlcnkucG9wdWxhdGUoc3ViUG9wdWxhdGUpO1xuICB9XG5cbiAgcXVlcnkuZXhlYygpLnRoZW4oXG4gICAgZG9jcyA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHZhbCBvZiBkb2NzKSB7XG4gICAgICAgIGxlYW5Qb3B1bGF0ZU1hcC5zZXQodmFsLCBtb2QubW9kZWwpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgZG9jcyk7XG4gICAgfSxcbiAgICBlcnIgPT4ge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2Fzc2lnbihtb2RlbCwgdmFscywgbW9kLCBhc3NpZ25tZW50T3B0cykge1xuICBjb25zdCBvcHRpb25zID0gbW9kLm9wdGlvbnM7XG4gIGNvbnN0IGlzVmlydHVhbCA9IG1vZC5pc1ZpcnR1YWw7XG4gIGNvbnN0IGp1c3RPbmUgPSBtb2QuanVzdE9uZTtcbiAgbGV0IF92YWw7XG4gIGNvbnN0IGxlYW4gPSBvcHRpb25zICYmXG4gICAgb3B0aW9ucy5vcHRpb25zICYmXG4gICAgb3B0aW9ucy5vcHRpb25zLmxlYW4gfHwgZmFsc2U7XG4gIGNvbnN0IGxlbiA9IHZhbHMubGVuZ3RoO1xuICBjb25zdCByYXdPcmRlciA9IHt9O1xuICBjb25zdCByYXdEb2NzID0ge307XG4gIGxldCBrZXk7XG4gIGxldCB2YWw7XG5cbiAgLy8gQ2xvbmUgYmVjYXVzZSBgYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmVgIHdpbGwgbXV0YXRlIHRoZSBhcnJheVxuICBjb25zdCBhbGxJZHMgPSBjbG9uZShtb2QuYWxsSWRzKTtcbiAgLy8gb3B0aW1pemF0aW9uOlxuICAvLyByZWNvcmQgdGhlIGRvY3VtZW50IHBvc2l0aW9ucyBhcyByZXR1cm5lZCBieVxuICAvLyB0aGUgcXVlcnkgcmVzdWx0LlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFsID0gdmFsc1tpXTtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZvcmVpZ25GaWVsZCBvZiBtb2QuZm9yZWlnbkZpZWxkKSB7XG4gICAgICBfdmFsID0gdXRpbHMuZ2V0VmFsdWUoZm9yZWlnbkZpZWxkLCB2YWwpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3ZhbCkpIHtcbiAgICAgICAgX3ZhbCA9IHV0aWxzLmFycmF5LnVuaXF1ZSh1dGlscy5hcnJheS5mbGF0dGVuKF92YWwpKTtcblxuICAgICAgICBmb3IgKGxldCBfX3ZhbCBvZiBfdmFsKSB7XG4gICAgICAgICAgaWYgKF9fdmFsIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIF9fdmFsID0gX192YWwuX2lkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXkgPSBTdHJpbmcoX192YWwpO1xuICAgICAgICAgIGlmIChyYXdEb2NzW2tleV0pIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd0RvY3Nba2V5XSkpIHtcbiAgICAgICAgICAgICAgcmF3RG9jc1trZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgcmF3T3JkZXJba2V5XS5wdXNoKGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmF3RG9jc1trZXldID0gW3Jhd0RvY3Nba2V5XSwgdmFsXTtcbiAgICAgICAgICAgICAgcmF3T3JkZXJba2V5XSA9IFtyYXdPcmRlcltrZXldLCBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzVmlydHVhbCAmJiAhanVzdE9uZSkge1xuICAgICAgICAgICAgICByYXdEb2NzW2tleV0gPSBbdmFsXTtcbiAgICAgICAgICAgICAgcmF3T3JkZXJba2V5XSA9IFtpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJhd0RvY3Nba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgcmF3T3JkZXJba2V5XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX3ZhbCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgICAgX3ZhbCA9IF92YWwuX2lkO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IFN0cmluZyhfdmFsKTtcbiAgICAgICAgaWYgKHJhd0RvY3Nba2V5XSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd0RvY3Nba2V5XSkpIHtcbiAgICAgICAgICAgIHJhd0RvY3Nba2V5XS5wdXNoKHZhbCk7XG4gICAgICAgICAgICByYXdPcmRlcltrZXldLnB1c2goaSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1ZpcnR1YWwgfHxcbiAgICAgICAgICAgIHJhd0RvY3Nba2V5XS5jb25zdHJ1Y3RvciAhPT0gdmFsLmNvbnN0cnVjdG9yIHx8XG4gICAgICAgICAgICBTdHJpbmcocmF3RG9jc1trZXldLl9pZCkgIT09IFN0cmluZyh2YWwuX2lkKSkge1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gc3RvcmUgbXVsdGlwbGUgZG9jcyB3aXRoIHRoZSBzYW1lIGlkIGlmIHRoZXJlJ3MgbXVsdGlwbGUgbW9kZWxzXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGRpc2NyaW1pbmF0b3JzIG9yIGEgcmVmIGZ1bmN0aW9uLiBCdXQgYXZvaWQgY29udmVydGluZyB0byBhbiBhcnJheVxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBxdWVyaWVzIG9uIHRoZSBzYW1lIG1vZGVsIGJlY2F1c2Ugb2YgYHBlckRvY3VtZW50TGltaXRgIHJlOiBnaC05OTA2XG4gICAgICAgICAgICByYXdEb2NzW2tleV0gPSBbcmF3RG9jc1trZXldLCB2YWxdO1xuICAgICAgICAgICAgcmF3T3JkZXJba2V5XSA9IFtyYXdPcmRlcltrZXldLCBpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmF3RG9jc1trZXldID0gdmFsO1xuICAgICAgICAgIHJhd09yZGVyW2tleV0gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBmbGFnIGVhY2ggYXMgcmVzdWx0IG9mIHBvcHVsYXRpb25cbiAgICAgIGlmICghbGVhbikge1xuICAgICAgICB2YWwuJF9fLndhc1BvcHVsYXRlZCA9IHZhbC4kX18ud2FzUG9wdWxhdGVkIHx8IHsgdmFsdWU6IF92YWwgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3NpZ25WYWxzKHtcbiAgICBvcmlnaW5hbE1vZGVsOiBtb2RlbCxcbiAgICAvLyBJZiB2aXJ0dWFsLCBtYWtlIHN1cmUgdG8gbm90IG11dGF0ZSBvcmlnaW5hbCBmaWVsZFxuICAgIHJhd0lkczogbW9kLmlzVmlydHVhbCA/IGFsbElkcyA6IG1vZC5hbGxJZHMsXG4gICAgYWxsSWRzOiBhbGxJZHMsXG4gICAgdW5wb3B1bGF0ZWRWYWx1ZXM6IG1vZC51bnBvcHVsYXRlZFZhbHVlcyxcbiAgICBmb3JlaWduRmllbGQ6IG1vZC5mb3JlaWduRmllbGQsXG4gICAgcmF3RG9jczogcmF3RG9jcyxcbiAgICByYXdPcmRlcjogcmF3T3JkZXIsXG4gICAgZG9jczogbW9kLmRvY3MsXG4gICAgcGF0aDogb3B0aW9ucy5wYXRoLFxuICAgIG9wdGlvbnM6IGFzc2lnbm1lbnRPcHRzLFxuICAgIGp1c3RPbmU6IG1vZC5qdXN0T25lLFxuICAgIGlzVmlydHVhbDogbW9kLmlzVmlydHVhbCxcbiAgICBhbGxPcHRpb25zOiBtb2QsXG4gICAgcG9wdWxhdGVkTW9kZWw6IG1vZC5tb2RlbCxcbiAgICBsZWFuOiBsZWFuLFxuICAgIHZpcnR1YWw6IG1vZC52aXJ0dWFsLFxuICAgIGNvdW50OiBtb2QuY291bnQsXG4gICAgbWF0Y2g6IG1vZC5tYXRjaFxuICB9KTtcbn1cblxuLyoqXG4gKiBDb21waWxlciB1dGlsaXR5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBuYW1lIG1vZGVsIG5hbWUgb3IgY2xhc3MgZXh0ZW5kaW5nIE1vZGVsXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQHBhcmFtIHtNb25nb29zZX0gYmFzZSBtb25nb29zZSBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTW9kZWwuY29tcGlsZSA9IGZ1bmN0aW9uIGNvbXBpbGUobmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uTmFtZSwgY29ubmVjdGlvbiwgYmFzZSkge1xuICBjb25zdCB2ZXJzaW9uaW5nRW5hYmxlZCA9IHNjaGVtYS5vcHRpb25zLnZlcnNpb25LZXkgIT09IGZhbHNlO1xuXG4gIGlmICh2ZXJzaW9uaW5nRW5hYmxlZCAmJiAhc2NoZW1hLnBhdGhzW3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXldKSB7XG4gICAgLy8gYWRkIHZlcnNpb25pbmcgdG8gdG9wIGxldmVsIGRvY3VtZW50cyBvbmx5XG4gICAgY29uc3QgbyA9IHt9O1xuICAgIG9bc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleV0gPSBOdW1iZXI7XG4gICAgc2NoZW1hLmFkZChvKTtcbiAgfVxuICBsZXQgbW9kZWw7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJyAmJiBuYW1lLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgbW9kZWwgPSBuYW1lO1xuICAgIG5hbWUgPSBtb2RlbC5uYW1lO1xuICAgIHNjaGVtYS5sb2FkQ2xhc3MobW9kZWwsIGZhbHNlKTtcbiAgICBtb2RlbC5wcm90b3R5cGUuJGlzTW9uZ29vc2VNb2RlbFByb3RvdHlwZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2VuZXJhdGUgbmV3IGNsYXNzXG4gICAgbW9kZWwgPSBmdW5jdGlvbiBtb2RlbChkb2MsIGZpZWxkcywgc2tpcElkKSB7XG4gICAgICBtb2RlbC5ob29rcy5leGVjUHJlU3luYygnY3JlYXRlTW9kZWwnLCBkb2MpO1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIG1vZGVsKSkge1xuICAgICAgICByZXR1cm4gbmV3IG1vZGVsKGRvYywgZmllbGRzLCBza2lwSWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IG1vZGVsLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG5cbiAgICAgIGlmIChtb2RlbC5kaXNjcmltaW5hdG9ycyA9PSBudWxsIHx8IGRvYyA9PSBudWxsIHx8IGRvY1tkaXNjcmltaW5hdG9yS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIE1vZGVsLmNhbGwodGhpcywgZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZGlzY3JpbWluYXRvciBrZXkgaXMgc2V0LCB1c2UgdGhlIGRpc2NyaW1pbmF0b3IgaW5zdGVhZCAoZ2gtNzU4NilcbiAgICAgIGNvbnN0IERpc2NyaW1pbmF0b3IgPSBtb2RlbC5kaXNjcmltaW5hdG9yc1tkb2NbZGlzY3JpbWluYXRvcktleV1dIHx8XG4gICAgICAgIGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKG1vZGVsLmRpc2NyaW1pbmF0b3JzLCBkb2NbZGlzY3JpbWluYXRvcktleV0pO1xuICAgICAgaWYgKERpc2NyaW1pbmF0b3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IERpc2NyaW1pbmF0b3IoZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwganVzdCB1c2UgdGhlIHRvcC1sZXZlbCBtb2RlbFxuICAgICAgTW9kZWwuY2FsbCh0aGlzLCBkb2MsIGZpZWxkcywgc2tpcElkKTtcbiAgICB9O1xuICB9XG5cbiAgbW9kZWwuaG9va3MgPSBzY2hlbWEucy5ob29rcy5jbG9uZSgpO1xuICBtb2RlbC5iYXNlID0gYmFzZTtcbiAgbW9kZWwubW9kZWxOYW1lID0gbmFtZTtcblxuICBpZiAoIShtb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobW9kZWwsIE1vZGVsKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobW9kZWwucHJvdG90eXBlLCBNb2RlbC5wcm90b3R5cGUpO1xuICB9XG4gIG1vZGVsLm1vZGVsID0gZnVuY3Rpb24gbW9kZWwobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmRiLm1vZGVsKG5hbWUpO1xuICB9O1xuXG4gIG1vZGVsLmRiID0gY29ubmVjdGlvbjtcbiAgbW9kZWwucHJvdG90eXBlLmRiID0gY29ubmVjdGlvbjtcbiAgbW9kZWwucHJvdG90eXBlW21vZGVsRGJTeW1ib2xdID0gY29ubmVjdGlvbjtcbiAgbW9kZWwuZGlzY3JpbWluYXRvcnMgPSBtb2RlbC5wcm90b3R5cGUuZGlzY3JpbWluYXRvcnMgPSB1bmRlZmluZWQ7XG4gIG1vZGVsW21vZGVsU3ltYm9sXSA9IHRydWU7XG4gIG1vZGVsLmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBzY2hlbWEuX3ByZUNvbXBpbGUoKTtcblxuICBjb25zdCBfdXNlclByb3ZpZGVkT3B0aW9ucyA9IHNjaGVtYS5fdXNlclByb3ZpZGVkT3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBjb2xsZWN0aW9uT3B0aW9ucyA9IHtcbiAgICBzY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zOiBfdXNlclByb3ZpZGVkT3B0aW9ucyxcbiAgICBjYXBwZWQ6IHNjaGVtYS5vcHRpb25zLmNhcHBlZCxcbiAgICBQcm9taXNlOiBtb2RlbC5iYXNlLlByb21pc2UsXG4gICAgbW9kZWxOYW1lOiBuYW1lXG4gIH07XG4gIGlmIChzY2hlbWEub3B0aW9ucy5hdXRvQ3JlYXRlICE9PSB2b2lkIDApIHtcbiAgICBjb2xsZWN0aW9uT3B0aW9ucy5hdXRvQ3JlYXRlID0gc2NoZW1hLm9wdGlvbnMuYXV0b0NyZWF0ZTtcbiAgfVxuXG4gIGNvbnN0IGNvbGxlY3Rpb24gPSBjb25uZWN0aW9uLmNvbGxlY3Rpb24oXG4gICAgY29sbGVjdGlvbk5hbWUsXG4gICAgY29sbGVjdGlvbk9wdGlvbnNcbiAgKTtcblxuICBtb2RlbC5wcm90b3R5cGUuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gIG1vZGVsLnByb3RvdHlwZS4kY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gIG1vZGVsLnByb3RvdHlwZVttb2RlbENvbGxlY3Rpb25TeW1ib2xdID0gY29sbGVjdGlvbjtcblxuICBtb2RlbC5wcm90b3R5cGUuJF9fc2V0U2NoZW1hKHNjaGVtYSk7XG5cbiAgLy8gYXBwbHkgbWV0aG9kcyBhbmQgc3RhdGljc1xuICBhcHBseU1ldGhvZHMobW9kZWwsIHNjaGVtYSk7XG4gIGFwcGx5U3RhdGljcyhtb2RlbCwgc2NoZW1hKTtcbiAgYXBwbHlIb29rcyhtb2RlbCwgc2NoZW1hKTtcbiAgYXBwbHlTdGF0aWNIb29rcyhtb2RlbCwgc2NoZW1hLnMuaG9va3MsIHNjaGVtYS5zdGF0aWNzKTtcblxuICBtb2RlbC5zY2hlbWEgPSBtb2RlbC5wcm90b3R5cGUuJF9fc2NoZW1hO1xuICBtb2RlbC5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgbW9kZWwuJF9fY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG5cbiAgLy8gQ3JlYXRlIGN1c3RvbSBxdWVyeSBjb25zdHJ1Y3RvclxuICBtb2RlbC5RdWVyeSA9IGZ1bmN0aW9uKCkge1xuICAgIFF1ZXJ5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihtb2RlbC5RdWVyeS5wcm90b3R5cGUsIFF1ZXJ5LnByb3RvdHlwZSk7XG4gIG1vZGVsLlF1ZXJ5LmJhc2UgPSBRdWVyeS5iYXNlO1xuICBtb2RlbC5RdWVyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRdWVyeTtcbiAgYXBwbHlRdWVyeU1pZGRsZXdhcmUobW9kZWwuUXVlcnksIG1vZGVsKTtcbiAgYXBwbHlRdWVyeU1ldGhvZHMobW9kZWwsIHNjaGVtYS5xdWVyeSk7XG5cbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBjdXN0b20gcXVlcnkgbWV0aG9kcyBmb3IgdGhpcyBtb2RlbFxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVF1ZXJ5TWV0aG9kcyhtb2RlbCwgbWV0aG9kcykge1xuICBmb3IgKGNvbnN0IGkgaW4gbWV0aG9kcykge1xuICAgIG1vZGVsLlF1ZXJ5LnByb3RvdHlwZVtpXSA9IG1ldGhvZHNbaV07XG4gIH1cbn1cblxuLyoqXG4gKiBTdWJjbGFzcyB0aGlzIG1vZGVsIHdpdGggYGNvbm5gLCBgc2NoZW1hYCwgYW5kIGBjb2xsZWN0aW9uYCBzZXR0aW5ncy5cbiAqXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5cbiAqIEBwYXJhbSB7U2NoZW1hfSBbc2NoZW1hXVxuICogQHBhcmFtIHtTdHJpbmd9IFtjb2xsZWN0aW9uXVxuICogQHJldHVybiB7TW9kZWx9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQHN0YXRpY1xuICogQG1ldGhvZCBfX3N1YmNsYXNzXG4gKi9cblxuTW9kZWwuX19zdWJjbGFzcyA9IGZ1bmN0aW9uIHN1YmNsYXNzKGNvbm4sIHNjaGVtYSwgY29sbGVjdGlvbikge1xuICAvLyBzdWJjbGFzcyBtb2RlbCB1c2luZyB0aGlzIGNvbm5lY3Rpb24gYW5kIGNvbGxlY3Rpb24gbmFtZVxuICBjb25zdCBfdGhpcyA9IHRoaXM7XG5cbiAgY29uc3QgTW9kZWwgPSBmdW5jdGlvbiBNb2RlbChkb2MsIGZpZWxkcywgc2tpcElkKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vZGVsKSkge1xuICAgICAgcmV0dXJuIG5ldyBNb2RlbChkb2MsIGZpZWxkcywgc2tpcElkKTtcbiAgICB9XG4gICAgX3RoaXMuY2FsbCh0aGlzLCBkb2MsIGZpZWxkcywgc2tpcElkKTtcbiAgfTtcblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoTW9kZWwsIF90aGlzKTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKE1vZGVsLnByb3RvdHlwZSwgX3RoaXMucHJvdG90eXBlKTtcbiAgTW9kZWwuZGIgPSBjb25uO1xuICBNb2RlbC5wcm90b3R5cGUuZGIgPSBjb25uO1xuICBNb2RlbC5wcm90b3R5cGVbbW9kZWxEYlN5bWJvbF0gPSBjb25uO1xuXG4gIF90aGlzW3N1YmNsYXNzZWRTeW1ib2xdID0gX3RoaXNbc3ViY2xhc3NlZFN5bWJvbF0gfHwgW107XG4gIF90aGlzW3N1YmNsYXNzZWRTeW1ib2xdLnB1c2goTW9kZWwpO1xuICBpZiAoX3RoaXMuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgIE1vZGVsLmRpc2NyaW1pbmF0b3JzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoX3RoaXMuZGlzY3JpbWluYXRvcnMpKSB7XG4gICAgICBNb2RlbC5kaXNjcmltaW5hdG9yc1trZXldID0gX3RoaXMuZGlzY3JpbWluYXRvcnNba2V5XS5cbiAgICAgICAgX19zdWJjbGFzcyhfdGhpcy5kYiwgX3RoaXMuZGlzY3JpbWluYXRvcnNba2V5XS5zY2hlbWEsIGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHMgPSBzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSAhPT0gJ3N0cmluZydcbiAgICA/IHNjaGVtYVxuICAgIDogX3RoaXMucHJvdG90eXBlLiRfX3NjaGVtYTtcblxuICBjb25zdCBvcHRpb25zID0gcy5vcHRpb25zIHx8IHt9O1xuICBjb25zdCBfdXNlclByb3ZpZGVkT3B0aW9ucyA9IHMuX3VzZXJQcm92aWRlZE9wdGlvbnMgfHwge307XG5cbiAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgY29sbGVjdGlvbiA9IF90aGlzLnByb3RvdHlwZS4kX19zY2hlbWEuZ2V0KCdjb2xsZWN0aW9uJykgfHxcbiAgICAgIHV0aWxzLnRvQ29sbGVjdGlvbk5hbWUoX3RoaXMubW9kZWxOYW1lLCB0aGlzLmJhc2UucGx1cmFsaXplKCkpO1xuICB9XG5cbiAgY29uc3QgY29sbGVjdGlvbk9wdGlvbnMgPSB7XG4gICAgc2NoZW1hVXNlclByb3ZpZGVkT3B0aW9uczogX3VzZXJQcm92aWRlZE9wdGlvbnMsXG4gICAgY2FwcGVkOiBzICYmIG9wdGlvbnMuY2FwcGVkXG4gIH07XG5cbiAgTW9kZWwucHJvdG90eXBlLmNvbGxlY3Rpb24gPSBjb25uLmNvbGxlY3Rpb24oY29sbGVjdGlvbiwgY29sbGVjdGlvbk9wdGlvbnMpO1xuICBNb2RlbC5wcm90b3R5cGUuJGNvbGxlY3Rpb24gPSBNb2RlbC5wcm90b3R5cGUuY29sbGVjdGlvbjtcbiAgTW9kZWwucHJvdG90eXBlW21vZGVsQ29sbGVjdGlvblN5bWJvbF0gPSBNb2RlbC5wcm90b3R5cGUuY29sbGVjdGlvbjtcbiAgTW9kZWwuY29sbGVjdGlvbiA9IE1vZGVsLnByb3RvdHlwZS5jb2xsZWN0aW9uO1xuICBNb2RlbC4kX19jb2xsZWN0aW9uID0gTW9kZWwuY29sbGVjdGlvbjtcbiAgLy8gRXJyb3JzIGhhbmRsZWQgaW50ZXJuYWxseSwgc28gaWdub3JlXG4gIE1vZGVsLmluaXQoKS5jYXRjaCgoKSA9PiB7fSk7XG4gIHJldHVybiBNb2RlbDtcbn07XG5cbi8qKlxuICogSGVscGVyIGZvciBjb25zb2xlLmxvZy4gR2l2ZW4gYSBtb2RlbCBuYW1lZCAnTXlNb2RlbCcsIHJldHVybnMgdGhlIHN0cmluZ1xuICogYCdNb2RlbCB7IE15TW9kZWwgfSdgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgTXlNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqICAgICBNeU1vZGVsLmluc3BlY3QoKTsgLy8gJ01vZGVsIHsgVGVzdCB9J1xuICogICAgIGNvbnNvbGUubG9nKE15TW9kZWwpOyAvLyBQcmludHMgJ01vZGVsIHsgVGVzdCB9J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYE1vZGVsIHsgJHt0aGlzLm1vZGVsTmFtZX0gfWA7XG59O1xuXG5pZiAodXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICAvLyBBdm9pZCBOb2RlIGRlcHJlY2F0aW9uIHdhcm5pbmcgREVQMDA3OVxuICBNb2RlbFt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IE1vZGVsLmluc3BlY3Q7XG59XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gTW9kZWw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/model.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options.js":
/*!******************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nexports.internalToObjectOptions = {\n  transform: false,\n  virtuals: false,\n  getters: false,\n  _skipDepopulateTopLevel: true,\n  depopulate: true,\n  flattenDecimals: false,\n  useProjection: false\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxvcHRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmludGVybmFsVG9PYmplY3RPcHRpb25zID0ge1xuICB0cmFuc2Zvcm06IGZhbHNlLFxuICB2aXJ0dWFsczogZmFsc2UsXG4gIGdldHRlcnM6IGZhbHNlLFxuICBfc2tpcERlcG9wdWxhdGVUb3BMZXZlbDogdHJ1ZSxcbiAgZGVwb3B1bGF0ZTogdHJ1ZSxcbiAgZmxhdHRlbkRlY2ltYWxzOiBmYWxzZSxcbiAgdXNlUHJvamVjdGlvbjogZmFsc2Vcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/PopulateOptions.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/PopulateOptions.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\n\nclass PopulateOptions {\n  constructor(obj) {\n    this._docs = {};\n    this._childDocs = [];\n\n    if (obj == null) {\n      return;\n    }\n    obj = clone(obj);\n    Object.assign(this, obj);\n    if (typeof obj.subPopulate === 'object') {\n      this.populate = obj.subPopulate;\n    }\n\n\n    if (obj.perDocumentLimit != null && obj.limit != null) {\n      throw new Error('Can not use `limit` and `perDocumentLimit` at the same time. Path: `' + obj.path + '`.');\n    }\n  }\n}\n\n/**\n * The connection used to look up models by name. If not specified, Mongoose\n * will default to using the connection associated with the model in\n * `PopulateOptions#model`.\n *\n * @memberOf PopulateOptions\n * @property {Connection} connection\n * @api public\n */\n\nmodule.exports = PopulateOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9Qb3B1bGF0ZU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLG9GQUFrQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXG9wdGlvbnNcXFBvcHVsYXRlT3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi4vaGVscGVycy9jbG9uZScpO1xuXG5jbGFzcyBQb3B1bGF0ZU9wdGlvbnMge1xuICBjb25zdHJ1Y3RvcihvYmopIHtcbiAgICB0aGlzLl9kb2NzID0ge307XG4gICAgdGhpcy5fY2hpbGREb2NzID0gW107XG5cbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb2JqID0gY2xvbmUob2JqKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9iaik7XG4gICAgaWYgKHR5cGVvZiBvYmouc3ViUG9wdWxhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLnBvcHVsYXRlID0gb2JqLnN1YlBvcHVsYXRlO1xuICAgIH1cblxuXG4gICAgaWYgKG9iai5wZXJEb2N1bWVudExpbWl0ICE9IG51bGwgJiYgb2JqLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCB1c2UgYGxpbWl0YCBhbmQgYHBlckRvY3VtZW50TGltaXRgIGF0IHRoZSBzYW1lIHRpbWUuIFBhdGg6IGAnICsgb2JqLnBhdGggKyAnYC4nKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgY29ubmVjdGlvbiB1c2VkIHRvIGxvb2sgdXAgbW9kZWxzIGJ5IG5hbWUuIElmIG5vdCBzcGVjaWZpZWQsIE1vbmdvb3NlXG4gKiB3aWxsIGRlZmF1bHQgdG8gdXNpbmcgdGhlIGNvbm5lY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBtb2RlbCBpblxuICogYFBvcHVsYXRlT3B0aW9ucyNtb2RlbGAuXG4gKlxuICogQG1lbWJlck9mIFBvcHVsYXRlT3B0aW9uc1xuICogQHByb3BlcnR5IHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9wdWxhdGVPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/PopulateOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/SchemaArrayOptions.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/SchemaArrayOptions.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./SchemaTypeOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\");\n\n/**\n * The options defined on an Array schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ tags: [String] });\n *     schema.path('tags').options; // SchemaArrayOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaArrayOptions\n */\n\nclass SchemaArrayOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If this is an array of strings, an array of allowed values for this path.\n * Throws an error if this array isn't an array of strings.\n *\n * @api public\n * @property enum\n * @memberOf SchemaArrayOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaArrayOptions.prototype, 'enum', opts);\n\n/**\n * If set, specifies the type of this array's values. Equivalent to setting\n * `type` to an array whose first element is `of`.\n *\n * #### Example:\n *\n *     // `arr` is an array of numbers.\n *     new Schema({ arr: [Number] });\n *     // Equivalent way to define `arr` as an array of numbers\n *     new Schema({ arr: { type: Array, of: Number } });\n *\n * @api public\n * @property of\n * @memberOf SchemaArrayOptions\n * @type {Function|String}\n * @instance\n */\n\nObject.defineProperty(SchemaArrayOptions.prototype, 'of', opts);\n\n/**\n * If set to `false`, will always deactivate casting non-array values to arrays.\n * If set to `true`, will cast non-array values to arrays if `init` and `SchemaArray.options.castNonArrays` are also `true`\n *\n * #### Example:\n *\n *     const Model = db.model('Test', new Schema({ x1: { castNonArrays: false, type: [String] } }));\n *     const doc = new Model({ x1: \"some non-array value\" });\n *     await doc.validate(); // Errors with \"CastError\"\n *\n * @api public\n * @property castNonArrays\n * @memberOf SchemaArrayOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaArrayOptions.prototype, 'castNonArrays', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaArrayOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9TY2hlbWFBcnJheU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEJBQTBCLG1CQUFPLENBQUMsbUdBQXFCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsK0ZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQSxvQkFBb0IsT0FBTywyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTSx3Q0FBd0M7QUFDakcsK0JBQStCLDRCQUE0QjtBQUMzRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxvcHRpb25zXFxTY2hlbWFBcnJheU9wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTY2hlbWFUeXBlT3B0aW9ucyA9IHJlcXVpcmUoJy4vU2NoZW1hVHlwZU9wdGlvbnMnKTtcblxuLyoqXG4gKiBUaGUgb3B0aW9ucyBkZWZpbmVkIG9uIGFuIEFycmF5IHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgdGFnczogW1N0cmluZ10gfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ3RhZ3MnKS5vcHRpb25zOyAvLyBTY2hlbWFBcnJheU9wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hQXJyYXlPcHRpb25zXG4gKi9cblxuY2xhc3MgU2NoZW1hQXJyYXlPcHRpb25zIGV4dGVuZHMgU2NoZW1hVHlwZU9wdGlvbnMge31cblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbi8qKlxuICogSWYgdGhpcyBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLCBhbiBhcnJheSBvZiBhbGxvd2VkIHZhbHVlcyBmb3IgdGhpcyBwYXRoLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoaXMgYXJyYXkgaXNuJ3QgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGVudW1cbiAqIEBtZW1iZXJPZiBTY2hlbWFBcnJheU9wdGlvbnNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFBcnJheU9wdGlvbnMucHJvdG90eXBlLCAnZW51bScsIG9wdHMpO1xuXG4vKipcbiAqIElmIHNldCwgc3BlY2lmaWVzIHRoZSB0eXBlIG9mIHRoaXMgYXJyYXkncyB2YWx1ZXMuIEVxdWl2YWxlbnQgdG8gc2V0dGluZ1xuICogYHR5cGVgIHRvIGFuIGFycmF5IHdob3NlIGZpcnN0IGVsZW1lbnQgaXMgYG9mYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGBhcnJgIGlzIGFuIGFycmF5IG9mIG51bWJlcnMuXG4gKiAgICAgbmV3IFNjaGVtYSh7IGFycjogW051bWJlcl0gfSk7XG4gKiAgICAgLy8gRXF1aXZhbGVudCB3YXkgdG8gZGVmaW5lIGBhcnJgIGFzIGFuIGFycmF5IG9mIG51bWJlcnNcbiAqICAgICBuZXcgU2NoZW1hKHsgYXJyOiB7IHR5cGU6IEFycmF5LCBvZjogTnVtYmVyIH0gfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBvZlxuICogQG1lbWJlck9mIFNjaGVtYUFycmF5T3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufFN0cmluZ31cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFBcnJheU9wdGlvbnMucHJvdG90eXBlLCAnb2YnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQgdG8gYGZhbHNlYCwgd2lsbCBhbHdheXMgZGVhY3RpdmF0ZSBjYXN0aW5nIG5vbi1hcnJheSB2YWx1ZXMgdG8gYXJyYXlzLlxuICogSWYgc2V0IHRvIGB0cnVlYCwgd2lsbCBjYXN0IG5vbi1hcnJheSB2YWx1ZXMgdG8gYXJyYXlzIGlmIGBpbml0YCBhbmQgYFNjaGVtYUFycmF5Lm9wdGlvbnMuY2FzdE5vbkFycmF5c2AgYXJlIGFsc28gYHRydWVgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IGRiLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IHgxOiB7IGNhc3ROb25BcnJheXM6IGZhbHNlLCB0eXBlOiBbU3RyaW5nXSB9IH0pKTtcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgTW9kZWwoeyB4MTogXCJzb21lIG5vbi1hcnJheSB2YWx1ZVwiIH0pO1xuICogICAgIGF3YWl0IGRvYy52YWxpZGF0ZSgpOyAvLyBFcnJvcnMgd2l0aCBcIkNhc3RFcnJvclwiXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBjYXN0Tm9uQXJyYXlzXG4gKiBAbWVtYmVyT2YgU2NoZW1hQXJyYXlPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFBcnJheU9wdGlvbnMucHJvdG90eXBlLCAnY2FzdE5vbkFycmF5cycsIG9wdHMpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hQXJyYXlPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/SchemaArrayOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/SchemaBufferOptions.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/SchemaBufferOptions.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./SchemaTypeOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\");\n\n/**\n * The options defined on a Buffer schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ bitmap: Buffer });\n *     schema.path('bitmap').options; // SchemaBufferOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaBufferOptions\n */\n\nclass SchemaBufferOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * Set the default subtype for this buffer.\n *\n * @api public\n * @property subtype\n * @memberOf SchemaBufferOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaBufferOptions.prototype, 'subtype', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaBufferOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9TY2hlbWFCdWZmZXJPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLG1HQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLCtGQUFtQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcb3B0aW9uc1xcU2NoZW1hQnVmZmVyT3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9TY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBCdWZmZXIgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBiaXRtYXA6IEJ1ZmZlciB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnYml0bWFwJykub3B0aW9uczsgLy8gU2NoZW1hQnVmZmVyT3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFCdWZmZXJPcHRpb25zXG4gKi9cblxuY2xhc3MgU2NoZW1hQnVmZmVyT3B0aW9ucyBleHRlbmRzIFNjaGVtYVR5cGVPcHRpb25zIHt9XG5cbmNvbnN0IG9wdHMgPSByZXF1aXJlKCcuL3Byb3BlcnR5T3B0aW9ucycpO1xuXG4vKipcbiAqIFNldCB0aGUgZGVmYXVsdCBzdWJ0eXBlIGZvciB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHN1YnR5cGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFCdWZmZXJPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYUJ1ZmZlck9wdGlvbnMucHJvdG90eXBlLCAnc3VidHlwZScsIG9wdHMpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hQnVmZmVyT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/SchemaBufferOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/SchemaDateOptions.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/SchemaDateOptions.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./SchemaTypeOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\");\n\n/**\n * The options defined on a Date schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ startedAt: Date });\n *     schema.path('startedAt').options; // SchemaDateOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaDateOptions\n */\n\nclass SchemaDateOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, Mongoose adds a validator that checks that this path is after the\n * given `min`.\n *\n * @api public\n * @property min\n * @memberOf SchemaDateOptions\n * @type {Date}\n * @instance\n */\n\nObject.defineProperty(SchemaDateOptions.prototype, 'min', opts);\n\n/**\n * If set, Mongoose adds a validator that checks that this path is before the\n * given `max`.\n *\n * @api public\n * @property max\n * @memberOf SchemaDateOptions\n * @type {Date}\n * @instance\n */\n\nObject.defineProperty(SchemaDateOptions.prototype, 'max', opts);\n\n/**\n * If set, Mongoose creates a TTL index on this path.\n *\n * mongo TTL index `expireAfterSeconds` value will take 'expires' value expressed in seconds.\n *\n * #### Example:\n *\n *     const schema = new Schema({ \"expireAt\": { type: Date,  expires: 11 } });\n *     // if 'expireAt' is set, then document expires at expireAt + 11 seconds\n *\n * @api public\n * @property expires\n * @memberOf SchemaDateOptions\n * @type {Date}\n * @instance\n */\n\nObject.defineProperty(SchemaDateOptions.prototype, 'expires', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaDateOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9TY2hlbWFEYXRlT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQyxtR0FBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BELHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrRkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjLDRCQUE0QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcb3B0aW9uc1xcU2NoZW1hRGF0ZU9wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTY2hlbWFUeXBlT3B0aW9ucyA9IHJlcXVpcmUoJy4vU2NoZW1hVHlwZU9wdGlvbnMnKTtcblxuLyoqXG4gKiBUaGUgb3B0aW9ucyBkZWZpbmVkIG9uIGEgRGF0ZSBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHN0YXJ0ZWRBdDogRGF0ZSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnc3RhcnRlZEF0Jykub3B0aW9uczsgLy8gU2NoZW1hRGF0ZU9wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hRGF0ZU9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFEYXRlT3B0aW9ucyBleHRlbmRzIFNjaGVtYVR5cGVPcHRpb25zIHt9XG5cbmNvbnN0IG9wdHMgPSByZXF1aXJlKCcuL3Byb3BlcnR5T3B0aW9ucycpO1xuXG4vKipcbiAqIElmIHNldCwgTW9uZ29vc2UgYWRkcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyB0aGF0IHRoaXMgcGF0aCBpcyBhZnRlciB0aGVcbiAqIGdpdmVuIGBtaW5gLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbWluXG4gKiBAbWVtYmVyT2YgU2NoZW1hRGF0ZU9wdGlvbnNcbiAqIEB0eXBlIHtEYXRlfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYURhdGVPcHRpb25zLnByb3RvdHlwZSwgJ21pbicsIG9wdHMpO1xuXG4vKipcbiAqIElmIHNldCwgTW9uZ29vc2UgYWRkcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyB0aGF0IHRoaXMgcGF0aCBpcyBiZWZvcmUgdGhlXG4gKiBnaXZlbiBgbWF4YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1heFxuICogQG1lbWJlck9mIFNjaGVtYURhdGVPcHRpb25zXG4gKiBAdHlwZSB7RGF0ZX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFEYXRlT3B0aW9ucy5wcm90b3R5cGUsICdtYXgnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQsIE1vbmdvb3NlIGNyZWF0ZXMgYSBUVEwgaW5kZXggb24gdGhpcyBwYXRoLlxuICpcbiAqIG1vbmdvIFRUTCBpbmRleCBgZXhwaXJlQWZ0ZXJTZWNvbmRzYCB2YWx1ZSB3aWxsIHRha2UgJ2V4cGlyZXMnIHZhbHVlIGV4cHJlc3NlZCBpbiBzZWNvbmRzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IFwiZXhwaXJlQXRcIjogeyB0eXBlOiBEYXRlLCAgZXhwaXJlczogMTEgfSB9KTtcbiAqICAgICAvLyBpZiAnZXhwaXJlQXQnIGlzIHNldCwgdGhlbiBkb2N1bWVudCBleHBpcmVzIGF0IGV4cGlyZUF0ICsgMTEgc2Vjb25kc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZXhwaXJlc1xuICogQG1lbWJlck9mIFNjaGVtYURhdGVPcHRpb25zXG4gKiBAdHlwZSB7RGF0ZX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFEYXRlT3B0aW9ucy5wcm90b3R5cGUsICdleHBpcmVzJywgb3B0cyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFEYXRlT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/SchemaDateOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js":
/*!*********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./SchemaTypeOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\");\n\n/**\n * The options defined on an Document Array schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ users: [{ name: string }] });\n *     schema.path('users').options; // SchemaDocumentArrayOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaDocumentOptions\n */\n\nclass SchemaDocumentArrayOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If `true`, Mongoose will skip building any indexes defined in this array's schema.\n * If not set, Mongoose will build all indexes defined in this array's schema.\n *\n * #### Example:\n *\n *     const childSchema = Schema({ name: { type: String, index: true } });\n *     // If `excludeIndexes` is `true`, Mongoose will skip building an index\n *     // on `arr.name`. Otherwise, Mongoose will build an index on `arr.name`.\n *     const parentSchema = Schema({\n *       arr: { type: [childSchema], excludeIndexes: true }\n *     });\n *\n * @api public\n * @property excludeIndexes\n * @memberOf SchemaDocumentArrayOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaDocumentArrayOptions.prototype, 'excludeIndexes', opts);\n\n/**\n * If set, overwrites the child schema's `_id` option.\n *\n * #### Example:\n *\n *     const childSchema = Schema({ name: String });\n *     const parentSchema = Schema({\n *       child: { type: childSchema, _id: false }\n *     });\n *     parentSchema.path('child').schema.options._id; // false\n *\n * @api public\n * @property _id\n * @memberOf SchemaDocumentArrayOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaDocumentArrayOptions.prototype, '_id', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaDocumentArrayOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9TY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQyxtR0FBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVSxjQUFjLEdBQUc7QUFDOUQscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLCtGQUFtQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsNkJBQTZCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQSxrQkFBa0I7QUFDbEIsUUFBUTtBQUNSLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXG9wdGlvbnNcXFNjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL1NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhbiBEb2N1bWVudCBBcnJheSBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHVzZXJzOiBbeyBuYW1lOiBzdHJpbmcgfV0gfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ3VzZXJzJykub3B0aW9uczsgLy8gU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hRG9jdW1lbnRPcHRpb25zXG4gKi9cblxuY2xhc3MgU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBJZiBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgc2tpcCBidWlsZGluZyBhbnkgaW5kZXhlcyBkZWZpbmVkIGluIHRoaXMgYXJyYXkncyBzY2hlbWEuXG4gKiBJZiBub3Qgc2V0LCBNb25nb29zZSB3aWxsIGJ1aWxkIGFsbCBpbmRleGVzIGRlZmluZWQgaW4gdGhpcyBhcnJheSdzIHNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNoaWxkU2NoZW1hID0gU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIGluZGV4OiB0cnVlIH0gfSk7XG4gKiAgICAgLy8gSWYgYGV4Y2x1ZGVJbmRleGVzYCBpcyBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgc2tpcCBidWlsZGluZyBhbiBpbmRleFxuICogICAgIC8vIG9uIGBhcnIubmFtZWAuIE90aGVyd2lzZSwgTW9uZ29vc2Ugd2lsbCBidWlsZCBhbiBpbmRleCBvbiBgYXJyLm5hbWVgLlxuICogICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IFNjaGVtYSh7XG4gKiAgICAgICBhcnI6IHsgdHlwZTogW2NoaWxkU2NoZW1hXSwgZXhjbHVkZUluZGV4ZXM6IHRydWUgfVxuICogICAgIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZXhjbHVkZUluZGV4ZXNcbiAqIEBtZW1iZXJPZiBTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9uc1xuICogQHR5cGUge0FycmF5fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zLnByb3RvdHlwZSwgJ2V4Y2x1ZGVJbmRleGVzJywgb3B0cyk7XG5cbi8qKlxuICogSWYgc2V0LCBvdmVyd3JpdGVzIHRoZSBjaGlsZCBzY2hlbWEncyBgX2lkYCBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjaGlsZFNjaGVtYSA9IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBjb25zdCBwYXJlbnRTY2hlbWEgPSBTY2hlbWEoe1xuICogICAgICAgY2hpbGQ6IHsgdHlwZTogY2hpbGRTY2hlbWEsIF9pZDogZmFsc2UgfVxuICogICAgIH0pO1xuICogICAgIHBhcmVudFNjaGVtYS5wYXRoKCdjaGlsZCcpLnNjaGVtYS5vcHRpb25zLl9pZDsgLy8gZmFsc2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IF9pZFxuICogQG1lbWJlck9mIFNjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMucHJvdG90eXBlLCAnX2lkJywgb3B0cyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/SchemaMapOptions.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/SchemaMapOptions.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./SchemaTypeOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\");\n\n/**\n * The options defined on a Map schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ socialMediaHandles: { type: Map, of: String } });\n *     schema.path('socialMediaHandles').options; // SchemaMapOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaMapOptions\n */\n\nclass SchemaMapOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, specifies the type of this map's values. Mongoose will cast\n * this map's values to the given type.\n *\n * If not set, Mongoose will not cast the map's values.\n *\n * #### Example:\n *\n *     // Mongoose will cast `socialMediaHandles` values to strings\n *     const schema = new Schema({ socialMediaHandles: { type: Map, of: String } });\n *     schema.path('socialMediaHandles').options.of; // String\n *\n * @api public\n * @property of\n * @memberOf SchemaMapOptions\n * @type {Function|string}\n * @instance\n */\n\nObject.defineProperty(SchemaMapOptions.prototype, 'of', opts);\n\nmodule.exports = SchemaMapOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9TY2hlbWFNYXBPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLG1HQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0IseUJBQXlCO0FBQ2xGLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrRkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0IseUJBQXlCO0FBQ2xGLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcb3B0aW9uc1xcU2NoZW1hTWFwT3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9TY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBNYXAgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBzb2NpYWxNZWRpYUhhbmRsZXM6IHsgdHlwZTogTWFwLCBvZjogU3RyaW5nIH0gfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ3NvY2lhbE1lZGlhSGFuZGxlcycpLm9wdGlvbnM7IC8vIFNjaGVtYU1hcE9wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hTWFwT3B0aW9uc1xuICovXG5cbmNsYXNzIFNjaGVtYU1hcE9wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBJZiBzZXQsIHNwZWNpZmllcyB0aGUgdHlwZSBvZiB0aGlzIG1hcCdzIHZhbHVlcy4gTW9uZ29vc2Ugd2lsbCBjYXN0XG4gKiB0aGlzIG1hcCdzIHZhbHVlcyB0byB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBJZiBub3Qgc2V0LCBNb25nb29zZSB3aWxsIG5vdCBjYXN0IHRoZSBtYXAncyB2YWx1ZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNb25nb29zZSB3aWxsIGNhc3QgYHNvY2lhbE1lZGlhSGFuZGxlc2AgdmFsdWVzIHRvIHN0cmluZ3NcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgc29jaWFsTWVkaWFIYW5kbGVzOiB7IHR5cGU6IE1hcCwgb2Y6IFN0cmluZyB9IH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdzb2NpYWxNZWRpYUhhbmRsZXMnKS5vcHRpb25zLm9mOyAvLyBTdHJpbmdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG9mXG4gKiBAbWVtYmVyT2YgU2NoZW1hTWFwT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufHN0cmluZ31cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFNYXBPcHRpb25zLnByb3RvdHlwZSwgJ29mJywgb3B0cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hTWFwT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/SchemaMapOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/SchemaNumberOptions.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/SchemaNumberOptions.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./SchemaTypeOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\");\n\n/**\n * The options defined on a Number schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ count: Number });\n *     schema.path('count').options; // SchemaNumberOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaNumberOptions\n */\n\nclass SchemaNumberOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, Mongoose adds a validator that checks that this path is at least the\n * given `min`.\n *\n * @api public\n * @property min\n * @memberOf SchemaNumberOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'min', opts);\n\n/**\n * If set, Mongoose adds a validator that checks that this path is less than the\n * given `max`.\n *\n * @api public\n * @property max\n * @memberOf SchemaNumberOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'max', opts);\n\n/**\n * If set, Mongoose adds a validator that checks that this path is strictly\n * equal to one of the given values.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       favoritePrime: {\n *         type: Number,\n *         enum: [3, 5, 7]\n *       }\n *     });\n *     schema.path('favoritePrime').options.enum; // [3, 5, 7]\n *\n * @api public\n * @property enum\n * @memberOf SchemaNumberOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'enum', opts);\n\n/**\n * Sets default [populate options](https://mongoosejs.com/docs/populate.html#query-conditions).\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       child: {\n *         type: Number,\n *         ref: 'Child',\n *         populate: { select: 'name' }\n *       }\n *     });\n *     const Parent = mongoose.model('Parent', schema);\n *\n *     // Automatically adds `.select('name')`\n *     Parent.findOne().populate('child');\n *\n * @api public\n * @property populate\n * @memberOf SchemaNumberOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'populate', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaNumberOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9TY2hlbWFOdW1iZXJPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLG1HQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrRkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcb3B0aW9uc1xcU2NoZW1hTnVtYmVyT3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9TY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBOdW1iZXIgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBjb3VudDogTnVtYmVyIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdjb3VudCcpLm9wdGlvbnM7IC8vIFNjaGVtYU51bWJlck9wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hTnVtYmVyT3B0aW9uc1xuICovXG5cbmNsYXNzIFNjaGVtYU51bWJlck9wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBJZiBzZXQsIE1vbmdvb3NlIGFkZHMgYSB2YWxpZGF0b3IgdGhhdCBjaGVja3MgdGhhdCB0aGlzIHBhdGggaXMgYXQgbGVhc3QgdGhlXG4gKiBnaXZlbiBgbWluYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1pblxuICogQG1lbWJlck9mIFNjaGVtYU51bWJlck9wdGlvbnNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hTnVtYmVyT3B0aW9ucy5wcm90b3R5cGUsICdtaW4nLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQsIE1vbmdvb3NlIGFkZHMgYSB2YWxpZGF0b3IgdGhhdCBjaGVja3MgdGhhdCB0aGlzIHBhdGggaXMgbGVzcyB0aGFuIHRoZVxuICogZ2l2ZW4gYG1heGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBtYXhcbiAqIEBtZW1iZXJPZiBTY2hlbWFOdW1iZXJPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYU51bWJlck9wdGlvbnMucHJvdG90eXBlLCAnbWF4Jywgb3B0cyk7XG5cbi8qKlxuICogSWYgc2V0LCBNb25nb29zZSBhZGRzIGEgdmFsaWRhdG9yIHRoYXQgY2hlY2tzIHRoYXQgdGhpcyBwYXRoIGlzIHN0cmljdGx5XG4gKiBlcXVhbCB0byBvbmUgb2YgdGhlIGdpdmVuIHZhbHVlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgZmF2b3JpdGVQcmltZToge1xuICogICAgICAgICB0eXBlOiBOdW1iZXIsXG4gKiAgICAgICAgIGVudW06IFszLCA1LCA3XVxuICogICAgICAgfVxuICogICAgIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdmYXZvcml0ZVByaW1lJykub3B0aW9ucy5lbnVtOyAvLyBbMywgNSwgN11cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGVudW1cbiAqIEBtZW1iZXJPZiBTY2hlbWFOdW1iZXJPcHRpb25zXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hTnVtYmVyT3B0aW9ucy5wcm90b3R5cGUsICdlbnVtJywgb3B0cyk7XG5cbi8qKlxuICogU2V0cyBkZWZhdWx0IFtwb3B1bGF0ZSBvcHRpb25zXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbCNxdWVyeS1jb25kaXRpb25zKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgY2hpbGQ6IHtcbiAqICAgICAgICAgdHlwZTogTnVtYmVyLFxuICogICAgICAgICByZWY6ICdDaGlsZCcsXG4gKiAgICAgICAgIHBvcHVsYXRlOiB7IHNlbGVjdDogJ25hbWUnIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgICBjb25zdCBQYXJlbnQgPSBtb25nb29zZS5tb2RlbCgnUGFyZW50Jywgc2NoZW1hKTtcbiAqXG4gKiAgICAgLy8gQXV0b21hdGljYWxseSBhZGRzIGAuc2VsZWN0KCduYW1lJylgXG4gKiAgICAgUGFyZW50LmZpbmRPbmUoKS5wb3B1bGF0ZSgnY2hpbGQnKTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHBvcHVsYXRlXG4gKiBAbWVtYmVyT2YgU2NoZW1hTnVtYmVyT3B0aW9uc1xuICogQHR5cGUge09iamVjdH1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFOdW1iZXJPcHRpb25zLnByb3RvdHlwZSwgJ3BvcHVsYXRlJywgb3B0cyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFOdW1iZXJPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/SchemaNumberOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/SchemaObjectIdOptions.js":
/*!****************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/SchemaObjectIdOptions.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./SchemaTypeOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\");\n\n/**\n * The options defined on an ObjectId schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ testId: mongoose.ObjectId });\n *     schema.path('testId').options; // SchemaObjectIdOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaObjectIdOptions\n */\n\nclass SchemaObjectIdOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If truthy, uses Mongoose's default built-in ObjectId path.\n *\n * @api public\n * @property auto\n * @memberOf SchemaObjectIdOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaObjectIdOptions.prototype, 'auto', opts);\n\n/**\n * Sets default [populate options](https://mongoosejs.com/docs/populate.html#query-conditions).\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       child: {\n *         type: 'ObjectId',\n *         ref: 'Child',\n *         populate: { select: 'name' }\n *       }\n *     });\n *     const Parent = mongoose.model('Parent', schema);\n *\n *     // Automatically adds `.select('name')`\n *     Parent.findOne().populate('child');\n *\n * @api public\n * @property populate\n * @memberOf SchemaObjectIdOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(SchemaObjectIdOptions.prototype, 'populate', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaObjectIdOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9TY2hlbWFPYmplY3RJZE9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEJBQTBCLG1CQUFPLENBQUMsbUdBQXFCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJCQUEyQjtBQUM5RCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsK0ZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXG9wdGlvbnNcXFNjaGVtYU9iamVjdElkT3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9TY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYW4gT2JqZWN0SWQgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyB0ZXN0SWQ6IG1vbmdvb3NlLk9iamVjdElkIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCd0ZXN0SWQnKS5vcHRpb25zOyAvLyBTY2hlbWFPYmplY3RJZE9wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hT2JqZWN0SWRPcHRpb25zXG4gKi9cblxuY2xhc3MgU2NoZW1hT2JqZWN0SWRPcHRpb25zIGV4dGVuZHMgU2NoZW1hVHlwZU9wdGlvbnMge31cblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbi8qKlxuICogSWYgdHJ1dGh5LCB1c2VzIE1vbmdvb3NlJ3MgZGVmYXVsdCBidWlsdC1pbiBPYmplY3RJZCBwYXRoLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgYXV0b1xuICogQG1lbWJlck9mIFNjaGVtYU9iamVjdElkT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hT2JqZWN0SWRPcHRpb25zLnByb3RvdHlwZSwgJ2F1dG8nLCBvcHRzKTtcblxuLyoqXG4gKiBTZXRzIGRlZmF1bHQgW3BvcHVsYXRlIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3F1ZXJ5LWNvbmRpdGlvbnMpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBjaGlsZDoge1xuICogICAgICAgICB0eXBlOiAnT2JqZWN0SWQnLFxuICogICAgICAgICByZWY6ICdDaGlsZCcsXG4gKiAgICAgICAgIHBvcHVsYXRlOiB7IHNlbGVjdDogJ25hbWUnIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgICBjb25zdCBQYXJlbnQgPSBtb25nb29zZS5tb2RlbCgnUGFyZW50Jywgc2NoZW1hKTtcbiAqXG4gKiAgICAgLy8gQXV0b21hdGljYWxseSBhZGRzIGAuc2VsZWN0KCduYW1lJylgXG4gKiAgICAgUGFyZW50LmZpbmRPbmUoKS5wb3B1bGF0ZSgnY2hpbGQnKTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHBvcHVsYXRlXG4gKiBAbWVtYmVyT2YgU2NoZW1hT2JqZWN0SWRPcHRpb25zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYU9iamVjdElkT3B0aW9ucy5wcm90b3R5cGUsICdwb3B1bGF0ZScsIG9wdHMpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hT2JqZWN0SWRPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/SchemaObjectIdOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/SchemaStringOptions.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/SchemaStringOptions.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./SchemaTypeOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\");\n\n/**\n * The options defined on a string schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name').options; // SchemaStringOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaStringOptions\n */\n\nclass SchemaStringOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * Array of allowed values for this path\n *\n * @api public\n * @property enum\n * @memberOf SchemaStringOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'enum', opts);\n\n/**\n * Attach a validator that succeeds if the data string matches the given regular\n * expression, and fails otherwise.\n *\n * @api public\n * @property match\n * @memberOf SchemaStringOptions\n * @type {RegExp}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'match', opts);\n\n/**\n * If truthy, Mongoose will add a custom setter that lowercases this string\n * using JavaScript's built-in `String#toLowerCase()`.\n *\n * @api public\n * @property lowercase\n * @memberOf SchemaStringOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'lowercase', opts);\n\n/**\n * If truthy, Mongoose will add a custom setter that removes leading and trailing\n * whitespace using [JavaScript's built-in `String#trim()`](https://masteringjs.io/tutorials/fundamentals/trim-string).\n *\n * @api public\n * @property trim\n * @memberOf SchemaStringOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'trim', opts);\n\n/**\n * If truthy, Mongoose will add a custom setter that uppercases this string\n * using JavaScript's built-in [`String#toUpperCase()`](https://masteringjs.io/tutorials/fundamentals/uppercase).\n *\n * @api public\n * @property uppercase\n * @memberOf SchemaStringOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'uppercase', opts);\n\n/**\n * If set, Mongoose will add a custom validator that ensures the given\n * string's `length` is at least the given number.\n *\n * Mongoose supports two different spellings for this option: `minLength` and `minlength`.\n * `minLength` is the recommended way to specify this option, but Mongoose also supports\n * `minlength` (lowercase \"l\").\n *\n * @api public\n * @property minLength\n * @memberOf SchemaStringOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'minLength', opts);\nObject.defineProperty(SchemaStringOptions.prototype, 'minlength', opts);\n\n/**\n * If set, Mongoose will add a custom validator that ensures the given\n * string's `length` is at most the given number.\n *\n * Mongoose supports two different spellings for this option: `maxLength` and `maxlength`.\n * `maxLength` is the recommended way to specify this option, but Mongoose also supports\n * `maxlength` (lowercase \"l\").\n *\n * @api public\n * @property maxLength\n * @memberOf SchemaStringOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'maxLength', opts);\nObject.defineProperty(SchemaStringOptions.prototype, 'maxlength', opts);\n\n/**\n * Sets default [populate options](https://mongoosejs.com/docs/populate.html#query-conditions).\n *\n * @api public\n * @property populate\n * @memberOf SchemaStringOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'populate', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaStringOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9TY2hlbWFTdHJpbmdPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLG1HQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrRkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcb3B0aW9uc1xcU2NoZW1hU3RyaW5nT3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9TY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBzdHJpbmcgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS5vcHRpb25zOyAvLyBTY2hlbWFTdHJpbmdPcHRpb25zIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlT3B0aW9uc1xuICogQGNvbnN0cnVjdG9yIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFTdHJpbmdPcHRpb25zIGV4dGVuZHMgU2NoZW1hVHlwZU9wdGlvbnMge31cblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbi8qKlxuICogQXJyYXkgb2YgYWxsb3dlZCB2YWx1ZXMgZm9yIHRoaXMgcGF0aFxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZW51bVxuICogQG1lbWJlck9mIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFTdHJpbmdPcHRpb25zLnByb3RvdHlwZSwgJ2VudW0nLCBvcHRzKTtcblxuLyoqXG4gKiBBdHRhY2ggYSB2YWxpZGF0b3IgdGhhdCBzdWNjZWVkcyBpZiB0aGUgZGF0YSBzdHJpbmcgbWF0Y2hlcyB0aGUgZ2l2ZW4gcmVndWxhclxuICogZXhwcmVzc2lvbiwgYW5kIGZhaWxzIG90aGVyd2lzZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1hdGNoXG4gKiBAbWVtYmVyT2YgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFTdHJpbmdPcHRpb25zLnByb3RvdHlwZSwgJ21hdGNoJywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1dGh5LCBNb25nb29zZSB3aWxsIGFkZCBhIGN1c3RvbSBzZXR0ZXIgdGhhdCBsb3dlcmNhc2VzIHRoaXMgc3RyaW5nXG4gKiB1c2luZyBKYXZhU2NyaXB0J3MgYnVpbHQtaW4gYFN0cmluZyN0b0xvd2VyQ2FzZSgpYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGxvd2VyY2FzZVxuICogQG1lbWJlck9mIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAnbG93ZXJjYXNlJywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1dGh5LCBNb25nb29zZSB3aWxsIGFkZCBhIGN1c3RvbSBzZXR0ZXIgdGhhdCByZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG4gKiB3aGl0ZXNwYWNlIHVzaW5nIFtKYXZhU2NyaXB0J3MgYnVpbHQtaW4gYFN0cmluZyN0cmltKClgXShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdHJpbS1zdHJpbmcpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdHJpbVxuICogQG1lbWJlck9mIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAndHJpbScsIG9wdHMpO1xuXG4vKipcbiAqIElmIHRydXRoeSwgTW9uZ29vc2Ugd2lsbCBhZGQgYSBjdXN0b20gc2V0dGVyIHRoYXQgdXBwZXJjYXNlcyB0aGlzIHN0cmluZ1xuICogdXNpbmcgSmF2YVNjcmlwdCdzIGJ1aWx0LWluIFtgU3RyaW5nI3RvVXBwZXJDYXNlKClgXShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdXBwZXJjYXNlKS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHVwcGVyY2FzZVxuICogQG1lbWJlck9mIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAndXBwZXJjYXNlJywgb3B0cyk7XG5cbi8qKlxuICogSWYgc2V0LCBNb25nb29zZSB3aWxsIGFkZCBhIGN1c3RvbSB2YWxpZGF0b3IgdGhhdCBlbnN1cmVzIHRoZSBnaXZlblxuICogc3RyaW5nJ3MgYGxlbmd0aGAgaXMgYXQgbGVhc3QgdGhlIGdpdmVuIG51bWJlci5cbiAqXG4gKiBNb25nb29zZSBzdXBwb3J0cyB0d28gZGlmZmVyZW50IHNwZWxsaW5ncyBmb3IgdGhpcyBvcHRpb246IGBtaW5MZW5ndGhgIGFuZCBgbWlubGVuZ3RoYC5cbiAqIGBtaW5MZW5ndGhgIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gc3BlY2lmeSB0aGlzIG9wdGlvbiwgYnV0IE1vbmdvb3NlIGFsc28gc3VwcG9ydHNcbiAqIGBtaW5sZW5ndGhgIChsb3dlcmNhc2UgXCJsXCIpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbWluTGVuZ3RoXG4gKiBAbWVtYmVyT2YgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICogQHR5cGUge051bWJlcn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFTdHJpbmdPcHRpb25zLnByb3RvdHlwZSwgJ21pbkxlbmd0aCcsIG9wdHMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAnbWlubGVuZ3RoJywgb3B0cyk7XG5cbi8qKlxuICogSWYgc2V0LCBNb25nb29zZSB3aWxsIGFkZCBhIGN1c3RvbSB2YWxpZGF0b3IgdGhhdCBlbnN1cmVzIHRoZSBnaXZlblxuICogc3RyaW5nJ3MgYGxlbmd0aGAgaXMgYXQgbW9zdCB0aGUgZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIE1vbmdvb3NlIHN1cHBvcnRzIHR3byBkaWZmZXJlbnQgc3BlbGxpbmdzIGZvciB0aGlzIG9wdGlvbjogYG1heExlbmd0aGAgYW5kIGBtYXhsZW5ndGhgLlxuICogYG1heExlbmd0aGAgaXMgdGhlIHJlY29tbWVuZGVkIHdheSB0byBzcGVjaWZ5IHRoaXMgb3B0aW9uLCBidXQgTW9uZ29vc2UgYWxzbyBzdXBwb3J0c1xuICogYG1heGxlbmd0aGAgKGxvd2VyY2FzZSBcImxcIikuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBtYXhMZW5ndGhcbiAqIEBtZW1iZXJPZiBTY2hlbWFTdHJpbmdPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAnbWF4TGVuZ3RoJywgb3B0cyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICdtYXhsZW5ndGgnLCBvcHRzKTtcblxuLyoqXG4gKiBTZXRzIGRlZmF1bHQgW3BvcHVsYXRlIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3F1ZXJ5LWNvbmRpdGlvbnMpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcG9wdWxhdGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFTdHJpbmdPcHRpb25zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAncG9wdWxhdGUnLCBvcHRzKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYVN0cmluZ09wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/SchemaStringOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/SchemaSubdocumentOptions.js":
/*!*******************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/SchemaSubdocumentOptions.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./SchemaTypeOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\");\n\n/**\n * The options defined on a single nested schematype.\n *\n * #### Example:\n *\n *     const schema = Schema({ child: Schema({ name: String }) });\n *     schema.path('child').options; // SchemaSubdocumentOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaSubdocumentOptions\n */\n\nclass SchemaSubdocumentOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, overwrites the child schema's `_id` option.\n *\n * #### Example:\n *\n *     const childSchema = Schema({ name: String });\n *     const parentSchema = Schema({\n *       child: { type: childSchema, _id: false }\n *     });\n *     parentSchema.path('child').schema.options._id; // false\n *\n * @api public\n * @property of\n * @memberOf SchemaSubdocumentOptions\n * @type {Function|string}\n * @instance\n */\n\nObject.defineProperty(SchemaSubdocumentOptions.prototype, '_id', opts);\n\nmodule.exports = SchemaSubdocumentOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9TY2hlbWFTdWJkb2N1bWVudE9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEJBQTBCLG1CQUFPLENBQUMsbUdBQXFCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQixjQUFjLEdBQUc7QUFDaEUscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLCtGQUFtQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0Esa0JBQWtCO0FBQ2xCLFFBQVE7QUFDUixzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXG9wdGlvbnNcXFNjaGVtYVN1YmRvY3VtZW50T3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9TY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBzaW5nbGUgbmVzdGVkIHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEoeyBjaGlsZDogU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdjaGlsZCcpLm9wdGlvbnM7IC8vIFNjaGVtYVN1YmRvY3VtZW50T3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFTdWJkb2N1bWVudE9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFTdWJkb2N1bWVudE9wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBJZiBzZXQsIG92ZXJ3cml0ZXMgdGhlIGNoaWxkIHNjaGVtYSdzIGBfaWRgIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNoaWxkU2NoZW1hID0gU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IFNjaGVtYSh7XG4gKiAgICAgICBjaGlsZDogeyB0eXBlOiBjaGlsZFNjaGVtYSwgX2lkOiBmYWxzZSB9XG4gKiAgICAgfSk7XG4gKiAgICAgcGFyZW50U2NoZW1hLnBhdGgoJ2NoaWxkJykuc2NoZW1hLm9wdGlvbnMuX2lkOyAvLyBmYWxzZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgb2ZcbiAqIEBtZW1iZXJPZiBTY2hlbWFTdWJkb2N1bWVudE9wdGlvbnNcbiAqIEB0eXBlIHtGdW5jdGlvbnxzdHJpbmd9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3ViZG9jdW1lbnRPcHRpb25zLnByb3RvdHlwZSwgJ19pZCcsIG9wdHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYVN1YmRvY3VtZW50T3B0aW9ucztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/SchemaSubdocumentOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\n\n/**\n * The options defined on a schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name').options instanceof mongoose.SchemaTypeOptions; // true\n *\n * @api public\n * @constructor SchemaTypeOptions\n */\n\nclass SchemaTypeOptions {\n  constructor(obj) {\n    if (obj == null) {\n      return this;\n    }\n    Object.assign(this, clone(obj));\n  }\n}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * The type to cast this path to.\n *\n * @api public\n * @property type\n * @memberOf SchemaTypeOptions\n * @type {Function|String|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'type', opts);\n\n/**\n * Function or object describing how to validate this schematype.\n *\n * @api public\n * @property validate\n * @memberOf SchemaTypeOptions\n * @type {Function|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'validate', opts);\n\n/**\n * Allows overriding casting logic for this individual path. If a string, the\n * given string overwrites Mongoose's default cast error message.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       num: {\n *         type: Number,\n *         cast: '{VALUE} is not a valid number'\n *       }\n *     });\n *\n *     // Throws 'CastError: \"bad\" is not a valid number'\n *     schema.path('num').cast('bad');\n *\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({ num: 'fail' });\n *     const err = doc.validateSync();\n *\n *     err.errors['num']; // 'CastError: \"fail\" is not a valid number'\n *\n * @api public\n * @property cast\n * @memberOf SchemaTypeOptions\n * @type {String}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'cast', opts);\n\n/**\n * If true, attach a required validator to this path, which ensures this path\n * cannot be set to a nullish value. If a function, Mongoose calls the\n * function and only checks for nullish values if the function returns a truthy value.\n *\n * @api public\n * @property required\n * @memberOf SchemaTypeOptions\n * @type {Function|Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'required', opts);\n\n/**\n * The default value for this path. If a function, Mongoose executes the function\n * and uses the return value as the default.\n *\n * @api public\n * @property default\n * @memberOf SchemaTypeOptions\n * @type {Function|Any}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'default', opts);\n\n/**\n * The model that `populate()` should use if populating this path.\n *\n * @api public\n * @property ref\n * @memberOf SchemaTypeOptions\n * @type {Function|String}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'ref', opts);\n\n/**\n * The path in the document that `populate()` should use to find the model\n * to use.\n *\n * @api public\n * @property ref\n * @memberOf SchemaTypeOptions\n * @type {Function|String}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'refPath', opts);\n\n/**\n * Whether to include or exclude this path by default when loading documents\n * using `find()`, `findOne()`, etc.\n *\n * @api public\n * @property select\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'select', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n * build an index on this path when the model is compiled.\n *\n * @api public\n * @property index\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'index', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\n * will build a unique index on this path when the\n * model is compiled. [The `unique` option is **not** a validator](https://mongoosejs.com/docs/validation.html#the-unique-option-is-not-a-validator).\n *\n * @api public\n * @property unique\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'unique', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n * disallow changes to this path once the document\n * is saved to the database for the first time. Read more about [immutability in Mongoose here](https://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html).\n *\n * @api public\n * @property immutable\n * @memberOf SchemaTypeOptions\n * @type {Function|Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'immutable', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n * build a sparse index on this path.\n *\n * @api public\n * @property sparse\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'sparse', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\n * will build a text index on this path.\n *\n * @api public\n * @property text\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'text', opts);\n\n/**\n * Define a transform function for this individual schema type.\n * Only called when calling `toJSON()` or `toObject()`.\n *\n * #### Example:\n *\n *     const schema = Schema({\n *       myDate: {\n *         type: Date,\n *         transform: v => v.getFullYear()\n *       }\n *     });\n *     const Model = mongoose.model('Test', schema);\n *\n *     const doc = new Model({ myDate: new Date('2019/06/01') });\n *     doc.myDate instanceof Date; // true\n *\n *     const res = doc.toObject({ transform: true });\n *     res.myDate; // 2019\n *\n * @api public\n * @property transform\n * @memberOf SchemaTypeOptions\n * @type {Function}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'transform', opts);\n\nmodule.exports = SchemaTypeOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9TY2hlbWFUeXBlT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsb0ZBQWtCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLCtGQUFtQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9ELG1DQUFtQztBQUNuQztBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxvcHRpb25zXFxTY2hlbWFUeXBlT3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi4vaGVscGVycy9jbG9uZScpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLm9wdGlvbnMgaW5zdGFuY2VvZiBtb25nb29zZS5TY2hlbWFUeXBlT3B0aW9uczsgLy8gdHJ1ZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hVHlwZU9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFUeXBlT3B0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2xvbmUob2JqKSk7XG4gIH1cbn1cblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIHR5cGUgdG8gY2FzdCB0aGlzIHBhdGggdG8uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB0eXBlXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtGdW5jdGlvbnxTdHJpbmd8T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3R5cGUnLCBvcHRzKTtcblxuLyoqXG4gKiBGdW5jdGlvbiBvciBvYmplY3QgZGVzY3JpYmluZyBob3cgdG8gdmFsaWRhdGUgdGhpcyBzY2hlbWF0eXBlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdmFsaWRhdGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufE9iamVjdH1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICd2YWxpZGF0ZScsIG9wdHMpO1xuXG4vKipcbiAqIEFsbG93cyBvdmVycmlkaW5nIGNhc3RpbmcgbG9naWMgZm9yIHRoaXMgaW5kaXZpZHVhbCBwYXRoLiBJZiBhIHN0cmluZywgdGhlXG4gKiBnaXZlbiBzdHJpbmcgb3ZlcndyaXRlcyBNb25nb29zZSdzIGRlZmF1bHQgY2FzdCBlcnJvciBtZXNzYWdlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBudW06IHtcbiAqICAgICAgICAgdHlwZTogTnVtYmVyLFxuICogICAgICAgICBjYXN0OiAne1ZBTFVFfSBpcyBub3QgYSB2YWxpZCBudW1iZXInXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIFRocm93cyAnQ2FzdEVycm9yOiBcImJhZFwiIGlzIG5vdCBhIHZhbGlkIG51bWJlcidcbiAqICAgICBzY2hlbWEucGF0aCgnbnVtJykuY2FzdCgnYmFkJyk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7IG51bTogJ2ZhaWwnIH0pO1xuICogICAgIGNvbnN0IGVyciA9IGRvYy52YWxpZGF0ZVN5bmMoKTtcbiAqXG4gKiAgICAgZXJyLmVycm9yc1snbnVtJ107IC8vICdDYXN0RXJyb3I6IFwiZmFpbFwiIGlzIG5vdCBhIHZhbGlkIG51bWJlcidcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNhc3RcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge1N0cmluZ31cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdjYXN0Jywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1ZSwgYXR0YWNoIGEgcmVxdWlyZWQgdmFsaWRhdG9yIHRvIHRoaXMgcGF0aCwgd2hpY2ggZW5zdXJlcyB0aGlzIHBhdGhcbiAqIGNhbm5vdCBiZSBzZXQgdG8gYSBudWxsaXNoIHZhbHVlLiBJZiBhIGZ1bmN0aW9uLCBNb25nb29zZSBjYWxscyB0aGVcbiAqIGZ1bmN0aW9uIGFuZCBvbmx5IGNoZWNrcyBmb3IgbnVsbGlzaCB2YWx1ZXMgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSByZXF1aXJlZFxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb258Qm9vbGVhbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdyZXF1aXJlZCcsIG9wdHMpO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIHBhdGguIElmIGEgZnVuY3Rpb24sIE1vbmdvb3NlIGV4ZWN1dGVzIHRoZSBmdW5jdGlvblxuICogYW5kIHVzZXMgdGhlIHJldHVybiB2YWx1ZSBhcyB0aGUgZGVmYXVsdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGRlZmF1bHRcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufEFueX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdkZWZhdWx0Jywgb3B0cyk7XG5cbi8qKlxuICogVGhlIG1vZGVsIHRoYXQgYHBvcHVsYXRlKClgIHNob3VsZCB1c2UgaWYgcG9wdWxhdGluZyB0aGlzIHBhdGguXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSByZWZcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufFN0cmluZ31cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdyZWYnLCBvcHRzKTtcblxuLyoqXG4gKiBUaGUgcGF0aCBpbiB0aGUgZG9jdW1lbnQgdGhhdCBgcG9wdWxhdGUoKWAgc2hvdWxkIHVzZSB0byBmaW5kIHRoZSBtb2RlbFxuICogdG8gdXNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcmVmXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtGdW5jdGlvbnxTdHJpbmd9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAncmVmUGF0aCcsIG9wdHMpO1xuXG4vKipcbiAqIFdoZXRoZXIgdG8gaW5jbHVkZSBvciBleGNsdWRlIHRoaXMgcGF0aCBieSBkZWZhdWx0IHdoZW4gbG9hZGluZyBkb2N1bWVudHNcbiAqIHVzaW5nIGBmaW5kKClgLCBgZmluZE9uZSgpYCwgZXRjLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgc2VsZWN0XG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufE51bWJlcn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdzZWxlY3QnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBbdHJ1dGh5XShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdHJ1dGh5KSwgTW9uZ29vc2Ugd2lsbFxuICogYnVpbGQgYW4gaW5kZXggb24gdGhpcyBwYXRoIHdoZW4gdGhlIG1vZGVsIGlzIGNvbXBpbGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgaW5kZXhcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW58TnVtYmVyfE9iamVjdH1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdpbmRleCcsIG9wdHMpO1xuXG4vKipcbiAqIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCBNb25nb29zZVxuICogd2lsbCBidWlsZCBhIHVuaXF1ZSBpbmRleCBvbiB0aGlzIHBhdGggd2hlbiB0aGVcbiAqIG1vZGVsIGlzIGNvbXBpbGVkLiBbVGhlIGB1bmlxdWVgIG9wdGlvbiBpcyAqKm5vdCoqIGEgdmFsaWRhdG9yXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdmFsaWRhdGlvbi5odG1sI3RoZS11bmlxdWUtb3B0aW9uLWlzLW5vdC1hLXZhbGlkYXRvcikuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB1bmlxdWVcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW58TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3VuaXF1ZScsIG9wdHMpO1xuXG4vKipcbiAqIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCBNb25nb29zZSB3aWxsXG4gKiBkaXNhbGxvdyBjaGFuZ2VzIHRvIHRoaXMgcGF0aCBvbmNlIHRoZSBkb2N1bWVudFxuICogaXMgc2F2ZWQgdG8gdGhlIGRhdGFiYXNlIGZvciB0aGUgZmlyc3QgdGltZS4gUmVhZCBtb3JlIGFib3V0IFtpbW11dGFiaWxpdHkgaW4gTW9uZ29vc2UgaGVyZV0oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS93aGF0cy1uZXctaW4tbW9uZ29vc2UtNS02LWltbXV0YWJsZS1wcm9wZXJ0aWVzLmh0bWwpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgaW1tdXRhYmxlXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtGdW5jdGlvbnxCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ2ltbXV0YWJsZScsIG9wdHMpO1xuXG4vKipcbiAqIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCBNb25nb29zZSB3aWxsXG4gKiBidWlsZCBhIHNwYXJzZSBpbmRleCBvbiB0aGlzIHBhdGguXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBzcGFyc2VcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW58TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3NwYXJzZScsIG9wdHMpO1xuXG4vKipcbiAqIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCBNb25nb29zZVxuICogd2lsbCBidWlsZCBhIHRleHQgaW5kZXggb24gdGhpcyBwYXRoLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdGV4dFxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbnxOdW1iZXJ8T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3RleHQnLCBvcHRzKTtcblxuLyoqXG4gKiBEZWZpbmUgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gZm9yIHRoaXMgaW5kaXZpZHVhbCBzY2hlbWEgdHlwZS5cbiAqIE9ubHkgY2FsbGVkIHdoZW4gY2FsbGluZyBgdG9KU09OKClgIG9yIGB0b09iamVjdCgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IFNjaGVtYSh7XG4gKiAgICAgICBteURhdGU6IHtcbiAqICAgICAgICAgdHlwZTogRGF0ZSxcbiAqICAgICAgICAgdHJhbnNmb3JtOiB2ID0+IHYuZ2V0RnVsbFllYXIoKVxuICogICAgICAgfVxuICogICAgIH0pO1xuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgTW9kZWwoeyBteURhdGU6IG5ldyBEYXRlKCcyMDE5LzA2LzAxJykgfSk7XG4gKiAgICAgZG9jLm15RGF0ZSBpbnN0YW5jZW9mIERhdGU7IC8vIHRydWVcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gZG9jLnRvT2JqZWN0KHsgdHJhbnNmb3JtOiB0cnVlIH0pO1xuICogICAgIHJlcy5teURhdGU7IC8vIDIwMTlcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHRyYW5zZm9ybVxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAndHJhbnNmb3JtJywgb3B0cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hVHlwZU9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/VirtualOptions.js":
/*!*********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/VirtualOptions.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js\");\n\nclass VirtualOptions {\n  constructor(obj) {\n    Object.assign(this, obj);\n\n    if (obj != null && obj.options != null) {\n      this.options = Object.assign({}, obj.options);\n    }\n  }\n}\n\n/**\n * Marks this virtual as a populate virtual, and specifies the model to\n * use for populate.\n *\n * @api public\n * @property ref\n * @memberOf VirtualOptions\n * @type {String|Model|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'ref', opts);\n\n/**\n * Marks this virtual as a populate virtual, and specifies the path that\n * contains the name of the model to populate\n *\n * @api public\n * @property refPath\n * @memberOf VirtualOptions\n * @type {String|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'refPath', opts);\n\n/**\n * The name of the property in the local model to match to `foreignField`\n * in the foreign model.\n *\n * @api public\n * @property localField\n * @memberOf VirtualOptions\n * @type {String|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'localField', opts);\n\n/**\n * The name of the property in the foreign model to match to `localField`\n * in the local model.\n *\n * @api public\n * @property foreignField\n * @memberOf VirtualOptions\n * @type {String|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'foreignField', opts);\n\n/**\n * Whether to populate this virtual as a single document (true) or an\n * array of documents (false).\n *\n * @api public\n * @property justOne\n * @memberOf VirtualOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'justOne', opts);\n\n/**\n * If true, populate just the number of documents where `localField`\n * matches `foreignField`, as opposed to the documents themselves.\n *\n * If `count` is set, it overrides `justOne`.\n *\n * @api public\n * @property count\n * @memberOf VirtualOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'count', opts);\n\n/**\n * Add an additional filter to populate, in addition to `localField`\n * matches `foreignField`.\n *\n * @api public\n * @property match\n * @memberOf VirtualOptions\n * @type {Object|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'match', opts);\n\n/**\n * Additional options to pass to the query used to `populate()`:\n *\n * - `sort`\n * - `skip`\n * - `limit`\n *\n * @api public\n * @property options\n * @memberOf VirtualOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'options', opts);\n\n/**\n * If true, add a `skip` to the query used to `populate()`.\n *\n * @api public\n * @property skip\n * @memberOf VirtualOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'skip', opts);\n\n/**\n * If true, add a `limit` to the query used to `populate()`.\n *\n * @api public\n * @property limit\n * @memberOf VirtualOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'limit', opts);\n\n/**\n * The `limit` option for `populate()` has [some unfortunate edge cases](https://mongoosejs.com/docs/populate.html#query-conditions)\n * when working with multiple documents, like `.find().populate()`. The\n * `perDocumentLimit` option makes `populate()` execute a separate query\n * for each document returned from `find()` to ensure each document\n * gets up to `perDocumentLimit` populated docs if possible.\n *\n * @api public\n * @property perDocumentLimit\n * @memberOf VirtualOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'perDocumentLimit', opts);\n\nmodule.exports = VirtualOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9WaXJ0dWFsT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsK0ZBQW1COztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXG9wdGlvbnNcXFZpcnR1YWxPcHRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbmNsYXNzIFZpcnR1YWxPcHRpb25zIHtcbiAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvYmopO1xuXG4gICAgaWYgKG9iaiAhPSBudWxsICYmIG9iai5vcHRpb25zICE9IG51bGwpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9iai5vcHRpb25zKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYXJrcyB0aGlzIHZpcnR1YWwgYXMgYSBwb3B1bGF0ZSB2aXJ0dWFsLCBhbmQgc3BlY2lmaWVzIHRoZSBtb2RlbCB0b1xuICogdXNlIGZvciBwb3B1bGF0ZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHJlZlxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7U3RyaW5nfE1vZGVsfEZ1bmN0aW9ufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ3JlZicsIG9wdHMpO1xuXG4vKipcbiAqIE1hcmtzIHRoaXMgdmlydHVhbCBhcyBhIHBvcHVsYXRlIHZpcnR1YWwsIGFuZCBzcGVjaWZpZXMgdGhlIHBhdGggdGhhdFxuICogY29udGFpbnMgdGhlIG5hbWUgb2YgdGhlIG1vZGVsIHRvIHBvcHVsYXRlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSByZWZQYXRoXG4gKiBAbWVtYmVyT2YgVmlydHVhbE9wdGlvbnNcbiAqIEB0eXBlIHtTdHJpbmd8RnVuY3Rpb259XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmlydHVhbE9wdGlvbnMucHJvdG90eXBlLCAncmVmUGF0aCcsIG9wdHMpO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBpbiB0aGUgbG9jYWwgbW9kZWwgdG8gbWF0Y2ggdG8gYGZvcmVpZ25GaWVsZGBcbiAqIGluIHRoZSBmb3JlaWduIG1vZGVsLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbG9jYWxGaWVsZFxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ2xvY2FsRmllbGQnLCBvcHRzKTtcblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgaW4gdGhlIGZvcmVpZ24gbW9kZWwgdG8gbWF0Y2ggdG8gYGxvY2FsRmllbGRgXG4gKiBpbiB0aGUgbG9jYWwgbW9kZWwuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBmb3JlaWduRmllbGRcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge1N0cmluZ3xGdW5jdGlvbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdmb3JlaWduRmllbGQnLCBvcHRzKTtcblxuLyoqXG4gKiBXaGV0aGVyIHRvIHBvcHVsYXRlIHRoaXMgdmlydHVhbCBhcyBhIHNpbmdsZSBkb2N1bWVudCAodHJ1ZSkgb3IgYW5cbiAqIGFycmF5IG9mIGRvY3VtZW50cyAoZmFsc2UpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkganVzdE9uZVxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdqdXN0T25lJywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1ZSwgcG9wdWxhdGUganVzdCB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyB3aGVyZSBgbG9jYWxGaWVsZGBcbiAqIG1hdGNoZXMgYGZvcmVpZ25GaWVsZGAsIGFzIG9wcG9zZWQgdG8gdGhlIGRvY3VtZW50cyB0aGVtc2VsdmVzLlxuICpcbiAqIElmIGBjb3VudGAgaXMgc2V0LCBpdCBvdmVycmlkZXMgYGp1c3RPbmVgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgY291bnRcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmlydHVhbE9wdGlvbnMucHJvdG90eXBlLCAnY291bnQnLCBvcHRzKTtcblxuLyoqXG4gKiBBZGQgYW4gYWRkaXRpb25hbCBmaWx0ZXIgdG8gcG9wdWxhdGUsIGluIGFkZGl0aW9uIHRvIGBsb2NhbEZpZWxkYFxuICogbWF0Y2hlcyBgZm9yZWlnbkZpZWxkYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1hdGNoXG4gKiBAbWVtYmVyT2YgVmlydHVhbE9wdGlvbnNcbiAqIEB0eXBlIHtPYmplY3R8RnVuY3Rpb259XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmlydHVhbE9wdGlvbnMucHJvdG90eXBlLCAnbWF0Y2gnLCBvcHRzKTtcblxuLyoqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgcXVlcnkgdXNlZCB0byBgcG9wdWxhdGUoKWA6XG4gKlxuICogLSBgc29ydGBcbiAqIC0gYHNraXBgXG4gKiAtIGBsaW1pdGBcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG9wdGlvbnNcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge09iamVjdH1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdvcHRpb25zJywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1ZSwgYWRkIGEgYHNraXBgIHRvIHRoZSBxdWVyeSB1c2VkIHRvIGBwb3B1bGF0ZSgpYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHNraXBcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge051bWJlcn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdza2lwJywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1ZSwgYWRkIGEgYGxpbWl0YCB0byB0aGUgcXVlcnkgdXNlZCB0byBgcG9wdWxhdGUoKWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBsaW1pdFxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ2xpbWl0Jywgb3B0cyk7XG5cbi8qKlxuICogVGhlIGBsaW1pdGAgb3B0aW9uIGZvciBgcG9wdWxhdGUoKWAgaGFzIFtzb21lIHVuZm9ydHVuYXRlIGVkZ2UgY2FzZXNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3F1ZXJ5LWNvbmRpdGlvbnMpXG4gKiB3aGVuIHdvcmtpbmcgd2l0aCBtdWx0aXBsZSBkb2N1bWVudHMsIGxpa2UgYC5maW5kKCkucG9wdWxhdGUoKWAuIFRoZVxuICogYHBlckRvY3VtZW50TGltaXRgIG9wdGlvbiBtYWtlcyBgcG9wdWxhdGUoKWAgZXhlY3V0ZSBhIHNlcGFyYXRlIHF1ZXJ5XG4gKiBmb3IgZWFjaCBkb2N1bWVudCByZXR1cm5lZCBmcm9tIGBmaW5kKClgIHRvIGVuc3VyZSBlYWNoIGRvY3VtZW50XG4gKiBnZXRzIHVwIHRvIGBwZXJEb2N1bWVudExpbWl0YCBwb3B1bGF0ZWQgZG9jcyBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHBlckRvY3VtZW50TGltaXRcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge051bWJlcn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdwZXJEb2N1bWVudExpbWl0Jywgb3B0cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmlydHVhbE9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/VirtualOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/propertyOptions.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = Object.freeze({\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: void 0\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9wcm9wZXJ0eU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxvcHRpb25zXFxwcm9wZXJ0eU9wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZTogdm9pZCAwXG59KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/propertyOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/options/saveOptions.js":
/*!******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/options/saveOptions.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\n\nclass SaveOptions {\n  constructor(obj) {\n    if (obj == null) {\n      return;\n    }\n    Object.assign(this, clone(obj));\n  }\n}\n\nmodule.exports = SaveOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zYXZlT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsb0ZBQWtCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcb3B0aW9uc1xcc2F2ZU9wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2xvbmUnKTtcblxuY2xhc3MgU2F2ZU9wdGlvbnMge1xuICBjb25zdHJ1Y3RvcihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjbG9uZShvYmopKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNhdmVPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/options/saveOptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/plugins/index.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/plugins/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.removeSubdocs = __webpack_require__(/*! ./removeSubdocs */ \"(api)/../server/node_modules/mongoose/lib/plugins/removeSubdocs.js\");\nexports.saveSubdocs = __webpack_require__(/*! ./saveSubdocs */ \"(api)/../server/node_modules/mongoose/lib/plugins/saveSubdocs.js\");\nexports.sharding = __webpack_require__(/*! ./sharding */ \"(api)/../server/node_modules/mongoose/lib/plugins/sharding.js\");\nexports.trackTransaction = __webpack_require__(/*! ./trackTransaction */ \"(api)/../server/node_modules/mongoose/lib/plugins/trackTransaction.js\");\nexports.validateBeforeSave = __webpack_require__(/*! ./validateBeforeSave */ \"(api)/../server/node_modules/mongoose/lib/plugins/validateBeforeSave.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix3SUFBa0Q7QUFDbEQsa0lBQThDO0FBQzlDLHlIQUF3QztBQUN4QyxpSkFBd0Q7QUFDeEQsdUpBQTREIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxccGx1Z2luc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnJlbW92ZVN1YmRvY3MgPSByZXF1aXJlKCcuL3JlbW92ZVN1YmRvY3MnKTtcbmV4cG9ydHMuc2F2ZVN1YmRvY3MgPSByZXF1aXJlKCcuL3NhdmVTdWJkb2NzJyk7XG5leHBvcnRzLnNoYXJkaW5nID0gcmVxdWlyZSgnLi9zaGFyZGluZycpO1xuZXhwb3J0cy50cmFja1RyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi90cmFja1RyYW5zYWN0aW9uJyk7XG5leHBvcnRzLnZhbGlkYXRlQmVmb3JlU2F2ZSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVCZWZvcmVTYXZlJyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/plugins/index.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/plugins/removeSubdocs.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/plugins/removeSubdocs.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst each = __webpack_require__(/*! ../helpers/each */ \"(api)/../server/node_modules/mongoose/lib/helpers/each.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function removeSubdocs(schema) {\n  const unshift = true;\n  schema.s.hooks.pre('deleteOne', { document: true, query: false }, function removeSubDocsPreRemove(next) {\n    if (this.$isSubdocument) {\n      next();\n      return;\n    }\n    if (this.$__ == null) {\n      next();\n      return;\n    }\n\n    const _this = this;\n    const subdocs = this.$getAllSubdocs();\n\n    each(subdocs, function(subdoc, cb) {\n      subdoc.$__deleteOne(cb);\n    }, function(error) {\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('deleteOne:error', _this, [_this], { error: error }, function(error) {\n          next(error);\n        });\n      }\n      next();\n    });\n  }, null, unshift);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy9yZW1vdmVTdWJkb2NzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxrRkFBaUI7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLDhCQUE4QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFGQUFxRixjQUFjO0FBQ25HO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxccGx1Z2luc1xccmVtb3ZlU3ViZG9jcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGVhY2ggPSByZXF1aXJlKCcuLi9oZWxwZXJzL2VhY2gnKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlbW92ZVN1YmRvY3Moc2NoZW1hKSB7XG4gIGNvbnN0IHVuc2hpZnQgPSB0cnVlO1xuICBzY2hlbWEucy5ob29rcy5wcmUoJ2RlbGV0ZU9uZScsIHsgZG9jdW1lbnQ6IHRydWUsIHF1ZXJ5OiBmYWxzZSB9LCBmdW5jdGlvbiByZW1vdmVTdWJEb2NzUHJlUmVtb3ZlKG5leHQpIHtcbiAgICBpZiAodGhpcy4kaXNTdWJkb2N1bWVudCkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4kX18gPT0gbnVsbCkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICBjb25zdCBzdWJkb2NzID0gdGhpcy4kZ2V0QWxsU3ViZG9jcygpO1xuXG4gICAgZWFjaChzdWJkb2NzLCBmdW5jdGlvbihzdWJkb2MsIGNiKSB7XG4gICAgICBzdWJkb2MuJF9fZGVsZXRlT25lKGNiKTtcbiAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy4kX19zY2hlbWEucy5ob29rcy5leGVjUG9zdCgnZGVsZXRlT25lOmVycm9yJywgX3RoaXMsIFtfdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgIH0pO1xuICB9LCBudWxsLCB1bnNoaWZ0KTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/plugins/removeSubdocs.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/plugins/saveSubdocs.js":
/*!******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/plugins/saveSubdocs.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst each = __webpack_require__(/*! ../helpers/each */ \"(api)/../server/node_modules/mongoose/lib/helpers/each.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function saveSubdocs(schema) {\n  const unshift = true;\n  schema.s.hooks.pre('save', false, function saveSubdocsPreSave(next) {\n    if (this.$isSubdocument) {\n      next();\n      return;\n    }\n\n    const _this = this;\n    const subdocs = this.$getAllSubdocs();\n\n    if (!subdocs.length) {\n      next();\n      return;\n    }\n\n    each(subdocs, function(subdoc, cb) {\n      subdoc.$__schema.s.hooks.execPre('save', subdoc, function(err) {\n        cb(err);\n      });\n    }, function(error) {\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n          next(error);\n        });\n      }\n      next();\n    });\n  }, null, unshift);\n\n  schema.s.hooks.post('save', function saveSubdocsPostSave(doc, next) {\n    if (this.$isSubdocument) {\n      next();\n      return;\n    }\n\n    const _this = this;\n    const subdocs = this.$getAllSubdocs();\n\n    if (!subdocs.length) {\n      next();\n      return;\n    }\n\n    each(subdocs, function(subdoc, cb) {\n      subdoc.$__schema.s.hooks.execPost('save', subdoc, [subdoc], function(err) {\n        cb(err);\n      });\n    }, function(error) {\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n          next(error);\n        });\n      }\n      next();\n    });\n  }, null, unshift);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy9zYXZlU3ViZG9jcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0ZBQWlCOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGNBQWM7QUFDOUY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsZ0ZBQWdGLGNBQWM7QUFDOUY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxwbHVnaW5zXFxzYXZlU3ViZG9jcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGVhY2ggPSByZXF1aXJlKCcuLi9oZWxwZXJzL2VhY2gnKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNhdmVTdWJkb2NzKHNjaGVtYSkge1xuICBjb25zdCB1bnNoaWZ0ID0gdHJ1ZTtcbiAgc2NoZW1hLnMuaG9va3MucHJlKCdzYXZlJywgZmFsc2UsIGZ1bmN0aW9uIHNhdmVTdWJkb2NzUHJlU2F2ZShuZXh0KSB7XG4gICAgaWYgKHRoaXMuJGlzU3ViZG9jdW1lbnQpIHtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgY29uc3Qgc3ViZG9jcyA9IHRoaXMuJGdldEFsbFN1YmRvY3MoKTtcblxuICAgIGlmICghc3ViZG9jcy5sZW5ndGgpIHtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlYWNoKHN1YmRvY3MsIGZ1bmN0aW9uKHN1YmRvYywgY2IpIHtcbiAgICAgIHN1YmRvYy4kX19zY2hlbWEucy5ob29rcy5leGVjUHJlKCdzYXZlJywgc3ViZG9jLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQb3N0KCdzYXZlOmVycm9yJywgX3RoaXMsIFtfdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgIH0pO1xuICB9LCBudWxsLCB1bnNoaWZ0KTtcblxuICBzY2hlbWEucy5ob29rcy5wb3N0KCdzYXZlJywgZnVuY3Rpb24gc2F2ZVN1YmRvY3NQb3N0U2F2ZShkb2MsIG5leHQpIHtcbiAgICBpZiAodGhpcy4kaXNTdWJkb2N1bWVudCkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICBjb25zdCBzdWJkb2NzID0gdGhpcy4kZ2V0QWxsU3ViZG9jcygpO1xuXG4gICAgaWYgKCFzdWJkb2NzLmxlbmd0aCkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVhY2goc3ViZG9jcywgZnVuY3Rpb24oc3ViZG9jLCBjYikge1xuICAgICAgc3ViZG9jLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQb3N0KCdzYXZlJywgc3ViZG9jLCBbc3ViZG9jXSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy4kX19zY2hlbWEucy5ob29rcy5leGVjUG9zdCgnc2F2ZTplcnJvcicsIF90aGlzLCBbX3RoaXNdLCB7IGVycm9yOiBlcnJvciB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIG5leHQoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG5leHQoKTtcbiAgICB9KTtcbiAgfSwgbnVsbCwgdW5zaGlmdCk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/plugins/saveSubdocs.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/plugins/sharding.js":
/*!***************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/plugins/sharding.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst objectIdSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").objectIdSymbol);\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function shardingPlugin(schema) {\n  schema.post('init', function shardingPluginPostInit() {\n    storeShard.call(this);\n    return this;\n  });\n  schema.pre('save', function shardingPluginPreSave(next) {\n    applyWhere.call(this);\n    next();\n  });\n  schema.pre('remove', function shardingPluginPreRemove(next) {\n    applyWhere.call(this);\n    next();\n  });\n  schema.post('save', function shardingPluginPostSave() {\n    storeShard.call(this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction applyWhere() {\n  let paths;\n  let len;\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    this.$where = this.$where || {};\n    for (let i = 0; i < len; ++i) {\n      this.$where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports.storeShard = storeShard;\n\n/*!\n * ignore\n */\n\nfunction storeShard() {\n  // backwards compat\n  const key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;\n  if (!utils.isPOJO(key)) {\n    return;\n  }\n\n  const orig = this.$__.shardval = {};\n  const paths = Object.keys(key);\n  const len = paths.length;\n  let val;\n\n  for (let i = 0; i < len; ++i) {\n    val = this.$__getValue(paths[i]);\n    if (val == null) {\n      orig[paths[i]] = val;\n    } else if (utils.isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({ depopulate: true, _isNested: true });\n    } else if (val instanceof Date || val[objectIdSymbol]) {\n      orig[paths[i]] = val;\n    } else if (typeof val.valueOf === 'function') {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy9zaGFyZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix1QkFBdUIsOEhBQTRDO0FBQ25FLGNBQWMsbUJBQU8sQ0FBQyxvRUFBVTs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNDQUFzQyxtQ0FBbUM7QUFDekUsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxccGx1Z2luc1xcc2hhcmRpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvYmplY3RJZFN5bWJvbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc3ltYm9scycpLm9iamVjdElkU3ltYm9sO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhcmRpbmdQbHVnaW4oc2NoZW1hKSB7XG4gIHNjaGVtYS5wb3N0KCdpbml0JywgZnVuY3Rpb24gc2hhcmRpbmdQbHVnaW5Qb3N0SW5pdCgpIHtcbiAgICBzdG9yZVNoYXJkLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICBzY2hlbWEucHJlKCdzYXZlJywgZnVuY3Rpb24gc2hhcmRpbmdQbHVnaW5QcmVTYXZlKG5leHQpIHtcbiAgICBhcHBseVdoZXJlLmNhbGwodGhpcyk7XG4gICAgbmV4dCgpO1xuICB9KTtcbiAgc2NoZW1hLnByZSgncmVtb3ZlJywgZnVuY3Rpb24gc2hhcmRpbmdQbHVnaW5QcmVSZW1vdmUobmV4dCkge1xuICAgIGFwcGx5V2hlcmUuY2FsbCh0aGlzKTtcbiAgICBuZXh0KCk7XG4gIH0pO1xuICBzY2hlbWEucG9zdCgnc2F2ZScsIGZ1bmN0aW9uIHNoYXJkaW5nUGx1Z2luUG9zdFNhdmUoKSB7XG4gICAgc3RvcmVTaGFyZC5jYWxsKHRoaXMpO1xuICB9KTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlXaGVyZSgpIHtcbiAgbGV0IHBhdGhzO1xuICBsZXQgbGVuO1xuXG4gIGlmICh0aGlzLiRfXy5zaGFyZHZhbCkge1xuICAgIHBhdGhzID0gT2JqZWN0LmtleXModGhpcy4kX18uc2hhcmR2YWwpO1xuICAgIGxlbiA9IHBhdGhzLmxlbmd0aDtcblxuICAgIHRoaXMuJHdoZXJlID0gdGhpcy4kd2hlcmUgfHwge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGhpcy4kd2hlcmVbcGF0aHNbaV1dID0gdGhpcy4kX18uc2hhcmR2YWxbcGF0aHNbaV1dO1xuICAgIH1cbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzLnN0b3JlU2hhcmQgPSBzdG9yZVNoYXJkO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIHN0b3JlU2hhcmQoKSB7XG4gIC8vIGJhY2t3YXJkcyBjb21wYXRcbiAgY29uc3Qga2V5ID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy5zaGFyZEtleSB8fCB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnNoYXJka2V5O1xuICBpZiAoIXV0aWxzLmlzUE9KTyhrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgb3JpZyA9IHRoaXMuJF9fLnNoYXJkdmFsID0ge307XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoa2V5KTtcbiAgY29uc3QgbGVuID0gcGF0aHMubGVuZ3RoO1xuICBsZXQgdmFsO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YWwgPSB0aGlzLiRfX2dldFZhbHVlKHBhdGhzW2ldKTtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIG9yaWdbcGF0aHNbaV1dID0gdmFsO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNNb25nb29zZU9iamVjdCh2YWwpKSB7XG4gICAgICBvcmlnW3BhdGhzW2ldXSA9IHZhbC50b09iamVjdCh7IGRlcG9wdWxhdGU6IHRydWUsIF9pc05lc3RlZDogdHJ1ZSB9KTtcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUgfHwgdmFsW29iamVjdElkU3ltYm9sXSkge1xuICAgICAgb3JpZ1twYXRoc1tpXV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9yaWdbcGF0aHNbaV1dID0gdmFsLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ1twYXRoc1tpXV0gPSB2YWw7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/plugins/sharding.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/plugins/trackTransaction.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/plugins/trackTransaction.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst sessionNewDocuments = (__webpack_require__(/*! ../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").sessionNewDocuments);\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = function trackTransaction(schema) {\n  schema.pre('save', function trackTransactionPreSave() {\n    const session = this.$session();\n    if (session == null) {\n      return;\n    }\n    if (session.transaction == null || session[sessionNewDocuments] == null) {\n      return;\n    }\n\n    if (!session[sessionNewDocuments].has(this)) {\n      const initialState = {};\n      if (this.isNew) {\n        initialState.isNew = true;\n      }\n      if (this.$__schema.options.versionKey) {\n        initialState.versionKey = this.get(this.$__schema.options.versionKey);\n      }\n\n      initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths('modify')));\n      initialState.atomics = _getAtomics(this);\n\n      session[sessionNewDocuments].set(this, initialState);\n    } else {\n      const state = session[sessionNewDocuments].get(this);\n\n      for (const path of Object.keys(this.$__.activePaths.getStatePaths('modify'))) {\n        state.modifiedPaths.add(path);\n      }\n      state.atomics = _getAtomics(this, state.atomics);\n    }\n  });\n};\n\nfunction _getAtomics(doc, previous) {\n  const pathToAtomics = new Map();\n  previous = previous || new Map();\n\n  const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));\n\n  for (const path of pathsToCheck) {\n    const val = doc.$__getValue(path);\n    if (val != null &&\n        Array.isArray(val) &&\n        utils.isMongooseDocumentArray(val) &&\n        val.length &&\n        val[arrayAtomicsSymbol] != null &&\n        Object.keys(val[arrayAtomicsSymbol]).length !== 0) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  const dirty = doc.$__dirty();\n  for (const dirt of dirty) {\n    const path = dirt.path;\n\n    const val = dirt.value;\n    if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  return pathToAtomics;\n}\n\nfunction mergeAtomics(destination, source) {\n  destination = destination || {};\n\n  if (source.$pullAll != null) {\n    destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);\n  }\n  if (source.$push != null) {\n    destination.$push = destination.$push || {};\n    destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);\n  }\n  if (source.$addToSet != null) {\n    destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);\n  }\n  if (source.$set != null) {\n    destination.$set = Object.assign(destination.$set || {}, source.$set);\n  }\n\n  return destination;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy90cmFja1RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDJCQUEyQixrSUFBZ0Q7QUFDM0UsNEJBQTRCLG1JQUFpRDtBQUM3RSxjQUFjLG1CQUFPLENBQUMsb0VBQVU7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHBsdWdpbnNcXHRyYWNrVHJhbnNhY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheUF0b21pY3NTeW1ib2w7XG5jb25zdCBzZXNzaW9uTmV3RG9jdW1lbnRzID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykuc2Vzc2lvbk5ld0RvY3VtZW50cztcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFja1RyYW5zYWN0aW9uKHNjaGVtYSkge1xuICBzY2hlbWEucHJlKCdzYXZlJywgZnVuY3Rpb24gdHJhY2tUcmFuc2FjdGlvblByZVNhdmUoKSB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuJHNlc3Npb24oKTtcbiAgICBpZiAoc2Vzc2lvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzZXNzaW9uLnRyYW5zYWN0aW9uID09IG51bGwgfHwgc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFzZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdLmhhcyh0aGlzKSkge1xuICAgICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge307XG4gICAgICBpZiAodGhpcy5pc05ldykge1xuICAgICAgICBpbml0aWFsU3RhdGUuaXNOZXcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSkge1xuICAgICAgICBpbml0aWFsU3RhdGUudmVyc2lvbktleSA9IHRoaXMuZ2V0KHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxTdGF0ZS5tb2RpZmllZFBhdGhzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdtb2RpZnknKSkpO1xuICAgICAgaW5pdGlhbFN0YXRlLmF0b21pY3MgPSBfZ2V0QXRvbWljcyh0aGlzKTtcblxuICAgICAgc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXS5zZXQodGhpcywgaW5pdGlhbFN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhdGUgPSBzZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdLmdldCh0aGlzKTtcblxuICAgICAgZm9yIChjb25zdCBwYXRoIG9mIE9iamVjdC5rZXlzKHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpKSkge1xuICAgICAgICBzdGF0ZS5tb2RpZmllZFBhdGhzLmFkZChwYXRoKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmF0b21pY3MgPSBfZ2V0QXRvbWljcyh0aGlzLCBzdGF0ZS5hdG9taWNzKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gX2dldEF0b21pY3MoZG9jLCBwcmV2aW91cykge1xuICBjb25zdCBwYXRoVG9BdG9taWNzID0gbmV3IE1hcCgpO1xuICBwcmV2aW91cyA9IHByZXZpb3VzIHx8IG5ldyBNYXAoKTtcblxuICBjb25zdCBwYXRoc1RvQ2hlY2sgPSBPYmplY3Qua2V5cyhkb2MuJF9fLmFjdGl2ZVBhdGhzLmluaXQpLmNvbmNhdChPYmplY3Qua2V5cyhkb2MuJF9fLmFjdGl2ZVBhdGhzLm1vZGlmeSkpO1xuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoc1RvQ2hlY2spIHtcbiAgICBjb25zdCB2YWwgPSBkb2MuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgaWYgKHZhbCAhPSBudWxsICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsKSAmJlxuICAgICAgICB1dGlscy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWwpICYmXG4gICAgICAgIHZhbC5sZW5ndGggJiZcbiAgICAgICAgdmFsW2FycmF5QXRvbWljc1N5bWJvbF0gIT0gbnVsbCAmJlxuICAgICAgICBPYmplY3Qua2V5cyh2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IHByZXZpb3VzLmdldChwYXRoKSB8fCB7fTtcbiAgICAgIHBhdGhUb0F0b21pY3Muc2V0KHBhdGgsIG1lcmdlQXRvbWljcyhleGlzdGluZywgdmFsW2FycmF5QXRvbWljc1N5bWJvbF0pKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkaXJ0eSA9IGRvYy4kX19kaXJ0eSgpO1xuICBmb3IgKGNvbnN0IGRpcnQgb2YgZGlydHkpIHtcbiAgICBjb25zdCBwYXRoID0gZGlydC5wYXRoO1xuXG4gICAgY29uc3QgdmFsID0gZGlydC52YWx1ZTtcbiAgICBpZiAodmFsICE9IG51bGwgJiYgdmFsW2FycmF5QXRvbWljc1N5bWJvbF0gIT0gbnVsbCAmJiBPYmplY3Qua2V5cyh2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IHByZXZpb3VzLmdldChwYXRoKSB8fCB7fTtcbiAgICAgIHBhdGhUb0F0b21pY3Muc2V0KHBhdGgsIG1lcmdlQXRvbWljcyhleGlzdGluZywgdmFsW2FycmF5QXRvbWljc1N5bWJvbF0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0aFRvQXRvbWljcztcbn1cblxuZnVuY3Rpb24gbWVyZ2VBdG9taWNzKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbiB8fCB7fTtcblxuICBpZiAoc291cmNlLiRwdWxsQWxsICE9IG51bGwpIHtcbiAgICBkZXN0aW5hdGlvbi4kcHVsbEFsbCA9IChkZXN0aW5hdGlvbi4kcHVsbEFsbCB8fCBbXSkuY29uY2F0KHNvdXJjZS4kcHVsbEFsbCk7XG4gIH1cbiAgaWYgKHNvdXJjZS4kcHVzaCAhPSBudWxsKSB7XG4gICAgZGVzdGluYXRpb24uJHB1c2ggPSBkZXN0aW5hdGlvbi4kcHVzaCB8fCB7fTtcbiAgICBkZXN0aW5hdGlvbi4kcHVzaC4kZWFjaCA9IChkZXN0aW5hdGlvbi4kcHVzaC4kZWFjaCB8fCBbXSkuY29uY2F0KHNvdXJjZS4kcHVzaC4kZWFjaCk7XG4gIH1cbiAgaWYgKHNvdXJjZS4kYWRkVG9TZXQgIT0gbnVsbCkge1xuICAgIGRlc3RpbmF0aW9uLiRhZGRUb1NldCA9IChkZXN0aW5hdGlvbi4kYWRkVG9TZXQgfHwgW10pLmNvbmNhdChzb3VyY2UuJGFkZFRvU2V0KTtcbiAgfVxuICBpZiAoc291cmNlLiRzZXQgIT0gbnVsbCkge1xuICAgIGRlc3RpbmF0aW9uLiRzZXQgPSBPYmplY3QuYXNzaWduKGRlc3RpbmF0aW9uLiRzZXQgfHwge30sIHNvdXJjZS4kc2V0KTtcbiAgfVxuXG4gIHJldHVybiBkZXN0aW5hdGlvbjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/plugins/trackTransaction.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/plugins/validateBeforeSave.js":
/*!*************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/plugins/validateBeforeSave.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function validateBeforeSave(schema) {\n  const unshift = true;\n  schema.pre('save', false, function validateBeforeSave(next, options) {\n    const _this = this;\n    // Nested docs have their own presave\n    if (this.$isSubdocument) {\n      return next();\n    }\n\n    const hasValidateBeforeSaveOption = options &&\n        (typeof options === 'object') &&\n        ('validateBeforeSave' in options);\n\n    let shouldValidate;\n    if (hasValidateBeforeSaveOption) {\n      shouldValidate = !!options.validateBeforeSave;\n    } else {\n      shouldValidate = this.$__schema.options.validateBeforeSave;\n    }\n\n    // Validate\n    if (shouldValidate) {\n      const hasValidateModifiedOnlyOption = options &&\n          (typeof options === 'object') &&\n          ('validateModifiedOnly' in options);\n      const validateOptions = hasValidateModifiedOnlyOption ?\n        { validateModifiedOnly: options.validateModifiedOnly } :\n        null;\n      this.$validate(validateOptions).then(\n        () => {\n          this.$op = 'save';\n          next();\n        },\n        error => {\n          _this.$__schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n            _this.$op = 'save';\n            next(error);\n          });\n        }\n      );\n    } else {\n      next();\n    }\n  }, null, unshift);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy92YWxpZGF0ZUJlZm9yZVNhdmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscURBQXFEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyRUFBMkUsY0FBYztBQUN6RjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHBsdWdpbnNcXHZhbGlkYXRlQmVmb3JlU2F2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUJlZm9yZVNhdmUoc2NoZW1hKSB7XG4gIGNvbnN0IHVuc2hpZnQgPSB0cnVlO1xuICBzY2hlbWEucHJlKCdzYXZlJywgZmFsc2UsIGZ1bmN0aW9uIHZhbGlkYXRlQmVmb3JlU2F2ZShuZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIC8vIE5lc3RlZCBkb2NzIGhhdmUgdGhlaXIgb3duIHByZXNhdmVcbiAgICBpZiAodGhpcy4kaXNTdWJkb2N1bWVudCkge1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNWYWxpZGF0ZUJlZm9yZVNhdmVPcHRpb24gPSBvcHRpb25zICYmXG4gICAgICAgICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpICYmXG4gICAgICAgICgndmFsaWRhdGVCZWZvcmVTYXZlJyBpbiBvcHRpb25zKTtcblxuICAgIGxldCBzaG91bGRWYWxpZGF0ZTtcbiAgICBpZiAoaGFzVmFsaWRhdGVCZWZvcmVTYXZlT3B0aW9uKSB7XG4gICAgICBzaG91bGRWYWxpZGF0ZSA9ICEhb3B0aW9ucy52YWxpZGF0ZUJlZm9yZVNhdmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFZhbGlkYXRlID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy52YWxpZGF0ZUJlZm9yZVNhdmU7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGVcbiAgICBpZiAoc2hvdWxkVmFsaWRhdGUpIHtcbiAgICAgIGNvbnN0IGhhc1ZhbGlkYXRlTW9kaWZpZWRPbmx5T3B0aW9uID0gb3B0aW9ucyAmJlxuICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgKCd2YWxpZGF0ZU1vZGlmaWVkT25seScgaW4gb3B0aW9ucyk7XG4gICAgICBjb25zdCB2YWxpZGF0ZU9wdGlvbnMgPSBoYXNWYWxpZGF0ZU1vZGlmaWVkT25seU9wdGlvbiA/XG4gICAgICAgIHsgdmFsaWRhdGVNb2RpZmllZE9ubHk6IG9wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHkgfSA6XG4gICAgICAgIG51bGw7XG4gICAgICB0aGlzLiR2YWxpZGF0ZSh2YWxpZGF0ZU9wdGlvbnMpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICB0aGlzLiRvcCA9ICdzYXZlJztcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICBfdGhpcy4kX19zY2hlbWEucy5ob29rcy5leGVjUG9zdCgnc2F2ZTplcnJvcicsIF90aGlzLCBbX3RoaXNdLCB7IGVycm9yOiBlcnJvciB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMuJG9wID0gJ3NhdmUnO1xuICAgICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gIH0sIG51bGwsIHVuc2hpZnQpO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/plugins/validateBeforeSave.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/query.js":
/*!****************************************************!*\
  !*** ../server/node_modules/mongoose/lib/query.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ./error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\nconst DocumentNotFoundError = __webpack_require__(/*! ./error/notFound */ \"(api)/../server/node_modules/mongoose/lib/error/notFound.js\");\nconst Kareem = __webpack_require__(/*! kareem */ \"(api)/../server/node_modules/kareem/index.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst ObjectParameterError = __webpack_require__(/*! ./error/objectParameter */ \"(api)/../server/node_modules/mongoose/lib/error/objectParameter.js\");\nconst QueryCursor = __webpack_require__(/*! ./cursor/QueryCursor */ \"(api)/../server/node_modules/mongoose/lib/cursor/QueryCursor.js\");\nconst ValidationError = __webpack_require__(/*! ./error/validation */ \"(api)/../server/node_modules/mongoose/lib/error/validation.js\");\nconst { applyGlobalMaxTimeMS, applyGlobalDiskUse } = __webpack_require__(/*! ./helpers/query/applyGlobalOption */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js\");\nconst handleReadPreferenceAliases = __webpack_require__(/*! ./helpers/query/handleReadPreferenceAliases */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js\");\nconst applyWriteConcern = __webpack_require__(/*! ./helpers/schema/applyWriteConcern */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js\");\nconst cast = __webpack_require__(/*! ./cast */ \"(api)/../server/node_modules/mongoose/lib/cast.js\");\nconst castArrayFilters = __webpack_require__(/*! ./helpers/update/castArrayFilters */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/castArrayFilters.js\");\nconst castNumber = __webpack_require__(/*! ./cast/number */ \"(api)/../server/node_modules/mongoose/lib/cast/number.js\");\nconst castUpdate = __webpack_require__(/*! ./helpers/query/castUpdate */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/castUpdate.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst completeMany = __webpack_require__(/*! ./helpers/query/completeMany */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/completeMany.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst hasDollarKeys = __webpack_require__(/*! ./helpers/query/hasDollarKeys */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\");\nconst helpers = __webpack_require__(/*! ./queryhelpers */ \"(api)/../server/node_modules/mongoose/lib/queryhelpers.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ./options */ \"(api)/../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst isExclusive = __webpack_require__(/*! ./helpers/projection/isExclusive */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst isInclusive = __webpack_require__(/*! ./helpers/projection/isInclusive */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isInclusive.js\");\nconst isPathSelectedInclusive = __webpack_require__(/*! ./helpers/projection/isPathSelectedInclusive */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\");\nconst isSubpath = __webpack_require__(/*! ./helpers/projection/isSubpath */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isSubpath.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(api)/../server/node_modules/mpath/index.js\");\nconst mquery = __webpack_require__(/*! mquery */ \"(api)/../server/node_modules/mquery/lib/mquery.js\");\nconst parseProjection = __webpack_require__(/*! ./helpers/projection/parseProjection */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/parseProjection.js\");\nconst removeUnusedArrayFilters = __webpack_require__(/*! ./helpers/update/removeUnusedArrayFilters */ \"(api)/../server/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js\");\nconst sanitizeFilter = __webpack_require__(/*! ./helpers/query/sanitizeFilter */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js\");\nconst sanitizeProjection = __webpack_require__(/*! ./helpers/query/sanitizeProjection */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js\");\nconst selectPopulatedFields = __webpack_require__(/*! ./helpers/query/selectPopulatedFields */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js\");\nconst setDefaultsOnInsert = __webpack_require__(/*! ./helpers/setDefaultsOnInsert */ \"(api)/../server/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js\");\nconst updateValidators = __webpack_require__(/*! ./helpers/updateValidators */ \"(api)/../server/node_modules/mongoose/lib/helpers/updateValidators.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst validOps = __webpack_require__(/*! ./helpers/query/validOps */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/validOps.js\");\n\nconst queryOptionMethods = new Set([\n  'allowDiskUse',\n  'batchSize',\n  'collation',\n  'comment',\n  'explain',\n  'hint',\n  'j',\n  'lean',\n  'limit',\n  'maxTimeMS',\n  'populate',\n  'projection',\n  'read',\n  'select',\n  'skip',\n  'slice',\n  'sort',\n  'tailable',\n  'w',\n  'writeConcern',\n  'wtimeout'\n]);\n\n/**\n * Query constructor used for building queries. You do not need\n * to instantiate a `Query` directly. Instead use Model functions like\n * [`Model.find()`](https://mongoosejs.com/docs/api/model.html#Model.find()).\n *\n * #### Example:\n *\n *     const query = MyModel.find(); // `query` is an instance of `Query`\n *     query.setOptions({ lean : true });\n *     query.collection(MyModel.collection);\n *     query.where('age').gte(21).exec(callback);\n *\n *     // You can instantiate a query directly. There is no need to do\n *     // this unless you're an advanced user with a very good reason to.\n *     const query = new mongoose.Query();\n *\n * @param {Object} [options]\n * @param {Object} [model]\n * @param {Object} [conditions]\n * @param {Object} [collection] Mongoose collection\n * @api public\n */\n\nfunction Query(conditions, options, model, collection) {\n  // this stuff is for dealing with custom queries created by #toConstructor\n  if (!this._mongooseOptions) {\n    this._mongooseOptions = {};\n  }\n  options = options || {};\n\n  this._transforms = [];\n  this._hooks = new Kareem();\n  this._executionStack = null;\n\n  // this is the case where we have a CustomQuery, we need to check if we got\n  // options passed in, and if we did, merge them in\n  const keys = Object.keys(options);\n  for (const key of keys) {\n    this._mongooseOptions[key] = options[key];\n  }\n\n  if (collection) {\n    this.mongooseCollection = collection;\n  }\n\n  if (model) {\n    this.model = model;\n    this.schema = model.schema;\n  }\n\n  // this is needed because map reduce returns a model that can be queried, but\n  // all of the queries on said model should be lean\n  if (this.model && this.model._mapreduce) {\n    this.lean();\n  }\n\n  // inherit mquery\n  mquery.call(this, null, options);\n  if (collection) {\n    this.collection(collection);\n  }\n\n  if (conditions) {\n    this.find(conditions);\n  }\n\n  this.options = this.options || {};\n\n  // For gh-6880. mquery still needs to support `fields` by default for old\n  // versions of MongoDB\n  this.$useProjection = true;\n\n  const collation = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collation || null;\n  if (collation != null) {\n    this.options.collation = collation;\n  }\n}\n\n/*!\n * inherit mquery\n */\n\nQuery.prototype = new mquery();\nQuery.prototype.constructor = Query;\nQuery.base = mquery.prototype;\n\n/*!\n * Overwrite mquery's `_distinct`, because Mongoose uses that name\n * to store the field to apply distinct on.\n */\n\nObject.defineProperty(Query.prototype, '_distinct', {\n  configurable: true,\n  writable: true,\n  enumerable: true,\n  value: undefined\n});\n\n/**\n * Flag to opt out of using `$geoWithin`.\n *\n * ```javascript\n * mongoose.Query.use$geoWithin = false;\n * ```\n *\n * MongoDB 2.4 deprecated the use of `$within`, replacing it with `$geoWithin`. Mongoose uses `$geoWithin` by default (which is 100% backward compatible with `$within`). If you are running an older version of MongoDB, set this flag to `false` so your `within()` queries continue to work.\n *\n * @see geoWithin https://www.mongodb.com/docs/manual/reference/operator/geoWithin/\n * @default true\n * @property use$geoWithin\n * @memberOf Query\n * @static\n * @api public\n */\n\nQuery.use$geoWithin = mquery.use$geoWithin;\n\n/**\n * Converts this query to a customized, reusable query constructor with all arguments and options retained.\n *\n * #### Example:\n *\n *     // Create a query for adventure movies and read from the primary\n *     // node in the replica-set unless it is down, in which case we'll\n *     // read from a secondary node.\n *     const query = Movie.find({ tags: 'adventure' }).read('primaryPreferred');\n *\n *     // create a custom Query constructor based off these settings\n *     const Adventure = query.toConstructor();\n *\n *     // further narrow down our query results while still using the previous settings\n *     await Adventure().where({ name: /^Life/ }).exec();\n *\n *     // since Adventure is a stand-alone constructor we can also add our own\n *     // helper methods and getters without impacting global queries\n *     Adventure.prototype.startsWith = function (prefix) {\n *       this.where({ name: new RegExp('^' + prefix) })\n *       return this;\n *     }\n *     Object.defineProperty(Adventure.prototype, 'highlyRated', {\n *       get: function () {\n *         this.where({ rating: { $gt: 4.5 }});\n *         return this;\n *       }\n *     })\n *     await Adventure().highlyRated.startsWith('Life').exec();\n *\n * @return {Query} subclass-of-Query\n * @api public\n */\n\nQuery.prototype.toConstructor = function toConstructor() {\n  const model = this.model;\n  const coll = this.mongooseCollection;\n\n  const CustomQuery = function(criteria, options) {\n    if (!(this instanceof CustomQuery)) {\n      return new CustomQuery(criteria, options);\n    }\n    this._mongooseOptions = clone(p._mongooseOptions);\n    Query.call(this, criteria, options || null, model, coll);\n  };\n\n  util.inherits(CustomQuery, model.Query);\n\n  // set inherited defaults\n  const p = CustomQuery.prototype;\n\n  p.options = {};\n\n  // Need to handle `sort()` separately because entries-style `sort()` syntax\n  // `sort([['prop1', 1]])` confuses mquery into losing the outer nested array.\n  // See gh-8159\n  const options = Object.assign({}, this.options);\n  if (options.sort != null) {\n    p.sort(options.sort);\n    delete options.sort;\n  }\n  p.setOptions(options);\n\n  p.op = this.op;\n  p._validateOp();\n  p._conditions = clone(this._conditions);\n  p._fields = clone(this._fields);\n  p._update = clone(this._update, {\n    flattenDecimals: false\n  });\n  p._path = this._path;\n  p._distinct = this._distinct;\n  p._collection = this._collection;\n  p._mongooseOptions = this._mongooseOptions;\n\n  return CustomQuery;\n};\n\n/**\n * Make a copy of this query so you can re-execute it.\n *\n * #### Example:\n *\n *     const q = Book.findOne({ title: 'Casino Royale' });\n *     await q.exec();\n *     await q.exec(); // Throws an error because you can't execute a query twice\n *\n *     await q.clone().exec(); // Works\n *\n * @method clone\n * @return {Query} copy\n * @memberOf Query\n * @instance\n * @api public\n */\n\nQuery.prototype.clone = function() {\n  const model = this.model;\n  const collection = this.mongooseCollection;\n\n  const q = new this.model.Query({}, {}, model, collection);\n\n  // Need to handle `sort()` separately because entries-style `sort()` syntax\n  // `sort([['prop1', 1]])` confuses mquery into losing the outer nested array.\n  // See gh-8159\n  const options = Object.assign({}, this.options);\n  if (options.sort != null) {\n    q.sort(options.sort);\n    delete options.sort;\n  }\n  q.setOptions(options);\n\n  q.op = this.op;\n  q._validateOp();\n  q._conditions = clone(this._conditions);\n  q._fields = clone(this._fields);\n  q._update = clone(this._update, {\n    flattenDecimals: false\n  });\n  q._path = this._path;\n  q._distinct = this._distinct;\n  q._collection = this._collection;\n  q._mongooseOptions = this._mongooseOptions;\n\n  return q;\n};\n\n/**\n * Specifies a javascript function or expression to pass to MongoDBs query system.\n *\n * #### Example:\n *\n *     query.$where('this.comments.length === 10 || this.name.length === 5')\n *\n *     // or\n *\n *     query.$where(function () {\n *       return this.comments.length === 10 || this.name.length === 5;\n *     })\n *\n * #### Note:\n *\n * Only use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`.\n * **Be sure to read about all of [its caveats](https://www.mongodb.com/docs/manual/reference/operator/where/) before using.**\n *\n * @see $where https://www.mongodb.com/docs/manual/reference/operator/where/\n * @method $where\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @instance\n * @method $where\n * @api public\n */\n\n/**\n * Specifies a `path` for use with chaining.\n *\n * #### Example:\n *\n *     // instead of writing:\n *     User.find({age: {$gte: 21, $lte: 65}});\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^vonderful/i)\n *     .where('friends').slice(10)\n *     .exec()\n *\n * @method where\n * @memberOf Query\n * @instance\n * @param {String|Object} [path]\n * @param {any} [val]\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies a `$slice` projection for an array.\n *\n * #### Example:\n *\n *     query.slice('comments', 5); // Returns the first 5 comments\n *     query.slice('comments', -5); // Returns the last 5 comments\n *     query.slice('comments', [10, 5]); // Returns the first 5 comments after the 10-th\n *     query.where('comments').slice(5); // Returns the first 5 comments\n *     query.where('comments').slice([-10, 5]); // Returns the first 5 comments after the 10-th to last\n *\n * **Note:** If the absolute value of the number of elements to be sliced is greater than the number of elements in the array, all array elements will be returned.\n *\n *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', 20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', -20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *\n * **Note:** If the number of elements to skip is positive and greater than the number of elements in the array, an empty array will be returned.\n *\n *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', [20, 5]); // Returns []\n *\n * **Note:** If the number of elements to skip is negative and its absolute value is greater than the number of elements in the array, the starting position is the start of the array.\n *\n *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', [-20, 5]); // Returns [1, 2, 3, 4, 5]\n *\n * @method slice\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number|Array} val number of elements to slice or array with number of elements to skip and number of elements to slice\n * @return {Query} this\n * @see mongodb https://www.mongodb.com/docs/manual/tutorial/query-documents/#projection\n * @see $slice https://www.mongodb.com/docs/manual/reference/projection/slice/#prj._S_slice\n * @api public\n */\n\nQuery.prototype.slice = function() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  this._validate('slice');\n\n  let path;\n  let val;\n\n  if (arguments.length === 1) {\n    const arg = arguments[0];\n    if (typeof arg === 'object' && !Array.isArray(arg)) {\n      const keys = Object.keys(arg);\n      const numKeys = keys.length;\n      for (let i = 0; i < numKeys; ++i) {\n        this.slice(keys[i], arg[keys[i]]);\n      }\n      return this;\n    }\n    this._ensurePath('slice');\n    path = this._path;\n    val = arguments[0];\n  } else if (arguments.length === 2) {\n    if ('number' === typeof arguments[0]) {\n      this._ensurePath('slice');\n      path = this._path;\n      val = [arguments[0], arguments[1]];\n    } else {\n      path = arguments[0];\n      val = arguments[1];\n    }\n  } else if (arguments.length === 3) {\n    path = arguments[0];\n    val = [arguments[1], arguments[2]];\n  }\n\n  const p = {};\n  p[path] = { $slice: val };\n  this.select(p);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nconst validOpsSet = new Set(validOps);\n\nQuery.prototype._validateOp = function() {\n  if (this.op != null && !validOpsSet.has(this.op)) {\n    this.error(new Error('Query has invalid `op`: \"' + this.op + '\"'));\n  }\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * #### Example:\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @method equals\n * @memberOf Query\n * @instance\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for an `$or` condition.\n *\n * #### Example:\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }]);\n *\n * @see $or https://www.mongodb.com/docs/manual/reference/operator/or/\n * @method or\n * @memberOf Query\n * @instance\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * #### Example:\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }]);\n *\n * @see $nor https://www.mongodb.com/docs/manual/reference/operator/nor/\n * @method nor\n * @memberOf Query\n * @instance\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for a `$and` condition.\n *\n * #### Example:\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @method and\n * @memberOf Query\n * @instance\n * @see $and https://www.mongodb.com/docs/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies a `$gt` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     Thing.find().where('age').gt(21);\n *\n *     // or\n *     Thing.find().gt('age', 21);\n *\n * @method gt\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $gt https://www.mongodb.com/docs/manual/reference/operator/gt/\n * @api public\n */\n\n/**\n * Specifies a `$gte` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $gte https://www.mongodb.com/docs/manual/reference/operator/gte/\n * @api public\n */\n\n/**\n * Specifies a `$lt` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $lt https://www.mongodb.com/docs/manual/reference/operator/lt/\n * @api public\n */\n\n/**\n * Specifies a `$lte` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @see $lte https://www.mongodb.com/docs/manual/reference/operator/lte/\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$ne` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $ne https://www.mongodb.com/docs/manual/reference/operator/ne/\n * @method ne\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {any} val\n * @api public\n */\n\n/**\n * Specifies an `$in` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $in https://www.mongodb.com/docs/manual/reference/operator/in/\n * @method in\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val\n * @api public\n */\n\n/**\n * Specifies an `$nin` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $nin https://www.mongodb.com/docs/manual/reference/operator/nin/\n * @method nin\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val\n * @api public\n */\n\n/**\n * Specifies an `$all` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     MyModel.find().where('pets').all(['dog', 'cat', 'ferret']);\n *     // Equivalent:\n *     MyModel.find().all('pets', ['dog', 'cat', 'ferret']);\n *\n * @see $all https://www.mongodb.com/docs/manual/reference/operator/all/\n * @method all\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val\n * @api public\n */\n\n/**\n * Specifies a `$size` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     const docs = await MyModel.where('tags').size(0).exec();\n *     assert(Array.isArray(docs));\n *     console.log('documents with 0 tags', docs);\n *\n * @see $size https://www.mongodb.com/docs/manual/reference/operator/size/\n * @method size\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$regex` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $regex https://www.mongodb.com/docs/manual/reference/operator/regex/\n * @method regex\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {String|RegExp} val\n * @api public\n */\n\n/**\n * Specifies a `maxDistance` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $maxDistance https://www.mongodb.com/docs/manual/reference/operator/maxDistance/\n * @method maxDistance\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$mod` condition, filters documents for documents whose\n * `path` property is a number that is equal to `remainder` modulo `divisor`.\n *\n * #### Example:\n *\n *     // All find products whose inventory is odd\n *     Product.find().mod('inventory', [2, 1]);\n *     Product.find().where('inventory').mod([2, 1]);\n *     // This syntax is a little strange, but supported.\n *     Product.find().where('inventory').mod(2, 1);\n *\n * @method mod\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val must be of length 2, first element is `divisor`, 2nd element is `remainder`.\n * @return {Query} this\n * @see $mod https://www.mongodb.com/docs/manual/reference/operator/mod/\n * @api public\n */\n\nQuery.prototype.mod = function() {\n  let val;\n  let path;\n\n  if (arguments.length === 1) {\n    this._ensurePath('mod');\n    val = arguments[0];\n    path = this._path;\n  } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {\n    this._ensurePath('mod');\n    val = [arguments[0], arguments[1]];\n    path = this._path;\n  } else if (arguments.length === 3) {\n    val = [arguments[1], arguments[2]];\n    path = arguments[0];\n  } else {\n    val = arguments[1];\n    path = arguments[0];\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$mod = val;\n  return this;\n};\n\n/**\n * Specifies an `$exists` condition\n *\n * #### Example:\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @method exists\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Boolean} val\n * @return {Query} this\n * @see $exists https://www.mongodb.com/docs/manual/reference/operator/exists/\n * @api public\n */\n\n/**\n * Specifies an `$elemMatch` condition\n *\n * #### Example:\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @method elemMatch\n * @memberOf Query\n * @instance\n * @param {String|Object|Function} path\n * @param {Object|Function} filter\n * @return {Query} this\n * @see $elemMatch https://www.mongodb.com/docs/manual/reference/operator/elemMatch/\n * @api public\n */\n\n/**\n * Defines a `$within` or `$geoWithin` argument for geo-spatial queries.\n *\n * #### Example:\n *\n *     query.where(path).within().box()\n *     query.where(path).within().circle()\n *     query.where(path).within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * **MUST** be used after `where()`.\n *\n * #### Note:\n *\n * As of Mongoose 3.7, `$geoWithin` is always used for queries. To change this behavior, see [Query.use$geoWithin](https://mongoosejs.com/docs/api/query.html#Query.prototype.use$geoWithin).\n *\n * #### Note:\n *\n * In Mongoose 3.7, `within` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n *\n * @method within\n * @see $polygon https://www.mongodb.com/docs/manual/reference/operator/polygon/\n * @see $box https://www.mongodb.com/docs/manual/reference/operator/box/\n * @see $geometry https://www.mongodb.com/docs/manual/reference/operator/geometry/\n * @see $center https://www.mongodb.com/docs/manual/reference/operator/center/\n * @see $centerSphere https://www.mongodb.com/docs/manual/reference/operator/centerSphere/\n * @memberOf Query\n * @instance\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies the maximum number of documents the query will return.\n *\n * #### Example:\n *\n *     query.limit(20);\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @api public\n */\n\nQuery.prototype.limit = function limit(v) {\n  this._validate('limit');\n\n  if (typeof v === 'string') {\n    try {\n      v = castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v, 'limit');\n    }\n  }\n\n  this.options.limit = v;\n  return this;\n};\n\n/**\n * Specifies the number of documents to skip.\n *\n * #### Example:\n *\n *     query.skip(100).limit(20);\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @see cursor.skip https://www.mongodb.com/docs/manual/reference/method/cursor.skip/\n * @api public\n */\n\nQuery.prototype.skip = function skip(v) {\n  this._validate('skip');\n\n  if (typeof v === 'string') {\n    try {\n      v = castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v, 'skip');\n    }\n  }\n\n  this.options.skip = v;\n  return this;\n};\n\n/**\n * Specifies the batchSize option.\n *\n * #### Example:\n *\n *     query.batchSize(100)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @see batchSize https://www.mongodb.com/docs/manual/reference/method/cursor.batchSize/\n * @api public\n */\n\n/**\n * Specifies the `comment` option.\n *\n * #### Example:\n *\n *     query.comment('login query')\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @instance\n * @param {String} val\n * @see comment https://www.mongodb.com/docs/manual/reference/operator/comment/\n * @api public\n */\n\n/**\n * Sets query hints.\n *\n * #### Example:\n *\n *     query.hint({ indexA: 1, indexB: -1 });\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method hint\n * @memberOf Query\n * @instance\n * @param {Object} val a hint object\n * @return {Query} this\n * @see $hint https://www.mongodb.com/docs/manual/reference/operator/hint/\n * @api public\n */\n\n/**\n * Get/set the current projection (AKA fields). Pass `null` to remove the\n * current projection.\n *\n * Unlike `projection()`, the `select()` function modifies the current\n * projection in place. This function overwrites the existing projection.\n *\n * #### Example:\n *\n *     const q = Model.find();\n *     q.projection(); // null\n *\n *     q.select('a b');\n *     q.projection(); // { a: 1, b: 1 }\n *\n *     q.projection({ c: 1 });\n *     q.projection(); // { c: 1 }\n *\n *     q.projection(null);\n *     q.projection(); // null\n *\n *\n * @method projection\n * @memberOf Query\n * @instance\n * @param {Object|null} arg\n * @return {Object} the current projection\n * @api public\n */\n\nQuery.prototype.projection = function(arg) {\n  if (arguments.length === 0) {\n    return this._fields;\n  }\n\n  this._fields = {};\n  this._userProvidedFields = {};\n  this.select(arg);\n  return this._fields;\n};\n\n/**\n * Specifies which document fields to include or exclude (also known as the query \"projection\")\n *\n * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.select()).\n *\n * A projection _must_ be either inclusive or exclusive. In other words, you must\n * either list the fields to include (which excludes all others), or list the fields\n * to exclude (which implies all other fields are included). The [`_id` field is the only exception because MongoDB includes it by default](https://www.mongodb.com/docs/manual/tutorial/project-fields-from-query-results/#suppress-id-field).\n *\n * #### Example:\n *\n *     // include a and b, exclude other fields\n *     query.select('a b');\n *     // Equivalent syntaxes:\n *     query.select(['a', 'b']);\n *     query.select({ a: 1, b: 1 });\n *\n *     // exclude c and d, include other fields\n *     query.select('-c -d');\n *\n *     // Use `+` to override schema-level `select: false` without making the\n *     // projection inclusive.\n *     const schema = new Schema({\n *       foo: { type: String, select: false },\n *       bar: String\n *     });\n *     // ...\n *     query.select('+foo'); // Override foo's `select: false` without excluding `bar`\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({ a: 1, b: 1 });\n *     query.select({ c: 0, d: 0 });\n *\n *     Additional calls to select can override the previous selection:\n *     query.select({ a: 1, b: 1 }).select({ b: 0 }); // selection is now { a: 1 }\n *     query.select({ a: 0, b: 0 }).select({ b: 1 }); // selection is now { a: 0 }\n *\n *\n * @method select\n * @memberOf Query\n * @instance\n * @param {Object|String|String[]} arg\n * @return {Query} this\n * @see SchemaType https://mongoosejs.com/docs/api/schematype.html\n * @api public\n */\n\nQuery.prototype.select = function select() {\n  let arg = arguments[0];\n  if (!arg) return this;\n\n  if (arguments.length !== 1) {\n    throw new Error('Invalid select: select only takes 1 argument');\n  }\n\n  this._validate('select');\n\n  const fields = this._fields || (this._fields = {});\n  const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});\n  let sanitizeProjection = undefined;\n  if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, 'sanitizeProjection')) {\n    sanitizeProjection = this.model.db.options.sanitizeProjection;\n  } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, 'sanitizeProjection')) {\n    sanitizeProjection = this.model.base.options.sanitizeProjection;\n  } else {\n    sanitizeProjection = this._mongooseOptions.sanitizeProjection;\n  }\n\n  function sanitizeValue(value) {\n    return typeof value === 'string' && sanitizeProjection ? value = 1 : value;\n  }\n  arg = parseProjection(arg, true); // we want to keep the minus and pluses, so add boolean arg.\n  if (utils.isObject(arg)) {\n    if (this.selectedInclusively()) {\n      Object.entries(arg).forEach(([key, value]) => {\n        if (value) {\n          // Add the field to the projection\n          if (fields['-' + key] != null) {\n            delete fields['-' + key];\n          }\n          fields[key] = userProvidedFields[key] = sanitizeValue(value);\n        } else {\n          // Remove the field from the projection\n          Object.keys(userProvidedFields).forEach(field => {\n            if (isSubpath(key, field)) {\n              delete fields[field];\n              delete userProvidedFields[field];\n            }\n          });\n        }\n      });\n    } else if (this.selectedExclusively()) {\n      Object.entries(arg).forEach(([key, value]) => {\n        if (!value) {\n          // Add the field to the projection\n          if (fields['+' + key] != null) {\n            delete fields['+' + key];\n          }\n          fields[key] = userProvidedFields[key] = sanitizeValue(value);\n        } else {\n          // Remove the field from the projection\n          Object.keys(userProvidedFields).forEach(field => {\n            if (isSubpath(key, field)) {\n              delete fields[field];\n              delete userProvidedFields[field];\n            }\n          });\n        }\n      });\n    } else {\n      const keys = Object.keys(arg);\n      for (let i = 0; i < keys.length; ++i) {\n        const value = arg[keys[i]];\n        const key = keys[i];\n        fields[key] = sanitizeValue(value);\n        userProvidedFields[key] = sanitizeValue(value);\n      }\n    }\n\n    return this;\n  }\n\n  throw new TypeError('Invalid select() argument. Must be string or object.');\n};\n\n/**\n * Determines the MongoDB nodes from which to read.\n *\n * #### Preferences:\n *\n * ```\n * primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n * secondary            Read from secondary if available, otherwise error.\n * primaryPreferred     Read from primary if available, otherwise a secondary.\n * secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n * nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n * ```\n *\n * Aliases\n *\n * ```\n * p   primary\n * pp  primaryPreferred\n * s   secondary\n * sp  secondaryPreferred\n * n   nearest\n * ```\n *\n * #### Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // read from secondaries with matching tags\n *     new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])\n *\n * Read more about how to use read preferences [here](https://www.mongodb.com/docs/manual/applications/replication/#read-preference).\n *\n * @method read\n * @memberOf Query\n * @instance\n * @param {String} mode one of the listed preference options or aliases\n * @param {Array} [tags] optional tags for this query\n * @see mongodb https://www.mongodb.com/docs/manual/applications/replication/#read-preference\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.read = function read(mode, tags) {\n  if (typeof mode === 'string') {\n    mode = handleReadPreferenceAliases(mode);\n    this.options.readPreference = { mode, tags };\n  } else {\n    this.options.readPreference = mode;\n  }\n  return this;\n};\n\n/**\n * Overwrite default `.toString` to make logging more useful\n *\n * @memberOf Query\n * @instance\n * @method toString\n * @api private\n */\n\nQuery.prototype.toString = function toString() {\n  if (this.op === 'count' ||\n      this.op === 'countDocuments' ||\n      this.op === 'find' ||\n      this.op === 'findOne' ||\n      this.op === 'deleteMany' ||\n      this.op === 'deleteOne' ||\n      this.op === 'findOneAndDelete' ||\n      this.op === 'findOneAndRemove' ||\n      this.op === 'remove') {\n    return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)})`;\n  }\n  if (this.op === 'distinct') {\n    return `${this.model.modelName}.distinct('${this._distinct}', ${util.inspect(this._conditions)})`;\n  }\n  if (this.op === 'findOneAndReplace' ||\n      this.op === 'findOneAndUpdate' ||\n      this.op === 'replaceOne' ||\n      this.op === 'update' ||\n      this.op === 'updateMany' ||\n      this.op === 'updateOne') {\n    return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)}, ${util.inspect(this._update)})`;\n  }\n\n  // 'estimatedDocumentCount' or any others\n  return `${this.model.modelName}.${this.op}()`;\n};\n\n/**\n * Sets the [MongoDB session](https://www.mongodb.com/docs/manual/reference/server-sessions/)\n * associated with this query. Sessions are how you mark a query as part of a\n * [transaction](https://mongoosejs.com/docs/transactions.html).\n *\n * Calling `session(null)` removes the session from this query.\n *\n * #### Example:\n *\n *     const s = await mongoose.startSession();\n *     await mongoose.model('Person').findOne({ name: 'Axl Rose' }).session(s);\n *\n * @method session\n * @memberOf Query\n * @instance\n * @param {ClientSession} [session] from `await conn.startSession()`\n * @see Connection.prototype.startSession() https://mongoosejs.com/docs/api/connection.html#Connection.prototype.startSession()\n * @see mongoose.startSession() https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.startSession()\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.session = function session(v) {\n  if (v == null) {\n    delete this.options.session;\n  }\n  this.options.session = v;\n  return this;\n};\n\n/**\n * Sets the 3 write concern parameters for this query:\n *\n * - `w`: Sets the specified number of `mongod` servers, or tag set of `mongod` servers, that must acknowledge this write before this write is considered successful.\n * - `j`: Boolean, set to `true` to request acknowledgement that this operation has been persisted to MongoDB's on-disk journal.\n * - `wtimeout`: If [`w > 1`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()), the maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     // The 'majority' option means the `deleteOne()` promise won't resolve\n *     // until the `deleteOne()` has propagated to the majority of the replica set\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       writeConcern({ w: 'majority' });\n *\n * @method writeConcern\n * @memberOf Query\n * @instance\n * @param {Object} writeConcern the write concern value to set\n * @see WriteConcernSettings https://mongodb.github.io/node-mongodb-native/4.9/interfaces/WriteConcernSettings.html\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.writeConcern = function writeConcern(val) {\n  if (val == null) {\n    delete this.options.writeConcern;\n    return this;\n  }\n  this.options.writeConcern = val;\n  return this;\n};\n\n/**\n * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n * that must acknowledge this write before this write is considered successful.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.w` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     // The 'majority' option means the `deleteOne()` promise won't resolve\n *     // until the `deleteOne()` has propagated to the majority of the replica set\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       w('majority');\n *\n * @method w\n * @memberOf Query\n * @instance\n * @param {String|number} val 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option).\n * @see mongodb https://www.mongodb.com/docs/manual/reference/write-concern/#w-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.w = function w(val) {\n  if (val == null) {\n    delete this.options.w;\n  }\n  if (this.options.writeConcern != null) {\n    this.options.writeConcern.w = val;\n  } else {\n    this.options.w = val;\n  }\n  return this;\n};\n\n/**\n * Requests acknowledgement that this operation has been persisted to MongoDB's\n * on-disk journal.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.j` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     await mongoose.model('Person').deleteOne({ name: 'Ned Stark' }).j(true);\n *\n * @method j\n * @memberOf Query\n * @instance\n * @param {boolean} val\n * @see mongodb https://www.mongodb.com/docs/manual/reference/write-concern/#j-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.j = function j(val) {\n  if (val == null) {\n    delete this.options.j;\n  }\n  if (this.options.writeConcern != null) {\n    this.options.writeConcern.j = val;\n  } else {\n    this.options.j = val;\n  }\n  return this;\n};\n\n/**\n * If [`w > 1`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()), the maximum amount of time to\n * wait for this write to propagate through the replica set before this\n * operation fails. The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.wtimeout` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     // The `deleteOne()` promise won't resolve until this `deleteOne()` has\n *     // propagated to at least `w = 2` members of the replica set. If it takes\n *     // longer than 1 second, this `deleteOne()` will fail.\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       w(2).\n *       wtimeout(1000);\n *\n * @method wtimeout\n * @memberOf Query\n * @instance\n * @param {number} ms number of milliseconds to wait\n * @see mongodb https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.wtimeout = function wtimeout(ms) {\n  if (ms == null) {\n    delete this.options.wtimeout;\n  }\n  if (this.options.writeConcern != null) {\n    this.options.writeConcern.wtimeout = ms;\n  } else {\n    this.options.wtimeout = ms;\n  }\n  return this;\n};\n\n/**\n * Sets the readConcern option for the query.\n *\n * #### Example:\n *\n *     new Query().readConcern('local')\n *     new Query().readConcern('l')  // same as local\n *\n *     new Query().readConcern('available')\n *     new Query().readConcern('a')  // same as available\n *\n *     new Query().readConcern('majority')\n *     new Query().readConcern('m')  // same as majority\n *\n *     new Query().readConcern('linearizable')\n *     new Query().readConcern('lz') // same as linearizable\n *\n *     new Query().readConcern('snapshot')\n *     new Query().readConcern('s')  // same as snapshot\n *\n *\n * #### Read Concern Level:\n *\n * ```\n * local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n * available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n * majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\n * linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\n * snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n * ```\n *\n * Aliases\n *\n * ```\n * l   local\n * a   available\n * m   majority\n * lz  linearizable\n * s   snapshot\n * ```\n *\n * Read more about how to use read concern [here](https://www.mongodb.com/docs/manual/reference/read-concern/).\n *\n * @memberOf Query\n * @method readConcern\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://www.mongodb.com/docs/manual/reference/read-concern/\n * @return {Query} this\n * @api public\n */\n\n/**\n * Gets query options.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.limit(10);\n *     query.setOptions({ maxTimeMS: 1000 });\n *     query.getOptions(); // { limit: 10, maxTimeMS: 1000 }\n *\n * @return {Object} the options\n * @api public\n */\n\nQuery.prototype.getOptions = function() {\n  return this.options;\n};\n\n/**\n * Sets query options. Some options only make sense for certain operations.\n *\n * #### Options:\n *\n * The following options are only for `find()`:\n *\n * - [tailable](https://www.mongodb.com/docs/manual/core/tailable-cursors/)\n * - [limit](https://www.mongodb.com/docs/manual/reference/method/cursor.limit/)\n * - [skip](https://www.mongodb.com/docs/manual/reference/method/cursor.skip/)\n * - [allowDiskUse](https://www.mongodb.com/docs/manual/reference/method/cursor.allowDiskUse/)\n * - [batchSize](https://www.mongodb.com/docs/manual/reference/method/cursor.batchSize/)\n * - [readPreference](https://www.mongodb.com/docs/manual/applications/replication/#read-preference)\n * - [hint](https://www.mongodb.com/docs/manual/reference/method/cursor.hint/)\n * - [comment](https://www.mongodb.com/docs/manual/reference/method/cursor.comment/)\n *\n * The following options are only for write operations: `updateOne()`, `updateMany()`, `replaceOne()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`:\n *\n * - [upsert](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n * - [writeConcern](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): If `timestamps` is set in the schema, set this option to `false` to skip timestamps for that particular update. Has no effect if `timestamps` is not enabled in the schema options.\n * - overwriteDiscriminatorKey: allow setting the discriminator key in the update. Will use the correct discriminator schema if the update changes the discriminator key.\n *\n * The following options are only for `find()`, `findOne()`, `findById()`, `findOneAndUpdate()`, `findOneAndReplace()`, `findOneAndDelete()`, and `findByIdAndUpdate()`:\n *\n * - [lean](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean())\n * - [populate](https://mongoosejs.com/docs/populate.html)\n * - [projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.projection())\n * - sanitizeProjection\n * - useBigInt64\n *\n * The following options are only for all operations **except** `updateOne()`, `updateMany()`, `deleteOne()`, and `deleteMany()`:\n *\n * - [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/)\n *\n * The following options are for `find()`, `findOne()`, `findOneAndUpdate()`, `findOneAndRemove()`, `findOneAndDelete()`, `updateOne()`, and `deleteOne()`:\n *\n * - [sort](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/)\n *\n * The following options are for `findOneAndUpdate()` and `findOneAndRemove()`\n *\n * - rawResult\n *\n * The following options are for all operations:\n *\n * - [strict](https://mongoosejs.com/docs/guide.html#strict)\n * - [collation](https://www.mongodb.com/docs/manual/reference/collation/)\n * - [session](https://www.mongodb.com/docs/manual/reference/server-sessions/)\n * - [explain](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/)\n *\n * @param {Object} options\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.setOptions = function(options, overwrite) {\n  // overwrite is only for internal use\n  if (overwrite) {\n    // ensure that _mongooseOptions & options are two different objects\n    this._mongooseOptions = (options && clone(options)) || {};\n    this.options = options || {};\n\n    if ('populate' in options) {\n      this.populate(this._mongooseOptions);\n    }\n    return this;\n  }\n  if (options == null) {\n    return this;\n  }\n  if (typeof options !== 'object') {\n    throw new Error('Options must be an object, got \"' + options + '\"');\n  }\n\n  options = Object.assign({}, options);\n\n  if (Array.isArray(options.populate)) {\n    const populate = options.populate;\n    delete options.populate;\n    const _numPopulate = populate.length;\n    for (let i = 0; i < _numPopulate; ++i) {\n      this.populate(populate[i]);\n    }\n  }\n\n  if ('setDefaultsOnInsert' in options) {\n    this._mongooseOptions.setDefaultsOnInsert = options.setDefaultsOnInsert;\n    delete options.setDefaultsOnInsert;\n  }\n  if ('overwriteDiscriminatorKey' in options) {\n    this._mongooseOptions.overwriteDiscriminatorKey = options.overwriteDiscriminatorKey;\n    delete options.overwriteDiscriminatorKey;\n  }\n  if ('sanitizeProjection' in options) {\n    if (options.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {\n      sanitizeProjection(this._fields);\n    }\n\n    this._mongooseOptions.sanitizeProjection = options.sanitizeProjection;\n    delete options.sanitizeProjection;\n  }\n  if ('sanitizeFilter' in options) {\n    this._mongooseOptions.sanitizeFilter = options.sanitizeFilter;\n    delete options.sanitizeFilter;\n  }\n  if ('overwrite' in options) {\n    this._mongooseOptions.overwrite = options.overwrite;\n    delete options.overwrite;\n  }\n  if ('timestamps' in options) {\n    this._mongooseOptions.timestamps = options.timestamps;\n    delete options.timestamps;\n  }\n  if ('defaults' in options) {\n    this._mongooseOptions.defaults = options.defaults;\n    // deleting options.defaults will cause 7287 to fail\n  }\n  if ('translateAliases' in options) {\n    this._mongooseOptions.translateAliases = options.translateAliases;\n    delete options.translateAliases;\n  }\n\n  if ('rawResult' in options) {\n    printRawResultDeprecationWarning();\n  }\n\n  if (options.lean == null && this.schema && 'lean' in this.schema.options) {\n    this._mongooseOptions.lean = this.schema.options.lean;\n  }\n\n  if (typeof options.limit === 'string') {\n    try {\n      options.limit = castNumber(options.limit);\n    } catch (err) {\n      throw new CastError('Number', options.limit, 'limit');\n    }\n  }\n  if (typeof options.skip === 'string') {\n    try {\n      options.skip = castNumber(options.skip);\n    } catch (err) {\n      throw new CastError('Number', options.skip, 'skip');\n    }\n  }\n\n  // set arbitrary options\n  for (const key of Object.keys(options)) {\n    if (queryOptionMethods.has(key)) {\n      const args = Array.isArray(options[key]) ?\n        options[key] :\n        [options[key]];\n      this[key].apply(this, args);\n    } else {\n      this.options[key] = options[key];\n    }\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nconst printRawResultDeprecationWarning = util.deprecate(\n  function printRawResultDeprecationWarning() {},\n  'The `rawResult` option for Mongoose queries is deprecated. Use `includeResultMetadata: true` as a replacement for `rawResult: true`.'\n);\n\n/*!\n * ignore\n */\n\nconst printOverwriteDeprecationWarning = util.deprecate(\n  function printOverwriteDeprecationWarning() {},\n  'The `overwrite` option for `findOneAndUpdate()` is deprecated. use `findOneAndReplace()` instead.'\n);\n\n/**\n * Sets the [`explain` option](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/),\n * which makes this query return detailed execution stats instead of the actual\n * query result. This method is useful for determining what index your queries\n * use.\n *\n * Calling `query.explain(v)` is equivalent to `query.setOptions({ explain: v })`\n *\n * #### Example:\n *\n *     const query = new Query();\n *     const res = await query.find({ a: 1 }).explain('queryPlanner');\n *     console.log(res);\n *\n * @param {String} [verbose] The verbosity mode. Either 'queryPlanner', 'executionStats', or 'allPlansExecution'. The default is 'queryPlanner'\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.explain = function explain(verbose) {\n  if (arguments.length === 0) {\n    this.options.explain = true;\n  } else if (verbose === false) {\n    delete this.options.explain;\n  } else {\n    this.options.explain = verbose;\n  }\n  return this;\n};\n\n/**\n * Sets the [`allowDiskUse` option](https://www.mongodb.com/docs/manual/reference/method/cursor.allowDiskUse/),\n * which allows the MongoDB server to use more than 100 MB for this query's `sort()`. This option can\n * let you work around `QueryExceededMemoryLimitNoDiskUseAllowed` errors from the MongoDB server.\n *\n * Note that this option requires MongoDB server >= 4.4. Setting this option is a no-op for MongoDB 4.2\n * and earlier.\n *\n * Calling `query.allowDiskUse(v)` is equivalent to `query.setOptions({ allowDiskUse: v })`\n *\n * #### Example:\n *\n *     await query.find().sort({ name: 1 }).allowDiskUse(true);\n *     // Equivalent:\n *     await query.find().sort({ name: 1 }).allowDiskUse();\n *\n * @param {Boolean} [v] Enable/disable `allowDiskUse`. If called with 0 arguments, sets `allowDiskUse: true`\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.allowDiskUse = function(v) {\n  if (arguments.length === 0) {\n    this.options.allowDiskUse = true;\n  } else if (v === false) {\n    delete this.options.allowDiskUse;\n  } else {\n    this.options.allowDiskUse = v;\n  }\n  return this;\n};\n\n/**\n * Sets the [maxTimeMS](https://www.mongodb.com/docs/manual/reference/method/cursor.maxTimeMS/)\n * option. This will tell the MongoDB server to abort if the query or write op\n * has been running for more than `ms` milliseconds.\n *\n * Calling `query.maxTimeMS(v)` is equivalent to `query.setOptions({ maxTimeMS: v })`\n *\n * #### Example:\n *\n *     const query = new Query();\n *     // Throws an error 'operation exceeded time limit' as long as there's\n *     // >= 1 doc in the queried collection\n *     const res = await query.find({ $where: 'sleep(1000) || true' }).maxTimeMS(100);\n *\n * @param {Number} [ms] The number of milliseconds\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.maxTimeMS = function(ms) {\n  this.options.maxTimeMS = ms;\n  return this;\n};\n\n/**\n * Returns the current query filter (also known as conditions) as a [POJO](https://masteringjs.io/tutorials/fundamentals/pojo).\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.find({ a: 1 }).where('b').gt(2);\n *     query.getFilter(); // { a: 1, b: { $gt: 2 } }\n *\n * @return {Object} current query filter\n * @api public\n */\n\nQuery.prototype.getFilter = function() {\n  return this._conditions;\n};\n\n/**\n * Returns the current query filter. Equivalent to `getFilter()`.\n *\n * You should use `getFilter()` instead of `getQuery()` where possible. `getQuery()`\n * will likely be deprecated in a future release.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.find({ a: 1 }).where('b').gt(2);\n *     query.getQuery(); // { a: 1, b: { $gt: 2 } }\n *\n * @return {Object} current query filter\n * @api public\n */\n\nQuery.prototype.getQuery = function() {\n  return this._conditions;\n};\n\n/**\n * Sets the query conditions to the provided JSON object.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.find({ a: 1 })\n *     query.setQuery({ a: 2 });\n *     query.getQuery(); // { a: 2 }\n *\n * @param {Object} new query conditions\n * @return {undefined}\n * @api public\n */\n\nQuery.prototype.setQuery = function(val) {\n  this._conditions = val;\n};\n\n/**\n * Returns the current update operations as a JSON object.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.updateOne({}, { $set: { a: 5 } });\n *     query.getUpdate(); // { $set: { a: 5 } }\n *\n * @return {Object} current update operations\n * @api public\n */\n\nQuery.prototype.getUpdate = function() {\n  return this._update;\n};\n\n/**\n * Sets the current update operation to new value.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.updateOne({}, { $set: { a: 5 } });\n *     query.setUpdate({ $set: { b: 6 } });\n *     query.getUpdate(); // { $set: { b: 6 } }\n *\n * @param {Object} new update operation\n * @return {undefined}\n * @api public\n */\n\nQuery.prototype.setUpdate = function(val) {\n  this._update = val;\n};\n\n/**\n * Returns fields selection for this query.\n *\n * @method _fieldsForExec\n * @return {Object}\n * @api private\n * @memberOf Query\n */\n\nQuery.prototype._fieldsForExec = function() {\n  if (this._fields == null) {\n    return null;\n  }\n  if (Object.keys(this._fields).length === 0) {\n    return null;\n  }\n  return clone(this._fields);\n};\n\n\n/**\n * Return an update document with corrected `$set` operations.\n *\n * @method _updateForExec\n * @return {Object}\n * @api private\n * @memberOf Query\n */\n\nQuery.prototype._updateForExec = function() {\n  const update = clone(this._update, {\n    transform: false,\n    depopulate: true\n  });\n  const ops = Object.keys(update);\n  let i = ops.length;\n  const ret = {};\n\n  while (i--) {\n    const op = ops[i];\n\n    if (this._mongooseOptions.overwrite) {\n      ret[op] = update[op];\n      continue;\n    }\n\n    if ('$' !== op[0]) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (update.$set) {\n          ret.$set = update.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = update[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if ('$set' === op) {\n      if (!ret.$set) {\n        ret[op] = update[op];\n      }\n    } else {\n      ret[op] = update[op];\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Makes sure _path is set.\n *\n * This method is inherited by `mquery`\n *\n * @method _ensurePath\n * @param {String} method\n * @api private\n * @memberOf Query\n */\n\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @method canMerge\n * @memberOf Query\n * @instance\n * @param {Object} conds\n * @return {Boolean}\n * @api private\n */\n\n/**\n * Returns default options for this query.\n *\n * @param {Model} model\n * @api private\n */\n\nQuery.prototype._optionsForExec = function(model) {\n  const options = clone(this.options);\n  delete options.populate;\n  model = model || this.model;\n\n  if (!model) {\n    return options;\n  }\n  // Apply schema-level `writeConcern` option\n  applyWriteConcern(model.schema, options);\n\n  const asyncLocalStorage = this.model?.db?.base.transactionAsyncLocalStorage?.getStore();\n  if (!this.options.hasOwnProperty('session') && asyncLocalStorage?.session != null) {\n    options.session = asyncLocalStorage.session;\n  }\n\n  const readPreference = model &&\n  model.schema &&\n  model.schema.options &&\n  model.schema.options.read;\n  if (!('readPreference' in options) && readPreference) {\n    options.readPreference = readPreference;\n  }\n\n  if (options.upsert !== void 0) {\n    options.upsert = !!options.upsert;\n  }\n  if (options.writeConcern) {\n    if (options.j) {\n      options.writeConcern.j = options.j;\n      delete options.j;\n    }\n    if (options.w) {\n      options.writeConcern.w = options.w;\n      delete options.w;\n    }\n    if (options.wtimeout) {\n      options.writeConcern.wtimeout = options.wtimeout;\n      delete options.wtimeout;\n    }\n  }\n\n  this._applyPaths();\n  if (this._fields != null) {\n    this._fields = this._castFields(this._fields);\n    const projection = this._fieldsForExec();\n    if (projection != null) {\n      options.projection = projection;\n    }\n  }\n\n  return options;\n};\n\n/**\n * Sets the lean option.\n *\n * Documents returned from queries with the `lean` option enabled are plain\n * javascript objects, not [Mongoose Documents](https://mongoosejs.com/docs/api/document.html). They have no\n * `save` method, getters/setters, virtuals, or other Mongoose features.\n *\n * #### Example:\n *\n *     new Query().lean() // true\n *     new Query().lean(true)\n *     new Query().lean(false)\n *\n *     const docs = await Model.find().lean();\n *     docs[0] instanceof mongoose.Document; // false\n *\n * [Lean is great for high-performance, read-only cases](https://mongoosejs.com/docs/tutorials/lean.html),\n * especially when combined\n * with [cursors](https://mongoosejs.com/docs/queries.html#streaming).\n *\n * If you need virtuals, getters/setters, or defaults with `lean()`, you need\n * to use a plugin. See:\n *\n * - [mongoose-lean-virtuals](https://plugins.mongoosejs.io/plugins/lean-virtuals)\n * - [mongoose-lean-getters](https://plugins.mongoosejs.io/plugins/lean-getters)\n * - [mongoose-lean-defaults](https://www.npmjs.com/package/mongoose-lean-defaults)\n *\n * @param {Boolean|Object} bool defaults to true\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.lean = function(v) {\n  this._mongooseOptions.lean = arguments.length ? v : true;\n  return this;\n};\n\n/**\n * Adds a `$set` to this query's update without changing the operation.\n * This is useful for query middleware so you can add an update regardless\n * of whether you use `updateOne()`, `updateMany()`, `findOneAndUpdate()`, etc.\n *\n * #### Example:\n *\n *     // Updates `{ $set: { updatedAt: new Date() } }`\n *     new Query().updateOne({}, {}).set('updatedAt', new Date());\n *     new Query().updateMany({}, {}).set({ updatedAt: new Date() });\n *\n * @param {String|Object} path path or object of key/value pairs to set\n * @param {Any} [val] the value to set\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.set = function(path, val) {\n  if (typeof path === 'object') {\n    const keys = Object.keys(path);\n    for (const key of keys) {\n      this.set(key, path[key]);\n    }\n    return this;\n  }\n\n  this._update = this._update || {};\n  if (path in this._update) {\n    delete this._update[path];\n  }\n  this._update.$set = this._update.$set || {};\n  this._update.$set[path] = val;\n  return this;\n};\n\n/**\n * For update operations, returns the value of a path in the update's `$set`.\n * Useful for writing getters/setters that can work with both update operations\n * and `save()`.\n *\n * #### Example:\n *\n *     const query = Model.updateOne({}, { $set: { name: 'Jean-Luc Picard' } });\n *     query.get('name'); // 'Jean-Luc Picard'\n *\n * @param {String|Object} path path or object of key/value pairs to get\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.get = function get(path) {\n  const update = this._update;\n  if (update == null) {\n    return void 0;\n  }\n  const $set = update.$set;\n  if ($set == null) {\n    return update[path];\n  }\n\n  if (utils.hasUserDefinedProperty(update, path)) {\n    return update[path];\n  }\n  if (utils.hasUserDefinedProperty($set, path)) {\n    return $set[path];\n  }\n\n  return void 0;\n};\n\n/**\n * Gets/sets the error flag on this query. If this flag is not null or\n * undefined, the `exec()` promise will reject without executing.\n *\n * #### Example:\n *\n *     Query().error(); // Get current error value\n *     Query().error(null); // Unset the current error\n *     Query().error(new Error('test')); // `exec()` will resolve with test\n *     Schema.pre('find', function() {\n *       if (!this.getQuery().userId) {\n *         this.error(new Error('Not allowed to query without setting userId'));\n *       }\n *     });\n *\n * Note that query casting runs **after** hooks, so cast errors will override\n * custom errors.\n *\n * #### Example:\n *\n *     const TestSchema = new Schema({ num: Number });\n *     const TestModel = db.model('Test', TestSchema);\n *     TestModel.find({ num: 'not a number' }).error(new Error('woops')).exec(function(error) {\n *       // `error` will be a cast error because `num` failed to cast\n *     });\n *\n * @param {Error|null} err if set, `exec()` will fail fast before sending the query to MongoDB\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.error = function error(err) {\n  if (arguments.length === 0) {\n    return this._error;\n  }\n\n  this._error = err;\n  return this;\n};\n\n/**\n * ignore\n * @method _unsetCastError\n * @instance\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._unsetCastError = function _unsetCastError() {\n  if (this._error != null && !(this._error instanceof CastError)) {\n    return;\n  }\n  return this.error(null);\n};\n\n/**\n * Getter/setter around the current mongoose-specific options for this query\n * Below are the current Mongoose-specific options.\n *\n * - `populate`: an array representing what paths will be populated. Should have one entry for each call to [`Query.prototype.populate()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.populate())\n * - `lean`: if truthy, Mongoose will not [hydrate](https://mongoosejs.com/docs/api/model.html#Model.hydrate()) any documents that are returned from this query. See [`Query.prototype.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) for more information.\n * - `strict`: controls how Mongoose handles keys that aren't in the schema for updates. This option is `true` by default, which means Mongoose will silently strip any paths in the update that aren't in the schema. See the [`strict` mode docs](https://mongoosejs.com/docs/guide.html#strict) for more information.\n * - `strictQuery`: controls how Mongoose handles keys that aren't in the schema for the query `filter`. This option is `false` by default, which means Mongoose will allow `Model.find({ foo: 'bar' })` even if `foo` is not in the schema. See the [`strictQuery` docs](https://mongoosejs.com/docs/guide.html#strictQuery) for more information.\n * - `nearSphere`: use `$nearSphere` instead of `near()`. See the [`Query.prototype.nearSphere()` docs](https://mongoosejs.com/docs/api/query.html#Query.prototype.nearSphere())\n *\n * Mongoose maintains a separate object for internal options because\n * Mongoose sends `Query.prototype.options` to the MongoDB server, and the\n * above options are not relevant for the MongoDB server.\n *\n * @param {Object} options if specified, overwrites the current options\n * @return {Object} the options\n * @api public\n */\n\nQuery.prototype.mongooseOptions = function(v) {\n  if (arguments.length > 0) {\n    this._mongooseOptions = v;\n  }\n  return this._mongooseOptions;\n};\n\n/**\n * ignore\n * @method _castConditions\n * @memberOf Query\n * @api private\n * @instance\n */\n\nQuery.prototype._castConditions = function() {\n  let sanitizeFilterOpt = undefined;\n  if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, 'sanitizeFilter')) {\n    sanitizeFilterOpt = this.model.db.options.sanitizeFilter;\n  } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, 'sanitizeFilter')) {\n    sanitizeFilterOpt = this.model.base.options.sanitizeFilter;\n  } else {\n    sanitizeFilterOpt = this._mongooseOptions.sanitizeFilter;\n  }\n\n  if (sanitizeFilterOpt) {\n    sanitizeFilter(this._conditions);\n  }\n\n  try {\n    this.cast(this.model);\n    this._unsetCastError();\n  } catch (err) {\n    this.error(err);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _castArrayFilters(query) {\n  try {\n    castArrayFilters(query);\n  } catch (err) {\n    query.error(err);\n  }\n}\n\n/**\n * Execute a `find()`\n *\n * @return {Query} this\n * @api private\n */\nQuery.prototype._find = async function _find() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const mongooseOptions = this._mongooseOptions;\n  const _this = this;\n  const userProvidedFields = _this._userProvidedFields || {};\n\n  applyGlobalMaxTimeMS(this.options, this.model);\n  applyGlobalDiskUse(this.options, this.model);\n\n  // Separate options to pass down to `completeMany()` in case we need to\n  // set a session on the document\n  const completeManyOptions = Object.assign({}, {\n    session: this && this.options && this.options.session || null,\n    lean: mongooseOptions.lean || null\n  });\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  const filter = this._conditions;\n  const fields = options.projection;\n\n  const cursor = await this._collection.collection.find(filter, options);\n  if (options.explain) {\n    return cursor.explain();\n  }\n\n  let docs = await cursor.toArray();\n  if (docs.length === 0) {\n    return docs;\n  }\n\n  if (!mongooseOptions.populate) {\n    const versionKey = _this.schema.options.versionKey;\n    if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {\n      docs.forEach((doc) => {\n        if (versionKey in doc) {\n          delete doc[versionKey];\n        }\n      });\n    }\n    return mongooseOptions.lean ?\n      _completeManyLean(_this.model.schema, docs, null, completeManyOptions) :\n      completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions);\n  }\n  const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);\n\n  if (mongooseOptions.lean) {\n    return _this.model.populate(docs, pop);\n  }\n\n  docs = await completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions);\n  await this.model.populate(docs, pop);\n\n  return docs;\n};\n\n/**\n * Find all documents that match `selector`. The result will be an array of documents.\n *\n * If there are too many documents in the result to fit in memory, use\n * [`Query.prototype.cursor()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.cursor())\n *\n * #### Example:\n *\n *     const arr = await Movie.find({ year: { $gte: 1980, $lte: 1989 } });\n *\n * @param {Object|ObjectId} [filter] mongodb filter. If not specified, returns all documents.\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.find = function(conditions) {\n  if (typeof conditions === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Query.prototype.find() no longer accepts a callback');\n  }\n\n  this.op = 'find';\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'find'));\n  }\n\n  Query.base.find.call(this);\n\n  return this;\n};\n\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */\n\nQuery.prototype.merge = function(source) {\n  if (!source) {\n    return this;\n  }\n\n  const opts = { overwrite: true };\n\n  if (source instanceof Query) {\n    // if source has a feature, apply it to ourselves\n\n    if (source._conditions) {\n      opts.omit = {};\n      if (this._conditions && this._conditions.$and && source._conditions.$and) {\n        opts.omit['$and'] = true;\n        this._conditions.$and = this._conditions.$and.concat(source._conditions.$and);\n      }\n      if (this._conditions && this._conditions.$or && source._conditions.$or) {\n        opts.omit['$or'] = true;\n        this._conditions.$or = this._conditions.$or.concat(source._conditions.$or);\n      }\n      utils.merge(this._conditions, source._conditions, opts);\n    }\n\n    if (source._fields) {\n      this._fields || (this._fields = {});\n      utils.merge(this._fields, source._fields, opts);\n    }\n\n    if (source.options) {\n      this.options || (this.options = {});\n      utils.merge(this.options, source.options, opts);\n    }\n\n    if (source._update) {\n      this._update || (this._update = {});\n      utils.mergeClone(this._update, source._update);\n    }\n\n    if (source._distinct) {\n      this._distinct = source._distinct;\n    }\n\n    utils.merge(this._mongooseOptions, source._mongooseOptions);\n\n    return this;\n  } else if (this.model != null && source instanceof this.model.base.Types.ObjectId) {\n    utils.merge(this._conditions, { _id: source }, opts);\n\n    return this;\n  } else if (source && source.$__) {\n    source = source.toObject(internalToObjectOptions);\n  }\n\n  opts.omit = {};\n  if (Array.isArray(source.$and)) {\n    opts.omit['$and'] = true;\n    if (!this._conditions) {\n      this._conditions = {};\n    }\n    this._conditions.$and = (this._conditions.$and || []).concat(\n      source.$and.map(el => utils.isPOJO(el) ? utils.merge({}, el) : el)\n    );\n  }\n  if (Array.isArray(source.$or)) {\n    opts.omit['$or'] = true;\n    if (!this._conditions) {\n      this._conditions = {};\n    }\n    this._conditions.$or = (this._conditions.$or || []).concat(\n      source.$or.map(el => utils.isPOJO(el) ? utils.merge({}, el) : el)\n    );\n  }\n\n  // plain object\n  utils.merge(this._conditions, source, opts);\n\n  return this;\n};\n\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */\n\nQuery.prototype.collation = function(value) {\n  if (this.options == null) {\n    this.options = {};\n  }\n  this.options.collation = value;\n  return this;\n};\n\n/**\n * Hydrate a single doc from `findOne()`, `findOneAndUpdate()`, etc.\n *\n * @api private\n */\n\nQuery.prototype._completeOne = function(doc, res, callback) {\n  if (!doc && !this.options.rawResult && !this.options.includeResultMetadata) {\n    return callback(null, null);\n  }\n\n  const model = this.model;\n  const projection = clone(this._fields);\n  const userProvidedFields = this._userProvidedFields || {};\n  // `populate`, `lean`\n  const mongooseOptions = this._mongooseOptions;\n  // `rawResult`\n  const options = this.options;\n  if (!options.lean && mongooseOptions.lean) {\n    options.lean = mongooseOptions.lean;\n  }\n\n  if (options.explain) {\n    return callback(null, doc);\n  }\n\n  if (!mongooseOptions.populate) {\n    const versionKey = this.schema.options.versionKey;\n    if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {\n      if (versionKey in doc) {\n        delete doc[versionKey];\n      }\n    }\n    return mongooseOptions.lean ?\n      _completeOneLean(model.schema, doc, null, res, options, callback) :\n      completeOne(model, doc, res, options, projection, userProvidedFields,\n        null, callback);\n  }\n\n  const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);\n  if (mongooseOptions.lean) {\n    return model.populate(doc, pop).then(\n      doc => {\n        _completeOneLean(model.schema, doc, null, res, options, callback);\n      },\n      error => {\n        callback(error);\n      }\n    );\n  }\n\n  completeOne(model, doc, res, options, projection, userProvidedFields, [], (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n    model.populate(doc, pop).then(res => { callback(null, res); }, err => { callback(err); });\n  });\n};\n\n/**\n * Internal helper to execute a findOne() operation\n *\n * @see findOne https://www.mongodb.com/docs/manual/reference/method/db.collection.findOne/\n * @api private\n */\n\nQuery.prototype._findOne = async function _findOne() {\n  this._castConditions();\n\n  if (this.error()) {\n    const err = this.error();\n    throw err;\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model);\n  applyGlobalDiskUse(this.options, this.model);\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  // don't pass in the conditions because we already merged them in\n  const doc = await this._collection.collection.findOne(this._conditions, options);\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, null, _wrapThunkCallback(this, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    }));\n  });\n};\n\n/**\n * Declares the query a findOne operation. When executed, the first found document is passed to the callback.\n *\n * The result of the query is a single document, or `null` if no document was found.\n *\n * * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `Model.findById()`\n * instead.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * #### Example:\n *\n *     const query = Kitten.where({ color: 'white' });\n *     const kitten = await query.findOne();\n *\n * @param {Object} [filter] mongodb selector\n * @param {Object} [projection] optional fields to return\n * @param {Object} [options] see [`setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query} this\n * @see findOne https://www.mongodb.com/docs/manual/reference/method/db.collection.findOne/\n * @see Query.select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @api public\n */\n\nQuery.prototype.findOne = function(conditions, projection, options) {\n  if (typeof conditions === 'function' ||\n      typeof projection === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[3] === 'function') {\n    throw new MongooseError('Query.prototype.findOne() no longer accepts a callback');\n  }\n\n  this.op = 'findOne';\n  this._validateOp();\n\n  if (options) {\n    this.setOptions(options);\n  }\n\n  if (projection) {\n    this.select(projection);\n  }\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'findOne'));\n  }\n\n  Query.base.findOne.call(this);\n\n  return this;\n};\n\n/**\n * Execute a count query\n *\n * @see count https://www.mongodb.com/docs/manual/reference/method/db.collection.count/\n * @api private\n */\n\nQuery.prototype._count = async function _count() {\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    this.error(err);\n  }\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model);\n  applyGlobalDiskUse(this.options, this.model);\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  const conds = this._conditions;\n\n  return this._collection.collection.count(conds, options);\n};\n\n/**\n * Execute a countDocuments query\n *\n * @see countDocuments https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments\n * @api private\n */\n\nQuery.prototype._countDocuments = async function _countDocuments() {\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    this.error(err);\n  }\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model);\n  applyGlobalDiskUse(this.options, this.model);\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  const conds = this._conditions;\n\n  return this._collection.collection.countDocuments(conds, options);\n};\n\n/*!\n * If `translateAliases` option is set, call `Model.translateAliases()`\n * on the following query properties: filter, projection, update, distinct.\n */\n\nQuery.prototype._applyTranslateAliases = function _applyTranslateAliases(options) {\n  let applyTranslateAliases = false;\n  if ('translateAliases' in this._mongooseOptions) {\n    applyTranslateAliases = this._mongooseOptions.translateAliases;\n  } else if (this.model?.schema?._userProvidedOptions?.translateAliases != null) {\n    applyTranslateAliases = this.model.schema._userProvidedOptions.translateAliases;\n  } else if (this.model?.base?.options?.translateAliases != null) {\n    applyTranslateAliases = this.model.base.options.translateAliases;\n  }\n  if (!applyTranslateAliases) {\n    return;\n  }\n\n  if (this.model?.schema?.aliases && Object.keys(this.model.schema.aliases).length > 0) {\n    this.model.translateAliases(this._conditions, true);\n    this.model.translateAliases(options.projection, true);\n    this.model.translateAliases(this._update, true);\n    if (this._distinct != null && this.model.schema.aliases[this._distinct] != null) {\n      this._distinct = this.model.schema.aliases[this._distinct];\n    }\n  }\n};\n\n/**\n * Execute a estimatedDocumentCount() query\n *\n * @see estimatedDocumentCount https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#estimatedDocumentCount\n * @api private\n */\n\nQuery.prototype._estimatedDocumentCount = async function _estimatedDocumentCount() {\n  if (this.error()) {\n    throw this.error();\n  }\n\n  const options = this._optionsForExec();\n\n  return this._collection.collection.estimatedDocumentCount(options);\n};\n\n/**\n * Specifies this query as a `count` query.\n *\n * This method is deprecated. If you want to count the number of documents in\n * a collection, e.g. `count({})`, use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/query.html#Query.prototype.estimatedDocumentCount())\n * instead. Otherwise, use the [`countDocuments()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.countDocuments()) function instead.\n *\n * This function triggers the following middleware.\n *\n * - `count()`\n *\n * #### Example:\n *\n *     const countQuery = model.where({ 'color': 'black' }).count();\n *\n *     query.count({ color: 'black' }).count().exec();\n *\n *     await query.count({ color: 'black' });\n *\n *     query.where('color', 'black').count();\n *\n * @deprecated\n * @param {Object} [filter] count documents that match this object\n * @return {Query} this\n * @see count https://www.mongodb.com/docs/manual/reference/method/db.collection.count/\n * @api public\n */\n\nQuery.prototype.count = function(filter) {\n  if (typeof filter === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Query.prototype.count() no longer accepts a callback');\n  }\n\n  this.op = 'count';\n  this._validateOp();\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  }\n\n  return this;\n};\n\n/**\n * Specifies this query as a `estimatedDocumentCount()` query. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * `estimatedDocumentCount()` does **not** accept a filter. `Model.find({ foo: bar }).estimatedDocumentCount()`\n * is equivalent to `Model.find().estimatedDocumentCount()`\n *\n * This function triggers the following middleware.\n *\n * - `estimatedDocumentCount()`\n *\n * #### Example:\n *\n *     await Model.find().estimatedDocumentCount();\n *\n * @param {Object} [options] passed transparently to the [MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/EstimatedDocumentCountOptions.html)\n * @return {Query} this\n * @see estimatedDocumentCount https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#estimatedDocumentCount\n * @api public\n */\n\nQuery.prototype.estimatedDocumentCount = function(options) {\n  if (typeof options === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Query.prototype.estimatedDocumentCount() no longer accepts a callback');\n  }\n\n  this.op = 'estimatedDocumentCount';\n  this._validateOp();\n\n  if (typeof options === 'object' && options != null) {\n    this.setOptions(options);\n  }\n\n  return this;\n};\n\n/**\n * Specifies this query as a `countDocuments()` query. Behaves like `count()`,\n * except it always does a full collection scan when passed an empty filter `{}`.\n *\n * There are also minor differences in how `countDocuments()` handles\n * [`$where` and a couple geospatial operators](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * versus `count()`.\n *\n * This function triggers the following middleware.\n *\n * - `countDocuments()`\n *\n * #### Example:\n *\n *     const countQuery = model.where({ 'color': 'black' }).countDocuments();\n *\n *     query.countDocuments({ color: 'black' }).count().exec();\n *\n *     await query.countDocuments({ color: 'black' });\n *\n *     query.where('color', 'black').countDocuments().exec();\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} [filter] mongodb selector\n * @param {Object} [options]\n * @return {Query} this\n * @see countDocuments https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments\n * @api public\n */\n\nQuery.prototype.countDocuments = function(conditions, options) {\n  if (typeof conditions === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.countDocuments() no longer accepts a callback');\n  }\n\n  this.op = 'countDocuments';\n  this._validateOp();\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  if (typeof options === 'object' && options != null) {\n    this.setOptions(options);\n  }\n\n  return this;\n};\n\n/**\n * Execute a `distinct()` query\n *\n * @see distinct https://www.mongodb.com/docs/manual/reference/method/db.collection.distinct/\n * @api private\n */\n\nQuery.prototype.__distinct = async function __distinct() {\n  this._castConditions();\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model);\n  applyGlobalDiskUse(this.options, this.model);\n\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n\n  return this._collection.collection.\n    distinct(this._distinct, this._conditions, options);\n};\n\n/**\n * Declares or executes a distinct() operation.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     distinct(field, conditions)\n *     distinct(field)\n *     distinct()\n *\n * @param {String} [field]\n * @param {Object|Query} [filter]\n * @return {Query} this\n * @see distinct https://www.mongodb.com/docs/manual/reference/method/db.collection.distinct/\n * @api public\n */\n\nQuery.prototype.distinct = function(field, conditions) {\n  if (typeof field === 'function' ||\n      typeof conditions === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.distinct() no longer accepts a callback');\n  }\n\n  this.op = 'distinct';\n  this._validateOp();\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'distinct'));\n  }\n\n  if (field != null) {\n    this._distinct = field;\n  }\n\n  return this;\n};\n\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The\n * sort order of each path is ascending unless the path name is prefixed with `-`\n * which will be treated as descending.\n *\n * #### Example:\n *\n *     // sort by \"field\" ascending and \"test\" descending\n *     query.sort({ field: 'asc', test: -1 });\n *\n *     // equivalent\n *     query.sort('field -test');\n *\n *     // also possible is to use a array with array key-value pairs\n *     query.sort([['field', 'asc']]);\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String|Array<Array<(string | number)>>} arg\n * @return {Query} this\n * @see cursor.sort https://www.mongodb.com/docs/manual/reference/method/cursor.sort/\n * @api public\n */\n\nQuery.prototype.sort = function(arg) {\n  if (arguments.length > 1) {\n    throw new Error('sort() only takes 1 Argument');\n  }\n\n  return Query.base.sort.call(this, arg);\n};\n\n/**\n * Declare and/or execute this query as a `deleteOne()` operation. Works like\n * remove, except it deletes at most one document regardless of the `single`\n * option.\n *\n * This function triggers `deleteOne` middleware.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' });\n *\n * This function calls the MongoDB driver's [`Collection#deleteOne()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne).\n * The returned [promise](https://mongoosejs.com/docs/queries.html) resolves to an\n * object that contains 3 properties:\n *\n * - `ok`: `1` if no errors occurred\n * - `deletedCount`: the number of documents deleted\n * - `n`: the number of documents deleted. Equal to `deletedCount`.\n *\n * #### Example:\n *\n *     const res = await Character.deleteOne({ name: 'Eddard Stark' });\n *     // `1` if MongoDB deleted a doc, `0` if no docs matched the filter `{ name: ... }`\n *     res.deletedCount;\n *\n * @param {Object|Query} [filter] mongodb selector\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query} this\n * @see DeleteResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html\n * @see deleteOne https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne\n * @api public\n */\n\nQuery.prototype.deleteOne = function deleteOne(filter, options) {\n  if (typeof filter === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.deleteOne() no longer accepts a callback');\n  }\n  this.op = 'deleteOne';\n  this.setOptions(options);\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (filter != null) {\n    this.error(new ObjectParameterError(filter, 'filter', 'deleteOne'));\n  }\n\n  Query.base.deleteOne.call(this);\n\n  return this;\n};\n\n/**\n * Internal thunk for `deleteOne()`\n *\n * @method _deleteOne\n * @instance\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._deleteOne = async function _deleteOne() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n\n  return this._collection.collection.deleteOne(this._conditions, options);\n};\n\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Works like\n * remove, except it deletes _every_ document that matches `filter` in the\n * collection, regardless of the value of `single`.\n *\n * This function triggers `deleteMany` middleware.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });\n *\n * This function calls the MongoDB driver's [`Collection#deleteMany()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany).\n * The returned [promise](https://mongoosejs.com/docs/queries.html) resolves to an\n * object that contains 3 properties:\n *\n * - `ok`: `1` if no errors occurred\n * - `deletedCount`: the number of documents deleted\n * - `n`: the number of documents deleted. Equal to `deletedCount`.\n *\n * #### Example:\n *\n *     const res = await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });\n *     // `0` if no docs matched the filter, number of docs deleted otherwise\n *     res.deletedCount;\n *\n * @param {Object|Query} [filter] mongodb selector\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query} this\n * @see DeleteResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html\n * @see deleteMany https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany\n * @api public\n */\n\nQuery.prototype.deleteMany = function(filter, options) {\n  if (typeof filter === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.deleteMany() no longer accepts a callback');\n  }\n  this.setOptions(options);\n  this.op = 'deleteMany';\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (filter != null) {\n    this.error(new ObjectParameterError(filter, 'filter', 'deleteMany'));\n  }\n\n  Query.base.deleteMany.call(this);\n\n  return this;\n};\n\n/**\n * Execute a `deleteMany()` query\n *\n * @param {Function} callback\n * @method _deleteMany\n * @instance\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._deleteMany = async function _deleteMany() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n\n  return this._collection.collection.deleteMany(this._conditions, options);\n};\n\n/**\n * hydrates a document\n *\n * @param {Model} model\n * @param {Document} doc\n * @param {Object} res 3rd parameter to callback\n * @param {Object} fields\n * @param {Query} self\n * @param {Array} [pop] array of paths used in population\n * @param {Function} callback\n * @api private\n */\n\nfunction completeOne(model, doc, res, options, fields, userProvidedFields, pop, callback) {\n  if ((options.rawResult || options.includeResultMetadata) && doc == null) {\n    _init(null);\n    return null;\n  }\n\n  helpers.createModelAndInit(model, doc, fields, userProvidedFields, options, pop, _init);\n\n  function _init(err, casted) {\n    if (err) {\n      return immediate(() => callback(err));\n    }\n\n\n    if (options.rawResult || options.includeResultMetadata) {\n      if (doc && casted) {\n        if (options.session != null) {\n          casted.$session(options.session);\n        }\n        res.value = casted;\n      } else {\n        res.value = null;\n      }\n      return immediate(() => callback(null, res));\n    }\n    if (options.session != null) {\n      casted.$session(options.session);\n    }\n    immediate(() => callback(null, casted));\n  }\n}\n\n/**\n * If the model is a discriminator type and not root, then add the key & value to the criteria.\n * @param {Query} query\n * @api private\n */\n\nfunction prepareDiscriminatorCriteria(query) {\n  if (!query || !query.model || !query.model.schema) {\n    return;\n  }\n\n  const schema = query.model.schema;\n\n  if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {\n    query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;\n  }\n}\n\n/**\n * Issues a mongodb `findOneAndUpdate()` command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found\n * document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Available options\n *\n * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `runValidators`: if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n * - `setDefaultsOnInsert`: `true` by default. If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created.\n * - `rawResult`: if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n *\n * #### Example:\n *\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @method findOneAndUpdate\n * @memberOf Query\n * @instance\n * @param {Object|Query} [filter]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean} [options.new=false] By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.returnOriginal=null] An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see findAndModify command https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @see ModifyResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html\n * @see findOneAndUpdate https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#findOneAndUpdate\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndUpdate = function(filter, doc, options) {\n  if (typeof filter === 'function' ||\n      typeof doc === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[3] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndUpdate() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndUpdate';\n  this._validateOp();\n  this._validate();\n\n  switch (arguments.length) {\n    case 2:\n      options = undefined;\n      break;\n    case 1:\n      doc = filter;\n      filter = options = undefined;\n      break;\n  }\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  } else if (filter != null) {\n    this.error(\n      new ObjectParameterError(filter, 'filter', 'findOneAndUpdate')\n    );\n  }\n\n  // apply doc\n  if (doc) {\n    this._mergeUpdate(doc);\n  }\n\n  options = options ? clone(options) : {};\n\n  if (options.projection) {\n    this.select(options.projection);\n    delete options.projection;\n  }\n  if (options.fields) {\n    this.select(options.fields);\n    delete options.fields;\n  }\n\n  const returnOriginal = this &&\n    this.model &&\n    this.model.base &&\n    this.model.base.options &&\n    this.model.base.options.returnOriginal;\n  if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {\n    options.returnOriginal = returnOriginal;\n  }\n\n  this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Execute a findOneAndUpdate operation\n *\n * @method _findOneAndUpdate\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._findOneAndUpdate = async function _findOneAndUpdate() {\n  // For backwards compability with Mongoose 6 re: #13550\n\n  if (this._mongooseOptions.overwrite != null) {\n    printOverwriteDeprecationWarning();\n  }\n  if (this._mongooseOptions.overwrite) {\n    this.op = 'findOneAndReplace';\n    return this._findOneAndReplace();\n  }\n\n  this._castConditions();\n\n  _castArrayFilters(this);\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model);\n  applyGlobalDiskUse(this.options, this.model);\n\n  if (this.options.rawResult && this.options.includeResultMetadata === false) {\n    throw new MongooseError('Cannot set `rawResult` option when `includeResultMetadata` is false');\n  }\n\n  if ('strict' in this.options) {\n    this._mongooseOptions.strict = this.options.strict;\n  }\n  const options = this._optionsForExec(this.model);\n  convertNewToReturnDocument(options);\n  this._applyTranslateAliases(options);\n\n  this._update = this._castUpdate(this._update, false);\n\n  const _opts = Object.assign({}, options, {\n    setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert\n  });\n  this._update = setDefaultsOnInsert(this._conditions, this.model.schema,\n    this._update, _opts);\n\n  if (!this._update || Object.keys(this._update).length === 0) {\n    if (options.upsert) {\n      // still need to do the upsert to empty doc\n      const doc = clone(this._update);\n      delete doc._id;\n      this._update = { $set: doc };\n    } else {\n      this._executionStack = null;\n      const res = await this._findOne();\n      return res;\n    }\n  } else if (this._update instanceof Error) {\n    throw this._update;\n  } else {\n    // In order to make MongoDB 2.6 happy (see\n    // https://jira.mongodb.org/browse/SERVER-12266 and related issues)\n    // if we have an actual update document but $set is empty, junk the $set.\n    if (this._update.$set && Object.keys(this._update.$set).length === 0) {\n      delete this._update.$set;\n    }\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n  if (runValidators) {\n    await this.validate(this._update, options, false);\n  }\n\n  if (this._update.toBSON) {\n    this._update = this._update.toBSON();\n  }\n\n  let res = await this._collection.collection.findOneAndUpdate(this._conditions, this._update, options);\n  for (const fn of this._transforms) {\n    res = fn(res);\n  }\n  const doc = options.includeResultMetadata === false ? res : res.value;\n\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, res, _wrapThunkCallback(this, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    }));\n  });\n};\n\n/**\n * Legacy alias for `findOneAndDelete()`.\n *\n * Finds a matching document, removes it, returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndRemove()`\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `rawResult`: if true, resolves to the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n *\n * #### Example:\n *\n *     A.where().findOneAndRemove(conditions, options)  // return Query\n *     A.where().findOneAndRemove(conditions) // returns Query\n *     A.where().findOneAndRemove()           // returns Query\n *\n * @method findOneAndRemove\n * @memberOf Query\n * @instance\n * @param {Object} [conditions]\n * @param {Object} [options]\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @return {Query} this\n * @see findAndModify command https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nQuery.prototype.findOneAndRemove = function(conditions, options) {\n  if (typeof conditions === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndRemove() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndRemove';\n  this._validateOp();\n  this._validate();\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  options && this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Issues a MongoDB [findOneAndDelete](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndDelete/) command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `rawResult`: if true, resolves to the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n *\n * #### Callback Signature\n *\n *     function(error, doc) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *     }\n *\n * #### Example:\n *\n *     A.where().findOneAndDelete(conditions, options)  // return Query\n *     A.where().findOneAndDelete(conditions) // returns Query\n *     A.where().findOneAndDelete()           // returns Query\n *\n * @method findOneAndDelete\n * @memberOf Query\n * @param {Object} [filter]\n * @param {Object} [options]\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @return {Query} this\n * @see findAndModify command https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nQuery.prototype.findOneAndDelete = function(filter, options) {\n  if (typeof filter === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndDelete() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndDelete';\n  this._validateOp();\n  this._validate();\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  }\n\n  options && this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Execute a `findOneAndDelete()` query\n *\n * @return {Query} this\n * @method _findOneAndDelete\n * @memberOf Query\n * @api private\n */\nQuery.prototype._findOneAndDelete = async function _findOneAndDelete() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const includeResultMetadata = this.options.includeResultMetadata;\n  if (this.options.rawResult && includeResultMetadata === false) {\n    throw new MongooseError('Cannot set `rawResult` option when `includeResultMetadata` is false');\n  }\n\n  const filter = this._conditions;\n  const options = this._optionsForExec(this.model);\n  this._applyTranslateAliases(options);\n\n  let res = await this._collection.collection.findOneAndDelete(filter, options);\n  for (const fn of this._transforms) {\n    res = fn(res);\n  }\n  const doc = includeResultMetadata === false ? res : res.value;\n\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, res, _wrapThunkCallback(this, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    }));\n  });\n};\n\n/**\n * Issues a MongoDB [findOneAndReplace](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndReplace/) command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `rawResult`: if true, resolves to the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n *\n * #### Callback Signature\n *\n *     function(error, doc) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *     }\n *\n * #### Example:\n *\n *     A.where().findOneAndReplace(filter, replacement, options); // return Query\n *     A.where().findOneAndReplace(filter); // returns Query\n *     A.where().findOneAndReplace(); // returns Query\n *\n * @method findOneAndReplace\n * @memberOf Query\n * @param {Object} [filter]\n * @param {Object} [replacement]\n * @param {Object} [options]\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.new=false] By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.returnOriginal=null] An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndReplace = function(filter, replacement, options) {\n  if (typeof filter === 'function' ||\n      typeof replacement === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[4] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndReplace() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndReplace';\n  this._validateOp();\n  this._validate();\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  } else if (filter != null) {\n    this.error(\n      new ObjectParameterError(filter, 'filter', 'findOneAndReplace')\n    );\n  }\n\n  if (replacement != null) {\n    this._mergeUpdate(replacement);\n  }\n\n  options = options || {};\n\n  const returnOriginal = this &&\n  this.model &&\n  this.model.base &&\n  this.model.base.options &&\n  this.model.base.options.returnOriginal;\n  if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {\n    options.returnOriginal = returnOriginal;\n  }\n  this.setOptions(options);\n  this.setOptions({ overwrite: true });\n\n  return this;\n};\n\n/**\n * Execute a findOneAndReplace() query\n *\n * @return {Query} this\n * @method _findOneAndReplace\n * @instance\n * @memberOf Query\n * @api private\n */\nQuery.prototype._findOneAndReplace = async function _findOneAndReplace() {\n  this._castConditions();\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  if ('strict' in this.options) {\n    this._mongooseOptions.strict = this.options.strict;\n    delete this.options.strict;\n  }\n\n  const filter = this._conditions;\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n  convertNewToReturnDocument(options);\n\n  const includeResultMetadata = this.options.includeResultMetadata;\n  if (this.options.rawResult && includeResultMetadata === false) {\n    throw new MongooseError('Cannot set `rawResult` option when `includeResultMetadata` is false');\n  }\n\n  const modelOpts = { skipId: true };\n  if ('strict' in this._mongooseOptions) {\n    modelOpts.strict = this._mongooseOptions.strict;\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n\n  try {\n    const update = new this.model(this._update, null, modelOpts);\n    if (runValidators) {\n      await update.validate();\n    } else if (update.$__.validationError) {\n      throw update.$__.validationError;\n    }\n    this._update = update.toBSON();\n  } catch (err) {\n    if (err instanceof ValidationError) {\n      throw err;\n    }\n    const validationError = new ValidationError();\n    validationError.errors[err.path] = err;\n    throw validationError;\n  }\n\n  let res = await this._collection.collection.findOneAndReplace(filter, this._update, options);\n\n  for (const fn of this._transforms) {\n    res = fn(res);\n  }\n\n  const doc = includeResultMetadata === false ? res : res.value;\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, res, _wrapThunkCallback(this, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    }));\n  });\n};\n\n/**\n * Support the `new` option as an alternative to `returnOriginal` for backwards\n * compat.\n * @api private\n */\n\nfunction convertNewToReturnDocument(options) {\n  if ('new' in options) {\n    options.returnDocument = options['new'] ? 'after' : 'before';\n    delete options['new'];\n  }\n  if ('returnOriginal' in options) {\n    options.returnDocument = options['returnOriginal'] ? 'before' : 'after';\n    delete options['returnOriginal'];\n  }\n  // Temporary since driver 4.0.0-beta does not support `returnDocument`\n  if (typeof options.returnDocument === 'string') {\n    options.returnOriginal = options.returnDocument === 'before';\n  }\n}\n\n/**\n * Execute a `findOneAndRemove`. Alias for `findOneAndDelete`\n *\n * @return {Query} this\n * @method _findOneAndRemove\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._findOneAndRemove = async function _findOneAndRemove() {\n  return this._findOneAndDelete();\n};\n\n/**\n * Get options from query opts, falling back to the base mongoose object.\n * @param {Query} query\n * @param {Object} option\n * @param {Any} def\n * @api private\n */\n\nfunction _getOption(query, option, def) {\n  const opts = query._optionsForExec(query.model);\n\n  if (option in opts) {\n    return opts[option];\n  }\n  if (option in query.model.base.options) {\n    return query.model.base.options[option];\n  }\n  return def;\n}\n\n/*!\n * ignore\n */\n\nfunction _completeOneLean(schema, doc, path, res, opts, callback) {\n  if (opts.lean && typeof opts.lean.transform === 'function') {\n    opts.lean.transform(doc);\n\n    for (let i = 0; i < schema.childSchemas.length; i++) {\n      const childPath = path ? path + '.' + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;\n      const _schema = schema.childSchemas[i].schema;\n      const obj = mpath.get(childPath, doc);\n      if (obj == null) {\n        continue;\n      }\n      if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n          opts.lean.transform(obj[i]);\n        }\n      } else {\n        opts.lean.transform(obj);\n      }\n      _completeOneLean(_schema, obj, childPath, res, opts);\n    }\n    if (callback) {\n      return callback(null, doc);\n    } else {\n      return;\n    }\n  }\n  if (opts.rawResult) {\n    return callback(null, res);\n  }\n  return callback(null, doc);\n}\n\n/*!\n * ignore\n */\n\nfunction _completeManyLean(schema, docs, path, opts) {\n  if (opts.lean && typeof opts.lean.transform === 'function') {\n    for (const doc of docs) {\n      opts.lean.transform(doc);\n    }\n\n    for (let i = 0; i < schema.childSchemas.length; i++) {\n      const childPath = path ? path + '.' + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;\n      const _schema = schema.childSchemas[i].schema;\n      let doc = mpath.get(childPath, docs);\n      if (doc == null) {\n        continue;\n      }\n      doc = doc.flat();\n      for (let i = 0; i < doc.length; i++) {\n        opts.lean.transform(doc[i]);\n      }\n      _completeManyLean(_schema, doc, childPath, opts);\n    }\n  }\n\n  return docs;\n}\n/**\n * Override mquery.prototype._mergeUpdate to handle mongoose objects in\n * updates.\n *\n * @param {Object} doc\n * @method _mergeUpdate\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype._mergeUpdate = function(doc) {\n  if (!this._update) {\n    this._update = Array.isArray(doc) ? [] : {};\n  }\n\n  if (doc == null || (typeof doc === 'object' && Object.keys(doc).length === 0)) {\n    return;\n  }\n\n  if (doc instanceof Query) {\n    if (Array.isArray(this._update)) {\n      throw new Error('Cannot mix array and object updates');\n    }\n    if (doc._update) {\n      utils.mergeClone(this._update, doc._update);\n    }\n  } else if (Array.isArray(doc)) {\n    if (!Array.isArray(this._update)) {\n      throw new Error('Cannot mix array and object updates');\n    }\n    this._update = this._update.concat(doc);\n  } else {\n    if (Array.isArray(this._update)) {\n      throw new Error('Cannot mix array and object updates');\n    }\n    utils.mergeClone(this._update, doc);\n  }\n};\n\n/*!\n * ignore\n */\n\nasync function _updateThunk(op) {\n  this._castConditions();\n\n  _castArrayFilters(this);\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const castedQuery = this._conditions;\n  const options = this._optionsForExec(this.model);\n  this._applyTranslateAliases(options);\n\n  this._update = clone(this._update, options);\n  const isOverwriting = this._mongooseOptions.overwrite && !hasDollarKeys(this._update);\n  if (isOverwriting) {\n    if (op === 'updateOne' || op === 'updateMany') {\n      throw new MongooseError('The MongoDB server disallows ' +\n        'overwriting documents using `' + op + '`. See: ' +\n        'https://mongoosejs.com/docs/deprecations.html#update');\n    }\n    this._update = new this.model(this._update, null, true);\n  } else {\n    this._update = this._castUpdate(this._update, this._mongooseOptions.overwrite);\n\n    if (this._update == null || Object.keys(this._update).length === 0) {\n      return { acknowledged: false };\n    }\n\n    const _opts = Object.assign({}, options, {\n      setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert\n    });\n    this._update = setDefaultsOnInsert(this._conditions, this.model.schema,\n      this._update, _opts);\n  }\n\n  if (Array.isArray(options.arrayFilters)) {\n    options.arrayFilters = removeUnusedArrayFilters(this._update, options.arrayFilters);\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n  if (runValidators) {\n    await this.validate(this._update, options, isOverwriting);\n  }\n\n  if (this._update.toBSON) {\n    this._update = this._update.toBSON();\n  }\n\n  return this._collection.collection[op](castedQuery, this._update, options);\n}\n\n/**\n * Mongoose calls this function internally to validate the query if\n * `runValidators` is set\n *\n * @param {Object} castedDoc the update, after casting\n * @param {Object} options the options from `_optionsForExec()`\n * @param {Boolean} isOverwriting\n * @method validate\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype.validate = async function validate(castedDoc, options, isOverwriting) {\n  if (typeof arguments[3] === 'function') {\n    throw new MongooseError('Query.prototype.validate() no longer accepts a callback');\n  }\n\n  await _executePreHooks(this, 'validate');\n\n  if (isOverwriting) {\n    await castedDoc.$validate();\n  } else {\n    await new Promise((resolve, reject) => {\n      updateValidators(this, this.model.schema, castedDoc, options, (err) => {\n        if (err != null) {\n          return reject(err);\n        }\n        resolve();\n      });\n    });\n  }\n\n  await _executePostHooks(this, null, null, 'validate');\n};\n\n/**\n * Execute an updateMany query\n *\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @method _updateMany\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._updateMany = async function _updateMany() {\n  return _updateThunk.call(this, 'updateMany');\n};\n\n/**\n * Execute an updateOne query\n *\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @method _updateOne\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._updateOne = async function _updateOne() {\n  return _updateThunk.call(this, 'updateOne');\n};\n\n/**\n * Execute a replaceOne query\n *\n * @see Model.replaceOne https://mongoosejs.com/docs/api/model.html#Model.replaceOne()\n * @method _replaceOne\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._replaceOne = async function _replaceOne() {\n  return _updateThunk.call(this, 'replaceOne');\n};\n\n/**\n * Declare and/or execute this query as an updateMany() operation.\n * MongoDB will update _all_ documents that match `filter` (as opposed to just the first one).\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.n; // Number of documents matched\n *     res.nModified; // Number of documents modified\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} [filter]\n * @param {Object|Array} [update] the update command\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see update https://www.mongodb.com/docs/manual/reference/method/db.collection.update/\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @api public\n */\n\nQuery.prototype.updateMany = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'updateMany', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as an updateOne() operation.\n * MongoDB will update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using [atomic operators](https://www.mongodb.com/docs/manual/tutorial/model-data-for-atomic-operations/#pattern) like `$set`.\n *\n * **Note** updateOne will _not_ fire update middleware. Use `pre('updateOne')`\n * and `post('updateOne')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.\n *     res.matchedCount; // Number of documents that matched the filter\n *     res.modifiedCount; // Number of documents that were modified\n *     res.upsertedCount; // Number of documents that were upserted\n *     res.upsertedId; // Identifier of the inserted document (if an upsert took place)\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} [filter]\n * @param {Object|Array} [update] the update command\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see update https://www.mongodb.com/docs/manual/reference/method/db.collection.update/\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @api public\n */\n\nQuery.prototype.updateOne = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'updateOne', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as a replaceOne() operation.\n * MongoDB will replace the existing document and will not accept any [atomic operators](https://www.mongodb.com/docs/manual/tutorial/model-data-for-atomic-operations/#pattern) (`$set`, etc.)\n *\n * **Note** replaceOne will _not_ fire update middleware. Use `pre('replaceOne')`\n * and `post('replaceOne')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.\n *     res.matchedCount; // Number of documents that matched the filter\n *     res.modifiedCount; // Number of documents that were modified\n *     res.upsertedCount; // Number of documents that were upserted\n *     res.upsertedId; // Identifier of the inserted document (if an upsert took place)\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} [filter]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see update https://www.mongodb.com/docs/manual/reference/method/db.collection.update/\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @api public\n */\n\nQuery.prototype.replaceOne = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  this.setOptions({ overwrite: true });\n  return _update(this, 'replaceOne', conditions, doc, options, callback);\n};\n\n/**\n * Internal helper for update, updateMany, updateOne, replaceOne\n * @param {Query} query\n * @param {String} op\n * @param {Object} filter\n * @param {Document} [doc]\n * @param {Object} [options]\n * @param {Function} callback\n * @api private\n */\n\nfunction _update(query, op, filter, doc, options, callback) {\n  // make sure we don't send in the whole Document to merge()\n  query.op = op;\n  query._validateOp();\n  doc = doc || {};\n\n  // strict is an option used in the update checking, make sure it gets set\n  if (options != null) {\n    if ('strict' in options) {\n      query._mongooseOptions.strict = options.strict;\n    }\n  }\n\n  if (!(filter instanceof Query) &&\n      filter != null &&\n      filter.toString() !== '[object Object]') {\n    query.error(new ObjectParameterError(filter, 'filter', op));\n  } else {\n    query.merge(filter);\n  }\n\n  if (utils.isObject(options)) {\n    query.setOptions(options);\n  }\n\n  query._mergeUpdate(doc);\n\n  // Hooks\n  if (callback) {\n    query.exec(callback);\n\n    return query;\n  }\n\n  return Query.base[op].call(query, filter, void 0, options, callback);\n}\n\n/**\n * Runs a function `fn` and treats the return value of `fn` as the new value\n * for the query to resolve to.\n *\n * Any functions you pass to `transform()` will run **after** any post hooks.\n *\n * #### Example:\n *\n *     const res = await MyModel.findOne().transform(res => {\n *       // Sets a `loadedAt` property on the doc that tells you the time the\n *       // document was loaded.\n *       return res == null ?\n *         res :\n *         Object.assign(res, { loadedAt: new Date() });\n *     });\n *\n * @method transform\n * @memberOf Query\n * @instance\n * @param {Function} fn function to run to transform the query result\n * @return {Query} this\n */\n\nQuery.prototype.transform = function(fn) {\n  this._transforms.push(fn);\n  return this;\n};\n\n/**\n * Make this query throw an error if no documents match the given `filter`.\n * This is handy for integrating with async/await, because `orFail()` saves you\n * an extra `if` statement to check if no document was found.\n *\n * #### Example:\n *\n *     // Throws if no doc returned\n *     await Model.findOne({ foo: 'bar' }).orFail();\n *\n *     // Throws if no document was updated. Note that `orFail()` will still\n *     // throw if the only document that matches is `{ foo: 'bar', name: 'test' }`,\n *     // because `orFail()` will throw if no document was _updated_, not\n *     // if no document was _found_.\n *     await Model.updateOne({ foo: 'bar' }, { name: 'test' }).orFail();\n *\n *     // Throws \"No docs found!\" error if no docs match `{ foo: 'bar' }`\n *     await Model.find({ foo: 'bar' }).orFail(new Error('No docs found!'));\n *\n *     // Throws \"Not found\" error if no document was found\n *     await Model.findOneAndUpdate({ foo: 'bar' }, { name: 'test' }).\n *       orFail(() => Error('Not found'));\n *\n * @method orFail\n * @memberOf Query\n * @instance\n * @param {Function|Error} [err] optional error to throw if no docs match `filter`. If not specified, `orFail()` will throw a `DocumentNotFoundError`\n * @return {Query} this\n */\n\nQuery.prototype.orFail = function(err) {\n  this.transform(res => {\n    switch (this.op) {\n      case 'find':\n        if (res.length === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'findOne':\n        if (res == null) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'replaceOne':\n      case 'updateMany':\n      case 'updateOne':\n        if (res && res.matchedCount === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'findOneAndDelete':\n      case 'findOneAndRemove':\n        if ((res && res.lastErrorObject && res.lastErrorObject.n) === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'findOneAndUpdate':\n      case 'findOneAndReplace':\n        if ((res && res.lastErrorObject && res.lastErrorObject.updatedExisting) === false) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'deleteMany':\n      case 'deleteOne':\n        if (res.deletedCount === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      default:\n        break;\n    }\n\n    return res;\n  });\n  return this;\n};\n\n/**\n * Get the error to throw for `orFail()`\n * @param {Error|undefined} err\n * @param {Query} query\n * @api private\n */\n\nfunction _orFailError(err, query) {\n  if (typeof err === 'function') {\n    err = err.call(query);\n  }\n\n  if (err == null) {\n    err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);\n  }\n\n  return err;\n}\n\n/**\n * Wrapper function to call isPathSelectedInclusive on a query.\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.isPathSelectedInclusive = function(path) {\n  return isPathSelectedInclusive(this._fields, path);\n};\n\n/**\n * Executes the query\n *\n * #### Example:\n *\n *     const promise = query.exec();\n *     const promise = query.exec('update');\n *\n * @param {String|Function} [operation]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.exec = async function exec(op) {\n  if (typeof op === 'function' || (arguments.length >= 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Query.prototype.exec() no longer accepts a callback');\n  }\n\n  if (typeof op === 'string') {\n    this.op = op;\n  }\n\n  if (this.op == null) {\n    throw new MongooseError('Query must have `op` before executing');\n  }\n  if (this.model == null) {\n    throw new MongooseError('Query must have an associated model before executing');\n  }\n  this._validateOp();\n\n  if (!this.op) {\n    return;\n  }\n\n  if (this.options && this.options.sort) {\n    const keys = Object.keys(this.options.sort);\n    if (keys.includes('')) {\n      throw new Error('Invalid field \"\" passed to sort()');\n    }\n  }\n\n  let thunk = '_' + this.op;\n  if (this.op === 'distinct') {\n    thunk = '__distinct';\n  }\n\n  if (this._executionStack != null) {\n    let str = this.toString();\n    if (str.length > 60) {\n      str = str.slice(0, 60) + '...';\n    }\n    const err = new MongooseError('Query was already executed: ' + str);\n    err.originalStack = this._executionStack.stack;\n    throw err;\n  } else {\n    this._executionStack = new Error();\n  }\n\n  await _executePreExecHooks(this);\n\n  let res;\n\n  let error = null;\n  try {\n    await _executePreHooks(this);\n    res = await this[thunk]();\n\n    for (const fn of this._transforms) {\n      res = fn(res);\n    }\n  } catch (err) {\n    if (err instanceof Kareem.skipWrappedFunction) {\n      res = err.args[0];\n    } else {\n      error = err;\n    }\n  }\n\n  res = await _executePostHooks(this, res, error);\n\n  await _executePostExecHooks(this);\n\n  return res;\n};\n\n/*!\n * ignore\n */\n\nfunction _executePostExecHooks(query) {\n  return new Promise((resolve, reject) => {\n    query._hooks.execPost('exec', query, [], {}, (error) => {\n      if (error) {\n        return reject(error);\n      }\n\n      resolve();\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _executePostHooks(query, res, error, op) {\n  if (query._queryMiddleware == null) {\n    if (error != null) {\n      throw error;\n    }\n    return res;\n  }\n\n  return new Promise((resolve, reject) => {\n    const opts = error ? { error } : {};\n\n    query._queryMiddleware.execPost(op || query.op, query, [res], opts, (error, res) => {\n      if (error) {\n        return reject(error);\n      }\n\n      resolve(res);\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _executePreExecHooks(query) {\n  return new Promise((resolve, reject) => {\n    query._hooks.execPre('exec', query, [], (error) => {\n      if (error != null) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _executePreHooks(query, op) {\n  if (query._queryMiddleware == null) {\n    return;\n  }\n\n  return new Promise((resolve, reject) => {\n    query._queryMiddleware.execPre(op || query.op, query, [], (error) => {\n      if (error != null) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _wrapThunkCallback(query, cb) {\n  return function(error, res) {\n    if (error != null) {\n      return cb(error);\n    }\n\n    for (const fn of query._transforms) {\n      try {\n        res = fn(res);\n      } catch (error) {\n        return cb(error);\n      }\n    }\n\n    return cb(null, res);\n  };\n}\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * More about [`then()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/then).\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n * Like `.then()`, but only takes a rejection handler.\n *\n * More about [Promise `catch()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/catch).\n *\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.catch = function(reject) {\n  return this.exec().then(null, reject);\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with `.finally()` chained.\n *\n * More about [Promise `finally()` in JavaScript](https://thecodebarbarian.com/using-promise-finally-in-node-js.html).\n *\n * @param {Function} [onFinally]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.finally = function(onFinally) {\n  return this.exec().finally(onFinally);\n};\n\n/**\n * Returns a string representation of this query.\n *\n * More about [`toString()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/tostring).\n *\n * #### Example:\n *     const q = Model.find();\n *     console.log(q); // Prints \"Query { find }\"\n *\n * @return {String}\n * @api public\n * @method [Symbol.toStringTag]\n * @memberOf Query\n */\n\nQuery.prototype[Symbol.toStringTag] = function toString() {\n  return `Query { ${this.op} }`;\n};\n\n/**\n * Add pre [middleware](https://mongoosejs.com/docs/middleware.html) to this query instance. Doesn't affect\n * other queries.\n *\n * #### Example:\n *\n *     const q1 = Question.find({ answer: 42 });\n *     q1.pre(function middleware() {\n *       console.log(this.getFilter());\n *     });\n *     await q1.exec(); // Prints \"{ answer: 42 }\"\n *\n *     // Doesn't print anything, because `middleware()` is only\n *     // registered on `q1`.\n *     await Question.find({ answer: 42 });\n *\n * @param {Function} fn\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.pre = function(fn) {\n  this._hooks.pre('exec', fn);\n  return this;\n};\n\n/**\n * Add post [middleware](https://mongoosejs.com/docs/middleware.html) to this query instance. Doesn't affect\n * other queries.\n *\n * #### Example:\n *\n *     const q1 = Question.find({ answer: 42 });\n *     q1.post(function middleware() {\n *       console.log(this.getFilter());\n *     });\n *     await q1.exec(); // Prints \"{ answer: 42 }\"\n *\n *     // Doesn't print anything, because `middleware()` is only\n *     // registered on `q1`.\n *     await Question.find({ answer: 42 });\n *\n * @param {Function} fn\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.post = function(fn) {\n  this._hooks.post('exec', fn);\n  return this;\n};\n\n/**\n * Casts obj for an update command.\n *\n * @param {Object} obj\n * @param {Boolean} overwrite\n * @return {Object} obj after casting its values\n * @method _castUpdate\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype._castUpdate = function _castUpdate(obj, overwrite) {\n  let schema = this.schema;\n\n  const discriminatorKey = schema.options.discriminatorKey;\n  const baseSchema = schema._baseSchema ? schema._baseSchema : schema;\n  if (this._mongooseOptions.overwriteDiscriminatorKey &&\n      obj[discriminatorKey] != null &&\n      baseSchema.discriminators) {\n    const _schema = Object.values(baseSchema.discriminators).find(\n      discriminator => discriminator.discriminatorMapping.value === obj[discriminatorKey]\n    );\n    if (_schema != null) {\n      schema = _schema;\n    }\n  }\n\n  let upsert;\n  if ('upsert' in this.options) {\n    upsert = this.options.upsert;\n  }\n\n  const filter = this._conditions;\n  if (schema != null &&\n      utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) &&\n      typeof filter[schema.options.discriminatorKey] !== 'object' &&\n      schema.discriminators != null) {\n    const discriminatorValue = filter[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(this.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      (byValue && byValue.schema) ||\n      schema;\n  }\n\n  return castUpdate(schema, obj, {\n    overwrite: overwrite,\n    strict: this._mongooseOptions.strict,\n    upsert: upsert,\n    arrayFilters: this.options.arrayFilters,\n    overwriteDiscriminatorKey: this._mongooseOptions.overwriteDiscriminatorKey\n  }, this, this._conditions);\n};\n\n/**\n * Specifies paths which should be populated with other documents.\n *\n * #### Example:\n *\n *     let book = await Book.findOne().populate('authors');\n *     book.title; // 'Node.js in Action'\n *     book.authors[0].name; // 'TJ Holowaychuk'\n *     book.authors[1].name; // 'Nathan Rajlich'\n *\n *     let books = await Book.find().populate({\n *       path: 'authors',\n *       // `match` and `sort` apply to the Author model,\n *       // not the Book model. These options do not affect\n *       // which documents are in `books`, just the order and\n *       // contents of each book document's `authors`.\n *       match: { name: new RegExp('.*h.*', 'i') },\n *       sort: { name: -1 }\n *     });\n *     books[0].title; // 'Node.js in Action'\n *     // Each book's `authors` are sorted by name, descending.\n *     books[0].authors[0].name; // 'TJ Holowaychuk'\n *     books[0].authors[1].name; // 'Marc Harter'\n *\n *     books[1].title; // 'Professional AngularJS'\n *     // Empty array, no authors' name has the letter 'h'\n *     books[1].authors; // []\n *\n * Paths are populated after the query executes and a response is received. A\n * separate query is then executed for each path specified for population. After\n * a response for each query has also been returned, the results are passed to\n * the callback.\n *\n * @param {Object|String|String[]} path either the path(s) to populate or an object specifying all parameters\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @see population https://mongoosejs.com/docs/populate.html\n * @see Query#select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see Model.populate https://mongoosejs.com/docs/api/model.html#Model.populate()\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.populate = function() {\n  // Bail when given no truthy arguments\n  if (!Array.from(arguments).some(Boolean)) {\n    return this;\n  }\n\n  const res = utils.populate.apply(null, arguments);\n\n  // Propagate readConcern and readPreference and lean from parent query,\n  // unless one already specified\n  if (this.options != null) {\n    const readConcern = this.options.readConcern;\n    const readPref = this.options.readPreference;\n\n    for (const populateOptions of res) {\n      if (readConcern != null && (populateOptions && populateOptions.options && populateOptions.options.readConcern) == null) {\n        populateOptions.options = populateOptions.options || {};\n        populateOptions.options.readConcern = readConcern;\n      }\n      if (readPref != null && (populateOptions && populateOptions.options && populateOptions.options.readPreference) == null) {\n        populateOptions.options = populateOptions.options || {};\n        populateOptions.options.readPreference = readPref;\n      }\n    }\n  }\n\n  const opts = this._mongooseOptions;\n\n  if (opts.lean != null) {\n    const lean = opts.lean;\n    for (const populateOptions of res) {\n      if ((populateOptions && populateOptions.options && populateOptions.options.lean) == null) {\n        populateOptions.options = populateOptions.options || {};\n        populateOptions.options.lean = lean;\n      }\n    }\n  }\n\n  if (!utils.isObject(opts.populate)) {\n    opts.populate = {};\n  }\n\n  const pop = opts.populate;\n\n  for (const populateOptions of res) {\n    const path = populateOptions.path;\n    if (pop[path] && pop[path].populate && populateOptions.populate) {\n      populateOptions.populate = pop[path].populate.concat(populateOptions.populate);\n    }\n\n    pop[populateOptions.path] = populateOptions;\n  }\n  return this;\n};\n\n/**\n * Gets a list of paths to be populated by this query\n *\n * #### Example:\n *\n *      bookSchema.pre('findOne', function() {\n *        let keys = this.getPopulatedPaths(); // ['author']\n *      });\n *      ...\n *      Book.findOne({}).populate('author');\n *\n * #### Example:\n *\n *      // Deep populate\n *      const q = L1.find().populate({\n *        path: 'level2',\n *        populate: { path: 'level3' }\n *      });\n *      q.getPopulatedPaths(); // ['level2', 'level2.level3']\n *\n * @return {Array} an array of strings representing populated paths\n * @api public\n */\n\nQuery.prototype.getPopulatedPaths = function getPopulatedPaths() {\n  const obj = this._mongooseOptions.populate || {};\n  const ret = Object.keys(obj);\n  for (const path of Object.keys(obj)) {\n    const pop = obj[path];\n    if (!Array.isArray(pop.populate)) {\n      continue;\n    }\n    _getPopulatedPaths(ret, pop.populate, path + '.');\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction _getPopulatedPaths(list, arr, prefix) {\n  for (const pop of arr) {\n    list.push(prefix + pop.path);\n    if (!Array.isArray(pop.populate)) {\n      continue;\n    }\n    _getPopulatedPaths(list, pop.populate, prefix + pop.path + '.');\n  }\n}\n\n/**\n * Casts this query to the schema of `model`\n *\n * #### Note:\n *\n * If `obj` is present, it is cast instead of this query.\n *\n * @param {Model} [model] the model to cast to. If not set, defaults to `this.model`\n * @param {Object} [obj]\n * @return {Object}\n * @api public\n */\n\nQuery.prototype.cast = function(model, obj) {\n  obj || (obj = this._conditions);\n  model = model || this.model;\n  const discriminatorKey = model.schema.options.discriminatorKey;\n  if (obj != null &&\n      obj.hasOwnProperty(discriminatorKey)) {\n    model = getDiscriminatorByValue(model.discriminators, obj[discriminatorKey]) || model;\n  }\n\n  const opts = { upsert: this.options && this.options.upsert };\n  if (this.options) {\n    if ('strict' in this.options) {\n      opts.strict = this.options.strict;\n    }\n    if ('strictQuery' in this.options) {\n      opts.strictQuery = this.options.strictQuery;\n    }\n  }\n\n  try {\n    return cast(model.schema, obj, opts, this);\n  } catch (err) {\n    // CastError, assign model\n    if (typeof err.setModel === 'function') {\n      err.setModel(model);\n    }\n    throw err;\n  }\n};\n\n/**\n * Casts selected field arguments for field selection with mongo 2.2\n *\n *     query.select({ ids: { $elemMatch: { $in: [hexString] }})\n *\n * @param {Object} fields\n * @see https://github.com/Automattic/mongoose/issues/1091\n * @see https://www.mongodb.com/docs/manual/reference/projection/elemMatch/\n * @api private\n */\n\nQuery.prototype._castFields = function _castFields(fields) {\n  let selected,\n      elemMatchKeys,\n      keys,\n      key,\n      out;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    elemMatchKeys = [];\n\n    // collect $elemMatch args\n    for (let i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (fields[key].$elemMatch) {\n        selected || (selected = {});\n        selected[key] = fields[key];\n        elemMatchKeys.push(key);\n      }\n    }\n  }\n\n  if (selected) {\n    // they passed $elemMatch, cast em\n    try {\n      out = this.cast(this.model, selected);\n    } catch (err) {\n      return err;\n    }\n\n    // apply the casted field args\n    for (let i = 0; i < elemMatchKeys.length; ++i) {\n      key = elemMatchKeys[i];\n      fields[key] = out[key];\n    }\n  }\n\n  return fields;\n};\n\n/**\n * Applies schematype selected options to this query.\n * @api private\n */\n\nQuery.prototype._applyPaths = function applyPaths() {\n  if (!this.model) {\n    return;\n  }\n  this._fields = this._fields || {};\n  helpers.applyPaths(this._fields, this.model.schema);\n\n  let _selectPopulatedPaths = true;\n\n  if ('selectPopulatedPaths' in this.model.base.options) {\n    _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;\n  }\n  if ('selectPopulatedPaths' in this.model.schema.options) {\n    _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;\n  }\n\n  if (_selectPopulatedPaths) {\n    selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);\n  }\n};\n\n/**\n * Returns a wrapper around a [mongodb driver cursor](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html).\n * A QueryCursor exposes a Streams3 interface, as well as a `.next()` function.\n *\n * The `.cursor()` function triggers pre find hooks, but **not** post find hooks.\n *\n * #### Example:\n *\n *     // There are 2 ways to use a cursor. First, as a stream:\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       on('data', function(doc) { console.log(doc); }).\n *       on('end', function() { console.log('Done!'); });\n *\n *     // Or you can use `.next()` to manually get the next doc in the stream.\n *     // `.next()` returns a promise, so you can use promises or callbacks.\n *     const cursor = Thing.find({ name: /^hello/ }).cursor();\n *     cursor.next(function(error, doc) {\n *       console.log(doc);\n *     });\n *\n *     // Because `.next()` returns a promise, you can use co\n *     // to easily iterate through all documents without loading them\n *     // all into memory.\n *     const cursor = Thing.find({ name: /^hello/ }).cursor();\n *     for (let doc = await cursor.next(); doc != null; doc = await cursor.next()) {\n *       console.log(doc);\n *     }\n *\n * #### Valid options\n *\n *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data` and returned by `.next()`.\n *\n * @return {QueryCursor}\n * @param {Object} [options]\n * @see QueryCursor https://mongoosejs.com/docs/api/querycursor.html\n * @api public\n */\n\nQuery.prototype.cursor = function cursor(opts) {\n  if (opts) {\n    this.setOptions(opts);\n  }\n\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    return (new QueryCursor(this))._markError(err);\n  }\n\n  return new QueryCursor(this);\n};\n\n// the rest of these are basically to support older Mongoose syntax with mquery\n\n/**\n * Sets the tailable option (for use with capped collections).\n *\n * #### Example:\n *\n *     query.tailable(); // true\n *     query.tailable(true);\n *     query.tailable(false);\n *\n *     // Set both `tailable` and `awaitData` options\n *     query.tailable({ awaitData: true });\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} bool defaults to true\n * @param {Object} [opts] options to set\n * @param {Boolean} [opts.awaitData] false by default. Set to true to keep the cursor open even if there's no data.\n * @param {Number} [opts.maxAwaitTimeMS] the maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires `tailable` and `awaitData` to be true\n * @see tailable https://www.mongodb.com/docs/manual/tutorial/create-tailable-cursor/\n * @api public\n */\n\nQuery.prototype.tailable = function(val, opts) {\n  // we need to support the tailable({ awaitData : true }) as well as the\n  // tailable(true, {awaitData :true}) syntax that mquery does not support\n  if (val != null && typeof val.constructor === 'function' && val.constructor.name === 'Object') {\n    opts = val;\n    val = true;\n  }\n\n  if (val === undefined) {\n    val = true;\n  }\n\n  if (opts && typeof opts === 'object') {\n    for (const key of Object.keys(opts)) {\n      if (key === 'awaitData' || key === 'awaitdata') { // backwards compat, see gh-10875\n        // For backwards compatibility\n        this.options['awaitData'] = !!opts[key];\n      } else {\n        this.options[key] = opts[key];\n      }\n    }\n  }\n\n  return Query.base.tailable.call(this, val);\n};\n\n/**\n * Declares an intersects query for `geometry()`.\n *\n * #### Example:\n *\n *     query.where('path').intersects().geometry({\n *       type: 'LineString',\n *       coordinates: [[180.0, 11.0], [180, 9.0]]\n *     });\n *\n *     query.where('path').intersects({\n *       type: 'LineString',\n *       coordinates: [[180.0, 11.0], [180, 9.0]]\n *     });\n *\n * #### Note:\n *\n * **MUST** be used after `where()`.\n *\n * #### Note:\n *\n * In Mongoose 3.7, `intersects` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n *\n * @method intersects\n * @memberOf Query\n * @instance\n * @param {Object} [arg]\n * @return {Query} this\n * @see $geometry https://www.mongodb.com/docs/manual/reference/operator/geometry/\n * @see geoIntersects https://www.mongodb.com/docs/manual/reference/operator/geoIntersects/\n * @api public\n */\n\n/**\n * Specifies a `$geometry` condition\n *\n * #### Example:\n *\n *     const polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     const polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     const polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * The argument is assigned to the most recent path passed to `where()`.\n *\n * #### Note:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * @method geometry\n * @memberOf Query\n * @instance\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see $geometry https://www.mongodb.com/docs/manual/reference/operator/geometry/\n * @see Geospatial Support Enhancements https://www.mongodb.com/docs/manual/release-notes/2.4/#geospatial-support-enhancements\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *\n * @method near\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see $near https://www.mongodb.com/docs/manual/reference/operator/near/\n * @see $nearSphere https://www.mongodb.com/docs/manual/reference/operator/nearSphere/\n * @see $maxDistance https://www.mongodb.com/docs/manual/reference/operator/maxDistance/\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * Overwriting mquery is needed to support a couple different near() forms found in older\n * versions of mongoose\n * near([1,1])\n * near(1,1)\n * near(field, [1,2])\n * near(field, 1, 2)\n * In addition to all of the normal forms supported by mquery\n *\n * @method near\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype.near = function() {\n  const params = [];\n  const sphere = this._mongooseOptions.nearSphere;\n\n  // TODO refactor\n\n  if (arguments.length === 1) {\n    if (Array.isArray(arguments[0])) {\n      params.push({ center: arguments[0], spherical: sphere });\n    } else if (typeof arguments[0] === 'string') {\n      // just passing a path\n      params.push(arguments[0]);\n    } else if (utils.isObject(arguments[0])) {\n      if (typeof arguments[0].spherical !== 'boolean') {\n        arguments[0].spherical = sphere;\n      }\n      params.push(arguments[0]);\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      params.push({ center: [arguments[0], arguments[1]], spherical: sphere });\n    } else if (typeof arguments[0] === 'string' && Array.isArray(arguments[1])) {\n      params.push(arguments[0]);\n      params.push({ center: arguments[1], spherical: sphere });\n    } else if (typeof arguments[0] === 'string' && utils.isObject(arguments[1])) {\n      params.push(arguments[0]);\n      if (typeof arguments[1].spherical !== 'boolean') {\n        arguments[1].spherical = sphere;\n      }\n      params.push(arguments[1]);\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else if (arguments.length === 3) {\n    if (typeof arguments[0] === 'string' && typeof arguments[1] === 'number'\n        && typeof arguments[2] === 'number') {\n      params.push(arguments[0]);\n      params.push({ center: [arguments[1], arguments[2]], spherical: sphere });\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else {\n    throw new TypeError('invalid argument');\n  }\n\n  return Query.base.near.apply(this, params);\n};\n\n/**\n * _DEPRECATED_ Specifies a `$nearSphere` condition\n *\n * #### Example:\n *\n *     query.where('loc').nearSphere({ center: [10, 10], maxDistance: 5 });\n *\n * **Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10], spherical: true });\n *\n * @deprecated\n * @see near() https://mongoosejs.com/docs/api/query.html#Query.prototype.near()\n * @see $near https://www.mongodb.com/docs/manual/reference/operator/near/\n * @see $nearSphere https://www.mongodb.com/docs/manual/reference/operator/nearSphere/\n * @see $maxDistance https://www.mongodb.com/docs/manual/reference/operator/maxDistance/\n */\n\nQuery.prototype.nearSphere = function() {\n  this._mongooseOptions.nearSphere = true;\n  this.near.apply(this, arguments);\n  return this;\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * This function *only* works for `find()` queries.\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     for await (const doc of Model.aggregate([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf Query\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  Query.prototype[Symbol.asyncIterator] = function() {\n    return this.cursor().transformNull()._transformForAsyncIterator();\n  };\n}\n\n/**\n * Specifies a `$polygon` condition\n *\n * #### Example:\n *\n *     query.where('loc').within().polygon([10, 20], [13, 25], [7, 15]);\n *     query.polygon('loc', [10, 20], [13, 25], [7, 15]);\n *\n * @method polygon\n * @memberOf Query\n * @instance\n * @param {String|Array} [path]\n * @param {...Array|Object} [coordinatePairs]\n * @return {Query} this\n * @see $polygon https://www.mongodb.com/docs/manual/reference/operator/polygon/\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * Specifies a `$box` condition\n *\n * #### Example:\n *\n *     const lowerLeft = [40.73083, -73.99756]\n *     const upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box({ ll : lowerLeft, ur : upperRight })\n *\n * @method box\n * @memberOf Query\n * @instance\n * @see $box https://www.mongodb.com/docs/manual/reference/operator/box/\n * @see within() Query#within https://mongoosejs.com/docs/api/query.html#Query.prototype.within()\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @param {Object|Array<Number>} val1 Lower Left Coordinates OR a object of lower-left(ll) and upper-right(ur) Coordinates\n * @param {Array<Number>} [val2] Upper Right Coordinates\n * @return {Query} this\n * @api public\n */\n\n/**\n * this is needed to support the mongoose syntax of:\n * box(field, { ll : [x,y], ur : [x2,y2] })\n * box({ ll : [x,y], ur : [x2,y2] })\n *\n * @method box\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype.box = function(ll, ur) {\n  if (!Array.isArray(ll) && utils.isObject(ll)) {\n    ur = ll.ur;\n    ll = ll.ll;\n  }\n  return Query.base.box.call(this, ll, ur);\n};\n\n/**\n * Specifies a `$center` or `$centerSphere` condition.\n *\n * #### Example:\n *\n *     const area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     // alternatively\n *     query.circle('loc', area);\n *\n *     // spherical calculations\n *     const area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     // alternatively\n *     query.circle('loc', area);\n *\n * @method circle\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see $center https://www.mongodb.com/docs/manual/reference/operator/center/\n * @see $centerSphere https://www.mongodb.com/docs/manual/reference/operator/centerSphere/\n * @see $geoWithin https://www.mongodb.com/docs/manual/reference/operator/geoWithin/\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * _DEPRECATED_ Alias for [circle](https://mongoosejs.com/docs/api/query.html#Query.prototype.circle())\n *\n * **Deprecated.** Use [circle](https://mongoosejs.com/docs/api/query.html#Query.prototype.circle()) instead.\n *\n * @deprecated\n * @method center\n * @memberOf Query\n * @instance\n * @api public\n */\n\nQuery.prototype.center = Query.base.circle;\n\n/**\n * _DEPRECATED_ Specifies a `$centerSphere` condition\n *\n * **Deprecated.** Use [circle](https://mongoosejs.com/docs/api/query.html#Query.prototype.circle()) instead.\n *\n * #### Example:\n *\n *     const area = { center: [50, 50], radius: 10 };\n *     query.where('loc').within().centerSphere(area);\n *\n * @deprecated\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @see $centerSphere https://www.mongodb.com/docs/manual/reference/operator/centerSphere/\n * @api public\n */\n\nQuery.prototype.centerSphere = function() {\n  if (arguments[0] != null && typeof arguments[0].constructor === 'function' && arguments[0].constructor.name === 'Object') {\n    arguments[0].spherical = true;\n  }\n\n  if (arguments[1] != null && typeof arguments[1].constructor === 'function' && arguments[1].constructor.name === 'Object') {\n    arguments[1].spherical = true;\n  }\n\n  Query.base.circle.apply(this, arguments);\n};\n\n/**\n * Determines if field selection has been made.\n *\n * @method selected\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively(); // false\n *     query.select('name');\n *     query.selectedInclusively(); // true\n *\n * @method selectedInclusively\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selectedInclusively = function selectedInclusively() {\n  return isInclusive(this._fields);\n};\n\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExclusively(); // false\n *     query.select('-name');\n *     query.selectedExclusively(); // true\n *     query.selectedInclusively(); // false\n *\n * @method selectedExclusively\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selectedExclusively = function selectedExclusively() {\n  return isExclusive(this._fields);\n};\n\n/**\n * The model this query is associated with.\n *\n * #### Example:\n *\n *     const q = MyModel.find();\n *     q.model === MyModel; // true\n *\n * @api public\n * @property model\n * @memberOf Query\n * @instance\n */\n\nQuery.prototype.model;\n\n/*!\n * Export\n */\n\nmodule.exports = Query;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLDZFQUFjO0FBQ3hDLDhCQUE4QixtQkFBTyxDQUFDLHFGQUFrQjtBQUN4RCxlQUFlLG1CQUFPLENBQUMsNERBQVE7QUFDL0Isc0JBQXNCLG1CQUFPLENBQUMsK0ZBQXVCO0FBQ3JELDZCQUE2QixtQkFBTyxDQUFDLG1HQUF5QjtBQUM5RCxvQkFBb0IsbUJBQU8sQ0FBQyw2RkFBc0I7QUFDbEQsd0JBQXdCLG1CQUFPLENBQUMseUZBQW9CO0FBQ3BELFFBQVEsMkNBQTJDLEVBQUUsbUJBQU8sQ0FBQyx1SEFBbUM7QUFDaEcsb0NBQW9DLG1CQUFPLENBQUMsMklBQTZDO0FBQ3pGLDBCQUEwQixtQkFBTyxDQUFDLHlIQUFvQztBQUN0RSxhQUFhLG1CQUFPLENBQUMsaUVBQVE7QUFDN0IseUJBQXlCLG1CQUFPLENBQUMsdUhBQW1DO0FBQ3BFLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFlO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLHlHQUE0QjtBQUN2RCxjQUFjLG1CQUFPLENBQUMsbUZBQWlCO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLDZHQUE4QjtBQUMzRCxnQ0FBZ0MsbUJBQU8sQ0FBQyxtSkFBaUQ7QUFDekYsc0JBQXNCLG1CQUFPLENBQUMsK0dBQStCO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLGlGQUFnQjtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQywyRkFBcUI7QUFDL0MsZ0NBQWdDLHNIQUE0QztBQUM1RSxvQkFBb0IsbUJBQU8sQ0FBQyxxSEFBa0M7QUFDOUQsb0JBQW9CLG1CQUFPLENBQUMscUhBQWtDO0FBQzlELGdDQUFnQyxtQkFBTyxDQUFDLDZJQUE4QztBQUN0RixrQkFBa0IsbUJBQU8sQ0FBQyxpSEFBZ0M7QUFDMUQsY0FBYyxtQkFBTyxDQUFDLDBEQUFPO0FB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Q0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHF1ZXJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvY2FzdCcpO1xuY29uc3QgRG9jdW1lbnROb3RGb3VuZEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9ub3RGb3VuZCcpO1xuY29uc3QgS2FyZWVtID0gcmVxdWlyZSgna2FyZWVtJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBPYmplY3RQYXJhbWV0ZXJFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Ivb2JqZWN0UGFyYW1ldGVyJyk7XG5jb25zdCBRdWVyeUN1cnNvciA9IHJlcXVpcmUoJy4vY3Vyc29yL1F1ZXJ5Q3Vyc29yJyk7XG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3ZhbGlkYXRpb24nKTtcbmNvbnN0IHsgYXBwbHlHbG9iYWxNYXhUaW1lTVMsIGFwcGx5R2xvYmFsRGlza1VzZSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L2FwcGx5R2xvYmFsT3B0aW9uJyk7XG5jb25zdCBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzJyk7XG5jb25zdCBhcHBseVdyaXRlQ29uY2VybiA9IHJlcXVpcmUoJy4vaGVscGVycy9zY2hlbWEvYXBwbHlXcml0ZUNvbmNlcm4nKTtcbmNvbnN0IGNhc3QgPSByZXF1aXJlKCcuL2Nhc3QnKTtcbmNvbnN0IGNhc3RBcnJheUZpbHRlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMvdXBkYXRlL2Nhc3RBcnJheUZpbHRlcnMnKTtcbmNvbnN0IGNhc3ROdW1iZXIgPSByZXF1aXJlKCcuL2Nhc3QvbnVtYmVyJyk7XG5jb25zdCBjYXN0VXBkYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L2Nhc3RVcGRhdGUnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBjb21wbGV0ZU1hbnkgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvY29tcGxldGVNYW55Jyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBoYXNEb2xsYXJLZXlzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L2hhc0RvbGxhcktleXMnKTtcbmNvbnN0IGhlbHBlcnMgPSByZXF1aXJlKCcuL3F1ZXJ5aGVscGVycycpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3QgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IGlzRXhjbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNFeGNsdXNpdmUnKTtcbmNvbnN0IGlzSW5jbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNJbmNsdXNpdmUnKTtcbmNvbnN0IGlzUGF0aFNlbGVjdGVkSW5jbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUnKTtcbmNvbnN0IGlzU3VicGF0aCA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzU3VicGF0aCcpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3QgbXF1ZXJ5ID0gcmVxdWlyZSgnbXF1ZXJ5Jyk7XG5jb25zdCBwYXJzZVByb2plY3Rpb24gPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvamVjdGlvbi9wYXJzZVByb2plY3Rpb24nKTtcbmNvbnN0IHJlbW92ZVVudXNlZEFycmF5RmlsdGVycyA9IHJlcXVpcmUoJy4vaGVscGVycy91cGRhdGUvcmVtb3ZlVW51c2VkQXJyYXlGaWx0ZXJzJyk7XG5jb25zdCBzYW5pdGl6ZUZpbHRlciA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9zYW5pdGl6ZUZpbHRlcicpO1xuY29uc3Qgc2FuaXRpemVQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L3Nhbml0aXplUHJvamVjdGlvbicpO1xuY29uc3Qgc2VsZWN0UG9wdWxhdGVkRmllbGRzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L3NlbGVjdFBvcHVsYXRlZEZpZWxkcycpO1xuY29uc3Qgc2V0RGVmYXVsdHNPbkluc2VydCA9IHJlcXVpcmUoJy4vaGVscGVycy9zZXREZWZhdWx0c09uSW5zZXJ0Jyk7XG5jb25zdCB1cGRhdGVWYWxpZGF0b3JzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3VwZGF0ZVZhbGlkYXRvcnMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHZhbGlkT3BzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L3ZhbGlkT3BzJyk7XG5cbmNvbnN0IHF1ZXJ5T3B0aW9uTWV0aG9kcyA9IG5ldyBTZXQoW1xuICAnYWxsb3dEaXNrVXNlJyxcbiAgJ2JhdGNoU2l6ZScsXG4gICdjb2xsYXRpb24nLFxuICAnY29tbWVudCcsXG4gICdleHBsYWluJyxcbiAgJ2hpbnQnLFxuICAnaicsXG4gICdsZWFuJyxcbiAgJ2xpbWl0JyxcbiAgJ21heFRpbWVNUycsXG4gICdwb3B1bGF0ZScsXG4gICdwcm9qZWN0aW9uJyxcbiAgJ3JlYWQnLFxuICAnc2VsZWN0JyxcbiAgJ3NraXAnLFxuICAnc2xpY2UnLFxuICAnc29ydCcsXG4gICd0YWlsYWJsZScsXG4gICd3JyxcbiAgJ3dyaXRlQ29uY2VybicsXG4gICd3dGltZW91dCdcbl0pO1xuXG4vKipcbiAqIFF1ZXJ5IGNvbnN0cnVjdG9yIHVzZWQgZm9yIGJ1aWxkaW5nIHF1ZXJpZXMuIFlvdSBkbyBub3QgbmVlZFxuICogdG8gaW5zdGFudGlhdGUgYSBgUXVlcnlgIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBNb2RlbCBmdW5jdGlvbnMgbGlrZVxuICogW2BNb2RlbC5maW5kKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuZmluZCgpKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gTXlNb2RlbC5maW5kKCk7IC8vIGBxdWVyeWAgaXMgYW4gaW5zdGFuY2Ugb2YgYFF1ZXJ5YFxuICogICAgIHF1ZXJ5LnNldE9wdGlvbnMoeyBsZWFuIDogdHJ1ZSB9KTtcbiAqICAgICBxdWVyeS5jb2xsZWN0aW9uKE15TW9kZWwuY29sbGVjdGlvbik7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2FnZScpLmd0ZSgyMSkuZXhlYyhjYWxsYmFjayk7XG4gKlxuICogICAgIC8vIFlvdSBjYW4gaW5zdGFudGlhdGUgYSBxdWVyeSBkaXJlY3RseS4gVGhlcmUgaXMgbm8gbmVlZCB0byBkb1xuICogICAgIC8vIHRoaXMgdW5sZXNzIHlvdSdyZSBhbiBhZHZhbmNlZCB1c2VyIHdpdGggYSB2ZXJ5IGdvb2QgcmVhc29uIHRvLlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IG1vbmdvb3NlLlF1ZXJ5KCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtPYmplY3R9IFttb2RlbF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZGl0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29sbGVjdGlvbl0gTW9uZ29vc2UgY29sbGVjdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBRdWVyeShjb25kaXRpb25zLCBvcHRpb25zLCBtb2RlbCwgY29sbGVjdGlvbikge1xuICAvLyB0aGlzIHN0dWZmIGlzIGZvciBkZWFsaW5nIHdpdGggY3VzdG9tIHF1ZXJpZXMgY3JlYXRlZCBieSAjdG9Db25zdHJ1Y3RvclxuICBpZiAoIXRoaXMuX21vbmdvb3NlT3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucyA9IHt9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRoaXMuX3RyYW5zZm9ybXMgPSBbXTtcbiAgdGhpcy5faG9va3MgPSBuZXcgS2FyZWVtKCk7XG4gIHRoaXMuX2V4ZWN1dGlvblN0YWNrID0gbnVsbDtcblxuICAvLyB0aGlzIGlzIHRoZSBjYXNlIHdoZXJlIHdlIGhhdmUgYSBDdXN0b21RdWVyeSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBnb3RcbiAgLy8gb3B0aW9ucyBwYXNzZWQgaW4sIGFuZCBpZiB3ZSBkaWQsIG1lcmdlIHRoZW0gaW5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cblxuICBpZiAoY29sbGVjdGlvbikge1xuICAgIHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgfVxuXG4gIGlmIChtb2RlbCkge1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB0aGlzLnNjaGVtYSA9IG1vZGVsLnNjaGVtYTtcbiAgfVxuXG4gIC8vIHRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgbWFwIHJlZHVjZSByZXR1cm5zIGEgbW9kZWwgdGhhdCBjYW4gYmUgcXVlcmllZCwgYnV0XG4gIC8vIGFsbCBvZiB0aGUgcXVlcmllcyBvbiBzYWlkIG1vZGVsIHNob3VsZCBiZSBsZWFuXG4gIGlmICh0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwuX21hcHJlZHVjZSkge1xuICAgIHRoaXMubGVhbigpO1xuICB9XG5cbiAgLy8gaW5oZXJpdCBtcXVlcnlcbiAgbXF1ZXJ5LmNhbGwodGhpcywgbnVsbCwgb3B0aW9ucyk7XG4gIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgdGhpcy5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICB9XG5cbiAgaWYgKGNvbmRpdGlvbnMpIHtcbiAgICB0aGlzLmZpbmQoY29uZGl0aW9ucyk7XG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG5cbiAgLy8gRm9yIGdoLTY4ODAuIG1xdWVyeSBzdGlsbCBuZWVkcyB0byBzdXBwb3J0IGBmaWVsZHNgIGJ5IGRlZmF1bHQgZm9yIG9sZFxuICAvLyB2ZXJzaW9ucyBvZiBNb25nb0RCXG4gIHRoaXMuJHVzZVByb2plY3Rpb24gPSB0cnVlO1xuXG4gIGNvbnN0IGNvbGxhdGlvbiA9IHRoaXMgJiZcbiAgICB0aGlzLnNjaGVtYSAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zLmNvbGxhdGlvbiB8fCBudWxsO1xuICBpZiAoY29sbGF0aW9uICE9IG51bGwpIHtcbiAgICB0aGlzLm9wdGlvbnMuY29sbGF0aW9uID0gY29sbGF0aW9uO1xuICB9XG59XG5cbi8qIVxuICogaW5oZXJpdCBtcXVlcnlcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUgPSBuZXcgbXF1ZXJ5KCk7XG5RdWVyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRdWVyeTtcblF1ZXJ5LmJhc2UgPSBtcXVlcnkucHJvdG90eXBlO1xuXG4vKiFcbiAqIE92ZXJ3cml0ZSBtcXVlcnkncyBgX2Rpc3RpbmN0YCwgYmVjYXVzZSBNb25nb29zZSB1c2VzIHRoYXQgbmFtZVxuICogdG8gc3RvcmUgdGhlIGZpZWxkIHRvIGFwcGx5IGRpc3RpbmN0IG9uLlxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeS5wcm90b3R5cGUsICdfZGlzdGluY3QnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiB1bmRlZmluZWRcbn0pO1xuXG4vKipcbiAqIEZsYWcgdG8gb3B0IG91dCBvZiB1c2luZyBgJGdlb1dpdGhpbmAuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogbW9uZ29vc2UuUXVlcnkudXNlJGdlb1dpdGhpbiA9IGZhbHNlO1xuICogYGBgXG4gKlxuICogTW9uZ29EQiAyLjQgZGVwcmVjYXRlZCB0aGUgdXNlIG9mIGAkd2l0aGluYCwgcmVwbGFjaW5nIGl0IHdpdGggYCRnZW9XaXRoaW5gLiBNb25nb29zZSB1c2VzIGAkZ2VvV2l0aGluYCBieSBkZWZhdWx0ICh3aGljaCBpcyAxMDAlIGJhY2t3YXJkIGNvbXBhdGlibGUgd2l0aCBgJHdpdGhpbmApLiBJZiB5b3UgYXJlIHJ1bm5pbmcgYW4gb2xkZXIgdmVyc2lvbiBvZiBNb25nb0RCLCBzZXQgdGhpcyBmbGFnIHRvIGBmYWxzZWAgc28geW91ciBgd2l0aGluKClgIHF1ZXJpZXMgY29udGludWUgdG8gd29yay5cbiAqXG4gKiBAc2VlIGdlb1dpdGhpbiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ2VvV2l0aGluL1xuICogQGRlZmF1bHQgdHJ1ZVxuICogQHByb3BlcnR5IHVzZSRnZW9XaXRoaW5cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS51c2UkZ2VvV2l0aGluID0gbXF1ZXJ5LnVzZSRnZW9XaXRoaW47XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBxdWVyeSB0byBhIGN1c3RvbWl6ZWQsIHJldXNhYmxlIHF1ZXJ5IGNvbnN0cnVjdG9yIHdpdGggYWxsIGFyZ3VtZW50cyBhbmQgb3B0aW9ucyByZXRhaW5lZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIENyZWF0ZSBhIHF1ZXJ5IGZvciBhZHZlbnR1cmUgbW92aWVzIGFuZCByZWFkIGZyb20gdGhlIHByaW1hcnlcbiAqICAgICAvLyBub2RlIGluIHRoZSByZXBsaWNhLXNldCB1bmxlc3MgaXQgaXMgZG93biwgaW4gd2hpY2ggY2FzZSB3ZSdsbFxuICogICAgIC8vIHJlYWQgZnJvbSBhIHNlY29uZGFyeSBub2RlLlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gTW92aWUuZmluZCh7IHRhZ3M6ICdhZHZlbnR1cmUnIH0pLnJlYWQoJ3ByaW1hcnlQcmVmZXJyZWQnKTtcbiAqXG4gKiAgICAgLy8gY3JlYXRlIGEgY3VzdG9tIFF1ZXJ5IGNvbnN0cnVjdG9yIGJhc2VkIG9mZiB0aGVzZSBzZXR0aW5nc1xuICogICAgIGNvbnN0IEFkdmVudHVyZSA9IHF1ZXJ5LnRvQ29uc3RydWN0b3IoKTtcbiAqXG4gKiAgICAgLy8gZnVydGhlciBuYXJyb3cgZG93biBvdXIgcXVlcnkgcmVzdWx0cyB3aGlsZSBzdGlsbCB1c2luZyB0aGUgcHJldmlvdXMgc2V0dGluZ3NcbiAqICAgICBhd2FpdCBBZHZlbnR1cmUoKS53aGVyZSh7IG5hbWU6IC9eTGlmZS8gfSkuZXhlYygpO1xuICpcbiAqICAgICAvLyBzaW5jZSBBZHZlbnR1cmUgaXMgYSBzdGFuZC1hbG9uZSBjb25zdHJ1Y3RvciB3ZSBjYW4gYWxzbyBhZGQgb3VyIG93blxuICogICAgIC8vIGhlbHBlciBtZXRob2RzIGFuZCBnZXR0ZXJzIHdpdGhvdXQgaW1wYWN0aW5nIGdsb2JhbCBxdWVyaWVzXG4gKiAgICAgQWR2ZW50dXJlLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICogICAgICAgdGhpcy53aGVyZSh7IG5hbWU6IG5ldyBSZWdFeHAoJ14nICsgcHJlZml4KSB9KVxuICogICAgICAgcmV0dXJuIHRoaXM7XG4gKiAgICAgfVxuICogICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBZHZlbnR1cmUucHJvdG90eXBlLCAnaGlnaGx5UmF0ZWQnLCB7XG4gKiAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgdGhpcy53aGVyZSh7IHJhdGluZzogeyAkZ3Q6IDQuNSB9fSk7XG4gKiAgICAgICAgIHJldHVybiB0aGlzO1xuICogICAgICAgfVxuICogICAgIH0pXG4gKiAgICAgYXdhaXQgQWR2ZW50dXJlKCkuaGlnaGx5UmF0ZWQuc3RhcnRzV2l0aCgnTGlmZScpLmV4ZWMoKTtcbiAqXG4gKiBAcmV0dXJuIHtRdWVyeX0gc3ViY2xhc3Mtb2YtUXVlcnlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnRvQ29uc3RydWN0b3IgPSBmdW5jdGlvbiB0b0NvbnN0cnVjdG9yKCkge1xuICBjb25zdCBtb2RlbCA9IHRoaXMubW9kZWw7XG4gIGNvbnN0IGNvbGwgPSB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbjtcblxuICBjb25zdCBDdXN0b21RdWVyeSA9IGZ1bmN0aW9uKGNyaXRlcmlhLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbVF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIG5ldyBDdXN0b21RdWVyeShjcml0ZXJpYSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucyA9IGNsb25lKHAuX21vbmdvb3NlT3B0aW9ucyk7XG4gICAgUXVlcnkuY2FsbCh0aGlzLCBjcml0ZXJpYSwgb3B0aW9ucyB8fCBudWxsLCBtb2RlbCwgY29sbCk7XG4gIH07XG5cbiAgdXRpbC5pbmhlcml0cyhDdXN0b21RdWVyeSwgbW9kZWwuUXVlcnkpO1xuXG4gIC8vIHNldCBpbmhlcml0ZWQgZGVmYXVsdHNcbiAgY29uc3QgcCA9IEN1c3RvbVF1ZXJ5LnByb3RvdHlwZTtcblxuICBwLm9wdGlvbnMgPSB7fTtcblxuICAvLyBOZWVkIHRvIGhhbmRsZSBgc29ydCgpYCBzZXBhcmF0ZWx5IGJlY2F1c2UgZW50cmllcy1zdHlsZSBgc29ydCgpYCBzeW50YXhcbiAgLy8gYHNvcnQoW1sncHJvcDEnLCAxXV0pYCBjb25mdXNlcyBtcXVlcnkgaW50byBsb3NpbmcgdGhlIG91dGVyIG5lc3RlZCBhcnJheS5cbiAgLy8gU2VlIGdoLTgxNTlcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLnNvcnQgIT0gbnVsbCkge1xuICAgIHAuc29ydChvcHRpb25zLnNvcnQpO1xuICAgIGRlbGV0ZSBvcHRpb25zLnNvcnQ7XG4gIH1cbiAgcC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHAub3AgPSB0aGlzLm9wO1xuICBwLl92YWxpZGF0ZU9wKCk7XG4gIHAuX2NvbmRpdGlvbnMgPSBjbG9uZSh0aGlzLl9jb25kaXRpb25zKTtcbiAgcC5fZmllbGRzID0gY2xvbmUodGhpcy5fZmllbGRzKTtcbiAgcC5fdXBkYXRlID0gY2xvbmUodGhpcy5fdXBkYXRlLCB7XG4gICAgZmxhdHRlbkRlY2ltYWxzOiBmYWxzZVxuICB9KTtcbiAgcC5fcGF0aCA9IHRoaXMuX3BhdGg7XG4gIHAuX2Rpc3RpbmN0ID0gdGhpcy5fZGlzdGluY3Q7XG4gIHAuX2NvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICBwLl9tb25nb29zZU9wdGlvbnMgPSB0aGlzLl9tb25nb29zZU9wdGlvbnM7XG5cbiAgcmV0dXJuIEN1c3RvbVF1ZXJ5O1xufTtcblxuLyoqXG4gKiBNYWtlIGEgY29weSBvZiB0aGlzIHF1ZXJ5IHNvIHlvdSBjYW4gcmUtZXhlY3V0ZSBpdC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHEgPSBCb29rLmZpbmRPbmUoeyB0aXRsZTogJ0Nhc2lubyBSb3lhbGUnIH0pO1xuICogICAgIGF3YWl0IHEuZXhlYygpO1xuICogICAgIGF3YWl0IHEuZXhlYygpOyAvLyBUaHJvd3MgYW4gZXJyb3IgYmVjYXVzZSB5b3UgY2FuJ3QgZXhlY3V0ZSBhIHF1ZXJ5IHR3aWNlXG4gKlxuICogICAgIGF3YWl0IHEuY2xvbmUoKS5leGVjKCk7IC8vIFdvcmtzXG4gKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHJldHVybiB7UXVlcnl9IGNvcHlcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBtb2RlbCA9IHRoaXMubW9kZWw7XG4gIGNvbnN0IGNvbGxlY3Rpb24gPSB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbjtcblxuICBjb25zdCBxID0gbmV3IHRoaXMubW9kZWwuUXVlcnkoe30sIHt9LCBtb2RlbCwgY29sbGVjdGlvbik7XG5cbiAgLy8gTmVlZCB0byBoYW5kbGUgYHNvcnQoKWAgc2VwYXJhdGVseSBiZWNhdXNlIGVudHJpZXMtc3R5bGUgYHNvcnQoKWAgc3ludGF4XG4gIC8vIGBzb3J0KFtbJ3Byb3AxJywgMV1dKWAgY29uZnVzZXMgbXF1ZXJ5IGludG8gbG9zaW5nIHRoZSBvdXRlciBuZXN0ZWQgYXJyYXkuXG4gIC8vIFNlZSBnaC04MTU5XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5zb3J0ICE9IG51bGwpIHtcbiAgICBxLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgICBkZWxldGUgb3B0aW9ucy5zb3J0O1xuICB9XG4gIHEuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICBxLm9wID0gdGhpcy5vcDtcbiAgcS5fdmFsaWRhdGVPcCgpO1xuICBxLl9jb25kaXRpb25zID0gY2xvbmUodGhpcy5fY29uZGl0aW9ucyk7XG4gIHEuX2ZpZWxkcyA9IGNsb25lKHRoaXMuX2ZpZWxkcyk7XG4gIHEuX3VwZGF0ZSA9IGNsb25lKHRoaXMuX3VwZGF0ZSwge1xuICAgIGZsYXR0ZW5EZWNpbWFsczogZmFsc2VcbiAgfSk7XG4gIHEuX3BhdGggPSB0aGlzLl9wYXRoO1xuICBxLl9kaXN0aW5jdCA9IHRoaXMuX2Rpc3RpbmN0O1xuICBxLl9jb2xsZWN0aW9uID0gdGhpcy5fY29sbGVjdGlvbjtcbiAgcS5fbW9uZ29vc2VPcHRpb25zID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zO1xuXG4gIHJldHVybiBxO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBqYXZhc2NyaXB0IGZ1bmN0aW9uIG9yIGV4cHJlc3Npb24gdG8gcGFzcyB0byBNb25nb0RCcyBxdWVyeSBzeXN0ZW0uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS4kd2hlcmUoJ3RoaXMuY29tbWVudHMubGVuZ3RoID09PSAxMCB8fCB0aGlzLm5hbWUubGVuZ3RoID09PSA1JylcbiAqXG4gKiAgICAgLy8gb3JcbiAqXG4gKiAgICAgcXVlcnkuJHdoZXJlKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHJldHVybiB0aGlzLmNvbW1lbnRzLmxlbmd0aCA9PT0gMTAgfHwgdGhpcy5uYW1lLmxlbmd0aCA9PT0gNTtcbiAqICAgICB9KVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBPbmx5IHVzZSBgJHdoZXJlYCB3aGVuIHlvdSBoYXZlIGEgY29uZGl0aW9uIHRoYXQgY2Fubm90IGJlIG1ldCB1c2luZyBvdGhlciBNb25nb0RCIG9wZXJhdG9ycyBsaWtlIGAkbHRgLlxuICogKipCZSBzdXJlIHRvIHJlYWQgYWJvdXQgYWxsIG9mIFtpdHMgY2F2ZWF0c10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3doZXJlLykgYmVmb3JlIHVzaW5nLioqXG4gKlxuICogQHNlZSAkd2hlcmUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3doZXJlL1xuICogQG1ldGhvZCAkd2hlcmVcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBqcyBqYXZhc2NyaXB0IHN0cmluZyBvciBmdW5jdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAbWV0aG9kICR3aGVyZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGBwYXRoYCBmb3IgdXNlIHdpdGggY2hhaW5pbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBpbnN0ZWFkIG9mIHdyaXRpbmc6XG4gKiAgICAgVXNlci5maW5kKHthZ2U6IHskZ3RlOiAyMSwgJGx0ZTogNjV9fSk7XG4gKlxuICogICAgIC8vIHdlIGNhbiBpbnN0ZWFkIHdyaXRlOlxuICogICAgIFVzZXIud2hlcmUoJ2FnZScpLmd0ZSgyMSkubHRlKDY1KTtcbiAqXG4gKiAgICAgLy8gcGFzc2luZyBxdWVyeSBjb25kaXRpb25zIGlzIHBlcm1pdHRlZFxuICogICAgIFVzZXIuZmluZCgpLndoZXJlKHsgbmFtZTogJ3ZvbmRlcmZ1bCcgfSlcbiAqXG4gKiAgICAgLy8gY2hhaW5pbmdcbiAqICAgICBVc2VyXG4gKiAgICAgLndoZXJlKCdhZ2UnKS5ndGUoMjEpLmx0ZSg2NSlcbiAqICAgICAud2hlcmUoJ25hbWUnLCAvXnZvbmRlcmZ1bC9pKVxuICogICAgIC53aGVyZSgnZnJpZW5kcycpLnNsaWNlKDEwKVxuICogICAgIC5leGVjKClcbiAqXG4gKiBAbWV0aG9kIHdoZXJlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBbcGF0aF1cbiAqIEBwYXJhbSB7YW55fSBbdmFsXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJHNsaWNlYCBwcm9qZWN0aW9uIGZvciBhbiBhcnJheS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnNsaWNlKCdjb21tZW50cycsIDUpOyAvLyBSZXR1cm5zIHRoZSBmaXJzdCA1IGNvbW1lbnRzXG4gKiAgICAgcXVlcnkuc2xpY2UoJ2NvbW1lbnRzJywgLTUpOyAvLyBSZXR1cm5zIHRoZSBsYXN0IDUgY29tbWVudHNcbiAqICAgICBxdWVyeS5zbGljZSgnY29tbWVudHMnLCBbMTAsIDVdKTsgLy8gUmV0dXJucyB0aGUgZmlyc3QgNSBjb21tZW50cyBhZnRlciB0aGUgMTAtdGhcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudHMnKS5zbGljZSg1KTsgLy8gUmV0dXJucyB0aGUgZmlyc3QgNSBjb21tZW50c1xuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50cycpLnNsaWNlKFstMTAsIDVdKTsgLy8gUmV0dXJucyB0aGUgZmlyc3QgNSBjb21tZW50cyBhZnRlciB0aGUgMTAtdGggdG8gbGFzdFxuICpcbiAqICoqTm90ZToqKiBJZiB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBiZSBzbGljZWQgaXMgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LCBhbGwgYXJyYXkgZWxlbWVudHMgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiAgICAgIC8vIEdpdmVuIGBhcnJgOiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdXG4gKiAgICAgIHF1ZXJ5LnNsaWNlKCdhcnInLCAyMCk7IC8vIFJldHVybnMgWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXVxuICogICAgICBxdWVyeS5zbGljZSgnYXJyJywgLTIwKTsgLy8gUmV0dXJucyBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdXG4gKlxuICogKipOb3RlOioqIElmIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBpcyBwb3NpdGl2ZSBhbmQgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LCBhbiBlbXB0eSBhcnJheSB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqICAgICAgLy8gR2l2ZW4gYGFycmA6IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF1cbiAqICAgICAgcXVlcnkuc2xpY2UoJ2FycicsIFsyMCwgNV0pOyAvLyBSZXR1cm5zIFtdXG4gKlxuICogKipOb3RlOioqIElmIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBpcyBuZWdhdGl2ZSBhbmQgaXRzIGFic29sdXRlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheSwgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGlzIHRoZSBzdGFydCBvZiB0aGUgYXJyYXkuXG4gKlxuICogICAgICAvLyBHaXZlbiBgYXJyYDogWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXVxuICogICAgICBxdWVyeS5zbGljZSgnYXJyJywgWy0yMCwgNV0pOyAvLyBSZXR1cm5zIFsxLCAyLCAzLCA0LCA1XVxuICpcbiAqIEBtZXRob2Qgc2xpY2VcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcnxBcnJheX0gdmFsIG51bWJlciBvZiBlbGVtZW50cyB0byBzbGljZSBvciBhcnJheSB3aXRoIG51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGFuZCBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2xpY2VcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvdHV0b3JpYWwvcXVlcnktZG9jdW1lbnRzLyNwcm9qZWN0aW9uXG4gKiBAc2VlICRzbGljZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvcHJvamVjdGlvbi9zbGljZS8jcHJqLl9TX3NsaWNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fdmFsaWRhdGUoJ3NsaWNlJyk7XG5cbiAgbGV0IHBhdGg7XG4gIGxldCB2YWw7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBhcmcgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICAgICAgdGhpcy5zbGljZShrZXlzW2ldLCBhcmdba2V5c1tpXV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ3NsaWNlJyk7XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBhcmd1bWVudHNbMF0pIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ3NsaWNlJyk7XG4gICAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICAgIHZhbCA9IFthcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbCA9IFthcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXV07XG4gIH1cblxuICBjb25zdCBwID0ge307XG4gIHBbcGF0aF0gPSB7ICRzbGljZTogdmFsIH07XG4gIHRoaXMuc2VsZWN0KHApO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCB2YWxpZE9wc1NldCA9IG5ldyBTZXQodmFsaWRPcHMpO1xuXG5RdWVyeS5wcm90b3R5cGUuX3ZhbGlkYXRlT3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3AgIT0gbnVsbCAmJiAhdmFsaWRPcHNTZXQuaGFzKHRoaXMub3ApKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ1F1ZXJ5IGhhcyBpbnZhbGlkIGBvcGA6IFwiJyArIHRoaXMub3AgKyAnXCInKSk7XG4gIH1cbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBjb21wbGVtZW50YXJ5IGNvbXBhcmlzb24gdmFsdWUgZm9yIHBhdGhzIHNwZWNpZmllZCB3aXRoIGB3aGVyZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZXF1YWxzKDQ5KTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJywgNDkpO1xuICpcbiAqIEBtZXRob2QgZXF1YWxzXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYXJndW1lbnRzIGZvciBhbiBgJG9yYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5vcihbeyBjb2xvcjogJ3JlZCcgfSwgeyBzdGF0dXM6ICdlbWVyZ2VuY3knIH1dKTtcbiAqXG4gKiBAc2VlICRvciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivb3IvXG4gKiBAbWV0aG9kIG9yXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgb2YgY29uZGl0aW9uc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYXJndW1lbnRzIGZvciBhIGAkbm9yYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5ub3IoW3sgY29sb3I6ICdncmVlbicgfSwgeyBzdGF0dXM6ICdvaycgfV0pO1xuICpcbiAqIEBzZWUgJG5vciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivbm9yL1xuICogQG1ldGhvZCBub3JcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhcnJheSBvZiBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhcmd1bWVudHMgZm9yIGEgYCRhbmRgIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmFuZChbeyBjb2xvcjogJ2dyZWVuJyB9LCB7IHN0YXR1czogJ29rJyB9XSlcbiAqXG4gKiBAbWV0aG9kIGFuZFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBzZWUgJGFuZCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYW5kL1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgb2YgY29uZGl0aW9uc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGd0YCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFRoaW5nLmZpbmQoKS53aGVyZSgnYWdlJykuZ3QoMjEpO1xuICpcbiAqICAgICAvLyBvclxuICogICAgIFRoaW5nLmZpbmQoKS5ndCgnYWdlJywgMjEpO1xuICpcbiAqIEBtZXRob2QgZ3RcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlICRndCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ3QvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRndGVgIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgZ3RlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSAkZ3RlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9ndGUvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRsdGAgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBsdFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgJGx0IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9sdC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGx0ZWAgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBsdGVcbiAqIEBzZWUgJGx0ZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbHRlL1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJG5lYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRuZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbmUvXG4gKiBAbWV0aG9kIG5lXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHthbnl9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiBgJGluYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRpbiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvaW4vXG4gKiBAbWV0aG9kIGluXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtBcnJheX0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkbmluYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRuaW4gaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL25pbi9cbiAqIEBtZXRob2QgbmluXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtBcnJheX0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkYWxsYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE15TW9kZWwuZmluZCgpLndoZXJlKCdwZXRzJykuYWxsKFsnZG9nJywgJ2NhdCcsICdmZXJyZXQnXSk7XG4gKiAgICAgLy8gRXF1aXZhbGVudDpcbiAqICAgICBNeU1vZGVsLmZpbmQoKS5hbGwoJ3BldHMnLCBbJ2RvZycsICdjYXQnLCAnZmVycmV0J10pO1xuICpcbiAqIEBzZWUgJGFsbCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWxsL1xuICogQG1ldGhvZCBhbGxcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge0FycmF5fSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJHNpemVgIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jcyA9IGF3YWl0IE15TW9kZWwud2hlcmUoJ3RhZ3MnKS5zaXplKDApLmV4ZWMoKTtcbiAqICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShkb2NzKSk7XG4gKiAgICAgY29uc29sZS5sb2coJ2RvY3VtZW50cyB3aXRoIDAgdGFncycsIGRvY3MpO1xuICpcbiAqIEBzZWUgJHNpemUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3NpemUvXG4gKiBAbWV0aG9kIHNpemVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRyZWdleGAgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQHNlZSAkcmVnZXggaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3JlZ2V4L1xuICogQG1ldGhvZCByZWdleFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYG1heERpc3RhbmNlYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRtYXhEaXN0YW5jZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWF4RGlzdGFuY2UvXG4gKiBAbWV0aG9kIG1heERpc3RhbmNlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkbW9kYCBjb25kaXRpb24sIGZpbHRlcnMgZG9jdW1lbnRzIGZvciBkb2N1bWVudHMgd2hvc2VcbiAqIGBwYXRoYCBwcm9wZXJ0eSBpcyBhIG51bWJlciB0aGF0IGlzIGVxdWFsIHRvIGByZW1haW5kZXJgIG1vZHVsbyBgZGl2aXNvcmAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbGwgZmluZCBwcm9kdWN0cyB3aG9zZSBpbnZlbnRvcnkgaXMgb2RkXG4gKiAgICAgUHJvZHVjdC5maW5kKCkubW9kKCdpbnZlbnRvcnknLCBbMiwgMV0pO1xuICogICAgIFByb2R1Y3QuZmluZCgpLndoZXJlKCdpbnZlbnRvcnknKS5tb2QoWzIsIDFdKTtcbiAqICAgICAvLyBUaGlzIHN5bnRheCBpcyBhIGxpdHRsZSBzdHJhbmdlLCBidXQgc3VwcG9ydGVkLlxuICogICAgIFByb2R1Y3QuZmluZCgpLndoZXJlKCdpbnZlbnRvcnknKS5tb2QoMiwgMSk7XG4gKlxuICogQG1ldGhvZCBtb2RcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge0FycmF5fSB2YWwgbXVzdCBiZSBvZiBsZW5ndGggMiwgZmlyc3QgZWxlbWVudCBpcyBgZGl2aXNvcmAsIDJuZCBlbGVtZW50IGlzIGByZW1haW5kZXJgLlxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgJG1vZCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbW9kL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24oKSB7XG4gIGxldCB2YWw7XG4gIGxldCBwYXRoO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnbW9kJyk7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzFdKSkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ21vZCcpO1xuICAgIHZhbCA9IFthcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXV07XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhbCA9IFthcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXV07XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHMuJG1vZCA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiBgJGV4aXN0c2AgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyB7IG5hbWU6IHsgJGV4aXN0czogdHJ1ZSB9fVxuICogICAgIFRoaW5nLndoZXJlKCduYW1lJykuZXhpc3RzKClcbiAqICAgICBUaGluZy53aGVyZSgnbmFtZScpLmV4aXN0cyh0cnVlKVxuICogICAgIFRoaW5nLmZpbmQoKS5leGlzdHMoJ25hbWUnKVxuICpcbiAqICAgICAvLyB7IG5hbWU6IHsgJGV4aXN0czogZmFsc2UgfX1cbiAqICAgICBUaGluZy53aGVyZSgnbmFtZScpLmV4aXN0cyhmYWxzZSk7XG4gKiAgICAgVGhpbmcuZmluZCgpLmV4aXN0cygnbmFtZScsIGZhbHNlKTtcbiAqXG4gKiBAbWV0aG9kIGV4aXN0c1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSAkZXhpc3RzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9leGlzdHMvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkZWxlbU1hdGNoYCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmVsZW1NYXRjaCgnY29tbWVudCcsIHsgYXV0aG9yOiAnYXV0b2JvdCcsIHZvdGVzOiB7JGd0ZTogNX19KVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudCcpLmVsZW1NYXRjaCh7IGF1dGhvcjogJ2F1dG9ib3QnLCB2b3RlczogeyRndGU6IDV9fSlcbiAqXG4gKiAgICAgcXVlcnkuZWxlbU1hdGNoKCdjb21tZW50JywgZnVuY3Rpb24gKGVsZW0pIHtcbiAqICAgICAgIGVsZW0ud2hlcmUoJ2F1dGhvcicpLmVxdWFscygnYXV0b2JvdCcpO1xuICogICAgICAgZWxlbS53aGVyZSgndm90ZXMnKS5ndGUoNSk7XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnQnKS5lbGVtTWF0Y2goZnVuY3Rpb24gKGVsZW0pIHtcbiAqICAgICAgIGVsZW0ud2hlcmUoeyBhdXRob3I6ICdhdXRvYm90JyB9KTtcbiAqICAgICAgIGVsZW0ud2hlcmUoJ3ZvdGVzJykuZ3RlKDUpO1xuICogICAgIH0pXG4gKlxuICogQG1ldGhvZCBlbGVtTWF0Y2hcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBmaWx0ZXJcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRlbGVtTWF0Y2ggaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2VsZW1NYXRjaC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBEZWZpbmVzIGEgYCR3aXRoaW5gIG9yIGAkZ2VvV2l0aGluYCBhcmd1bWVudCBmb3IgZ2VvLXNwYXRpYWwgcXVlcmllcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKHBhdGgpLndpdGhpbigpLmJveCgpXG4gKiAgICAgcXVlcnkud2hlcmUocGF0aCkud2l0aGluKCkuY2lyY2xlKClcbiAqICAgICBxdWVyeS53aGVyZShwYXRoKS53aXRoaW4oKS5nZW9tZXRyeSgpXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBjZW50ZXI6IFs1MCw1MF0sIHJhZGl1czogMTAsIHVuaXF1ZTogdHJ1ZSwgc3BoZXJpY2FsOiB0cnVlIH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBib3g6IFtbNDAuNzMsIC03My45XSwgWzQwLjcsIC03My45ODhdXSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKHsgcG9seWdvbjogW1tdLFtdLFtdLFtdXSB9KTtcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbihbXSwgW10sIFtdKSAvLyBwb2x5Z29uXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbihbXSwgW10pIC8vIGJveFxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyB0eXBlOiAnTGluZVN0cmluZycsIGNvb3JkaW5hdGVzOiBbLi4uXSB9KTsgLy8gZ2VvbWV0cnlcbiAqXG4gKiAqKk1VU1QqKiBiZSB1c2VkIGFmdGVyIGB3aGVyZSgpYC5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQXMgb2YgTW9uZ29vc2UgMy43LCBgJGdlb1dpdGhpbmAgaXMgYWx3YXlzIHVzZWQgZm9yIHF1ZXJpZXMuIFRvIGNoYW5nZSB0aGlzIGJlaGF2aW9yLCBzZWUgW1F1ZXJ5LnVzZSRnZW9XaXRoaW5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUudXNlJGdlb1dpdGhpbikuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIEluIE1vbmdvb3NlIDMuNywgYHdpdGhpbmAgY2hhbmdlZCBmcm9tIGEgZ2V0dGVyIHRvIGEgZnVuY3Rpb24uIElmIHlvdSBuZWVkIHRoZSBvbGQgc3ludGF4LCB1c2UgW3RoaXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9lYmVuc2luZy9tb25nb29zZS13aXRoaW4pLlxuICpcbiAqIEBtZXRob2Qgd2l0aGluXG4gKiBAc2VlICRwb2x5Z29uIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9wb2x5Z29uL1xuICogQHNlZSAkYm94IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9ib3gvXG4gKiBAc2VlICRnZW9tZXRyeSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ2VvbWV0cnkvXG4gKiBAc2VlICRjZW50ZXIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2NlbnRlci9cbiAqIEBzZWUgJGNlbnRlclNwaGVyZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvY2VudGVyU3BoZXJlL1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkb2N1bWVudHMgdGhlIHF1ZXJ5IHdpbGwgcmV0dXJuLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkubGltaXQoMjApO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgbGltaXRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5saW1pdCA9IGZ1bmN0aW9uIGxpbWl0KHYpIHtcbiAgdGhpcy5fdmFsaWRhdGUoJ2xpbWl0Jyk7XG5cbiAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICB2ID0gY2FzdE51bWJlcih2KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ051bWJlcicsIHYsICdsaW1pdCcpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub3B0aW9ucy5saW1pdCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgdG8gc2tpcC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnNraXAoMTAwKS5saW1pdCgyMCk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBza2lwXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSBjdXJzb3Iuc2tpcCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5za2lwL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAodikge1xuICB0aGlzLl92YWxpZGF0ZSgnc2tpcCcpO1xuXG4gIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgdiA9IGNhc3ROdW1iZXIodik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdOdW1iZXInLCB2LCAnc2tpcCcpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub3B0aW9ucy5za2lwID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYmF0Y2hTaXplIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmJhdGNoU2l6ZSgxMDApXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBiYXRjaFNpemVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlIGJhdGNoU2l6ZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5iYXRjaFNpemUvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBgY29tbWVudGAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuY29tbWVudCgnbG9naW4gcXVlcnknKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgY29tbWVudFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEBzZWUgY29tbWVudCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvY29tbWVudC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTZXRzIHF1ZXJ5IGhpbnRzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuaGludCh7IGluZGV4QTogMSwgaW5kZXhCOiAtMSB9KTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIGhpbnRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIGEgaGludCBvYmplY3RcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRoaW50IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9oaW50L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGN1cnJlbnQgcHJvamVjdGlvbiAoQUtBIGZpZWxkcykuIFBhc3MgYG51bGxgIHRvIHJlbW92ZSB0aGVcbiAqIGN1cnJlbnQgcHJvamVjdGlvbi5cbiAqXG4gKiBVbmxpa2UgYHByb2plY3Rpb24oKWAsIHRoZSBgc2VsZWN0KClgIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZSBjdXJyZW50XG4gKiBwcm9qZWN0aW9uIGluIHBsYWNlLiBUaGlzIGZ1bmN0aW9uIG92ZXJ3cml0ZXMgdGhlIGV4aXN0aW5nIHByb2plY3Rpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxID0gTW9kZWwuZmluZCgpO1xuICogICAgIHEucHJvamVjdGlvbigpOyAvLyBudWxsXG4gKlxuICogICAgIHEuc2VsZWN0KCdhIGInKTtcbiAqICAgICBxLnByb2plY3Rpb24oKTsgLy8geyBhOiAxLCBiOiAxIH1cbiAqXG4gKiAgICAgcS5wcm9qZWN0aW9uKHsgYzogMSB9KTtcbiAqICAgICBxLnByb2plY3Rpb24oKTsgLy8geyBjOiAxIH1cbiAqXG4gKiAgICAgcS5wcm9qZWN0aW9uKG51bGwpO1xuICogICAgIHEucHJvamVjdGlvbigpOyAvLyBudWxsXG4gKlxuICpcbiAqIEBtZXRob2QgcHJvamVjdGlvblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGFyZ1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY3VycmVudCBwcm9qZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5wcm9qZWN0aW9uID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpZWxkcztcbiAgfVxuXG4gIHRoaXMuX2ZpZWxkcyA9IHt9O1xuICB0aGlzLl91c2VyUHJvdmlkZWRGaWVsZHMgPSB7fTtcbiAgdGhpcy5zZWxlY3QoYXJnKTtcbiAgcmV0dXJuIHRoaXMuX2ZpZWxkcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHdoaWNoIGRvY3VtZW50IGZpZWxkcyB0byBpbmNsdWRlIG9yIGV4Y2x1ZGUgKGFsc28ga25vd24gYXMgdGhlIHF1ZXJ5IFwicHJvamVjdGlvblwiKVxuICpcbiAqIFdoZW4gdXNpbmcgc3RyaW5nIHN5bnRheCwgcHJlZml4aW5nIGEgcGF0aCB3aXRoIGAtYCB3aWxsIGZsYWcgdGhhdCBwYXRoIGFzIGV4Y2x1ZGVkLiBXaGVuIGEgcGF0aCBkb2VzIG5vdCBoYXZlIHRoZSBgLWAgcHJlZml4LCBpdCBpcyBpbmNsdWRlZC4gTGFzdGx5LCBpZiBhIHBhdGggaXMgcHJlZml4ZWQgd2l0aCBgK2AsIGl0IGZvcmNlcyBpbmNsdXNpb24gb2YgdGhlIHBhdGgsIHdoaWNoIGlzIHVzZWZ1bCBmb3IgcGF0aHMgZXhjbHVkZWQgYXQgdGhlIFtzY2hlbWEgbGV2ZWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hdHlwZS5odG1sI1NjaGVtYVR5cGUucHJvdG90eXBlLnNlbGVjdCgpKS5cbiAqXG4gKiBBIHByb2plY3Rpb24gX211c3RfIGJlIGVpdGhlciBpbmNsdXNpdmUgb3IgZXhjbHVzaXZlLiBJbiBvdGhlciB3b3JkcywgeW91IG11c3RcbiAqIGVpdGhlciBsaXN0IHRoZSBmaWVsZHMgdG8gaW5jbHVkZSAod2hpY2ggZXhjbHVkZXMgYWxsIG90aGVycyksIG9yIGxpc3QgdGhlIGZpZWxkc1xuICogdG8gZXhjbHVkZSAod2hpY2ggaW1wbGllcyBhbGwgb3RoZXIgZmllbGRzIGFyZSBpbmNsdWRlZCkuIFRoZSBbYF9pZGAgZmllbGQgaXMgdGhlIG9ubHkgZXhjZXB0aW9uIGJlY2F1c2UgTW9uZ29EQiBpbmNsdWRlcyBpdCBieSBkZWZhdWx0XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9wcm9qZWN0LWZpZWxkcy1mcm9tLXF1ZXJ5LXJlc3VsdHMvI3N1cHByZXNzLWlkLWZpZWxkKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGluY2x1ZGUgYSBhbmQgYiwgZXhjbHVkZSBvdGhlciBmaWVsZHNcbiAqICAgICBxdWVyeS5zZWxlY3QoJ2EgYicpO1xuICogICAgIC8vIEVxdWl2YWxlbnQgc3ludGF4ZXM6XG4gKiAgICAgcXVlcnkuc2VsZWN0KFsnYScsICdiJ10pO1xuICogICAgIHF1ZXJ5LnNlbGVjdCh7IGE6IDEsIGI6IDEgfSk7XG4gKlxuICogICAgIC8vIGV4Y2x1ZGUgYyBhbmQgZCwgaW5jbHVkZSBvdGhlciBmaWVsZHNcbiAqICAgICBxdWVyeS5zZWxlY3QoJy1jIC1kJyk7XG4gKlxuICogICAgIC8vIFVzZSBgK2AgdG8gb3ZlcnJpZGUgc2NoZW1hLWxldmVsIGBzZWxlY3Q6IGZhbHNlYCB3aXRob3V0IG1ha2luZyB0aGVcbiAqICAgICAvLyBwcm9qZWN0aW9uIGluY2x1c2l2ZS5cbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIGZvbzogeyB0eXBlOiBTdHJpbmcsIHNlbGVjdDogZmFsc2UgfSxcbiAqICAgICAgIGJhcjogU3RyaW5nXG4gKiAgICAgfSk7XG4gKiAgICAgLy8gLi4uXG4gKiAgICAgcXVlcnkuc2VsZWN0KCcrZm9vJyk7IC8vIE92ZXJyaWRlIGZvbydzIGBzZWxlY3Q6IGZhbHNlYCB3aXRob3V0IGV4Y2x1ZGluZyBgYmFyYFxuICpcbiAqICAgICAvLyBvciB5b3UgbWF5IHVzZSBvYmplY3Qgbm90YXRpb24sIHVzZWZ1bCB3aGVuXG4gKiAgICAgLy8geW91IGhhdmUga2V5cyBhbHJlYWR5IHByZWZpeGVkIHdpdGggYSBcIi1cIlxuICogICAgIHF1ZXJ5LnNlbGVjdCh7IGE6IDEsIGI6IDEgfSk7XG4gKiAgICAgcXVlcnkuc2VsZWN0KHsgYzogMCwgZDogMCB9KTtcbiAqXG4gKiAgICAgQWRkaXRpb25hbCBjYWxscyB0byBzZWxlY3QgY2FuIG92ZXJyaWRlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb246XG4gKiAgICAgcXVlcnkuc2VsZWN0KHsgYTogMSwgYjogMSB9KS5zZWxlY3QoeyBiOiAwIH0pOyAvLyBzZWxlY3Rpb24gaXMgbm93IHsgYTogMSB9XG4gKiAgICAgcXVlcnkuc2VsZWN0KHsgYTogMCwgYjogMCB9KS5zZWxlY3QoeyBiOiAxIH0pOyAvLyBzZWxlY3Rpb24gaXMgbm93IHsgYTogMCB9XG4gKlxuICpcbiAqIEBtZXRob2Qgc2VsZWN0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBhcmdcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIFNjaGVtYVR5cGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWF0eXBlLmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgbGV0IGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgaWYgKCFhcmcpIHJldHVybiB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdDogc2VsZWN0IG9ubHkgdGFrZXMgMSBhcmd1bWVudCcpO1xuICB9XG5cbiAgdGhpcy5fdmFsaWRhdGUoJ3NlbGVjdCcpO1xuXG4gIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcyB8fCAodGhpcy5fZmllbGRzID0ge30pO1xuICBjb25zdCB1c2VyUHJvdmlkZWRGaWVsZHMgPSB0aGlzLl91c2VyUHJvdmlkZWRGaWVsZHMgfHwgKHRoaXMuX3VzZXJQcm92aWRlZEZpZWxkcyA9IHt9KTtcbiAgbGV0IHNhbml0aXplUHJvamVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgaWYgKHRoaXMubW9kZWwgIT0gbnVsbCAmJiB1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KHRoaXMubW9kZWwuZGIub3B0aW9ucywgJ3Nhbml0aXplUHJvamVjdGlvbicpKSB7XG4gICAgc2FuaXRpemVQcm9qZWN0aW9uID0gdGhpcy5tb2RlbC5kYi5vcHRpb25zLnNhbml0aXplUHJvamVjdGlvbjtcbiAgfSBlbHNlIGlmICh0aGlzLm1vZGVsICE9IG51bGwgJiYgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucywgJ3Nhbml0aXplUHJvamVjdGlvbicpKSB7XG4gICAgc2FuaXRpemVQcm9qZWN0aW9uID0gdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMuc2FuaXRpemVQcm9qZWN0aW9uO1xuICB9IGVsc2Uge1xuICAgIHNhbml0aXplUHJvamVjdGlvbiA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiBzYW5pdGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgc2FuaXRpemVQcm9qZWN0aW9uID8gdmFsdWUgPSAxIDogdmFsdWU7XG4gIH1cbiAgYXJnID0gcGFyc2VQcm9qZWN0aW9uKGFyZywgdHJ1ZSk7IC8vIHdlIHdhbnQgdG8ga2VlcCB0aGUgbWludXMgYW5kIHBsdXNlcywgc28gYWRkIGJvb2xlYW4gYXJnLlxuICBpZiAodXRpbHMuaXNPYmplY3QoYXJnKSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkSW5jbHVzaXZlbHkoKSkge1xuICAgICAgT2JqZWN0LmVudHJpZXMoYXJnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgLy8gQWRkIHRoZSBmaWVsZCB0byB0aGUgcHJvamVjdGlvblxuICAgICAgICAgIGlmIChmaWVsZHNbJy0nICsga2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgZmllbGRzWyctJyArIGtleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpZWxkc1trZXldID0gdXNlclByb3ZpZGVkRmllbGRzW2tleV0gPSBzYW5pdGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZpZWxkIGZyb20gdGhlIHByb2plY3Rpb25cbiAgICAgICAgICBPYmplY3Qua2V5cyh1c2VyUHJvdmlkZWRGaWVsZHMpLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGlzU3VicGF0aChrZXksIGZpZWxkKSkge1xuICAgICAgICAgICAgICBkZWxldGUgZmllbGRzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgZGVsZXRlIHVzZXJQcm92aWRlZEZpZWxkc1tmaWVsZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZEV4Y2x1c2l2ZWx5KCkpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGFyZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAvLyBBZGQgdGhlIGZpZWxkIHRvIHRoZSBwcm9qZWN0aW9uXG4gICAgICAgICAgaWYgKGZpZWxkc1snKycgKyBrZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNbJysnICsga2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmllbGRzW2tleV0gPSB1c2VyUHJvdmlkZWRGaWVsZHNba2V5XSA9IHNhbml0aXplVmFsdWUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmllbGQgZnJvbSB0aGUgcHJvamVjdGlvblxuICAgICAgICAgIE9iamVjdC5rZXlzKHVzZXJQcm92aWRlZEZpZWxkcykuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBpZiAoaXNTdWJwYXRoKGtleSwgZmllbGQpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNbZmllbGRdO1xuICAgICAgICAgICAgICBkZWxldGUgdXNlclByb3ZpZGVkRmllbGRzW2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXJnW2tleXNbaV1dO1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBmaWVsZHNba2V5XSA9IHNhbml0aXplVmFsdWUodmFsdWUpO1xuICAgICAgICB1c2VyUHJvdmlkZWRGaWVsZHNba2V5XSA9IHNhbml0aXplVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzZWxlY3QoKSBhcmd1bWVudC4gTXVzdCBiZSBzdHJpbmcgb3Igb2JqZWN0LicpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBNb25nb0RCIG5vZGVzIGZyb20gd2hpY2ggdG8gcmVhZC5cbiAqXG4gKiAjIyMjIFByZWZlcmVuY2VzOlxuICpcbiAqIGBgYFxuICogcHJpbWFyeSAtIChkZWZhdWx0KSBSZWFkIGZyb20gcHJpbWFyeSBvbmx5LiBPcGVyYXRpb25zIHdpbGwgcHJvZHVjZSBhbiBlcnJvciBpZiBwcmltYXJ5IGlzIHVuYXZhaWxhYmxlLiBDYW5ub3QgYmUgY29tYmluZWQgd2l0aCB0YWdzLlxuICogc2Vjb25kYXJ5ICAgICAgICAgICAgUmVhZCBmcm9tIHNlY29uZGFyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBlcnJvci5cbiAqIHByaW1hcnlQcmVmZXJyZWQgICAgIFJlYWQgZnJvbSBwcmltYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGEgc2Vjb25kYXJ5LlxuICogc2Vjb25kYXJ5UHJlZmVycmVkICAgUmVhZCBmcm9tIGEgc2Vjb25kYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHJlYWQgZnJvbSB0aGUgcHJpbWFyeS5cbiAqIG5lYXJlc3QgICAgICAgICAgICAgIEFsbCBvcGVyYXRpb25zIHJlYWQgZnJvbSBhbW9uZyB0aGUgbmVhcmVzdCBjYW5kaWRhdGVzLCBidXQgdW5saWtlIG90aGVyIG1vZGVzLCB0aGlzIG9wdGlvbiB3aWxsIGluY2x1ZGUgYm90aCB0aGUgcHJpbWFyeSBhbmQgYWxsIHNlY29uZGFyaWVzIGluIHRoZSByYW5kb20gc2VsZWN0aW9uLlxuICogYGBgXG4gKlxuICogQWxpYXNlc1xuICpcbiAqIGBgYFxuICogcCAgIHByaW1hcnlcbiAqIHBwICBwcmltYXJ5UHJlZmVycmVkXG4gKiBzICAgc2Vjb25kYXJ5XG4gKiBzcCAgc2Vjb25kYXJ5UHJlZmVycmVkXG4gKiBuICAgbmVhcmVzdFxuICogYGBgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcmltYXJ5JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwJykgIC8vIHNhbWUgYXMgcHJpbWFyeVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcmltYXJ5UHJlZmVycmVkJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcCcpIC8vIHNhbWUgYXMgcHJpbWFyeVByZWZlcnJlZFxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzZWNvbmRhcnknKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3MnKSAgLy8gc2FtZSBhcyBzZWNvbmRhcnlcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnc2Vjb25kYXJ5UHJlZmVycmVkJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzcCcpIC8vIHNhbWUgYXMgc2Vjb25kYXJ5UHJlZmVycmVkXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ25lYXJlc3QnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ24nKSAgLy8gc2FtZSBhcyBuZWFyZXN0XG4gKlxuICogICAgIC8vIHJlYWQgZnJvbSBzZWNvbmRhcmllcyB3aXRoIG1hdGNoaW5nIHRhZ3NcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzJywgW3sgZGM6J3NmJywgczogMSB9LHsgZGM6J21hJywgczogMiB9XSlcbiAqXG4gKiBSZWFkIG1vcmUgYWJvdXQgaG93IHRvIHVzZSByZWFkIHByZWZlcmVuY2VzIFtoZXJlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZSkuXG4gKlxuICogQG1ldGhvZCByZWFkXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGUgb25lIG9mIHRoZSBsaXN0ZWQgcHJlZmVyZW5jZSBvcHRpb25zIG9yIGFsaWFzZXNcbiAqIEBwYXJhbSB7QXJyYXl9IFt0YWdzXSBvcHRpb25hbCB0YWdzIGZvciB0aGlzIHF1ZXJ5XG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2VcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gcmVhZChtb2RlLCB0YWdzKSB7XG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICBtb2RlID0gaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzKG1vZGUpO1xuICAgIHRoaXMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9IHsgbW9kZSwgdGFncyB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9IG1vZGU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJ3cml0ZSBkZWZhdWx0IGAudG9TdHJpbmdgIHRvIG1ha2UgbG9nZ2luZyBtb3JlIHVzZWZ1bFxuICpcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgaWYgKHRoaXMub3AgPT09ICdjb3VudCcgfHxcbiAgICAgIHRoaXMub3AgPT09ICdjb3VudERvY3VtZW50cycgfHxcbiAgICAgIHRoaXMub3AgPT09ICdmaW5kJyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ2ZpbmRPbmUnIHx8XG4gICAgICB0aGlzLm9wID09PSAnZGVsZXRlTWFueScgfHxcbiAgICAgIHRoaXMub3AgPT09ICdkZWxldGVPbmUnIHx8XG4gICAgICB0aGlzLm9wID09PSAnZmluZE9uZUFuZERlbGV0ZScgfHxcbiAgICAgIHRoaXMub3AgPT09ICdmaW5kT25lQW5kUmVtb3ZlJyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ3JlbW92ZScpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5tb2RlbC5tb2RlbE5hbWV9LiR7dGhpcy5vcH0oJHt1dGlsLmluc3BlY3QodGhpcy5fY29uZGl0aW9ucyl9KWA7XG4gIH1cbiAgaWYgKHRoaXMub3AgPT09ICdkaXN0aW5jdCcpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5tb2RlbC5tb2RlbE5hbWV9LmRpc3RpbmN0KCcke3RoaXMuX2Rpc3RpbmN0fScsICR7dXRpbC5pbnNwZWN0KHRoaXMuX2NvbmRpdGlvbnMpfSlgO1xuICB9XG4gIGlmICh0aGlzLm9wID09PSAnZmluZE9uZUFuZFJlcGxhY2UnIHx8XG4gICAgICB0aGlzLm9wID09PSAnZmluZE9uZUFuZFVwZGF0ZScgfHxcbiAgICAgIHRoaXMub3AgPT09ICdyZXBsYWNlT25lJyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ3VwZGF0ZScgfHxcbiAgICAgIHRoaXMub3AgPT09ICd1cGRhdGVNYW55JyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ3VwZGF0ZU9uZScpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5tb2RlbC5tb2RlbE5hbWV9LiR7dGhpcy5vcH0oJHt1dGlsLmluc3BlY3QodGhpcy5fY29uZGl0aW9ucyl9LCAke3V0aWwuaW5zcGVjdCh0aGlzLl91cGRhdGUpfSlgO1xuICB9XG5cbiAgLy8gJ2VzdGltYXRlZERvY3VtZW50Q291bnQnIG9yIGFueSBvdGhlcnNcbiAgcmV0dXJuIGAke3RoaXMubW9kZWwubW9kZWxOYW1lfS4ke3RoaXMub3B9KClgO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBbTW9uZ29EQiBzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvc2VydmVyLXNlc3Npb25zLylcbiAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZXNzaW9ucyBhcmUgaG93IHlvdSBtYXJrIGEgcXVlcnkgYXMgcGFydCBvZiBhXG4gKiBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKlxuICogQ2FsbGluZyBgc2Vzc2lvbihudWxsKWAgcmVtb3ZlcyB0aGUgc2Vzc2lvbiBmcm9tIHRoaXMgcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gYXdhaXQgbW9uZ29vc2Uuc3RhcnRTZXNzaW9uKCk7XG4gKiAgICAgYXdhaXQgbW9uZ29vc2UubW9kZWwoJ1BlcnNvbicpLmZpbmRPbmUoeyBuYW1lOiAnQXhsIFJvc2UnIH0pLnNlc3Npb24ocyk7XG4gKlxuICogQG1ldGhvZCBzZXNzaW9uXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbc2Vzc2lvbl0gZnJvbSBgYXdhaXQgY29ubi5zdGFydFNlc3Npb24oKWBcbiAqIEBzZWUgQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnRTZXNzaW9uKCkgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uLmh0bWwjQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnRTZXNzaW9uKClcbiAqIEBzZWUgbW9uZ29vc2Uuc3RhcnRTZXNzaW9uKCkgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5zdGFydFNlc3Npb24oKVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlc3Npb24gPSBmdW5jdGlvbiBzZXNzaW9uKHYpIHtcbiAgaWYgKHYgPT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuc2Vzc2lvbjtcbiAgfVxuICB0aGlzLm9wdGlvbnMuc2Vzc2lvbiA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSAzIHdyaXRlIGNvbmNlcm4gcGFyYW1ldGVycyBmb3IgdGhpcyBxdWVyeTpcbiAqXG4gKiAtIGB3YDogU2V0cyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBgbW9uZ29kYCBzZXJ2ZXJzLCBvciB0YWcgc2V0IG9mIGBtb25nb2RgIHNlcnZlcnMsIHRoYXQgbXVzdCBhY2tub3dsZWRnZSB0aGlzIHdyaXRlIGJlZm9yZSB0aGlzIHdyaXRlIGlzIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bC5cbiAqIC0gYGpgOiBCb29sZWFuLCBzZXQgdG8gYHRydWVgIHRvIHJlcXVlc3QgYWNrbm93bGVkZ2VtZW50IHRoYXQgdGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gcGVyc2lzdGVkIHRvIE1vbmdvREIncyBvbi1kaXNrIGpvdXJuYWwuXG4gKiAtIGB3dGltZW91dGA6IElmIFtgdyA+IDFgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLncoKSksIHRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgZm9yIHRoaXMgd3JpdGUgdG8gcHJvcGFnYXRlIHRocm91Z2ggdGhlIHJlcGxpY2Egc2V0IGJlZm9yZSB0aGlzIG9wZXJhdGlvbiBmYWlscy4gVGhlIGRlZmF1bHQgaXMgYDBgLCB3aGljaCBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIFRoaXMgb3B0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIG9wZXJhdGlvbnMgdGhhdCB3cml0ZSB0byB0aGUgZGF0YWJhc2U6XG4gKlxuICogLSBgZGVsZXRlT25lKClgXG4gKiAtIGBkZWxldGVNYW55KClgXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiAtIGBmaW5kT25lQW5kUmVwbGFjZSgpYFxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgdXBkYXRlT25lKClgXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogRGVmYXVsdHMgdG8gdGhlIHNjaGVtYSdzIFtgd3JpdGVDb25jZXJuYCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRoZSAnbWFqb3JpdHknIG9wdGlvbiBtZWFucyB0aGUgYGRlbGV0ZU9uZSgpYCBwcm9taXNlIHdvbid0IHJlc29sdmVcbiAqICAgICAvLyB1bnRpbCB0aGUgYGRlbGV0ZU9uZSgpYCBoYXMgcHJvcGFnYXRlZCB0byB0aGUgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0XG4gKiAgICAgYXdhaXQgbW9uZ29vc2UubW9kZWwoJ1BlcnNvbicpLlxuICogICAgICAgZGVsZXRlT25lKHsgbmFtZTogJ05lZCBTdGFyaycgfSkuXG4gKiAgICAgICB3cml0ZUNvbmNlcm4oeyB3OiAnbWFqb3JpdHknIH0pO1xuICpcbiAqIEBtZXRob2Qgd3JpdGVDb25jZXJuXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IHdyaXRlQ29uY2VybiB0aGUgd3JpdGUgY29uY2VybiB2YWx1ZSB0byBzZXRcbiAqIEBzZWUgV3JpdGVDb25jZXJuU2V0dGluZ3MgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL1dyaXRlQ29uY2VyblNldHRpbmdzLmh0bWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS53cml0ZUNvbmNlcm4gPSBmdW5jdGlvbiB3cml0ZUNvbmNlcm4odmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMud3JpdGVDb25jZXJuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGBtb25nb2RgIHNlcnZlcnMsIG9yIHRhZyBzZXQgb2YgYG1vbmdvZGAgc2VydmVycyxcbiAqIHRoYXQgbXVzdCBhY2tub3dsZWRnZSB0aGlzIHdyaXRlIGJlZm9yZSB0aGlzIHdyaXRlIGlzIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bC5cbiAqIFRoaXMgb3B0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIG9wZXJhdGlvbnMgdGhhdCB3cml0ZSB0byB0aGUgZGF0YWJhc2U6XG4gKlxuICogLSBgZGVsZXRlT25lKClgXG4gKiAtIGBkZWxldGVNYW55KClgXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiAtIGBmaW5kT25lQW5kUmVwbGFjZSgpYFxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgdXBkYXRlT25lKClgXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogRGVmYXVsdHMgdG8gdGhlIHNjaGVtYSdzIFtgd3JpdGVDb25jZXJuLndgIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gVGhlICdtYWpvcml0eScgb3B0aW9uIG1lYW5zIHRoZSBgZGVsZXRlT25lKClgIHByb21pc2Ugd29uJ3QgcmVzb2x2ZVxuICogICAgIC8vIHVudGlsIHRoZSBgZGVsZXRlT25lKClgIGhhcyBwcm9wYWdhdGVkIHRvIHRoZSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXRcbiAqICAgICBhd2FpdCBtb25nb29zZS5tb2RlbCgnUGVyc29uJykuXG4gKiAgICAgICBkZWxldGVPbmUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9KS5cbiAqICAgICAgIHcoJ21ham9yaXR5Jyk7XG4gKlxuICogQG1ldGhvZCB3XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd8bnVtYmVyfSB2YWwgMCBmb3IgZmlyZS1hbmQtZm9yZ2V0LCAxIGZvciBhY2tub3dsZWRnZWQgYnkgb25lIHNlcnZlciwgJ21ham9yaXR5JyBmb3IgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0LCBvciBbYW55IG9mIHRoZSBtb3JlIGFkdmFuY2VkIG9wdGlvbnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3LW9wdGlvbikuXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3ctb3B0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudyA9IGZ1bmN0aW9uIHcodmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMudztcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLndyaXRlQ29uY2VybiAhPSBudWxsKSB7XG4gICAgdGhpcy5vcHRpb25zLndyaXRlQ29uY2Vybi53ID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy53ID0gdmFsO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyBhY2tub3dsZWRnZW1lbnQgdGhhdCB0aGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBwZXJzaXN0ZWQgdG8gTW9uZ29EQidzXG4gKiBvbi1kaXNrIGpvdXJuYWwuXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFJlcGxhY2UoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIHRoZSBzY2hlbWEncyBbYHdyaXRlQ29uY2Vybi5qYCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IG1vbmdvb3NlLm1vZGVsKCdQZXJzb24nKS5kZWxldGVPbmUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9KS5qKHRydWUpO1xuICpcbiAqIEBtZXRob2QgalxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI2otb3B0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuaiA9IGZ1bmN0aW9uIGoodmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuajtcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLndyaXRlQ29uY2VybiAhPSBudWxsKSB7XG4gICAgdGhpcy5vcHRpb25zLndyaXRlQ29uY2Vybi5qID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5qID0gdmFsO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJZiBbYHcgPiAxYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS53KCkpLCB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0b1xuICogd2FpdCBmb3IgdGhpcyB3cml0ZSB0byBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgcmVwbGljYSBzZXQgYmVmb3JlIHRoaXNcbiAqIG9wZXJhdGlvbiBmYWlscy4gVGhlIGRlZmF1bHQgaXMgYDBgLCB3aGljaCBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIFRoaXMgb3B0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIG9wZXJhdGlvbnMgdGhhdCB3cml0ZSB0byB0aGUgZGF0YWJhc2U6XG4gKlxuICogLSBgZGVsZXRlT25lKClgXG4gKiAtIGBkZWxldGVNYW55KClgXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiAtIGBmaW5kT25lQW5kUmVwbGFjZSgpYFxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgdXBkYXRlT25lKClgXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogRGVmYXVsdHMgdG8gdGhlIHNjaGVtYSdzIFtgd3JpdGVDb25jZXJuLnd0aW1lb3V0YCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRoZSBgZGVsZXRlT25lKClgIHByb21pc2Ugd29uJ3QgcmVzb2x2ZSB1bnRpbCB0aGlzIGBkZWxldGVPbmUoKWAgaGFzXG4gKiAgICAgLy8gcHJvcGFnYXRlZCB0byBhdCBsZWFzdCBgdyA9IDJgIG1lbWJlcnMgb2YgdGhlIHJlcGxpY2Egc2V0LiBJZiBpdCB0YWtlc1xuICogICAgIC8vIGxvbmdlciB0aGFuIDEgc2Vjb25kLCB0aGlzIGBkZWxldGVPbmUoKWAgd2lsbCBmYWlsLlxuICogICAgIGF3YWl0IG1vbmdvb3NlLm1vZGVsKCdQZXJzb24nKS5cbiAqICAgICAgIGRlbGV0ZU9uZSh7IG5hbWU6ICdOZWQgU3RhcmsnIH0pLlxuICogICAgICAgdygyKS5cbiAqICAgICAgIHd0aW1lb3V0KDEwMDApO1xuICpcbiAqIEBtZXRob2Qgd3RpbWVvdXRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbXMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0XG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3d0aW1lb3V0XG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUud3RpbWVvdXQgPSBmdW5jdGlvbiB3dGltZW91dChtcykge1xuICBpZiAobXMgPT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMud3RpbWVvdXQ7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4gIT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4ud3RpbWVvdXQgPSBtcztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMud3RpbWVvdXQgPSBtcztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVhZENvbmNlcm4gb3B0aW9uIGZvciB0aGUgcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbG9jYWwnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdsJykgIC8vIHNhbWUgYXMgbG9jYWxcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2F2YWlsYWJsZScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2EnKSAgLy8gc2FtZSBhcyBhdmFpbGFibGVcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ21ham9yaXR5JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbScpICAvLyBzYW1lIGFzIG1ham9yaXR5XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdsaW5lYXJpemFibGUnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdseicpIC8vIHNhbWUgYXMgbGluZWFyaXphYmxlXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdzbmFwc2hvdCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ3MnKSAgLy8gc2FtZSBhcyBzbmFwc2hvdFxuICpcbiAqXG4gKiAjIyMjIFJlYWQgQ29uY2VybiBMZXZlbDpcbiAqXG4gKiBgYGBcbiAqIGxvY2FsICAgICAgICAgTW9uZ29EQiAzLjIrIFRoZSBxdWVyeSByZXR1cm5zIGZyb20gdGhlIGluc3RhbmNlIHdpdGggbm8gZ3VhcmFudGVlIGd1YXJhbnRlZSB0aGF0IHRoZSBkYXRhIGhhcyBiZWVuIHdyaXR0ZW4gdG8gYSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQgbWVtYmVycyAoaS5lLiBtYXkgYmUgcm9sbGVkIGJhY2spLlxuICogYXZhaWxhYmxlICAgICBNb25nb0RCIDMuNisgVGhlIHF1ZXJ5IHJldHVybnMgZnJvbSB0aGUgaW5zdGFuY2Ugd2l0aCBubyBndWFyYW50ZWUgZ3VhcmFudGVlIHRoYXQgdGhlIGRhdGEgaGFzIGJlZW4gd3JpdHRlbiB0byBhIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCBtZW1iZXJzIChpLmUuIG1heSBiZSByb2xsZWQgYmFjaykuXG4gKiBtYWpvcml0eSAgICAgIE1vbmdvREIgMy4yKyBUaGUgcXVlcnkgcmV0dXJucyB0aGUgZGF0YSB0aGF0IGhhcyBiZWVuIGFja25vd2xlZGdlZCBieSBhIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCBtZW1iZXJzLiBUaGUgZG9jdW1lbnRzIHJldHVybmVkIGJ5IHRoZSByZWFkIG9wZXJhdGlvbiBhcmUgZHVyYWJsZSwgZXZlbiBpbiB0aGUgZXZlbnQgb2YgZmFpbHVyZS5cbiAqIGxpbmVhcml6YWJsZSAgTW9uZ29EQiAzLjQrIFRoZSBxdWVyeSByZXR1cm5zIGRhdGEgdGhhdCByZWZsZWN0cyBhbGwgc3VjY2Vzc2Z1bCBtYWpvcml0eS1hY2tub3dsZWRnZWQgd3JpdGVzIHRoYXQgY29tcGxldGVkIHByaW9yIHRvIHRoZSBzdGFydCBvZiB0aGUgcmVhZCBvcGVyYXRpb24uIFRoZSBxdWVyeSBtYXkgd2FpdCBmb3IgY29uY3VycmVudGx5IGV4ZWN1dGluZyB3cml0ZXMgdG8gcHJvcGFnYXRlIHRvIGEgbWFqb3JpdHkgb2YgcmVwbGljYSBzZXQgbWVtYmVycyBiZWZvcmUgcmV0dXJuaW5nIHJlc3VsdHMuXG4gKiBzbmFwc2hvdCAgICAgIE1vbmdvREIgNC4wKyBPbmx5IGF2YWlsYWJsZSBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gbXVsdGktZG9jdW1lbnQgdHJhbnNhY3Rpb25zLiBVcG9uIHRyYW5zYWN0aW9uIGNvbW1pdCB3aXRoIHdyaXRlIGNvbmNlcm4gXCJtYWpvcml0eVwiLCB0aGUgdHJhbnNhY3Rpb24gb3BlcmF0aW9ucyBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHJlYWQgZnJvbSBhIHNuYXBzaG90IG9mIG1ham9yaXR5LWNvbW1pdHRlZCBkYXRhLlxuICogYGBgXG4gKlxuICogQWxpYXNlc1xuICpcbiAqIGBgYFxuICogbCAgIGxvY2FsXG4gKiBhICAgYXZhaWxhYmxlXG4gKiBtICAgbWFqb3JpdHlcbiAqIGx6ICBsaW5lYXJpemFibGVcbiAqIHMgICBzbmFwc2hvdFxuICogYGBgXG4gKlxuICogUmVhZCBtb3JlIGFib3V0IGhvdyB0byB1c2UgcmVhZCBjb25jZXJuIFtoZXJlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvcmVhZC1jb25jZXJuLykuXG4gKlxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAbWV0aG9kIHJlYWRDb25jZXJuXG4gKiBAcGFyYW0ge1N0cmluZ30gbGV2ZWwgb25lIG9mIHRoZSBsaXN0ZWQgcmVhZCBjb25jZXJuIGxldmVsIG9yIHRoZWlyIGFsaWFzZXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvcmVhZC1jb25jZXJuL1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBHZXRzIHF1ZXJ5IG9wdGlvbnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeSgpO1xuICogICAgIHF1ZXJ5LmxpbWl0KDEwKTtcbiAqICAgICBxdWVyeS5zZXRPcHRpb25zKHsgbWF4VGltZU1TOiAxMDAwIH0pO1xuICogICAgIHF1ZXJ5LmdldE9wdGlvbnMoKTsgLy8geyBsaW1pdDogMTAsIG1heFRpbWVNUzogMTAwMCB9XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vcHRpb25zO1xufTtcblxuLyoqXG4gKiBTZXRzIHF1ZXJ5IG9wdGlvbnMuIFNvbWUgb3B0aW9ucyBvbmx5IG1ha2Ugc2Vuc2UgZm9yIGNlcnRhaW4gb3BlcmF0aW9ucy5cbiAqXG4gKiAjIyMjIE9wdGlvbnM6XG4gKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBvbmx5IGZvciBgZmluZCgpYDpcbiAqXG4gKiAtIFt0YWlsYWJsZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS90YWlsYWJsZS1jdXJzb3JzLylcbiAqIC0gW2xpbWl0XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5saW1pdC8pXG4gKiAtIFtza2lwXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5za2lwLylcbiAqIC0gW2FsbG93RGlza1VzZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IuYWxsb3dEaXNrVXNlLylcbiAqIC0gW2JhdGNoU2l6ZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IuYmF0Y2hTaXplLylcbiAqIC0gW3JlYWRQcmVmZXJlbmNlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZSlcbiAqIC0gW2hpbnRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmhpbnQvKVxuICogLSBbY29tbWVudF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IuY29tbWVudC8pXG4gKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBvbmx5IGZvciB3cml0ZSBvcGVyYXRpb25zOiBgdXBkYXRlT25lKClgLCBgdXBkYXRlTWFueSgpYCwgYHJlcGxhY2VPbmUoKWAsIGBmaW5kT25lQW5kVXBkYXRlKClgLCBhbmQgYGZpbmRCeUlkQW5kVXBkYXRlKClgOlxuICpcbiAqIC0gW3Vwc2VydF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLnVwZGF0ZS8pXG4gKiAtIFt3cml0ZUNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi51cGRhdGUvKVxuICogLSBbdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcyk6IElmIGB0aW1lc3RhbXBzYCBpcyBzZXQgaW4gdGhlIHNjaGVtYSwgc2V0IHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgdG8gc2tpcCB0aW1lc3RhbXBzIGZvciB0aGF0IHBhcnRpY3VsYXIgdXBkYXRlLiBIYXMgbm8gZWZmZWN0IGlmIGB0aW1lc3RhbXBzYCBpcyBub3QgZW5hYmxlZCBpbiB0aGUgc2NoZW1hIG9wdGlvbnMuXG4gKiAtIG92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXk6IGFsbG93IHNldHRpbmcgdGhlIGRpc2NyaW1pbmF0b3Iga2V5IGluIHRoZSB1cGRhdGUuIFdpbGwgdXNlIHRoZSBjb3JyZWN0IGRpc2NyaW1pbmF0b3Igc2NoZW1hIGlmIHRoZSB1cGRhdGUgY2hhbmdlcyB0aGUgZGlzY3JpbWluYXRvciBrZXkuXG4gKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBvbmx5IGZvciBgZmluZCgpYCwgYGZpbmRPbmUoKWAsIGBmaW5kQnlJZCgpYCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAsIGBmaW5kT25lQW5kUmVwbGFjZSgpYCwgYGZpbmRPbmVBbmREZWxldGUoKWAsIGFuZCBgZmluZEJ5SWRBbmRVcGRhdGUoKWA6XG4gKlxuICogLSBbbGVhbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpXG4gKiAtIFtwb3B1bGF0ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwpXG4gKiAtIFtwcm9qZWN0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnByb2plY3Rpb24oKSlcbiAqIC0gc2FuaXRpemVQcm9qZWN0aW9uXG4gKiAtIHVzZUJpZ0ludDY0XG4gKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBvbmx5IGZvciBhbGwgb3BlcmF0aW9ucyAqKmV4Y2VwdCoqIGB1cGRhdGVPbmUoKWAsIGB1cGRhdGVNYW55KClgLCBgZGVsZXRlT25lKClgLCBhbmQgYGRlbGV0ZU1hbnkoKWA6XG4gKlxuICogLSBbbWF4VGltZU1TXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWV0YS9tYXhUaW1lTVMvKVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgZm9yIGBmaW5kKClgLCBgZmluZE9uZSgpYCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAsIGBmaW5kT25lQW5kUmVtb3ZlKClgLCBgZmluZE9uZUFuZERlbGV0ZSgpYCwgYHVwZGF0ZU9uZSgpYCwgYW5kIGBkZWxldGVPbmUoKWA6XG4gKlxuICogLSBbc29ydF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3Iuc29ydC8pXG4gKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBmb3IgYGZpbmRPbmVBbmRVcGRhdGUoKWAgYW5kIGBmaW5kT25lQW5kUmVtb3ZlKClgXG4gKlxuICogLSByYXdSZXN1bHRcbiAqXG4gKiBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGZvciBhbGwgb3BlcmF0aW9uczpcbiAqXG4gKiAtIFtzdHJpY3RdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIC0gW2NvbGxhdGlvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbGxhdGlvbi8pXG4gKiAtIFtzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvc2VydmVyLXNlc3Npb25zLylcbiAqIC0gW2V4cGxhaW5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmV4cGxhaW4vKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMsIG92ZXJ3cml0ZSkge1xuICAvLyBvdmVyd3JpdGUgaXMgb25seSBmb3IgaW50ZXJuYWwgdXNlXG4gIGlmIChvdmVyd3JpdGUpIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBfbW9uZ29vc2VPcHRpb25zICYgb3B0aW9ucyBhcmUgdHdvIGRpZmZlcmVudCBvYmplY3RzXG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0gKG9wdGlvbnMgJiYgY2xvbmUob3B0aW9ucykpIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoJ3BvcHVsYXRlJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLnBvcHVsYXRlKHRoaXMuX21vbmdvb3NlT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgXCInICsgb3B0aW9ucyArICdcIicpO1xuICB9XG5cbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucG9wdWxhdGUpKSB7XG4gICAgY29uc3QgcG9wdWxhdGUgPSBvcHRpb25zLnBvcHVsYXRlO1xuICAgIGRlbGV0ZSBvcHRpb25zLnBvcHVsYXRlO1xuICAgIGNvbnN0IF9udW1Qb3B1bGF0ZSA9IHBvcHVsYXRlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9udW1Qb3B1bGF0ZTsgKytpKSB7XG4gICAgICB0aGlzLnBvcHVsYXRlKHBvcHVsYXRlW2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAoJ3NldERlZmF1bHRzT25JbnNlcnQnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydCA9IG9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydDtcbiAgICBkZWxldGUgb3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0O1xuICB9XG4gIGlmICgnb3ZlcndyaXRlRGlzY3JpbWluYXRvcktleScgaW4gb3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5ID0gb3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5O1xuICAgIGRlbGV0ZSBvcHRpb25zLm92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXk7XG4gIH1cbiAgaWYgKCdzYW5pdGl6ZVByb2plY3Rpb24nIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb24gJiYgIXRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb24pIHtcbiAgICAgIHNhbml0aXplUHJvamVjdGlvbih0aGlzLl9maWVsZHMpO1xuICAgIH1cblxuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb24gPSBvcHRpb25zLnNhbml0aXplUHJvamVjdGlvbjtcbiAgICBkZWxldGUgb3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb247XG4gIH1cbiAgaWYgKCdzYW5pdGl6ZUZpbHRlcicgaW4gb3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZUZpbHRlciA9IG9wdGlvbnMuc2FuaXRpemVGaWx0ZXI7XG4gICAgZGVsZXRlIG9wdGlvbnMuc2FuaXRpemVGaWx0ZXI7XG4gIH1cbiAgaWYgKCdvdmVyd3JpdGUnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMub3ZlcndyaXRlID0gb3B0aW9ucy5vdmVyd3JpdGU7XG4gICAgZGVsZXRlIG9wdGlvbnMub3ZlcndyaXRlO1xuICB9XG4gIGlmICgndGltZXN0YW1wcycgaW4gb3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy50aW1lc3RhbXBzID0gb3B0aW9ucy50aW1lc3RhbXBzO1xuICAgIGRlbGV0ZSBvcHRpb25zLnRpbWVzdGFtcHM7XG4gIH1cbiAgaWYgKCdkZWZhdWx0cycgaW4gb3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5kZWZhdWx0cyA9IG9wdGlvbnMuZGVmYXVsdHM7XG4gICAgLy8gZGVsZXRpbmcgb3B0aW9ucy5kZWZhdWx0cyB3aWxsIGNhdXNlIDcyODcgdG8gZmFpbFxuICB9XG4gIGlmICgndHJhbnNsYXRlQWxpYXNlcycgaW4gb3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzID0gb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzO1xuICAgIGRlbGV0ZSBvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM7XG4gIH1cblxuICBpZiAoJ3Jhd1Jlc3VsdCcgaW4gb3B0aW9ucykge1xuICAgIHByaW50UmF3UmVzdWx0RGVwcmVjYXRpb25XYXJuaW5nKCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5sZWFuID09IG51bGwgJiYgdGhpcy5zY2hlbWEgJiYgJ2xlYW4nIGluIHRoaXMuc2NoZW1hLm9wdGlvbnMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMubGVhbiA9IHRoaXMuc2NoZW1hLm9wdGlvbnMubGVhbjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5saW1pdCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucy5saW1pdCA9IGNhc3ROdW1iZXIob3B0aW9ucy5saW1pdCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdOdW1iZXInLCBvcHRpb25zLmxpbWl0LCAnbGltaXQnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLnNraXAgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMuc2tpcCA9IGNhc3ROdW1iZXIob3B0aW9ucy5za2lwKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ051bWJlcicsIG9wdGlvbnMuc2tpcCwgJ3NraXAnKTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgYXJiaXRyYXJ5IG9wdGlvbnNcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0aW9ucykpIHtcbiAgICBpZiAocXVlcnlPcHRpb25NZXRob2RzLmhhcyhrZXkpKSB7XG4gICAgICBjb25zdCBhcmdzID0gQXJyYXkuaXNBcnJheShvcHRpb25zW2tleV0pID9cbiAgICAgICAgb3B0aW9uc1trZXldIDpcbiAgICAgICAgW29wdGlvbnNba2V5XV07XG4gICAgICB0aGlzW2tleV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBwcmludFJhd1Jlc3VsdERlcHJlY2F0aW9uV2FybmluZyA9IHV0aWwuZGVwcmVjYXRlKFxuICBmdW5jdGlvbiBwcmludFJhd1Jlc3VsdERlcHJlY2F0aW9uV2FybmluZygpIHt9LFxuICAnVGhlIGByYXdSZXN1bHRgIG9wdGlvbiBmb3IgTW9uZ29vc2UgcXVlcmllcyBpcyBkZXByZWNhdGVkLiBVc2UgYGluY2x1ZGVSZXN1bHRNZXRhZGF0YTogdHJ1ZWAgYXMgYSByZXBsYWNlbWVudCBmb3IgYHJhd1Jlc3VsdDogdHJ1ZWAuJ1xuKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBwcmludE92ZXJ3cml0ZURlcHJlY2F0aW9uV2FybmluZyA9IHV0aWwuZGVwcmVjYXRlKFxuICBmdW5jdGlvbiBwcmludE92ZXJ3cml0ZURlcHJlY2F0aW9uV2FybmluZygpIHt9LFxuICAnVGhlIGBvdmVyd3JpdGVgIG9wdGlvbiBmb3IgYGZpbmRPbmVBbmRVcGRhdGUoKWAgaXMgZGVwcmVjYXRlZC4gdXNlIGBmaW5kT25lQW5kUmVwbGFjZSgpYCBpbnN0ZWFkLidcbik7XG5cbi8qKlxuICogU2V0cyB0aGUgW2BleHBsYWluYCBvcHRpb25dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmV4cGxhaW4vKSxcbiAqIHdoaWNoIG1ha2VzIHRoaXMgcXVlcnkgcmV0dXJuIGRldGFpbGVkIGV4ZWN1dGlvbiBzdGF0cyBpbnN0ZWFkIG9mIHRoZSBhY3R1YWxcbiAqIHF1ZXJ5IHJlc3VsdC4gVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGF0IGluZGV4IHlvdXIgcXVlcmllc1xuICogdXNlLlxuICpcbiAqIENhbGxpbmcgYHF1ZXJ5LmV4cGxhaW4odilgIGlzIGVxdWl2YWxlbnQgdG8gYHF1ZXJ5LnNldE9wdGlvbnMoeyBleHBsYWluOiB2IH0pYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoKTtcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBxdWVyeS5maW5kKHsgYTogMSB9KS5leHBsYWluKCdxdWVyeVBsYW5uZXInKTtcbiAqICAgICBjb25zb2xlLmxvZyhyZXMpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdmVyYm9zZV0gVGhlIHZlcmJvc2l0eSBtb2RlLiBFaXRoZXIgJ3F1ZXJ5UGxhbm5lcicsICdleGVjdXRpb25TdGF0cycsIG9yICdhbGxQbGFuc0V4ZWN1dGlvbicuIFRoZSBkZWZhdWx0IGlzICdxdWVyeVBsYW5uZXInXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXhwbGFpbiA9IGZ1bmN0aW9uIGV4cGxhaW4odmVyYm9zZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMub3B0aW9ucy5leHBsYWluID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh2ZXJib3NlID09PSBmYWxzZSkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuZXhwbGFpbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMuZXhwbGFpbiA9IHZlcmJvc2U7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIFtgYWxsb3dEaXNrVXNlYCBvcHRpb25dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmFsbG93RGlza1VzZS8pLFxuICogd2hpY2ggYWxsb3dzIHRoZSBNb25nb0RCIHNlcnZlciB0byB1c2UgbW9yZSB0aGFuIDEwMCBNQiBmb3IgdGhpcyBxdWVyeSdzIGBzb3J0KClgLiBUaGlzIG9wdGlvbiBjYW5cbiAqIGxldCB5b3Ugd29yayBhcm91bmQgYFF1ZXJ5RXhjZWVkZWRNZW1vcnlMaW1pdE5vRGlza1VzZUFsbG93ZWRgIGVycm9ycyBmcm9tIHRoZSBNb25nb0RCIHNlcnZlci5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBvcHRpb24gcmVxdWlyZXMgTW9uZ29EQiBzZXJ2ZXIgPj0gNC40LiBTZXR0aW5nIHRoaXMgb3B0aW9uIGlzIGEgbm8tb3AgZm9yIE1vbmdvREIgNC4yXG4gKiBhbmQgZWFybGllci5cbiAqXG4gKiBDYWxsaW5nIGBxdWVyeS5hbGxvd0Rpc2tVc2UodilgIGlzIGVxdWl2YWxlbnQgdG8gYHF1ZXJ5LnNldE9wdGlvbnMoeyBhbGxvd0Rpc2tVc2U6IHYgfSlgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kKCkuc29ydCh7IG5hbWU6IDEgfSkuYWxsb3dEaXNrVXNlKHRydWUpO1xuICogICAgIC8vIEVxdWl2YWxlbnQ6XG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZCgpLnNvcnQoeyBuYW1lOiAxIH0pLmFsbG93RGlza1VzZSgpO1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZdIEVuYWJsZS9kaXNhYmxlIGBhbGxvd0Rpc2tVc2VgLiBJZiBjYWxsZWQgd2l0aCAwIGFyZ3VtZW50cywgc2V0cyBgYWxsb3dEaXNrVXNlOiB0cnVlYFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmFsbG93RGlza1VzZSA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLm9wdGlvbnMuYWxsb3dEaXNrVXNlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh2ID09PSBmYWxzZSkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuYWxsb3dEaXNrVXNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5hbGxvd0Rpc2tVc2UgPSB2O1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBbbWF4VGltZU1TXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5tYXhUaW1lTVMvKVxuICogb3B0aW9uLiBUaGlzIHdpbGwgdGVsbCB0aGUgTW9uZ29EQiBzZXJ2ZXIgdG8gYWJvcnQgaWYgdGhlIHF1ZXJ5IG9yIHdyaXRlIG9wXG4gKiBoYXMgYmVlbiBydW5uaW5nIGZvciBtb3JlIHRoYW4gYG1zYCBtaWxsaXNlY29uZHMuXG4gKlxuICogQ2FsbGluZyBgcXVlcnkubWF4VGltZU1TKHYpYCBpcyBlcXVpdmFsZW50IHRvIGBxdWVyeS5zZXRPcHRpb25zKHsgbWF4VGltZU1TOiB2IH0pYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoKTtcbiAqICAgICAvLyBUaHJvd3MgYW4gZXJyb3IgJ29wZXJhdGlvbiBleGNlZWRlZCB0aW1lIGxpbWl0JyBhcyBsb25nIGFzIHRoZXJlJ3NcbiAqICAgICAvLyA+PSAxIGRvYyBpbiB0aGUgcXVlcmllZCBjb2xsZWN0aW9uXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgcXVlcnkuZmluZCh7ICR3aGVyZTogJ3NsZWVwKDEwMDApIHx8IHRydWUnIH0pLm1heFRpbWVNUygxMDApO1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbXNdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubWF4VGltZU1TID0gZnVuY3Rpb24obXMpIHtcbiAgdGhpcy5vcHRpb25zLm1heFRpbWVNUyA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBxdWVyeSBmaWx0ZXIgKGFsc28ga25vd24gYXMgY29uZGl0aW9ucykgYXMgYSBbUE9KT10oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3Bvam8pLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoKTtcbiAqICAgICBxdWVyeS5maW5kKHsgYTogMSB9KS53aGVyZSgnYicpLmd0KDIpO1xuICogICAgIHF1ZXJ5LmdldEZpbHRlcigpOyAvLyB7IGE6IDEsIGI6IHsgJGd0OiAyIH0gfVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gY3VycmVudCBxdWVyeSBmaWx0ZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdldEZpbHRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29uZGl0aW9ucztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBxdWVyeSBmaWx0ZXIuIEVxdWl2YWxlbnQgdG8gYGdldEZpbHRlcigpYC5cbiAqXG4gKiBZb3Ugc2hvdWxkIHVzZSBgZ2V0RmlsdGVyKClgIGluc3RlYWQgb2YgYGdldFF1ZXJ5KClgIHdoZXJlIHBvc3NpYmxlLiBgZ2V0UXVlcnkoKWBcbiAqIHdpbGwgbGlrZWx5IGJlIGRlcHJlY2F0ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgcXVlcnkuZmluZCh7IGE6IDEgfSkud2hlcmUoJ2InKS5ndCgyKTtcbiAqICAgICBxdWVyeS5nZXRRdWVyeSgpOyAvLyB7IGE6IDEsIGI6IHsgJGd0OiAyIH0gfVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gY3VycmVudCBxdWVyeSBmaWx0ZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdldFF1ZXJ5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jb25kaXRpb25zO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBxdWVyeSBjb25kaXRpb25zIHRvIHRoZSBwcm92aWRlZCBKU09OIG9iamVjdC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgcXVlcnkuZmluZCh7IGE6IDEgfSlcbiAqICAgICBxdWVyeS5zZXRRdWVyeSh7IGE6IDIgfSk7XG4gKiAgICAgcXVlcnkuZ2V0UXVlcnkoKTsgLy8geyBhOiAyIH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbmV3IHF1ZXJ5IGNvbmRpdGlvbnNcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNldFF1ZXJ5ID0gZnVuY3Rpb24odmFsKSB7XG4gIHRoaXMuX2NvbmRpdGlvbnMgPSB2YWw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlIG9wZXJhdGlvbnMgYXMgYSBKU09OIG9iamVjdC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgcXVlcnkudXBkYXRlT25lKHt9LCB7ICRzZXQ6IHsgYTogNSB9IH0pO1xuICogICAgIHF1ZXJ5LmdldFVwZGF0ZSgpOyAvLyB7ICRzZXQ6IHsgYTogNSB9IH1cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgdXBkYXRlIG9wZXJhdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdldFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdXBkYXRlO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHVwZGF0ZSBvcGVyYXRpb24gdG8gbmV3IHZhbHVlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoKTtcbiAqICAgICBxdWVyeS51cGRhdGVPbmUoe30sIHsgJHNldDogeyBhOiA1IH0gfSk7XG4gKiAgICAgcXVlcnkuc2V0VXBkYXRlKHsgJHNldDogeyBiOiA2IH0gfSk7XG4gKiAgICAgcXVlcnkuZ2V0VXBkYXRlKCk7IC8vIHsgJHNldDogeyBiOiA2IH0gfVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXcgdXBkYXRlIG9wZXJhdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2V0VXBkYXRlID0gZnVuY3Rpb24odmFsKSB7XG4gIHRoaXMuX3VwZGF0ZSA9IHZhbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmaWVsZHMgc2VsZWN0aW9uIGZvciB0aGlzIHF1ZXJ5LlxuICpcbiAqIEBtZXRob2QgX2ZpZWxkc0ZvckV4ZWNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9maWVsZHNGb3JFeGVjID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9maWVsZHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyh0aGlzLl9maWVsZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjbG9uZSh0aGlzLl9maWVsZHMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBhbiB1cGRhdGUgZG9jdW1lbnQgd2l0aCBjb3JyZWN0ZWQgYCRzZXRgIG9wZXJhdGlvbnMuXG4gKlxuICogQG1ldGhvZCBfdXBkYXRlRm9yRXhlY1xuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX3VwZGF0ZUZvckV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgdXBkYXRlID0gY2xvbmUodGhpcy5fdXBkYXRlLCB7XG4gICAgdHJhbnNmb3JtOiBmYWxzZSxcbiAgICBkZXBvcHVsYXRlOiB0cnVlXG4gIH0pO1xuICBjb25zdCBvcHMgPSBPYmplY3Qua2V5cyh1cGRhdGUpO1xuICBsZXQgaSA9IG9wcy5sZW5ndGg7XG4gIGNvbnN0IHJldCA9IHt9O1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBvcCA9IG9wc1tpXTtcblxuICAgIGlmICh0aGlzLl9tb25nb29zZU9wdGlvbnMub3ZlcndyaXRlKSB7XG4gICAgICByZXRbb3BdID0gdXBkYXRlW29wXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgnJCcgIT09IG9wWzBdKSB7XG4gICAgICAvLyBmaXggdXAgJHNldCBzdWdhclxuICAgICAgaWYgKCFyZXQuJHNldCkge1xuICAgICAgICBpZiAodXBkYXRlLiRzZXQpIHtcbiAgICAgICAgICByZXQuJHNldCA9IHVwZGF0ZS4kc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC4kc2V0ID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldC4kc2V0W29wXSA9IHVwZGF0ZVtvcF07XG4gICAgICBvcHMuc3BsaWNlKGksIDEpO1xuICAgICAgaWYgKCF+b3BzLmluZGV4T2YoJyRzZXQnKSkgb3BzLnB1c2goJyRzZXQnKTtcbiAgICB9IGVsc2UgaWYgKCckc2V0JyA9PT0gb3ApIHtcbiAgICAgIGlmICghcmV0LiRzZXQpIHtcbiAgICAgICAgcmV0W29wXSA9IHVwZGF0ZVtvcF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIE1ha2VzIHN1cmUgX3BhdGggaXMgc2V0LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGluaGVyaXRlZCBieSBgbXF1ZXJ5YFxuICpcbiAqIEBtZXRob2QgX2Vuc3VyZVBhdGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKi9cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBjb25kc2AgY2FuIGJlIG1lcmdlZCB1c2luZyBgbXF1ZXJ5KCkubWVyZ2UoKWBcbiAqXG4gKiBAbWV0aG9kIGNhbk1lcmdlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmRzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhpcyBxdWVyeS5cbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9vcHRpb25zRm9yRXhlYyA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjbG9uZSh0aGlzLm9wdGlvbnMpO1xuICBkZWxldGUgb3B0aW9ucy5wb3B1bGF0ZTtcbiAgbW9kZWwgPSBtb2RlbCB8fCB0aGlzLm1vZGVsO1xuXG4gIGlmICghbW9kZWwpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICAvLyBBcHBseSBzY2hlbWEtbGV2ZWwgYHdyaXRlQ29uY2VybmAgb3B0aW9uXG4gIGFwcGx5V3JpdGVDb25jZXJuKG1vZGVsLnNjaGVtYSwgb3B0aW9ucyk7XG5cbiAgY29uc3QgYXN5bmNMb2NhbFN0b3JhZ2UgPSB0aGlzLm1vZGVsPy5kYj8uYmFzZS50cmFuc2FjdGlvbkFzeW5jTG9jYWxTdG9yYWdlPy5nZXRTdG9yZSgpO1xuICBpZiAoIXRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2Vzc2lvbicpICYmIGFzeW5jTG9jYWxTdG9yYWdlPy5zZXNzaW9uICE9IG51bGwpIHtcbiAgICBvcHRpb25zLnNlc3Npb24gPSBhc3luY0xvY2FsU3RvcmFnZS5zZXNzaW9uO1xuICB9XG5cbiAgY29uc3QgcmVhZFByZWZlcmVuY2UgPSBtb2RlbCAmJlxuICBtb2RlbC5zY2hlbWEgJiZcbiAgbW9kZWwuc2NoZW1hLm9wdGlvbnMgJiZcbiAgbW9kZWwuc2NoZW1hLm9wdGlvbnMucmVhZDtcbiAgaWYgKCEoJ3JlYWRQcmVmZXJlbmNlJyBpbiBvcHRpb25zKSAmJiByZWFkUHJlZmVyZW5jZSkge1xuICAgIG9wdGlvbnMucmVhZFByZWZlcmVuY2UgPSByZWFkUHJlZmVyZW5jZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnVwc2VydCAhPT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucy51cHNlcnQgPSAhIW9wdGlvbnMudXBzZXJ0O1xuICB9XG4gIGlmIChvcHRpb25zLndyaXRlQ29uY2Vybikge1xuICAgIGlmIChvcHRpb25zLmopIHtcbiAgICAgIG9wdGlvbnMud3JpdGVDb25jZXJuLmogPSBvcHRpb25zLmo7XG4gICAgICBkZWxldGUgb3B0aW9ucy5qO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53KSB7XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2Vybi53ID0gb3B0aW9ucy53O1xuICAgICAgZGVsZXRlIG9wdGlvbnMudztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud3RpbWVvdXQpIHtcbiAgICAgIG9wdGlvbnMud3JpdGVDb25jZXJuLnd0aW1lb3V0ID0gb3B0aW9ucy53dGltZW91dDtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnd0aW1lb3V0O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2FwcGx5UGF0aHMoKTtcbiAgaWYgKHRoaXMuX2ZpZWxkcyAhPSBudWxsKSB7XG4gICAgdGhpcy5fZmllbGRzID0gdGhpcy5fY2FzdEZpZWxkcyh0aGlzLl9maWVsZHMpO1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gICAgaWYgKHByb2plY3Rpb24gIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5wcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbGVhbiBvcHRpb24uXG4gKlxuICogRG9jdW1lbnRzIHJldHVybmVkIGZyb20gcXVlcmllcyB3aXRoIHRoZSBgbGVhbmAgb3B0aW9uIGVuYWJsZWQgYXJlIHBsYWluXG4gKiBqYXZhc2NyaXB0IG9iamVjdHMsIG5vdCBbTW9uZ29vc2UgRG9jdW1lbnRzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwpLiBUaGV5IGhhdmUgbm9cbiAqIGBzYXZlYCBtZXRob2QsIGdldHRlcnMvc2V0dGVycywgdmlydHVhbHMsIG9yIG90aGVyIE1vbmdvb3NlIGZlYXR1cmVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkubGVhbigpIC8vIHRydWVcbiAqICAgICBuZXcgUXVlcnkoKS5sZWFuKHRydWUpXG4gKiAgICAgbmV3IFF1ZXJ5KCkubGVhbihmYWxzZSlcbiAqXG4gKiAgICAgY29uc3QgZG9jcyA9IGF3YWl0IE1vZGVsLmZpbmQoKS5sZWFuKCk7XG4gKiAgICAgZG9jc1swXSBpbnN0YW5jZW9mIG1vbmdvb3NlLkRvY3VtZW50OyAvLyBmYWxzZVxuICpcbiAqIFtMZWFuIGlzIGdyZWF0IGZvciBoaWdoLXBlcmZvcm1hbmNlLCByZWFkLW9ubHkgY2FzZXNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sKSxcbiAqIGVzcGVjaWFsbHkgd2hlbiBjb21iaW5lZFxuICogd2l0aCBbY3Vyc29yc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3F1ZXJpZXMuaHRtbCNzdHJlYW1pbmcpLlxuICpcbiAqIElmIHlvdSBuZWVkIHZpcnR1YWxzLCBnZXR0ZXJzL3NldHRlcnMsIG9yIGRlZmF1bHRzIHdpdGggYGxlYW4oKWAsIHlvdSBuZWVkXG4gKiB0byB1c2UgYSBwbHVnaW4uIFNlZTpcbiAqXG4gKiAtIFttb25nb29zZS1sZWFuLXZpcnR1YWxzXShodHRwczovL3BsdWdpbnMubW9uZ29vc2Vqcy5pby9wbHVnaW5zL2xlYW4tdmlydHVhbHMpXG4gKiAtIFttb25nb29zZS1sZWFuLWdldHRlcnNdKGh0dHBzOi8vcGx1Z2lucy5tb25nb29zZWpzLmlvL3BsdWdpbnMvbGVhbi1nZXR0ZXJzKVxuICogLSBbbW9uZ29vc2UtbGVhbi1kZWZhdWx0c10oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9uZ29vc2UtbGVhbi1kZWZhdWx0cylcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBib29sIGRlZmF1bHRzIHRvIHRydWVcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5sZWFuID0gZnVuY3Rpb24odikge1xuICB0aGlzLl9tb25nb29zZU9wdGlvbnMubGVhbiA9IGFyZ3VtZW50cy5sZW5ndGggPyB2IDogdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBgJHNldGAgdG8gdGhpcyBxdWVyeSdzIHVwZGF0ZSB3aXRob3V0IGNoYW5naW5nIHRoZSBvcGVyYXRpb24uXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgcXVlcnkgbWlkZGxld2FyZSBzbyB5b3UgY2FuIGFkZCBhbiB1cGRhdGUgcmVnYXJkbGVzc1xuICogb2Ygd2hldGhlciB5b3UgdXNlIGB1cGRhdGVPbmUoKWAsIGB1cGRhdGVNYW55KClgLCBgZmluZE9uZUFuZFVwZGF0ZSgpYCwgZXRjLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gVXBkYXRlcyBgeyAkc2V0OiB7IHVwZGF0ZWRBdDogbmV3IERhdGUoKSB9IH1gXG4gKiAgICAgbmV3IFF1ZXJ5KCkudXBkYXRlT25lKHt9LCB7fSkuc2V0KCd1cGRhdGVkQXQnLCBuZXcgRGF0ZSgpKTtcbiAqICAgICBuZXcgUXVlcnkoKS51cGRhdGVNYW55KHt9LCB7fSkuc2V0KHsgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpIH0pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcGF0aCBwYXRoIG9yIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgdG8gc2V0XG4gKiBAcGFyYW0ge0FueX0gW3ZhbF0gdGhlIHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHBhdGgsIHZhbCkge1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBhdGgpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgcGF0aFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl91cGRhdGUgPSB0aGlzLl91cGRhdGUgfHwge307XG4gIGlmIChwYXRoIGluIHRoaXMuX3VwZGF0ZSkge1xuICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVbcGF0aF07XG4gIH1cbiAgdGhpcy5fdXBkYXRlLiRzZXQgPSB0aGlzLl91cGRhdGUuJHNldCB8fCB7fTtcbiAgdGhpcy5fdXBkYXRlLiRzZXRbcGF0aF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGb3IgdXBkYXRlIG9wZXJhdGlvbnMsIHJldHVybnMgdGhlIHZhbHVlIG9mIGEgcGF0aCBpbiB0aGUgdXBkYXRlJ3MgYCRzZXRgLlxuICogVXNlZnVsIGZvciB3cml0aW5nIGdldHRlcnMvc2V0dGVycyB0aGF0IGNhbiB3b3JrIHdpdGggYm90aCB1cGRhdGUgb3BlcmF0aW9uc1xuICogYW5kIGBzYXZlKClgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBNb2RlbC51cGRhdGVPbmUoe30sIHsgJHNldDogeyBuYW1lOiAnSmVhbi1MdWMgUGljYXJkJyB9IH0pO1xuICogICAgIHF1ZXJ5LmdldCgnbmFtZScpOyAvLyAnSmVhbi1MdWMgUGljYXJkJ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcGF0aCBwYXRoIG9yIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgdG8gZ2V0XG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KHBhdGgpIHtcbiAgY29uc3QgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICBpZiAodXBkYXRlID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0ICRzZXQgPSB1cGRhdGUuJHNldDtcbiAgaWYgKCRzZXQgPT0gbnVsbCkge1xuICAgIHJldHVybiB1cGRhdGVbcGF0aF07XG4gIH1cblxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh1cGRhdGUsIHBhdGgpKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVtwYXRoXTtcbiAgfVxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSgkc2V0LCBwYXRoKSkge1xuICAgIHJldHVybiAkc2V0W3BhdGhdO1xuICB9XG5cbiAgcmV0dXJuIHZvaWQgMDtcbn07XG5cbi8qKlxuICogR2V0cy9zZXRzIHRoZSBlcnJvciBmbGFnIG9uIHRoaXMgcXVlcnkuIElmIHRoaXMgZmxhZyBpcyBub3QgbnVsbCBvclxuICogdW5kZWZpbmVkLCB0aGUgYGV4ZWMoKWAgcHJvbWlzZSB3aWxsIHJlamVjdCB3aXRob3V0IGV4ZWN1dGluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFF1ZXJ5KCkuZXJyb3IoKTsgLy8gR2V0IGN1cnJlbnQgZXJyb3IgdmFsdWVcbiAqICAgICBRdWVyeSgpLmVycm9yKG51bGwpOyAvLyBVbnNldCB0aGUgY3VycmVudCBlcnJvclxuICogICAgIFF1ZXJ5KCkuZXJyb3IobmV3IEVycm9yKCd0ZXN0JykpOyAvLyBgZXhlYygpYCB3aWxsIHJlc29sdmUgd2l0aCB0ZXN0XG4gKiAgICAgU2NoZW1hLnByZSgnZmluZCcsIGZ1bmN0aW9uKCkge1xuICogICAgICAgaWYgKCF0aGlzLmdldFF1ZXJ5KCkudXNlcklkKSB7XG4gKiAgICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdOb3QgYWxsb3dlZCB0byBxdWVyeSB3aXRob3V0IHNldHRpbmcgdXNlcklkJykpO1xuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIE5vdGUgdGhhdCBxdWVyeSBjYXN0aW5nIHJ1bnMgKiphZnRlcioqIGhvb2tzLCBzbyBjYXN0IGVycm9ycyB3aWxsIG92ZXJyaWRlXG4gKiBjdXN0b20gZXJyb3JzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgVGVzdFNjaGVtYSA9IG5ldyBTY2hlbWEoeyBudW06IE51bWJlciB9KTtcbiAqICAgICBjb25zdCBUZXN0TW9kZWwgPSBkYi5tb2RlbCgnVGVzdCcsIFRlc3RTY2hlbWEpO1xuICogICAgIFRlc3RNb2RlbC5maW5kKHsgbnVtOiAnbm90IGEgbnVtYmVyJyB9KS5lcnJvcihuZXcgRXJyb3IoJ3dvb3BzJykpLmV4ZWMoZnVuY3Rpb24oZXJyb3IpIHtcbiAqICAgICAgIC8vIGBlcnJvcmAgd2lsbCBiZSBhIGNhc3QgZXJyb3IgYmVjYXVzZSBgbnVtYCBmYWlsZWQgdG8gY2FzdFxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyIGlmIHNldCwgYGV4ZWMoKWAgd2lsbCBmYWlsIGZhc3QgYmVmb3JlIHNlbmRpbmcgdGhlIHF1ZXJ5IHRvIE1vbmdvREJcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKGVycikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgfVxuXG4gIHRoaXMuX2Vycm9yID0gZXJyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogaWdub3JlXG4gKiBAbWV0aG9kIF91bnNldENhc3RFcnJvclxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fdW5zZXRDYXN0RXJyb3IgPSBmdW5jdGlvbiBfdW5zZXRDYXN0RXJyb3IoKSB7XG4gIGlmICh0aGlzLl9lcnJvciAhPSBudWxsICYmICEodGhpcy5fZXJyb3IgaW5zdGFuY2VvZiBDYXN0RXJyb3IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0aGlzLmVycm9yKG51bGwpO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIvc2V0dGVyIGFyb3VuZCB0aGUgY3VycmVudCBtb25nb29zZS1zcGVjaWZpYyBvcHRpb25zIGZvciB0aGlzIHF1ZXJ5XG4gKiBCZWxvdyBhcmUgdGhlIGN1cnJlbnQgTW9uZ29vc2Utc3BlY2lmaWMgb3B0aW9ucy5cbiAqXG4gKiAtIGBwb3B1bGF0ZWA6IGFuIGFycmF5IHJlcHJlc2VudGluZyB3aGF0IHBhdGhzIHdpbGwgYmUgcG9wdWxhdGVkLiBTaG91bGQgaGF2ZSBvbmUgZW50cnkgZm9yIGVhY2ggY2FsbCB0byBbYFF1ZXJ5LnByb3RvdHlwZS5wb3B1bGF0ZSgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5wb3B1bGF0ZSgpKVxuICogLSBgbGVhbmA6IGlmIHRydXRoeSwgTW9uZ29vc2Ugd2lsbCBub3QgW2h5ZHJhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5oeWRyYXRlKCkpIGFueSBkb2N1bWVudHMgdGhhdCBhcmUgcmV0dXJuZWQgZnJvbSB0aGlzIHF1ZXJ5LiBTZWUgW2BRdWVyeS5wcm90b3R5cGUubGVhbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogLSBgc3RyaWN0YDogY29udHJvbHMgaG93IE1vbmdvb3NlIGhhbmRsZXMga2V5cyB0aGF0IGFyZW4ndCBpbiB0aGUgc2NoZW1hIGZvciB1cGRhdGVzLiBUaGlzIG9wdGlvbiBpcyBgdHJ1ZWAgYnkgZGVmYXVsdCwgd2hpY2ggbWVhbnMgTW9uZ29vc2Ugd2lsbCBzaWxlbnRseSBzdHJpcCBhbnkgcGF0aHMgaW4gdGhlIHVwZGF0ZSB0aGF0IGFyZW4ndCBpbiB0aGUgc2NoZW1hLiBTZWUgdGhlIFtgc3RyaWN0YCBtb2RlIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdCkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiAtIGBzdHJpY3RRdWVyeWA6IGNvbnRyb2xzIGhvdyBNb25nb29zZSBoYW5kbGVzIGtleXMgdGhhdCBhcmVuJ3QgaW4gdGhlIHNjaGVtYSBmb3IgdGhlIHF1ZXJ5IGBmaWx0ZXJgLiBUaGlzIG9wdGlvbiBpcyBgZmFsc2VgIGJ5IGRlZmF1bHQsIHdoaWNoIG1lYW5zIE1vbmdvb3NlIHdpbGwgYWxsb3cgYE1vZGVsLmZpbmQoeyBmb286ICdiYXInIH0pYCBldmVuIGlmIGBmb29gIGlzIG5vdCBpbiB0aGUgc2NoZW1hLiBTZWUgdGhlIFtgc3RyaWN0UXVlcnlgIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdFF1ZXJ5KSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIC0gYG5lYXJTcGhlcmVgOiB1c2UgYCRuZWFyU3BoZXJlYCBpbnN0ZWFkIG9mIGBuZWFyKClgLiBTZWUgdGhlIFtgUXVlcnkucHJvdG90eXBlLm5lYXJTcGhlcmUoKWAgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5uZWFyU3BoZXJlKCkpXG4gKlxuICogTW9uZ29vc2UgbWFpbnRhaW5zIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBpbnRlcm5hbCBvcHRpb25zIGJlY2F1c2VcbiAqIE1vbmdvb3NlIHNlbmRzIGBRdWVyeS5wcm90b3R5cGUub3B0aW9uc2AgdG8gdGhlIE1vbmdvREIgc2VydmVyLCBhbmQgdGhlXG4gKiBhYm92ZSBvcHRpb25zIGFyZSBub3QgcmVsZXZhbnQgZm9yIHRoZSBNb25nb0RCIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBpZiBzcGVjaWZpZWQsIG92ZXJ3cml0ZXMgdGhlIGN1cnJlbnQgb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubW9uZ29vc2VPcHRpb25zID0gZnVuY3Rpb24odikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMgPSB2O1xuICB9XG4gIHJldHVybiB0aGlzLl9tb25nb29zZU9wdGlvbnM7XG59O1xuXG4vKipcbiAqIGlnbm9yZVxuICogQG1ldGhvZCBfY2FzdENvbmRpdGlvbnNcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGFwaSBwcml2YXRlXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2Nhc3RDb25kaXRpb25zID0gZnVuY3Rpb24oKSB7XG4gIGxldCBzYW5pdGl6ZUZpbHRlck9wdCA9IHVuZGVmaW5lZDtcbiAgaWYgKHRoaXMubW9kZWwgIT0gbnVsbCAmJiB1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KHRoaXMubW9kZWwuZGIub3B0aW9ucywgJ3Nhbml0aXplRmlsdGVyJykpIHtcbiAgICBzYW5pdGl6ZUZpbHRlck9wdCA9IHRoaXMubW9kZWwuZGIub3B0aW9ucy5zYW5pdGl6ZUZpbHRlcjtcbiAgfSBlbHNlIGlmICh0aGlzLm1vZGVsICE9IG51bGwgJiYgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucywgJ3Nhbml0aXplRmlsdGVyJykpIHtcbiAgICBzYW5pdGl6ZUZpbHRlck9wdCA9IHRoaXMubW9kZWwuYmFzZS5vcHRpb25zLnNhbml0aXplRmlsdGVyO1xuICB9IGVsc2Uge1xuICAgIHNhbml0aXplRmlsdGVyT3B0ID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zLnNhbml0aXplRmlsdGVyO1xuICB9XG5cbiAgaWYgKHNhbml0aXplRmlsdGVyT3B0KSB7XG4gICAgc2FuaXRpemVGaWx0ZXIodGhpcy5fY29uZGl0aW9ucyk7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMuY2FzdCh0aGlzLm1vZGVsKTtcbiAgICB0aGlzLl91bnNldENhc3RFcnJvcigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLmVycm9yKGVycik7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2Nhc3RBcnJheUZpbHRlcnMocXVlcnkpIHtcbiAgdHJ5IHtcbiAgICBjYXN0QXJyYXlGaWx0ZXJzKHF1ZXJ5KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcXVlcnkuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4ZWN1dGUgYSBgZmluZCgpYFxuICpcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmQoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSAhPSBudWxsKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgY29uc3QgbW9uZ29vc2VPcHRpb25zID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zO1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGNvbnN0IHVzZXJQcm92aWRlZEZpZWxkcyA9IF90aGlzLl91c2VyUHJvdmlkZWRGaWVsZHMgfHwge307XG5cbiAgYXBwbHlHbG9iYWxNYXhUaW1lTVModGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsKTtcbiAgYXBwbHlHbG9iYWxEaXNrVXNlKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbCk7XG5cbiAgLy8gU2VwYXJhdGUgb3B0aW9ucyB0byBwYXNzIGRvd24gdG8gYGNvbXBsZXRlTWFueSgpYCBpbiBjYXNlIHdlIG5lZWQgdG9cbiAgLy8gc2V0IGEgc2Vzc2lvbiBvbiB0aGUgZG9jdW1lbnRcbiAgY29uc3QgY29tcGxldGVNYW55T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICBzZXNzaW9uOiB0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuc2Vzc2lvbiB8fCBudWxsLFxuICAgIGxlYW46IG1vbmdvb3NlT3B0aW9ucy5sZWFuIHx8IG51bGxcbiAgfSk7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIGNvbnN0IGZpbHRlciA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IGZpZWxkcyA9IG9wdGlvbnMucHJvamVjdGlvbjtcblxuICBjb25zdCBjdXJzb3IgPSBhd2FpdCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb24uZmluZChmaWx0ZXIsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5leHBsYWluKSB7XG4gICAgcmV0dXJuIGN1cnNvci5leHBsYWluKCk7XG4gIH1cblxuICBsZXQgZG9jcyA9IGF3YWl0IGN1cnNvci50b0FycmF5KCk7XG4gIGlmIChkb2NzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkb2NzO1xuICB9XG5cbiAgaWYgKCFtb25nb29zZU9wdGlvbnMucG9wdWxhdGUpIHtcbiAgICBjb25zdCB2ZXJzaW9uS2V5ID0gX3RoaXMuc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleTtcbiAgICBpZiAobW9uZ29vc2VPcHRpb25zLmxlYW4gJiYgbW9uZ29vc2VPcHRpb25zLmxlYW4udmVyc2lvbktleSA9PT0gZmFsc2UgJiYgdmVyc2lvbktleSkge1xuICAgICAgZG9jcy5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgaWYgKHZlcnNpb25LZXkgaW4gZG9jKSB7XG4gICAgICAgICAgZGVsZXRlIGRvY1t2ZXJzaW9uS2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb25nb29zZU9wdGlvbnMubGVhbiA/XG4gICAgICBfY29tcGxldGVNYW55TGVhbihfdGhpcy5tb2RlbC5zY2hlbWEsIGRvY3MsIG51bGwsIGNvbXBsZXRlTWFueU9wdGlvbnMpIDpcbiAgICAgIGNvbXBsZXRlTWFueShfdGhpcy5tb2RlbCwgZG9jcywgZmllbGRzLCB1c2VyUHJvdmlkZWRGaWVsZHMsIGNvbXBsZXRlTWFueU9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IHBvcCA9IGhlbHBlcnMucHJlcGFyZVBvcHVsYXRpb25PcHRpb25zTVEoX3RoaXMsIG1vbmdvb3NlT3B0aW9ucyk7XG5cbiAgaWYgKG1vbmdvb3NlT3B0aW9ucy5sZWFuKSB7XG4gICAgcmV0dXJuIF90aGlzLm1vZGVsLnBvcHVsYXRlKGRvY3MsIHBvcCk7XG4gIH1cblxuICBkb2NzID0gYXdhaXQgY29tcGxldGVNYW55KF90aGlzLm1vZGVsLCBkb2NzLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgY29tcGxldGVNYW55T3B0aW9ucyk7XG4gIGF3YWl0IHRoaXMubW9kZWwucG9wdWxhdGUoZG9jcywgcG9wKTtcblxuICByZXR1cm4gZG9jcztcbn07XG5cbi8qKlxuICogRmluZCBhbGwgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggYHNlbGVjdG9yYC4gVGhlIHJlc3VsdCB3aWxsIGJlIGFuIGFycmF5IG9mIGRvY3VtZW50cy5cbiAqXG4gKiBJZiB0aGVyZSBhcmUgdG9vIG1hbnkgZG9jdW1lbnRzIGluIHRoZSByZXN1bHQgdG8gZml0IGluIG1lbW9yeSwgdXNlXG4gKiBbYFF1ZXJ5LnByb3RvdHlwZS5jdXJzb3IoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY3Vyc29yKCkpXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhcnIgPSBhd2FpdCBNb3ZpZS5maW5kKHsgeWVhcjogeyAkZ3RlOiAxOTgwLCAkbHRlOiAxOTg5IH0gfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R8T2JqZWN0SWR9IFtmaWx0ZXJdIG1vbmdvZGIgZmlsdGVyLiBJZiBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGFsbCBkb2N1bWVudHMuXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGNvbmRpdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5maW5kKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5vcCA9ICdmaW5kJztcblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGNvbmRpdGlvbnMpKSB7XG4gICAgdGhpcy5tZXJnZShjb25kaXRpb25zKTtcblxuICAgIHByZXBhcmVEaXNjcmltaW5hdG9yQ3JpdGVyaWEodGhpcyk7XG4gIH0gZWxzZSBpZiAoY29uZGl0aW9ucyAhPSBudWxsKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoY29uZGl0aW9ucywgJ2ZpbHRlcicsICdmaW5kJykpO1xuICB9XG5cbiAgUXVlcnkuYmFzZS5maW5kLmNhbGwodGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1lcmdlcyBhbm90aGVyIFF1ZXJ5IG9yIGNvbmRpdGlvbnMgb2JqZWN0IGludG8gdGhpcyBvbmUuXG4gKlxuICogV2hlbiBhIFF1ZXJ5IGlzIHBhc3NlZCwgY29uZGl0aW9ucywgZmllbGQgc2VsZWN0aW9uIGFuZCBvcHRpb25zIGFyZSBtZXJnZWQuXG4gKlxuICogQHBhcmFtIHtRdWVyeXxPYmplY3R9IHNvdXJjZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgaWYgKCFzb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSB7IG92ZXJ3cml0ZTogdHJ1ZSB9O1xuXG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBRdWVyeSkge1xuICAgIC8vIGlmIHNvdXJjZSBoYXMgYSBmZWF0dXJlLCBhcHBseSBpdCB0byBvdXJzZWx2ZXNcblxuICAgIGlmIChzb3VyY2UuX2NvbmRpdGlvbnMpIHtcbiAgICAgIG9wdHMub21pdCA9IHt9O1xuICAgICAgaWYgKHRoaXMuX2NvbmRpdGlvbnMgJiYgdGhpcy5fY29uZGl0aW9ucy4kYW5kICYmIHNvdXJjZS5fY29uZGl0aW9ucy4kYW5kKSB7XG4gICAgICAgIG9wdHMub21pdFsnJGFuZCddID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY29uZGl0aW9ucy4kYW5kID0gdGhpcy5fY29uZGl0aW9ucy4kYW5kLmNvbmNhdChzb3VyY2UuX2NvbmRpdGlvbnMuJGFuZCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY29uZGl0aW9ucyAmJiB0aGlzLl9jb25kaXRpb25zLiRvciAmJiBzb3VyY2UuX2NvbmRpdGlvbnMuJG9yKSB7XG4gICAgICAgIG9wdHMub21pdFsnJG9yJ10gPSB0cnVlO1xuICAgICAgICB0aGlzLl9jb25kaXRpb25zLiRvciA9IHRoaXMuX2NvbmRpdGlvbnMuJG9yLmNvbmNhdChzb3VyY2UuX2NvbmRpdGlvbnMuJG9yKTtcbiAgICAgIH1cbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMuX2NvbmRpdGlvbnMsIHNvdXJjZS5fY29uZGl0aW9ucywgb3B0cyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5fZmllbGRzKSB7XG4gICAgICB0aGlzLl9maWVsZHMgfHwgKHRoaXMuX2ZpZWxkcyA9IHt9KTtcbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMuX2ZpZWxkcywgc291cmNlLl9maWVsZHMsIG9wdHMpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2Uub3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zIHx8ICh0aGlzLm9wdGlvbnMgPSB7fSk7XG4gICAgICB1dGlscy5tZXJnZSh0aGlzLm9wdGlvbnMsIHNvdXJjZS5vcHRpb25zLCBvcHRzKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl91cGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSB8fCAodGhpcy5fdXBkYXRlID0ge30pO1xuICAgICAgdXRpbHMubWVyZ2VDbG9uZSh0aGlzLl91cGRhdGUsIHNvdXJjZS5fdXBkYXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl9kaXN0aW5jdCkge1xuICAgICAgdGhpcy5fZGlzdGluY3QgPSBzb3VyY2UuX2Rpc3RpbmN0O1xuICAgIH1cblxuICAgIHV0aWxzLm1lcmdlKHRoaXMuX21vbmdvb3NlT3B0aW9ucywgc291cmNlLl9tb25nb29zZU9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSBpZiAodGhpcy5tb2RlbCAhPSBudWxsICYmIHNvdXJjZSBpbnN0YW5jZW9mIHRoaXMubW9kZWwuYmFzZS5UeXBlcy5PYmplY3RJZCkge1xuICAgIHV0aWxzLm1lcmdlKHRoaXMuX2NvbmRpdGlvbnMsIHsgX2lkOiBzb3VyY2UgfSwgb3B0cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmIChzb3VyY2UgJiYgc291cmNlLiRfXykge1xuICAgIHNvdXJjZSA9IHNvdXJjZS50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gIH1cblxuICBvcHRzLm9taXQgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlLiRhbmQpKSB7XG4gICAgb3B0cy5vbWl0WyckYW5kJ10gPSB0cnVlO1xuICAgIGlmICghdGhpcy5fY29uZGl0aW9ucykge1xuICAgICAgdGhpcy5fY29uZGl0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLl9jb25kaXRpb25zLiRhbmQgPSAodGhpcy5fY29uZGl0aW9ucy4kYW5kIHx8IFtdKS5jb25jYXQoXG4gICAgICBzb3VyY2UuJGFuZC5tYXAoZWwgPT4gdXRpbHMuaXNQT0pPKGVsKSA/IHV0aWxzLm1lcmdlKHt9LCBlbCkgOiBlbClcbiAgICApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZS4kb3IpKSB7XG4gICAgb3B0cy5vbWl0Wyckb3InXSA9IHRydWU7XG4gICAgaWYgKCF0aGlzLl9jb25kaXRpb25zKSB7XG4gICAgICB0aGlzLl9jb25kaXRpb25zID0ge307XG4gICAgfVxuICAgIHRoaXMuX2NvbmRpdGlvbnMuJG9yID0gKHRoaXMuX2NvbmRpdGlvbnMuJG9yIHx8IFtdKS5jb25jYXQoXG4gICAgICBzb3VyY2UuJG9yLm1hcChlbCA9PiB1dGlscy5pc1BPSk8oZWwpID8gdXRpbHMubWVyZ2Uoe30sIGVsKSA6IGVsKVxuICAgICk7XG4gIH1cblxuICAvLyBwbGFpbiBvYmplY3RcbiAgdXRpbHMubWVyZ2UodGhpcy5fY29uZGl0aW9ucywgc291cmNlLCBvcHRzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGNvbGxhdGlvbiB0byB0aGlzIG9wIChNb25nb0RCIDMuNCBhbmQgdXApXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBNb25nb0RCIGRvY3MgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IuY29sbGF0aW9uLyNjdXJzb3IuY29sbGF0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jb2xsYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodGhpcy5vcHRpb25zID09IG51bGwpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgfVxuICB0aGlzLm9wdGlvbnMuY29sbGF0aW9uID0gdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBIeWRyYXRlIGEgc2luZ2xlIGRvYyBmcm9tIGBmaW5kT25lKClgLCBgZmluZE9uZUFuZFVwZGF0ZSgpYCwgZXRjLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fY29tcGxldGVPbmUgPSBmdW5jdGlvbihkb2MsIHJlcywgY2FsbGJhY2spIHtcbiAgaWYgKCFkb2MgJiYgIXRoaXMub3B0aW9ucy5yYXdSZXN1bHQgJiYgIXRoaXMub3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGEpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gIH1cblxuICBjb25zdCBtb2RlbCA9IHRoaXMubW9kZWw7XG4gIGNvbnN0IHByb2plY3Rpb24gPSBjbG9uZSh0aGlzLl9maWVsZHMpO1xuICBjb25zdCB1c2VyUHJvdmlkZWRGaWVsZHMgPSB0aGlzLl91c2VyUHJvdmlkZWRGaWVsZHMgfHwge307XG4gIC8vIGBwb3B1bGF0ZWAsIGBsZWFuYFxuICBjb25zdCBtb25nb29zZU9wdGlvbnMgPSB0aGlzLl9tb25nb29zZU9wdGlvbnM7XG4gIC8vIGByYXdSZXN1bHRgXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIGlmICghb3B0aW9ucy5sZWFuICYmIG1vbmdvb3NlT3B0aW9ucy5sZWFuKSB7XG4gICAgb3B0aW9ucy5sZWFuID0gbW9uZ29vc2VPcHRpb25zLmxlYW47XG4gIH1cblxuICBpZiAob3B0aW9ucy5leHBsYWluKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRvYyk7XG4gIH1cblxuICBpZiAoIW1vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZSkge1xuICAgIGNvbnN0IHZlcnNpb25LZXkgPSB0aGlzLnNjaGVtYS5vcHRpb25zLnZlcnNpb25LZXk7XG4gICAgaWYgKG1vbmdvb3NlT3B0aW9ucy5sZWFuICYmIG1vbmdvb3NlT3B0aW9ucy5sZWFuLnZlcnNpb25LZXkgPT09IGZhbHNlICYmIHZlcnNpb25LZXkpIHtcbiAgICAgIGlmICh2ZXJzaW9uS2V5IGluIGRvYykge1xuICAgICAgICBkZWxldGUgZG9jW3ZlcnNpb25LZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW9uZ29vc2VPcHRpb25zLmxlYW4gP1xuICAgICAgX2NvbXBsZXRlT25lTGVhbihtb2RlbC5zY2hlbWEsIGRvYywgbnVsbCwgcmVzLCBvcHRpb25zLCBjYWxsYmFjaykgOlxuICAgICAgY29tcGxldGVPbmUobW9kZWwsIGRvYywgcmVzLCBvcHRpb25zLCBwcm9qZWN0aW9uLCB1c2VyUHJvdmlkZWRGaWVsZHMsXG4gICAgICAgIG51bGwsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGNvbnN0IHBvcCA9IGhlbHBlcnMucHJlcGFyZVBvcHVsYXRpb25PcHRpb25zTVEodGhpcywgdGhpcy5fbW9uZ29vc2VPcHRpb25zKTtcbiAgaWYgKG1vbmdvb3NlT3B0aW9ucy5sZWFuKSB7XG4gICAgcmV0dXJuIG1vZGVsLnBvcHVsYXRlKGRvYywgcG9wKS50aGVuKFxuICAgICAgZG9jID0+IHtcbiAgICAgICAgX2NvbXBsZXRlT25lTGVhbihtb2RlbC5zY2hlbWEsIGRvYywgbnVsbCwgcmVzLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICB9LFxuICAgICAgZXJyb3IgPT4ge1xuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGNvbXBsZXRlT25lKG1vZGVsLCBkb2MsIHJlcywgb3B0aW9ucywgcHJvamVjdGlvbiwgdXNlclByb3ZpZGVkRmllbGRzLCBbXSwgKGVyciwgZG9jKSA9PiB7XG4gICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgbW9kZWwucG9wdWxhdGUoZG9jLCBwb3ApLnRoZW4ocmVzID0+IHsgY2FsbGJhY2sobnVsbCwgcmVzKTsgfSwgZXJyID0+IHsgY2FsbGJhY2soZXJyKTsgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgdG8gZXhlY3V0ZSBhIGZpbmRPbmUoKSBvcGVyYXRpb25cbiAqXG4gKiBAc2VlIGZpbmRPbmUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmZpbmRPbmUvXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2ZpbmRPbmUgPSBhc3luYyBmdW5jdGlvbiBfZmluZE9uZSgpIHtcbiAgdGhpcy5fY2FzdENvbmRpdGlvbnMoKTtcblxuICBpZiAodGhpcy5lcnJvcigpKSB7XG4gICAgY29uc3QgZXJyID0gdGhpcy5lcnJvcigpO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIGFwcGx5R2xvYmFsTWF4VGltZU1TKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbCk7XG4gIGFwcGx5R2xvYmFsRGlza1VzZSh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICAvLyBkb24ndCBwYXNzIGluIHRoZSBjb25kaXRpb25zIGJlY2F1c2Ugd2UgYWxyZWFkeSBtZXJnZWQgdGhlbSBpblxuICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb24uZmluZE9uZSh0aGlzLl9jb25kaXRpb25zLCBvcHRpb25zKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLl9jb21wbGV0ZU9uZShkb2MsIG51bGwsIF93cmFwVGh1bmtDYWxsYmFjayh0aGlzLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIHRoZSBxdWVyeSBhIGZpbmRPbmUgb3BlcmF0aW9uLiBXaGVuIGV4ZWN1dGVkLCB0aGUgZmlyc3QgZm91bmQgZG9jdW1lbnQgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBUaGUgcmVzdWx0IG9mIHRoZSBxdWVyeSBpcyBhIHNpbmdsZSBkb2N1bWVudCwgb3IgYG51bGxgIGlmIG5vIGRvY3VtZW50IHdhcyBmb3VuZC5cbiAqXG4gKiAqICpOb3RlOiogYGNvbmRpdGlvbnNgIGlzIG9wdGlvbmFsLCBhbmQgaWYgYGNvbmRpdGlvbnNgIGlzIG51bGwgb3IgdW5kZWZpbmVkLFxuICogbW9uZ29vc2Ugd2lsbCBzZW5kIGFuIGVtcHR5IGBmaW5kT25lYCBjb21tYW5kIHRvIE1vbmdvREIsIHdoaWNoIHdpbGwgcmV0dXJuXG4gKiBhbiBhcmJpdHJhcnkgZG9jdW1lbnQuIElmIHlvdSdyZSBxdWVyeWluZyBieSBgX2lkYCwgdXNlIGBNb2RlbC5maW5kQnlJZCgpYFxuICogaW5zdGVhZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lKClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IEtpdHRlbi53aGVyZSh7IGNvbG9yOiAnd2hpdGUnIH0pO1xuICogICAgIGNvbnN0IGtpdHRlbiA9IGF3YWl0IHF1ZXJ5LmZpbmRPbmUoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2ZpbHRlcl0gbW9uZ29kYiBzZWxlY3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9qZWN0aW9uXSBvcHRpb25hbCBmaWVsZHMgdG8gcmV0dXJuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNlZSBbYHNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGZpbmRPbmUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmZpbmRPbmUvXG4gKiBAc2VlIFF1ZXJ5LnNlbGVjdCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kT25lID0gZnVuY3Rpb24oY29uZGl0aW9ucywgcHJvamVjdGlvbiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBwcm9qZWN0aW9uID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZmluZE9uZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHRoaXMub3AgPSAnZmluZE9uZSc7XG4gIHRoaXMuX3ZhbGlkYXRlT3AoKTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgdGhpcy5zZWxlY3QocHJvamVjdGlvbik7XG4gIH1cblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGNvbmRpdGlvbnMpKSB7XG4gICAgdGhpcy5tZXJnZShjb25kaXRpb25zKTtcblxuICAgIHByZXBhcmVEaXNjcmltaW5hdG9yQ3JpdGVyaWEodGhpcyk7XG4gIH0gZWxzZSBpZiAoY29uZGl0aW9ucyAhPSBudWxsKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoY29uZGl0aW9ucywgJ2ZpbHRlcicsICdmaW5kT25lJykpO1xuICB9XG5cbiAgUXVlcnkuYmFzZS5maW5kT25lLmNhbGwodGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBjb3VudCBxdWVyeVxuICpcbiAqIEBzZWUgY291bnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmNvdW50L1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9jb3VudCA9IGFzeW5jIGZ1bmN0aW9uIF9jb3VudCgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmNhc3QodGhpcy5tb2RlbCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgfVxuXG4gIGlmICh0aGlzLmVycm9yKCkpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBhcHBseUdsb2JhbE1heFRpbWVNUyh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwpO1xuICBhcHBseUdsb2JhbERpc2tVc2UodGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsKTtcblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICB0aGlzLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucyk7XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb24uY291bnQoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgY291bnREb2N1bWVudHMgcXVlcnlcbiAqXG4gKiBAc2VlIGNvdW50RG9jdW1lbnRzIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjY291bnREb2N1bWVudHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fY291bnREb2N1bWVudHMgPSBhc3luYyBmdW5jdGlvbiBfY291bnREb2N1bWVudHMoKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5jYXN0KHRoaXMubW9kZWwpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLmVycm9yKGVycik7XG4gIH1cblxuICBpZiAodGhpcy5lcnJvcigpKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgYXBwbHlHbG9iYWxNYXhUaW1lTVModGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsKTtcbiAgYXBwbHlHbG9iYWxEaXNrVXNlKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbCk7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uLmNvdW50RG9jdW1lbnRzKGNvbmRzLCBvcHRpb25zKTtcbn07XG5cbi8qIVxuICogSWYgYHRyYW5zbGF0ZUFsaWFzZXNgIG9wdGlvbiBpcyBzZXQsIGNhbGwgYE1vZGVsLnRyYW5zbGF0ZUFsaWFzZXMoKWBcbiAqIG9uIHRoZSBmb2xsb3dpbmcgcXVlcnkgcHJvcGVydGllczogZmlsdGVyLCBwcm9qZWN0aW9uLCB1cGRhdGUsIGRpc3RpbmN0LlxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzID0gZnVuY3Rpb24gX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKSB7XG4gIGxldCBhcHBseVRyYW5zbGF0ZUFsaWFzZXMgPSBmYWxzZTtcbiAgaWYgKCd0cmFuc2xhdGVBbGlhc2VzJyBpbiB0aGlzLl9tb25nb29zZU9wdGlvbnMpIHtcbiAgICBhcHBseVRyYW5zbGF0ZUFsaWFzZXMgPSB0aGlzLl9tb25nb29zZU9wdGlvbnMudHJhbnNsYXRlQWxpYXNlcztcbiAgfSBlbHNlIGlmICh0aGlzLm1vZGVsPy5zY2hlbWE/Ll91c2VyUHJvdmlkZWRPcHRpb25zPy50cmFuc2xhdGVBbGlhc2VzICE9IG51bGwpIHtcbiAgICBhcHBseVRyYW5zbGF0ZUFsaWFzZXMgPSB0aGlzLm1vZGVsLnNjaGVtYS5fdXNlclByb3ZpZGVkT3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzO1xuICB9IGVsc2UgaWYgKHRoaXMubW9kZWw/LmJhc2U/Lm9wdGlvbnM/LnRyYW5zbGF0ZUFsaWFzZXMgIT0gbnVsbCkge1xuICAgIGFwcGx5VHJhbnNsYXRlQWxpYXNlcyA9IHRoaXMubW9kZWwuYmFzZS5vcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM7XG4gIH1cbiAgaWYgKCFhcHBseVRyYW5zbGF0ZUFsaWFzZXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5tb2RlbD8uc2NoZW1hPy5hbGlhc2VzICYmIE9iamVjdC5rZXlzKHRoaXMubW9kZWwuc2NoZW1hLmFsaWFzZXMpLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLm1vZGVsLnRyYW5zbGF0ZUFsaWFzZXModGhpcy5fY29uZGl0aW9ucywgdHJ1ZSk7XG4gICAgdGhpcy5tb2RlbC50cmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMucHJvamVjdGlvbiwgdHJ1ZSk7XG4gICAgdGhpcy5tb2RlbC50cmFuc2xhdGVBbGlhc2VzKHRoaXMuX3VwZGF0ZSwgdHJ1ZSk7XG4gICAgaWYgKHRoaXMuX2Rpc3RpbmN0ICE9IG51bGwgJiYgdGhpcy5tb2RlbC5zY2hlbWEuYWxpYXNlc1t0aGlzLl9kaXN0aW5jdF0gIT0gbnVsbCkge1xuICAgICAgdGhpcy5fZGlzdGluY3QgPSB0aGlzLm1vZGVsLnNjaGVtYS5hbGlhc2VzW3RoaXMuX2Rpc3RpbmN0XTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGVzdGltYXRlZERvY3VtZW50Q291bnQoKSBxdWVyeVxuICpcbiAqIEBzZWUgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2VzdGltYXRlZERvY3VtZW50Q291bnRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fZXN0aW1hdGVkRG9jdW1lbnRDb3VudCA9IGFzeW5jIGZ1bmN0aW9uIF9lc3RpbWF0ZWREb2N1bWVudENvdW50KCkge1xuICBpZiAodGhpcy5lcnJvcigpKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbi5lc3RpbWF0ZWREb2N1bWVudENvdW50KG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhpcyBxdWVyeSBhcyBhIGBjb3VudGAgcXVlcnkuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZC4gSWYgeW91IHdhbnQgdG8gY291bnQgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgaW5cbiAqIGEgY29sbGVjdGlvbiwgZS5nLiBgY291bnQoe30pYCwgdXNlIHRoZSBbYGVzdGltYXRlZERvY3VtZW50Q291bnQoKWAgZnVuY3Rpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpKVxuICogaW5zdGVhZC4gT3RoZXJ3aXNlLCB1c2UgdGhlIFtgY291bnREb2N1bWVudHMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY291bnREb2N1bWVudHMoKSkgZnVuY3Rpb24gaW5zdGVhZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBjb3VudCgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY291bnRRdWVyeSA9IG1vZGVsLndoZXJlKHsgJ2NvbG9yJzogJ2JsYWNrJyB9KS5jb3VudCgpO1xuICpcbiAqICAgICBxdWVyeS5jb3VudCh7IGNvbG9yOiAnYmxhY2snIH0pLmNvdW50KCkuZXhlYygpO1xuICpcbiAqICAgICBhd2FpdCBxdWVyeS5jb3VudCh7IGNvbG9yOiAnYmxhY2snIH0pO1xuICpcbiAqICAgICBxdWVyeS53aGVyZSgnY29sb3InLCAnYmxhY2snKS5jb3VudCgpO1xuICpcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW2ZpbHRlcl0gY291bnQgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhpcyBvYmplY3RcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGNvdW50IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5jb3VudC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5jb3VudCgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHRoaXMub3AgPSAnY291bnQnO1xuICB0aGlzLl92YWxpZGF0ZU9wKCk7XG5cbiAgaWYgKG1xdWVyeS5jYW5NZXJnZShmaWx0ZXIpKSB7XG4gICAgdGhpcy5tZXJnZShmaWx0ZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGlzIHF1ZXJ5IGFzIGEgYGVzdGltYXRlZERvY3VtZW50Q291bnQoKWAgcXVlcnkuIEZhc3RlciB0aGFuXG4gKiB1c2luZyBgY291bnREb2N1bWVudHMoKWAgZm9yIGxhcmdlIGNvbGxlY3Rpb25zIGJlY2F1c2VcbiAqIGBlc3RpbWF0ZWREb2N1bWVudENvdW50KClgIHVzZXMgY29sbGVjdGlvbiBtZXRhZGF0YSByYXRoZXIgdGhhbiBzY2FubmluZ1xuICogdGhlIGVudGlyZSBjb2xsZWN0aW9uLlxuICpcbiAqIGBlc3RpbWF0ZWREb2N1bWVudENvdW50KClgIGRvZXMgKipub3QqKiBhY2NlcHQgYSBmaWx0ZXIuIGBNb2RlbC5maW5kKHsgZm9vOiBiYXIgfSkuZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYFxuICogaXMgZXF1aXZhbGVudCB0byBgTW9kZWwuZmluZCgpLmVzdGltYXRlZERvY3VtZW50Q291bnQoKWBcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBlc3RpbWF0ZWREb2N1bWVudENvdW50KClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBNb2RlbC5maW5kKCkuZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gcGFzc2VkIHRyYW5zcGFyZW50bHkgdG8gdGhlIFtNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL0VzdGltYXRlZERvY3VtZW50Q291bnRPcHRpb25zLmh0bWwpXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBlc3RpbWF0ZWREb2N1bWVudENvdW50IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjZXN0aW1hdGVkRG9jdW1lbnRDb3VudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXN0aW1hdGVkRG9jdW1lbnRDb3VudCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5lc3RpbWF0ZWREb2N1bWVudENvdW50KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5vcCA9ICdlc3RpbWF0ZWREb2N1bWVudENvdW50JztcbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGlzIHF1ZXJ5IGFzIGEgYGNvdW50RG9jdW1lbnRzKClgIHF1ZXJ5LiBCZWhhdmVzIGxpa2UgYGNvdW50KClgLFxuICogZXhjZXB0IGl0IGFsd2F5cyBkb2VzIGEgZnVsbCBjb2xsZWN0aW9uIHNjYW4gd2hlbiBwYXNzZWQgYW4gZW1wdHkgZmlsdGVyIGB7fWAuXG4gKlxuICogVGhlcmUgYXJlIGFsc28gbWlub3IgZGlmZmVyZW5jZXMgaW4gaG93IGBjb3VudERvY3VtZW50cygpYCBoYW5kbGVzXG4gKiBbYCR3aGVyZWAgYW5kIGEgY291cGxlIGdlb3NwYXRpYWwgb3BlcmF0b3JzXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2NvdW50RG9jdW1lbnRzKS5cbiAqIHZlcnN1cyBgY291bnQoKWAuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgY291bnREb2N1bWVudHMoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNvdW50UXVlcnkgPSBtb2RlbC53aGVyZSh7ICdjb2xvcic6ICdibGFjaycgfSkuY291bnREb2N1bWVudHMoKTtcbiAqXG4gKiAgICAgcXVlcnkuY291bnREb2N1bWVudHMoeyBjb2xvcjogJ2JsYWNrJyB9KS5jb3VudCgpLmV4ZWMoKTtcbiAqXG4gKiAgICAgYXdhaXQgcXVlcnkuY291bnREb2N1bWVudHMoeyBjb2xvcjogJ2JsYWNrJyB9KTtcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbG9yJywgJ2JsYWNrJykuY291bnREb2N1bWVudHMoKS5leGVjKCk7XG4gKlxuICogVGhlIGBjb3VudERvY3VtZW50cygpYCBmdW5jdGlvbiBpcyBzaW1pbGFyIHRvIGBjb3VudCgpYCwgYnV0IHRoZXJlIGFyZSBhXG4gKiBbZmV3IG9wZXJhdG9ycyB0aGF0IGBjb3VudERvY3VtZW50cygpYCBkb2VzIG5vdCBzdXBwb3J0XShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2NvdW50RG9jdW1lbnRzKS5cbiAqIEJlbG93IGFyZSB0aGUgb3BlcmF0b3JzIHRoYXQgYGNvdW50KClgIHN1cHBvcnRzIGJ1dCBgY291bnREb2N1bWVudHMoKWAgZG9lcyBub3QsXG4gKiBhbmQgdGhlIHN1Z2dlc3RlZCByZXBsYWNlbWVudDpcbiAqXG4gKiAtIGAkd2hlcmVgOiBbYCRleHByYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2V4cHIvKVxuICogLSBgJG5lYXJgOiBbYCRnZW9XaXRoaW5gXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvZ2VvV2l0aGluLykgd2l0aCBbYCRjZW50ZXJgXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvY2VudGVyLyNvcC5fU19jZW50ZXIpXG4gKiAtIGAkbmVhclNwaGVyZWA6IFtgJGdlb1dpdGhpbmBdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9nZW9XaXRoaW4vKSB3aXRoIFtgJGNlbnRlclNwaGVyZWBdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9jZW50ZXJTcGhlcmUvI29wLl9TX2NlbnRlclNwaGVyZSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2ZpbHRlcl0gbW9uZ29kYiBzZWxlY3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgY291bnREb2N1bWVudHMgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNjb3VudERvY3VtZW50c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY291bnREb2N1bWVudHMgPSBmdW5jdGlvbihjb25kaXRpb25zLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLmNvdW50RG9jdW1lbnRzKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5vcCA9ICdjb3VudERvY3VtZW50cyc7XG4gIHRoaXMuX3ZhbGlkYXRlT3AoKTtcblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGNvbmRpdGlvbnMpKSB7XG4gICAgdGhpcy5tZXJnZShjb25kaXRpb25zKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBgZGlzdGluY3QoKWAgcXVlcnlcbiAqXG4gKiBAc2VlIGRpc3RpbmN0IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5kaXN0aW5jdC9cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fX2Rpc3RpbmN0ID0gYXN5bmMgZnVuY3Rpb24gX19kaXN0aW5jdCgpIHtcbiAgdGhpcy5fY2FzdENvbmRpdGlvbnMoKTtcblxuICBpZiAodGhpcy5lcnJvcigpKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgYXBwbHlHbG9iYWxNYXhUaW1lTVModGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsKTtcbiAgYXBwbHlHbG9iYWxEaXNrVXNlKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbCk7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uLlxuICAgIGRpc3RpbmN0KHRoaXMuX2Rpc3RpbmN0LCB0aGlzLl9jb25kaXRpb25zLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgb3IgZXhlY3V0ZXMgYSBkaXN0aW5jdCgpIG9wZXJhdGlvbi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHRyaWdnZXIgYW55IG1pZGRsZXdhcmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBkaXN0aW5jdChmaWVsZCwgY29uZGl0aW9ucylcbiAqICAgICBkaXN0aW5jdChmaWVsZClcbiAqICAgICBkaXN0aW5jdCgpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtmaWVsZF1cbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbZmlsdGVyXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgZGlzdGluY3QgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmRpc3RpbmN0L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbihmaWVsZCwgY29uZGl0aW9ucykge1xuICBpZiAodHlwZW9mIGZpZWxkID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZGlzdGluY3QoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICB0aGlzLm9wID0gJ2Rpc3RpbmN0JztcbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuXG4gIGlmIChtcXVlcnkuY2FuTWVyZ2UoY29uZGl0aW9ucykpIHtcbiAgICB0aGlzLm1lcmdlKGNvbmRpdGlvbnMpO1xuXG4gICAgcHJlcGFyZURpc2NyaW1pbmF0b3JDcml0ZXJpYSh0aGlzKTtcbiAgfSBlbHNlIGlmIChjb25kaXRpb25zICE9IG51bGwpIHtcbiAgICB0aGlzLmVycm9yKG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihjb25kaXRpb25zLCAnZmlsdGVyJywgJ2Rpc3RpbmN0JykpO1xuICB9XG5cbiAgaWYgKGZpZWxkICE9IG51bGwpIHtcbiAgICB0aGlzLl9kaXN0aW5jdCA9IGZpZWxkO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNvcnQgb3JkZXJcbiAqXG4gKiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkLCB2YWx1ZXMgYWxsb3dlZCBhcmUgYGFzY2AsIGBkZXNjYCwgYGFzY2VuZGluZ2AsIGBkZXNjZW5kaW5nYCwgYDFgLCBhbmQgYC0xYC5cbiAqXG4gKiBJZiBhIHN0cmluZyBpcyBwYXNzZWQsIGl0IG11c3QgYmUgYSBzcGFjZSBkZWxpbWl0ZWQgbGlzdCBvZiBwYXRoIG5hbWVzLiBUaGVcbiAqIHNvcnQgb3JkZXIgb2YgZWFjaCBwYXRoIGlzIGFzY2VuZGluZyB1bmxlc3MgdGhlIHBhdGggbmFtZSBpcyBwcmVmaXhlZCB3aXRoIGAtYFxuICogd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGFzIGRlc2NlbmRpbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBzb3J0IGJ5IFwiZmllbGRcIiBhc2NlbmRpbmcgYW5kIFwidGVzdFwiIGRlc2NlbmRpbmdcbiAqICAgICBxdWVyeS5zb3J0KHsgZmllbGQ6ICdhc2MnLCB0ZXN0OiAtMSB9KTtcbiAqXG4gKiAgICAgLy8gZXF1aXZhbGVudFxuICogICAgIHF1ZXJ5LnNvcnQoJ2ZpZWxkIC10ZXN0Jyk7XG4gKlxuICogICAgIC8vIGFsc28gcG9zc2libGUgaXMgdG8gdXNlIGEgYXJyYXkgd2l0aCBhcnJheSBrZXktdmFsdWUgcGFpcnNcbiAqICAgICBxdWVyeS5zb3J0KFtbJ2ZpZWxkJywgJ2FzYyddXSk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfEFycmF5PEFycmF5PChzdHJpbmcgfCBudW1iZXIpPj59IGFyZ1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgY3Vyc29yLnNvcnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3Iuc29ydC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihhcmcpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3J0KCkgb25seSB0YWtlcyAxIEFyZ3VtZW50Jyk7XG4gIH1cblxuICByZXR1cm4gUXVlcnkuYmFzZS5zb3J0LmNhbGwodGhpcywgYXJnKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGEgYGRlbGV0ZU9uZSgpYCBvcGVyYXRpb24uIFdvcmtzIGxpa2VcbiAqIHJlbW92ZSwgZXhjZXB0IGl0IGRlbGV0ZXMgYXQgbW9zdCBvbmUgZG9jdW1lbnQgcmVnYXJkbGVzcyBvZiB0aGUgYHNpbmdsZWBcbiAqIG9wdGlvbi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIGBkZWxldGVPbmVgIG1pZGRsZXdhcmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuZGVsZXRlT25lKHsgbmFtZTogJ0VkZGFyZCBTdGFyaycgfSk7XG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYWxscyB0aGUgTW9uZ29EQiBkcml2ZXIncyBbYENvbGxlY3Rpb24jZGVsZXRlT25lKClgIGZ1bmN0aW9uXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2RlbGV0ZU9uZSkuXG4gKiBUaGUgcmV0dXJuZWQgW3Byb21pc2VdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWwpIHJlc29sdmVzIHRvIGFuXG4gKiBvYmplY3QgdGhhdCBjb250YWlucyAzIHByb3BlcnRpZXM6XG4gKlxuICogLSBgb2tgOiBgMWAgaWYgbm8gZXJyb3JzIG9jY3VycmVkXG4gKiAtIGBkZWxldGVkQ291bnRgOiB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBkZWxldGVkXG4gKiAtIGBuYDogdGhlIG51bWJlciBvZiBkb2N1bWVudHMgZGVsZXRlZC4gRXF1YWwgdG8gYGRlbGV0ZWRDb3VudGAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBDaGFyYWN0ZXIuZGVsZXRlT25lKHsgbmFtZTogJ0VkZGFyZCBTdGFyaycgfSk7XG4gKiAgICAgLy8gYDFgIGlmIE1vbmdvREIgZGVsZXRlZCBhIGRvYywgYDBgIGlmIG5vIGRvY3MgbWF0Y2hlZCB0aGUgZmlsdGVyIGB7IG5hbWU6IC4uLiB9YFxuICogICAgIHJlcy5kZWxldGVkQ291bnQ7XG4gKlxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtmaWx0ZXJdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgRGVsZXRlUmVzdWx0IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9EZWxldGVSZXN1bHQuaHRtbFxuICogQHNlZSBkZWxldGVPbmUgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNkZWxldGVPbmVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmRlbGV0ZU9uZSA9IGZ1bmN0aW9uIGRlbGV0ZU9uZShmaWx0ZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZGVsZXRlT25lKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIHRoaXMub3AgPSAnZGVsZXRlT25lJztcbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIGlmIChtcXVlcnkuY2FuTWVyZ2UoZmlsdGVyKSkge1xuICAgIHRoaXMubWVyZ2UoZmlsdGVyKTtcblxuICAgIHByZXBhcmVEaXNjcmltaW5hdG9yQ3JpdGVyaWEodGhpcyk7XG4gIH0gZWxzZSBpZiAoZmlsdGVyICE9IG51bGwpIHtcbiAgICB0aGlzLmVycm9yKG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihmaWx0ZXIsICdmaWx0ZXInLCAnZGVsZXRlT25lJykpO1xuICB9XG5cbiAgUXVlcnkuYmFzZS5kZWxldGVPbmUuY2FsbCh0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgdGh1bmsgZm9yIGBkZWxldGVPbmUoKWBcbiAqXG4gKiBAbWV0aG9kIF9kZWxldGVPbmVcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2RlbGV0ZU9uZSA9IGFzeW5jIGZ1bmN0aW9uIF9kZWxldGVPbmUoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSAhPSBudWxsKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbi5jb2xsZWN0aW9uLmRlbGV0ZU9uZSh0aGlzLl9jb25kaXRpb25zLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGEgYGRlbGV0ZU1hbnkoKWAgb3BlcmF0aW9uLiBXb3JrcyBsaWtlXG4gKiByZW1vdmUsIGV4Y2VwdCBpdCBkZWxldGVzIF9ldmVyeV8gZG9jdW1lbnQgdGhhdCBtYXRjaGVzIGBmaWx0ZXJgIGluIHRoZVxuICogY29sbGVjdGlvbiwgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYHNpbmdsZWAuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyBgZGVsZXRlTWFueWAgbWlkZGxld2FyZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IENoYXJhY3Rlci5kZWxldGVNYW55KHsgbmFtZTogL1N0YXJrLywgYWdlOiB7ICRndGU6IDE4IH0gfSk7XG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYWxscyB0aGUgTW9uZ29EQiBkcml2ZXIncyBbYENvbGxlY3Rpb24jZGVsZXRlTWFueSgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNkZWxldGVNYW55KS5cbiAqIFRoZSByZXR1cm5lZCBbcHJvbWlzZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3F1ZXJpZXMuaHRtbCkgcmVzb2x2ZXMgdG8gYW5cbiAqIG9iamVjdCB0aGF0IGNvbnRhaW5zIDMgcHJvcGVydGllczpcbiAqXG4gKiAtIGBva2A6IGAxYCBpZiBubyBlcnJvcnMgb2NjdXJyZWRcbiAqIC0gYGRlbGV0ZWRDb3VudGA6IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGRlbGV0ZWRcbiAqIC0gYG5gOiB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBkZWxldGVkLiBFcXVhbCB0byBgZGVsZXRlZENvdW50YC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IENoYXJhY3Rlci5kZWxldGVNYW55KHsgbmFtZTogL1N0YXJrLywgYWdlOiB7ICRndGU6IDE4IH0gfSk7XG4gKiAgICAgLy8gYDBgIGlmIG5vIGRvY3MgbWF0Y2hlZCB0aGUgZmlsdGVyLCBudW1iZXIgb2YgZG9jcyBkZWxldGVkIG90aGVyd2lzZVxuICogICAgIHJlcy5kZWxldGVkQ291bnQ7XG4gKlxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtmaWx0ZXJdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgRGVsZXRlUmVzdWx0IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9EZWxldGVSZXN1bHQuaHRtbFxuICogQHNlZSBkZWxldGVNYW55IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjZGVsZXRlTWFueVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZGVsZXRlTWFueSA9IGZ1bmN0aW9uKGZpbHRlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5kZWxldGVNYW55KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgdGhpcy5vcCA9ICdkZWxldGVNYW55JztcblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGZpbHRlcikpIHtcbiAgICB0aGlzLm1lcmdlKGZpbHRlcik7XG5cbiAgICBwcmVwYXJlRGlzY3JpbWluYXRvckNyaXRlcmlhKHRoaXMpO1xuICB9IGVsc2UgaWYgKGZpbHRlciAhPSBudWxsKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoZmlsdGVyLCAnZmlsdGVyJywgJ2RlbGV0ZU1hbnknKSk7XG4gIH1cblxuICBRdWVyeS5iYXNlLmRlbGV0ZU1hbnkuY2FsbCh0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGBkZWxldGVNYW55KClgIHF1ZXJ5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBtZXRob2QgX2RlbGV0ZU1hbnlcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2RlbGV0ZU1hbnkgPSBhc3luYyBmdW5jdGlvbiBfZGVsZXRlTWFueSgpIHtcbiAgdGhpcy5fY2FzdENvbmRpdGlvbnMoKTtcblxuICBpZiAodGhpcy5lcnJvcigpICE9IG51bGwpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb24uZGVsZXRlTWFueSh0aGlzLl9jb25kaXRpb25zLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogaHlkcmF0ZXMgYSBkb2N1bWVudFxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXMgM3JkIHBhcmFtZXRlciB0byBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICogQHBhcmFtIHtRdWVyeX0gc2VsZlxuICogQHBhcmFtIHtBcnJheX0gW3BvcF0gYXJyYXkgb2YgcGF0aHMgdXNlZCBpbiBwb3B1bGF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGxldGVPbmUobW9kZWwsIGRvYywgcmVzLCBvcHRpb25zLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgcG9wLCBjYWxsYmFjaykge1xuICBpZiAoKG9wdGlvbnMucmF3UmVzdWx0IHx8IG9wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhKSAmJiBkb2MgPT0gbnVsbCkge1xuICAgIF9pbml0KG51bGwpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaGVscGVycy5jcmVhdGVNb2RlbEFuZEluaXQobW9kZWwsIGRvYywgZmllbGRzLCB1c2VyUHJvdmlkZWRGaWVsZHMsIG9wdGlvbnMsIHBvcCwgX2luaXQpO1xuXG4gIGZ1bmN0aW9uIF9pbml0KGVyciwgY2FzdGVkKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhlcnIpKTtcbiAgICB9XG5cblxuICAgIGlmIChvcHRpb25zLnJhd1Jlc3VsdCB8fCBvcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YSkge1xuICAgICAgaWYgKGRvYyAmJiBjYXN0ZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgICAgY2FzdGVkLiRzZXNzaW9uKG9wdGlvbnMuc2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnZhbHVlID0gY2FzdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzLnZhbHVlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgcmVzKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNlc3Npb24gIT0gbnVsbCkge1xuICAgICAgY2FzdGVkLiRzZXNzaW9uKG9wdGlvbnMuc2Vzc2lvbik7XG4gICAgfVxuICAgIGltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhudWxsLCBjYXN0ZWQpKTtcbiAgfVxufVxuXG4vKipcbiAqIElmIHRoZSBtb2RlbCBpcyBhIGRpc2NyaW1pbmF0b3IgdHlwZSBhbmQgbm90IHJvb3QsIHRoZW4gYWRkIHRoZSBrZXkgJiB2YWx1ZSB0byB0aGUgY3JpdGVyaWEuXG4gKiBAcGFyYW0ge1F1ZXJ5fSBxdWVyeVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcHJlcGFyZURpc2NyaW1pbmF0b3JDcml0ZXJpYShxdWVyeSkge1xuICBpZiAoIXF1ZXJ5IHx8ICFxdWVyeS5tb2RlbCB8fCAhcXVlcnkubW9kZWwuc2NoZW1hKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc2NoZW1hID0gcXVlcnkubW9kZWwuc2NoZW1hO1xuXG4gIGlmIChzY2hlbWEgJiYgc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nICYmICFzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcuaXNSb290KSB7XG4gICAgcXVlcnkuX2NvbmRpdGlvbnNbc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLmtleV0gPSBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBJc3N1ZXMgYSBtb25nb2RiIGBmaW5kT25lQW5kVXBkYXRlKClgIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgdXBkYXRlcyBpdCBhY2NvcmRpbmcgdG8gdGhlIGB1cGRhdGVgIGFyZywgcGFzc2luZyBhbnkgYG9wdGlvbnNgLCBhbmQgcmV0dXJucyB0aGUgZm91bmRcbiAqIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqXG4gKiAjIyMjIEF2YWlsYWJsZSBvcHRpb25zXG4gKlxuICogLSBgbmV3YDogYm9vbCAtIGlmIHRydWUsIHJldHVybiB0aGUgbW9kaWZpZWQgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdGhlIG9yaWdpbmFsLiBkZWZhdWx0cyB0byBmYWxzZSAoY2hhbmdlZCBpbiA0LjApXG4gKiAtIGB1cHNlcnRgOiBib29sIC0gY3JlYXRlcyB0aGUgb2JqZWN0IGlmIGl0IGRvZXNuJ3QgZXhpc3QuIGRlZmF1bHRzIHRvIGZhbHNlLlxuICogLSBgZmllbGRzYDoge09iamVjdHxTdHJpbmd9IC0gRmllbGQgc2VsZWN0aW9uLiBFcXVpdmFsZW50IHRvIGAuc2VsZWN0KGZpZWxkcykuZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgc29ydGA6IGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlXG4gKiAtIGBtYXhUaW1lTVNgOiBwdXRzIGEgdGltZSBsaW1pdCBvbiB0aGUgcXVlcnkgLSByZXF1aXJlcyBtb25nb2RiID49IDIuNi4wXG4gKiAtIGBydW5WYWxpZGF0b3JzYDogaWYgdHJ1ZSwgcnVucyBbdXBkYXRlIHZhbGlkYXRvcnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy92YWxpZGF0aW9uLmh0bWwjdXBkYXRlLXZhbGlkYXRvcnMpIG9uIHRoaXMgY29tbWFuZC4gVXBkYXRlIHZhbGlkYXRvcnMgdmFsaWRhdGUgdGhlIHVwZGF0ZSBvcGVyYXRpb24gYWdhaW5zdCB0aGUgbW9kZWwncyBzY2hlbWEuXG4gKiAtIGBzZXREZWZhdWx0c09uSW5zZXJ0YDogYHRydWVgIGJ5IGRlZmF1bHQuIElmIGBzZXREZWZhdWx0c09uSW5zZXJ0YCBhbmQgYHVwc2VydGAgYXJlIHRydWUsIG1vbmdvb3NlIHdpbGwgYXBwbHkgdGhlIFtkZWZhdWx0c10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2RlZmF1bHRzLmh0bWwpIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwncyBzY2hlbWEgaWYgYSBuZXcgZG9jdW1lbnQgaXMgY3JlYXRlZC5cbiAqIC0gYHJhd1Jlc3VsdGA6IGlmIHRydWUsIHJldHVybnMgdGhlIFtyYXcgcmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSwgb3B0aW9ucykgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSkgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKHVwZGF0ZSkgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqXG4gKiBAbWV0aG9kIGZpbmRPbmVBbmRVcGRhdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yYXdSZXN1bHRdIGlmIHRydWUsIHJldHVybnMgdGhlIFtyYXcgcmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubXVsdGlwbGVDYXN0RXJyb3JdIGJ5IGRlZmF1bHQsIG1vbmdvb3NlIG9ubHkgcmV0dXJucyB0aGUgZmlyc3QgZXJyb3IgdGhhdCBvY2N1cnJlZCBpbiBjYXN0aW5nIHRoZSBxdWVyeS4gVHVybiBvbiB0aGlzIG9wdGlvbiB0byBhZ2dyZWdhdGUgYWxsIHRoZSBjYXN0IGVycm9ycy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubmV3PWZhbHNlXSBCeSBkZWZhdWx0LCBgZmluZE9uZUFuZFVwZGF0ZSgpYCByZXR1cm5zIHRoZSBkb2N1bWVudCBhcyBpdCB3YXMgKipiZWZvcmUqKiBgdXBkYXRlYCB3YXMgYXBwbGllZC4gSWYgeW91IHNldCBgbmV3OiB0cnVlYCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAgd2lsbCBpbnN0ZWFkIGdpdmUgeW91IHRoZSBvYmplY3QgYWZ0ZXIgYHVwZGF0ZWAgd2FzIGFwcGxpZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGVhbl0gaWYgdHJ1dGh5LCBtb25nb29zZSB3aWxsIHJldHVybiB0aGUgZG9jdW1lbnQgYXMgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCByYXRoZXIgdGhhbiBhIG1vbmdvb3NlIGRvY3VtZW50LiBTZWUgW2BRdWVyeS5sZWFuKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmxlYW4oKSkgYW5kIFt0aGUgTW9uZ29vc2UgbGVhbiB0dXRvcmlhbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9sZWFuLmh0bWwpLlxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIE5vdGUgdGhhdCB0aGlzIGFsbG93cyB5b3UgdG8gb3ZlcndyaXRlIHRpbWVzdGFtcHMuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmV0dXJuT3JpZ2luYWw9bnVsbF0gQW4gYWxpYXMgZm9yIHRoZSBgbmV3YCBvcHRpb24uIGByZXR1cm5PcmlnaW5hbDogZmFsc2VgIGlzIGVxdWl2YWxlbnQgdG8gYG5ldzogdHJ1ZWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5PWZhbHNlXSBNb25nb29zZSByZW1vdmVzIGRpc2NyaW1pbmF0b3Iga2V5IHVwZGF0ZXMgZnJvbSBgdXBkYXRlYCBieSBkZWZhdWx0LCBzZXQgYG92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXlgIHRvIGB0cnVlYCB0byBhbGxvdyB1cGRhdGluZyB0aGUgZGlzY3JpbWluYXRvciBrZXlcbiAqIEBzZWUgVHV0b3JpYWwgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9maW5kb25lYW5kdXBkYXRlLmh0bWxcbiAqIEBzZWUgZmluZEFuZE1vZGlmeSBjb21tYW5kIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2ZpbmRBbmRNb2RpZnkvXG4gKiBAc2VlIE1vZGlmeVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWxcbiAqIEBzZWUgZmluZE9uZUFuZFVwZGF0ZSBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2ZpbmRPbmVBbmRVcGRhdGVcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kVXBkYXRlID0gZnVuY3Rpb24oZmlsdGVyLCBkb2MsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBkb2MgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kVXBkYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5vcCA9ICdmaW5kT25lQW5kVXBkYXRlJztcbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMjpcbiAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBkb2MgPSBmaWx0ZXI7XG4gICAgICBmaWx0ZXIgPSBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGZpbHRlcikpIHtcbiAgICB0aGlzLm1lcmdlKGZpbHRlcik7XG4gIH0gZWxzZSBpZiAoZmlsdGVyICE9IG51bGwpIHtcbiAgICB0aGlzLmVycm9yKFxuICAgICAgbmV3IE9iamVjdFBhcmFtZXRlckVycm9yKGZpbHRlciwgJ2ZpbHRlcicsICdmaW5kT25lQW5kVXBkYXRlJylcbiAgICApO1xuICB9XG5cbiAgLy8gYXBwbHkgZG9jXG4gIGlmIChkb2MpIHtcbiAgICB0aGlzLl9tZXJnZVVwZGF0ZShkb2MpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgPyBjbG9uZShvcHRpb25zKSA6IHt9O1xuXG4gIGlmIChvcHRpb25zLnByb2plY3Rpb24pIHtcbiAgICB0aGlzLnNlbGVjdChvcHRpb25zLnByb2plY3Rpb24pO1xuICAgIGRlbGV0ZSBvcHRpb25zLnByb2plY3Rpb247XG4gIH1cbiAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgdGhpcy5zZWxlY3Qob3B0aW9ucy5maWVsZHMpO1xuICAgIGRlbGV0ZSBvcHRpb25zLmZpZWxkcztcbiAgfVxuXG4gIGNvbnN0IHJldHVybk9yaWdpbmFsID0gdGhpcyAmJlxuICAgIHRoaXMubW9kZWwgJiZcbiAgICB0aGlzLm1vZGVsLmJhc2UgJiZcbiAgICB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucyAmJlxuICAgIHRoaXMubW9kZWwuYmFzZS5vcHRpb25zLnJldHVybk9yaWdpbmFsO1xuICBpZiAob3B0aW9ucy5uZXcgPT0gbnVsbCAmJiBvcHRpb25zLnJldHVybkRvY3VtZW50ID09IG51bGwgJiYgb3B0aW9ucy5yZXR1cm5PcmlnaW5hbCA9PSBudWxsICYmIHJldHVybk9yaWdpbmFsICE9IG51bGwpIHtcbiAgICBvcHRpb25zLnJldHVybk9yaWdpbmFsID0gcmV0dXJuT3JpZ2luYWw7XG4gIH1cblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBmaW5kT25lQW5kVXBkYXRlIG9wZXJhdGlvblxuICpcbiAqIEBtZXRob2QgX2ZpbmRPbmVBbmRVcGRhdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9maW5kT25lQW5kVXBkYXRlID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmRPbmVBbmRVcGRhdGUoKSB7XG4gIC8vIEZvciBiYWNrd2FyZHMgY29tcGFiaWxpdHkgd2l0aCBNb25nb29zZSA2IHJlOiAjMTM1NTBcblxuICBpZiAodGhpcy5fbW9uZ29vc2VPcHRpb25zLm92ZXJ3cml0ZSAhPSBudWxsKSB7XG4gICAgcHJpbnRPdmVyd3JpdGVEZXByZWNhdGlvbldhcm5pbmcoKTtcbiAgfVxuICBpZiAodGhpcy5fbW9uZ29vc2VPcHRpb25zLm92ZXJ3cml0ZSkge1xuICAgIHRoaXMub3AgPSAnZmluZE9uZUFuZFJlcGxhY2UnO1xuICAgIHJldHVybiB0aGlzLl9maW5kT25lQW5kUmVwbGFjZSgpO1xuICB9XG5cbiAgdGhpcy5fY2FzdENvbmRpdGlvbnMoKTtcblxuICBfY2FzdEFycmF5RmlsdGVycyh0aGlzKTtcblxuICBpZiAodGhpcy5lcnJvcigpKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgYXBwbHlHbG9iYWxNYXhUaW1lTVModGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsKTtcbiAgYXBwbHlHbG9iYWxEaXNrVXNlKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbCk7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5yYXdSZXN1bHQgJiYgdGhpcy5vcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ2Fubm90IHNldCBgcmF3UmVzdWx0YCBvcHRpb24gd2hlbiBgaW5jbHVkZVJlc3VsdE1ldGFkYXRhYCBpcyBmYWxzZScpO1xuICB9XG5cbiAgaWYgKCdzdHJpY3QnIGluIHRoaXMub3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3QgPSB0aGlzLm9wdGlvbnMuc3RyaWN0O1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYyh0aGlzLm1vZGVsKTtcbiAgY29udmVydE5ld1RvUmV0dXJuRG9jdW1lbnQob3B0aW9ucyk7XG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICB0aGlzLl91cGRhdGUgPSB0aGlzLl9jYXN0VXBkYXRlKHRoaXMuX3VwZGF0ZSwgZmFsc2UpO1xuXG4gIGNvbnN0IF9vcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgIHNldERlZmF1bHRzT25JbnNlcnQ6IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0XG4gIH0pO1xuICB0aGlzLl91cGRhdGUgPSBzZXREZWZhdWx0c09uSW5zZXJ0KHRoaXMuX2NvbmRpdGlvbnMsIHRoaXMubW9kZWwuc2NoZW1hLFxuICAgIHRoaXMuX3VwZGF0ZSwgX29wdHMpO1xuXG4gIGlmICghdGhpcy5fdXBkYXRlIHx8IE9iamVjdC5rZXlzKHRoaXMuX3VwZGF0ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKG9wdGlvbnMudXBzZXJ0KSB7XG4gICAgICAvLyBzdGlsbCBuZWVkIHRvIGRvIHRoZSB1cHNlcnQgdG8gZW1wdHkgZG9jXG4gICAgICBjb25zdCBkb2MgPSBjbG9uZSh0aGlzLl91cGRhdGUpO1xuICAgICAgZGVsZXRlIGRvYy5faWQ7XG4gICAgICB0aGlzLl91cGRhdGUgPSB7ICRzZXQ6IGRvYyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9leGVjdXRpb25TdGFjayA9IG51bGw7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9maW5kT25lKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl91cGRhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHRocm93IHRoaXMuX3VwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBvcmRlciB0byBtYWtlIE1vbmdvREIgMi42IGhhcHB5IChzZWVcbiAgICAvLyBodHRwczovL2ppcmEubW9uZ29kYi5vcmcvYnJvd3NlL1NFUlZFUi0xMjI2NiBhbmQgcmVsYXRlZCBpc3N1ZXMpXG4gICAgLy8gaWYgd2UgaGF2ZSBhbiBhY3R1YWwgdXBkYXRlIGRvY3VtZW50IGJ1dCAkc2V0IGlzIGVtcHR5LCBqdW5rIHRoZSAkc2V0LlxuICAgIGlmICh0aGlzLl91cGRhdGUuJHNldCAmJiBPYmplY3Qua2V5cyh0aGlzLl91cGRhdGUuJHNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5fdXBkYXRlLiRzZXQ7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcnVuVmFsaWRhdG9ycyA9IF9nZXRPcHRpb24odGhpcywgJ3J1blZhbGlkYXRvcnMnLCBmYWxzZSk7XG4gIGlmIChydW5WYWxpZGF0b3JzKSB7XG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZSh0aGlzLl91cGRhdGUsIG9wdGlvbnMsIGZhbHNlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91cGRhdGUudG9CU09OKSB7XG4gICAgdGhpcy5fdXBkYXRlID0gdGhpcy5fdXBkYXRlLnRvQlNPTigpO1xuICB9XG5cbiAgbGV0IHJlcyA9IGF3YWl0IHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbi5maW5kT25lQW5kVXBkYXRlKHRoaXMuX2NvbmRpdGlvbnMsIHRoaXMuX3VwZGF0ZSwgb3B0aW9ucyk7XG4gIGZvciAoY29uc3QgZm4gb2YgdGhpcy5fdHJhbnNmb3Jtcykge1xuICAgIHJlcyA9IGZuKHJlcyk7XG4gIH1cbiAgY29uc3QgZG9jID0gb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGEgPT09IGZhbHNlID8gcmVzIDogcmVzLnZhbHVlO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy5fY29tcGxldGVPbmUoZG9jLCByZXMsIF93cmFwVGh1bmtDYWxsYmFjayh0aGlzLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIExlZ2FjeSBhbGlhcyBmb3IgYGZpbmRPbmVBbmREZWxldGUoKWAuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgcmVtb3ZlcyBpdCwgcmV0dXJucyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZUFuZFJlbW92ZSgpYFxuICpcbiAqICMjIyMgQXZhaWxhYmxlIG9wdGlvbnNcbiAqXG4gKiAtIGBzb3J0YDogaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGVcbiAqIC0gYG1heFRpbWVNU2A6IHB1dHMgYSB0aW1lIGxpbWl0IG9uIHRoZSBxdWVyeSAtIHJlcXVpcmVzIG1vbmdvZGIgPj0gMi42LjBcbiAqIC0gYHJhd1Jlc3VsdGA6IGlmIHRydWUsIHJlc29sdmVzIHRvIHRoZSBbcmF3IHJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmRSZW1vdmUoY29uZGl0aW9ucywgb3B0aW9ucykgIC8vIHJldHVybiBRdWVyeVxuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kUmVtb3ZlKGNvbmRpdGlvbnMpIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZFJlbW92ZSgpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogQG1ldGhvZCBmaW5kT25lQW5kUmVtb3ZlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IFtjb25kaXRpb25zXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yYXdSZXN1bHRdIGlmIHRydWUsIHJldHVybnMgdGhlIFtyYXcgcmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGZpbmRBbmRNb2RpZnkgY29tbWFuZCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9maW5kQW5kTW9kaWZ5L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFJlbW92ZSA9IGZ1bmN0aW9uKGNvbmRpdGlvbnMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFJlbW92ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHRoaXMub3AgPSAnZmluZE9uZUFuZFJlbW92ZSc7XG4gIHRoaXMuX3ZhbGlkYXRlT3AoKTtcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGNvbmRpdGlvbnMpKSB7XG4gICAgdGhpcy5tZXJnZShjb25kaXRpb25zKTtcbiAgfVxuXG4gIG9wdGlvbnMgJiYgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgYSBNb25nb0RCIFtmaW5kT25lQW5kRGVsZXRlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNvbGxlY3Rpb24uZmluZE9uZUFuZERlbGV0ZS8pIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgcmVtb3ZlcyBpdCwgYW5kIHJldHVybnMgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqXG4gKiAjIyMjIEF2YWlsYWJsZSBvcHRpb25zXG4gKlxuICogLSBgc29ydGA6IGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlXG4gKiAtIGBtYXhUaW1lTVNgOiBwdXRzIGEgdGltZSBsaW1pdCBvbiB0aGUgcXVlcnkgLSByZXF1aXJlcyBtb25nb2RiID49IDIuNi4wXG4gKiAtIGByYXdSZXN1bHRgOiBpZiB0cnVlLCByZXNvbHZlcyB0byB0aGUgW3JhdyByZXN1bHQgZnJvbSB0aGUgTW9uZ29EQiBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb2RpZnlSZXN1bHQuaHRtbClcbiAqXG4gKiAjIyMjIENhbGxiYWNrIFNpZ25hdHVyZVxuICpcbiAqICAgICBmdW5jdGlvbihlcnJvciwgZG9jKSB7XG4gKiAgICAgICAvLyBlcnJvcjogYW55IGVycm9ycyB0aGF0IG9jY3VycmVkXG4gKiAgICAgICAvLyBkb2M6IHRoZSBkb2N1bWVudCBiZWZvcmUgdXBkYXRlcyBhcmUgYXBwbGllZCBpZiBgbmV3OiBmYWxzZWAsIG9yIGFmdGVyIHVwZGF0ZXMgaWYgYG5ldyA9IHRydWVgXG4gKiAgICAgfVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmREZWxldGUoY29uZGl0aW9ucywgb3B0aW9ucykgIC8vIHJldHVybiBRdWVyeVxuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kRGVsZXRlKGNvbmRpdGlvbnMpIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZERlbGV0ZSgpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogQG1ldGhvZCBmaW5kT25lQW5kRGVsZXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yYXdSZXN1bHRdIGlmIHRydWUsIHJldHVybnMgdGhlIFtyYXcgcmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGZpbmRBbmRNb2RpZnkgY29tbWFuZCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9maW5kQW5kTW9kaWZ5L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZERlbGV0ZSA9IGZ1bmN0aW9uKGZpbHRlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLmZpbmRPbmVBbmREZWxldGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICB0aGlzLm9wID0gJ2ZpbmRPbmVBbmREZWxldGUnO1xuICB0aGlzLl92YWxpZGF0ZU9wKCk7XG4gIHRoaXMuX3ZhbGlkYXRlKCk7XG5cbiAgaWYgKG1xdWVyeS5jYW5NZXJnZShmaWx0ZXIpKSB7XG4gICAgdGhpcy5tZXJnZShmaWx0ZXIpO1xuICB9XG5cbiAgb3B0aW9ucyAmJiB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBgZmluZE9uZUFuZERlbGV0ZSgpYCBxdWVyeVxuICpcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAbWV0aG9kIF9maW5kT25lQW5kRGVsZXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5RdWVyeS5wcm90b3R5cGUuX2ZpbmRPbmVBbmREZWxldGUgPSBhc3luYyBmdW5jdGlvbiBfZmluZE9uZUFuZERlbGV0ZSgpIHtcbiAgdGhpcy5fY2FzdENvbmRpdGlvbnMoKTtcblxuICBpZiAodGhpcy5lcnJvcigpICE9IG51bGwpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBjb25zdCBpbmNsdWRlUmVzdWx0TWV0YWRhdGEgPSB0aGlzLm9wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhO1xuICBpZiAodGhpcy5vcHRpb25zLnJhd1Jlc3VsdCAmJiBpbmNsdWRlUmVzdWx0TWV0YWRhdGEgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCBzZXQgYHJhd1Jlc3VsdGAgb3B0aW9uIHdoZW4gYGluY2x1ZGVSZXN1bHRNZXRhZGF0YWAgaXMgZmFsc2UnKTtcbiAgfVxuXG4gIGNvbnN0IGZpbHRlciA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYyh0aGlzLm1vZGVsKTtcbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIGxldCByZXMgPSBhd2FpdCB0aGlzLl9jb2xsZWN0aW9uLmNvbGxlY3Rpb24uZmluZE9uZUFuZERlbGV0ZShmaWx0ZXIsIG9wdGlvbnMpO1xuICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMuX3RyYW5zZm9ybXMpIHtcbiAgICByZXMgPSBmbihyZXMpO1xuICB9XG4gIGNvbnN0IGRvYyA9IGluY2x1ZGVSZXN1bHRNZXRhZGF0YSA9PT0gZmFsc2UgPyByZXMgOiByZXMudmFsdWU7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLl9jb21wbGV0ZU9uZShkb2MsIHJlcywgX3dyYXBUaHVua0NhbGxiYWNrKHRoaXMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSkpO1xuICB9KTtcbn07XG5cbi8qKlxuICogSXNzdWVzIGEgTW9uZ29EQiBbZmluZE9uZUFuZFJlcGxhY2VdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5maW5kT25lQW5kUmVwbGFjZS8pIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgcmVtb3ZlcyBpdCwgYW5kIHJldHVybnMgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmVBbmRSZXBsYWNlKClgXG4gKlxuICogIyMjIyBBdmFpbGFibGUgb3B0aW9uc1xuICpcbiAqIC0gYHNvcnRgOiBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZVxuICogLSBgbWF4VGltZU1TYDogcHV0cyBhIHRpbWUgbGltaXQgb24gdGhlIHF1ZXJ5IC0gcmVxdWlyZXMgbW9uZ29kYiA+PSAyLjYuMFxuICogLSBgcmF3UmVzdWx0YDogaWYgdHJ1ZSwgcmVzb2x2ZXMgdG8gdGhlIFtyYXcgcmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpXG4gKlxuICogIyMjIyBDYWxsYmFjayBTaWduYXR1cmVcbiAqXG4gKiAgICAgZnVuY3Rpb24oZXJyb3IsIGRvYykge1xuICogICAgICAgLy8gZXJyb3I6IGFueSBlcnJvcnMgdGhhdCBvY2N1cnJlZFxuICogICAgICAgLy8gZG9jOiB0aGUgZG9jdW1lbnQgYmVmb3JlIHVwZGF0ZXMgYXJlIGFwcGxpZWQgaWYgYG5ldzogZmFsc2VgLCBvciBhZnRlciB1cGRhdGVzIGlmIGBuZXcgPSB0cnVlYFxuICogICAgIH1cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kUmVwbGFjZShmaWx0ZXIsIHJlcGxhY2VtZW50LCBvcHRpb25zKTsgLy8gcmV0dXJuIFF1ZXJ5XG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmRSZXBsYWNlKGZpbHRlcik7IC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZFJlcGxhY2UoKTsgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqIEBtZXRob2QgZmluZE9uZUFuZFJlcGxhY2VcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcGxhY2VtZW50XVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yYXdSZXN1bHRdIGlmIHRydWUsIHJldHVybnMgdGhlIFtyYXcgcmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubmV3PWZhbHNlXSBCeSBkZWZhdWx0LCBgZmluZE9uZUFuZFVwZGF0ZSgpYCByZXR1cm5zIHRoZSBkb2N1bWVudCBhcyBpdCB3YXMgKipiZWZvcmUqKiBgdXBkYXRlYCB3YXMgYXBwbGllZC4gSWYgeW91IHNldCBgbmV3OiB0cnVlYCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAgd2lsbCBpbnN0ZWFkIGdpdmUgeW91IHRoZSBvYmplY3QgYWZ0ZXIgYHVwZGF0ZWAgd2FzIGFwcGxpZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGVhbl0gaWYgdHJ1dGh5LCBtb25nb29zZSB3aWxsIHJldHVybiB0aGUgZG9jdW1lbnQgYXMgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCByYXRoZXIgdGhhbiBhIG1vbmdvb3NlIGRvY3VtZW50LiBTZWUgW2BRdWVyeS5sZWFuKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmxlYW4oKSkgYW5kIFt0aGUgTW9uZ29vc2UgbGVhbiB0dXRvcmlhbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9sZWFuLmh0bWwpLlxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIE5vdGUgdGhhdCB0aGlzIGFsbG93cyB5b3UgdG8gb3ZlcndyaXRlIHRpbWVzdGFtcHMuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmV0dXJuT3JpZ2luYWw9bnVsbF0gQW4gYWxpYXMgZm9yIHRoZSBgbmV3YCBvcHRpb24uIGByZXR1cm5PcmlnaW5hbDogZmFsc2VgIGlzIGVxdWl2YWxlbnQgdG8gYG5ldzogdHJ1ZWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmRPbmVBbmRSZXBsYWNlID0gZnVuY3Rpb24oZmlsdGVyLCByZXBsYWNlbWVudCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIHJlcGxhY2VtZW50ID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1s0XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFJlcGxhY2UoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICB0aGlzLm9wID0gJ2ZpbmRPbmVBbmRSZXBsYWNlJztcbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIGlmIChtcXVlcnkuY2FuTWVyZ2UoZmlsdGVyKSkge1xuICAgIHRoaXMubWVyZ2UoZmlsdGVyKTtcbiAgfSBlbHNlIGlmIChmaWx0ZXIgIT0gbnVsbCkge1xuICAgIHRoaXMuZXJyb3IoXG4gICAgICBuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoZmlsdGVyLCAnZmlsdGVyJywgJ2ZpbmRPbmVBbmRSZXBsYWNlJylcbiAgICApO1xuICB9XG5cbiAgaWYgKHJlcGxhY2VtZW50ICE9IG51bGwpIHtcbiAgICB0aGlzLl9tZXJnZVVwZGF0ZShyZXBsYWNlbWVudCk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCByZXR1cm5PcmlnaW5hbCA9IHRoaXMgJiZcbiAgdGhpcy5tb2RlbCAmJlxuICB0aGlzLm1vZGVsLmJhc2UgJiZcbiAgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMgJiZcbiAgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMucmV0dXJuT3JpZ2luYWw7XG4gIGlmIChvcHRpb25zLm5ldyA9PSBudWxsICYmIG9wdGlvbnMucmV0dXJuRG9jdW1lbnQgPT0gbnVsbCAmJiBvcHRpb25zLnJldHVybk9yaWdpbmFsID09IG51bGwgJiYgcmV0dXJuT3JpZ2luYWwgIT0gbnVsbCkge1xuICAgIG9wdGlvbnMucmV0dXJuT3JpZ2luYWwgPSByZXR1cm5PcmlnaW5hbDtcbiAgfVxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuc2V0T3B0aW9ucyh7IG92ZXJ3cml0ZTogdHJ1ZSB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGZpbmRPbmVBbmRSZXBsYWNlKCkgcXVlcnlcbiAqXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQG1ldGhvZCBfZmluZE9uZUFuZFJlcGxhY2VcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kT25lQW5kUmVwbGFjZSA9IGFzeW5jIGZ1bmN0aW9uIF9maW5kT25lQW5kUmVwbGFjZSgpIHtcbiAgdGhpcy5fY2FzdENvbmRpdGlvbnMoKTtcbiAgaWYgKHRoaXMuZXJyb3IoKSAhPSBudWxsKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgaWYgKCdzdHJpY3QnIGluIHRoaXMub3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3QgPSB0aGlzLm9wdGlvbnMuc3RyaWN0O1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuc3RyaWN0O1xuICB9XG5cbiAgY29uc3QgZmlsdGVyID0gdGhpcy5fY29uZGl0aW9ucztcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcbiAgY29udmVydE5ld1RvUmV0dXJuRG9jdW1lbnQob3B0aW9ucyk7XG5cbiAgY29uc3QgaW5jbHVkZVJlc3VsdE1ldGFkYXRhID0gdGhpcy5vcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YTtcbiAgaWYgKHRoaXMub3B0aW9ucy5yYXdSZXN1bHQgJiYgaW5jbHVkZVJlc3VsdE1ldGFkYXRhID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3Qgc2V0IGByYXdSZXN1bHRgIG9wdGlvbiB3aGVuIGBpbmNsdWRlUmVzdWx0TWV0YWRhdGFgIGlzIGZhbHNlJyk7XG4gIH1cblxuICBjb25zdCBtb2RlbE9wdHMgPSB7IHNraXBJZDogdHJ1ZSB9O1xuICBpZiAoJ3N0cmljdCcgaW4gdGhpcy5fbW9uZ29vc2VPcHRpb25zKSB7XG4gICAgbW9kZWxPcHRzLnN0cmljdCA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3Q7XG4gIH1cblxuICBjb25zdCBydW5WYWxpZGF0b3JzID0gX2dldE9wdGlvbih0aGlzLCAncnVuVmFsaWRhdG9ycycsIGZhbHNlKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHVwZGF0ZSA9IG5ldyB0aGlzLm1vZGVsKHRoaXMuX3VwZGF0ZSwgbnVsbCwgbW9kZWxPcHRzKTtcbiAgICBpZiAocnVuVmFsaWRhdG9ycykge1xuICAgICAgYXdhaXQgdXBkYXRlLnZhbGlkYXRlKCk7XG4gICAgfSBlbHNlIGlmICh1cGRhdGUuJF9fLnZhbGlkYXRpb25FcnJvcikge1xuICAgICAgdGhyb3cgdXBkYXRlLiRfXy52YWxpZGF0aW9uRXJyb3I7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZSA9IHVwZGF0ZS50b0JTT04oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBuZXcgVmFsaWRhdGlvbkVycm9yKCk7XG4gICAgdmFsaWRhdGlvbkVycm9yLmVycm9yc1tlcnIucGF0aF0gPSBlcnI7XG4gICAgdGhyb3cgdmFsaWRhdGlvbkVycm9yO1xuICB9XG5cbiAgbGV0IHJlcyA9IGF3YWl0IHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbi5maW5kT25lQW5kUmVwbGFjZShmaWx0ZXIsIHRoaXMuX3VwZGF0ZSwgb3B0aW9ucyk7XG5cbiAgZm9yIChjb25zdCBmbiBvZiB0aGlzLl90cmFuc2Zvcm1zKSB7XG4gICAgcmVzID0gZm4ocmVzKTtcbiAgfVxuXG4gIGNvbnN0IGRvYyA9IGluY2x1ZGVSZXN1bHRNZXRhZGF0YSA9PT0gZmFsc2UgPyByZXMgOiByZXMudmFsdWU7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy5fY29tcGxldGVPbmUoZG9jLCByZXMsIF93cmFwVGh1bmtDYWxsYmFjayh0aGlzLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFN1cHBvcnQgdGhlIGBuZXdgIG9wdGlvbiBhcyBhbiBhbHRlcm5hdGl2ZSB0byBgcmV0dXJuT3JpZ2luYWxgIGZvciBiYWNrd2FyZHNcbiAqIGNvbXBhdC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbnZlcnROZXdUb1JldHVybkRvY3VtZW50KG9wdGlvbnMpIHtcbiAgaWYgKCduZXcnIGluIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnJldHVybkRvY3VtZW50ID0gb3B0aW9uc1snbmV3J10gPyAnYWZ0ZXInIDogJ2JlZm9yZSc7XG4gICAgZGVsZXRlIG9wdGlvbnNbJ25ldyddO1xuICB9XG4gIGlmICgncmV0dXJuT3JpZ2luYWwnIGluIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnJldHVybkRvY3VtZW50ID0gb3B0aW9uc1sncmV0dXJuT3JpZ2luYWwnXSA/ICdiZWZvcmUnIDogJ2FmdGVyJztcbiAgICBkZWxldGUgb3B0aW9uc1sncmV0dXJuT3JpZ2luYWwnXTtcbiAgfVxuICAvLyBUZW1wb3Jhcnkgc2luY2UgZHJpdmVyIDQuMC4wLWJldGEgZG9lcyBub3Qgc3VwcG9ydCBgcmV0dXJuRG9jdW1lbnRgXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXR1cm5Eb2N1bWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLnJldHVybk9yaWdpbmFsID0gb3B0aW9ucy5yZXR1cm5Eb2N1bWVudCA9PT0gJ2JlZm9yZSc7XG4gIH1cbn1cblxuLyoqXG4gKiBFeGVjdXRlIGEgYGZpbmRPbmVBbmRSZW1vdmVgLiBBbGlhcyBmb3IgYGZpbmRPbmVBbmREZWxldGVgXG4gKlxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBtZXRob2QgX2ZpbmRPbmVBbmRSZW1vdmVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kT25lQW5kUmVtb3ZlID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmRPbmVBbmRSZW1vdmUoKSB7XG4gIHJldHVybiB0aGlzLl9maW5kT25lQW5kRGVsZXRlKCk7XG59O1xuXG4vKipcbiAqIEdldCBvcHRpb25zIGZyb20gcXVlcnkgb3B0cywgZmFsbGluZyBiYWNrIHRvIHRoZSBiYXNlIG1vbmdvb3NlIG9iamVjdC5cbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gKiBAcGFyYW0ge0FueX0gZGVmXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfZ2V0T3B0aW9uKHF1ZXJ5LCBvcHRpb24sIGRlZikge1xuICBjb25zdCBvcHRzID0gcXVlcnkuX29wdGlvbnNGb3JFeGVjKHF1ZXJ5Lm1vZGVsKTtcblxuICBpZiAob3B0aW9uIGluIG9wdHMpIHtcbiAgICByZXR1cm4gb3B0c1tvcHRpb25dO1xuICB9XG4gIGlmIChvcHRpb24gaW4gcXVlcnkubW9kZWwuYmFzZS5vcHRpb25zKSB7XG4gICAgcmV0dXJuIHF1ZXJ5Lm1vZGVsLmJhc2Uub3B0aW9uc1tvcHRpb25dO1xuICB9XG4gIHJldHVybiBkZWY7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2NvbXBsZXRlT25lTGVhbihzY2hlbWEsIGRvYywgcGF0aCwgcmVzLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAob3B0cy5sZWFuICYmIHR5cGVvZiBvcHRzLmxlYW4udHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cy5sZWFuLnRyYW5zZm9ybShkb2MpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuY2hpbGRTY2hlbWFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoID8gcGF0aCArICcuJyArIHNjaGVtYS5jaGlsZFNjaGVtYXNbaV0ubW9kZWwucGF0aCA6IHNjaGVtYS5jaGlsZFNjaGVtYXNbaV0ubW9kZWwucGF0aDtcbiAgICAgIGNvbnN0IF9zY2hlbWEgPSBzY2hlbWEuY2hpbGRTY2hlbWFzW2ldLnNjaGVtYTtcbiAgICAgIGNvbnN0IG9iaiA9IG1wYXRoLmdldChjaGlsZFBhdGgsIGRvYyk7XG4gICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb3B0cy5sZWFuLnRyYW5zZm9ybShvYmpbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRzLmxlYW4udHJhbnNmb3JtKG9iaik7XG4gICAgICB9XG4gICAgICBfY29tcGxldGVPbmVMZWFuKF9zY2hlbWEsIG9iaiwgY2hpbGRQYXRoLCByZXMsIG9wdHMpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkb2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChvcHRzLnJhd1Jlc3VsdCkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXMpO1xuICB9XG4gIHJldHVybiBjYWxsYmFjayhudWxsLCBkb2MpO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9jb21wbGV0ZU1hbnlMZWFuKHNjaGVtYSwgZG9jcywgcGF0aCwgb3B0cykge1xuICBpZiAob3B0cy5sZWFuICYmIHR5cGVvZiBvcHRzLmxlYW4udHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jcykge1xuICAgICAgb3B0cy5sZWFuLnRyYW5zZm9ybShkb2MpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLmNoaWxkU2NoZW1hcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aCA/IHBhdGggKyAnLicgKyBzY2hlbWEuY2hpbGRTY2hlbWFzW2ldLm1vZGVsLnBhdGggOiBzY2hlbWEuY2hpbGRTY2hlbWFzW2ldLm1vZGVsLnBhdGg7XG4gICAgICBjb25zdCBfc2NoZW1hID0gc2NoZW1hLmNoaWxkU2NoZW1hc1tpXS5zY2hlbWE7XG4gICAgICBsZXQgZG9jID0gbXBhdGguZ2V0KGNoaWxkUGF0aCwgZG9jcyk7XG4gICAgICBpZiAoZG9jID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBkb2MgPSBkb2MuZmxhdCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb2MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3B0cy5sZWFuLnRyYW5zZm9ybShkb2NbaV0pO1xuICAgICAgfVxuICAgICAgX2NvbXBsZXRlTWFueUxlYW4oX3NjaGVtYSwgZG9jLCBjaGlsZFBhdGgsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb2NzO1xufVxuLyoqXG4gKiBPdmVycmlkZSBtcXVlcnkucHJvdG90eXBlLl9tZXJnZVVwZGF0ZSB0byBoYW5kbGUgbW9uZ29vc2Ugb2JqZWN0cyBpblxuICogdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jXG4gKiBAbWV0aG9kIF9tZXJnZVVwZGF0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fbWVyZ2VVcGRhdGUgPSBmdW5jdGlvbihkb2MpIHtcbiAgaWYgKCF0aGlzLl91cGRhdGUpIHtcbiAgICB0aGlzLl91cGRhdGUgPSBBcnJheS5pc0FycmF5KGRvYykgPyBbXSA6IHt9O1xuICB9XG5cbiAgaWYgKGRvYyA9PSBudWxsIHx8ICh0eXBlb2YgZG9jID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhkb2MpLmxlbmd0aCA9PT0gMCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZG9jIGluc3RhbmNlb2YgUXVlcnkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl91cGRhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtaXggYXJyYXkgYW5kIG9iamVjdCB1cGRhdGVzJyk7XG4gICAgfVxuICAgIGlmIChkb2MuX3VwZGF0ZSkge1xuICAgICAgdXRpbHMubWVyZ2VDbG9uZSh0aGlzLl91cGRhdGUsIGRvYy5fdXBkYXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkb2MpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuX3VwZGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1peCBhcnJheSBhbmQgb2JqZWN0IHVwZGF0ZXMnKTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlID0gdGhpcy5fdXBkYXRlLmNvbmNhdChkb2MpO1xuICB9IGVsc2Uge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX3VwZGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1peCBhcnJheSBhbmQgb2JqZWN0IHVwZGF0ZXMnKTtcbiAgICB9XG4gICAgdXRpbHMubWVyZ2VDbG9uZSh0aGlzLl91cGRhdGUsIGRvYyk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gX3VwZGF0ZVRodW5rKG9wKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgX2Nhc3RBcnJheUZpbHRlcnModGhpcyk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSAhPSBudWxsKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgY29uc3QgY2FzdGVkUXVlcnkgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWModGhpcy5tb2RlbCk7XG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICB0aGlzLl91cGRhdGUgPSBjbG9uZSh0aGlzLl91cGRhdGUsIG9wdGlvbnMpO1xuICBjb25zdCBpc092ZXJ3cml0aW5nID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zLm92ZXJ3cml0ZSAmJiAhaGFzRG9sbGFyS2V5cyh0aGlzLl91cGRhdGUpO1xuICBpZiAoaXNPdmVyd3JpdGluZykge1xuICAgIGlmIChvcCA9PT0gJ3VwZGF0ZU9uZScgfHwgb3AgPT09ICd1cGRhdGVNYW55Jykge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1RoZSBNb25nb0RCIHNlcnZlciBkaXNhbGxvd3MgJyArXG4gICAgICAgICdvdmVyd3JpdGluZyBkb2N1bWVudHMgdXNpbmcgYCcgKyBvcCArICdgLiBTZWU6ICcgK1xuICAgICAgICAnaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2RlcHJlY2F0aW9ucy5odG1sI3VwZGF0ZScpO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGUgPSBuZXcgdGhpcy5tb2RlbCh0aGlzLl91cGRhdGUsIG51bGwsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3VwZGF0ZSA9IHRoaXMuX2Nhc3RVcGRhdGUodGhpcy5fdXBkYXRlLCB0aGlzLl9tb25nb29zZU9wdGlvbnMub3ZlcndyaXRlKTtcblxuICAgIGlmICh0aGlzLl91cGRhdGUgPT0gbnVsbCB8fCBPYmplY3Qua2V5cyh0aGlzLl91cGRhdGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgYWNrbm93bGVkZ2VkOiBmYWxzZSB9O1xuICAgIH1cblxuICAgIGNvbnN0IF9vcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgc2V0RGVmYXVsdHNPbkluc2VydDogdGhpcy5fbW9uZ29vc2VPcHRpb25zLnNldERlZmF1bHRzT25JbnNlcnRcbiAgICB9KTtcbiAgICB0aGlzLl91cGRhdGUgPSBzZXREZWZhdWx0c09uSW5zZXJ0KHRoaXMuX2NvbmRpdGlvbnMsIHRoaXMubW9kZWwuc2NoZW1hLFxuICAgICAgdGhpcy5fdXBkYXRlLCBfb3B0cyk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmFycmF5RmlsdGVycykpIHtcbiAgICBvcHRpb25zLmFycmF5RmlsdGVycyA9IHJlbW92ZVVudXNlZEFycmF5RmlsdGVycyh0aGlzLl91cGRhdGUsIG9wdGlvbnMuYXJyYXlGaWx0ZXJzKTtcbiAgfVxuXG4gIGNvbnN0IHJ1blZhbGlkYXRvcnMgPSBfZ2V0T3B0aW9uKHRoaXMsICdydW5WYWxpZGF0b3JzJywgZmFsc2UpO1xuICBpZiAocnVuVmFsaWRhdG9ycykge1xuICAgIGF3YWl0IHRoaXMudmFsaWRhdGUodGhpcy5fdXBkYXRlLCBvcHRpb25zLCBpc092ZXJ3cml0aW5nKTtcbiAgfVxuXG4gIGlmICh0aGlzLl91cGRhdGUudG9CU09OKSB7XG4gICAgdGhpcy5fdXBkYXRlID0gdGhpcy5fdXBkYXRlLnRvQlNPTigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb24uY29sbGVjdGlvbltvcF0oY2FzdGVkUXVlcnksIHRoaXMuX3VwZGF0ZSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogTW9uZ29vc2UgY2FsbHMgdGhpcyBmdW5jdGlvbiBpbnRlcm5hbGx5IHRvIHZhbGlkYXRlIHRoZSBxdWVyeSBpZlxuICogYHJ1blZhbGlkYXRvcnNgIGlzIHNldFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYXN0ZWREb2MgdGhlIHVwZGF0ZSwgYWZ0ZXIgY2FzdGluZ1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgZnJvbSBgX29wdGlvbnNGb3JFeGVjKClgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3ZlcndyaXRpbmdcbiAqIEBtZXRob2QgdmFsaWRhdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudmFsaWRhdGUgPSBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZShjYXN0ZWREb2MsIG9wdGlvbnMsIGlzT3ZlcndyaXRpbmcpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLnZhbGlkYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgYXdhaXQgX2V4ZWN1dGVQcmVIb29rcyh0aGlzLCAndmFsaWRhdGUnKTtcblxuICBpZiAoaXNPdmVyd3JpdGluZykge1xuICAgIGF3YWl0IGNhc3RlZERvYy4kdmFsaWRhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB1cGRhdGVWYWxpZGF0b3JzKHRoaXMsIHRoaXMubW9kZWwuc2NoZW1hLCBjYXN0ZWREb2MsIG9wdGlvbnMsIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXdhaXQgX2V4ZWN1dGVQb3N0SG9va3ModGhpcywgbnVsbCwgbnVsbCwgJ3ZhbGlkYXRlJyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYW4gdXBkYXRlTWFueSBxdWVyeVxuICpcbiAqIEBzZWUgTW9kZWwudXBkYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGUoKVxuICogQG1ldGhvZCBfdXBkYXRlTWFueVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5RdWVyeS5wcm90b3R5cGUuX3VwZGF0ZU1hbnkgPSBhc3luYyBmdW5jdGlvbiBfdXBkYXRlTWFueSgpIHtcbiAgcmV0dXJuIF91cGRhdGVUaHVuay5jYWxsKHRoaXMsICd1cGRhdGVNYW55Jyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYW4gdXBkYXRlT25lIHF1ZXJ5XG4gKlxuICogQHNlZSBNb2RlbC51cGRhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnVwZGF0ZSgpXG4gKiBAbWV0aG9kIF91cGRhdGVPbmVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUXVlcnkucHJvdG90eXBlLl91cGRhdGVPbmUgPSBhc3luYyBmdW5jdGlvbiBfdXBkYXRlT25lKCkge1xuICByZXR1cm4gX3VwZGF0ZVRodW5rLmNhbGwodGhpcywgJ3VwZGF0ZU9uZScpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgcmVwbGFjZU9uZSBxdWVyeVxuICpcbiAqIEBzZWUgTW9kZWwucmVwbGFjZU9uZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwucmVwbGFjZU9uZSgpXG4gKiBAbWV0aG9kIF9yZXBsYWNlT25lXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fcmVwbGFjZU9uZSA9IGFzeW5jIGZ1bmN0aW9uIF9yZXBsYWNlT25lKCkge1xuICByZXR1cm4gX3VwZGF0ZVRodW5rLmNhbGwodGhpcywgJ3JlcGxhY2VPbmUnKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGFuIHVwZGF0ZU1hbnkoKSBvcGVyYXRpb24uXG4gKiBNb25nb0RCIHdpbGwgdXBkYXRlIF9hbGxfIGRvY3VtZW50cyB0aGF0IG1hdGNoIGBmaWx0ZXJgIChhcyBvcHBvc2VkIHRvIGp1c3QgdGhlIGZpcnN0IG9uZSkuXG4gKlxuICogKipOb3RlKiogdXBkYXRlTWFueSB3aWxsIF9ub3RfIGZpcmUgdXBkYXRlIG1pZGRsZXdhcmUuIFVzZSBgcHJlKCd1cGRhdGVNYW55JylgXG4gKiBhbmQgYHBvc3QoJ3VwZGF0ZU1hbnknKWAgaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IFBlcnNvbi51cGRhdGVNYW55KHsgbmFtZTogL1N0YXJrJC8gfSwgeyBpc0RlbGV0ZWQ6IHRydWUgfSk7XG4gKiAgICAgcmVzLm47IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbWF0Y2hlZFxuICogICAgIHJlcy5uTW9kaWZpZWQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbW9kaWZpZWRcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gW3VwZGF0ZV0gdGhlIHVwZGF0ZSBjb21tYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm11bHRpcGxlQ2FzdEVycm9yXSBieSBkZWZhdWx0LCBtb25nb29zZSBvbmx5IHJldHVybnMgdGhlIGZpcnN0IGVycm9yIHRoYXQgb2NjdXJyZWQgaW4gY2FzdGluZyB0aGUgcXVlcnkuIFR1cm4gb24gdGhpcyBvcHRpb24gdG8gYWdncmVnYXRlIGFsbCB0aGUgY2FzdCBlcnJvcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZUNvbmNlcm49bnVsbF0gc2V0cyB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykgZm9yIHJlcGxpY2Egc2V0cy4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleT1mYWxzZV0gTW9uZ29vc2UgcmVtb3ZlcyBkaXNjcmltaW5hdG9yIGtleSB1cGRhdGVzIGZyb20gYHVwZGF0ZWAgYnkgZGVmYXVsdCwgc2V0IGBvdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5YCB0byBgdHJ1ZWAgdG8gYWxsb3cgdXBkYXRpbmcgdGhlIGRpc2NyaW1pbmF0b3Iga2V5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHBhcmFtcyBhcmUgKGVycm9yLCB3cml0ZU9wUmVzdWx0KVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9kZWwudXBkYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGUoKVxuICogQHNlZSBRdWVyeSBkb2NzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWxcbiAqIEBzZWUgdXBkYXRlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi51cGRhdGUvXG4gKiBAc2VlIFVwZGF0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvVXBkYXRlUmVzdWx0Lmh0bWxcbiAqIEBzZWUgTW9uZ29EQiBkb2NzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL3VwZGF0ZS8jdXBkYXRlLWNvbW1hbmQtb3V0cHV0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS51cGRhdGVNYW55ID0gZnVuY3Rpb24oY29uZGl0aW9ucywgZG9jLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGNvbmRpdGlvbnMsIGRvYywgY2FsbGJhY2spXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGRvYywgY2FsbGJhY2spO1xuICAgIGNhbGxiYWNrID0gZG9jO1xuICAgIGRvYyA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHt9O1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gLnVwZGF0ZShjYWxsYmFjaylcbiAgICBjYWxsYmFjayA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBkb2MgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ29iamVjdCcgJiYgIWRvYyAmJiAhb3B0aW9ucyAmJiAhY2FsbGJhY2spIHtcbiAgICAvLyAudXBkYXRlKGRvYylcbiAgICBkb2MgPSBjb25kaXRpb25zO1xuICAgIGNvbmRpdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICd1cGRhdGVNYW55JywgY29uZGl0aW9ucywgZG9jLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhbiB1cGRhdGVPbmUoKSBvcGVyYXRpb24uXG4gKiBNb25nb0RCIHdpbGwgdXBkYXRlIF9vbmx5XyB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIGBmaWx0ZXJgLlxuICpcbiAqIC0gVXNlIGByZXBsYWNlT25lKClgIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSBhbiBlbnRpcmUgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdXNpbmcgW2F0b21pYyBvcGVyYXRvcnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3R1dG9yaWFsL21vZGVsLWRhdGEtZm9yLWF0b21pYy1vcGVyYXRpb25zLyNwYXR0ZXJuKSBsaWtlIGAkc2V0YC5cbiAqXG4gKiAqKk5vdGUqKiB1cGRhdGVPbmUgd2lsbCBfbm90XyBmaXJlIHVwZGF0ZSBtaWRkbGV3YXJlLiBVc2UgYHByZSgndXBkYXRlT25lJylgXG4gKiBhbmQgYHBvc3QoJ3VwZGF0ZU9uZScpYCBpbnN0ZWFkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgUGVyc29uLnVwZGF0ZU9uZSh7IG5hbWU6ICdKZWFuLUx1YyBQaWNhcmQnIH0sIHsgc2hpcDogJ1VTUyBFbnRlcnByaXNlJyB9KTtcbiAqICAgICByZXMuYWNrbm93bGVkZ2VkOyAvLyBJbmRpY2F0ZXMgaWYgdGhpcyB3cml0ZSByZXN1bHQgd2FzIGFja25vd2xlZGdlZC4gSWYgbm90LCB0aGVuIGFsbCBvdGhlciBtZW1iZXJzIG9mIHRoaXMgcmVzdWx0IHdpbGwgYmUgdW5kZWZpbmVkLlxuICogICAgIHJlcy5tYXRjaGVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgdGhhdCBtYXRjaGVkIHRoZSBmaWx0ZXJcbiAqICAgICByZXMubW9kaWZpZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgbW9kaWZpZWRcbiAqICAgICByZXMudXBzZXJ0ZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgdXBzZXJ0ZWRcbiAqICAgICByZXMudXBzZXJ0ZWRJZDsgLy8gSWRlbnRpZmllciBvZiB0aGUgaW5zZXJ0ZWQgZG9jdW1lbnQgKGlmIGFuIHVwc2VydCB0b29rIHBsYWNlKVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IFt1cGRhdGVdIHRoZSB1cGRhdGUgY29tbWFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdWx0aXBsZUNhc3RFcnJvcl0gYnkgZGVmYXVsdCwgbW9uZ29vc2Ugb25seSByZXR1cm5zIHRoZSBmaXJzdCBlcnJvciB0aGF0IG9jY3VycmVkIGluIGNhc3RpbmcgdGhlIHF1ZXJ5LiBUdXJuIG9uIHRoaXMgb3B0aW9uIHRvIGFnZ3JlZ2F0ZSBhbGwgdGhlIGNhc3QgZXJyb3JzLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVwc2VydD1mYWxzZV0gaWYgdHJ1ZSwgYW5kIG5vIGRvY3VtZW50cyBmb3VuZCwgaW5zZXJ0IGEgbmV3IGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMud3JpdGVDb25jZXJuPW51bGxdIHNldHMgdGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8pIGZvciByZXBsaWNhIHNldHMuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCB3cml0ZSBjb25jZXJuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIE5vdGUgdGhhdCB0aGlzIGFsbG93cyB5b3UgdG8gb3ZlcndyaXRlIHRpbWVzdGFtcHMuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXk9ZmFsc2VdIE1vbmdvb3NlIHJlbW92ZXMgZGlzY3JpbWluYXRvciBrZXkgdXBkYXRlcyBmcm9tIGB1cGRhdGVgIGJ5IGRlZmF1bHQsIHNldCBgb3ZlcndyaXRlRGlzY3JpbWluYXRvcktleWAgdG8gYHRydWVgIHRvIGFsbG93IHVwZGF0aW5nIHRoZSBkaXNjcmltaW5hdG9yIGtleVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBwYXJhbXMgYXJlIChlcnJvciwgd3JpdGVPcFJlc3VsdClcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIE1vZGVsLnVwZGF0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwudXBkYXRlKClcbiAqIEBzZWUgUXVlcnkgZG9jcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sXG4gKiBAc2VlIHVwZGF0ZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNvbGxlY3Rpb24udXBkYXRlL1xuICogQHNlZSBVcGRhdGVSZXN1bHQgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL1VwZGF0ZVJlc3VsdC5odG1sXG4gKiBAc2VlIE1vbmdvREIgZG9jcyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC91cGRhdGUvI3VwZGF0ZS1jb21tYW5kLW91dHB1dFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudXBkYXRlT25lID0gZnVuY3Rpb24oY29uZGl0aW9ucywgZG9jLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGNvbmRpdGlvbnMsIGRvYywgY2FsbGJhY2spXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGRvYywgY2FsbGJhY2spO1xuICAgIGNhbGxiYWNrID0gZG9jO1xuICAgIGRvYyA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHt9O1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gLnVwZGF0ZShjYWxsYmFjaylcbiAgICBjYWxsYmFjayA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBkb2MgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ29iamVjdCcgJiYgIWRvYyAmJiAhb3B0aW9ucyAmJiAhY2FsbGJhY2spIHtcbiAgICAvLyAudXBkYXRlKGRvYylcbiAgICBkb2MgPSBjb25kaXRpb25zO1xuICAgIGNvbmRpdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICd1cGRhdGVPbmUnLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGEgcmVwbGFjZU9uZSgpIG9wZXJhdGlvbi5cbiAqIE1vbmdvREIgd2lsbCByZXBsYWNlIHRoZSBleGlzdGluZyBkb2N1bWVudCBhbmQgd2lsbCBub3QgYWNjZXB0IGFueSBbYXRvbWljIG9wZXJhdG9yc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvdHV0b3JpYWwvbW9kZWwtZGF0YS1mb3ItYXRvbWljLW9wZXJhdGlvbnMvI3BhdHRlcm4pIChgJHNldGAsIGV0Yy4pXG4gKlxuICogKipOb3RlKiogcmVwbGFjZU9uZSB3aWxsIF9ub3RfIGZpcmUgdXBkYXRlIG1pZGRsZXdhcmUuIFVzZSBgcHJlKCdyZXBsYWNlT25lJylgXG4gKiBhbmQgYHBvc3QoJ3JlcGxhY2VPbmUnKWAgaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IFBlcnNvbi5yZXBsYWNlT25lKHsgX2lkOiAyNDYwMSB9LCB7IG5hbWU6ICdKZWFuIFZhbGplYW4nIH0pO1xuICogICAgIHJlcy5hY2tub3dsZWRnZWQ7IC8vIEluZGljYXRlcyBpZiB0aGlzIHdyaXRlIHJlc3VsdCB3YXMgYWNrbm93bGVkZ2VkLiBJZiBub3QsIHRoZW4gYWxsIG90aGVyIG1lbWJlcnMgb2YgdGhpcyByZXN1bHQgd2lsbCBiZSB1bmRlZmluZWQuXG4gKiAgICAgcmVzLm1hdGNoZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IG1hdGNoZWQgdGhlIGZpbHRlclxuICogICAgIHJlcy5tb2RpZmllZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSBtb2RpZmllZFxuICogICAgIHJlcy51cHNlcnRlZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSB1cHNlcnRlZFxuICogICAgIHJlcy51cHNlcnRlZElkOyAvLyBJZGVudGlmaWVyIG9mIHRoZSBpbnNlcnRlZCBkb2N1bWVudCAoaWYgYW4gdXBzZXJ0IHRvb2sgcGxhY2UpXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgcmVwbGFjZU9uZSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHBhcmFtIHtPYmplY3R9IFtkb2NdIHRoZSB1cGRhdGUgY29tbWFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdWx0aXBsZUNhc3RFcnJvcl0gYnkgZGVmYXVsdCwgbW9uZ29vc2Ugb25seSByZXR1cm5zIHRoZSBmaXJzdCBlcnJvciB0aGF0IG9jY3VycmVkIGluIGNhc3RpbmcgdGhlIHF1ZXJ5LiBUdXJuIG9uIHRoaXMgb3B0aW9uIHRvIGFnZ3JlZ2F0ZSBhbGwgdGhlIGNhc3QgZXJyb3JzLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVwc2VydD1mYWxzZV0gaWYgdHJ1ZSwgYW5kIG5vIGRvY3VtZW50cyBmb3VuZCwgaW5zZXJ0IGEgbmV3IGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMud3JpdGVDb25jZXJuPW51bGxdIHNldHMgdGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8pIGZvciByZXBsaWNhIHNldHMuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCB3cml0ZSBjb25jZXJuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHBhcmFtcyBhcmUgKGVycm9yLCB3cml0ZU9wUmVzdWx0KVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9kZWwudXBkYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGUoKVxuICogQHNlZSBRdWVyeSBkb2NzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWxcbiAqIEBzZWUgdXBkYXRlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi51cGRhdGUvXG4gKiBAc2VlIFVwZGF0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvVXBkYXRlUmVzdWx0Lmh0bWxcbiAqIEBzZWUgTW9uZ29EQiBkb2NzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL3VwZGF0ZS8jdXBkYXRlLWNvbW1hbmQtb3V0cHV0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5yZXBsYWNlT25lID0gZnVuY3Rpb24oY29uZGl0aW9ucywgZG9jLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGNvbmRpdGlvbnMsIGRvYywgY2FsbGJhY2spXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGRvYywgY2FsbGJhY2spO1xuICAgIGNhbGxiYWNrID0gZG9jO1xuICAgIGRvYyA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHt9O1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gLnVwZGF0ZShjYWxsYmFjaylcbiAgICBjYWxsYmFjayA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBkb2MgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ29iamVjdCcgJiYgIWRvYyAmJiAhb3B0aW9ucyAmJiAhY2FsbGJhY2spIHtcbiAgICAvLyAudXBkYXRlKGRvYylcbiAgICBkb2MgPSBjb25kaXRpb25zO1xuICAgIGNvbmRpdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRoaXMuc2V0T3B0aW9ucyh7IG92ZXJ3cml0ZTogdHJ1ZSB9KTtcbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3JlcGxhY2VPbmUnLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZvciB1cGRhdGUsIHVwZGF0ZU1hbnksIHVwZGF0ZU9uZSwgcmVwbGFjZU9uZVxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcFxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHBhcmFtIHtEb2N1bWVudH0gW2RvY11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfdXBkYXRlKHF1ZXJ5LCBvcCwgZmlsdGVyLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBzZW5kIGluIHRoZSB3aG9sZSBEb2N1bWVudCB0byBtZXJnZSgpXG4gIHF1ZXJ5Lm9wID0gb3A7XG4gIHF1ZXJ5Ll92YWxpZGF0ZU9wKCk7XG4gIGRvYyA9IGRvYyB8fCB7fTtcblxuICAvLyBzdHJpY3QgaXMgYW4gb3B0aW9uIHVzZWQgaW4gdGhlIHVwZGF0ZSBjaGVja2luZywgbWFrZSBzdXJlIGl0IGdldHMgc2V0XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICBpZiAoJ3N0cmljdCcgaW4gb3B0aW9ucykge1xuICAgICAgcXVlcnkuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgICB9XG4gIH1cblxuICBpZiAoIShmaWx0ZXIgaW5zdGFuY2VvZiBRdWVyeSkgJiZcbiAgICAgIGZpbHRlciAhPSBudWxsICYmXG4gICAgICBmaWx0ZXIudG9TdHJpbmcoKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICBxdWVyeS5lcnJvcihuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoZmlsdGVyLCAnZmlsdGVyJywgb3ApKTtcbiAgfSBlbHNlIHtcbiAgICBxdWVyeS5tZXJnZShmaWx0ZXIpO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcXVlcnkuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHF1ZXJ5Ll9tZXJnZVVwZGF0ZShkb2MpO1xuXG4gIC8vIEhvb2tzXG4gIGlmIChjYWxsYmFjaykge1xuICAgIHF1ZXJ5LmV4ZWMoY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIFF1ZXJ5LmJhc2Vbb3BdLmNhbGwocXVlcnksIGZpbHRlciwgdm9pZCAwLCBvcHRpb25zLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyBhIGZ1bmN0aW9uIGBmbmAgYW5kIHRyZWF0cyB0aGUgcmV0dXJuIHZhbHVlIG9mIGBmbmAgYXMgdGhlIG5ldyB2YWx1ZVxuICogZm9yIHRoZSBxdWVyeSB0byByZXNvbHZlIHRvLlxuICpcbiAqIEFueSBmdW5jdGlvbnMgeW91IHBhc3MgdG8gYHRyYW5zZm9ybSgpYCB3aWxsIHJ1biAqKmFmdGVyKiogYW55IHBvc3QgaG9va3MuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBNeU1vZGVsLmZpbmRPbmUoKS50cmFuc2Zvcm0ocmVzID0+IHtcbiAqICAgICAgIC8vIFNldHMgYSBgbG9hZGVkQXRgIHByb3BlcnR5IG9uIHRoZSBkb2MgdGhhdCB0ZWxscyB5b3UgdGhlIHRpbWUgdGhlXG4gKiAgICAgICAvLyBkb2N1bWVudCB3YXMgbG9hZGVkLlxuICogICAgICAgcmV0dXJuIHJlcyA9PSBudWxsID9cbiAqICAgICAgICAgcmVzIDpcbiAqICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXMsIHsgbG9hZGVkQXQ6IG5ldyBEYXRlKCkgfSk7XG4gKiAgICAgfSk7XG4gKlxuICogQG1ldGhvZCB0cmFuc2Zvcm1cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBmdW5jdGlvbiB0byBydW4gdG8gdHJhbnNmb3JtIHRoZSBxdWVyeSByZXN1bHRcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGZuKSB7XG4gIHRoaXMuX3RyYW5zZm9ybXMucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNYWtlIHRoaXMgcXVlcnkgdGhyb3cgYW4gZXJyb3IgaWYgbm8gZG9jdW1lbnRzIG1hdGNoIHRoZSBnaXZlbiBgZmlsdGVyYC5cbiAqIFRoaXMgaXMgaGFuZHkgZm9yIGludGVncmF0aW5nIHdpdGggYXN5bmMvYXdhaXQsIGJlY2F1c2UgYG9yRmFpbCgpYCBzYXZlcyB5b3VcbiAqIGFuIGV4dHJhIGBpZmAgc3RhdGVtZW50IHRvIGNoZWNrIGlmIG5vIGRvY3VtZW50IHdhcyBmb3VuZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRocm93cyBpZiBubyBkb2MgcmV0dXJuZWRcbiAqICAgICBhd2FpdCBNb2RlbC5maW5kT25lKHsgZm9vOiAnYmFyJyB9KS5vckZhaWwoKTtcbiAqXG4gKiAgICAgLy8gVGhyb3dzIGlmIG5vIGRvY3VtZW50IHdhcyB1cGRhdGVkLiBOb3RlIHRoYXQgYG9yRmFpbCgpYCB3aWxsIHN0aWxsXG4gKiAgICAgLy8gdGhyb3cgaWYgdGhlIG9ubHkgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIGlzIGB7IGZvbzogJ2JhcicsIG5hbWU6ICd0ZXN0JyB9YCxcbiAqICAgICAvLyBiZWNhdXNlIGBvckZhaWwoKWAgd2lsbCB0aHJvdyBpZiBubyBkb2N1bWVudCB3YXMgX3VwZGF0ZWRfLCBub3RcbiAqICAgICAvLyBpZiBubyBkb2N1bWVudCB3YXMgX2ZvdW5kXy5cbiAqICAgICBhd2FpdCBNb2RlbC51cGRhdGVPbmUoeyBmb286ICdiYXInIH0sIHsgbmFtZTogJ3Rlc3QnIH0pLm9yRmFpbCgpO1xuICpcbiAqICAgICAvLyBUaHJvd3MgXCJObyBkb2NzIGZvdW5kIVwiIGVycm9yIGlmIG5vIGRvY3MgbWF0Y2ggYHsgZm9vOiAnYmFyJyB9YFxuICogICAgIGF3YWl0IE1vZGVsLmZpbmQoeyBmb286ICdiYXInIH0pLm9yRmFpbChuZXcgRXJyb3IoJ05vIGRvY3MgZm91bmQhJykpO1xuICpcbiAqICAgICAvLyBUaHJvd3MgXCJOb3QgZm91bmRcIiBlcnJvciBpZiBubyBkb2N1bWVudCB3YXMgZm91bmRcbiAqICAgICBhd2FpdCBNb2RlbC5maW5kT25lQW5kVXBkYXRlKHsgZm9vOiAnYmFyJyB9LCB7IG5hbWU6ICd0ZXN0JyB9KS5cbiAqICAgICAgIG9yRmFpbCgoKSA9PiBFcnJvcignTm90IGZvdW5kJykpO1xuICpcbiAqIEBtZXRob2Qgb3JGYWlsXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbnxFcnJvcn0gW2Vycl0gb3B0aW9uYWwgZXJyb3IgdG8gdGhyb3cgaWYgbm8gZG9jcyBtYXRjaCBgZmlsdGVyYC4gSWYgbm90IHNwZWNpZmllZCwgYG9yRmFpbCgpYCB3aWxsIHRocm93IGEgYERvY3VtZW50Tm90Rm91bmRFcnJvcmBcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm9yRmFpbCA9IGZ1bmN0aW9uKGVycikge1xuICB0aGlzLnRyYW5zZm9ybShyZXMgPT4ge1xuICAgIHN3aXRjaCAodGhpcy5vcCkge1xuICAgICAgY2FzZSAnZmluZCc6XG4gICAgICAgIGlmIChyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgX29yRmFpbEVycm9yKGVyciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmaW5kT25lJzpcbiAgICAgICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgX29yRmFpbEVycm9yKGVyciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZXBsYWNlT25lJzpcbiAgICAgIGNhc2UgJ3VwZGF0ZU1hbnknOlxuICAgICAgY2FzZSAndXBkYXRlT25lJzpcbiAgICAgICAgaWYgKHJlcyAmJiByZXMubWF0Y2hlZENvdW50ID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgX29yRmFpbEVycm9yKGVyciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmaW5kT25lQW5kRGVsZXRlJzpcbiAgICAgIGNhc2UgJ2ZpbmRPbmVBbmRSZW1vdmUnOlxuICAgICAgICBpZiAoKHJlcyAmJiByZXMubGFzdEVycm9yT2JqZWN0ICYmIHJlcy5sYXN0RXJyb3JPYmplY3QubikgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBfb3JGYWlsRXJyb3IoZXJyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ZpbmRPbmVBbmRVcGRhdGUnOlxuICAgICAgY2FzZSAnZmluZE9uZUFuZFJlcGxhY2UnOlxuICAgICAgICBpZiAoKHJlcyAmJiByZXMubGFzdEVycm9yT2JqZWN0ICYmIHJlcy5sYXN0RXJyb3JPYmplY3QudXBkYXRlZEV4aXN0aW5nKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBfb3JGYWlsRXJyb3IoZXJyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RlbGV0ZU1hbnknOlxuICAgICAgY2FzZSAnZGVsZXRlT25lJzpcbiAgICAgICAgaWYgKHJlcy5kZWxldGVkQ291bnQgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBfb3JGYWlsRXJyb3IoZXJyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBlcnJvciB0byB0aHJvdyBmb3IgYG9yRmFpbCgpYFxuICogQHBhcmFtIHtFcnJvcnx1bmRlZmluZWR9IGVyclxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9vckZhaWxFcnJvcihlcnIsIHF1ZXJ5KSB7XG4gIGlmICh0eXBlb2YgZXJyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXJyID0gZXJyLmNhbGwocXVlcnkpO1xuICB9XG5cbiAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgZXJyID0gbmV3IERvY3VtZW50Tm90Rm91bmRFcnJvcihxdWVyeS5nZXRRdWVyeSgpLCBxdWVyeS5tb2RlbC5tb2RlbE5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBXcmFwcGVyIGZ1bmN0aW9uIHRvIGNhbGwgaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUgb24gYSBxdWVyeS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZSh0aGlzLl9maWVsZHMsIHBhdGgpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnlcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb21pc2UgPSBxdWVyeS5leGVjKCk7XG4gKiAgICAgY29uc3QgcHJvbWlzZSA9IHF1ZXJ5LmV4ZWMoJ3VwZGF0ZScpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb3BlcmF0aW9uXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmV4ZWMgPSBhc3luYyBmdW5jdGlvbiBleGVjKG9wKSB7XG4gIGlmICh0eXBlb2Ygb3AgPT09ICdmdW5jdGlvbicgfHwgKGFyZ3VtZW50cy5sZW5ndGggPj0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZXhlYygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5vcCA9IG9wO1xuICB9XG5cbiAgaWYgKHRoaXMub3AgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeSBtdXN0IGhhdmUgYG9wYCBiZWZvcmUgZXhlY3V0aW5nJyk7XG4gIH1cbiAgaWYgKHRoaXMubW9kZWwgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeSBtdXN0IGhhdmUgYW4gYXNzb2NpYXRlZCBtb2RlbCBiZWZvcmUgZXhlY3V0aW5nJyk7XG4gIH1cbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuXG4gIGlmICghdGhpcy5vcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnNvcnQpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLnNvcnQpO1xuICAgIGlmIChrZXlzLmluY2x1ZGVzKCcnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZpZWxkIFwiXCIgcGFzc2VkIHRvIHNvcnQoKScpO1xuICAgIH1cbiAgfVxuXG4gIGxldCB0aHVuayA9ICdfJyArIHRoaXMub3A7XG4gIGlmICh0aGlzLm9wID09PSAnZGlzdGluY3QnKSB7XG4gICAgdGh1bmsgPSAnX19kaXN0aW5jdCc7XG4gIH1cblxuICBpZiAodGhpcy5fZXhlY3V0aW9uU3RhY2sgIT0gbnVsbCkge1xuICAgIGxldCBzdHIgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgaWYgKHN0ci5sZW5ndGggPiA2MCkge1xuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIDYwKSArICcuLi4nO1xuICAgIH1cbiAgICBjb25zdCBlcnIgPSBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkgd2FzIGFscmVhZHkgZXhlY3V0ZWQ6ICcgKyBzdHIpO1xuICAgIGVyci5vcmlnaW5hbFN0YWNrID0gdGhpcy5fZXhlY3V0aW9uU3RhY2suc3RhY2s7XG4gICAgdGhyb3cgZXJyO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V4ZWN1dGlvblN0YWNrID0gbmV3IEVycm9yKCk7XG4gIH1cblxuICBhd2FpdCBfZXhlY3V0ZVByZUV4ZWNIb29rcyh0aGlzKTtcblxuICBsZXQgcmVzO1xuXG4gIGxldCBlcnJvciA9IG51bGw7XG4gIHRyeSB7XG4gICAgYXdhaXQgX2V4ZWN1dGVQcmVIb29rcyh0aGlzKTtcbiAgICByZXMgPSBhd2FpdCB0aGlzW3RodW5rXSgpO1xuXG4gICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLl90cmFuc2Zvcm1zKSB7XG4gICAgICByZXMgPSBmbihyZXMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uKSB7XG4gICAgICByZXMgPSBlcnIuYXJnc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IgPSBlcnI7XG4gICAgfVxuICB9XG5cbiAgcmVzID0gYXdhaXQgX2V4ZWN1dGVQb3N0SG9va3ModGhpcywgcmVzLCBlcnJvcik7XG5cbiAgYXdhaXQgX2V4ZWN1dGVQb3N0RXhlY0hvb2tzKHRoaXMpO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9leGVjdXRlUG9zdEV4ZWNIb29rcyhxdWVyeSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHF1ZXJ5Ll9ob29rcy5leGVjUG9zdCgnZXhlYycsIHF1ZXJ5LCBbXSwge30sIChlcnJvcikgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9leGVjdXRlUG9zdEhvb2tzKHF1ZXJ5LCByZXMsIGVycm9yLCBvcCkge1xuICBpZiAocXVlcnkuX3F1ZXJ5TWlkZGxld2FyZSA9PSBudWxsKSB7XG4gICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBvcHRzID0gZXJyb3IgPyB7IGVycm9yIH0gOiB7fTtcblxuICAgIHF1ZXJ5Ll9xdWVyeU1pZGRsZXdhcmUuZXhlY1Bvc3Qob3AgfHwgcXVlcnkub3AsIHF1ZXJ5LCBbcmVzXSwgb3B0cywgKGVycm9yLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXhlY3V0ZVByZUV4ZWNIb29rcyhxdWVyeSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHF1ZXJ5Ll9ob29rcy5leGVjUHJlKCdleGVjJywgcXVlcnksIFtdLCAoZXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXhlY3V0ZVByZUhvb2tzKHF1ZXJ5LCBvcCkge1xuICBpZiAocXVlcnkuX3F1ZXJ5TWlkZGxld2FyZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBxdWVyeS5fcXVlcnlNaWRkbGV3YXJlLmV4ZWNQcmUob3AgfHwgcXVlcnkub3AsIHF1ZXJ5LCBbXSwgKGVycm9yKSA9PiB7XG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3dyYXBUaHVua0NhbGxiYWNrKHF1ZXJ5LCBjYikge1xuICByZXR1cm4gZnVuY3Rpb24oZXJyb3IsIHJlcykge1xuICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2IoZXJyb3IpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZm4gb2YgcXVlcnkuX3RyYW5zZm9ybXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGZuKHJlcyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY2IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjYihudWxsLCByZXMpO1xuICB9O1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSByZXR1cm5pbmcgYSBgUHJvbWlzZWAgd2hpY2ggd2lsbCBiZVxuICogcmVzb2x2ZWQgd2l0aCBlaXRoZXIgdGhlIGRvYyhzKSBvciByZWplY3RlZCB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBNb3JlIGFib3V0IFtgdGhlbigpYCBpbiBKYXZhU2NyaXB0XShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdGhlbikuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVqZWN0XVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IHJldHVybmluZyBhIGBQcm9taXNlYCB3aGljaCB3aWxsIGJlXG4gKiByZXNvbHZlZCB3aXRoIGVpdGhlciB0aGUgZG9jKHMpIG9yIHJlamVjdGVkIHdpdGggdGhlIGVycm9yLlxuICogTGlrZSBgLnRoZW4oKWAsIGJ1dCBvbmx5IHRha2VzIGEgcmVqZWN0aW9uIGhhbmRsZXIuXG4gKlxuICogTW9yZSBhYm91dCBbUHJvbWlzZSBgY2F0Y2goKWAgaW4gSmF2YVNjcmlwdF0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL2NhdGNoKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVqZWN0XVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24ocmVqZWN0KSB7XG4gIHJldHVybiB0aGlzLmV4ZWMoKS50aGVuKG51bGwsIHJlamVjdCk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSByZXR1cm5pbmcgYSBgUHJvbWlzZWAgd2hpY2ggd2lsbCBiZVxuICogcmVzb2x2ZWQgd2l0aCBgLmZpbmFsbHkoKWAgY2hhaW5lZC5cbiAqXG4gKiBNb3JlIGFib3V0IFtQcm9taXNlIGBmaW5hbGx5KClgIGluIEphdmFTY3JpcHRdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vdXNpbmctcHJvbWlzZS1maW5hbGx5LWluLW5vZGUtanMuaHRtbCkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRmluYWxseV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24ob25GaW5hbGx5KSB7XG4gIHJldHVybiB0aGlzLmV4ZWMoKS5maW5hbGx5KG9uRmluYWxseSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBxdWVyeS5cbiAqXG4gKiBNb3JlIGFib3V0IFtgdG9TdHJpbmcoKWAgaW4gSmF2YVNjcmlwdF0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3Rvc3RyaW5nKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiAgICAgY29uc3QgcSA9IE1vZGVsLmZpbmQoKTtcbiAqICAgICBjb25zb2xlLmxvZyhxKTsgLy8gUHJpbnRzIFwiUXVlcnkgeyBmaW5kIH1cIlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIFtTeW1ib2wudG9TdHJpbmdUYWddXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gYFF1ZXJ5IHsgJHt0aGlzLm9wfSB9YDtcbn07XG5cbi8qKlxuICogQWRkIHByZSBbbWlkZGxld2FyZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL21pZGRsZXdhcmUuaHRtbCkgdG8gdGhpcyBxdWVyeSBpbnN0YW5jZS4gRG9lc24ndCBhZmZlY3RcbiAqIG90aGVyIHF1ZXJpZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxMSA9IFF1ZXN0aW9uLmZpbmQoeyBhbnN3ZXI6IDQyIH0pO1xuICogICAgIHExLnByZShmdW5jdGlvbiBtaWRkbGV3YXJlKCkge1xuICogICAgICAgY29uc29sZS5sb2codGhpcy5nZXRGaWx0ZXIoKSk7XG4gKiAgICAgfSk7XG4gKiAgICAgYXdhaXQgcTEuZXhlYygpOyAvLyBQcmludHMgXCJ7IGFuc3dlcjogNDIgfVwiXG4gKlxuICogICAgIC8vIERvZXNuJ3QgcHJpbnQgYW55dGhpbmcsIGJlY2F1c2UgYG1pZGRsZXdhcmUoKWAgaXMgb25seVxuICogICAgIC8vIHJlZ2lzdGVyZWQgb24gYHExYC5cbiAqICAgICBhd2FpdCBRdWVzdGlvbi5maW5kKHsgYW5zd2VyOiA0MiB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnByZSA9IGZ1bmN0aW9uKGZuKSB7XG4gIHRoaXMuX2hvb2tzLnByZSgnZXhlYycsIGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBwb3N0IFttaWRkbGV3YXJlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbWlkZGxld2FyZS5odG1sKSB0byB0aGlzIHF1ZXJ5IGluc3RhbmNlLiBEb2Vzbid0IGFmZmVjdFxuICogb3RoZXIgcXVlcmllcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHExID0gUXVlc3Rpb24uZmluZCh7IGFuc3dlcjogNDIgfSk7XG4gKiAgICAgcTEucG9zdChmdW5jdGlvbiBtaWRkbGV3YXJlKCkge1xuICogICAgICAgY29uc29sZS5sb2codGhpcy5nZXRGaWx0ZXIoKSk7XG4gKiAgICAgfSk7XG4gKiAgICAgYXdhaXQgcTEuZXhlYygpOyAvLyBQcmludHMgXCJ7IGFuc3dlcjogNDIgfVwiXG4gKlxuICogICAgIC8vIERvZXNuJ3QgcHJpbnQgYW55dGhpbmcsIGJlY2F1c2UgYG1pZGRsZXdhcmUoKWAgaXMgb25seVxuICogICAgIC8vIHJlZ2lzdGVyZWQgb24gYHExYC5cbiAqICAgICBhd2FpdCBRdWVzdGlvbi5maW5kKHsgYW5zd2VyOiA0MiB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbihmbikge1xuICB0aGlzLl9ob29rcy5wb3N0KCdleGVjJywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FzdHMgb2JqIGZvciBhbiB1cGRhdGUgY29tbWFuZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG92ZXJ3cml0ZVxuICogQHJldHVybiB7T2JqZWN0fSBvYmogYWZ0ZXIgY2FzdGluZyBpdHMgdmFsdWVzXG4gKiBAbWV0aG9kIF9jYXN0VXBkYXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9jYXN0VXBkYXRlID0gZnVuY3Rpb24gX2Nhc3RVcGRhdGUob2JqLCBvdmVyd3JpdGUpIHtcbiAgbGV0IHNjaGVtYSA9IHRoaXMuc2NoZW1hO1xuXG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICBjb25zdCBiYXNlU2NoZW1hID0gc2NoZW1hLl9iYXNlU2NoZW1hID8gc2NoZW1hLl9iYXNlU2NoZW1hIDogc2NoZW1hO1xuICBpZiAodGhpcy5fbW9uZ29vc2VPcHRpb25zLm92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXkgJiZcbiAgICAgIG9ialtkaXNjcmltaW5hdG9yS2V5XSAhPSBudWxsICYmXG4gICAgICBiYXNlU2NoZW1hLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgY29uc3QgX3NjaGVtYSA9IE9iamVjdC52YWx1ZXMoYmFzZVNjaGVtYS5kaXNjcmltaW5hdG9ycykuZmluZChcbiAgICAgIGRpc2NyaW1pbmF0b3IgPT4gZGlzY3JpbWluYXRvci5kaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZSA9PT0gb2JqW2Rpc2NyaW1pbmF0b3JLZXldXG4gICAgKTtcbiAgICBpZiAoX3NjaGVtYSAhPSBudWxsKSB7XG4gICAgICBzY2hlbWEgPSBfc2NoZW1hO1xuICAgIH1cbiAgfVxuXG4gIGxldCB1cHNlcnQ7XG4gIGlmICgndXBzZXJ0JyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICB1cHNlcnQgPSB0aGlzLm9wdGlvbnMudXBzZXJ0O1xuICB9XG5cbiAgY29uc3QgZmlsdGVyID0gdGhpcy5fY29uZGl0aW9ucztcbiAgaWYgKHNjaGVtYSAhPSBudWxsICYmXG4gICAgICB1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KGZpbHRlciwgc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSkgJiZcbiAgICAgIHR5cGVvZiBmaWx0ZXJbc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0gIT09ICdvYmplY3QnICYmXG4gICAgICBzY2hlbWEuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGZpbHRlcltzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XTtcbiAgICBjb25zdCBieVZhbHVlID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUodGhpcy5tb2RlbC5kaXNjcmltaW5hdG9ycywgZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICBzY2hlbWEgPSBzY2hlbWEuZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvclZhbHVlXSB8fFxuICAgICAgKGJ5VmFsdWUgJiYgYnlWYWx1ZS5zY2hlbWEpIHx8XG4gICAgICBzY2hlbWE7XG4gIH1cblxuICByZXR1cm4gY2FzdFVwZGF0ZShzY2hlbWEsIG9iaiwge1xuICAgIG92ZXJ3cml0ZTogb3ZlcndyaXRlLFxuICAgIHN0cmljdDogdGhpcy5fbW9uZ29vc2VPcHRpb25zLnN0cmljdCxcbiAgICB1cHNlcnQ6IHVwc2VydCxcbiAgICBhcnJheUZpbHRlcnM6IHRoaXMub3B0aW9ucy5hcnJheUZpbHRlcnMsXG4gICAgb3ZlcndyaXRlRGlzY3JpbWluYXRvcktleTogdGhpcy5fbW9uZ29vc2VPcHRpb25zLm92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXlcbiAgfSwgdGhpcywgdGhpcy5fY29uZGl0aW9ucyk7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBwYXRocyB3aGljaCBzaG91bGQgYmUgcG9wdWxhdGVkIHdpdGggb3RoZXIgZG9jdW1lbnRzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbGV0IGJvb2sgPSBhd2FpdCBCb29rLmZpbmRPbmUoKS5wb3B1bGF0ZSgnYXV0aG9ycycpO1xuICogICAgIGJvb2sudGl0bGU7IC8vICdOb2RlLmpzIGluIEFjdGlvbidcbiAqICAgICBib29rLmF1dGhvcnNbMF0ubmFtZTsgLy8gJ1RKIEhvbG93YXljaHVrJ1xuICogICAgIGJvb2suYXV0aG9yc1sxXS5uYW1lOyAvLyAnTmF0aGFuIFJhamxpY2gnXG4gKlxuICogICAgIGxldCBib29rcyA9IGF3YWl0IEJvb2suZmluZCgpLnBvcHVsYXRlKHtcbiAqICAgICAgIHBhdGg6ICdhdXRob3JzJyxcbiAqICAgICAgIC8vIGBtYXRjaGAgYW5kIGBzb3J0YCBhcHBseSB0byB0aGUgQXV0aG9yIG1vZGVsLFxuICogICAgICAgLy8gbm90IHRoZSBCb29rIG1vZGVsLiBUaGVzZSBvcHRpb25zIGRvIG5vdCBhZmZlY3RcbiAqICAgICAgIC8vIHdoaWNoIGRvY3VtZW50cyBhcmUgaW4gYGJvb2tzYCwganVzdCB0aGUgb3JkZXIgYW5kXG4gKiAgICAgICAvLyBjb250ZW50cyBvZiBlYWNoIGJvb2sgZG9jdW1lbnQncyBgYXV0aG9yc2AuXG4gKiAgICAgICBtYXRjaDogeyBuYW1lOiBuZXcgUmVnRXhwKCcuKmguKicsICdpJykgfSxcbiAqICAgICAgIHNvcnQ6IHsgbmFtZTogLTEgfVxuICogICAgIH0pO1xuICogICAgIGJvb2tzWzBdLnRpdGxlOyAvLyAnTm9kZS5qcyBpbiBBY3Rpb24nXG4gKiAgICAgLy8gRWFjaCBib29rJ3MgYGF1dGhvcnNgIGFyZSBzb3J0ZWQgYnkgbmFtZSwgZGVzY2VuZGluZy5cbiAqICAgICBib29rc1swXS5hdXRob3JzWzBdLm5hbWU7IC8vICdUSiBIb2xvd2F5Y2h1aydcbiAqICAgICBib29rc1swXS5hdXRob3JzWzFdLm5hbWU7IC8vICdNYXJjIEhhcnRlcidcbiAqXG4gKiAgICAgYm9va3NbMV0udGl0bGU7IC8vICdQcm9mZXNzaW9uYWwgQW5ndWxhckpTJ1xuICogICAgIC8vIEVtcHR5IGFycmF5LCBubyBhdXRob3JzJyBuYW1lIGhhcyB0aGUgbGV0dGVyICdoJ1xuICogICAgIGJvb2tzWzFdLmF1dGhvcnM7IC8vIFtdXG4gKlxuICogUGF0aHMgYXJlIHBvcHVsYXRlZCBhZnRlciB0aGUgcXVlcnkgZXhlY3V0ZXMgYW5kIGEgcmVzcG9uc2UgaXMgcmVjZWl2ZWQuIEFcbiAqIHNlcGFyYXRlIHF1ZXJ5IGlzIHRoZW4gZXhlY3V0ZWQgZm9yIGVhY2ggcGF0aCBzcGVjaWZpZWQgZm9yIHBvcHVsYXRpb24uIEFmdGVyXG4gKiBhIHJlc3BvbnNlIGZvciBlYWNoIHF1ZXJ5IGhhcyBhbHNvIGJlZW4gcmV0dXJuZWQsIHRoZSByZXN1bHRzIGFyZSBwYXNzZWQgdG9cbiAqIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8U3RyaW5nW119IHBhdGggZWl0aGVyIHRoZSBwYXRoKHMpIHRvIHBvcHVsYXRlIG9yIGFuIG9iamVjdCBzcGVjaWZ5aW5nIGFsbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtzZWxlY3RdIEZpZWxkIHNlbGVjdGlvbiBmb3IgdGhlIHBvcHVsYXRpb24gcXVlcnlcbiAqIEBwYXJhbSB7TW9kZWx9IFttb2RlbF0gVGhlIG1vZGVsIHlvdSB3aXNoIHRvIHVzZSBmb3IgcG9wdWxhdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgcG9wdWxhdGUgd2lsbCBsb29rIHVwIHRoZSBtb2RlbCBieSB0aGUgbmFtZSBpbiB0aGUgU2NoZW1hJ3MgYHJlZmAgZmllbGQuXG4gKiBAcGFyYW0ge09iamVjdH0gW21hdGNoXSBDb25kaXRpb25zIGZvciB0aGUgcG9wdWxhdGlvbiBxdWVyeVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIGZvciB0aGUgcG9wdWxhdGlvbiBxdWVyeSAoc29ydCwgZXRjKVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhdGg9bnVsbF0gVGhlIHBhdGggdG8gcG9wdWxhdGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJldGFpbk51bGxWYWx1ZXM9ZmFsc2VdIGJ5IGRlZmF1bHQsIE1vbmdvb3NlIHJlbW92ZXMgbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIHBvcHVsYXRlZCBhcnJheXMuIFVzZSB0aGlzIG9wdGlvbiB0byBtYWtlIGBwb3B1bGF0ZSgpYCByZXRhaW4gYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcnJheSBlbnRyaWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5nZXR0ZXJzPWZhbHNlXSBpZiB0cnVlLCBNb25nb29zZSB3aWxsIGNhbGwgYW55IGdldHRlcnMgZGVmaW5lZCBvbiB0aGUgYGxvY2FsRmllbGRgLiBCeSBkZWZhdWx0LCBNb25nb29zZSBnZXRzIHRoZSByYXcgdmFsdWUgb2YgYGxvY2FsRmllbGRgLiBGb3IgZXhhbXBsZSwgeW91IHdvdWxkIG5lZWQgdG8gc2V0IHRoaXMgb3B0aW9uIHRvIGB0cnVlYCBpZiB5b3Ugd2FudGVkIHRvIFthZGQgYSBgbG93ZXJjYXNlYCBnZXR0ZXIgdG8geW91ciBgbG9jYWxGaWVsZGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI3NjaGVtYXR5cGUtb3B0aW9ucykuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsb25lPWZhbHNlXSBXaGVuIHlvdSBkbyBgQmxvZ1Bvc3QuZmluZCgpLnBvcHVsYXRlKCdhdXRob3InKWAsIGJsb2cgcG9zdHMgd2l0aCB0aGUgc2FtZSBhdXRob3Igd2lsbCBzaGFyZSAxIGNvcHkgb2YgYW4gYGF1dGhvcmAgZG9jLiBFbmFibGUgdGhpcyBvcHRpb24gdG8gbWFrZSBNb25nb29zZSBjbG9uZSBwb3B1bGF0ZWQgZG9jcyBiZWZvcmUgYXNzaWduaW5nIHRoZW0uXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW29wdGlvbnMubWF0Y2g9bnVsbF0gQWRkIGFuIGFkZGl0aW9uYWwgZmlsdGVyIHRvIHRoZSBwb3B1bGF0ZSBxdWVyeS4gQ2FuIGJlIGEgZmlsdGVyIG9iamVjdCBjb250YWluaW5nIFtNb25nb0RCIHF1ZXJ5IHN5bnRheF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvdHV0b3JpYWwvcXVlcnktZG9jdW1lbnRzLyksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZmlsdGVyIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnRyYW5zZm9ybT1udWxsXSBGdW5jdGlvbiB0aGF0IE1vbmdvb3NlIHdpbGwgY2FsbCBvbiBldmVyeSBwb3B1bGF0ZWQgZG9jdW1lbnQgdGhhdCBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSB0aGUgcG9wdWxhdGVkIGRvY3VtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm9wdGlvbnM9bnVsbF0gQWRkaXRpb25hbCBvcHRpb25zIGxpa2UgYGxpbWl0YCBhbmQgYGxlYW5gLlxuICogQHNlZSBwb3B1bGF0aW9uIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sXG4gKiBAc2VlIFF1ZXJ5I3NlbGVjdCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpXG4gKiBAc2VlIE1vZGVsLnBvcHVsYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5wb3B1bGF0ZSgpXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucG9wdWxhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gQmFpbCB3aGVuIGdpdmVuIG5vIHRydXRoeSBhcmd1bWVudHNcbiAgaWYgKCFBcnJheS5mcm9tKGFyZ3VtZW50cykuc29tZShCb29sZWFuKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uc3QgcmVzID0gdXRpbHMucG9wdWxhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblxuICAvLyBQcm9wYWdhdGUgcmVhZENvbmNlcm4gYW5kIHJlYWRQcmVmZXJlbmNlIGFuZCBsZWFuIGZyb20gcGFyZW50IHF1ZXJ5LFxuICAvLyB1bmxlc3Mgb25lIGFscmVhZHkgc3BlY2lmaWVkXG4gIGlmICh0aGlzLm9wdGlvbnMgIT0gbnVsbCkge1xuICAgIGNvbnN0IHJlYWRDb25jZXJuID0gdGhpcy5vcHRpb25zLnJlYWRDb25jZXJuO1xuICAgIGNvbnN0IHJlYWRQcmVmID0gdGhpcy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlO1xuXG4gICAgZm9yIChjb25zdCBwb3B1bGF0ZU9wdGlvbnMgb2YgcmVzKSB7XG4gICAgICBpZiAocmVhZENvbmNlcm4gIT0gbnVsbCAmJiAocG9wdWxhdGVPcHRpb25zICYmIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zICYmIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zLnJlYWRDb25jZXJuKSA9PSBudWxsKSB7XG4gICAgICAgIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zID0gcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgfHwge307XG4gICAgICAgIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zLnJlYWRDb25jZXJuID0gcmVhZENvbmNlcm47XG4gICAgICB9XG4gICAgICBpZiAocmVhZFByZWYgIT0gbnVsbCAmJiAocG9wdWxhdGVPcHRpb25zICYmIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zICYmIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlKSA9PSBudWxsKSB7XG4gICAgICAgIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zID0gcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgfHwge307XG4gICAgICAgIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gcmVhZFByZWY7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb3B0cyA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucztcblxuICBpZiAob3B0cy5sZWFuICE9IG51bGwpIHtcbiAgICBjb25zdCBsZWFuID0gb3B0cy5sZWFuO1xuICAgIGZvciAoY29uc3QgcG9wdWxhdGVPcHRpb25zIG9mIHJlcykge1xuICAgICAgaWYgKChwb3B1bGF0ZU9wdGlvbnMgJiYgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgJiYgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMubGVhbikgPT0gbnVsbCkge1xuICAgICAgICBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucyA9IHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zIHx8IHt9O1xuICAgICAgICBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucy5sZWFuID0gbGVhbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXV0aWxzLmlzT2JqZWN0KG9wdHMucG9wdWxhdGUpKSB7XG4gICAgb3B0cy5wb3B1bGF0ZSA9IHt9O1xuICB9XG5cbiAgY29uc3QgcG9wID0gb3B0cy5wb3B1bGF0ZTtcblxuICBmb3IgKGNvbnN0IHBvcHVsYXRlT3B0aW9ucyBvZiByZXMpIHtcbiAgICBjb25zdCBwYXRoID0gcG9wdWxhdGVPcHRpb25zLnBhdGg7XG4gICAgaWYgKHBvcFtwYXRoXSAmJiBwb3BbcGF0aF0ucG9wdWxhdGUgJiYgcG9wdWxhdGVPcHRpb25zLnBvcHVsYXRlKSB7XG4gICAgICBwb3B1bGF0ZU9wdGlvbnMucG9wdWxhdGUgPSBwb3BbcGF0aF0ucG9wdWxhdGUuY29uY2F0KHBvcHVsYXRlT3B0aW9ucy5wb3B1bGF0ZSk7XG4gICAgfVxuXG4gICAgcG9wW3BvcHVsYXRlT3B0aW9ucy5wYXRoXSA9IHBvcHVsYXRlT3B0aW9ucztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyBhIGxpc3Qgb2YgcGF0aHMgdG8gYmUgcG9wdWxhdGVkIGJ5IHRoaXMgcXVlcnlcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgICBib29rU2NoZW1hLnByZSgnZmluZE9uZScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgIGxldCBrZXlzID0gdGhpcy5nZXRQb3B1bGF0ZWRQYXRocygpOyAvLyBbJ2F1dGhvciddXG4gKiAgICAgIH0pO1xuICogICAgICAuLi5cbiAqICAgICAgQm9vay5maW5kT25lKHt9KS5wb3B1bGF0ZSgnYXV0aG9yJyk7XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAgLy8gRGVlcCBwb3B1bGF0ZVxuICogICAgICBjb25zdCBxID0gTDEuZmluZCgpLnBvcHVsYXRlKHtcbiAqICAgICAgICBwYXRoOiAnbGV2ZWwyJyxcbiAqICAgICAgICBwb3B1bGF0ZTogeyBwYXRoOiAnbGV2ZWwzJyB9XG4gKiAgICAgIH0pO1xuICogICAgICBxLmdldFBvcHVsYXRlZFBhdGhzKCk7IC8vIFsnbGV2ZWwyJywgJ2xldmVsMi5sZXZlbDMnXVxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBwb3B1bGF0ZWQgcGF0aHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdldFBvcHVsYXRlZFBhdGhzID0gZnVuY3Rpb24gZ2V0UG9wdWxhdGVkUGF0aHMoKSB7XG4gIGNvbnN0IG9iaiA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZSB8fCB7fTtcbiAgY29uc3QgcmV0ID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICBjb25zdCBwb3AgPSBvYmpbcGF0aF07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBvcC5wb3B1bGF0ZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBfZ2V0UG9wdWxhdGVkUGF0aHMocmV0LCBwb3AucG9wdWxhdGUsIHBhdGggKyAnLicpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9nZXRQb3B1bGF0ZWRQYXRocyhsaXN0LCBhcnIsIHByZWZpeCkge1xuICBmb3IgKGNvbnN0IHBvcCBvZiBhcnIpIHtcbiAgICBsaXN0LnB1c2gocHJlZml4ICsgcG9wLnBhdGgpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb3AucG9wdWxhdGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgX2dldFBvcHVsYXRlZFBhdGhzKGxpc3QsIHBvcC5wb3B1bGF0ZSwgcHJlZml4ICsgcG9wLnBhdGggKyAnLicpO1xuICB9XG59XG5cbi8qKlxuICogQ2FzdHMgdGhpcyBxdWVyeSB0byB0aGUgc2NoZW1hIG9mIGBtb2RlbGBcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogSWYgYG9iamAgaXMgcHJlc2VudCwgaXQgaXMgY2FzdCBpbnN0ZWFkIG9mIHRoaXMgcXVlcnkuXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gW21vZGVsXSB0aGUgbW9kZWwgdG8gY2FzdCB0by4gSWYgbm90IHNldCwgZGVmYXVsdHMgdG8gYHRoaXMubW9kZWxgXG4gKiBAcGFyYW0ge09iamVjdH0gW29ial1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbihtb2RlbCwgb2JqKSB7XG4gIG9iaiB8fCAob2JqID0gdGhpcy5fY29uZGl0aW9ucyk7XG4gIG1vZGVsID0gbW9kZWwgfHwgdGhpcy5tb2RlbDtcbiAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IG1vZGVsLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gIGlmIChvYmogIT0gbnVsbCAmJlxuICAgICAgb2JqLmhhc093blByb3BlcnR5KGRpc2NyaW1pbmF0b3JLZXkpKSB7XG4gICAgbW9kZWwgPSBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShtb2RlbC5kaXNjcmltaW5hdG9ycywgb2JqW2Rpc2NyaW1pbmF0b3JLZXldKSB8fCBtb2RlbDtcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSB7IHVwc2VydDogdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy51cHNlcnQgfTtcbiAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgIGlmICgnc3RyaWN0JyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgIG9wdHMuc3RyaWN0ID0gdGhpcy5vcHRpb25zLnN0cmljdDtcbiAgICB9XG4gICAgaWYgKCdzdHJpY3RRdWVyeScgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICBvcHRzLnN0cmljdFF1ZXJ5ID0gdGhpcy5vcHRpb25zLnN0cmljdFF1ZXJ5O1xuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhc3QobW9kZWwuc2NoZW1hLCBvYmosIG9wdHMsIHRoaXMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXN0RXJyb3IsIGFzc2lnbiBtb2RlbFxuICAgIGlmICh0eXBlb2YgZXJyLnNldE1vZGVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnIuc2V0TW9kZWwobW9kZWwpO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FzdHMgc2VsZWN0ZWQgZmllbGQgYXJndW1lbnRzIGZvciBmaWVsZCBzZWxlY3Rpb24gd2l0aCBtb25nbyAyLjJcbiAqXG4gKiAgICAgcXVlcnkuc2VsZWN0KHsgaWRzOiB7ICRlbGVtTWF0Y2g6IHsgJGluOiBbaGV4U3RyaW5nXSB9fSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL21vbmdvb3NlL2lzc3Vlcy8xMDkxXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9wcm9qZWN0aW9uL2VsZW1NYXRjaC9cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fY2FzdEZpZWxkcyA9IGZ1bmN0aW9uIF9jYXN0RmllbGRzKGZpZWxkcykge1xuICBsZXQgc2VsZWN0ZWQsXG4gICAgICBlbGVtTWF0Y2hLZXlzLFxuICAgICAga2V5cyxcbiAgICAgIGtleSxcbiAgICAgIG91dDtcblxuICBpZiAoZmllbGRzKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkcyk7XG4gICAgZWxlbU1hdGNoS2V5cyA9IFtdO1xuXG4gICAgLy8gY29sbGVjdCAkZWxlbU1hdGNoIGFyZ3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoZmllbGRzW2tleV0uJGVsZW1NYXRjaCkge1xuICAgICAgICBzZWxlY3RlZCB8fCAoc2VsZWN0ZWQgPSB7fSk7XG4gICAgICAgIHNlbGVjdGVkW2tleV0gPSBmaWVsZHNba2V5XTtcbiAgICAgICAgZWxlbU1hdGNoS2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGVjdGVkKSB7XG4gICAgLy8gdGhleSBwYXNzZWQgJGVsZW1NYXRjaCwgY2FzdCBlbVxuICAgIHRyeSB7XG4gICAgICBvdXQgPSB0aGlzLmNhc3QodGhpcy5tb2RlbCwgc2VsZWN0ZWQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0aGUgY2FzdGVkIGZpZWxkIGFyZ3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1NYXRjaEtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGtleSA9IGVsZW1NYXRjaEtleXNbaV07XG4gICAgICBmaWVsZHNba2V5XSA9IG91dFtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWVsZHM7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgc2NoZW1hdHlwZSBzZWxlY3RlZCBvcHRpb25zIHRvIHRoaXMgcXVlcnkuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2FwcGx5UGF0aHMgPSBmdW5jdGlvbiBhcHBseVBhdGhzKCkge1xuICBpZiAoIXRoaXMubW9kZWwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZmllbGRzID0gdGhpcy5fZmllbGRzIHx8IHt9O1xuICBoZWxwZXJzLmFwcGx5UGF0aHModGhpcy5fZmllbGRzLCB0aGlzLm1vZGVsLnNjaGVtYSk7XG5cbiAgbGV0IF9zZWxlY3RQb3B1bGF0ZWRQYXRocyA9IHRydWU7XG5cbiAgaWYgKCdzZWxlY3RQb3B1bGF0ZWRQYXRocycgaW4gdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMpIHtcbiAgICBfc2VsZWN0UG9wdWxhdGVkUGF0aHMgPSB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucy5zZWxlY3RQb3B1bGF0ZWRQYXRocztcbiAgfVxuICBpZiAoJ3NlbGVjdFBvcHVsYXRlZFBhdGhzJyBpbiB0aGlzLm1vZGVsLnNjaGVtYS5vcHRpb25zKSB7XG4gICAgX3NlbGVjdFBvcHVsYXRlZFBhdGhzID0gdGhpcy5tb2RlbC5zY2hlbWEub3B0aW9ucy5zZWxlY3RQb3B1bGF0ZWRQYXRocztcbiAgfVxuXG4gIGlmIChfc2VsZWN0UG9wdWxhdGVkUGF0aHMpIHtcbiAgICBzZWxlY3RQb3B1bGF0ZWRGaWVsZHModGhpcy5fZmllbGRzLCB0aGlzLl91c2VyUHJvdmlkZWRGaWVsZHMsIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHdyYXBwZXIgYXJvdW5kIGEgW21vbmdvZGIgZHJpdmVyIGN1cnNvcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0ZpbmRDdXJzb3IuaHRtbCkuXG4gKiBBIFF1ZXJ5Q3Vyc29yIGV4cG9zZXMgYSBTdHJlYW1zMyBpbnRlcmZhY2UsIGFzIHdlbGwgYXMgYSBgLm5leHQoKWAgZnVuY3Rpb24uXG4gKlxuICogVGhlIGAuY3Vyc29yKClgIGZ1bmN0aW9uIHRyaWdnZXJzIHByZSBmaW5kIGhvb2tzLCBidXQgKipub3QqKiBwb3N0IGZpbmQgaG9va3MuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBUaGVyZSBhcmUgMiB3YXlzIHRvIHVzZSBhIGN1cnNvci4gRmlyc3QsIGFzIGEgc3RyZWFtOlxuICogICAgIFRoaW5nLlxuICogICAgICAgZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLlxuICogICAgICAgY3Vyc29yKCkuXG4gKiAgICAgICBvbignZGF0YScsIGZ1bmN0aW9uKGRvYykgeyBjb25zb2xlLmxvZyhkb2MpOyB9KS5cbiAqICAgICAgIG9uKCdlbmQnLCBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ0RvbmUhJyk7IH0pO1xuICpcbiAqICAgICAvLyBPciB5b3UgY2FuIHVzZSBgLm5leHQoKWAgdG8gbWFudWFsbHkgZ2V0IHRoZSBuZXh0IGRvYyBpbiB0aGUgc3RyZWFtLlxuICogICAgIC8vIGAubmV4dCgpYCByZXR1cm5zIGEgcHJvbWlzZSwgc28geW91IGNhbiB1c2UgcHJvbWlzZXMgb3IgY2FsbGJhY2tzLlxuICogICAgIGNvbnN0IGN1cnNvciA9IFRoaW5nLmZpbmQoeyBuYW1lOiAvXmhlbGxvLyB9KS5jdXJzb3IoKTtcbiAqICAgICBjdXJzb3IubmV4dChmdW5jdGlvbihlcnJvciwgZG9jKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBCZWNhdXNlIGAubmV4dCgpYCByZXR1cm5zIGEgcHJvbWlzZSwgeW91IGNhbiB1c2UgY29cbiAqICAgICAvLyB0byBlYXNpbHkgaXRlcmF0ZSB0aHJvdWdoIGFsbCBkb2N1bWVudHMgd2l0aG91dCBsb2FkaW5nIHRoZW1cbiAqICAgICAvLyBhbGwgaW50byBtZW1vcnkuXG4gKiAgICAgY29uc3QgY3Vyc29yID0gVGhpbmcuZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLmN1cnNvcigpO1xuICogICAgIGZvciAobGV0IGRvYyA9IGF3YWl0IGN1cnNvci5uZXh0KCk7IGRvYyAhPSBudWxsOyBkb2MgPSBhd2FpdCBjdXJzb3IubmV4dCgpKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MpO1xuICogICAgIH1cbiAqXG4gKiAjIyMjIFZhbGlkIG9wdGlvbnNcbiAqXG4gKiAgIC0gYHRyYW5zZm9ybWA6IG9wdGlvbmFsIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgYSBtb25nb29zZSBkb2N1bWVudC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gd2lsbCBiZSBlbWl0dGVkIG9uIGBkYXRhYCBhbmQgcmV0dXJuZWQgYnkgYC5uZXh0KClgLlxuICpcbiAqIEByZXR1cm4ge1F1ZXJ5Q3Vyc29yfVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHNlZSBRdWVyeUN1cnNvciBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Y3Vyc29yLmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmN1cnNvciA9IGZ1bmN0aW9uIGN1cnNvcihvcHRzKSB7XG4gIGlmIChvcHRzKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdHMpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmNhc3QodGhpcy5tb2RlbCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAobmV3IFF1ZXJ5Q3Vyc29yKHRoaXMpKS5fbWFya0Vycm9yKGVycik7XG4gIH1cblxuICByZXR1cm4gbmV3IFF1ZXJ5Q3Vyc29yKHRoaXMpO1xufTtcblxuLy8gdGhlIHJlc3Qgb2YgdGhlc2UgYXJlIGJhc2ljYWxseSB0byBzdXBwb3J0IG9sZGVyIE1vbmdvb3NlIHN5bnRheCB3aXRoIG1xdWVyeVxuXG4vKipcbiAqIFNldHMgdGhlIHRhaWxhYmxlIG9wdGlvbiAoZm9yIHVzZSB3aXRoIGNhcHBlZCBjb2xsZWN0aW9ucykuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS50YWlsYWJsZSgpOyAvLyB0cnVlXG4gKiAgICAgcXVlcnkudGFpbGFibGUodHJ1ZSk7XG4gKiAgICAgcXVlcnkudGFpbGFibGUoZmFsc2UpO1xuICpcbiAqICAgICAvLyBTZXQgYm90aCBgdGFpbGFibGVgIGFuZCBgYXdhaXREYXRhYCBvcHRpb25zXG4gKiAgICAgcXVlcnkudGFpbGFibGUoeyBhd2FpdERhdGE6IHRydWUgfSk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBib29sIGRlZmF1bHRzIHRvIHRydWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gb3B0aW9ucyB0byBzZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdHMuYXdhaXREYXRhXSBmYWxzZSBieSBkZWZhdWx0LiBTZXQgdG8gdHJ1ZSB0byBrZWVwIHRoZSBjdXJzb3Igb3BlbiBldmVuIGlmIHRoZXJlJ3Mgbm8gZGF0YS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy5tYXhBd2FpdFRpbWVNU10gdGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgZm9yIHRoZSBzZXJ2ZXIgdG8gd2FpdCBvbiBuZXcgZG9jdW1lbnRzIHRvIHNhdGlzZnkgYSB0YWlsYWJsZSBjdXJzb3IgcXVlcnkuIFJlcXVpcmVzIGB0YWlsYWJsZWAgYW5kIGBhd2FpdERhdGFgIHRvIGJlIHRydWVcbiAqIEBzZWUgdGFpbGFibGUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvdHV0b3JpYWwvY3JlYXRlLXRhaWxhYmxlLWN1cnNvci9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnRhaWxhYmxlID0gZnVuY3Rpb24odmFsLCBvcHRzKSB7XG4gIC8vIHdlIG5lZWQgdG8gc3VwcG9ydCB0aGUgdGFpbGFibGUoeyBhd2FpdERhdGEgOiB0cnVlIH0pIGFzIHdlbGwgYXMgdGhlXG4gIC8vIHRhaWxhYmxlKHRydWUsIHthd2FpdERhdGEgOnRydWV9KSBzeW50YXggdGhhdCBtcXVlcnkgZG9lcyBub3Qgc3VwcG9ydFxuICBpZiAodmFsICE9IG51bGwgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICBvcHRzID0gdmFsO1xuICAgIHZhbCA9IHRydWU7XG4gIH1cblxuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wdHMgJiYgdHlwZW9mIG9wdHMgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0cykpIHtcbiAgICAgIGlmIChrZXkgPT09ICdhd2FpdERhdGEnIHx8IGtleSA9PT0gJ2F3YWl0ZGF0YScpIHsgLy8gYmFja3dhcmRzIGNvbXBhdCwgc2VlIGdoLTEwODc1XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICB0aGlzLm9wdGlvbnNbJ2F3YWl0RGF0YSddID0gISFvcHRzW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IG9wdHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUXVlcnkuYmFzZS50YWlsYWJsZS5jYWxsKHRoaXMsIHZhbCk7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGFuIGludGVyc2VjdHMgcXVlcnkgZm9yIGBnZW9tZXRyeSgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdwYXRoJykuaW50ZXJzZWN0cygpLmdlb21ldHJ5KHtcbiAqICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAqICAgICAgIGNvb3JkaW5hdGVzOiBbWzE4MC4wLCAxMS4wXSwgWzE4MCwgOS4wXV1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ3BhdGgnKS5pbnRlcnNlY3RzKHtcbiAqICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAqICAgICAgIGNvb3JkaW5hdGVzOiBbWzE4MC4wLCAxMS4wXSwgWzE4MCwgOS4wXV1cbiAqICAgICB9KTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogKipNVVNUKiogYmUgdXNlZCBhZnRlciBgd2hlcmUoKWAuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIEluIE1vbmdvb3NlIDMuNywgYGludGVyc2VjdHNgIGNoYW5nZWQgZnJvbSBhIGdldHRlciB0byBhIGZ1bmN0aW9uLiBJZiB5b3UgbmVlZCB0aGUgb2xkIHN5bnRheCwgdXNlIFt0aGlzXShodHRwczovL2dpdGh1Yi5jb20vZWJlbnNpbmcvbW9uZ29vc2Utd2l0aGluKS5cbiAqXG4gKiBAbWV0aG9kIGludGVyc2VjdHNcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRnZW9tZXRyeSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ2VvbWV0cnkvXG4gKiBAc2VlIGdlb0ludGVyc2VjdHMgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2dlb0ludGVyc2VjdHMvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRnZW9tZXRyeWAgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBwb2x5QSA9IFtbWyAxMCwgMjAgXSwgWyAxMCwgNDAgXSwgWyAzMCwgNDAgXSwgWyAzMCwgMjAgXV1dXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ1BvbHlnb24nLCBjb29yZGluYXRlczogcG9seUEgfSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICBjb25zdCBwb2x5QiA9IFtbIDAsIDAgXSwgWyAxLCAxIF1dXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ0xpbmVTdHJpbmcnLCBjb29yZGluYXRlczogcG9seUIgfSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICBjb25zdCBwb2x5QyA9IFsgMCwgMCBdXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IHBvbHlDIH0pXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLmludGVyc2VjdHMoKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBwb2x5QyB9KVxuICpcbiAqIFRoZSBhcmd1bWVudCBpcyBhc3NpZ25lZCB0byB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBgZ2VvbWV0cnkoKWAgKiptdXN0KiogY29tZSBhZnRlciBlaXRoZXIgYGludGVyc2VjdHMoKWAgb3IgYHdpdGhpbigpYC5cbiAqXG4gKiBUaGUgYG9iamVjdGAgYXJndW1lbnQgbXVzdCBjb250YWluIGB0eXBlYCBhbmQgYGNvb3JkaW5hdGVzYCBwcm9wZXJ0aWVzLlxuICogLSB0eXBlIHtTdHJpbmd9XG4gKiAtIGNvb3JkaW5hdGVzIHtBcnJheX1cbiAqXG4gKiBAbWV0aG9kIGdlb21ldHJ5XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBNdXN0IGNvbnRhaW4gYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggaXMgYSBTdHJpbmcgYW5kIGEgYGNvb3JkaW5hdGVzYCBwcm9wZXJ0eSB3aGljaCBpcyBhbiBBcnJheS4gU2VlIHRoZSBleGFtcGxlcy5cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRnZW9tZXRyeSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ2VvbWV0cnkvXG4gKiBAc2VlIEdlb3NwYXRpYWwgU3VwcG9ydCBFbmhhbmNlbWVudHMgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVsZWFzZS1ub3Rlcy8yLjQvI2dlb3NwYXRpYWwtc3VwcG9ydC1lbmhhbmNlbWVudHNcbiAqIEBzZWUgTW9uZ29EQiBHZW9zcGF0aWFsIEluZGV4aW5nIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvZ2Vvc3BhdGlhbC1pbmRleGVzL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkbmVhcmAgb3IgYCRuZWFyU3BoZXJlYCBjb25kaXRpb25cbiAqXG4gKiBUaGVzZSBvcGVyYXRvcnMgcmV0dXJuIGRvY3VtZW50cyBzb3J0ZWQgYnkgZGlzdGFuY2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhcih7IGNlbnRlcjogWzEwLCAxMF0gfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhcih7IGNlbnRlcjogWzEwLCAxMF0sIG1heERpc3RhbmNlOiA1LCBzcGhlcmljYWw6IHRydWUgfSk7XG4gKiAgICAgcXVlcnkubmVhcignbG9jJywgeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSB9KTtcbiAqXG4gKiBAbWV0aG9kIG5lYXJcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSAkbmVhciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbmVhci9cbiAqIEBzZWUgJG5lYXJTcGhlcmUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL25lYXJTcGhlcmUvXG4gKiBAc2VlICRtYXhEaXN0YW5jZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWF4RGlzdGFuY2UvXG4gKiBAc2VlIE1vbmdvREIgR2Vvc3BhdGlhbCBJbmRleGluZyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2dlb3NwYXRpYWwtaW5kZXhlcy9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBPdmVyd3JpdGluZyBtcXVlcnkgaXMgbmVlZGVkIHRvIHN1cHBvcnQgYSBjb3VwbGUgZGlmZmVyZW50IG5lYXIoKSBmb3JtcyBmb3VuZCBpbiBvbGRlclxuICogdmVyc2lvbnMgb2YgbW9uZ29vc2VcbiAqIG5lYXIoWzEsMV0pXG4gKiBuZWFyKDEsMSlcbiAqIG5lYXIoZmllbGQsIFsxLDJdKVxuICogbmVhcihmaWVsZCwgMSwgMilcbiAqIEluIGFkZGl0aW9uIHRvIGFsbCBvZiB0aGUgbm9ybWFsIGZvcm1zIHN1cHBvcnRlZCBieSBtcXVlcnlcbiAqXG4gKiBAbWV0aG9kIG5lYXJcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubmVhciA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgY29uc3Qgc3BoZXJlID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zLm5lYXJTcGhlcmU7XG5cbiAgLy8gVE9ETyByZWZhY3RvclxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgcGFyYW1zLnB1c2goeyBjZW50ZXI6IGFyZ3VtZW50c1swXSwgc3BoZXJpY2FsOiBzcGhlcmUgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgLy8ganVzdCBwYXNzaW5nIGEgcGF0aFxuICAgICAgcGFyYW1zLnB1c2goYXJndW1lbnRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdLnNwaGVyaWNhbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXS5zcGhlcmljYWwgPSBzcGhlcmU7XG4gICAgICB9XG4gICAgICBwYXJhbXMucHVzaChhcmd1bWVudHNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHBhcmFtcy5wdXNoKHsgY2VudGVyOiBbYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV1dLCBzcGhlcmljYWw6IHNwaGVyZSB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzFdKSkge1xuICAgICAgcGFyYW1zLnB1c2goYXJndW1lbnRzWzBdKTtcbiAgICAgIHBhcmFtcy5wdXNoKHsgY2VudGVyOiBhcmd1bWVudHNbMV0sIHNwaGVyaWNhbDogc3BoZXJlIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycgJiYgdXRpbHMuaXNPYmplY3QoYXJndW1lbnRzWzFdKSkge1xuICAgICAgcGFyYW1zLnB1c2goYXJndW1lbnRzWzBdKTtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdLnNwaGVyaWNhbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGFyZ3VtZW50c1sxXS5zcGhlcmljYWwgPSBzcGhlcmU7XG4gICAgICB9XG4gICAgICBwYXJhbXMucHVzaChhcmd1bWVudHNbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcidcbiAgICAgICAgJiYgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGFyZ3VtZW50c1swXSk7XG4gICAgICBwYXJhbXMucHVzaCh7IGNlbnRlcjogW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXSwgc3BoZXJpY2FsOiBzcGhlcmUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgcmV0dXJuIFF1ZXJ5LmJhc2UubmVhci5hcHBseSh0aGlzLCBwYXJhbXMpO1xufTtcblxuLyoqXG4gKiBfREVQUkVDQVRFRF8gU3BlY2lmaWVzIGEgYCRuZWFyU3BoZXJlYCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5uZWFyU3BoZXJlKHsgY2VudGVyOiBbMTAsIDEwXSwgbWF4RGlzdGFuY2U6IDUgfSk7XG4gKlxuICogKipEZXByZWNhdGVkLioqIFVzZSBgcXVlcnkubmVhcigpYCBpbnN0ZWFkIHdpdGggdGhlIGBzcGhlcmljYWxgIG9wdGlvbiBzZXQgdG8gYHRydWVgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdLCBzcGhlcmljYWw6IHRydWUgfSk7XG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBzZWUgbmVhcigpIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubmVhcigpXG4gKiBAc2VlICRuZWFyIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9uZWFyL1xuICogQHNlZSAkbmVhclNwaGVyZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbmVhclNwaGVyZS9cbiAqIEBzZWUgJG1heERpc3RhbmNlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9tYXhEaXN0YW5jZS9cbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubmVhclNwaGVyZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9tb25nb29zZU9wdGlvbnMubmVhclNwaGVyZSA9IHRydWU7XG4gIHRoaXMubmVhci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhc3luY0l0ZXJhdG9yIGZvciB1c2Ugd2l0aCBbYGZvci9hd2FpdC9vZmAgbG9vcHNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vZ2V0dGluZy1zdGFydGVkLXdpdGgtYXN5bmMtaXRlcmF0b3JzLWluLW5vZGUtanMpXG4gKiBUaGlzIGZ1bmN0aW9uICpvbmx5KiB3b3JrcyBmb3IgYGZpbmQoKWAgcXVlcmllcy5cbiAqIFlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gZXhwbGljaXRseSwgdGhlIEphdmFTY3JpcHQgcnVudGltZVxuICogd2lsbCBjYWxsIGl0IGZvciB5b3UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBNb2RlbC5hZ2dyZWdhdGUoW3sgJHNvcnQ6IHsgbmFtZTogMSB9IH1dKSkge1xuICogICAgICAgY29uc29sZS5sb2coZG9jLm5hbWUpO1xuICogICAgIH1cbiAqXG4gKiBOb2RlLmpzIDEwLnggc3VwcG9ydHMgYXN5bmMgaXRlcmF0b3JzIG5hdGl2ZWx5IHdpdGhvdXQgYW55IGZsYWdzLiBZb3UgY2FuXG4gKiBlbmFibGUgYXN5bmMgaXRlcmF0b3JzIGluIE5vZGUuanMgOC54IHVzaW5nIHRoZSBbYC0taGFybW9ueV9hc3luY19pdGVyYXRpb25gIGZsYWddKGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFzeW5jLWl0ZXJhdGlvbi9pc3N1ZXMvMTE3I2lzc3VlY29tbWVudC0zNDY2OTUxODcpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBpZiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIHVuZGVmaW5lZC4gSWZcbiAqIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgaXMgdW5kZWZpbmVkLCB0aGF0IG1lYW5zIHlvdXIgTm9kZS5qcyB2ZXJzaW9uIGRvZXMgbm90XG4gKiBzdXBwb3J0IGFzeW5jIGl0ZXJhdG9ycy5cbiAqXG4gKiBAbWV0aG9kIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl1cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciAhPSBudWxsKSB7XG4gIFF1ZXJ5LnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJzb3IoKS50cmFuc2Zvcm1OdWxsKCkuX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJHBvbHlnb25gIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLnBvbHlnb24oWzEwLCAyMF0sIFsxMywgMjVdLCBbNywgMTVdKTtcbiAqICAgICBxdWVyeS5wb2x5Z29uKCdsb2MnLCBbMTAsIDIwXSwgWzEzLCAyNV0sIFs3LCAxNV0pO1xuICpcbiAqIEBtZXRob2QgcG9seWdvblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbcGF0aF1cbiAqIEBwYXJhbSB7Li4uQXJyYXl8T2JqZWN0fSBbY29vcmRpbmF0ZVBhaXJzXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgJHBvbHlnb24gaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3BvbHlnb24vXG4gKiBAc2VlIE1vbmdvREIgR2Vvc3BhdGlhbCBJbmRleGluZyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2dlb3NwYXRpYWwtaW5kZXhlcy9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGJveGAgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBsb3dlckxlZnQgPSBbNDAuNzMwODMsIC03My45OTc1Nl1cbiAqICAgICBjb25zdCB1cHBlclJpZ2h0PSBbNDAuNzQxNDA0LCAgLTczLjk4ODEzNV1cbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmJveChsb3dlckxlZnQsIHVwcGVyUmlnaHQpXG4gKiAgICAgcXVlcnkuYm94KHsgbGwgOiBsb3dlckxlZnQsIHVyIDogdXBwZXJSaWdodCB9KVxuICpcbiAqIEBtZXRob2QgYm94XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHNlZSAkYm94IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9ib3gvXG4gKiBAc2VlIHdpdGhpbigpIFF1ZXJ5I3dpdGhpbiBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLndpdGhpbigpXG4gKiBAc2VlIE1vbmdvREIgR2Vvc3BhdGlhbCBJbmRleGluZyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2dlb3NwYXRpYWwtaW5kZXhlcy9cbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5PE51bWJlcj59IHZhbDEgTG93ZXIgTGVmdCBDb29yZGluYXRlcyBPUiBhIG9iamVjdCBvZiBsb3dlci1sZWZ0KGxsKSBhbmQgdXBwZXItcmlnaHQodXIpIENvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IFt2YWwyXSBVcHBlciBSaWdodCBDb29yZGluYXRlc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiB0aGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IHRoZSBtb25nb29zZSBzeW50YXggb2Y6XG4gKiBib3goZmllbGQsIHsgbGwgOiBbeCx5XSwgdXIgOiBbeDIseTJdIH0pXG4gKiBib3goeyBsbCA6IFt4LHldLCB1ciA6IFt4Mix5Ml0gfSlcbiAqXG4gKiBAbWV0aG9kIGJveFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5ib3ggPSBmdW5jdGlvbihsbCwgdXIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxsKSAmJiB1dGlscy5pc09iamVjdChsbCkpIHtcbiAgICB1ciA9IGxsLnVyO1xuICAgIGxsID0gbGwubGw7XG4gIH1cbiAgcmV0dXJuIFF1ZXJ5LmJhc2UuYm94LmNhbGwodGhpcywgbGwsIHVyKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRjZW50ZXJgIG9yIGAkY2VudGVyU3BoZXJlYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhcmVhID0geyBjZW50ZXI6IFs1MCwgNTBdLCByYWRpdXM6IDEwLCB1bmlxdWU6IHRydWUgfVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5jaXJjbGUoYXJlYSlcbiAqICAgICAvLyBhbHRlcm5hdGl2ZWx5XG4gKiAgICAgcXVlcnkuY2lyY2xlKCdsb2MnLCBhcmVhKTtcbiAqXG4gKiAgICAgLy8gc3BoZXJpY2FsIGNhbGN1bGF0aW9uc1xuICogICAgIGNvbnN0IGFyZWEgPSB7IGNlbnRlcjogWzUwLCA1MF0sIHJhZGl1czogMTAsIHVuaXF1ZTogdHJ1ZSwgc3BoZXJpY2FsOiB0cnVlIH1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuY2lyY2xlKGFyZWEpXG4gKiAgICAgLy8gYWx0ZXJuYXRpdmVseVxuICogICAgIHF1ZXJ5LmNpcmNsZSgnbG9jJywgYXJlYSk7XG4gKlxuICogQG1ldGhvZCBjaXJjbGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge09iamVjdH0gYXJlYVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgJGNlbnRlciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvY2VudGVyL1xuICogQHNlZSAkY2VudGVyU3BoZXJlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9jZW50ZXJTcGhlcmUvXG4gKiBAc2VlICRnZW9XaXRoaW4gaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2dlb1dpdGhpbi9cbiAqIEBzZWUgTW9uZ29EQiBHZW9zcGF0aWFsIEluZGV4aW5nIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvZ2Vvc3BhdGlhbC1pbmRleGVzL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIF9ERVBSRUNBVEVEXyBBbGlhcyBmb3IgW2NpcmNsZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5jaXJjbGUoKSlcbiAqXG4gKiAqKkRlcHJlY2F0ZWQuKiogVXNlIFtjaXJjbGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY2lyY2xlKCkpIGluc3RlYWQuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBtZXRob2QgY2VudGVyXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY2VudGVyID0gUXVlcnkuYmFzZS5jaXJjbGU7XG5cbi8qKlxuICogX0RFUFJFQ0FURURfIFNwZWNpZmllcyBhIGAkY2VudGVyU3BoZXJlYCBjb25kaXRpb25cbiAqXG4gKiAqKkRlcHJlY2F0ZWQuKiogVXNlIFtjaXJjbGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY2lyY2xlKCkpIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhcmVhID0geyBjZW50ZXI6IFs1MCwgNTBdLCByYWRpdXM6IDEwIH07XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmNlbnRlclNwaGVyZShhcmVhKTtcbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9uZ29EQiBHZW9zcGF0aWFsIEluZGV4aW5nIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvZ2Vvc3BhdGlhbC1pbmRleGVzL1xuICogQHNlZSAkY2VudGVyU3BoZXJlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9jZW50ZXJTcGhlcmUvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jZW50ZXJTcGhlcmUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSAhPSBudWxsICYmIHR5cGVvZiBhcmd1bWVudHNbMF0uY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzWzBdLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgYXJndW1lbnRzWzBdLnNwaGVyaWNhbCA9IHRydWU7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzWzFdICE9IG51bGwgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXS5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHNbMV0uY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICBhcmd1bWVudHNbMV0uc3BoZXJpY2FsID0gdHJ1ZTtcbiAgfVxuXG4gIFF1ZXJ5LmJhc2UuY2lyY2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogQG1ldGhvZCBzZWxlY3RlZFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBpbmNsdXNpdmUgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogICAgIHF1ZXJ5LnNlbGVjdGVkSW5jbHVzaXZlbHkoKTsgLy8gZmFsc2VcbiAqICAgICBxdWVyeS5zZWxlY3QoJ25hbWUnKTtcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCk7IC8vIHRydWVcbiAqXG4gKiBAbWV0aG9kIHNlbGVjdGVkSW5jbHVzaXZlbHlcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2VsZWN0ZWRJbmNsdXNpdmVseSA9IGZ1bmN0aW9uIHNlbGVjdGVkSW5jbHVzaXZlbHkoKSB7XG4gIHJldHVybiBpc0luY2x1c2l2ZSh0aGlzLl9maWVsZHMpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGV4Y2x1c2l2ZSBmaWVsZCBzZWxlY3Rpb24gaGFzIGJlZW4gbWFkZS5cbiAqXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRFeGNsdXNpdmVseSgpOyAvLyBmYWxzZVxuICogICAgIHF1ZXJ5LnNlbGVjdCgnLW5hbWUnKTtcbiAqICAgICBxdWVyeS5zZWxlY3RlZEV4Y2x1c2l2ZWx5KCk7IC8vIHRydWVcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCk7IC8vIGZhbHNlXG4gKlxuICogQG1ldGhvZCBzZWxlY3RlZEV4Y2x1c2l2ZWx5XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdGVkRXhjbHVzaXZlbHkgPSBmdW5jdGlvbiBzZWxlY3RlZEV4Y2x1c2l2ZWx5KCkge1xuICByZXR1cm4gaXNFeGNsdXNpdmUodGhpcy5fZmllbGRzKTtcbn07XG5cbi8qKlxuICogVGhlIG1vZGVsIHRoaXMgcXVlcnkgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcSA9IE15TW9kZWwuZmluZCgpO1xuICogICAgIHEubW9kZWwgPT09IE15TW9kZWw7IC8vIHRydWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1vZGVsXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5tb2RlbDtcblxuLyohXG4gKiBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/query.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/queryhelpers.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/queryhelpers.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection =\n  __webpack_require__(/*! ./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue =\n  __webpack_require__(/*! ./helpers/discriminator/getDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst isDefiningProjection = __webpack_require__(/*! ./helpers/projection/isDefiningProjection */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst isPathSelectedInclusive = __webpack_require__(/*! ./helpers/projection/isPathSelectedInclusive */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\");\n\n/**\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => (p && p.options && p.options.lean) == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/**\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => (p && p.options && p.options.lean) == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  const session = query && query.options && query.options.session || null;\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/**\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping && discriminatorMapping.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n  return new model(undefined, fields, _opts);\n};\n\n/*!\n * ignore\n */\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = populatedIds ?\n    { populated: populatedIds } :\n    undefined;\n\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  const minusPathsToSkip = new Set();\n\n  if (fields) {\n    keys = Object.keys(fields);\n\n    // Collapse minus paths\n    const minusPaths = [];\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (keys[i][0] !== '-') {\n        continue;\n      }\n\n      delete fields[key];\n      if (key === '-_id') {\n        fields['_id'] = 0;\n      } else {\n        minusPaths.push(key.slice(1));\n      }\n    }\n\n    keys = Object.keys(fields);\n    for (let keyIndex = 0; keyIndex < keys.length; ++keyIndex) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      if (keys[keyIndex] === '_id' && keys.length > 1) {\n        continue;\n      }\n      if (keys[keyIndex] === schema.options.discriminatorKey && keys.length > 1 && field != null && !field) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n\n    // Potentially add back minus paths based on schema-level path config\n    // and whether the projection is inclusive\n    for (const path of minusPaths) {\n      const type = schema.path(path);\n      // If the path isn't selected by default or the projection is not\n      // inclusive, minus path is treated as equivalent to `key: 0`.\n      // But we also allow using `-name` to remove `name` from an inclusive\n      // projection if `name` has schema-level `select: true`.\n      if ((!type || !type.selected) || exclude !== false) {\n        fields[path] = 0;\n        exclude = true;\n      } else if (type && type.selected && exclude === false) {\n        // Make a note of minus paths that are overwriting paths that are\n        // included by default.\n        minusPathsToSkip.add(path);\n      }\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  analyzeSchema(schema);\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        if (minusPathsToSkip.has(fieldName)) {\n          continue;\n        }\n        if (isPathSelectedInclusive(fields, fieldName)) {\n          continue;\n        }\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        if (fields[fieldName] != null) {\n          // Skip applying default projections to fields with non-defining\n          // projections, like `$slice`\n          continue;\n        }\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n\n    const addedPaths = [];\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        const plusPath = '+' + path;\n        const hasPlusPath = fields && plusPath in fields;\n        if (type.options && type.options.select === false && !hasPlusPath) {\n          excluded.push(path);\n        }\n        return;\n      }\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\n            selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    if (fields == null) {\n      return;\n    }\n\n    // If schema-level selected not set, nothing to do\n    if (typeof type.selected !== 'boolean') {\n      return;\n    }\n\n    // User overwriting default exclusion\n    if (type.selected === false && fields[path]) {\n      return;\n    }\n\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n    if (!exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    if (exclude === false && type.selected && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/**\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.\n        filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).\n        map(path => path.slice(option.path.length + 1));\n    }\n\n    option.options.lean = val;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcXVlcnloZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsbUJBQU8sQ0FBQyxtTEFBaUU7QUFDM0UsWUFBWSxtQkFBTyxDQUFDLCtFQUFlO0FBQ25DO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLG1KQUFpRDtBQUMzRCw2QkFBNkIsbUJBQU8sQ0FBQyx1SUFBMkM7QUFDaEYsY0FBYyxtQkFBTyxDQUFDLG1GQUFpQjtBQUN2QyxnQ0FBZ0MsbUJBQU8sQ0FBQyw2SUFBOEM7O0FBRXRGO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaOztBQUVBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQSxNQUFNLDBCQUEwQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxccXVlcnloZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxuY29uc3QgY2hlY2tFbWJlZGRlZERpc2NyaW1pbmF0b3JLZXlQcm9qZWN0aW9uID1cbiAgcmVxdWlyZSgnLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvY2hlY2tFbWJlZGRlZERpc2NyaW1pbmF0b3JLZXlQcm9qZWN0aW9uJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Jyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9XG4gIHJlcXVpcmUoJy4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBpc0RlZmluaW5nUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzRGVmaW5pbmdQcm9qZWN0aW9uJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvamVjdGlvbi9pc1BhdGhTZWxlY3RlZEluY2x1c2l2ZScpO1xuXG4vKipcbiAqIFByZXBhcmUgYSBzZXQgb2YgcGF0aCBvcHRpb25zIGZvciBxdWVyeSBwb3B1bGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZXhwb3J0cy5wcmVwYXJlUG9wdWxhdGlvbk9wdGlvbnMgPSBmdW5jdGlvbiBwcmVwYXJlUG9wdWxhdGlvbk9wdGlvbnMocXVlcnksIG9wdGlvbnMpIHtcbiAgY29uc3QgX3BvcHVsYXRlID0gcXVlcnkub3B0aW9ucy5wb3B1bGF0ZTtcbiAgY29uc3QgcG9wID0gT2JqZWN0LmtleXMoX3BvcHVsYXRlKS5yZWR1Y2UoKHZhbHMsIGtleSkgPT4gdmFscy5jb25jYXQoW19wb3B1bGF0ZVtrZXldXSksIFtdKTtcblxuICAvLyBsZWFuIG9wdGlvbnMgc2hvdWxkIHRyaWNrbGUgdGhyb3VnaCBhbGwgcXVlcmllc1xuICBpZiAob3B0aW9ucy5sZWFuICE9IG51bGwpIHtcbiAgICBwb3BcbiAgICAgIC5maWx0ZXIocCA9PiAocCAmJiBwLm9wdGlvbnMgJiYgcC5vcHRpb25zLmxlYW4pID09IG51bGwpXG4gICAgICAuZm9yRWFjaChtYWtlTGVhbihvcHRpb25zLmxlYW4pKTtcbiAgfVxuXG4gIHBvcC5mb3JFYWNoKG9wdHMgPT4ge1xuICAgIG9wdHMuX2xvY2FsTW9kZWwgPSBxdWVyeS5tb2RlbDtcbiAgfSk7XG5cbiAgcmV0dXJuIHBvcDtcbn07XG5cbi8qKlxuICogUHJlcGFyZSBhIHNldCBvZiBwYXRoIG9wdGlvbnMgZm9yIHF1ZXJ5IHBvcHVsYXRpb24uIFRoaXMgaXMgdGhlIE1vbmdvb3NlUXVlcnlcbiAqIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge1F1ZXJ5fSBxdWVyeVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmV4cG9ydHMucHJlcGFyZVBvcHVsYXRpb25PcHRpb25zTVEgPSBmdW5jdGlvbiBwcmVwYXJlUG9wdWxhdGlvbk9wdGlvbnNNUShxdWVyeSwgb3B0aW9ucykge1xuICBjb25zdCBfcG9wdWxhdGUgPSBxdWVyeS5fbW9uZ29vc2VPcHRpb25zLnBvcHVsYXRlO1xuICBjb25zdCBwb3AgPSBPYmplY3Qua2V5cyhfcG9wdWxhdGUpLnJlZHVjZSgodmFscywga2V5KSA9PiB2YWxzLmNvbmNhdChbX3BvcHVsYXRlW2tleV1dKSwgW10pO1xuXG4gIC8vIGxlYW4gb3B0aW9ucyBzaG91bGQgdHJpY2tsZSB0aHJvdWdoIGFsbCBxdWVyaWVzXG4gIGlmIChvcHRpb25zLmxlYW4gIT0gbnVsbCkge1xuICAgIHBvcFxuICAgICAgLmZpbHRlcihwID0+IChwICYmIHAub3B0aW9ucyAmJiBwLm9wdGlvbnMubGVhbikgPT0gbnVsbClcbiAgICAgIC5mb3JFYWNoKG1ha2VMZWFuKG9wdGlvbnMubGVhbikpO1xuICB9XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IHF1ZXJ5ICYmIHF1ZXJ5Lm9wdGlvbnMgJiYgcXVlcnkub3B0aW9ucy5zZXNzaW9uIHx8IG51bGw7XG4gIGlmIChzZXNzaW9uICE9IG51bGwpIHtcbiAgICBwb3AuZm9yRWFjaChwYXRoID0+IHtcbiAgICAgIGlmIChwYXRoLm9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBwYXRoLm9wdGlvbnMgPSB7IHNlc3Npb246IHNlc3Npb24gfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCEoJ3Nlc3Npb24nIGluIHBhdGgub3B0aW9ucykpIHtcbiAgICAgICAgcGF0aC5vcHRpb25zLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgcHJvamVjdGlvbiA9IHF1ZXJ5Ll9maWVsZHNGb3JFeGVjKCk7XG4gIHBvcC5mb3JFYWNoKHAgPT4ge1xuICAgIHAuX3F1ZXJ5UHJvamVjdGlvbiA9IHByb2plY3Rpb247XG4gIH0pO1xuICBwb3AuZm9yRWFjaChvcHRzID0+IHtcbiAgICBvcHRzLl9sb2NhbE1vZGVsID0gcXVlcnkubW9kZWw7XG4gIH0pO1xuXG4gIHJldHVybiBwb3A7XG59O1xuXG4vKipcbiAqIElmIHRoZSBkb2N1bWVudCBpcyBhIG1hcHBlZCBkaXNjcmltaW5hdG9yIHR5cGUsIGl0IHJldHVybnMgYSBtb2RlbCBpbnN0YW5jZSBmb3IgdGhhdCB0eXBlLCBvdGhlcndpc2UsXG4gKiBpdCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBtb2RlbC5cbiAqXG4gKiBAcGFyYW0ge01vZGVsfSAgbW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAqXG4gKiBAcmV0dXJuIHtEb2N1bWVudH1cbiAqL1xuZXhwb3J0cy5jcmVhdGVNb2RlbCA9IGZ1bmN0aW9uIGNyZWF0ZU1vZGVsKG1vZGVsLCBkb2MsIGZpZWxkcywgdXNlclByb3ZpZGVkRmllbGRzLCBvcHRpb25zKSB7XG4gIG1vZGVsLmhvb2tzLmV4ZWNQcmVTeW5jKCdjcmVhdGVNb2RlbCcsIGRvYyk7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JNYXBwaW5nID0gbW9kZWwuc2NoZW1hID9cbiAgICBtb2RlbC5zY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgOlxuICAgIG51bGw7XG5cbiAgY29uc3Qga2V5ID0gZGlzY3JpbWluYXRvck1hcHBpbmcgJiYgZGlzY3JpbWluYXRvck1hcHBpbmcuaXNSb290ID9cbiAgICBkaXNjcmltaW5hdG9yTWFwcGluZy5rZXkgOlxuICAgIG51bGw7XG5cbiAgY29uc3QgdmFsdWUgPSBkb2Nba2V5XTtcbiAgaWYgKGtleSAmJiB2YWx1ZSAmJiBtb2RlbC5kaXNjcmltaW5hdG9ycykge1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSBtb2RlbC5kaXNjcmltaW5hdG9yc1t2YWx1ZV0gfHwgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUobW9kZWwuZGlzY3JpbWluYXRvcnMsIHZhbHVlKTtcbiAgICBpZiAoZGlzY3JpbWluYXRvcikge1xuICAgICAgY29uc3QgX2ZpZWxkcyA9IGNsb25lKHVzZXJQcm92aWRlZEZpZWxkcyk7XG4gICAgICBleHBvcnRzLmFwcGx5UGF0aHMoX2ZpZWxkcywgZGlzY3JpbWluYXRvci5zY2hlbWEpO1xuICAgICAgcmV0dXJuIG5ldyBkaXNjcmltaW5hdG9yKHVuZGVmaW5lZCwgX2ZpZWxkcywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgX29wdHMgPSB7XG4gICAgc2tpcElkOiB0cnVlLFxuICAgIGlzTmV3OiBmYWxzZSxcbiAgICB3aWxsSW5pdDogdHJ1ZVxuICB9O1xuICBpZiAob3B0aW9ucyAhPSBudWxsICYmICdkZWZhdWx0cycgaW4gb3B0aW9ucykge1xuICAgIF9vcHRzLmRlZmF1bHRzID0gb3B0aW9ucy5kZWZhdWx0cztcbiAgfVxuICByZXR1cm4gbmV3IG1vZGVsKHVuZGVmaW5lZCwgZmllbGRzLCBfb3B0cyk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuY3JlYXRlTW9kZWxBbmRJbml0ID0gZnVuY3Rpb24gY3JlYXRlTW9kZWxBbmRJbml0KG1vZGVsLCBkb2MsIGZpZWxkcywgdXNlclByb3ZpZGVkRmllbGRzLCBvcHRpb25zLCBwb3B1bGF0ZWRJZHMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGluaXRPcHRzID0gcG9wdWxhdGVkSWRzID9cbiAgICB7IHBvcHVsYXRlZDogcG9wdWxhdGVkSWRzIH0gOlxuICAgIHVuZGVmaW5lZDtcblxuICBjb25zdCBjYXN0ZWQgPSBleHBvcnRzLmNyZWF0ZU1vZGVsKG1vZGVsLCBkb2MsIGZpZWxkcywgdXNlclByb3ZpZGVkRmllbGRzLCBvcHRpb25zKTtcbiAgdHJ5IHtcbiAgICBjYXN0ZWQuJGluaXQoZG9jLCBpbml0T3B0cywgY2FsbGJhY2spO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhbGxiYWNrKGVycm9yLCBjYXN0ZWQpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuYXBwbHlQYXRocyA9IGZ1bmN0aW9uIGFwcGx5UGF0aHMoZmllbGRzLCBzY2hlbWEpIHtcbiAgLy8gZGV0ZXJtaW5lIGlmIHF1ZXJ5IGlzIHNlbGVjdGluZyBvciBleGNsdWRpbmcgZmllbGRzXG4gIGxldCBleGNsdWRlO1xuICBsZXQga2V5cztcbiAgY29uc3QgbWludXNQYXRoc1RvU2tpcCA9IG5ldyBTZXQoKTtcblxuICBpZiAoZmllbGRzKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkcyk7XG5cbiAgICAvLyBDb2xsYXBzZSBtaW51cyBwYXRoc1xuICAgIGNvbnN0IG1pbnVzUGF0aHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoa2V5c1tpXVswXSAhPT0gJy0nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgZmllbGRzW2tleV07XG4gICAgICBpZiAoa2V5ID09PSAnLV9pZCcpIHtcbiAgICAgICAgZmllbGRzWydfaWQnXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW51c1BhdGhzLnB1c2goa2V5LnNsaWNlKDEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgICBmb3IgKGxldCBrZXlJbmRleCA9IDA7IGtleUluZGV4IDwga2V5cy5sZW5ndGg7ICsra2V5SW5kZXgpIHtcbiAgICAgIGlmIChrZXlzW2tleUluZGV4XVswXSA9PT0gJysnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNba2V5c1trZXlJbmRleF1dO1xuICAgICAgLy8gU2tpcCBgJG1ldGFgIGFuZCBgJHNsaWNlYFxuICAgICAgaWYgKCFpc0RlZmluaW5nUHJvamVjdGlvbihmaWVsZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5c1trZXlJbmRleF0gPT09ICdfaWQnICYmIGtleXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlzW2tleUluZGV4XSA9PT0gc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSAmJiBrZXlzLmxlbmd0aCA+IDEgJiYgZmllbGQgIT0gbnVsbCAmJiAhZmllbGQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBleGNsdWRlID0gIWZpZWxkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gUG90ZW50aWFsbHkgYWRkIGJhY2sgbWludXMgcGF0aHMgYmFzZWQgb24gc2NoZW1hLWxldmVsIHBhdGggY29uZmlnXG4gICAgLy8gYW5kIHdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgaW5jbHVzaXZlXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIG1pbnVzUGF0aHMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEucGF0aChwYXRoKTtcbiAgICAgIC8vIElmIHRoZSBwYXRoIGlzbid0IHNlbGVjdGVkIGJ5IGRlZmF1bHQgb3IgdGhlIHByb2plY3Rpb24gaXMgbm90XG4gICAgICAvLyBpbmNsdXNpdmUsIG1pbnVzIHBhdGggaXMgdHJlYXRlZCBhcyBlcXVpdmFsZW50IHRvIGBrZXk6IDBgLlxuICAgICAgLy8gQnV0IHdlIGFsc28gYWxsb3cgdXNpbmcgYC1uYW1lYCB0byByZW1vdmUgYG5hbWVgIGZyb20gYW4gaW5jbHVzaXZlXG4gICAgICAvLyBwcm9qZWN0aW9uIGlmIGBuYW1lYCBoYXMgc2NoZW1hLWxldmVsIGBzZWxlY3Q6IHRydWVgLlxuICAgICAgaWYgKCghdHlwZSB8fCAhdHlwZS5zZWxlY3RlZCkgfHwgZXhjbHVkZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgZmllbGRzW3BhdGhdID0gMDtcbiAgICAgICAgZXhjbHVkZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgJiYgdHlwZS5zZWxlY3RlZCAmJiBleGNsdWRlID09PSBmYWxzZSkge1xuICAgICAgICAvLyBNYWtlIGEgbm90ZSBvZiBtaW51cyBwYXRocyB0aGF0IGFyZSBvdmVyd3JpdGluZyBwYXRocyB0aGF0IGFyZVxuICAgICAgICAvLyBpbmNsdWRlZCBieSBkZWZhdWx0LlxuICAgICAgICBtaW51c1BhdGhzVG9Ta2lwLmFkZChwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBpZiBzZWxlY3RpbmcsIGFwcGx5IGRlZmF1bHQgc2NoZW1hdHlwZSBzZWxlY3Q6dHJ1ZSBmaWVsZHNcbiAgLy8gaWYgZXhjbHVkaW5nLCBhcHBseSBzY2hlbWF0eXBlIHNlbGVjdDpmYWxzZSBmaWVsZHNcbiAgY29uc3Qgc2VsZWN0ZWQgPSBbXTtcbiAgY29uc3QgZXhjbHVkZWQgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICBhbmFseXplU2NoZW1hKHNjaGVtYSk7XG4gIHN3aXRjaCAoZXhjbHVkZSkge1xuICAgIGNhc2UgdHJ1ZTpcbiAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIGV4Y2x1ZGVkKSB7XG4gICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmFsc2U6XG4gICAgICBpZiAoc2NoZW1hICYmXG4gICAgICAgICAgc2NoZW1hLnBhdGhzWydfaWQnXSAmJlxuICAgICAgICAgIHNjaGVtYS5wYXRoc1snX2lkJ10ub3B0aW9ucyAmJlxuICAgICAgICAgIHNjaGVtYS5wYXRoc1snX2lkJ10ub3B0aW9ucy5zZWxlY3QgPT09IGZhbHNlKSB7XG4gICAgICAgIGZpZWxkcy5faWQgPSAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBzZWxlY3RlZCkge1xuICAgICAgICBpZiAobWludXNQYXRoc1RvU2tpcC5oYXMoZmllbGROYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZShmaWVsZHMsIGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHNbZmllbGROYW1lXSA9IGZpZWxkc1tmaWVsZE5hbWVdIHx8IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIGlmIChmaWVsZHMgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEFueSBsZWZ0b3ZlciBwbHVzIHBhdGhzIG11c3QgaW4gdGhlIHNjaGVtYSwgc28gZGVsZXRlIHRoZW0gKGdoLTcwMTcpXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWVsZHMgfHwge30pKSB7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnKycpKSB7XG4gICAgICAgICAgZGVsZXRlIGZpZWxkc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHVzZXIgZGlkbid0IHNwZWNpZnkgZmllbGRzLCBpbXBsaWVzIHJldHVybmluZyBhbGwgZmllbGRzLlxuICAgICAgLy8gb25seSBuZWVkIHRvIGFwcGx5IGV4Y2x1ZGVkIGZpZWxkcyBhbmQgZGVsZXRlIGFueSBwbHVzIHBhdGhzXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBleGNsdWRlZCkge1xuICAgICAgICBpZiAoZmllbGRzW2ZpZWxkTmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIC8vIFNraXAgYXBwbHlpbmcgZGVmYXVsdCBwcm9qZWN0aW9ucyB0byBmaWVsZHMgd2l0aCBub24tZGVmaW5pbmdcbiAgICAgICAgICAvLyBwcm9qZWN0aW9ucywgbGlrZSBgJHNsaWNlYFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgZnVuY3Rpb24gYW5hbHl6ZVNjaGVtYShzY2hlbWEsIHByZWZpeCkge1xuICAgIHByZWZpeCB8fCAocHJlZml4ID0gJycpO1xuXG4gICAgLy8gYXZvaWQgcmVjdXJzaW9uXG4gICAgaWYgKHN0YWNrLmluZGV4T2Yoc2NoZW1hKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgc3RhY2sucHVzaChzY2hlbWEpO1xuXG4gICAgY29uc3QgYWRkZWRQYXRocyA9IFtdO1xuICAgIHNjaGVtYS5lYWNoUGF0aChmdW5jdGlvbihwYXRoLCB0eXBlKSB7XG4gICAgICBpZiAocHJlZml4KSBwYXRoID0gcHJlZml4ICsgJy4nICsgcGF0aDtcbiAgICAgIGlmICh0eXBlLiRpc1NjaGVtYU1hcCB8fCBwYXRoLmVuZHNXaXRoKCcuJConKSkge1xuICAgICAgICBjb25zdCBwbHVzUGF0aCA9ICcrJyArIHBhdGg7XG4gICAgICAgIGNvbnN0IGhhc1BsdXNQYXRoID0gZmllbGRzICYmIHBsdXNQYXRoIGluIGZpZWxkcztcbiAgICAgICAgaWYgKHR5cGUub3B0aW9ucyAmJiB0eXBlLm9wdGlvbnMuc2VsZWN0ID09PSBmYWxzZSAmJiAhaGFzUGx1c1BhdGgpIHtcbiAgICAgICAgICBleGNsdWRlZC5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBhZGRlZFBhdGggPSBhbmFseXplUGF0aChwYXRoLCB0eXBlKTtcbiAgICAgIC8vIGFycmF5c1xuICAgICAgaWYgKGFkZGVkUGF0aCA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHR5cGUpICYmIHR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJiAhdHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgYWRkZWRQYXRoID0gYW5hbHl6ZVBhdGgocGF0aCwgdHlwZS5jYXN0ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGFkZGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICAgIGFkZGVkUGF0aHMucHVzaChhZGRlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICAvLyBuZXN0ZWQgc2NoZW1hc1xuICAgICAgaWYgKHR5cGUuc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IF9hZGRlZFBhdGhzID0gYW5hbHl6ZVNjaGVtYSh0eXBlLnNjaGVtYSwgcGF0aCk7XG5cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBpZiBkaXNjcmltaW5hdG9yIGtleSBpcyB0aGUgb25seSBmaWVsZCB0aGF0IHdvdWxkXG4gICAgICAgIC8vIGJlIHByb2plY3RlZCBpbiwgcmVtb3ZlIGl0LlxuICAgICAgICBpZiAoZXhjbHVkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjaGVja0VtYmVkZGVkRGlzY3JpbWluYXRvcktleVByb2plY3Rpb24oZmllbGRzLCBwYXRoLCB0eXBlLnNjaGVtYSxcbiAgICAgICAgICAgIHNlbGVjdGVkLCBfYWRkZWRQYXRocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXR1cm4gYWRkZWRQYXRocztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuYWx5emVQYXRoKHBhdGgsIHR5cGUpIHtcbiAgICBpZiAoZmllbGRzID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzY2hlbWEtbGV2ZWwgc2VsZWN0ZWQgbm90IHNldCwgbm90aGluZyB0byBkb1xuICAgIGlmICh0eXBlb2YgdHlwZS5zZWxlY3RlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVXNlciBvdmVyd3JpdGluZyBkZWZhdWx0IGV4Y2x1c2lvblxuICAgIGlmICh0eXBlLnNlbGVjdGVkID09PSBmYWxzZSAmJiBmaWVsZHNbcGF0aF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzZXQgdG8gMCwgd2UncmUgZXhwbGljaXRseSBleGNsdWRpbmcgdGhlIGRpc2NyaW1pbmF0b3Iga2V5LiBDYW4ndCBkbyB0aGlzIGZvciBhbGwgZmllbGRzLFxuICAgIC8vIGJlY2F1c2Ugd2UgaGF2ZSB0ZXN0cyB0aGF0IGFzc2VydCB0aGF0IHVzaW5nIGAtcGF0aGAgdG8gZXhjbHVkZSBzY2hlbWEtbGV2ZWwgYHNlbGVjdDogdHJ1ZWBcbiAgICAvLyBmaWVsZHMgY291bnRzIGFzIGFuIGV4Y2x1c2l2ZSBwcm9qZWN0aW9uLiBTZWUgZ2gtMTE1NDZcbiAgICBpZiAoIWV4Y2x1ZGUgJiYgdHlwZS5zZWxlY3RlZCAmJiBwYXRoID09PSBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5ICYmIGZpZWxkc1twYXRoXSAhPSBudWxsICYmICFmaWVsZHNbcGF0aF0pIHtcbiAgICAgIGRlbGV0ZSBmaWVsZHNbcGF0aF07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV4Y2x1ZGUgPT09IGZhbHNlICYmIHR5cGUuc2VsZWN0ZWQgJiYgZmllbGRzW3BhdGhdICE9IG51bGwgJiYgIWZpZWxkc1twYXRoXSkge1xuICAgICAgZGVsZXRlIGZpZWxkc1twYXRoXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwbHVzUGF0aCA9ICcrJyArIHBhdGg7XG4gICAgY29uc3QgaGFzUGx1c1BhdGggPSBmaWVsZHMgJiYgcGx1c1BhdGggaW4gZmllbGRzO1xuICAgIGlmIChoYXNQbHVzUGF0aCkge1xuICAgICAgLy8gZm9yY2VkIGluY2x1c2lvblxuICAgICAgZGVsZXRlIGZpZWxkc1twbHVzUGF0aF07XG5cbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBvdGhlciBmaWVsZHMgYmVpbmcgaW5jbHVkZWQsIGFkZCB0aGlzIG9uZVxuICAgICAgLy8gaWYgbm8gb3RoZXIgaW5jbHVkZWQgZmllbGRzLCBsZWF2ZSB0aGlzIG91dCAoaW1wbGllZCBpbmNsdXNpb24pXG4gICAgICBpZiAoZXhjbHVkZSA9PT0gZmFsc2UgJiYga2V5cy5sZW5ndGggPiAxICYmICF+a2V5cy5pbmRleE9mKHBhdGgpKSB7XG4gICAgICAgIGZpZWxkc1twYXRoXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgcGFyZW50IGV4Y2x1c2lvbnNcbiAgICBjb25zdCBwaWVjZXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgbGV0IGN1ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjdXIgKz0gY3VyLmxlbmd0aCA/ICcuJyArIHBpZWNlc1tpXSA6IHBpZWNlc1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGN1cikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2U6IGlmIHVzZXIgaGFzIGluY2x1ZGVkIGEgcGFyZW50IHBhdGggb2YgYSBkaXNjcmltaW5hdG9yIGtleSxcbiAgICAvLyBkb24ndCBleHBsaWNpdGx5IHByb2plY3QgaW4gdGhlIGRpc2NyaW1pbmF0b3Iga2V5IGJlY2F1c2UgdGhhdCB3aWxsXG4gICAgLy8gcHJvamVjdCBvdXQgZXZlcnl0aGluZyBlbHNlIHVuZGVyIHRoZSBwYXJlbnQgcGF0aFxuICAgIGlmICghZXhjbHVkZSAmJiAodHlwZSAmJiB0eXBlLm9wdGlvbnMgJiYgdHlwZS5vcHRpb25zLiRza2lwRGlzY3JpbWluYXRvckNoZWNrIHx8IGZhbHNlKSkge1xuICAgICAgbGV0IGN1ciA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3VyICs9IChjdXIubGVuZ3RoID09PSAwID8gJycgOiAnLicpICsgcGllY2VzW2ldO1xuICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gZ2V0KGZpZWxkcywgY3VyLCBmYWxzZSkgfHwgZ2V0KGZpZWxkcywgY3VyICsgJy4kJywgZmFsc2UpO1xuICAgICAgICBpZiAocHJvamVjdGlvbiAmJiB0eXBlb2YgcHJvamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAodHlwZS5zZWxlY3RlZCA/IHNlbGVjdGVkIDogZXhjbHVkZWQpLnB1c2gocGF0aCk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGVhY2ggcGF0aCBxdWVyeSBvcHRpb24gdG8gbGVhblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAqL1xuXG5mdW5jdGlvbiBtYWtlTGVhbih2YWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgIG9wdGlvbi5vcHRpb25zIHx8IChvcHRpb24ub3B0aW9ucyA9IHt9KTtcblxuICAgIGlmICh2YWwgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbC52aXJ0dWFscykpIHtcbiAgICAgIHZhbCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbCk7XG4gICAgICB2YWwudmlydHVhbHMgPSB2YWwudmlydHVhbHMuXG4gICAgICAgIGZpbHRlcihwYXRoID0+IHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoLnN0YXJ0c1dpdGgob3B0aW9uLnBhdGggKyAnLicpKS5cbiAgICAgICAgbWFwKHBhdGggPT4gcGF0aC5zbGljZShvcHRpb24ucGF0aC5sZW5ndGggKyAxKSk7XG4gICAgfVxuXG4gICAgb3B0aW9uLm9wdGlvbnMubGVhbiA9IHZhbDtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/queryhelpers.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema.js":
/*!*****************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Kareem = __webpack_require__(/*! kareem */ \"(api)/../server/node_modules/kareem/index.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst SchemaType = __webpack_require__(/*! ./schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst SchemaTypeOptions = __webpack_require__(/*! ./options/SchemaTypeOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\");\nconst VirtualOptions = __webpack_require__(/*! ./options/VirtualOptions */ \"(api)/../server/node_modules/mongoose/lib/options/VirtualOptions.js\");\nconst VirtualType = __webpack_require__(/*! ./virtualtype */ \"(api)/../server/node_modules/mongoose/lib/virtualtype.js\");\nconst addAutoId = __webpack_require__(/*! ./helpers/schema/addAutoId */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/addAutoId.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"(api)/../server/node_modules/mongoose/lib/helpers/get.js\");\nconst getConstructorName = __webpack_require__(/*! ./helpers/getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getIndexes = __webpack_require__(/*! ./helpers/schema/getIndexes */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/getIndexes.js\");\nconst handleReadPreferenceAliases = __webpack_require__(/*! ./helpers/query/handleReadPreferenceAliases */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js\");\nconst idGetter = __webpack_require__(/*! ./helpers/schema/idGetter */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/idGetter.js\");\nconst merge = __webpack_require__(/*! ./helpers/schema/merge */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/merge.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(api)/../server/node_modules/mpath/index.js\");\nconst setupTimestamps = __webpack_require__(/*! ./helpers/timestamps/setupTimestamps */ \"(api)/../server/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst validateRef = __webpack_require__(/*! ./helpers/populate/validateRef */ \"(api)/../server/node_modules/mongoose/lib/helpers/populate/validateRef.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst hasNumericSubpathRegex = /\\.\\d+(\\.|$)/;\n\nlet MongooseTypes;\n\nconst queryHooks = (__webpack_require__(/*! ./helpers/query/applyQueryMiddleware */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js\").middlewareFunctions);\nconst documentHooks = (__webpack_require__(/*! ./helpers/model/applyHooks */ \"(api)/../server/node_modules/mongoose/lib/helpers/model/applyHooks.js\").middlewareFunctions);\nconst hookNames = queryHooks.concat(documentHooks).\n  reduce((s, hook) => s.add(hook), new Set());\n\nconst isPOJO = utils.isPOJO;\n\nlet id = 0;\n\nconst numberRE = /^\\d+$/;\n\n/**\n * Schema constructor.\n *\n * #### Example:\n *\n *     const child = new Schema({ name: String });\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\n *     const Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * #### Options:\n *\n * - [autoIndex](https://mongoosejs.com/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](https://mongoosejs.com/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](https://mongoosejs.com/docs/guide.html#bufferCommands): bool - defaults to true\n * - [bufferTimeoutMS](https://mongoosejs.com/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\n * - [capped](https://mongoosejs.com/docs/guide.html#capped): bool | number | object - defaults to false\n * - [collection](https://mongoosejs.com/docs/guide.html#collection): string - no default\n * - [discriminatorKey](https://mongoosejs.com/docs/guide.html#discriminatorKey): string - defaults to `__t`\n * - [id](https://mongoosejs.com/docs/guide.html#id): bool - defaults to true\n * - [_id](https://mongoosejs.com/docs/guide.html#_id): bool - defaults to true\n * - [minimize](https://mongoosejs.com/docs/guide.html#minimize): bool - controls [document#toObject](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()) behavior when called manually - defaults to true\n * - [read](https://mongoosejs.com/docs/guide.html#read): string\n * - [writeConcern](https://mongoosejs.com/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://www.mongodb.com/docs/manual/reference/write-concern/)\n * - [shardKey](https://mongoosejs.com/docs/guide.html#shardKey): object - defaults to `null`\n * - [strict](https://mongoosejs.com/docs/guide.html#strict): bool - defaults to true\n * - [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery): bool - defaults to false\n * - [toJSON](https://mongoosejs.com/docs/guide.html#toJSON) - object - no default\n * - [toObject](https://mongoosejs.com/docs/guide.html#toObject) - object - no default\n * - [typeKey](https://mongoosejs.com/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [validateBeforeSave](https://mongoosejs.com/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [validateModifiedOnly](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()) - bool - defaults to `false`\n * - [versionKey](https://mongoosejs.com/docs/guide.html#versionKey): string or object - defaults to \"__v\"\n * - [optimisticConcurrency](https://mongoosejs.com/docs/guide.html#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).\n * - [collation](https://mongoosejs.com/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [timeseries](https://mongoosejs.com/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\n * - [selectPopulatedPaths](https://mongoosejs.com/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n * - [skipVersioning](https://mongoosejs.com/docs/guide.html#skipVersioning): object - paths to exclude from versioning\n * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n * - [pluginTags](https://mongoosejs.com/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\n * - [virtuals](https://mongoosejs.com/docs/tutorials/virtuals.html#virtuals-via-schema-options): object - virtuals to define, alias for [`.virtual`](https://mongoosejs.com/docs/api/schema.html#Schema.prototype.virtual())\n * - [collectionOptions]: object with options passed to [`createCollection()`](https://www.mongodb.com/docs/manual/reference/method/db.createCollection/) when calling `Model.createCollection()` or `autoCreate` set to true.\n *\n * #### Options for Nested Schemas:\n *\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n *\n * #### Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = (options && options.methods) || {};\n  this.methodOptions = {};\n  this.statics = (options && options.statics) || {};\n  this.tree = {};\n  this.query = (options && options.query) || {};\n  this.childSchemas = [];\n  this.plugins = [];\n  // For internal debugging. Do not use this to try to save a schema in MDB.\n  this.$id = ++id;\n  this.mapPaths = [];\n\n  this.s = {\n    hooks: new Kareem()\n  };\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  }\n\n  // build virtual paths\n  if (options && options.virtuals) {\n    const virtuals = options.virtuals;\n    const pathNames = Object.keys(virtuals);\n    for (const pathName of pathNames) {\n      const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : undefined;\n      const virtual = this.virtual(pathName, pathOptions);\n\n      if (virtuals[pathName].get) {\n        virtual.get(virtuals[pathName].get);\n      }\n\n      if (virtuals[pathName].set) {\n        virtual.set(virtuals[pathName].set);\n      }\n    }\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  const auto_id = !this.paths['_id'] &&\n      (this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    addAutoId(this);\n  }\n\n  this.setupTimestamp(this.options.timestamps);\n}\n\n/**\n * Create virtual properties with alias field\n * @api private\n */\nfunction aliasFields(schema, paths) {\n  for (const path of Object.keys(paths)) {\n    let alias = null;\n    if (paths[path] != null) {\n      alias = paths[path];\n    } else {\n      const options = get(schema.paths[path], 'options');\n      if (options == null) {\n        continue;\n      }\n\n      alias = options.alias;\n    }\n\n    if (!alias) {\n      continue;\n    }\n\n    const prop = schema.paths[path].path;\n    if (Array.isArray(alias)) {\n      for (const a of alias) {\n        if (typeof a !== 'string') {\n          throw new Error('Invalid value for alias option on ' + prop + ', got ' + a);\n        }\n\n        schema.aliases[a] = prop;\n\n        schema.\n          virtual(a).\n          get((function(p) {\n            return function() {\n              if (typeof this.get === 'function') {\n                return this.get(p);\n              }\n              return this[p];\n            };\n          })(prop)).\n          set((function(p) {\n            return function(v) {\n              return this.$set(p, v);\n            };\n          })(prop));\n      }\n\n      continue;\n    }\n\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n\n    schema.aliases[alias] = prop;\n\n    schema.\n      virtual(alias).\n      get((function(p) {\n        return function() {\n          if (typeof this.get === 'function') {\n            return this.get(p);\n          }\n          return this[p];\n        };\n      })(prop)).\n      set((function(p) {\n        return function(v) {\n          return this.$set(p, v);\n        };\n      })(prop));\n  }\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * Object containing all virtuals defined on this schema.\n * The objects' keys are the virtual paths and values are instances of `VirtualType`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * #### Example:\n *\n *     const schema = new Schema({});\n *     schema.virtual('answer').get(() => 42);\n *\n *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\n *     console.log(schema.virtuals['answer'].getters[0].call()); // 42\n *\n * @api public\n * @property virtuals\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'virtuals', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The original object passed to the schema constructor\n *\n * #### Example:\n *\n *     const schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n\n/**\n * The paths defined on this schema. The keys are the top-level paths\n * in this schema, and the values are instances of the SchemaType class.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { _id: false });\n *     schema.paths; // { name: SchemaString { ... } }\n *\n *     schema.add({ age: Number });\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n *\n * @api public\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * #### Example:\n *\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n\n/**\n * Returns a deep copy of the schema\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     const clone = schema.clone();\n *     clone === schema; // false\n *     clone.path('name'); // SchemaString { ... }\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function() {\n  const s = this._clone();\n\n  // Bubble up `init` for backwards compat\n  s.on('init', v => this.emit('init', v));\n\n  return s;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._clone = function _clone(Constructor) {\n  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);\n\n  const s = new Constructor({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = clone(this.options);\n  s.callQueue = this.callQueue.map(function(f) { return f; });\n  s.methods = clone(this.methods);\n  s.methodOptions = clone(this.methodOptions);\n  s.statics = clone(this.statics);\n  s.query = clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = clone(this._indexes);\n  s.s.hooks = this.s.hooks.clone();\n\n  s.tree = clone(this.tree);\n  s.paths = Object.fromEntries(\n    Object.entries(this.paths).map(([key, value]) => ([key, value.clone()]))\n  );\n  s.nested = clone(this.nested);\n  s.subpaths = clone(this.subpaths);\n  for (const schemaType of Object.values(s.paths)) {\n    if (schemaType.$isSingleNested) {\n      const path = schemaType.path;\n      for (const key of Object.keys(schemaType.schema.paths)) {\n        s.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n        s.singleNestedPaths[path + '.' + key] =\n          schemaType.schema.singleNestedPaths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.subpaths)) {\n        s.singleNestedPaths[path + '.' + key] =\n          schemaType.schema.subpaths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.nested)) {\n        s.singleNestedPaths[path + '.' + key] = 'nested';\n      }\n    }\n  }\n  s.childSchemas = gatherChildSchemas(s);\n\n  s.virtuals = clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n  s.$id = ++id;\n  s.$originalSchemaId = this.$id;\n  s.mapPaths = [].concat(this.mapPaths);\n\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n  if (this._applyDiscriminators != null) {\n    s._applyDiscriminators = new Map(this._applyDiscriminators);\n  }\n\n  s.aliases = Object.assign({}, this.aliases);\n\n  return s;\n};\n\n/**\n * Returns a new schema that has the picked `paths` from this schema.\n *\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema with the same `name` path as `schema`,\n *     // but no `age` path.\n *     const newSchema = schema.pick(['name']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to pick for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.pick = function(paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' +\n      'got \"' + typeof paths + '\"');\n  }\n\n  for (const path of paths) {\n    if (this.nested[path]) {\n      newSchema.add({ [path]: get(this.tree, path) });\n    } else {\n      const schematype = this.path(path);\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n      newSchema.add({ [path]: schematype });\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns a new schema that has the `paths` from the original schema, minus the omitted ones.\n *\n * This method is analagous to [Lodash's `omit()` function](https://lodash.com/docs/#omit) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema omitting the `age` path\n *     const newSchema = schema.omit(['age']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to omit for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.omit = function(paths, options) {\n  const newSchema = new Schema(this, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError(\n      'Schema#omit() only accepts an array argument, ' +\n        'got \"' +\n        typeof paths +\n        '\"'\n    );\n  }\n\n  newSchema.remove(paths);\n\n  for (const nested in newSchema.singleNestedPaths) {\n    if (paths.includes(nested)) {\n      delete newSchema.singleNestedPaths[nested];\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} [options] Options to overwrite the default options\n * @return {Object} The merged options of `options` and the default options\n * @api private\n */\n\nSchema.prototype.defaultOptions = function(options) {\n  this._userProvidedOptions = options == null ? {} : clone(options);\n  const baseOptions = this.base && this.base.options || {};\n  const strict = 'strict' in baseOptions ? baseOptions.strict : true;\n  const strictQuery = 'strictQuery' in baseOptions ? baseOptions.strictQuery : false;\n  const id = 'id' in baseOptions ? baseOptions.id : true;\n  options = {\n    strict,\n    strictQuery,\n    bufferCommands: true,\n    capped: false, // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    minimize: true,\n    autoIndex: null,\n    discriminatorKey: '__t',\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    validateModifiedOnly: false,\n    // the following are only applied at construction time\n    _id: true,\n    id: id,\n    typeKey: 'type',\n    ...options\n  };\n\n  if (options.versionKey && typeof options.versionKey !== 'string') {\n    throw new MongooseError('`versionKey` must be falsy or string, got `' + (typeof options.versionKey) + '`');\n  }\n\n  if (typeof options.read === 'string') {\n    options.read = handleReadPreferenceAliases(options.read);\n  } else if (Array.isArray(options.read) && typeof options.read[0] === 'string') {\n    options.read = {\n      mode: handleReadPreferenceAliases(options.read[0]),\n      tags: options.read[1]\n    };\n  }\n\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n\n  return options;\n};\n\n/**\n * Inherit a Schema by applying a discriminator on an existing Schema.\n *\n *\n * #### Example:\n *\n *     const eventSchema = new mongoose.Schema({ timestamp: Date }, { discriminatorKey: 'kind' });\n *\n *     const clickedEventSchema = new mongoose.Schema({ element: String }, { discriminatorKey: 'kind' });\n *     const ClickedModel = eventSchema.discriminator('clicked', clickedEventSchema);\n *\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.discriminators['clicked']; // Model { clicked }\n *\n *     const doc = await Event.create({ kind: 'clicked', element: '#hero' });\n *     doc.element; // '#hero'\n *     doc instanceof ClickedModel; // true\n *\n * @param {String} name the name of the discriminator\n * @param {Schema} schema the discriminated Schema\n * @param {Object} [options] discriminator options\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.discriminator = function(name, schema, options) {\n  this._applyDiscriminators = this._applyDiscriminators || new Map();\n  this._applyDiscriminators.set(name, { schema, options });\n\n  return this;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema || (obj != null && obj.instanceOfSchema)) {\n    merge(this, obj);\n\n    return this;\n  }\n\n  // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n\n  prefix = prefix || '';\n  // avoid prototype pollution\n  if (prefix === '__proto__.' || prefix === 'constructor.' || prefix === 'prototype.') {\n    return this;\n  }\n\n  const keys = Object.keys(obj);\n  const typeKey = this.options.typeKey;\n  for (const key of keys) {\n    if (utils.specialProperties.has(key)) {\n      continue;\n    }\n\n    const fullPath = prefix + key;\n    const val = obj[key];\n\n    if (val == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath +\n        '`, got value \"' + val + '\"');\n    }\n    // Retain `_id: false` but don't set it as a path, re: gh-8274.\n    if (key === '_id' && val === false) {\n      continue;\n    }\n    // Deprecate setting schema paths to primitive types (gh-7558)\n    let isMongooseTypeString = false;\n    if (typeof val === 'string') {\n      // Handle the case in which the type is specified as a string (eg. 'date', 'oid', ...)\n      const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n      const upperVal = val.charAt(0).toUpperCase() + val.substring(1);\n      isMongooseTypeString = MongooseTypes[upperVal] != null;\n    }\n    if (\n      key !== '_id' &&\n      ((typeof val !== 'object' && typeof val !== 'function' && !isMongooseTypeString) ||\n      val == null)\n    ) {\n      throw new TypeError(`Invalid schema configuration: \\`${val}\\` is not ` +\n        `a valid type at path \\`${key}\\`. See ` +\n        'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n    }\n    if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === 'VirtualType') {\n      this.virtual(val);\n      continue;\n    }\n\n    if (Array.isArray(val) && val.length === 1 && val[0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath +\n        '`, got value \"' + val[0] + '\"');\n    }\n\n    if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, val);\n      if (val[0] != null && !(val[0].instanceOfSchema) && utils.isPOJO(val[0].discriminators)) {\n        const schemaType = this.path(prefix + key);\n        for (const key in val[0].discriminators) {\n          schemaType.discriminator(key, val[0].discriminators[key]);\n        }\n      }\n    } else if (Object.keys(val).length < 1) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(fullPath, val); // mixed type\n    } else if (!val[typeKey] || (typeKey === 'type' && isPOJO(val.type) && val.type.type)) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because\n      // NestJS sometimes adds `Date.type`.\n      this.nested[fullPath] = true;\n      this.add(val, fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      const _typeDef = val[typeKey];\n      if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n\n        const childSchemaOptions = {};\n        if (this._userProvidedOptions.typeKey) {\n          childSchemaOptions.typeKey = this._userProvidedOptions.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (this._userProvidedOptions.strict != null) {\n          childSchemaOptions.strict = this._userProvidedOptions.strict;\n        }\n        if (this._userProvidedOptions.toObject != null) {\n          childSchemaOptions.toObject = utils.omit(this._userProvidedOptions.toObject, ['transform']);\n        }\n        if (this._userProvidedOptions.toJSON != null) {\n          childSchemaOptions.toJSON = utils.omit(this._userProvidedOptions.toJSON, ['transform']);\n        }\n\n        const _schema = new Schema(_typeDef, childSchemaOptions);\n        _schema.$implicitlyCreated = true;\n        const schemaWrappedPath = Object.assign({}, val, { [typeKey]: _schema });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, val);\n        if (val != null && !(val.instanceOfSchema) && utils.isPOJO(val.discriminators)) {\n          const schemaType = this.path(prefix + key);\n          for (const key in val.discriminators) {\n            schemaType.discriminator(key, val.discriminators[key]);\n          }\n        }\n      }\n    }\n  }\n\n  const aliasObj = Object.fromEntries(\n    Object.entries(obj).map(([key]) => ([prefix + key, null]))\n  );\n  aliasFields(this, aliasObj);\n  return this;\n};\n\n/**\n * Add an alias for `path`. This means getting or setting the `alias`\n * is equivalent to getting or setting the `path`.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ n: String });\n *\n *     // Make 'name' an alias for 'n'\n *     toySchema.alias('n', 'name');\n *\n *     const Toy = mongoose.model('Toy', toySchema);\n *     const turboMan = new Toy({ n: 'Turbo Man' });\n *\n *     turboMan.name; // 'Turbo Man'\n *     turboMan.n; // 'Turbo Man'\n *\n *     turboMan.name = 'Turbo Man Action Figure';\n *     turboMan.n; // 'Turbo Man Action Figure'\n *\n *     await turboMan.save(); // Saves { _id: ..., n: 'Turbo Man Action Figure' }\n *\n *\n * @param {String} path real path to alias\n * @param {String|String[]} alias the path(s) to use as an alias for `path`\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.alias = function alias(path, alias) {\n  aliasFields(this, { [path]: alias });\n  return this;\n};\n\n/**\n * Remove an index by name or index specification.\n *\n * removeIndex only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *\n *     // Add a new index on { name, color }\n *     ToySchema.index({ name: 1, color: 1 });\n *\n *     // Remove index on { name, color }\n *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\n *     ToySchema.removeIndex({ name: 1, color: 1 });\n *\n *     // Add an index with a custom name\n *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });\n *     // Remove index by name\n *     ToySchema.removeIndex('my custom index name');\n *\n * @param {Object|string} index name or index specification\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.removeIndex = function removeIndex(index) {\n  if (arguments.length > 1) {\n    throw new Error('removeIndex() takes only 1 argument');\n  }\n\n  if (typeof index !== 'object' && typeof index !== 'string') {\n    throw new Error('removeIndex() may only take either an object or a string as an argument');\n  }\n\n  if (typeof index === 'object') {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (util.isDeepStrictEqual(this._indexes[i][0], index)) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  } else {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  }\n\n  return this;\n};\n\n/**\n * Remove all indexes from this schema.\n *\n * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.index({ name: 1 });\n *     ToySchema.index({ color: 1 });\n *\n *     // Remove all indexes on this schema\n *     ToySchema.clearIndexes();\n *\n *     ToySchema.indexes(); // []\n *\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.clearIndexes = function clearIndexes() {\n  this._indexes.length = 0;\n\n  return this;\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are warned in schema declarations\n * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema\n * using `new Schema()` with one of these property names, Mongoose will log a warning.\n *\n * - _posts\n * - _pres\n * - collection\n  * - emit\n * - errors\n * - get\n * - init\n * - isModified\n * - isNew\n * - listeners\n * - modelName\n * - on\n * - once\n * - populated\n * - prototype\n * - remove\n * - removeListener\n * - save\n * - schema\n * - toObject\n * - validate\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      const schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n *\n * @property reserved\n * @memberOf Schema\n * @static\n */\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\n\nconst reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit =\nreserved.listeners =\nreserved.removeListener =\n\n// document properties and functions\nreserved.collection =\nreserved.errors =\nreserved.get =\nreserved.init =\nreserved.isModified =\nreserved.isNew =\nreserved.populated =\nreserved.remove =\nreserved.save =\nreserved.toObject =\nreserved.validate = 1;\nreserved.collection = 1;\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * #### Example:\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path The name of the Path to get / set\n * @param {Object} [obj] The Type to set the path to, if provided the path will be SET, otherwise the path will be GET\n * @api public\n */\n\nSchema.prototype.path = function(path, obj) {\n  if (obj === undefined) {\n    if (this.paths[path] != null) {\n      return this.paths[path];\n    }\n    // Convert to '.$' to check subpaths re: gh-6405\n    const cleanPath = _pathToPositionalSyntax(path);\n    let schematype = _getPath(this, path, cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // Look for maps\n    const mapPath = getMapPath(this, path);\n    if (mapPath != null) {\n      return mapPath;\n    }\n\n    // Look if a parent of this path is mixed\n    schematype = this.hasMixedParent(cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // subpaths?\n    return hasNumericSubpathRegex.test(path)\n      ? getPositionalPath(this, path, cleanPath)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  const firstPieceOfPath = path.split('.')[0];\n  if (reserved[firstPieceOfPath] && !this.options.suppressReservedKeysWarning) {\n    const errorMessage = `\\`${firstPieceOfPath}\\` is a reserved schema pathname and may break some functionality. ` +\n      'You are allowed to use it, but use at your own risk. ' +\n      'To disable this warning pass `suppressReservedKeysWarning` as a schema option.';\n\n    utils.warn(errorMessage);\n  }\n\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  }\n\n  // update the tree\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n\n  for (const sub of subpaths) {\n    if (utils.specialProperties.has(sub)) {\n      throw new Error('Cannot set special property `' + sub + '` on a schema');\n    }\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. '\n          + 'Parent path `'\n          + fullPath\n          + '` already set to type ' + branch[sub].name\n          + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  }\n\n  branch[last] = clone(obj);\n\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n\n    this.paths[mapPath] = schemaType.$__schemaType;\n    this.mapPaths.push(this.paths[mapPath]);\n  }\n\n  if (schemaType.$isSingleNested) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.singleNestedPaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.subpaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.nested)) {\n      this.singleNestedPaths[path + '.' + key] = 'nested';\n    }\n\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.caster.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.caster\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.casterConstructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.casterConstructor\n    });\n  }\n\n  if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n\n    const toAdd = [];\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$';\n\n      // Skip arrays of document arrays\n      if (_schemaType.$isMongooseDocumentArray) {\n        _schemaType.$embeddedSchemaType._arrayPath = arrayPath;\n        _schemaType.$embeddedSchemaType._arrayParentPath = path;\n        _schemaType = _schemaType.$embeddedSchemaType;\n      } else {\n        _schemaType.caster._arrayPath = arrayPath;\n        _schemaType.caster._arrayParentPath = path;\n        _schemaType = _schemaType.caster;\n      }\n\n      this.subpaths[arrayPath] = _schemaType;\n    }\n\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      const _schemaType = schemaType.schema.paths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      const _schemaType = schemaType.schema.subpaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      const _schemaType = schemaType.schema.singleNestedPaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction gatherChildSchemas(schema) {\n  const childSchemas = [];\n\n  for (const path of Object.keys(schema.paths)) {\n    const schematype = schema.paths[path];\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({ schema: schematype.schema, model: schematype.caster });\n    }\n  }\n\n  return childSchemas;\n}\n\n/*!\n * ignore\n */\n\nfunction _getPath(schema, path, cleanPath) {\n  if (schema.paths.hasOwnProperty(path)) {\n    return schema.paths[path];\n  }\n  if (schema.subpaths.hasOwnProperty(cleanPath)) {\n    return schema.subpaths[cleanPath];\n  }\n  if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === 'object') {\n    return schema.singleNestedPaths[cleanPath];\n  }\n\n  return null;\n}\n\n/*!\n * ignore\n */\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n\n/*!\n * ignore\n */\n\nfunction getMapPath(schema, path) {\n  if (schema.mapPaths.length === 0) {\n    return null;\n  }\n  for (const val of schema.mapPaths) {\n    const _path = val.path;\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '\\\\.[^.]+') + '$');\n    if (re.test(path)) {\n      return schema.paths[_path];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The Mongoose instance this schema is associated with\n *\n * @property base\n * @api private\n */\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @param {Object} options\n * @api private\n */\n\nSchema.prototype.interpretAsType = function(path, obj, options) {\n  if (obj instanceof SchemaType) {\n    if (obj.path === path) {\n      return obj;\n    }\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  }\n\n  // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n  const Types = this.base != null ? this.base.Types : __webpack_require__(/*! ./types */ \"(api)/../server/node_modules/mongoose/lib/types/index.js\");\n\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== 'type' || !obj.type.type)\n    ? obj[options.typeKey]\n    : {};\n  let name;\n\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = (type === Array || type === 'array')\n      ? obj.cast || obj.of\n      : type[0];\n\n    // new Schema({ path: [new Schema({ ... })] })\n    if (cast && cast.instanceOfSchema) {\n      if (!(cast instanceof Schema)) {\n        if (this.options._isMerging) {\n          cast = new Schema(cast);\n        } else {\n          throw new TypeError('Schema for array path `' + path +\n            '` is from a different copy of the Mongoose module. ' +\n            'Please make sure you\\'re using the same version ' +\n            'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n            'getting this error, please add `new Schema()` around the path: ' +\n            `${path}: new Schema(...)`);\n        }\n      }\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n    if (cast &&\n        cast[options.typeKey] &&\n        cast[options.typeKey].instanceOfSchema) {\n      if (!(cast[options.typeKey] instanceof Schema)) {\n        if (this.options._isMerging) {\n          cast[options.typeKey] = new Schema(cast[options.typeKey]);\n        } else {\n          throw new TypeError('Schema for array path `' + path +\n            '` is from a different copy of the Mongoose module. ' +\n            'Please make sure you\\'re using the same version ' +\n            'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n            'getting this error, please add `new Schema()` around the path: ' +\n            `${path}: new Schema(...)`);\n        }\n      }\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\n    }\n\n    // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`\n    const castFromTypeKey = (cast != null && cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)) ?\n      cast[options.typeKey] :\n      cast;\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (utils.isPOJO(castFromTypeKey)) {\n      if (Object.keys(castFromTypeKey).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = { minimize: options.minimize };\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n        if (options.hasOwnProperty('strictQuery')) {\n          childSchemaOptions.strictQuery = options.strictQuery;\n        }\n        if (options.hasOwnProperty('toObject')) {\n          childSchemaOptions.toObject = utils.omit(options.toObject, ['transform']);\n        }\n        if (options.hasOwnProperty('toJSON')) {\n          childSchemaOptions.toJSON = utils.omit(options.toJSON, ['transform']);\n        }\n\n        if (this._userProvidedOptions.hasOwnProperty('_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n\n        const childSchema = new Schema(castFromTypeKey, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\n        ? cast[options.typeKey]\n        : cast;\n\n      if (Array.isArray(type)) {\n        return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj);\n      }\n\n      name = typeof type === 'string'\n        ? type\n        : type.schemaName || utils.getFunctionName(type);\n\n      // For Jest 26+, see #10296\n      if (name === 'ClockDate') {\n        name = 'Date';\n      }\n\n      if (name === void 0) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `Could not determine the embedded type for array \\`${path}\\`. ` +\n          'See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n      }\n      if (!MongooseTypes.hasOwnProperty(name)) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` +\n          'See https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n    return new MongooseTypes.Subdocument(type, path, obj);\n  }\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else if (type === Types.ObjectId) {\n    name = 'ObjectId';\n  } else if (type === Types.Decimal128) {\n    name = 'Decimal128';\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n  // For Jest 26+, see #10296\n  if (name === 'ClockDate') {\n    name = 'Date';\n  }\n\n  if (name === void 0) {\n    throw new TypeError(`Invalid schema configuration: \\`${path}\\` schematype definition is ` +\n      'invalid. See ' +\n      'https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n  }\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` +\n      `a valid type at path \\`${path}\\`. See ` +\n      'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n\n  const schemaType = new MongooseTypes[name](path, obj);\n\n  if (schemaType.$isSchemaMap) {\n    createMapNestedSchemaType(this, schemaType, path, obj, options);\n  }\n\n  return schemaType;\n};\n\n/*!\n * ignore\n */\n\nfunction createMapNestedSchemaType(schema, schemaType, path, obj, options) {\n  const mapPath = path + '.$*';\n  let _mapType = { type: {} };\n  if (utils.hasUserDefinedProperty(obj, 'of')) {\n    const isInlineSchema = utils.isPOJO(obj.of) &&\n      Object.keys(obj.of).length > 0 &&\n      !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);\n    if (isInlineSchema) {\n      _mapType = { [schema.options.typeKey]: new Schema(obj.of) };\n    } else if (utils.isPOJO(obj.of)) {\n      _mapType = Object.assign({}, obj.of);\n    } else {\n      _mapType = { [schema.options.typeKey]: obj.of };\n    }\n\n    if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {\n      const subdocumentSchema = _mapType[schema.options.typeKey];\n      subdocumentSchema.eachPath((subpath, type) => {\n        if (type.options.select === true || type.options.select === false) {\n          throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path \"' + path + '.' + subpath + '\"');\n        }\n      });\n    }\n\n    if (utils.hasUserDefinedProperty(obj, 'ref')) {\n      _mapType.ref = obj.ref;\n    }\n  }\n  schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);\n}\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and the schemaType instance.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\n *     userSchema.eachPath((pathname, schematype) => {\n *       // Prints twice:\n *       // name SchemaString { ... }\n *       // registeredAt SchemaDate { ... }\n *       console.log(pathname, schematype);\n *     });\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function(fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({\n *       name: { type: String, required: true },\n *       age: { type: String, required: true },\n *       notes: String\n *     });\n *     s.requiredPaths(); // [ 'age', 'name' ]\n *\n * @api public\n * @param {Boolean} invalidate Refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n\n  while (i--) {\n    const path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String, nested: { foo: String } });\n *     s.virtual('foo').get(() => 42);\n *     s.pathType('name'); // \"real\"\n *     s.pathType('nested'); // \"nested\"\n *     s.pathType('foo'); // \"virtual\"\n *     s.pathType('fail'); // \"adhocOrUndefined\"\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function(path) {\n  if (this.paths.hasOwnProperty(path)) {\n    return 'real';\n  }\n  if (this.virtuals.hasOwnProperty(path)) {\n    return 'virtual';\n  }\n  if (this.nested.hasOwnProperty(path)) {\n    return 'nested';\n  }\n\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {\n    return 'real';\n  }\n\n  const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);\n  if (singleNestedPath) {\n    return singleNestedPath === 'nested' ? 'nested' : 'real';\n  }\n\n  // Look for maps\n  const mapPath = getMapPath(this, path);\n  if (mapPath != null) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path, cleanPath);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function(path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (this.paths.hasOwnProperty(path) &&\n        this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n\n  return null;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function(timestamps) {\n  return setupTimestamps(this, timestamps);\n};\n\n/**\n * ignore. Deprecated re: #6405\n * @param {Any} self\n * @param {String} path\n * @api private\n */\n\nfunction getPositionalPathType(self, path, cleanPath) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths.hasOwnProperty(subpaths[0]) ?\n      self.paths[subpaths[0]] :\n      'adhocOrUndefined';\n  }\n\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n\n  const last = subpaths.length - 1;\n\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.$embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.caster;\n      }\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    const type = val.schema.pathType(subpath);\n    isNested = (type === 'nested');\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[cleanPath] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path, cleanPath) {\n  getPositionalPathType(self, path, cleanPath);\n  return self.subpaths[cleanPath];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * #### Example:\n *\n *     schema.methods.print = function() { console.log(this); };\n *     schema.queue('print', []); // Print the doc every one is instantiated\n *\n *     const Model = mongoose.model('Test', schema);\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function(name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the model.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function(next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     });\n *\n *     toySchema.pre('validate', function(next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     toySchema.pre('deleteOne', function() {\n *       // Runs when you call `Toy.deleteOne()`\n *     });\n *\n *     toySchema.pre('deleteOne', { document: true }, function() {\n *       // Runs when you call `doc.deleteOne()`\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @api public\n */\n\nSchema.prototype.pre = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Defines a post hook for the document\n *\n *     const schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');\n *     });\n *\n *     const Model = mongoose.model('Model', schema);\n *\n *     const m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware https://mongoosejs.com/docs/middleware.html\n * @see kareem https://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin(schema => console.log(schema.path('name').path));\n *     mongoose.model('Test', s); // Prints 'name'\n *\n * Or with Options:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: \"Schema Path Name:\" });\n *     mongoose.model('Test', s); // Prints 'Schema Path Name: name'\n *\n * @param {Function} plugin The Plugin's callback\n * @param {Object} [opts] Options to pass to the plugin\n * @param {Boolean} [opts.deduplicate=false] If true, ignore duplicate plugins (same `fn` argument using `===`)\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nSchema.prototype.plugin = function(fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' +\n      'got \"' + (typeof fn) + '\"');\n  }\n\n\n  if (opts && opts.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({ fn: fn, opts: opts });\n\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     const Kitty = mongoose.model('Kitty', schema);\n *\n *     const fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     const fizz = new Kitty;\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](https://mongoosejs.com/docs/guide.html#methods)\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n */\n\nSchema.prototype.method = function(name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = clone(options);\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = new Schema(..);\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\n *     schema.static('findByName', function(name) {\n *       return this.find({ name: name });\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.static({\n *         findByName: function () {..}\n *       , findByCost: function () {..}\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *     await Drink.findByCost(3);\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n * @see Statics https://mongoosejs.com/docs/guide.html#statics\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * #### Example:\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#createIndex)\n * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @param {String} [options.language_override=null] Tells mongodb to use the specified field instead of `language` for parsing text indexes.\n * @api public\n */\n\nSchema.prototype.index = function(fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n  for (const key in fields) {\n    if (this.aliases[key]) {\n      fields[this.aliases[key]] = fields[key];\n      delete fields[key];\n    }\n  }\n\n  for (const field of Object.keys(fields)) {\n    if (fields[field] === 'ascending' || fields[field] === 'asc') {\n      fields[field] = 1;\n    } else if (fields[field] === 'descending' || fields[field] === 'desc') {\n      fields[field] = -1;\n    }\n  }\n\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets a schema option.\n *\n * #### Example:\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key The name of the option to set the value to\n * @param {Object} [value] The value to set the option to, if not passed, the option will be reset to default\n * @param {Array<string>} [tags] tags to add to read preference if key === 'read'\n * @see Schema https://mongoosejs.com/docs/api/schema.html#Schema()\n * @api public\n */\n\nSchema.prototype.set = function(key, value, tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      if (typeof value === 'string') {\n        this.options[key] = { mode: handleReadPreferenceAliases(value), tags };\n      } else if (Array.isArray(value) && typeof value[0] === 'string') {\n        this.options[key] = {\n          mode: handleReadPreferenceAliases(value[0]),\n          tags: value[1]\n        };\n      } else {\n        this.options[key] = value;\n      }\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n      break;\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  // Propagate `strict` and `strictQuery` changes down to implicitly created schemas\n  if (key === 'strict') {\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { strict: value });\n  }\n  if (key === 'strictQuery') {\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { strictQuery: value });\n  }\n\n  return this;\n};\n\n/*!\n * Recursively set options on implicitly created schemas\n */\n\nfunction _propagateOptionsToImplicitlyCreatedSchemas(baseSchema, options) {\n  for (const { schema } of baseSchema.childSchemas) {\n    if (!schema.$implicitlyCreated) {\n      continue;\n    }\n    Object.assign(schema.options, options);\n    _propagateOptionsToImplicitlyCreatedSchemas(schema, options);\n  }\n}\n\n/**\n * Gets a schema option.\n *\n * #### Example:\n *\n *     schema.get('strict'); // true\n *     schema.set('strict', false);\n *     schema.get('strict'); // false\n *\n * @param {String} key The name of the Option to get the current value for\n * @api public\n * @return {Any} the option's value\n */\n\nSchema.prototype.get = function(key) {\n  return this.options[key];\n};\n\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\n\n/**\n * The allowed index types\n *\n * @property {String[]} indexTypes\n * @memberOf Schema\n * @static\n * @api public\n */\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function() {\n    return indexTypes;\n  },\n  set: function() {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.\n * Indexes are expressed as an array `[spec, options]`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       email: { type: String, required: true, unique: true },\n *       registeredAt: { type: Date, index: true }\n *     });\n *\n *     // [ [ { email: 1 }, { unique: true, background: true } ],\n *     //   [ { registeredAt: 1 }, { background: true } ] ]\n *     userSchema.indexes();\n *\n * [Plugins](https://mongoosejs.com/docs/plugins.html) can use the return value of this function to modify a schema's indexes.\n * For example, the below plugin makes every index unique by default.\n *\n *     function myPlugin(schema) {\n *       for (const index of schema.indexes()) {\n *         if (index[1].unique === undefined) {\n *           index[1].unique = true;\n *         }\n *       }\n *     }\n *\n * @api public\n * @return {Array} list of indexes defined in the schema\n */\n\nSchema.prototype.indexes = function() {\n  return getIndexes(this);\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name The name of the Virtual\n * @param {Object} [options]\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](https://mongoosejs.com/docs/populate.html#populate-virtuals).\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](https://mongoosejs.com/docs/populate.html#populate-virtuals) for more information.\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](https://mongoosejs.com/docs/populate.html#populate-virtuals) for more information.\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n * @param {Function|null} [options.get=null] Adds a [getter](https://mongoosejs.com/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.\n * @param {Object|Function} [options.match=null] Apply a default [`match` option to populate](https://mongoosejs.com/docs/populate.html#match), adding an additional filter to the populate query.\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function virtualPreInit(obj) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n    });\n\n    const virtual = this.virtual(name);\n    virtual.options = options;\n\n    virtual.\n      set(function(_v) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n\n          if (typeof this.$$populatedVirtuals[name] !== 'object') {\n            this.$$populatedVirtuals[name] = options.count ? _v : null;\n          }\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n\n          this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {\n            return doc && typeof doc === 'object';\n          });\n        }\n      });\n\n    if (typeof options.get === 'function') {\n      virtual.get(options.get);\n    }\n\n    // Workaround for gh-8198: if virtual is under document array, make a fake\n    // virtual. See gh-8210, gh-13189\n    const parts = name.split('.');\n    let cur = parts[0];\n    for (let i = 0; i < parts.length - 1; ++i) {\n      if (this.paths[cur] == null) {\n        continue;\n      }\n\n      if (this.paths[cur].$isMongooseDocumentArray || this.paths[cur].$isSingleNested) {\n        const remnant = parts.slice(i + 1).join('.');\n        this.paths[cur].schema.virtual(remnant, options);\n        break;\n      }\n\n      cur += '.' + parts[i + 1];\n    }\n\n    return virtual;\n  }\n\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' +\n      ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function(mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length - 1)\n      ? new VirtualType(options, name)\n      : {});\n    return mem[part];\n  }, this.tree);\n\n  return virtuals[name];\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name The name of the Virtual to get\n * @return {VirtualType|null}\n */\n\nSchema.prototype.virtualpath = function(name) {\n  return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String, age: Number });\n *     schema.remove('name');\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // SchemaNumber { ... }\n *\n * Or as a Array:\n *\n *     schema.remove(['name', 'age']);\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // Undefined\n *\n * @param {String|Array} path The Path(s) to remove\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.remove = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function(name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).\n          concat(Object.keys(this.nested));\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n            _deletePath(this, path);\n          }\n        }\n\n        delete this.nested[name];\n        _deletePath(this, name);\n        return;\n      }\n\n      delete this.paths[name];\n      _deletePath(this, name);\n    }, this);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n\n  let branch = schema.tree;\n\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n\n  delete branch[last];\n}\n\n/**\n * Removes the given virtual or virtuals from the schema.\n *\n * @param {String|Array} path The virutal path(s) to remove.\n * @returns {Schema} the Schema instance, or a mongoose error if the virtual does not exist.\n * @api public\n */\n\nSchema.prototype.removeVirtual = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    for (const virtual of path) {\n      if (this.virtuals[virtual] == null) {\n        throw new MongooseError(`Attempting to remove virtual \"${virtual}\" that does not exist.`);\n      }\n    }\n\n    for (const virtual of path) {\n      delete this.paths[virtual];\n      delete this.virtuals[virtual];\n      if (virtual.indexOf('.') !== -1) {\n        mpath.unset(virtual, this.tree);\n      } else {\n        delete this.tree[virtual];\n      }\n    }\n  }\n  return this;\n};\n\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](https://mongoosejs.com/docs/guide.html#virtuals),\n * [statics](https://mongoosejs.com/docs/guide.html#statics), and\n * [methods](https://mongoosejs.com/docs/guide.html#methods).\n *\n * #### Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model The Class to load\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\nSchema.prototype.loadClass = function(model, virtualsOnly) {\n  // Stop copying when hit certain base classes\n  if (model === Object.prototype ||\n      model === Function.prototype ||\n      model.prototype.hasOwnProperty('$isMongooseModelPrototype') ||\n      model.prototype.hasOwnProperty('$isMongooseDocumentPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model), virtualsOnly);\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function(name) {\n      if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {\n        return;\n      }\n      const prop = Object.getOwnPropertyDescriptor(model, name);\n      if (prop.hasOwnProperty('value')) {\n        this.static(name, prop.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].getters = [];\n      }\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].setters = [];\n      }\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  const resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length) {\n            if (p + 1 === parts.length && foundschema.$embeddedSchemaType && (parts[p] === '$' || isArrayFilter(parts[p]))) {\n              return foundschema.$embeddedSchemaType;\n            }\n\n            if (foundschema.schema) {\n              let ret;\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema.$embeddedSchemaType;\n                }\n                // comments.$.comments.$.title\n                ret = search(parts.slice(p + 1), foundschema.schema);\n                if (ret) {\n                  ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                    (foundschema.schema.$isSingleNested ? null : foundschema);\n                }\n                return ret;\n              }\n              // this is the last path of the selector\n              ret = search(parts.slice(p), foundschema.schema);\n              if (ret) {\n                ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                  (foundschema.schema.$isSingleNested ? null : foundschema);\n              }\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p >= parts.length) {\n            return foundschema;\n          }\n          // Any path in the map will be an instance of the map's embedded schematype\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n\n          if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {\n            return foundschema.$__schemaType;\n          }\n          if (foundschema.$__schemaType.schema != null) {\n            // Map of docs\n            const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n            return ret;\n          }\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n    if (numberRE.test(parts[i])) {\n      parts[i] = '$';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return { schema: foundschema, pathType: 'mixed' };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return { schema: foundschema, pathType: 'nested' };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return { schema: foundschema, pathType: 'real' };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return { schema: schema, pathType: 'nested' };\n      }\n    }\n    return { schema: foundschema || schema, pathType: 'undefined' };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/*!\n * ignore\n */\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n\n/**\n * Called by `compile()` _right before_ compiling. Good for making any changes to\n * the schema that should respect options set by plugins, like `id`\n * @method _preCompile\n * @memberOf Schema\n * @instance\n * @api private\n */\n\nSchema.prototype._preCompile = function _preCompile() {\n  this.plugin(idGetter, { deduplicate: true });\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * #### Types:\n *\n * - [String](https://mongoosejs.com/docs/schematypes.html#strings)\n * - [Number](https://mongoosejs.com/docs/schematypes.html#numbers)\n * - [Boolean](https://mongoosejs.com/docs/schematypes.html#booleans) | Bool\n * - [Array](https://mongoosejs.com/docs/schematypes.html#arrays)\n * - [Buffer](https://mongoosejs.com/docs/schematypes.html#buffers)\n * - [Date](https://mongoosejs.com/docs/schematypes.html#dates)\n * - [ObjectId](https://mongoosejs.com/docs/schematypes.html#objectids) | Oid\n * - [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed)\n * - [UUID](https://mongoosejs.com/docs/schematypes.html#uuid)\n * - [BigInt](https://mongoosejs.com/docs/schematypes.html#bigint)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     const Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = __webpack_require__(/*! ./schema/index */ \"(api)/../server/node_modules/mongoose/lib/schema/index.js\");\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsMERBQThCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyw0REFBUTtBQUMvQixzQkFBc0IsbUJBQU8sQ0FBQywrRkFBdUI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsNkVBQWM7QUFDekMsMEJBQTBCLG1CQUFPLENBQUMsMkdBQTZCO0FBQy9ELHVCQUF1QixtQkFBTyxDQUFDLHFHQUEwQjtBQUN6RCxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBZTtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyx5R0FBNEI7QUFDdEQsY0FBYyxtQkFBTyxDQUFDLG1GQUFpQjtBQUN2QyxZQUFZLG1CQUFPLENBQUMsK0VBQWU7QUFDbkMsMkJBQTJCLG1CQUFPLENBQUMsNkdBQThCO0FBQ2pFLG1CQUFtQixtQkFBTyxDQUFDLDJHQUE2QjtBQUN4RCxvQ0FBb0MsbUJBQU8sQ0FBQywySUFBNkM7QUFDekYsaUJBQWlCLG1CQUFPLENBQUMsdUdBQTJCO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQyxpR0FBd0I7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLDBEQUFPO0FBQzdCLHdCQUF3QixtQkFBTyxDQUFDLDZIQUFzQztBQUN0RSxjQUFjLG1CQUFPLENBQUMsbUVBQVM7QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsaUhBQWdDO0FBQzVELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7O0FBRUE7O0FBRUEsbUJBQW1CLHdLQUNFO0FBQ3JCLHNCQUFzQixvSkFBeUQ7QUFDL0U7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQsbUNBQW1DLDhDQUE4QztBQUNqRjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYyxJQUFJLDhCQUE4QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EscUNBQXFDLEtBQUssc0JBQXNCO0FBQ2hFLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVyxRQUFRLFdBQVc7QUFDakUsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjLElBQUksWUFBWTtBQUNqRSxxQkFBcUIsS0FBSyxxQkFBcUI7QUFDL0M7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQyxxQkFBcUIsS0FBSyxxQkFBcUIsS0FBSyxzQkFBc0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0EseUJBQXlCO0FBQ3pCLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRCw4QkFBOEI7QUFDOUI7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pELDhCQUE4QjtBQUM5QjtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQkFBaUIsSUFBSSwwQkFBMEI7QUFDaEc7QUFDQSx3REFBd0QsaUJBQWlCLElBQUksMEJBQTBCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQSx3Q0FBd0MsbUNBQW1DO0FBQzNFLG9CQUFvQjtBQUNwQixvQ0FBb0M7QUFDcEM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7O0FBRXpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFrRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsSUFBSTtBQUNqRSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxNQUFNO0FBQ047QUFDQSwwQkFBMEIsUUFBUSxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxTQUFTLG9CQUFvQjtBQUMvRTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNENBQTRDO0FBQ2xGO0FBQ0EsK0JBQStCO0FBQy9CLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQSw0QkFBNEI7QUFDNUIsMERBQTBELG1CQUFtQjtBQUM3RSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVSxJQUFJLDhCQUE4QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNENBQTRDO0FBQ2xGLHlCQUF5QixTQUFTO0FBQ2xDLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBOztBQUVBLCtCQUErQixtQkFBTyxDQUFDLGlGQUFnQjs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHNjaGVtYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBLYXJlZW0gPSByZXF1aXJlKCdrYXJlZW0nKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuL3NjaGVtYXR5cGUnKTtcbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zL1NjaGVtYVR5cGVPcHRpb25zJyk7XG5jb25zdCBWaXJ0dWFsT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9ucy9WaXJ0dWFsT3B0aW9ucycpO1xuY29uc3QgVmlydHVhbFR5cGUgPSByZXF1aXJlKCcuL3ZpcnR1YWx0eXBlJyk7XG5jb25zdCBhZGRBdXRvSWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hL2FkZEF1dG9JZCcpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXQnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXRDb25zdHJ1Y3Rvck5hbWUnKTtcbmNvbnN0IGdldEluZGV4ZXMgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hL2dldEluZGV4ZXMnKTtcbmNvbnN0IGhhbmRsZVJlYWRQcmVmZXJlbmNlQWxpYXNlcyA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9oYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMnKTtcbmNvbnN0IGlkR2V0dGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9pZEdldHRlcicpO1xuY29uc3QgbWVyZ2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hL21lcmdlJyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5jb25zdCBzZXR1cFRpbWVzdGFtcHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvdGltZXN0YW1wcy9zZXR1cFRpbWVzdGFtcHMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgdmFsaWRhdGVSZWYgPSByZXF1aXJlKCcuL2hlbHBlcnMvcG9wdWxhdGUvdmFsaWRhdGVSZWYnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IGhhc051bWVyaWNTdWJwYXRoUmVnZXggPSAvXFwuXFxkKyhcXC58JCkvO1xuXG5sZXQgTW9uZ29vc2VUeXBlcztcblxuY29uc3QgcXVlcnlIb29rcyA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9hcHBseVF1ZXJ5TWlkZGxld2FyZScpLlxuICBtaWRkbGV3YXJlRnVuY3Rpb25zO1xuY29uc3QgZG9jdW1lbnRIb29rcyA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9hcHBseUhvb2tzJykubWlkZGxld2FyZUZ1bmN0aW9ucztcbmNvbnN0IGhvb2tOYW1lcyA9IHF1ZXJ5SG9va3MuY29uY2F0KGRvY3VtZW50SG9va3MpLlxuICByZWR1Y2UoKHMsIGhvb2spID0+IHMuYWRkKGhvb2spLCBuZXcgU2V0KCkpO1xuXG5jb25zdCBpc1BPSk8gPSB1dGlscy5pc1BPSk87XG5cbmxldCBpZCA9IDA7XG5cbmNvbnN0IG51bWJlclJFID0gL15cXGQrJC87XG5cbi8qKlxuICogU2NoZW1hIGNvbnN0cnVjdG9yLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY2hpbGQgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGFnZTogTnVtYmVyLCBjaGlsZHJlbjogW2NoaWxkXSB9KTtcbiAqICAgICBjb25zdCBUcmVlID0gbW9uZ29vc2UubW9kZWwoJ1RyZWUnLCBzY2hlbWEpO1xuICpcbiAqICAgICAvLyBzZXR0aW5nIHNjaGVtYSBvcHRpb25zXG4gKiAgICAgbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9LCB7IF9pZDogZmFsc2UsIGF1dG9JbmRleDogZmFsc2UgfSlcbiAqXG4gKiAjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBbYXV0b0luZGV4XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNhdXRvSW5kZXgpOiBib29sIC0gZGVmYXVsdHMgdG8gbnVsbCAod2hpY2ggbWVhbnMgdXNlIHRoZSBjb25uZWN0aW9uJ3MgYXV0b0luZGV4IG9wdGlvbilcbiAqIC0gW2F1dG9DcmVhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2F1dG9DcmVhdGUpOiBib29sIC0gZGVmYXVsdHMgdG8gbnVsbCAod2hpY2ggbWVhbnMgdXNlIHRoZSBjb25uZWN0aW9uJ3MgYXV0b0NyZWF0ZSBvcHRpb24pXG4gKiAtIFtidWZmZXJDb21tYW5kc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjYnVmZmVyQ29tbWFuZHMpOiBib29sIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICogLSBbYnVmZmVyVGltZW91dE1TXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNidWZmZXJUaW1lb3V0TVMpOiBudW1iZXIgLSBkZWZhdWx0cyB0byAxMDAwMCAoMTAgc2Vjb25kcykuIElmIGBidWZmZXJDb21tYW5kc2AgaXMgZW5hYmxlZCwgdGhlIGFtb3VudCBvZiB0aW1lIE1vbmdvb3NlIHdpbGwgd2FpdCBmb3IgY29ubmVjdGl2aXR5IHRvIGJlIHJlc3RhYmxpc2hlZCBiZWZvcmUgZXJyb3Jpbmcgb3V0LlxuICogLSBbY2FwcGVkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNjYXBwZWQpOiBib29sIHwgbnVtYmVyIHwgb2JqZWN0IC0gZGVmYXVsdHMgdG8gZmFsc2VcbiAqIC0gW2NvbGxlY3Rpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2NvbGxlY3Rpb24pOiBzdHJpbmcgLSBubyBkZWZhdWx0XG4gKiAtIFtkaXNjcmltaW5hdG9yS2V5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNkaXNjcmltaW5hdG9yS2V5KTogc3RyaW5nIC0gZGVmYXVsdHMgdG8gYF9fdGBcbiAqIC0gW2lkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNpZCk6IGJvb2wgLSBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIFtfaWRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI19pZCk6IGJvb2wgLSBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIFttaW5pbWl6ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjbWluaW1pemUpOiBib29sIC0gY29udHJvbHMgW2RvY3VtZW50I3RvT2JqZWN0XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnRvT2JqZWN0KCkpIGJlaGF2aW9yIHdoZW4gY2FsbGVkIG1hbnVhbGx5IC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICogLSBbcmVhZF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjcmVhZCk6IHN0cmluZ1xuICogLSBbd3JpdGVDb25jZXJuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pOiBvYmplY3QgLSBkZWZhdWx0cyB0byBudWxsLCB1c2UgdG8gb3ZlcnJpZGUgW3RoZSBNb25nb0RCIHNlcnZlcidzIGRlZmF1bHQgd3JpdGUgY29uY2VybiBzZXR0aW5nc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vKVxuICogLSBbc2hhcmRLZXldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NoYXJkS2V5KTogb2JqZWN0IC0gZGVmYXVsdHMgdG8gYG51bGxgXG4gKiAtIFtzdHJpY3RdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdCk6IGJvb2wgLSBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIFtzdHJpY3RRdWVyeV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0UXVlcnkpOiBib29sIC0gZGVmYXVsdHMgdG8gZmFsc2VcbiAqIC0gW3RvSlNPTl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdG9KU09OKSAtIG9iamVjdCAtIG5vIGRlZmF1bHRcbiAqIC0gW3RvT2JqZWN0XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0b09iamVjdCkgLSBvYmplY3QgLSBubyBkZWZhdWx0XG4gKiAtIFt0eXBlS2V5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0eXBlS2V5KSAtIHN0cmluZyAtIGRlZmF1bHRzIHRvICd0eXBlJ1xuICogLSBbdmFsaWRhdGVCZWZvcmVTYXZlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN2YWxpZGF0ZUJlZm9yZVNhdmUpIC0gYm9vbCAtIGRlZmF1bHRzIHRvIGB0cnVlYFxuICogLSBbdmFsaWRhdGVNb2RpZmllZE9ubHldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGUoKSkgLSBib29sIC0gZGVmYXVsdHMgdG8gYGZhbHNlYFxuICogLSBbdmVyc2lvbktleV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdmVyc2lvbktleSk6IHN0cmluZyBvciBvYmplY3QgLSBkZWZhdWx0cyB0byBcIl9fdlwiXG4gKiAtIFtvcHRpbWlzdGljQ29uY3VycmVuY3ldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI29wdGltaXN0aWNDb25jdXJyZW5jeSk6IGJvb2wgLSBkZWZhdWx0cyB0byBmYWxzZS4gU2V0IHRvIHRydWUgdG8gZW5hYmxlIFtvcHRpbWlzdGljIGNvbmN1cnJlbmN5XShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3doYXRzLW5ldy1pbi1tb25nb29zZS01LTEwLW9wdGltaXN0aWMtY29uY3VycmVuY3kuaHRtbCkuXG4gKiAtIFtjb2xsYXRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2NvbGxhdGlvbik6IG9iamVjdCAtIGRlZmF1bHRzIHRvIG51bGwgKHdoaWNoIG1lYW5zIHVzZSBubyBjb2xsYXRpb24pXG4gKiAtIFt0aW1lc2VyaWVzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc2VyaWVzKTogb2JqZWN0IC0gZGVmYXVsdHMgdG8gbnVsbCAod2hpY2ggbWVhbnMgdGhpcyBzY2hlbWEncyBjb2xsZWN0aW9uIHdvbid0IGJlIGEgdGltZXNlcmllcyBjb2xsZWN0aW9uKVxuICogLSBbc2VsZWN0UG9wdWxhdGVkUGF0aHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NlbGVjdFBvcHVsYXRlZFBhdGhzKTogYm9vbGVhbiAtIGRlZmF1bHRzIHRvIGB0cnVlYFxuICogLSBbc2tpcFZlcnNpb25pbmddKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NraXBWZXJzaW9uaW5nKTogb2JqZWN0IC0gcGF0aHMgdG8gZXhjbHVkZSBmcm9tIHZlcnNpb25pbmdcbiAqIC0gW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpOiBvYmplY3Qgb3IgYm9vbGVhbiAtIGRlZmF1bHRzIHRvIGBmYWxzZWAuIElmIHRydWUsIE1vbmdvb3NlIGFkZHMgYGNyZWF0ZWRBdGAgYW5kIGB1cGRhdGVkQXRgIHByb3BlcnRpZXMgdG8geW91ciBzY2hlbWEgYW5kIG1hbmFnZXMgdGhvc2UgcHJvcGVydGllcyBmb3IgeW91LlxuICogLSBbcGx1Z2luVGFnc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjcGx1Z2luVGFncyk6IGFycmF5IG9mIHN0cmluZ3MgLSBkZWZhdWx0cyB0byBgdW5kZWZpbmVkYC4gSWYgc2V0IGFuZCBwbHVnaW4gY2FsbGVkIHdpdGggYHRhZ3NgIG9wdGlvbiwgd2lsbCBvbmx5IGFwcGx5IHRoYXQgcGx1Z2luIHRvIHNjaGVtYXMgd2l0aCBhIG1hdGNoaW5nIHRhZy5cbiAqIC0gW3ZpcnR1YWxzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL3ZpcnR1YWxzLmh0bWwjdmlydHVhbHMtdmlhLXNjaGVtYS1vcHRpb25zKTogb2JqZWN0IC0gdmlydHVhbHMgdG8gZGVmaW5lLCBhbGlhcyBmb3IgW2AudmlydHVhbGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hLmh0bWwjU2NoZW1hLnByb3RvdHlwZS52aXJ0dWFsKCkpXG4gKiAtIFtjb2xsZWN0aW9uT3B0aW9uc106IG9iamVjdCB3aXRoIG9wdGlvbnMgcGFzc2VkIHRvIFtgY3JlYXRlQ29sbGVjdGlvbigpYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jcmVhdGVDb2xsZWN0aW9uLykgd2hlbiBjYWxsaW5nIGBNb2RlbC5jcmVhdGVDb2xsZWN0aW9uKClgIG9yIGBhdXRvQ3JlYXRlYCBzZXQgdG8gdHJ1ZS5cbiAqXG4gKiAjIyMjIE9wdGlvbnMgZm9yIE5lc3RlZCBTY2hlbWFzOlxuICpcbiAqIC0gYGV4Y2x1ZGVJbmRleGVzYDogYm9vbCAtIGRlZmF1bHRzIHRvIGBmYWxzZWAuIElmIGB0cnVlYCwgc2tpcCBidWlsZGluZyBpbmRleGVzIG9uIHRoaXMgc2NoZW1hJ3MgcGF0aHMuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIF9XaGVuIG5lc3Rpbmcgc2NoZW1hcywgKGBjaGlsZHJlbmAgaW4gdGhlIGV4YW1wbGUgYWJvdmUpLCBhbHdheXMgZGVjbGFyZSB0aGUgY2hpbGQgc2NoZW1hIGZpcnN0IGJlZm9yZSBwYXNzaW5nIGl0IGludG8gaXRzIHBhcmVudC5fXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U2NoZW1hfEFycmF5fSBbZGVmaW5pdGlvbl0gQ2FuIGJlIG9uZSBvZjogb2JqZWN0IGRlc2NyaWJpbmcgc2NoZW1hIHBhdGhzLCBvciBzY2hlbWEgdG8gY29weSwgb3IgYXJyYXkgb2Ygb2JqZWN0cyBhbmQgc2NoZW1hc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGluaGVyaXRzIE5vZGVKUyBFdmVudEVtaXR0ZXIgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNjbGFzcy1ldmVudGVtaXR0ZXJcbiAqIEBldmVudCBgaW5pdGA6IEVtaXR0ZWQgYWZ0ZXIgdGhlIHNjaGVtYSBpcyBjb21waWxlZCBpbnRvIGEgYE1vZGVsYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hKG9iaiwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2NoZW1hKSkge1xuICAgIHJldHVybiBuZXcgU2NoZW1hKG9iaiwgb3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLm9iaiA9IG9iajtcbiAgdGhpcy5wYXRocyA9IHt9O1xuICB0aGlzLmFsaWFzZXMgPSB7fTtcbiAgdGhpcy5zdWJwYXRocyA9IHt9O1xuICB0aGlzLnZpcnR1YWxzID0ge307XG4gIHRoaXMuc2luZ2xlTmVzdGVkUGF0aHMgPSB7fTtcbiAgdGhpcy5uZXN0ZWQgPSB7fTtcbiAgdGhpcy5pbmhlcml0cyA9IHt9O1xuICB0aGlzLmNhbGxRdWV1ZSA9IFtdO1xuICB0aGlzLl9pbmRleGVzID0gW107XG4gIHRoaXMubWV0aG9kcyA9IChvcHRpb25zICYmIG9wdGlvbnMubWV0aG9kcykgfHwge307XG4gIHRoaXMubWV0aG9kT3B0aW9ucyA9IHt9O1xuICB0aGlzLnN0YXRpY3MgPSAob3B0aW9ucyAmJiBvcHRpb25zLnN0YXRpY3MpIHx8IHt9O1xuICB0aGlzLnRyZWUgPSB7fTtcbiAgdGhpcy5xdWVyeSA9IChvcHRpb25zICYmIG9wdGlvbnMucXVlcnkpIHx8IHt9O1xuICB0aGlzLmNoaWxkU2NoZW1hcyA9IFtdO1xuICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgLy8gRm9yIGludGVybmFsIGRlYnVnZ2luZy4gRG8gbm90IHVzZSB0aGlzIHRvIHRyeSB0byBzYXZlIGEgc2NoZW1hIGluIE1EQi5cbiAgdGhpcy4kaWQgPSArK2lkO1xuICB0aGlzLm1hcFBhdGhzID0gW107XG5cbiAgdGhpcy5zID0ge1xuICAgIGhvb2tzOiBuZXcgS2FyZWVtKClcbiAgfTtcbiAgdGhpcy5vcHRpb25zID0gdGhpcy5kZWZhdWx0T3B0aW9ucyhvcHRpb25zKTtcblxuICAvLyBidWlsZCBwYXRoc1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgZm9yIChjb25zdCBkZWZpbml0aW9uIG9mIG9iaikge1xuICAgICAgdGhpcy5hZGQoZGVmaW5pdGlvbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9iaikge1xuICAgIHRoaXMuYWRkKG9iaik7XG4gIH1cblxuICAvLyBidWlsZCB2aXJ0dWFsIHBhdGhzXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMudmlydHVhbHMpIHtcbiAgICBjb25zdCB2aXJ0dWFscyA9IG9wdGlvbnMudmlydHVhbHM7XG4gICAgY29uc3QgcGF0aE5hbWVzID0gT2JqZWN0LmtleXModmlydHVhbHMpO1xuICAgIGZvciAoY29uc3QgcGF0aE5hbWUgb2YgcGF0aE5hbWVzKSB7XG4gICAgICBjb25zdCBwYXRoT3B0aW9ucyA9IHZpcnR1YWxzW3BhdGhOYW1lXS5vcHRpb25zID8gdmlydHVhbHNbcGF0aE5hbWVdLm9wdGlvbnMgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCB2aXJ0dWFsID0gdGhpcy52aXJ0dWFsKHBhdGhOYW1lLCBwYXRoT3B0aW9ucyk7XG5cbiAgICAgIGlmICh2aXJ0dWFsc1twYXRoTmFtZV0uZ2V0KSB7XG4gICAgICAgIHZpcnR1YWwuZ2V0KHZpcnR1YWxzW3BhdGhOYW1lXS5nZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmlydHVhbHNbcGF0aE5hbWVdLnNldCkge1xuICAgICAgICB2aXJ0dWFsLnNldCh2aXJ0dWFsc1twYXRoTmFtZV0uc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBpZiBfaWQncyB2YWx1ZSBpcyBhIHN1YmRvY3VtZW50IChnaC0yMjc2KVxuICBjb25zdCBfaWRTdWJEb2MgPSBvYmogJiYgb2JqLl9pZCAmJiB1dGlscy5pc09iamVjdChvYmouX2lkKTtcblxuICAvLyBlbnN1cmUgdGhlIGRvY3VtZW50cyBnZXQgYW4gYXV0byBfaWQgdW5sZXNzIGRpc2FibGVkXG4gIGNvbnN0IGF1dG9faWQgPSAhdGhpcy5wYXRoc1snX2lkJ10gJiZcbiAgICAgICh0aGlzLm9wdGlvbnMuX2lkKSAmJiAhX2lkU3ViRG9jO1xuXG4gIGlmIChhdXRvX2lkKSB7XG4gICAgYWRkQXV0b0lkKHRoaXMpO1xuICB9XG5cbiAgdGhpcy5zZXR1cFRpbWVzdGFtcCh0aGlzLm9wdGlvbnMudGltZXN0YW1wcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIHZpcnR1YWwgcHJvcGVydGllcyB3aXRoIGFsaWFzIGZpZWxkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWxpYXNGaWVsZHMoc2NoZW1hLCBwYXRocykge1xuICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXMocGF0aHMpKSB7XG4gICAgbGV0IGFsaWFzID0gbnVsbDtcbiAgICBpZiAocGF0aHNbcGF0aF0gIT0gbnVsbCkge1xuICAgICAgYWxpYXMgPSBwYXRoc1twYXRoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGdldChzY2hlbWEucGF0aHNbcGF0aF0sICdvcHRpb25zJyk7XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBhbGlhcyA9IG9wdGlvbnMuYWxpYXM7XG4gICAgfVxuXG4gICAgaWYgKCFhbGlhcykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvcCA9IHNjaGVtYS5wYXRoc1twYXRoXS5wYXRoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFsaWFzKSkge1xuICAgICAgZm9yIChjb25zdCBhIG9mIGFsaWFzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIGFsaWFzIG9wdGlvbiBvbiAnICsgcHJvcCArICcsIGdvdCAnICsgYSk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlbWEuYWxpYXNlc1thXSA9IHByb3A7XG5cbiAgICAgICAgc2NoZW1hLlxuICAgICAgICAgIHZpcnR1YWwoYSkuXG4gICAgICAgICAgZ2V0KChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQocCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbcF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pKHByb3ApKS5cbiAgICAgICAgICBzZXQoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLiRzZXQocCwgdik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pKHByb3ApKTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhbGlhcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgYWxpYXMgb3B0aW9uIG9uICcgKyBwcm9wICsgJywgZ290ICcgKyBhbGlhcyk7XG4gICAgfVxuXG4gICAgc2NoZW1hLmFsaWFzZXNbYWxpYXNdID0gcHJvcDtcblxuICAgIHNjaGVtYS5cbiAgICAgIHZpcnR1YWwoYWxpYXMpLlxuICAgICAgZ2V0KChmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQocCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzW3BdO1xuICAgICAgICB9O1xuICAgICAgfSkocHJvcCkpLlxuICAgICAgc2V0KChmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHNldChwLCB2KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHByb3ApKTtcbiAgfVxufVxuXG4vKiFcbiAqIEluaGVyaXQgZnJvbSBFdmVudEVtaXR0ZXIuXG4gKi9cblNjaGVtYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuU2NoZW1hLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYTtcblNjaGVtYS5wcm90b3R5cGUuaW5zdGFuY2VPZlNjaGVtYSA9IHRydWU7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYS5wcm90b3R5cGUsICckc2NoZW1hVHlwZScsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBBcnJheSBvZiBjaGlsZCBzY2hlbWFzIChmcm9tIGRvY3VtZW50IGFycmF5cyBhbmQgc2luZ2xlIG5lc3RlZCBzdWJkb2NzKVxuICogYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgY29tcGlsZWQgbW9kZWxzLiBFYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzXG4gKiBhbiBvYmplY3Qgd2l0aCAyIHByb3BlcnRpZXM6IGBzY2hlbWFgIGFuZCBgbW9kZWxgLlxuICpcbiAqIFRoaXMgcHJvcGVydHkgaXMgdHlwaWNhbGx5IG9ubHkgdXNlZnVsIGZvciBwbHVnaW4gYXV0aG9ycyBhbmQgYWR2YW5jZWQgdXNlcnMuXG4gKiBZb3UgZG8gbm90IG5lZWQgdG8gaW50ZXJhY3Qgd2l0aCB0aGlzIHByb3BlcnR5IGF0IGFsbCB0byB1c2UgbW9uZ29vc2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBjaGlsZFNjaGVtYXNcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWEucHJvdG90eXBlLCAnY2hpbGRTY2hlbWFzJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogT2JqZWN0IGNvbnRhaW5pbmcgYWxsIHZpcnR1YWxzIGRlZmluZWQgb24gdGhpcyBzY2hlbWEuXG4gKiBUaGUgb2JqZWN0cycga2V5cyBhcmUgdGhlIHZpcnR1YWwgcGF0aHMgYW5kIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIGBWaXJ0dWFsVHlwZWAuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBpcyB0eXBpY2FsbHkgb25seSB1c2VmdWwgZm9yIHBsdWdpbiBhdXRob3JzIGFuZCBhZHZhbmNlZCB1c2Vycy5cbiAqIFlvdSBkbyBub3QgbmVlZCB0byBpbnRlcmFjdCB3aXRoIHRoaXMgcHJvcGVydHkgYXQgYWxsIHRvIHVzZSBtb25nb29zZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoe30pO1xuICogICAgIHNjaGVtYS52aXJ0dWFsKCdhbnN3ZXInKS5nZXQoKCkgPT4gNDIpO1xuICpcbiAqICAgICBjb25zb2xlLmxvZyhzY2hlbWEudmlydHVhbHMpOyAvLyB7IGFuc3dlcjogVmlydHVhbFR5cGUgeyBwYXRoOiAnYW5zd2VyJywgLi4uIH0gfVxuICogICAgIGNvbnNvbGUubG9nKHNjaGVtYS52aXJ0dWFsc1snYW5zd2VyJ10uZ2V0dGVyc1swXS5jYWxsKCkpOyAvLyA0MlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdmlydHVhbHNcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWEucHJvdG90eXBlLCAndmlydHVhbHMnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBUaGUgb3JpZ2luYWwgb2JqZWN0IHBhc3NlZCB0byB0aGUgc2NoZW1hIGNvbnN0cnVjdG9yXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgYTogU3RyaW5nIH0pLmFkZCh7IGI6IFN0cmluZyB9KTtcbiAqICAgICBzY2hlbWEub2JqOyAvLyB7IGE6IFN0cmluZyB9XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBvYmpcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBpbnN0YW5jZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUub2JqO1xuXG4vKipcbiAqIFRoZSBwYXRocyBkZWZpbmVkIG9uIHRoaXMgc2NoZW1hLiBUaGUga2V5cyBhcmUgdGhlIHRvcC1sZXZlbCBwYXRoc1xuICogaW4gdGhpcyBzY2hlbWEsIGFuZCB0aGUgdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdGhlIFNjaGVtYVR5cGUgY2xhc3MuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgX2lkOiBmYWxzZSB9KTtcbiAqICAgICBzY2hlbWEucGF0aHM7IC8vIHsgbmFtZTogU2NoZW1hU3RyaW5nIHsgLi4uIH0gfVxuICpcbiAqICAgICBzY2hlbWEuYWRkKHsgYWdlOiBOdW1iZXIgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGhzOyAvLyB7IG5hbWU6IFNjaGVtYVN0cmluZyB7IC4uLiB9LCBhZ2U6IFNjaGVtYU51bWJlciB7IC4uLiB9IH1cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHBhdGhzXG4gKiBAbWVtYmVyT2YgU2NoZW1hXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnBhdGhzO1xuXG4vKipcbiAqIFNjaGVtYSBhcyBhIHRyZWVcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHtcbiAqICAgICAgICAgJ19pZCcgICAgIDogT2JqZWN0SWRcbiAqICAgICAgICwgJ25lc3RlZCcgIDoge1xuICogICAgICAgICAgICAgJ2tleScgOiBTdHJpbmdcbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBwcm9wZXJ0eSB0cmVlXG4gKiBAbWVtYmVyT2YgU2NoZW1hXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnRyZWU7XG5cbi8qKlxuICogUmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGUgc2NoZW1hXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIGNvbnN0IGNsb25lID0gc2NoZW1hLmNsb25lKCk7XG4gKiAgICAgY2xvbmUgPT09IHNjaGVtYTsgLy8gZmFsc2VcbiAqICAgICBjbG9uZS5wYXRoKCduYW1lJyk7IC8vIFNjaGVtYVN0cmluZyB7IC4uLiB9XG4gKlxuICogQHJldHVybiB7U2NoZW1hfSB0aGUgY2xvbmVkIHNjaGVtYVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBpbnN0YW5jZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgcyA9IHRoaXMuX2Nsb25lKCk7XG5cbiAgLy8gQnViYmxlIHVwIGBpbml0YCBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICBzLm9uKCdpbml0JywgdiA9PiB0aGlzLmVtaXQoJ2luaXQnLCB2KSk7XG5cbiAgcmV0dXJuIHM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24gX2Nsb25lKENvbnN0cnVjdG9yKSB7XG4gIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3IgfHwgKHRoaXMuYmFzZSA9PSBudWxsID8gU2NoZW1hIDogdGhpcy5iYXNlLlNjaGVtYSk7XG5cbiAgY29uc3QgcyA9IG5ldyBDb25zdHJ1Y3Rvcih7fSwgdGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucyk7XG4gIHMuYmFzZSA9IHRoaXMuYmFzZTtcbiAgcy5vYmogPSB0aGlzLm9iajtcbiAgcy5vcHRpb25zID0gY2xvbmUodGhpcy5vcHRpb25zKTtcbiAgcy5jYWxsUXVldWUgPSB0aGlzLmNhbGxRdWV1ZS5tYXAoZnVuY3Rpb24oZikgeyByZXR1cm4gZjsgfSk7XG4gIHMubWV0aG9kcyA9IGNsb25lKHRoaXMubWV0aG9kcyk7XG4gIHMubWV0aG9kT3B0aW9ucyA9IGNsb25lKHRoaXMubWV0aG9kT3B0aW9ucyk7XG4gIHMuc3RhdGljcyA9IGNsb25lKHRoaXMuc3RhdGljcyk7XG4gIHMucXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcbiAgcy5wbHVnaW5zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5wbHVnaW5zKTtcbiAgcy5faW5kZXhlcyA9IGNsb25lKHRoaXMuX2luZGV4ZXMpO1xuICBzLnMuaG9va3MgPSB0aGlzLnMuaG9va3MuY2xvbmUoKTtcblxuICBzLnRyZWUgPSBjbG9uZSh0aGlzLnRyZWUpO1xuICBzLnBhdGhzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMucGF0aHMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiAoW2tleSwgdmFsdWUuY2xvbmUoKV0pKVxuICApO1xuICBzLm5lc3RlZCA9IGNsb25lKHRoaXMubmVzdGVkKTtcbiAgcy5zdWJwYXRocyA9IGNsb25lKHRoaXMuc3VicGF0aHMpO1xuICBmb3IgKGNvbnN0IHNjaGVtYVR5cGUgb2YgT2JqZWN0LnZhbHVlcyhzLnBhdGhzKSkge1xuICAgIGlmIChzY2hlbWFUeXBlLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgY29uc3QgcGF0aCA9IHNjaGVtYVR5cGUucGF0aDtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnBhdGhzKSkge1xuICAgICAgICBzLnNpbmdsZU5lc3RlZFBhdGhzW3BhdGggKyAnLicgKyBrZXldID0gc2NoZW1hVHlwZS5zY2hlbWEucGF0aHNba2V5XTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzKSkge1xuICAgICAgICBzLnNpbmdsZU5lc3RlZFBhdGhzW3BhdGggKyAnLicgKyBrZXldID1cbiAgICAgICAgICBzY2hlbWFUeXBlLnNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRoc1trZXldO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEuc3VicGF0aHMpKSB7XG4gICAgICAgIHMuc2luZ2xlTmVzdGVkUGF0aHNbcGF0aCArICcuJyArIGtleV0gPVxuICAgICAgICAgIHNjaGVtYVR5cGUuc2NoZW1hLnN1YnBhdGhzW2tleV07XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5uZXN0ZWQpKSB7XG4gICAgICAgIHMuc2luZ2xlTmVzdGVkUGF0aHNbcGF0aCArICcuJyArIGtleV0gPSAnbmVzdGVkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcy5jaGlsZFNjaGVtYXMgPSBnYXRoZXJDaGlsZFNjaGVtYXMocyk7XG5cbiAgcy52aXJ0dWFscyA9IGNsb25lKHRoaXMudmlydHVhbHMpO1xuICBzLiRnbG9iYWxQbHVnaW5zQXBwbGllZCA9IHRoaXMuJGdsb2JhbFBsdWdpbnNBcHBsaWVkO1xuICBzLiRpc1Jvb3REaXNjcmltaW5hdG9yID0gdGhpcy4kaXNSb290RGlzY3JpbWluYXRvcjtcbiAgcy4kaW1wbGljaXRseUNyZWF0ZWQgPSB0aGlzLiRpbXBsaWNpdGx5Q3JlYXRlZDtcbiAgcy4kaWQgPSArK2lkO1xuICBzLiRvcmlnaW5hbFNjaGVtYUlkID0gdGhpcy4kaWQ7XG4gIHMubWFwUGF0aHMgPSBbXS5jb25jYXQodGhpcy5tYXBQYXRocyk7XG5cbiAgaWYgKHRoaXMuZGlzY3JpbWluYXRvck1hcHBpbmcgIT0gbnVsbCkge1xuICAgIHMuZGlzY3JpbWluYXRvck1hcHBpbmcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRpc2NyaW1pbmF0b3JNYXBwaW5nKTtcbiAgfVxuICBpZiAodGhpcy5kaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgcy5kaXNjcmltaW5hdG9ycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGlzY3JpbWluYXRvcnMpO1xuICB9XG4gIGlmICh0aGlzLl9hcHBseURpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICBzLl9hcHBseURpc2NyaW1pbmF0b3JzID0gbmV3IE1hcCh0aGlzLl9hcHBseURpc2NyaW1pbmF0b3JzKTtcbiAgfVxuXG4gIHMuYWxpYXNlcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYWxpYXNlcyk7XG5cbiAgcmV0dXJuIHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgc2NoZW1hIHRoYXQgaGFzIHRoZSBwaWNrZWQgYHBhdGhzYCBmcm9tIHRoaXMgc2NoZW1hLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGFuYWxhZ291cyB0byBbTG9kYXNoJ3MgYHBpY2soKWAgZnVuY3Rpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9kb2NzLzQuMTcuMTUjcGljaykgZm9yIE1vbmdvb3NlIHNjaGVtYXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGFnZTogTnVtYmVyIH0pO1xuICogICAgIC8vIENyZWF0ZXMgYSBuZXcgc2NoZW1hIHdpdGggdGhlIHNhbWUgYG5hbWVgIHBhdGggYXMgYHNjaGVtYWAsXG4gKiAgICAgLy8gYnV0IG5vIGBhZ2VgIHBhdGguXG4gKiAgICAgY29uc3QgbmV3U2NoZW1hID0gc2NoZW1hLnBpY2soWyduYW1lJ10pO1xuICpcbiAqICAgICBuZXdTY2hlbWEucGF0aCgnbmFtZScpOyAvLyBTY2hlbWFTdHJpbmcgeyAuLi4gfVxuICogICAgIG5ld1NjaGVtYS5wYXRoKCdhZ2UnKTsgLy8gdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmdbXX0gcGF0aHMgTGlzdCBvZiBQYXRocyB0byBwaWNrIGZvciB0aGUgbmV3IFNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIG5ldyBTY2hlbWEgQ29uc3RydWN0b3IgKHNhbWUgYXMgYG5ldyBTY2hlbWEoLi4sIE9wdGlvbnMpYCkuIERlZmF1bHRzIHRvIGB0aGlzLm9wdGlvbnNgIGlmIG5vdCBzZXQuXG4gKiBAcmV0dXJuIHtTY2hlbWF9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUucGljayA9IGZ1bmN0aW9uKHBhdGhzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG5ld1NjaGVtYSA9IG5ldyBTY2hlbWEoe30sIG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGhzKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdTY2hlbWEjcGljaygpIG9ubHkgYWNjZXB0cyBhbiBhcnJheSBhcmd1bWVudCwgJyArXG4gICAgICAnZ290IFwiJyArIHR5cGVvZiBwYXRocyArICdcIicpO1xuICB9XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgaWYgKHRoaXMubmVzdGVkW3BhdGhdKSB7XG4gICAgICBuZXdTY2hlbWEuYWRkKHsgW3BhdGhdOiBnZXQodGhpcy50cmVlLCBwYXRoKSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2NoZW1hdHlwZSA9IHRoaXMucGF0aChwYXRoKTtcbiAgICAgIGlmIChzY2hlbWF0eXBlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1BhdGggYCcgKyBwYXRoICsgJ2AgaXMgbm90IGluIHRoZSBzY2hlbWEnKTtcbiAgICAgIH1cbiAgICAgIG5ld1NjaGVtYS5hZGQoeyBbcGF0aF06IHNjaGVtYXR5cGUgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1NjaGVtYTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBzY2hlbWEgdGhhdCBoYXMgdGhlIGBwYXRoc2AgZnJvbSB0aGUgb3JpZ2luYWwgc2NoZW1hLCBtaW51cyB0aGUgb21pdHRlZCBvbmVzLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGFuYWxhZ291cyB0byBbTG9kYXNoJ3MgYG9taXQoKWAgZnVuY3Rpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9kb2NzLyNvbWl0KSBmb3IgTW9uZ29vc2Ugc2NoZW1hcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IFNjaGVtYSh7IG5hbWU6IFN0cmluZywgYWdlOiBOdW1iZXIgfSk7XG4gKiAgICAgLy8gQ3JlYXRlcyBhIG5ldyBzY2hlbWEgb21pdHRpbmcgdGhlIGBhZ2VgIHBhdGhcbiAqICAgICBjb25zdCBuZXdTY2hlbWEgPSBzY2hlbWEub21pdChbJ2FnZSddKTtcbiAqXG4gKiAgICAgbmV3U2NoZW1hLnBhdGgoJ25hbWUnKTsgLy8gU2NoZW1hU3RyaW5nIHsgLi4uIH1cbiAqICAgICBuZXdTY2hlbWEucGF0aCgnYWdlJyk7IC8vIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nW119IHBhdGhzIExpc3Qgb2YgUGF0aHMgdG8gb21pdCBmb3IgdGhlIG5ldyBTY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBuZXcgU2NoZW1hIENvbnN0cnVjdG9yIChzYW1lIGFzIGBuZXcgU2NoZW1hKC4uLCBPcHRpb25zKWApLiBEZWZhdWx0cyB0byBgdGhpcy5vcHRpb25zYCBpZiBub3Qgc2V0LlxuICogQHJldHVybiB7U2NoZW1hfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLm9taXQgPSBmdW5jdGlvbihwYXRocywgb3B0aW9ucykge1xuICBjb25zdCBuZXdTY2hlbWEgPSBuZXcgU2NoZW1hKHRoaXMsIG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGhzKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKFxuICAgICAgJ1NjaGVtYSNvbWl0KCkgb25seSBhY2NlcHRzIGFuIGFycmF5IGFyZ3VtZW50LCAnICtcbiAgICAgICAgJ2dvdCBcIicgK1xuICAgICAgICB0eXBlb2YgcGF0aHMgK1xuICAgICAgICAnXCInXG4gICAgKTtcbiAgfVxuXG4gIG5ld1NjaGVtYS5yZW1vdmUocGF0aHMpO1xuXG4gIGZvciAoY29uc3QgbmVzdGVkIGluIG5ld1NjaGVtYS5zaW5nbGVOZXN0ZWRQYXRocykge1xuICAgIGlmIChwYXRocy5pbmNsdWRlcyhuZXN0ZWQpKSB7XG4gICAgICBkZWxldGUgbmV3U2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzW25lc3RlZF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1NjaGVtYTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgc2NoZW1hLCBtZXJnZWQgd2l0aCBgb3B0aW9uc2AuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRvIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtZXJnZWQgb3B0aW9ucyBvZiBgb3B0aW9uc2AgYW5kIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMgPSBvcHRpb25zID09IG51bGwgPyB7fSA6IGNsb25lKG9wdGlvbnMpO1xuICBjb25zdCBiYXNlT3B0aW9ucyA9IHRoaXMuYmFzZSAmJiB0aGlzLmJhc2Uub3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgc3RyaWN0ID0gJ3N0cmljdCcgaW4gYmFzZU9wdGlvbnMgPyBiYXNlT3B0aW9ucy5zdHJpY3QgOiB0cnVlO1xuICBjb25zdCBzdHJpY3RRdWVyeSA9ICdzdHJpY3RRdWVyeScgaW4gYmFzZU9wdGlvbnMgPyBiYXNlT3B0aW9ucy5zdHJpY3RRdWVyeSA6IGZhbHNlO1xuICBjb25zdCBpZCA9ICdpZCcgaW4gYmFzZU9wdGlvbnMgPyBiYXNlT3B0aW9ucy5pZCA6IHRydWU7XG4gIG9wdGlvbnMgPSB7XG4gICAgc3RyaWN0LFxuICAgIHN0cmljdFF1ZXJ5LFxuICAgIGJ1ZmZlckNvbW1hbmRzOiB0cnVlLFxuICAgIGNhcHBlZDogZmFsc2UsIC8vIHsgc2l6ZSwgbWF4LCBhdXRvSW5kZXhJZCB9XG4gICAgdmVyc2lvbktleTogJ19fdicsXG4gICAgb3B0aW1pc3RpY0NvbmN1cnJlbmN5OiBmYWxzZSxcbiAgICBtaW5pbWl6ZTogdHJ1ZSxcbiAgICBhdXRvSW5kZXg6IG51bGwsXG4gICAgZGlzY3JpbWluYXRvcktleTogJ19fdCcsXG4gICAgc2hhcmRLZXk6IG51bGwsXG4gICAgcmVhZDogbnVsbCxcbiAgICB2YWxpZGF0ZUJlZm9yZVNhdmU6IHRydWUsXG4gICAgdmFsaWRhdGVNb2RpZmllZE9ubHk6IGZhbHNlLFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgYXJlIG9ubHkgYXBwbGllZCBhdCBjb25zdHJ1Y3Rpb24gdGltZVxuICAgIF9pZDogdHJ1ZSxcbiAgICBpZDogaWQsXG4gICAgdHlwZUtleTogJ3R5cGUnLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcblxuICBpZiAob3B0aW9ucy52ZXJzaW9uS2V5ICYmIHR5cGVvZiBvcHRpb25zLnZlcnNpb25LZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ2B2ZXJzaW9uS2V5YCBtdXN0IGJlIGZhbHN5IG9yIHN0cmluZywgZ290IGAnICsgKHR5cGVvZiBvcHRpb25zLnZlcnNpb25LZXkpICsgJ2AnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMucmVhZCA9IGhhbmRsZVJlYWRQcmVmZXJlbmNlQWxpYXNlcyhvcHRpb25zLnJlYWQpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5yZWFkKSAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkWzBdID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMucmVhZCA9IHtcbiAgICAgIG1vZGU6IGhhbmRsZVJlYWRQcmVmZXJlbmNlQWxpYXNlcyhvcHRpb25zLnJlYWRbMF0pLFxuICAgICAgdGFnczogb3B0aW9ucy5yZWFkWzFdXG4gICAgfTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm9wdGltaXN0aWNDb25jdXJyZW5jeSAmJiAhb3B0aW9ucy52ZXJzaW9uS2V5KSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ011c3Qgc2V0IGB2ZXJzaW9uS2V5YCBpZiB1c2luZyBgb3B0aW1pc3RpY0NvbmN1cnJlbmN5YCcpO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKipcbiAqIEluaGVyaXQgYSBTY2hlbWEgYnkgYXBwbHlpbmcgYSBkaXNjcmltaW5hdG9yIG9uIGFuIGV4aXN0aW5nIFNjaGVtYS5cbiAqXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBldmVudFNjaGVtYSA9IG5ldyBtb25nb29zZS5TY2hlbWEoeyB0aW1lc3RhbXA6IERhdGUgfSwgeyBkaXNjcmltaW5hdG9yS2V5OiAna2luZCcgfSk7XG4gKlxuICogICAgIGNvbnN0IGNsaWNrZWRFdmVudFNjaGVtYSA9IG5ldyBtb25nb29zZS5TY2hlbWEoeyBlbGVtZW50OiBTdHJpbmcgfSwgeyBkaXNjcmltaW5hdG9yS2V5OiAna2luZCcgfSk7XG4gKiAgICAgY29uc3QgQ2xpY2tlZE1vZGVsID0gZXZlbnRTY2hlbWEuZGlzY3JpbWluYXRvcignY2xpY2tlZCcsIGNsaWNrZWRFdmVudFNjaGVtYSk7XG4gKlxuICogICAgIGNvbnN0IEV2ZW50ID0gbW9uZ29vc2UubW9kZWwoJ0V2ZW50JywgZXZlbnRTY2hlbWEpO1xuICpcbiAqICAgICBFdmVudC5kaXNjcmltaW5hdG9yc1snY2xpY2tlZCddOyAvLyBNb2RlbCB7IGNsaWNrZWQgfVxuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBFdmVudC5jcmVhdGUoeyBraW5kOiAnY2xpY2tlZCcsIGVsZW1lbnQ6ICcjaGVybycgfSk7XG4gKiAgICAgZG9jLmVsZW1lbnQ7IC8vICcjaGVybydcbiAqICAgICBkb2MgaW5zdGFuY2VvZiBDbGlja2VkTW9kZWw7IC8vIHRydWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZGlzY3JpbWluYXRvclxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYSB0aGUgZGlzY3JpbWluYXRlZCBTY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gZGlzY3JpbWluYXRvciBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudmFsdWVdIHRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBgZGlzY3JpbWluYXRvcktleWAgcHJvcGVydHkuIElmIG5vdCBzcGVjaWZpZWQsIE1vbmdvb3NlIHVzZXMgdGhlIGBuYW1lYCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsb25lPXRydWVdIEJ5IGRlZmF1bHQsIGBkaXNjcmltaW5hdG9yKClgIGNsb25lcyB0aGUgZ2l2ZW4gYHNjaGVtYWAuIFNldCB0byBgZmFsc2VgIHRvIHNraXAgY2xvbmluZy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlTW9kZWxzPWZhbHNlXSBieSBkZWZhdWx0LCBNb25nb29zZSBkb2VzIG5vdCBhbGxvdyB5b3UgdG8gZGVmaW5lIGEgZGlzY3JpbWluYXRvciB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgYW5vdGhlciBkaXNjcmltaW5hdG9yLiBTZXQgdGhpcyB0byBhbGxvdyBvdmVyd3JpdGluZyBkaXNjcmltaW5hdG9ycyB3aXRoIHRoZSBzYW1lIG5hbWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1lcmdlSG9va3M9dHJ1ZV0gQnkgZGVmYXVsdCwgTW9uZ29vc2UgbWVyZ2VzIHRoZSBiYXNlIHNjaGVtYSdzIGhvb2tzIHdpdGggdGhlIGRpc2NyaW1pbmF0b3Igc2NoZW1hJ3MgaG9va3MuIFNldCB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHRvIG1ha2UgTW9uZ29vc2UgdXNlIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSdzIGhvb2tzIGluc3RlYWQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1lcmdlUGx1Z2lucz10cnVlXSBCeSBkZWZhdWx0LCBNb25nb29zZSBtZXJnZXMgdGhlIGJhc2Ugc2NoZW1hJ3MgcGx1Z2lucyB3aXRoIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSdzIHBsdWdpbnMuIFNldCB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHRvIG1ha2UgTW9uZ29vc2UgdXNlIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSdzIHBsdWdpbnMgaW5zdGVhZC5cbiAqIEByZXR1cm4ge1NjaGVtYX0gdGhlIFNjaGVtYSBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hLnByb3RvdHlwZS5kaXNjcmltaW5hdG9yID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIHRoaXMuX2FwcGx5RGlzY3JpbWluYXRvcnMgPSB0aGlzLl9hcHBseURpc2NyaW1pbmF0b3JzIHx8IG5ldyBNYXAoKTtcbiAgdGhpcy5fYXBwbHlEaXNjcmltaW5hdG9ycy5zZXQobmFtZSwgeyBzY2hlbWEsIG9wdGlvbnMgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMga2V5IHBhdGggLyBzY2hlbWEgdHlwZSBwYWlycyB0byB0aGlzIHNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRveVNjaGVtYSA9IG5ldyBTY2hlbWEoKTtcbiAqICAgICBUb3lTY2hlbWEuYWRkKHsgbmFtZTogJ3N0cmluZycsIGNvbG9yOiAnc3RyaW5nJywgcHJpY2U6ICdudW1iZXInIH0pO1xuICpcbiAqICAgICBjb25zdCBUdXJib01hblNjaGVtYSA9IG5ldyBTY2hlbWEoKTtcbiAqICAgICAvLyBZb3UgY2FuIGFsc28gYGFkZCgpYCBhbm90aGVyIHNjaGVtYSBhbmQgY29weSBvdmVyIGFsbCBwYXRocywgdmlydHVhbHMsXG4gKiAgICAgLy8gZ2V0dGVycywgc2V0dGVycywgaW5kZXhlcywgbWV0aG9kcywgYW5kIHN0YXRpY3MuXG4gKiAgICAgVHVyYm9NYW5TY2hlbWEuYWRkKFRveVNjaGVtYSkuYWRkKHsgeWVhcjogTnVtYmVyIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFNjaGVtYX0gb2JqIHBsYWluIG9iamVjdCB3aXRoIHBhdGhzIHRvIGFkZCwgb3IgYW5vdGhlciBzY2hlbWFcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4XSBwYXRoIHRvIHByZWZpeCB0aGUgbmV3bHkgYWRkZWQgcGF0aHMgd2l0aFxuICogQHJldHVybiB7U2NoZW1hfSB0aGUgU2NoZW1hIGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iaiwgcHJlZml4KSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBTY2hlbWEgfHwgKG9iaiAhPSBudWxsICYmIG9iai5pbnN0YW5jZU9mU2NoZW1hKSkge1xuICAgIG1lcmdlKHRoaXMsIG9iaik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFNwZWNpYWwgY2FzZTogc2V0dGluZyB0b3AtbGV2ZWwgYF9pZGAgdG8gZmFsc2Ugc2hvdWxkIGNvbnZlcnQgdG8gZGlzYWJsaW5nXG4gIC8vIHRoZSBgX2lkYCBvcHRpb24uIFRoaXMgYmVoYXZpb3IgbmV2ZXIgd29ya2VkIGJlZm9yZSA1LjQuMTEgYnV0IG51bWVyb3VzXG4gIC8vIGNvZGViYXNlcyB1c2UgaXQgKHNlZSBnaC03NTE2LCBnaC03NTEyKS5cbiAgaWYgKG9iai5faWQgPT09IGZhbHNlICYmIHByZWZpeCA9PSBudWxsKSB7XG4gICAgdGhpcy5vcHRpb25zLl9pZCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuICAvLyBhdm9pZCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gIGlmIChwcmVmaXggPT09ICdfX3Byb3RvX18uJyB8fCBwcmVmaXggPT09ICdjb25zdHJ1Y3Rvci4nIHx8IHByZWZpeCA9PT0gJ3Byb3RvdHlwZS4nKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgY29uc3QgdHlwZUtleSA9IHRoaXMub3B0aW9ucy50eXBlS2V5O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKHV0aWxzLnNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBmdWxsUGF0aCA9IHByZWZpeCArIGtleTtcbiAgICBjb25zdCB2YWwgPSBvYmpba2V5XTtcblxuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2YWx1ZSBmb3Igc2NoZW1hIHBhdGggYCcgKyBmdWxsUGF0aCArXG4gICAgICAgICdgLCBnb3QgdmFsdWUgXCInICsgdmFsICsgJ1wiJyk7XG4gICAgfVxuICAgIC8vIFJldGFpbiBgX2lkOiBmYWxzZWAgYnV0IGRvbid0IHNldCBpdCBhcyBhIHBhdGgsIHJlOiBnaC04Mjc0LlxuICAgIGlmIChrZXkgPT09ICdfaWQnICYmIHZhbCA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBEZXByZWNhdGUgc2V0dGluZyBzY2hlbWEgcGF0aHMgdG8gcHJpbWl0aXZlIHR5cGVzIChnaC03NTU4KVxuICAgIGxldCBpc01vbmdvb3NlVHlwZVN0cmluZyA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIGluIHdoaWNoIHRoZSB0eXBlIGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZWcuICdkYXRlJywgJ29pZCcsIC4uLilcbiAgICAgIGNvbnN0IE1vbmdvb3NlVHlwZXMgPSB0aGlzLmJhc2UgIT0gbnVsbCA/IHRoaXMuYmFzZS5TY2hlbWEuVHlwZXMgOiBTY2hlbWEuVHlwZXM7XG4gICAgICBjb25zdCB1cHBlclZhbCA9IHZhbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbC5zdWJzdHJpbmcoMSk7XG4gICAgICBpc01vbmdvb3NlVHlwZVN0cmluZyA9IE1vbmdvb3NlVHlwZXNbdXBwZXJWYWxdICE9IG51bGw7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGtleSAhPT0gJ19pZCcgJiZcbiAgICAgICgodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJyAmJiAhaXNNb25nb29zZVR5cGVTdHJpbmcpIHx8XG4gICAgICB2YWwgPT0gbnVsbClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2NoZW1hIGNvbmZpZ3VyYXRpb246IFxcYCR7dmFsfVxcYCBpcyBub3QgYCArXG4gICAgICAgIGBhIHZhbGlkIHR5cGUgYXQgcGF0aCBcXGAke2tleX1cXGAuIFNlZSBgICtcbiAgICAgICAgJ2h0dHBzOi8vYml0Lmx5L21vbmdvb3NlLXNjaGVtYXR5cGVzIGZvciBhIGxpc3Qgb2YgdmFsaWQgc2NoZW1hIHR5cGVzLicpO1xuICAgIH1cbiAgICBpZiAodmFsIGluc3RhbmNlb2YgVmlydHVhbFR5cGUgfHwgKHZhbC5jb25zdHJ1Y3RvciAmJiB2YWwuY29uc3RydWN0b3IubmFtZSB8fCBudWxsKSA9PT0gJ1ZpcnR1YWxUeXBlJykge1xuICAgICAgdGhpcy52aXJ0dWFsKHZhbCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGggPT09IDEgJiYgdmFsWzBdID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHNjaGVtYSBBcnJheSBwYXRoIGAnICsgZnVsbFBhdGggK1xuICAgICAgICAnYCwgZ290IHZhbHVlIFwiJyArIHZhbFswXSArICdcIicpO1xuICAgIH1cblxuICAgIGlmICghKGlzUE9KTyh2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFNjaGVtYVR5cGVPcHRpb25zKSkge1xuICAgICAgLy8gU3BlY2lhbC1jYXNlOiBOb24tb3B0aW9ucyBkZWZpbml0ZWx5IGEgcGF0aCBzbyBsZWFmIGF0IHRoaXMgbm9kZVxuICAgICAgLy8gRXhhbXBsZXM6IFNjaGVtYSBpbnN0YW5jZXMsIFNjaGVtYVR5cGUgaW5zdGFuY2VzXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIHRoaXMubmVzdGVkW3ByZWZpeC5zdWJzdHJpbmcoMCwgcHJlZml4Lmxlbmd0aCAtIDEpXSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnBhdGgocHJlZml4ICsga2V5LCB2YWwpO1xuICAgICAgaWYgKHZhbFswXSAhPSBudWxsICYmICEodmFsWzBdLmluc3RhbmNlT2ZTY2hlbWEpICYmIHV0aWxzLmlzUE9KTyh2YWxbMF0uZGlzY3JpbWluYXRvcnMpKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSB0aGlzLnBhdGgocHJlZml4ICsga2V5KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsWzBdLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgICAgICAgc2NoZW1hVHlwZS5kaXNjcmltaW5hdG9yKGtleSwgdmFsWzBdLmRpc2NyaW1pbmF0b3JzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA8IDEpIHtcbiAgICAgIC8vIFNwZWNpYWwtY2FzZToge30gYWx3YXlzIGludGVycHJldGVkIGFzIE1peGVkIHBhdGggc28gbGVhZiBhdCB0aGlzIG5vZGVcbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5uZXN0ZWRbcHJlZml4LnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoIC0gMSldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGF0aChmdWxsUGF0aCwgdmFsKTsgLy8gbWl4ZWQgdHlwZVxuICAgIH0gZWxzZSBpZiAoIXZhbFt0eXBlS2V5XSB8fCAodHlwZUtleSA9PT0gJ3R5cGUnICYmIGlzUE9KTyh2YWwudHlwZSkgJiYgdmFsLnR5cGUudHlwZSkpIHtcbiAgICAgIC8vIFNwZWNpYWwtY2FzZTogUE9KTyB3aXRoIG5vIGJvbmEtZmlkZSB0eXBlIGtleSAtIGludGVycHJldCBhcyB0cmVlIG9mIGRlZXAgcGF0aHMgc28gcmVjdXJzZVxuICAgICAgLy8gbmVzdGVkIG9iamVjdCBgeyBsYXN0OiB7IG5hbWU6IFN0cmluZyB9IH1gLiBBdm9pZCBmdW5jdGlvbnMgd2l0aCBgLnR5cGVgIHJlOiAjMTA4MDcgYmVjYXVzZVxuICAgICAgLy8gTmVzdEpTIHNvbWV0aW1lcyBhZGRzIGBEYXRlLnR5cGVgLlxuICAgICAgdGhpcy5uZXN0ZWRbZnVsbFBhdGhdID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWRkKHZhbCwgZnVsbFBhdGggKyAnLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBJUyBhIGJvbmEtZmlkZSB0eXBlIGtleSB0aGF0IG1heSBhbHNvIGJlIGEgUE9KT1xuICAgICAgY29uc3QgX3R5cGVEZWYgPSB2YWxbdHlwZUtleV07XG4gICAgICBpZiAoaXNQT0pPKF90eXBlRGVmKSAmJiBPYmplY3Qua2V5cyhfdHlwZURlZikubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBJZiBhIFBPSk8gaXMgdGhlIHZhbHVlIG9mIGEgdHlwZSBrZXksIG1ha2UgaXQgYSBzdWJkb2N1bWVudFxuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgdGhpcy5uZXN0ZWRbcHJlZml4LnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoIC0gMSldID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkU2NoZW1hT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy50eXBlS2V5KSB7XG4gICAgICAgICAgY2hpbGRTY2hlbWFPcHRpb25zLnR5cGVLZXkgPSB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLnR5cGVLZXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvcGFnYXRlICdzdHJpY3QnIG9wdGlvbiB0byBjaGlsZCBzY2hlbWFcbiAgICAgICAgaWYgKHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMuc3RyaWN0ICE9IG51bGwpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMuc3RyaWN0ID0gdGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy5zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMudG9PYmplY3QgIT0gbnVsbCkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy50b09iamVjdCA9IHV0aWxzLm9taXQodGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy50b09iamVjdCwgWyd0cmFuc2Zvcm0nXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMudG9KU09OICE9IG51bGwpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMudG9KU09OID0gdXRpbHMub21pdCh0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLnRvSlNPTiwgWyd0cmFuc2Zvcm0nXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBfc2NoZW1hID0gbmV3IFNjaGVtYShfdHlwZURlZiwgY2hpbGRTY2hlbWFPcHRpb25zKTtcbiAgICAgICAgX3NjaGVtYS4kaW1wbGljaXRseUNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBzY2hlbWFXcmFwcGVkUGF0aCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbCwgeyBbdHlwZUtleV06IF9zY2hlbWEgfSk7XG4gICAgICAgIHRoaXMucGF0aChwcmVmaXggKyBrZXksIHNjaGVtYVdyYXBwZWRQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVpdGhlciB0aGUgdHlwZSBpcyBub24tUE9KTyBvciB3ZSBpbnRlcnByZXQgaXQgYXMgTWl4ZWQgYW55d2F5XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICB0aGlzLm5lc3RlZFtwcmVmaXguc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGggLSAxKV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0aChwcmVmaXggKyBrZXksIHZhbCk7XG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCAmJiAhKHZhbC5pbnN0YW5jZU9mU2NoZW1hKSAmJiB1dGlscy5pc1BPSk8odmFsLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSB0aGlzLnBhdGgocHJlZml4ICsga2V5KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWwuZGlzY3JpbWluYXRvcnMpIHtcbiAgICAgICAgICAgIHNjaGVtYVR5cGUuZGlzY3JpbWluYXRvcihrZXksIHZhbC5kaXNjcmltaW5hdG9yc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBhbGlhc09iaiA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhvYmopLm1hcCgoW2tleV0pID0+IChbcHJlZml4ICsga2V5LCBudWxsXSkpXG4gICk7XG4gIGFsaWFzRmllbGRzKHRoaXMsIGFsaWFzT2JqKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBhbGlhcyBmb3IgYHBhdGhgLiBUaGlzIG1lYW5zIGdldHRpbmcgb3Igc2V0dGluZyB0aGUgYGFsaWFzYFxuICogaXMgZXF1aXZhbGVudCB0byBnZXR0aW5nIG9yIHNldHRpbmcgdGhlIGBwYXRoYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHRveVNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuOiBTdHJpbmcgfSk7XG4gKlxuICogICAgIC8vIE1ha2UgJ25hbWUnIGFuIGFsaWFzIGZvciAnbidcbiAqICAgICB0b3lTY2hlbWEuYWxpYXMoJ24nLCAnbmFtZScpO1xuICpcbiAqICAgICBjb25zdCBUb3kgPSBtb25nb29zZS5tb2RlbCgnVG95JywgdG95U2NoZW1hKTtcbiAqICAgICBjb25zdCB0dXJib01hbiA9IG5ldyBUb3koeyBuOiAnVHVyYm8gTWFuJyB9KTtcbiAqXG4gKiAgICAgdHVyYm9NYW4ubmFtZTsgLy8gJ1R1cmJvIE1hbidcbiAqICAgICB0dXJib01hbi5uOyAvLyAnVHVyYm8gTWFuJ1xuICpcbiAqICAgICB0dXJib01hbi5uYW1lID0gJ1R1cmJvIE1hbiBBY3Rpb24gRmlndXJlJztcbiAqICAgICB0dXJib01hbi5uOyAvLyAnVHVyYm8gTWFuIEFjdGlvbiBGaWd1cmUnXG4gKlxuICogICAgIGF3YWl0IHR1cmJvTWFuLnNhdmUoKTsgLy8gU2F2ZXMgeyBfaWQ6IC4uLiwgbjogJ1R1cmJvIE1hbiBBY3Rpb24gRmlndXJlJyB9XG4gKlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHJlYWwgcGF0aCB0byBhbGlhc1xuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IGFsaWFzIHRoZSBwYXRoKHMpIHRvIHVzZSBhcyBhbiBhbGlhcyBmb3IgYHBhdGhgXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5hbGlhcyA9IGZ1bmN0aW9uIGFsaWFzKHBhdGgsIGFsaWFzKSB7XG4gIGFsaWFzRmllbGRzKHRoaXMsIHsgW3BhdGhdOiBhbGlhcyB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbmRleCBieSBuYW1lIG9yIGluZGV4IHNwZWNpZmljYXRpb24uXG4gKlxuICogcmVtb3ZlSW5kZXggb25seSByZW1vdmVzIGluZGV4ZXMgZnJvbSB5b3VyIHNjaGVtYSBvYmplY3QuIERvZXMgKipub3QqKiBhZmZlY3QgdGhlIGluZGV4ZXNcbiAqIGluIE1vbmdvREIuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBUb3lTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBjb2xvcjogU3RyaW5nLCBwcmljZTogTnVtYmVyIH0pO1xuICpcbiAqICAgICAvLyBBZGQgYSBuZXcgaW5kZXggb24geyBuYW1lLCBjb2xvciB9XG4gKiAgICAgVG95U2NoZW1hLmluZGV4KHsgbmFtZTogMSwgY29sb3I6IDEgfSk7XG4gKlxuICogICAgIC8vIFJlbW92ZSBpbmRleCBvbiB7IG5hbWUsIGNvbG9yIH1cbiAqICAgICAvLyBLZWVwIGluIG1pbmQgdGhhdCBvcmRlciBtYXR0ZXJzISBgcmVtb3ZlSW5kZXgoeyBjb2xvcjogMSwgbmFtZTogMSB9KWAgd29uJ3QgcmVtb3ZlIHRoZSBpbmRleFxuICogICAgIFRveVNjaGVtYS5yZW1vdmVJbmRleCh7IG5hbWU6IDEsIGNvbG9yOiAxIH0pO1xuICpcbiAqICAgICAvLyBBZGQgYW4gaW5kZXggd2l0aCBhIGN1c3RvbSBuYW1lXG4gKiAgICAgVG95U2NoZW1hLmluZGV4KHsgY29sb3I6IDEgfSwgeyBuYW1lOiAnbXkgY3VzdG9tIGluZGV4IG5hbWUnIH0pO1xuICogICAgIC8vIFJlbW92ZSBpbmRleCBieSBuYW1lXG4gKiAgICAgVG95U2NoZW1hLnJlbW92ZUluZGV4KCdteSBjdXN0b20gaW5kZXggbmFtZScpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gaW5kZXggbmFtZSBvciBpbmRleCBzcGVjaWZpY2F0aW9uXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5yZW1vdmVJbmRleCA9IGZ1bmN0aW9uIHJlbW92ZUluZGV4KGluZGV4KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlSW5kZXgoKSB0YWtlcyBvbmx5IDEgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbmRleCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUluZGV4KCkgbWF5IG9ubHkgdGFrZSBlaXRoZXIgYW4gb2JqZWN0IG9yIGEgc3RyaW5nIGFzIGFuIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluZGV4ID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLl9pbmRleGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAodXRpbC5pc0RlZXBTdHJpY3RFcXVhbCh0aGlzLl9pbmRleGVzW2ldWzBdLCBpbmRleCkpIHtcbiAgICAgICAgdGhpcy5faW5kZXhlcy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLl9pbmRleGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAodGhpcy5faW5kZXhlc1tpXVsxXSAhPSBudWxsICYmIHRoaXMuX2luZGV4ZXNbaV1bMV0ubmFtZSA9PT0gaW5kZXgpIHtcbiAgICAgICAgdGhpcy5faW5kZXhlcy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgaW5kZXhlcyBmcm9tIHRoaXMgc2NoZW1hLlxuICpcbiAqIGNsZWFySW5kZXhlcyBvbmx5IHJlbW92ZXMgaW5kZXhlcyBmcm9tIHlvdXIgc2NoZW1hIG9iamVjdC4gRG9lcyAqKm5vdCoqIGFmZmVjdCB0aGUgaW5kZXhlc1xuICogaW4gTW9uZ29EQi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRveVNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGNvbG9yOiBTdHJpbmcsIHByaWNlOiBOdW1iZXIgfSk7XG4gKiAgICAgVG95U2NoZW1hLmluZGV4KHsgbmFtZTogMSB9KTtcbiAqICAgICBUb3lTY2hlbWEuaW5kZXgoeyBjb2xvcjogMSB9KTtcbiAqXG4gKiAgICAgLy8gUmVtb3ZlIGFsbCBpbmRleGVzIG9uIHRoaXMgc2NoZW1hXG4gKiAgICAgVG95U2NoZW1hLmNsZWFySW5kZXhlcygpO1xuICpcbiAqICAgICBUb3lTY2hlbWEuaW5kZXhlcygpOyAvLyBbXVxuICpcbiAqIEByZXR1cm4ge1NjaGVtYX0gdGhlIFNjaGVtYSBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmNsZWFySW5kZXhlcyA9IGZ1bmN0aW9uIGNsZWFySW5kZXhlcygpIHtcbiAgdGhpcy5faW5kZXhlcy5sZW5ndGggPSAwO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNlcnZlZCBkb2N1bWVudCBrZXlzLlxuICpcbiAqIEtleXMgaW4gdGhpcyBvYmplY3QgYXJlIG5hbWVzIHRoYXQgYXJlIHdhcm5lZCBpbiBzY2hlbWEgZGVjbGFyYXRpb25zXG4gKiBiZWNhdXNlIHRoZXkgaGF2ZSB0aGUgcG90ZW50aWFsIHRvIGJyZWFrIE1vbmdvb3NlLyBNb25nb29zZSBwbHVnaW5zIGZ1bmN0aW9uYWxpdHkuIElmIHlvdSBjcmVhdGUgYSBzY2hlbWFcbiAqIHVzaW5nIGBuZXcgU2NoZW1hKClgIHdpdGggb25lIG9mIHRoZXNlIHByb3BlcnR5IG5hbWVzLCBNb25nb29zZSB3aWxsIGxvZyBhIHdhcm5pbmcuXG4gKlxuICogLSBfcG9zdHNcbiAqIC0gX3ByZXNcbiAqIC0gY29sbGVjdGlvblxuICAqIC0gZW1pdFxuICogLSBlcnJvcnNcbiAqIC0gZ2V0XG4gKiAtIGluaXRcbiAqIC0gaXNNb2RpZmllZFxuICogLSBpc05ld1xuICogLSBsaXN0ZW5lcnNcbiAqIC0gbW9kZWxOYW1lXG4gKiAtIG9uXG4gKiAtIG9uY2VcbiAqIC0gcG9wdWxhdGVkXG4gKiAtIHByb3RvdHlwZVxuICogLSByZW1vdmVcbiAqIC0gcmVtb3ZlTGlzdGVuZXJcbiAqIC0gc2F2ZVxuICogLSBzY2hlbWFcbiAqIC0gdG9PYmplY3RcbiAqIC0gdmFsaWRhdGVcbiAqXG4gKiBfTk9URTpfIFVzZSBvZiB0aGVzZSB0ZXJtcyBhcyBtZXRob2QgbmFtZXMgaXMgcGVybWl0dGVkLCBidXQgcGxheSBhdCB5b3VyIG93biByaXNrLCBhcyB0aGV5IG1heSBiZSBleGlzdGluZyBtb25nb29zZSBkb2N1bWVudCBtZXRob2RzIHlvdSBhcmUgc3RvbXBpbmcgb24uXG4gKlxuICogICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKC4uKTtcbiAqICAgICAgc2NoZW1hLm1ldGhvZHMuaW5pdCA9IGZ1bmN0aW9uICgpIHt9IC8vIHBvdGVudGlhbGx5IGJyZWFraW5nXG4gKlxuICogQHByb3BlcnR5IHJlc2VydmVkXG4gKiBAbWVtYmVyT2YgU2NoZW1hXG4gKiBAc3RhdGljXG4gKi9cblxuU2NoZW1hLnJlc2VydmVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblNjaGVtYS5wcm90b3R5cGUucmVzZXJ2ZWQgPSBTY2hlbWEucmVzZXJ2ZWQ7XG5cbmNvbnN0IHJlc2VydmVkID0gU2NoZW1hLnJlc2VydmVkO1xuLy8gQ29yZSBvYmplY3RcbnJlc2VydmVkWydwcm90b3R5cGUnXSA9XG4vLyBFdmVudEVtaXR0ZXJcbnJlc2VydmVkLmVtaXQgPVxucmVzZXJ2ZWQubGlzdGVuZXJzID1cbnJlc2VydmVkLnJlbW92ZUxpc3RlbmVyID1cblxuLy8gZG9jdW1lbnQgcHJvcGVydGllcyBhbmQgZnVuY3Rpb25zXG5yZXNlcnZlZC5jb2xsZWN0aW9uID1cbnJlc2VydmVkLmVycm9ycyA9XG5yZXNlcnZlZC5nZXQgPVxucmVzZXJ2ZWQuaW5pdCA9XG5yZXNlcnZlZC5pc01vZGlmaWVkID1cbnJlc2VydmVkLmlzTmV3ID1cbnJlc2VydmVkLnBvcHVsYXRlZCA9XG5yZXNlcnZlZC5yZW1vdmUgPVxucmVzZXJ2ZWQuc2F2ZSA9XG5yZXNlcnZlZC50b09iamVjdCA9XG5yZXNlcnZlZC52YWxpZGF0ZSA9IDE7XG5yZXNlcnZlZC5jb2xsZWN0aW9uID0gMTtcblxuLyoqXG4gKiBHZXRzL3NldHMgc2NoZW1hIHBhdGhzLlxuICpcbiAqIFNldHMgYSBwYXRoIChpZiBhcml0eSAyKVxuICogR2V0cyBhIHBhdGggKGlmIGFyaXR5IDEpXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpIC8vIHJldHVybnMgYSBTY2hlbWFUeXBlXG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnLCBOdW1iZXIpIC8vIGNoYW5nZXMgdGhlIHNjaGVtYVR5cGUgb2YgYG5hbWVgIHRvIE51bWJlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBuYW1lIG9mIHRoZSBQYXRoIHRvIGdldCAvIHNldFxuICogQHBhcmFtIHtPYmplY3R9IFtvYmpdIFRoZSBUeXBlIHRvIHNldCB0aGUgcGF0aCB0bywgaWYgcHJvdmlkZWQgdGhlIHBhdGggd2lsbCBiZSBTRVQsIG90aGVyd2lzZSB0aGUgcGF0aCB3aWxsIGJlIEdFVFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbihwYXRoLCBvYmopIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXMucGF0aHNbcGF0aF0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aHNbcGF0aF07XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdG8gJy4kJyB0byBjaGVjayBzdWJwYXRocyByZTogZ2gtNjQwNVxuICAgIGNvbnN0IGNsZWFuUGF0aCA9IF9wYXRoVG9Qb3NpdGlvbmFsU3ludGF4KHBhdGgpO1xuICAgIGxldCBzY2hlbWF0eXBlID0gX2dldFBhdGgodGhpcywgcGF0aCwgY2xlYW5QYXRoKTtcbiAgICBpZiAoc2NoZW1hdHlwZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gc2NoZW1hdHlwZTtcbiAgICB9XG5cbiAgICAvLyBMb29rIGZvciBtYXBzXG4gICAgY29uc3QgbWFwUGF0aCA9IGdldE1hcFBhdGgodGhpcywgcGF0aCk7XG4gICAgaWYgKG1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG1hcFBhdGg7XG4gICAgfVxuXG4gICAgLy8gTG9vayBpZiBhIHBhcmVudCBvZiB0aGlzIHBhdGggaXMgbWl4ZWRcbiAgICBzY2hlbWF0eXBlID0gdGhpcy5oYXNNaXhlZFBhcmVudChjbGVhblBhdGgpO1xuICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBzY2hlbWF0eXBlO1xuICAgIH1cblxuICAgIC8vIHN1YnBhdGhzP1xuICAgIHJldHVybiBoYXNOdW1lcmljU3VicGF0aFJlZ2V4LnRlc3QocGF0aClcbiAgICAgID8gZ2V0UG9zaXRpb25hbFBhdGgodGhpcywgcGF0aCwgY2xlYW5QYXRoKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBzb21lIHBhdGggbmFtZXMgY29uZmxpY3Qgd2l0aCBkb2N1bWVudCBtZXRob2RzXG4gIGNvbnN0IGZpcnN0UGllY2VPZlBhdGggPSBwYXRoLnNwbGl0KCcuJylbMF07XG4gIGlmIChyZXNlcnZlZFtmaXJzdFBpZWNlT2ZQYXRoXSAmJiAhdGhpcy5vcHRpb25zLnN1cHByZXNzUmVzZXJ2ZWRLZXlzV2FybmluZykge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBcXGAke2ZpcnN0UGllY2VPZlBhdGh9XFxgIGlzIGEgcmVzZXJ2ZWQgc2NoZW1hIHBhdGhuYW1lIGFuZCBtYXkgYnJlYWsgc29tZSBmdW5jdGlvbmFsaXR5LiBgICtcbiAgICAgICdZb3UgYXJlIGFsbG93ZWQgdG8gdXNlIGl0LCBidXQgdXNlIGF0IHlvdXIgb3duIHJpc2suICcgK1xuICAgICAgJ1RvIGRpc2FibGUgdGhpcyB3YXJuaW5nIHBhc3MgYHN1cHByZXNzUmVzZXJ2ZWRLZXlzV2FybmluZ2AgYXMgYSBzY2hlbWEgb3B0aW9uLic7XG5cbiAgICB1dGlscy53YXJuKGVycm9yTWVzc2FnZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvYmosICdyZWYnKSkge1xuICAgIHZhbGlkYXRlUmVmKG9iai5yZWYsIHBhdGgpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHRoZSB0cmVlXG4gIGNvbnN0IHN1YnBhdGhzID0gcGF0aC5zcGxpdCgvXFwuLyk7XG4gIGNvbnN0IGxhc3QgPSBzdWJwYXRocy5wb3AoKTtcbiAgbGV0IGJyYW5jaCA9IHRoaXMudHJlZTtcbiAgbGV0IGZ1bGxQYXRoID0gJyc7XG5cbiAgZm9yIChjb25zdCBzdWIgb2Ygc3VicGF0aHMpIHtcbiAgICBpZiAodXRpbHMuc3BlY2lhbFByb3BlcnRpZXMuaGFzKHN1YikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBzcGVjaWFsIHByb3BlcnR5IGAnICsgc3ViICsgJ2Agb24gYSBzY2hlbWEnKTtcbiAgICB9XG4gICAgZnVsbFBhdGggPSBmdWxsUGF0aCArPSAoZnVsbFBhdGgubGVuZ3RoID4gMCA/ICcuJyA6ICcnKSArIHN1YjtcbiAgICBpZiAoIWJyYW5jaFtzdWJdKSB7XG4gICAgICB0aGlzLm5lc3RlZFtmdWxsUGF0aF0gPSB0cnVlO1xuICAgICAgYnJhbmNoW3N1Yl0gPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBicmFuY2hbc3ViXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdDYW5ub3Qgc2V0IG5lc3RlZCBwYXRoIGAnICsgcGF0aCArICdgLiAnXG4gICAgICAgICAgKyAnUGFyZW50IHBhdGggYCdcbiAgICAgICAgICArIGZ1bGxQYXRoXG4gICAgICAgICAgKyAnYCBhbHJlYWR5IHNldCB0byB0eXBlICcgKyBicmFuY2hbc3ViXS5uYW1lXG4gICAgICAgICAgKyAnLic7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgYnJhbmNoID0gYnJhbmNoW3N1Yl07XG4gIH1cblxuICBicmFuY2hbbGFzdF0gPSBjbG9uZShvYmopO1xuXG4gIHRoaXMucGF0aHNbcGF0aF0gPSB0aGlzLmludGVycHJldEFzVHlwZShwYXRoLCBvYmosIHRoaXMub3B0aW9ucyk7XG4gIGNvbnN0IHNjaGVtYVR5cGUgPSB0aGlzLnBhdGhzW3BhdGhdO1xuXG4gIGlmIChzY2hlbWFUeXBlLiRpc1NjaGVtYU1hcCkge1xuICAgIC8vIE1hcHMgY2FuIGhhdmUgYXJiaXRyYXJ5IGtleXMsIHNvIGAkKmAgaXMgaW50ZXJuYWwgc2hvcnRoYW5kIGZvciBcImFueSBrZXlcIlxuICAgIC8vIFRoZSAnJCcgaXMgdG8gaW1wbHkgdGhpcyBwYXRoIHNob3VsZCBuZXZlciBiZSBzdG9yZWQgaW4gTW9uZ29EQiBzbyB3ZVxuICAgIC8vIGNhbiBlYXNpbHkgYnVpbGQgYSByZWdleHAgb3V0IG9mIHRoaXMgcGF0aCwgYW5kICcqJyB0byBpbXBseSBcImFueSBrZXkuXCJcbiAgICBjb25zdCBtYXBQYXRoID0gcGF0aCArICcuJConO1xuXG4gICAgdGhpcy5wYXRoc1ttYXBQYXRoXSA9IHNjaGVtYVR5cGUuJF9fc2NoZW1hVHlwZTtcbiAgICB0aGlzLm1hcFBhdGhzLnB1c2godGhpcy5wYXRoc1ttYXBQYXRoXSk7XG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5wYXRocykpIHtcbiAgICAgIHRoaXMuc2luZ2xlTmVzdGVkUGF0aHNbcGF0aCArICcuJyArIGtleV0gPSBzY2hlbWFUeXBlLnNjaGVtYS5wYXRoc1trZXldO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRocykpIHtcbiAgICAgIHRoaXMuc2luZ2xlTmVzdGVkUGF0aHNbcGF0aCArICcuJyArIGtleV0gPVxuICAgICAgICBzY2hlbWFUeXBlLnNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRoc1trZXldO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5zdWJwYXRocykpIHtcbiAgICAgIHRoaXMuc2luZ2xlTmVzdGVkUGF0aHNbcGF0aCArICcuJyArIGtleV0gPVxuICAgICAgICBzY2hlbWFUeXBlLnNjaGVtYS5zdWJwYXRoc1trZXldO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5uZXN0ZWQpKSB7XG4gICAgICB0aGlzLnNpbmdsZU5lc3RlZFBhdGhzW3BhdGggKyAnLicgKyBrZXldID0gJ25lc3RlZCc7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjaGVtYVR5cGUuc2NoZW1hLCAnYmFzZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHRoaXMuYmFzZVxuICAgIH0pO1xuXG4gICAgc2NoZW1hVHlwZS5jYXN0ZXIuYmFzZSA9IHRoaXMuYmFzZTtcbiAgICB0aGlzLmNoaWxkU2NoZW1hcy5wdXNoKHtcbiAgICAgIHNjaGVtYTogc2NoZW1hVHlwZS5zY2hlbWEsXG4gICAgICBtb2RlbDogc2NoZW1hVHlwZS5jYXN0ZXJcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY2hlbWFUeXBlLnNjaGVtYSwgJ2Jhc2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB0aGlzLmJhc2VcbiAgICB9KTtcblxuICAgIHNjaGVtYVR5cGUuY2FzdGVyQ29uc3RydWN0b3IuYmFzZSA9IHRoaXMuYmFzZTtcbiAgICB0aGlzLmNoaWxkU2NoZW1hcy5wdXNoKHtcbiAgICAgIHNjaGVtYTogc2NoZW1hVHlwZS5zY2hlbWEsXG4gICAgICBtb2RlbDogc2NoZW1hVHlwZS5jYXN0ZXJDb25zdHJ1Y3RvclxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJiBzY2hlbWFUeXBlLmNhc3RlciBpbnN0YW5jZW9mIFNjaGVtYVR5cGUpIHtcbiAgICBsZXQgYXJyYXlQYXRoID0gcGF0aDtcbiAgICBsZXQgX3NjaGVtYVR5cGUgPSBzY2hlbWFUeXBlO1xuXG4gICAgY29uc3QgdG9BZGQgPSBbXTtcbiAgICB3aGlsZSAoX3NjaGVtYVR5cGUuJGlzTW9uZ29vc2VBcnJheSkge1xuICAgICAgYXJyYXlQYXRoID0gYXJyYXlQYXRoICsgJy4kJztcblxuICAgICAgLy8gU2tpcCBhcnJheXMgb2YgZG9jdW1lbnQgYXJyYXlzXG4gICAgICBpZiAoX3NjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgIF9zY2hlbWFUeXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUuX2FycmF5UGF0aCA9IGFycmF5UGF0aDtcbiAgICAgICAgX3NjaGVtYVR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS5fYXJyYXlQYXJlbnRQYXRoID0gcGF0aDtcbiAgICAgICAgX3NjaGVtYVR5cGUgPSBfc2NoZW1hVHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3NjaGVtYVR5cGUuY2FzdGVyLl9hcnJheVBhdGggPSBhcnJheVBhdGg7XG4gICAgICAgIF9zY2hlbWFUeXBlLmNhc3Rlci5fYXJyYXlQYXJlbnRQYXRoID0gcGF0aDtcbiAgICAgICAgX3NjaGVtYVR5cGUgPSBfc2NoZW1hVHlwZS5jYXN0ZXI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3VicGF0aHNbYXJyYXlQYXRoXSA9IF9zY2hlbWFUeXBlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgX3NjaGVtYVR5cGUgb2YgdG9BZGQpIHtcbiAgICAgIHRoaXMuc3VicGF0aHNbX3NjaGVtYVR5cGUucGF0aF0gPSBfc2NoZW1hVHlwZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5wYXRocykpIHtcbiAgICAgIGNvbnN0IF9zY2hlbWFUeXBlID0gc2NoZW1hVHlwZS5zY2hlbWEucGF0aHNba2V5XTtcbiAgICAgIHRoaXMuc3VicGF0aHNbcGF0aCArICcuJyArIGtleV0gPSBfc2NoZW1hVHlwZTtcbiAgICAgIGlmICh0eXBlb2YgX3NjaGVtYVR5cGUgPT09ICdvYmplY3QnICYmIF9zY2hlbWFUeXBlICE9IG51bGwgJiYgX3NjaGVtYVR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5ID09IG51bGwpIHtcbiAgICAgICAgX3NjaGVtYVR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gc2NoZW1hVHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEuc3VicGF0aHMpKSB7XG4gICAgICBjb25zdCBfc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGUuc2NoZW1hLnN1YnBhdGhzW2tleV07XG4gICAgICB0aGlzLnN1YnBhdGhzW3BhdGggKyAnLicgKyBrZXldID0gX3NjaGVtYVR5cGU7XG4gICAgICBpZiAodHlwZW9mIF9zY2hlbWFUeXBlID09PSAnb2JqZWN0JyAmJiBfc2NoZW1hVHlwZSAhPSBudWxsICYmIF9zY2hlbWFUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9PSBudWxsKSB7XG4gICAgICAgIF9zY2hlbWFUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IHNjaGVtYVR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzKSkge1xuICAgICAgY29uc3QgX3NjaGVtYVR5cGUgPSBzY2hlbWFUeXBlLnNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRoc1trZXldO1xuICAgICAgdGhpcy5zdWJwYXRoc1twYXRoICsgJy4nICsga2V5XSA9IF9zY2hlbWFUeXBlO1xuICAgICAgaWYgKHR5cGVvZiBfc2NoZW1hVHlwZSA9PT0gJ29iamVjdCcgJiYgX3NjaGVtYVR5cGUgIT0gbnVsbCAmJiBfc2NoZW1hVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPT0gbnVsbCkge1xuICAgICAgICBfc2NoZW1hVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPSBzY2hlbWFUeXBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBnYXRoZXJDaGlsZFNjaGVtYXMoc2NoZW1hKSB7XG4gIGNvbnN0IGNoaWxkU2NoZW1hcyA9IFtdO1xuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpKSB7XG4gICAgY29uc3Qgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoc1twYXRoXTtcbiAgICBpZiAoc2NoZW1hdHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgfHwgc2NoZW1hdHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIGNoaWxkU2NoZW1hcy5wdXNoKHsgc2NoZW1hOiBzY2hlbWF0eXBlLnNjaGVtYSwgbW9kZWw6IHNjaGVtYXR5cGUuY2FzdGVyIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZFNjaGVtYXM7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2dldFBhdGgoc2NoZW1hLCBwYXRoLCBjbGVhblBhdGgpIHtcbiAgaWYgKHNjaGVtYS5wYXRocy5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgIHJldHVybiBzY2hlbWEucGF0aHNbcGF0aF07XG4gIH1cbiAgaWYgKHNjaGVtYS5zdWJwYXRocy5oYXNPd25Qcm9wZXJ0eShjbGVhblBhdGgpKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5zdWJwYXRoc1tjbGVhblBhdGhdO1xuICB9XG4gIGlmIChzY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHMuaGFzT3duUHJvcGVydHkoY2xlYW5QYXRoKSAmJiB0eXBlb2Ygc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzW2NsZWFuUGF0aF0gPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRoc1tjbGVhblBhdGhdO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3BhdGhUb1Bvc2l0aW9uYWxTeW50YXgocGF0aCkge1xuICBpZiAoIS9cXC5cXGQrLy50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwuXFxkK1xcLi9nLCAnLiQuJykucmVwbGFjZSgvXFwuXFxkKyQvLCAnLiQnKTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBnZXRNYXBQYXRoKHNjaGVtYSwgcGF0aCkge1xuICBpZiAoc2NoZW1hLm1hcFBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZvciAoY29uc3QgdmFsIG9mIHNjaGVtYS5tYXBQYXRocykge1xuICAgIGNvbnN0IF9wYXRoID0gdmFsLnBhdGg7XG4gICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKCdeJyArIF9wYXRoLnJlcGxhY2UoL1xcLlxcJFxcKi9nLCAnXFxcXC5bXi5dKycpICsgJyQnKTtcbiAgICBpZiAocmUudGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuIHNjaGVtYS5wYXRoc1tfcGF0aF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIGluc3RhbmNlIHRoaXMgc2NoZW1hIGlzIGFzc29jaWF0ZWQgd2l0aFxuICpcbiAqIEBwcm9wZXJ0eSBiYXNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hLnByb3RvdHlwZSwgJ2Jhc2UnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZTogbnVsbFxufSk7XG5cbi8qKlxuICogQ29udmVydHMgdHlwZSBhcmd1bWVudHMgaW50byBNb25nb29zZSBUeXBlcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUuaW50ZXJwcmV0QXNUeXBlID0gZnVuY3Rpb24ocGF0aCwgb2JqLCBvcHRpb25zKSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBTY2hlbWFUeXBlKSB7XG4gICAgaWYgKG9iai5wYXRoID09PSBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBjb25zdCBjbG9uZSA9IG9iai5jbG9uZSgpO1xuICAgIGNsb25lLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIC8vIElmIHRoaXMgc2NoZW1hIGhhcyBhbiBhc3NvY2lhdGVkIE1vbmdvb3NlIG9iamVjdCwgdXNlIHRoZSBNb25nb29zZSBvYmplY3Qnc1xuICAvLyBjb3B5IG9mIFNjaGVtYVR5cGVzIHJlOiBnaC03MTU4IGdoLTY5MzNcbiAgY29uc3QgTW9uZ29vc2VUeXBlcyA9IHRoaXMuYmFzZSAhPSBudWxsID8gdGhpcy5iYXNlLlNjaGVtYS5UeXBlcyA6IFNjaGVtYS5UeXBlcztcbiAgY29uc3QgVHlwZXMgPSB0aGlzLmJhc2UgIT0gbnVsbCA/IHRoaXMuYmFzZS5UeXBlcyA6IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxuICBpZiAoIXV0aWxzLmlzUE9KTyhvYmopICYmICEob2JqIGluc3RhbmNlb2YgU2NoZW1hVHlwZU9wdGlvbnMpKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JOYW1lID0gdXRpbHMuZ2V0RnVuY3Rpb25OYW1lKG9iai5jb25zdHJ1Y3Rvcik7XG4gICAgaWYgKGNvbnN0cnVjdG9yTmFtZSAhPT0gJ09iamVjdCcpIHtcbiAgICAgIGNvbnN0IG9sZE9iaiA9IG9iajtcbiAgICAgIG9iaiA9IHt9O1xuICAgICAgb2JqW29wdGlvbnMudHlwZUtleV0gPSBvbGRPYmo7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHRoZSB0eXBlIG1ha2luZyBzdXJlIHRvIGFsbG93IGtleXMgbmFtZWQgXCJ0eXBlXCJcbiAgLy8gYW5kIGRlZmF1bHQgdG8gbWl4ZWQgaWYgbm90IHNwZWNpZmllZC5cbiAgLy8geyB0eXBlOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ2ZyZXNoY3V0JyB9IH1cbiAgbGV0IHR5cGUgPSBvYmpbb3B0aW9ucy50eXBlS2V5XSAmJiAob2JqW29wdGlvbnMudHlwZUtleV0gaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBvcHRpb25zLnR5cGVLZXkgIT09ICd0eXBlJyB8fCAhb2JqLnR5cGUudHlwZSlcbiAgICA/IG9ialtvcHRpb25zLnR5cGVLZXldXG4gICAgOiB7fTtcbiAgbGV0IG5hbWU7XG5cbiAgaWYgKHV0aWxzLmlzUE9KTyh0eXBlKSB8fCB0eXBlID09PSAnbWl4ZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLk1peGVkKHBhdGgsIG9iaik7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSB8fCB0eXBlID09PSBBcnJheSB8fCB0eXBlID09PSAnYXJyYXknIHx8IHR5cGUgPT09IE1vbmdvb3NlVHlwZXMuQXJyYXkpIHtcbiAgICAvLyBpZiBpdCB3YXMgc3BlY2lmaWVkIHRocm91Z2ggeyB0eXBlIH0gbG9vayBmb3IgYGNhc3RgXG4gICAgbGV0IGNhc3QgPSAodHlwZSA9PT0gQXJyYXkgfHwgdHlwZSA9PT0gJ2FycmF5JylcbiAgICAgID8gb2JqLmNhc3QgfHwgb2JqLm9mXG4gICAgICA6IHR5cGVbMF07XG5cbiAgICAvLyBuZXcgU2NoZW1hKHsgcGF0aDogW25ldyBTY2hlbWEoeyAuLi4gfSldIH0pXG4gICAgaWYgKGNhc3QgJiYgY2FzdC5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICBpZiAoIShjYXN0IGluc3RhbmNlb2YgU2NoZW1hKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLl9pc01lcmdpbmcpIHtcbiAgICAgICAgICBjYXN0ID0gbmV3IFNjaGVtYShjYXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTY2hlbWEgZm9yIGFycmF5IHBhdGggYCcgKyBwYXRoICtcbiAgICAgICAgICAgICdgIGlzIGZyb20gYSBkaWZmZXJlbnQgY29weSBvZiB0aGUgTW9uZ29vc2UgbW9kdWxlLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgbWFrZSBzdXJlIHlvdVxcJ3JlIHVzaW5nIHRoZSBzYW1lIHZlcnNpb24gJyArXG4gICAgICAgICAgICAnb2YgTW9uZ29vc2UgZXZlcnl3aGVyZSB3aXRoIGBucG0gbGlzdCBtb25nb29zZWAuIElmIHlvdSBhcmUgc3RpbGwgJyArXG4gICAgICAgICAgICAnZ2V0dGluZyB0aGlzIGVycm9yLCBwbGVhc2UgYWRkIGBuZXcgU2NoZW1hKClgIGFyb3VuZCB0aGUgcGF0aDogJyArXG4gICAgICAgICAgICBgJHtwYXRofTogbmV3IFNjaGVtYSguLi4pYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTW9uZ29vc2VUeXBlcy5Eb2N1bWVudEFycmF5KHBhdGgsIGNhc3QsIG9iaik7XG4gICAgfVxuICAgIGlmIChjYXN0ICYmXG4gICAgICAgIGNhc3Rbb3B0aW9ucy50eXBlS2V5XSAmJlxuICAgICAgICBjYXN0W29wdGlvbnMudHlwZUtleV0uaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgICAgaWYgKCEoY2FzdFtvcHRpb25zLnR5cGVLZXldIGluc3RhbmNlb2YgU2NoZW1hKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLl9pc01lcmdpbmcpIHtcbiAgICAgICAgICBjYXN0W29wdGlvbnMudHlwZUtleV0gPSBuZXcgU2NoZW1hKGNhc3Rbb3B0aW9ucy50eXBlS2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2NoZW1hIGZvciBhcnJheSBwYXRoIGAnICsgcGF0aCArXG4gICAgICAgICAgICAnYCBpcyBmcm9tIGEgZGlmZmVyZW50IGNvcHkgb2YgdGhlIE1vbmdvb3NlIG1vZHVsZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIG1ha2Ugc3VyZSB5b3VcXCdyZSB1c2luZyB0aGUgc2FtZSB2ZXJzaW9uICcgK1xuICAgICAgICAgICAgJ29mIE1vbmdvb3NlIGV2ZXJ5d2hlcmUgd2l0aCBgbnBtIGxpc3QgbW9uZ29vc2VgLiBJZiB5b3UgYXJlIHN0aWxsICcgK1xuICAgICAgICAgICAgJ2dldHRpbmcgdGhpcyBlcnJvciwgcGxlYXNlIGFkZCBgbmV3IFNjaGVtYSgpYCBhcm91bmQgdGhlIHBhdGg6ICcgK1xuICAgICAgICAgICAgYCR7cGF0aH06IG5ldyBTY2hlbWEoLi4uKWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE1vbmdvb3NlVHlwZXMuRG9jdW1lbnRBcnJheShwYXRoLCBjYXN0W29wdGlvbnMudHlwZUtleV0sIG9iaiwgY2FzdCk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2FzdCkpIHtcbiAgICAgIHJldHVybiBuZXcgTW9uZ29vc2VUeXBlcy5BcnJheShwYXRoLCB0aGlzLmludGVycHJldEFzVHlwZShwYXRoLCBjYXN0LCBvcHRpb25zKSwgb2JqKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYm90aCBgbmV3IFNjaGVtYSh7IGFycjogW3sgc3VicGF0aDogU3RyaW5nIH1dIH0pYCBhbmQgYG5ldyBTY2hlbWEoeyBhcnI6IFt7IHR5cGU6IHsgc3VicGF0aDogc3RyaW5nIH0gfV0gfSlgXG4gICAgY29uc3QgY2FzdEZyb21UeXBlS2V5ID0gKGNhc3QgIT0gbnVsbCAmJiBjYXN0W29wdGlvbnMudHlwZUtleV0gJiYgKG9wdGlvbnMudHlwZUtleSAhPT0gJ3R5cGUnIHx8ICFjYXN0LnR5cGUudHlwZSkpID9cbiAgICAgIGNhc3Rbb3B0aW9ucy50eXBlS2V5XSA6XG4gICAgICBjYXN0O1xuICAgIGlmICh0eXBlb2YgY2FzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNhc3QgPSBNb25nb29zZVR5cGVzW2Nhc3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYXN0LnN1YnN0cmluZygxKV07XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BPSk8oY2FzdEZyb21UeXBlS2V5KSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGNhc3RGcm9tVHlwZUtleSkubGVuZ3RoKSB7XG4gICAgICAgIC8vIFRoZSBgbWluaW1pemVgIGFuZCBgdHlwZUtleWAgb3B0aW9ucyBwcm9wYWdhdGUgdG8gY2hpbGQgc2NoZW1hc1xuICAgICAgICAvLyBkZWNsYXJlZCBpbmxpbmUsIGxpa2UgYHsgYXJyOiBbeyB2YWw6IHsgJHR5cGU6IFN0cmluZyB9IH1dIH1gLlxuICAgICAgICAvLyBTZWUgZ2gtMzU2MFxuICAgICAgICBjb25zdCBjaGlsZFNjaGVtYU9wdGlvbnMgPSB7IG1pbmltaXplOiBvcHRpb25zLm1pbmltaXplIH07XG4gICAgICAgIGlmIChvcHRpb25zLnR5cGVLZXkpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMudHlwZUtleSA9IG9wdGlvbnMudHlwZUtleTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9wYWdhdGUgJ3N0cmljdCcgb3B0aW9uIHRvIGNoaWxkIHNjaGVtYVxuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc3RyaWN0JykpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMuc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3N0cmljdFF1ZXJ5JykpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMuc3RyaWN0UXVlcnkgPSBvcHRpb25zLnN0cmljdFF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCd0b09iamVjdCcpKSB7XG4gICAgICAgICAgY2hpbGRTY2hlbWFPcHRpb25zLnRvT2JqZWN0ID0gdXRpbHMub21pdChvcHRpb25zLnRvT2JqZWN0LCBbJ3RyYW5zZm9ybSddKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgndG9KU09OJykpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMudG9KU09OID0gdXRpbHMub21pdChvcHRpb25zLnRvSlNPTiwgWyd0cmFuc2Zvcm0nXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnX2lkJykpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMuX2lkID0gdGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy5faWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoU2NoZW1hLlR5cGVzLkRvY3VtZW50QXJyYXkuZGVmYXVsdE9wdGlvbnMuX2lkICE9IG51bGwpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMuX2lkID0gU2NoZW1hLlR5cGVzLkRvY3VtZW50QXJyYXkuZGVmYXVsdE9wdGlvbnMuX2lkO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2hpbGRTY2hlbWEgPSBuZXcgU2NoZW1hKGNhc3RGcm9tVHlwZUtleSwgY2hpbGRTY2hlbWFPcHRpb25zKTtcbiAgICAgICAgY2hpbGRTY2hlbWEuJGltcGxpY2l0bHlDcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLkRvY3VtZW50QXJyYXkocGF0aCwgY2hpbGRTY2hlbWEsIG9iaik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IGVtcHR5IG9iamVjdCBiZWNvbWVzIG1peGVkXG4gICAgICAgIHJldHVybiBuZXcgTW9uZ29vc2VUeXBlcy5BcnJheShwYXRoLCBNb25nb29zZVR5cGVzLk1peGVkLCBvYmopO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYXN0KSB7XG4gICAgICB0eXBlID0gY2FzdFtvcHRpb25zLnR5cGVLZXldICYmIChvcHRpb25zLnR5cGVLZXkgIT09ICd0eXBlJyB8fCAhY2FzdC50eXBlLnR5cGUpXG4gICAgICAgID8gY2FzdFtvcHRpb25zLnR5cGVLZXldXG4gICAgICAgIDogY2FzdDtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLkFycmF5KHBhdGgsIHRoaXMuaW50ZXJwcmV0QXNUeXBlKHBhdGgsIHR5cGUsIG9wdGlvbnMpLCBvYmopO1xuICAgICAgfVxuXG4gICAgICBuYW1lID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gdHlwZVxuICAgICAgICA6IHR5cGUuc2NoZW1hTmFtZSB8fCB1dGlscy5nZXRGdW5jdGlvbk5hbWUodHlwZSk7XG5cbiAgICAgIC8vIEZvciBKZXN0IDI2Kywgc2VlICMxMDI5NlxuICAgICAgaWYgKG5hbWUgPT09ICdDbG9ja0RhdGUnKSB7XG4gICAgICAgIG5hbWUgPSAnRGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzY2hlbWEgY29uZmlndXJhdGlvbjogJyArXG4gICAgICAgICAgYENvdWxkIG5vdCBkZXRlcm1pbmUgdGhlIGVtYmVkZGVkIHR5cGUgZm9yIGFycmF5IFxcYCR7cGF0aH1cXGAuIGAgK1xuICAgICAgICAgICdTZWUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjZGVmaW5pdGlvbiBmb3IgbW9yZSBpbmZvIG9uIHN1cHBvcnRlZCBzY2hlbWEgc3ludGF4ZXMuJyk7XG4gICAgICB9XG4gICAgICBpZiAoIU1vbmdvb3NlVHlwZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzY2hlbWEgY29uZmlndXJhdGlvbjogJyArXG4gICAgICAgICAgYFxcYCR7bmFtZX1cXGAgaXMgbm90IGEgdmFsaWQgdHlwZSB3aXRoaW4gdGhlIGFycmF5IFxcYCR7cGF0aH1cXGAuYCArXG4gICAgICAgICAgJ1NlZSBodHRwczovL2JpdC5seS9tb25nb29zZS1zY2hlbWF0eXBlcyBmb3IgYSBsaXN0IG9mIHZhbGlkIHNjaGVtYSB0eXBlcy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1vbmdvb3NlVHlwZXMuQXJyYXkocGF0aCwgY2FzdCB8fCBNb25nb29zZVR5cGVzLk1peGVkLCBvYmosIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLlN1YmRvY3VtZW50KHR5cGUsIHBhdGgsIG9iaik7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHR5cGUpKSB7XG4gICAgbmFtZSA9ICdCdWZmZXInO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIG5hbWUgPSB0eXBlLnNjaGVtYU5hbWUgfHwgdXRpbHMuZ2V0RnVuY3Rpb25OYW1lKHR5cGUpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFR5cGVzLk9iamVjdElkKSB7XG4gICAgbmFtZSA9ICdPYmplY3RJZCc7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVHlwZXMuRGVjaW1hbDEyOCkge1xuICAgIG5hbWUgPSAnRGVjaW1hbDEyOCc7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IHR5cGUgPT0gbnVsbCA/ICcnICsgdHlwZSA6IHR5cGUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIGlmIChuYW1lKSB7XG4gICAgbmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTtcbiAgfVxuICAvLyBTcGVjaWFsIGNhc2UgcmU6IGdoLTcwNDkgYmVjYXVzZSB0aGUgYnNvbiBgT2JqZWN0SURgIGNsYXNzJyBjYXBpdGFsaXphdGlvblxuICAvLyBkb2Vzbid0IGxpbmUgdXAgd2l0aCBNb25nb29zZSdzLlxuICBpZiAobmFtZSA9PT0gJ09iamVjdElEJykge1xuICAgIG5hbWUgPSAnT2JqZWN0SWQnO1xuICB9XG4gIC8vIEZvciBKZXN0IDI2Kywgc2VlICMxMDI5NlxuICBpZiAobmFtZSA9PT0gJ0Nsb2NrRGF0ZScpIHtcbiAgICBuYW1lID0gJ0RhdGUnO1xuICB9XG5cbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2NoZW1hIGNvbmZpZ3VyYXRpb246IFxcYCR7cGF0aH1cXGAgc2NoZW1hdHlwZSBkZWZpbml0aW9uIGlzIGAgK1xuICAgICAgJ2ludmFsaWQuIFNlZSAnICtcbiAgICAgICdodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNkZWZpbml0aW9uIGZvciBtb3JlIGluZm8gb24gc3VwcG9ydGVkIHNjaGVtYSBzeW50YXhlcy4nKTtcbiAgfVxuICBpZiAoTW9uZ29vc2VUeXBlc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBzY2hlbWEgY29uZmlndXJhdGlvbjogXFxgJHtuYW1lfVxcYCBpcyBub3QgYCArXG4gICAgICBgYSB2YWxpZCB0eXBlIGF0IHBhdGggXFxgJHtwYXRofVxcYC4gU2VlIGAgK1xuICAgICAgJ2h0dHBzOi8vYml0Lmx5L21vbmdvb3NlLXNjaGVtYXR5cGVzIGZvciBhIGxpc3Qgb2YgdmFsaWQgc2NoZW1hIHR5cGVzLicpO1xuICB9XG5cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IG5ldyBNb25nb29zZVR5cGVzW25hbWVdKHBhdGgsIG9iaik7XG5cbiAgaWYgKHNjaGVtYVR5cGUuJGlzU2NoZW1hTWFwKSB7XG4gICAgY3JlYXRlTWFwTmVzdGVkU2NoZW1hVHlwZSh0aGlzLCBzY2hlbWFUeXBlLCBwYXRoLCBvYmosIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYVR5cGU7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcE5lc3RlZFNjaGVtYVR5cGUoc2NoZW1hLCBzY2hlbWFUeXBlLCBwYXRoLCBvYmosIG9wdGlvbnMpIHtcbiAgY29uc3QgbWFwUGF0aCA9IHBhdGggKyAnLiQqJztcbiAgbGV0IF9tYXBUeXBlID0geyB0eXBlOiB7fSB9O1xuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvYmosICdvZicpKSB7XG4gICAgY29uc3QgaXNJbmxpbmVTY2hlbWEgPSB1dGlscy5pc1BPSk8ob2JqLm9mKSAmJlxuICAgICAgT2JqZWN0LmtleXMob2JqLm9mKS5sZW5ndGggPiAwICYmXG4gICAgICAhdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvYmoub2YsIHNjaGVtYS5vcHRpb25zLnR5cGVLZXkpO1xuICAgIGlmIChpc0lubGluZVNjaGVtYSkge1xuICAgICAgX21hcFR5cGUgPSB7IFtzY2hlbWEub3B0aW9ucy50eXBlS2V5XTogbmV3IFNjaGVtYShvYmoub2YpIH07XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BPSk8ob2JqLm9mKSkge1xuICAgICAgX21hcFR5cGUgPSBPYmplY3QuYXNzaWduKHt9LCBvYmoub2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfbWFwVHlwZSA9IHsgW3NjaGVtYS5vcHRpb25zLnR5cGVLZXldOiBvYmoub2YgfTtcbiAgICB9XG5cbiAgICBpZiAoX21hcFR5cGVbc2NoZW1hLm9wdGlvbnMudHlwZUtleV0gJiYgX21hcFR5cGVbc2NoZW1hLm9wdGlvbnMudHlwZUtleV0uaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgICAgY29uc3Qgc3ViZG9jdW1lbnRTY2hlbWEgPSBfbWFwVHlwZVtzY2hlbWEub3B0aW9ucy50eXBlS2V5XTtcbiAgICAgIHN1YmRvY3VtZW50U2NoZW1hLmVhY2hQYXRoKChzdWJwYXRoLCB0eXBlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlLm9wdGlvbnMuc2VsZWN0ID09PSB0cnVlIHx8IHR5cGUub3B0aW9ucy5zZWxlY3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCB1c2Ugc2NoZW1hLWxldmVsIHByb2plY3Rpb25zIChgc2VsZWN0OiB0cnVlYCBvciBgc2VsZWN0OiBmYWxzZWApIHdpdGhpbiBtYXBzIGF0IHBhdGggXCInICsgcGF0aCArICcuJyArIHN1YnBhdGggKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkob2JqLCAncmVmJykpIHtcbiAgICAgIF9tYXBUeXBlLnJlZiA9IG9iai5yZWY7XG4gICAgfVxuICB9XG4gIHNjaGVtYVR5cGUuJF9fc2NoZW1hVHlwZSA9IHNjaGVtYS5pbnRlcnByZXRBc1R5cGUobWFwUGF0aCwgX21hcFR5cGUsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRoZSBzY2hlbWFzIHBhdGhzIHNpbWlsYXIgdG8gQXJyYXkjZm9yRWFjaC5cbiAqXG4gKiBUaGUgY2FsbGJhY2sgaXMgcGFzc2VkIHRoZSBwYXRobmFtZSBhbmQgdGhlIHNjaGVtYVR5cGUgaW5zdGFuY2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB1c2VyU2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZywgcmVnaXN0ZXJlZEF0OiBEYXRlIH0pO1xuICogICAgIHVzZXJTY2hlbWEuZWFjaFBhdGgoKHBhdGhuYW1lLCBzY2hlbWF0eXBlKSA9PiB7XG4gKiAgICAgICAvLyBQcmludHMgdHdpY2U6XG4gKiAgICAgICAvLyBuYW1lIFNjaGVtYVN0cmluZyB7IC4uLiB9XG4gKiAgICAgICAvLyByZWdpc3RlcmVkQXQgU2NoZW1hRGF0ZSB7IC4uLiB9XG4gKiAgICAgICBjb25zb2xlLmxvZyhwYXRobmFtZSwgc2NoZW1hdHlwZSk7XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm4ge1NjaGVtYX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmVhY2hQYXRoID0gZnVuY3Rpb24oZm4pIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMucGF0aHMpO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgZm4oa2V5c1tpXSwgdGhpcy5wYXRoc1trZXlzW2ldXSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBBcnJheSBvZiBwYXRoIHN0cmluZ3MgdGhhdCBhcmUgcmVxdWlyZWQgYnkgdGhpcyBzY2hlbWEuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSxcbiAqICAgICAgIGFnZTogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gKiAgICAgICBub3RlczogU3RyaW5nXG4gKiAgICAgfSk7XG4gKiAgICAgcy5yZXF1aXJlZFBhdGhzKCk7IC8vIFsgJ2FnZScsICduYW1lJyBdXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW52YWxpZGF0ZSBSZWZyZXNoIHRoZSBjYWNoZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5yZXF1aXJlZFBhdGhzID0gZnVuY3Rpb24gcmVxdWlyZWRQYXRocyhpbnZhbGlkYXRlKSB7XG4gIGlmICh0aGlzLl9yZXF1aXJlZHBhdGhzICYmICFpbnZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVpcmVkcGF0aHM7XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHRoaXMucGF0aHMpO1xuICBsZXQgaSA9IHBhdGhzLmxlbmd0aDtcbiAgY29uc3QgcmV0ID0gW107XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGNvbnN0IHBhdGggPSBwYXRoc1tpXTtcbiAgICBpZiAodGhpcy5wYXRoc1twYXRoXS5pc1JlcXVpcmVkKSB7XG4gICAgICByZXQucHVzaChwYXRoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fcmVxdWlyZWRwYXRocyA9IHJldDtcbiAgcmV0dXJuIHRoaXMuX3JlcXVpcmVkcGF0aHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgaW5kZXhlcyBmcm9tIGZpZWxkcyBhbmQgc2NoZW1hLWxldmVsIGluZGV4ZXMgKGNhY2hlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmluZGV4ZWRQYXRocyA9IGZ1bmN0aW9uIGluZGV4ZWRQYXRocygpIHtcbiAgaWYgKHRoaXMuX2luZGV4ZWRwYXRocykge1xuICAgIHJldHVybiB0aGlzLl9pbmRleGVkcGF0aHM7XG4gIH1cbiAgdGhpcy5faW5kZXhlZHBhdGhzID0gdGhpcy5pbmRleGVzKCk7XG4gIHJldHVybiB0aGlzLl9pbmRleGVkcGF0aHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhdGhUeXBlIG9mIGBwYXRoYCBmb3IgdGhpcyBzY2hlbWEuXG4gKlxuICogR2l2ZW4gYSBwYXRoLCByZXR1cm5zIHdoZXRoZXIgaXQgaXMgYSByZWFsLCB2aXJ0dWFsLCBuZXN0ZWQsIG9yIGFkLWhvYy91bmRlZmluZWQgcGF0aC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBuZXN0ZWQ6IHsgZm9vOiBTdHJpbmcgfSB9KTtcbiAqICAgICBzLnZpcnR1YWwoJ2ZvbycpLmdldCgoKSA9PiA0Mik7XG4gKiAgICAgcy5wYXRoVHlwZSgnbmFtZScpOyAvLyBcInJlYWxcIlxuICogICAgIHMucGF0aFR5cGUoJ25lc3RlZCcpOyAvLyBcIm5lc3RlZFwiXG4gKiAgICAgcy5wYXRoVHlwZSgnZm9vJyk7IC8vIFwidmlydHVhbFwiXG4gKiAgICAgcy5wYXRoVHlwZSgnZmFpbCcpOyAvLyBcImFkaG9jT3JVbmRlZmluZWRcIlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUucGF0aFR5cGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICh0aGlzLnBhdGhzLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgcmV0dXJuICdyZWFsJztcbiAgfVxuICBpZiAodGhpcy52aXJ0dWFscy5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgIHJldHVybiAndmlydHVhbCc7XG4gIH1cbiAgaWYgKHRoaXMubmVzdGVkLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgcmV0dXJuICduZXN0ZWQnO1xuICB9XG5cbiAgLy8gQ29udmVydCB0byAnLiQnIHRvIGNoZWNrIHN1YnBhdGhzIHJlOiBnaC02NDA1XG4gIGNvbnN0IGNsZWFuUGF0aCA9IF9wYXRoVG9Qb3NpdGlvbmFsU3ludGF4KHBhdGgpO1xuXG4gIGlmICh0aGlzLnN1YnBhdGhzLmhhc093blByb3BlcnR5KGNsZWFuUGF0aCkgfHwgdGhpcy5zdWJwYXRocy5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgIHJldHVybiAncmVhbCc7XG4gIH1cblxuICBjb25zdCBzaW5nbGVOZXN0ZWRQYXRoID0gdGhpcy5zaW5nbGVOZXN0ZWRQYXRocy5oYXNPd25Qcm9wZXJ0eShjbGVhblBhdGgpIHx8IHRoaXMuc2luZ2xlTmVzdGVkUGF0aHMuaGFzT3duUHJvcGVydHkocGF0aCk7XG4gIGlmIChzaW5nbGVOZXN0ZWRQYXRoKSB7XG4gICAgcmV0dXJuIHNpbmdsZU5lc3RlZFBhdGggPT09ICduZXN0ZWQnID8gJ25lc3RlZCcgOiAncmVhbCc7XG4gIH1cblxuICAvLyBMb29rIGZvciBtYXBzXG4gIGNvbnN0IG1hcFBhdGggPSBnZXRNYXBQYXRoKHRoaXMsIHBhdGgpO1xuICBpZiAobWFwUGF0aCAhPSBudWxsKSB7XG4gICAgcmV0dXJuICdyZWFsJztcbiAgfVxuXG4gIGlmICgvXFwuXFxkK1xcLnxcXC5cXGQrJC8udGVzdChwYXRoKSkge1xuICAgIHJldHVybiBnZXRQb3NpdGlvbmFsUGF0aFR5cGUodGhpcywgcGF0aCwgY2xlYW5QYXRoKTtcbiAgfVxuICByZXR1cm4gJ2FkaG9jT3JVbmRlZmluZWQnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWZmIHRoaXMgcGF0aCBpcyBhIGNoaWxkIG9mIGEgbWl4ZWQgc2NoZW1hLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5oYXNNaXhlZFBhcmVudCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgY29uc3Qgc3VicGF0aHMgPSBwYXRoLnNwbGl0KC9cXC4vZyk7XG4gIHBhdGggPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJwYXRocy5sZW5ndGg7ICsraSkge1xuICAgIHBhdGggPSBpID4gMCA/IHBhdGggKyAnLicgKyBzdWJwYXRoc1tpXSA6IHN1YnBhdGhzW2ldO1xuICAgIGlmICh0aGlzLnBhdGhzLmhhc093blByb3BlcnR5KHBhdGgpICYmXG4gICAgICAgIHRoaXMucGF0aHNbcGF0aF0gaW5zdGFuY2VvZiBNb25nb29zZVR5cGVzLk1peGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoc1twYXRoXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogU2V0dXAgdXBkYXRlZEF0IGFuZCBjcmVhdGVkQXQgdGltZXN0YW1wcyB0byBkb2N1bWVudHMgaWYgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IHRpbWVzdGFtcHMgdGltZXN0YW1wcyBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU2NoZW1hLnByb3RvdHlwZS5zZXR1cFRpbWVzdGFtcCA9IGZ1bmN0aW9uKHRpbWVzdGFtcHMpIHtcbiAgcmV0dXJuIHNldHVwVGltZXN0YW1wcyh0aGlzLCB0aW1lc3RhbXBzKTtcbn07XG5cbi8qKlxuICogaWdub3JlLiBEZXByZWNhdGVkIHJlOiAjNjQwNVxuICogQHBhcmFtIHtBbnl9IHNlbGZcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbmFsUGF0aFR5cGUoc2VsZiwgcGF0aCwgY2xlYW5QYXRoKSB7XG4gIGNvbnN0IHN1YnBhdGhzID0gcGF0aC5zcGxpdCgvXFwuKFxcZCspXFwufFxcLihcXGQrKSQvKS5maWx0ZXIoQm9vbGVhbik7XG4gIGlmIChzdWJwYXRocy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIHNlbGYucGF0aHMuaGFzT3duUHJvcGVydHkoc3VicGF0aHNbMF0pID9cbiAgICAgIHNlbGYucGF0aHNbc3VicGF0aHNbMF1dIDpcbiAgICAgICdhZGhvY09yVW5kZWZpbmVkJztcbiAgfVxuXG4gIGxldCB2YWwgPSBzZWxmLnBhdGgoc3VicGF0aHNbMF0pO1xuICBsZXQgaXNOZXN0ZWQgPSBmYWxzZTtcbiAgaWYgKCF2YWwpIHtcbiAgICByZXR1cm4gJ2FkaG9jT3JVbmRlZmluZWQnO1xuICB9XG5cbiAgY29uc3QgbGFzdCA9IHN1YnBhdGhzLmxlbmd0aCAtIDE7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdWJwYXRocy5sZW5ndGg7ICsraSkge1xuICAgIGlzTmVzdGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3VicGF0aCA9IHN1YnBhdGhzW2ldO1xuXG4gICAgaWYgKGkgPT09IGxhc3QgJiYgdmFsICYmICEvXFxELy50ZXN0KHN1YnBhdGgpKSB7XG4gICAgICBpZiAodmFsLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgICB2YWwgPSB2YWwuJGVtYmVkZGVkU2NoZW1hVHlwZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgTW9uZ29vc2VUeXBlcy5BcnJheSkge1xuICAgICAgICAvLyBTdHJpbmdTY2hlbWEsIE51bWJlclNjaGVtYSwgZXRjXG4gICAgICAgIHZhbCA9IHZhbC5jYXN0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgaWYgaXRzIGp1c3QgYSBwb3NpdGlvbiBzZWdtZW50OiBwYXRoLjAuc3VicGF0aFxuICAgIGlmICghL1xcRC8udGVzdChzdWJwYXRoKSkge1xuICAgICAgLy8gTmVzdGVkIGFycmF5XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgTW9uZ29vc2VUeXBlcy5BcnJheSAmJiBpICE9PSBsYXN0KSB7XG4gICAgICAgIHZhbCA9IHZhbC5jYXN0ZXI7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoISh2YWwgJiYgdmFsLnNjaGVtYSkpIHtcbiAgICAgIHZhbCA9IHVuZGVmaW5lZDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB2YWwuc2NoZW1hLnBhdGhUeXBlKHN1YnBhdGgpO1xuICAgIGlzTmVzdGVkID0gKHR5cGUgPT09ICduZXN0ZWQnKTtcbiAgICB2YWwgPSB2YWwuc2NoZW1hLnBhdGgoc3VicGF0aCk7XG4gIH1cblxuICBzZWxmLnN1YnBhdGhzW2NsZWFuUGF0aF0gPSB2YWw7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gJ3JlYWwnO1xuICB9XG4gIGlmIChpc05lc3RlZCkge1xuICAgIHJldHVybiAnbmVzdGVkJztcbiAgfVxuICByZXR1cm4gJ2FkaG9jT3JVbmRlZmluZWQnO1xufVxuXG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25hbFBhdGgoc2VsZiwgcGF0aCwgY2xlYW5QYXRoKSB7XG4gIGdldFBvc2l0aW9uYWxQYXRoVHlwZShzZWxmLCBwYXRoLCBjbGVhblBhdGgpO1xuICByZXR1cm4gc2VsZi5zdWJwYXRoc1tjbGVhblBhdGhdO1xufVxuXG4vKipcbiAqIEFkZHMgYSBtZXRob2QgY2FsbCB0byB0aGUgcXVldWUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBzY2hlbWEubWV0aG9kcy5wcmludCA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyh0aGlzKTsgfTtcbiAqICAgICBzY2hlbWEucXVldWUoJ3ByaW50JywgW10pOyAvLyBQcmludCB0aGUgZG9jIGV2ZXJ5IG9uZSBpcyBpbnN0YW50aWF0ZWRcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKiAgICAgbmV3IE1vZGVsKHsgbmFtZTogJ3Rlc3QnIH0pOyAvLyBQcmludHMgJ3tcIl9pZFwiOiAuLi4sIFwibmFtZVwiOiBcInRlc3RcIiB9J1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGRvY3VtZW50IG1ldGhvZCB0byBjYWxsIGxhdGVyXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgdGhpcy5jYWxsUXVldWUucHVzaChbbmFtZSwgYXJnc10pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyBhIHByZSBob29rIGZvciB0aGUgbW9kZWwuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB0b3lTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBjcmVhdGVkOiBEYXRlIH0pO1xuICpcbiAqICAgICB0b3lTY2hlbWEucHJlKCdzYXZlJywgZnVuY3Rpb24obmV4dCkge1xuICogICAgICAgaWYgKCF0aGlzLmNyZWF0ZWQpIHRoaXMuY3JlYXRlZCA9IG5ldyBEYXRlO1xuICogICAgICAgbmV4dCgpO1xuICogICAgIH0pO1xuICpcbiAqICAgICB0b3lTY2hlbWEucHJlKCd2YWxpZGF0ZScsIGZ1bmN0aW9uKG5leHQpIHtcbiAqICAgICAgIGlmICh0aGlzLm5hbWUgIT09ICdXb29keScpIHRoaXMubmFtZSA9ICdXb29keSc7XG4gKiAgICAgICBuZXh0KCk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgcHJlKClgIG9uIGBmaW5kYCwgYGZpbmRPbmVgLCBgZmluZE9uZUFuZFVwZGF0ZWAuXG4gKiAgICAgdG95U2NoZW1hLnByZSgvXmZpbmQvLCBmdW5jdGlvbihuZXh0KSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdldEZpbHRlcigpKTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gRXF1aXZhbGVudCB0byBjYWxsaW5nIGBwcmUoKWAgb24gYHVwZGF0ZU9uZWAsIGBmaW5kT25lQW5kVXBkYXRlYC5cbiAqICAgICB0b3lTY2hlbWEucHJlKFsndXBkYXRlT25lJywgJ2ZpbmRPbmVBbmRVcGRhdGUnXSwgZnVuY3Rpb24obmV4dCkge1xuICogICAgICAgY29uc29sZS5sb2codGhpcy5nZXRGaWx0ZXIoKSk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIHRveVNjaGVtYS5wcmUoJ2RlbGV0ZU9uZScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgLy8gUnVucyB3aGVuIHlvdSBjYWxsIGBUb3kuZGVsZXRlT25lKClgXG4gKiAgICAgfSk7XG4gKlxuICogICAgIHRveVNjaGVtYS5wcmUoJ2RlbGV0ZU9uZScsIHsgZG9jdW1lbnQ6IHRydWUgfSwgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAvLyBSdW5zIHdoZW4geW91IGNhbGwgYGRvYy5kZWxldGVPbmUoKWBcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB8U3RyaW5nW119IG1ldGhvZE5hbWUgVGhlIG1ldGhvZCBuYW1lIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBtZXRob2QgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb2N1bWVudF0gSWYgYG5hbWVgIGlzIGEgaG9vayBmb3IgYm90aCBkb2N1bWVudCBhbmQgcXVlcnkgbWlkZGxld2FyZSwgc2V0IHRvIGB0cnVlYCB0byBydW4gb24gZG9jdW1lbnQgbWlkZGxld2FyZS4gRm9yIGV4YW1wbGUsIHNldCBgb3B0aW9ucy5kb2N1bWVudGAgdG8gYHRydWVgIHRvIGFwcGx5IHRoaXMgaG9vayB0byBgRG9jdW1lbnQjZGVsZXRlT25lKClgIHJhdGhlciB0aGFuIGBRdWVyeSNkZWxldGVPbmUoKWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnF1ZXJ5XSBJZiBgbmFtZWAgaXMgYSBob29rIGZvciBib3RoIGRvY3VtZW50IGFuZCBxdWVyeSBtaWRkbGV3YXJlLCBzZXQgdG8gYHRydWVgIHRvIHJ1biBvbiBxdWVyeSBtaWRkbGV3YXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5wcmUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmIChuYW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgY29uc3QgcmVtYWluaW5nQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgZm9yIChjb25zdCBmbiBvZiBob29rTmFtZXMpIHtcbiAgICAgIGlmIChuYW1lLnRlc3QoZm4pKSB7XG4gICAgICAgIHRoaXMucHJlLmFwcGx5KHRoaXMsIFtmbl0uY29uY2F0KHJlbWFpbmluZ0FyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICBjb25zdCByZW1haW5pbmdBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIG5hbWUpIHtcbiAgICAgIHRoaXMucHJlLmFwcGx5KHRoaXMsIFtlbF0uY29uY2F0KHJlbWFpbmluZ0FyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5zLmhvb2tzLnByZS5hcHBseSh0aGlzLnMuaG9va3MsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGEgcG9zdCBob29rIGZvciB0aGUgZG9jdW1lbnRcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSguLik7XG4gKiAgICAgc2NoZW1hLnBvc3QoJ3NhdmUnLCBmdW5jdGlvbiAoZG9jKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygndGhpcyBmaXJlZCBhZnRlciBhIGRvY3VtZW50IHdhcyBzYXZlZCcpO1xuICogICAgIH0pO1xuICpcbiAqICAgICBzY2hlbWEucG9zdCgnZmluZCcsIGZ1bmN0aW9uKGRvY3MpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCd0aGlzIGZpcmVkIGFmdGVyIHlvdSByYW4gYSBmaW5kIHF1ZXJ5Jyk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIHNjaGVtYS5wb3N0KC9NYW55JC8sIGZ1bmN0aW9uKHJlcykge1xuICogICAgICAgY29uc29sZS5sb2coJ3RoaXMgZmlyZWQgYWZ0ZXIgeW91IHJhbiBgdXBkYXRlTWFueSgpYCBvciBgZGVsZXRlTWFueSgpYCcpO1xuICogICAgIH0pO1xuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdNb2RlbCcsIHNjaGVtYSk7XG4gKlxuICogICAgIGNvbnN0IG0gPSBuZXcgTW9kZWwoLi4pO1xuICogICAgIG0uc2F2ZShmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCd0aGlzIGZpcmVzIGFmdGVyIHRoZSBgcG9zdGAgaG9vaycpO1xuICogICAgIH0pO1xuICpcbiAqICAgICBtLmZpbmQoZnVuY3Rpb24oZXJyLCBkb2NzKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygndGhpcyBmaXJlcyBhZnRlciB0aGUgcG9zdCBmaW5kIGhvb2snKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB8U3RyaW5nW119IG1ldGhvZE5hbWUgVGhlIG1ldGhvZCBuYW1lIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBtZXRob2QgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb2N1bWVudF0gSWYgYG5hbWVgIGlzIGEgaG9vayBmb3IgYm90aCBkb2N1bWVudCBhbmQgcXVlcnkgbWlkZGxld2FyZSwgc2V0IHRvIGB0cnVlYCB0byBydW4gb24gZG9jdW1lbnQgbWlkZGxld2FyZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucXVlcnldIElmIGBuYW1lYCBpcyBhIGhvb2sgZm9yIGJvdGggZG9jdW1lbnQgYW5kIHF1ZXJ5IG1pZGRsZXdhcmUsIHNldCB0byBgdHJ1ZWAgdG8gcnVuIG9uIHF1ZXJ5IG1pZGRsZXdhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBjYWxsYmFja1xuICogQHNlZSBtaWRkbGV3YXJlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWxcbiAqIEBzZWUga2FyZWVtIGh0dHBzOi8vbnBtanMub3JnL3BhY2thZ2Uva2FyZWVtXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICBjb25zdCByZW1haW5pbmdBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGhvb2tOYW1lcykge1xuICAgICAgaWYgKG5hbWUudGVzdChmbikpIHtcbiAgICAgICAgdGhpcy5wb3N0LmFwcGx5KHRoaXMsIFtmbl0uY29uY2F0KHJlbWFpbmluZ0FyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICBjb25zdCByZW1haW5pbmdBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIG5hbWUpIHtcbiAgICAgIHRoaXMucG9zdC5hcHBseSh0aGlzLCBbZWxdLmNvbmNhdChyZW1haW5pbmdBcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMucy5ob29rcy5wb3N0LmFwcGx5KHRoaXMucy5ob29rcywgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIHBsdWdpbiBmb3IgdGhpcyBzY2hlbWEuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBzLnBsdWdpbihzY2hlbWEgPT4gY29uc29sZS5sb2coc2NoZW1hLnBhdGgoJ25hbWUnKS5wYXRoKSk7XG4gKiAgICAgbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzKTsgLy8gUHJpbnRzICduYW1lJ1xuICpcbiAqIE9yIHdpdGggT3B0aW9uczpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgcy5wbHVnaW4oKHNjaGVtYSwgb3B0cykgPT4gY29uc29sZS5sb2cob3B0cy50ZXh0LCBzY2hlbWEucGF0aCgnbmFtZScpLnBhdGgpLCB7IHRleHQ6IFwiU2NoZW1hIFBhdGggTmFtZTpcIiB9KTtcbiAqICAgICBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHMpOyAvLyBQcmludHMgJ1NjaGVtYSBQYXRoIE5hbWU6IG5hbWUnXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGx1Z2luIFRoZSBQbHVnaW4ncyBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIHBsdWdpblxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0cy5kZWR1cGxpY2F0ZT1mYWxzZV0gSWYgdHJ1ZSwgaWdub3JlIGR1cGxpY2F0ZSBwbHVnaW5zIChzYW1lIGBmbmAgYXJndW1lbnQgdXNpbmcgYD09PWApXG4gKiBAc2VlIHBsdWdpbnMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BsdWdpbnMuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnBsdWdpbiA9IGZ1bmN0aW9uKGZuLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IHBhcmFtIHRvIGBzY2hlbWEucGx1Z2luKClgIG11c3QgYmUgYSBmdW5jdGlvbiwgJyArXG4gICAgICAnZ290IFwiJyArICh0eXBlb2YgZm4pICsgJ1wiJyk7XG4gIH1cblxuXG4gIGlmIChvcHRzICYmIG9wdHMuZGVkdXBsaWNhdGUpIHtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgIGlmIChwbHVnaW4uZm4gPT09IGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnBsdWdpbnMucHVzaCh7IGZuOiBmbiwgb3B0czogb3B0cyB9KTtcblxuICBmbih0aGlzLCBvcHRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gaW5zdGFuY2UgbWV0aG9kIHRvIGRvY3VtZW50cyBjb25zdHJ1Y3RlZCBmcm9tIE1vZGVscyBjb21waWxlZCBmcm9tIHRoaXMgc2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0ga2l0dHlTY2hlbWEgPSBuZXcgU2NoZW1hKC4uKTtcbiAqXG4gKiAgICAgc2NoZW1hLm1ldGhvZCgnbWVvdycsIGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdtZWVlZWVvb29vb29vb29vb293Jyk7XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgY29uc3QgS2l0dHkgPSBtb25nb29zZS5tb2RlbCgnS2l0dHknLCBzY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBmaXp6ID0gbmV3IEtpdHR5O1xuICogICAgIGZpenoubWVvdygpOyAvLyBtZWVlZWVvb29vb29vb29vb29vd1xuICpcbiAqIElmIGEgaGFzaCBvZiBuYW1lL2ZuIHBhaXJzIGlzIHBhc3NlZCBhcyB0aGUgb25seSBhcmd1bWVudCwgZWFjaCBuYW1lL2ZuIHBhaXIgd2lsbCBiZSBhZGRlZCBhcyBtZXRob2RzLlxuICpcbiAqICAgICBzY2hlbWEubWV0aG9kKHtcbiAqICAgICAgICAgcHVycjogZnVuY3Rpb24gKCkge31cbiAqICAgICAgICwgc2NyYXRjaDogZnVuY3Rpb24gKCkge31cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gbGF0ZXJcbiAqICAgICBjb25zdCBmaXp6ID0gbmV3IEtpdHR5O1xuICogICAgIGZpenoucHVycigpO1xuICogICAgIGZpenouc2NyYXRjaCgpO1xuICpcbiAqIE5PVEU6IGBTY2hlbWEubWV0aG9kKClgIGFkZHMgaW5zdGFuY2UgbWV0aG9kcyB0byB0aGUgYFNjaGVtYS5tZXRob2RzYCBvYmplY3QuIFlvdSBjYW4gYWxzbyBhZGQgaW5zdGFuY2UgbWV0aG9kcyBkaXJlY3RseSB0byB0aGUgYFNjaGVtYS5tZXRob2RzYCBvYmplY3QgYXMgc2VlbiBpbiB0aGUgW2d1aWRlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNtZXRob2RzKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZSBUaGUgTWV0aG9kIE5hbWUgZm9yIGEgc2luZ2xlIGZ1bmN0aW9uLCBvciBhIE9iamVjdCBvZiBcInN0cmluZy1mdW5jdGlvblwiIHBhaXJzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBUaGUgRnVuY3Rpb24gaW4gYSBzaW5nbGUtZnVuY3Rpb24gZGVmaW5pdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbihuYW1lLCBmbiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgZm9yIChjb25zdCBpIGluIG5hbWUpIHtcbiAgICAgIHRoaXMubWV0aG9kc1tpXSA9IG5hbWVbaV07XG4gICAgICB0aGlzLm1ldGhvZE9wdGlvbnNbaV0gPSBjbG9uZShvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXRob2RzW25hbWVdID0gZm47XG4gICAgdGhpcy5tZXRob2RPcHRpb25zW25hbWVdID0gY2xvbmUob3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgc3RhdGljIFwiY2xhc3NcIiBtZXRob2RzIHRvIE1vZGVscyBjb21waWxlZCBmcm9tIHRoaXMgc2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSguLik7XG4gKiAgICAgLy8gRXF1aXZhbGVudCB0byBgc2NoZW1hLnN0YXRpY3MuZmluZEJ5TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHt9YDtcbiAqICAgICBzY2hlbWEuc3RhdGljKCdmaW5kQnlOYW1lJywgZnVuY3Rpb24obmFtZSkge1xuICogICAgICAgcmV0dXJuIHRoaXMuZmluZCh7IG5hbWU6IG5hbWUgfSk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGNvbnN0IERyaW5rID0gbW9uZ29vc2UubW9kZWwoJ0RyaW5rJywgc2NoZW1hKTtcbiAqICAgICBhd2FpdCBEcmluay5maW5kQnlOYW1lKCdMYUNyb2l4Jyk7XG4gKlxuICogSWYgYSBoYXNoIG9mIG5hbWUvZm4gcGFpcnMgaXMgcGFzc2VkIGFzIHRoZSBvbmx5IGFyZ3VtZW50LCBlYWNoIG5hbWUvZm4gcGFpciB3aWxsIGJlIGFkZGVkIGFzIG1ldGhvZHMuXG4gKlxuICogICAgIHNjaGVtYS5zdGF0aWMoe1xuICogICAgICAgICBmaW5kQnlOYW1lOiBmdW5jdGlvbiAoKSB7Li59XG4gKiAgICAgICAsIGZpbmRCeUNvc3Q6IGZ1bmN0aW9uICgpIHsuLn1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgY29uc3QgRHJpbmsgPSBtb25nb29zZS5tb2RlbCgnRHJpbmsnLCBzY2hlbWEpO1xuICogICAgIGF3YWl0IERyaW5rLmZpbmRCeU5hbWUoJ0xhQ3JvaXgnKTtcbiAqICAgICBhd2FpdCBEcmluay5maW5kQnlDb3N0KDMpO1xuICpcbiAqIElmIGEgaGFzaCBvZiBuYW1lL2ZuIHBhaXJzIGlzIHBhc3NlZCBhcyB0aGUgb25seSBhcmd1bWVudCwgZWFjaCBuYW1lL2ZuIHBhaXIgd2lsbCBiZSBhZGRlZCBhcyBzdGF0aWNzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZSBUaGUgTWV0aG9kIE5hbWUgZm9yIGEgc2luZ2xlIGZ1bmN0aW9uLCBvciBhIE9iamVjdCBvZiBcInN0cmluZy1mdW5jdGlvblwiIHBhaXJzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBUaGUgRnVuY3Rpb24gaW4gYSBzaW5nbGUtZnVuY3Rpb24gZGVmaW5pdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIFN0YXRpY3MgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RhdGljc1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuc3RhdGljID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIGZvciAoY29uc3QgaSBpbiBuYW1lKSB7XG4gICAgICB0aGlzLnN0YXRpY3NbaV0gPSBuYW1lW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YXRpY3NbbmFtZV0gPSBmbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyBhbiBpbmRleCAobW9zdCBsaWtlbHkgY29tcG91bmQpIGZvciB0aGlzIHNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHNjaGVtYS5pbmRleCh7IGZpcnN0OiAxLCBsYXN0OiAtMSB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHMgVGhlIEZpZWxkcyB0byBpbmRleCwgd2l0aCB0aGUgb3JkZXIsIGF2YWlsYWJsZSB2YWx1ZXM6IGAxIHwgLTEgfCAnMmQnIHwgJzJkc3BoZXJlJyB8ICdnZW9IYXlzdGFjaycgfCAnaGFzaGVkJyB8ICd0ZXh0J2BcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIFtNb25nb0RCIGRyaXZlcidzIGBjcmVhdGVJbmRleCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNjcmVhdGVJbmRleClcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyfSBbb3B0aW9ucy5leHBpcmVzPW51bGxdIE1vbmdvb3NlLXNwZWNpZmljIHN5bnRhY3RpYyBzdWdhciwgdXNlcyBbbXNdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zKSB0byBjb252ZXJ0IGBleHBpcmVzYCBvcHRpb24gaW50byBzZWNvbmRzIGZvciB0aGUgYGV4cGlyZUFmdGVyU2Vjb25kc2AgaW4gdGhlIGFib3ZlIGxpbmsuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2Vfb3ZlcnJpZGU9bnVsbF0gVGVsbHMgbW9uZ29kYiB0byB1c2UgdGhlIHNwZWNpZmllZCBmaWVsZCBpbnN0ZWFkIG9mIGBsYW5ndWFnZWAgZm9yIHBhcnNpbmcgdGV4dCBpbmRleGVzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oZmllbGRzLCBvcHRpb25zKSB7XG4gIGZpZWxkcyB8fCAoZmllbGRzID0ge30pO1xuICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gIGlmIChvcHRpb25zLmV4cGlyZXMpIHtcbiAgICB1dGlscy5leHBpcmVzKG9wdGlvbnMpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGZpZWxkcykge1xuICAgIGlmICh0aGlzLmFsaWFzZXNba2V5XSkge1xuICAgICAgZmllbGRzW3RoaXMuYWxpYXNlc1trZXldXSA9IGZpZWxkc1trZXldO1xuICAgICAgZGVsZXRlIGZpZWxkc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgIGlmIChmaWVsZHNbZmllbGRdID09PSAnYXNjZW5kaW5nJyB8fCBmaWVsZHNbZmllbGRdID09PSAnYXNjJykge1xuICAgICAgZmllbGRzW2ZpZWxkXSA9IDE7XG4gICAgfSBlbHNlIGlmIChmaWVsZHNbZmllbGRdID09PSAnZGVzY2VuZGluZycgfHwgZmllbGRzW2ZpZWxkXSA9PT0gJ2Rlc2MnKSB7XG4gICAgICBmaWVsZHNbZmllbGRdID0gLTE7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5faW5kZXhlcy5wdXNoKFtmaWVsZHMsIG9wdGlvbnNdKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgYSBzY2hlbWEgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLnNldCgnc3RyaWN0Jyk7IC8vICd0cnVlJyBieSBkZWZhdWx0XG4gKiAgICAgc2NoZW1hLnNldCgnc3RyaWN0JywgZmFsc2UpOyAvLyBTZXRzICdzdHJpY3QnIHRvIGZhbHNlXG4gKiAgICAgc2NoZW1hLnNldCgnc3RyaWN0Jyk7IC8vICdmYWxzZSdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBvcHRpb24gdG8gc2V0IHRoZSB2YWx1ZSB0b1xuICogQHBhcmFtIHtPYmplY3R9IFt2YWx1ZV0gVGhlIHZhbHVlIHRvIHNldCB0aGUgb3B0aW9uIHRvLCBpZiBub3QgcGFzc2VkLCB0aGUgb3B0aW9uIHdpbGwgYmUgcmVzZXQgdG8gZGVmYXVsdFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbdGFnc10gdGFncyB0byBhZGQgdG8gcmVhZCBwcmVmZXJlbmNlIGlmIGtleSA9PT0gJ3JlYWQnXG4gKiBAc2VlIFNjaGVtYSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYS5odG1sI1NjaGVtYSgpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgdGFncykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSAncmVhZCc6XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHsgbW9kZTogaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzKHZhbHVlKSwgdGFncyB9O1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWVbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0ge1xuICAgICAgICAgIG1vZGU6IGhhbmRsZVJlYWRQcmVmZXJlbmNlQWxpYXNlcyh2YWx1ZVswXSksXG4gICAgICAgICAgdGFnczogdmFsdWVbMV1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zW2tleV0gPSB0aGlzLm9wdGlvbnNba2V5XTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RpbWVzdGFtcHMnOlxuICAgICAgdGhpcy5zZXR1cFRpbWVzdGFtcCh2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgdGhpcy5fdXNlclByb3ZpZGVkT3B0aW9uc1trZXldID0gdGhpcy5vcHRpb25zW2tleV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdfaWQnOlxuICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9uc1trZXldO1xuXG4gICAgICBpZiAodmFsdWUgJiYgIXRoaXMucGF0aHNbJ19pZCddKSB7XG4gICAgICAgIGFkZEF1dG9JZCh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMucGF0aHNbJ19pZCddICE9IG51bGwgJiYgdGhpcy5wYXRoc1snX2lkJ10uYXV0bykge1xuICAgICAgICB0aGlzLnJlbW92ZSgnX2lkJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9uc1trZXldO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICAvLyBQcm9wYWdhdGUgYHN0cmljdGAgYW5kIGBzdHJpY3RRdWVyeWAgY2hhbmdlcyBkb3duIHRvIGltcGxpY2l0bHkgY3JlYXRlZCBzY2hlbWFzXG4gIGlmIChrZXkgPT09ICdzdHJpY3QnKSB7XG4gICAgX3Byb3BhZ2F0ZU9wdGlvbnNUb0ltcGxpY2l0bHlDcmVhdGVkU2NoZW1hcyh0aGlzLCB7IHN0cmljdDogdmFsdWUgfSk7XG4gIH1cbiAgaWYgKGtleSA9PT0gJ3N0cmljdFF1ZXJ5Jykge1xuICAgIF9wcm9wYWdhdGVPcHRpb25zVG9JbXBsaWNpdGx5Q3JlYXRlZFNjaGVtYXModGhpcywgeyBzdHJpY3RRdWVyeTogdmFsdWUgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogUmVjdXJzaXZlbHkgc2V0IG9wdGlvbnMgb24gaW1wbGljaXRseSBjcmVhdGVkIHNjaGVtYXNcbiAqL1xuXG5mdW5jdGlvbiBfcHJvcGFnYXRlT3B0aW9uc1RvSW1wbGljaXRseUNyZWF0ZWRTY2hlbWFzKGJhc2VTY2hlbWEsIG9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCB7IHNjaGVtYSB9IG9mIGJhc2VTY2hlbWEuY2hpbGRTY2hlbWFzKSB7XG4gICAgaWYgKCFzY2hlbWEuJGltcGxpY2l0bHlDcmVhdGVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzY2hlbWEub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgX3Byb3BhZ2F0ZU9wdGlvbnNUb0ltcGxpY2l0bHlDcmVhdGVkU2NoZW1hcyhzY2hlbWEsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyBhIHNjaGVtYSBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBzY2hlbWEuZ2V0KCdzdHJpY3QnKTsgLy8gdHJ1ZVxuICogICAgIHNjaGVtYS5zZXQoJ3N0cmljdCcsIGZhbHNlKTtcbiAqICAgICBzY2hlbWEuZ2V0KCdzdHJpY3QnKTsgLy8gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBPcHRpb24gdG8gZ2V0IHRoZSBjdXJyZW50IHZhbHVlIGZvclxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge0FueX0gdGhlIG9wdGlvbidzIHZhbHVlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9uc1trZXldO1xufTtcblxuY29uc3QgaW5kZXhUeXBlcyA9ICcyZCAyZHNwaGVyZSBoYXNoZWQgdGV4dCcuc3BsaXQoJyAnKTtcblxuLyoqXG4gKiBUaGUgYWxsb3dlZCBpbmRleCB0eXBlc1xuICpcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IGluZGV4VHlwZXNcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYSwgJ2luZGV4VHlwZXMnLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGluZGV4VHlwZXM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb3ZlcndyaXRlIFNjaGVtYS5pbmRleFR5cGVzJyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGluZGV4ZXMgdGhhdCB0aGlzIHNjaGVtYSBkZWNsYXJlcywgdmlhIGBzY2hlbWEuaW5kZXgoKWAgb3IgYnkgYGluZGV4OiB0cnVlYCBpbiBhIHBhdGgncyBvcHRpb25zLlxuICogSW5kZXhlcyBhcmUgZXhwcmVzc2VkIGFzIGFuIGFycmF5IGBbc3BlYywgb3B0aW9uc11gLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgZW1haWw6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gKiAgICAgICByZWdpc3RlcmVkQXQ6IHsgdHlwZTogRGF0ZSwgaW5kZXg6IHRydWUgfVxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBbIFsgeyBlbWFpbDogMSB9LCB7IHVuaXF1ZTogdHJ1ZSwgYmFja2dyb3VuZDogdHJ1ZSB9IF0sXG4gKiAgICAgLy8gICBbIHsgcmVnaXN0ZXJlZEF0OiAxIH0sIHsgYmFja2dyb3VuZDogdHJ1ZSB9IF0gXVxuICogICAgIHVzZXJTY2hlbWEuaW5kZXhlcygpO1xuICpcbiAqIFtQbHVnaW5zXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcGx1Z2lucy5odG1sKSBjYW4gdXNlIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiB0byBtb2RpZnkgYSBzY2hlbWEncyBpbmRleGVzLlxuICogRm9yIGV4YW1wbGUsIHRoZSBiZWxvdyBwbHVnaW4gbWFrZXMgZXZlcnkgaW5kZXggdW5pcXVlIGJ5IGRlZmF1bHQuXG4gKlxuICogICAgIGZ1bmN0aW9uIG15UGx1Z2luKHNjaGVtYSkge1xuICogICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBzY2hlbWEuaW5kZXhlcygpKSB7XG4gKiAgICAgICAgIGlmIChpbmRleFsxXS51bmlxdWUgPT09IHVuZGVmaW5lZCkge1xuICogICAgICAgICAgIGluZGV4WzFdLnVuaXF1ZSA9IHRydWU7XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge0FycmF5fSBsaXN0IG9mIGluZGV4ZXMgZGVmaW5lZCBpbiB0aGUgc2NoZW1hXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5pbmRleGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnZXRJbmRleGVzKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdmlydHVhbCB0eXBlIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIFZpcnR1YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7U3RyaW5nfE1vZGVsfSBbb3B0aW9ucy5yZWZdIG1vZGVsIG5hbWUgb3IgbW9kZWwgaW5zdGFuY2UuIE1hcmtzIHRoaXMgYXMgYSBbcG9wdWxhdGUgdmlydHVhbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjcG9wdWxhdGUtdmlydHVhbHMpLlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtvcHRpb25zLmxvY2FsRmllbGRdIFJlcXVpcmVkIGZvciBwb3B1bGF0ZSB2aXJ0dWFscy4gU2VlIFtwb3B1bGF0ZSB2aXJ0dWFsIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3BvcHVsYXRlLXZpcnR1YWxzKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb3B0aW9ucy5mb3JlaWduRmllbGRdIFJlcXVpcmVkIGZvciBwb3B1bGF0ZSB2aXJ0dWFscy4gU2VlIFtwb3B1bGF0ZSB2aXJ0dWFsIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3BvcHVsYXRlLXZpcnR1YWxzKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMuanVzdE9uZT1mYWxzZV0gT25seSB3b3JrcyB3aXRoIHBvcHVsYXRlIHZpcnR1YWxzLiBJZiBbdHJ1dGh5XShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdHJ1dGh5KSwgd2lsbCBiZSBhIHNpbmdsZSBkb2Mgb3IgYG51bGxgLiBPdGhlcndpc2UsIHRoZSBwb3B1bGF0ZSB2aXJ0dWFsIHdpbGwgYmUgYW4gYXJyYXkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvdW50PWZhbHNlXSBPbmx5IHdvcmtzIHdpdGggcG9wdWxhdGUgdmlydHVhbHMuIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCB0aGlzIHBvcHVsYXRlIHZpcnR1YWwgd2lsbCBjb250YWluIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHJhdGhlciB0aGFuIHRoZSBkb2N1bWVudHMgdGhlbXNlbHZlcyB3aGVuIHlvdSBgcG9wdWxhdGUoKWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx9IFtvcHRpb25zLmdldD1udWxsXSBBZGRzIGEgW2dldHRlcl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9nZXR0ZXJzLXNldHRlcnMuaHRtbCkgdG8gdGhpcyB2aXJ0dWFsIHRvIHRyYW5zZm9ybSB0aGUgcG9wdWxhdGVkIGRvYy5cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbb3B0aW9ucy5tYXRjaD1udWxsXSBBcHBseSBhIGRlZmF1bHQgW2BtYXRjaGAgb3B0aW9uIHRvIHBvcHVsYXRlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbCNtYXRjaCksIGFkZGluZyBhbiBhZGRpdGlvbmFsIGZpbHRlciB0byB0aGUgcG9wdWxhdGUgcXVlcnkuXG4gKiBAcmV0dXJuIHtWaXJ0dWFsVHlwZX1cbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnZpcnR1YWwgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChuYW1lIGluc3RhbmNlb2YgVmlydHVhbFR5cGUgfHwgZ2V0Q29uc3RydWN0b3JOYW1lKG5hbWUpID09PSAnVmlydHVhbFR5cGUnKSB7XG4gICAgcmV0dXJuIHRoaXMudmlydHVhbChuYW1lLnBhdGgsIG5hbWUub3B0aW9ucyk7XG4gIH1cbiAgb3B0aW9ucyA9IG5ldyBWaXJ0dWFsT3B0aW9ucyhvcHRpb25zKTtcblxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvcHRpb25zLCBbJ3JlZicsICdyZWZQYXRoJ10pKSB7XG4gICAgaWYgKG9wdGlvbnMubG9jYWxGaWVsZCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZSB2aXJ0dWFscyByZXF1aXJlIGBsb2NhbEZpZWxkYCBvcHRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5mb3JlaWduRmllbGQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2UgdmlydHVhbHMgcmVxdWlyZSBgZm9yZWlnbkZpZWxkYCBvcHRpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLnByZSgnaW5pdCcsIGZ1bmN0aW9uIHZpcnR1YWxQcmVJbml0KG9iaikge1xuICAgICAgaWYgKG1wYXRoLmhhcyhuYW1lLCBvYmopKSB7XG4gICAgICAgIGNvbnN0IF92ID0gbXBhdGguZ2V0KG5hbWUsIG9iaik7XG4gICAgICAgIGlmICghdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzKSB7XG4gICAgICAgICAgdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5qdXN0T25lIHx8IG9wdGlvbnMuY291bnQpIHtcbiAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gPSBBcnJheS5pc0FycmF5KF92KSA/XG4gICAgICAgICAgICBfdlswXSA6XG4gICAgICAgICAgICBfdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gPSBBcnJheS5pc0FycmF5KF92KSA/XG4gICAgICAgICAgICBfdiA6XG4gICAgICAgICAgICBfdiA9PSBudWxsID8gW10gOiBbX3ZdO1xuICAgICAgICB9XG5cbiAgICAgICAgbXBhdGgudW5zZXQobmFtZSwgb2JqKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHZpcnR1YWwgPSB0aGlzLnZpcnR1YWwobmFtZSk7XG4gICAgdmlydHVhbC5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHZpcnR1YWwuXG4gICAgICBzZXQoZnVuY3Rpb24oX3YpIHtcbiAgICAgICAgaWYgKCF0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHMpIHtcbiAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmp1c3RPbmUgfHwgb3B0aW9ucy5jb3VudCkge1xuICAgICAgICAgIHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFsc1tuYW1lXSA9IEFycmF5LmlzQXJyYXkoX3YpID9cbiAgICAgICAgICAgIF92WzBdIDpcbiAgICAgICAgICAgIF92O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gPSBvcHRpb25zLmNvdW50ID8gX3YgOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gPSBBcnJheS5pc0FycmF5KF92KSA/XG4gICAgICAgICAgICBfdiA6XG4gICAgICAgICAgICBfdiA9PSBudWxsID8gW10gOiBbX3ZdO1xuXG4gICAgICAgICAgdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzW25hbWVdID0gdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzW25hbWVdLmZpbHRlcihmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2MgJiYgdHlwZW9mIGRvYyA9PT0gJ29iamVjdCc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmlydHVhbC5nZXQob3B0aW9ucy5nZXQpO1xuICAgIH1cblxuICAgIC8vIFdvcmthcm91bmQgZm9yIGdoLTgxOTg6IGlmIHZpcnR1YWwgaXMgdW5kZXIgZG9jdW1lbnQgYXJyYXksIG1ha2UgYSBmYWtlXG4gICAgLy8gdmlydHVhbC4gU2VlIGdoLTgyMTAsIGdoLTEzMTg5XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgbGV0IGN1ciA9IHBhcnRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBpZiAodGhpcy5wYXRoc1tjdXJdID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBhdGhzW2N1cl0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IHRoaXMucGF0aHNbY3VyXS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgY29uc3QgcmVtbmFudCA9IHBhcnRzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICAgIHRoaXMucGF0aHNbY3VyXS5zY2hlbWEudmlydHVhbChyZW1uYW50LCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGN1ciArPSAnLicgKyBwYXJ0c1tpICsgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpcnR1YWw7XG4gIH1cblxuICBjb25zdCB2aXJ0dWFscyA9IHRoaXMudmlydHVhbHM7XG4gIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXG4gIGlmICh0aGlzLnBhdGhUeXBlKG5hbWUpID09PSAncmVhbCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpcnR1YWwgcGF0aCBcIicgKyBuYW1lICsgJ1wiJyArXG4gICAgICAnIGNvbmZsaWN0cyB3aXRoIGEgcmVhbCBwYXRoIGluIHRoZSBzY2hlbWEnKTtcbiAgfVxuXG4gIHZpcnR1YWxzW25hbWVdID0gcGFydHMucmVkdWNlKGZ1bmN0aW9uKG1lbSwgcGFydCwgaSkge1xuICAgIG1lbVtwYXJ0XSB8fCAobWVtW3BhcnRdID0gKGkgPT09IHBhcnRzLmxlbmd0aCAtIDEpXG4gICAgICA/IG5ldyBWaXJ0dWFsVHlwZShvcHRpb25zLCBuYW1lKVxuICAgICAgOiB7fSk7XG4gICAgcmV0dXJuIG1lbVtwYXJ0XTtcbiAgfSwgdGhpcy50cmVlKTtcblxuICByZXR1cm4gdmlydHVhbHNbbmFtZV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZpcnR1YWwgdHlwZSB3aXRoIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIFZpcnR1YWwgdG8gZ2V0XG4gKiBAcmV0dXJuIHtWaXJ0dWFsVHlwZXxudWxsfVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUudmlydHVhbHBhdGggPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLnZpcnR1YWxzLmhhc093blByb3BlcnR5KG5hbWUpID8gdGhpcy52aXJ0dWFsc1tuYW1lXSA6IG51bGw7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGdpdmVuIGBwYXRoYCAob3IgW2BwYXRoc2BdKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGFnZTogTnVtYmVyIH0pO1xuICogICAgIHNjaGVtYS5yZW1vdmUoJ25hbWUnKTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpOyAvLyBVbmRlZmluZWRcbiAqICAgICBzY2hlbWEucGF0aCgnYWdlJyk7IC8vIFNjaGVtYU51bWJlciB7IC4uLiB9XG4gKlxuICogT3IgYXMgYSBBcnJheTpcbiAqXG4gKiAgICAgc2NoZW1hLnJlbW92ZShbJ25hbWUnLCAnYWdlJ10pO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJyk7IC8vIFVuZGVmaW5lZFxuICogICAgIHNjaGVtYS5wYXRoKCdhZ2UnKTsgLy8gVW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBhdGggVGhlIFBhdGgocykgdG8gcmVtb3ZlXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IFtwYXRoXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHBhdGguZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAodGhpcy5wYXRoKG5hbWUpID09IG51bGwgJiYgIXRoaXMubmVzdGVkW25hbWVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lc3RlZFtuYW1lXSkge1xuICAgICAgICBjb25zdCBhbGxLZXlzID0gT2JqZWN0LmtleXModGhpcy5wYXRocykuXG4gICAgICAgICAgY29uY2F0KE9iamVjdC5rZXlzKHRoaXMubmVzdGVkKSk7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBhbGxLZXlzKSB7XG4gICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aChuYW1lICsgJy4nKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGF0aHNbcGF0aF07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5uZXN0ZWRbcGF0aF07XG4gICAgICAgICAgICBfZGVsZXRlUGF0aCh0aGlzLCBwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5uZXN0ZWRbbmFtZV07XG4gICAgICAgIF9kZWxldGVQYXRoKHRoaXMsIG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnBhdGhzW25hbWVdO1xuICAgICAgX2RlbGV0ZVBhdGgodGhpcywgbmFtZSk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9kZWxldGVQYXRoKHNjaGVtYSwgbmFtZSkge1xuICBjb25zdCBwaWVjZXMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGxhc3QgPSBwaWVjZXMucG9wKCk7XG5cbiAgbGV0IGJyYW5jaCA9IHNjaGVtYS50cmVlO1xuXG4gIGZvciAoY29uc3QgcGllY2Ugb2YgcGllY2VzKSB7XG4gICAgYnJhbmNoID0gYnJhbmNoW3BpZWNlXTtcbiAgfVxuXG4gIGRlbGV0ZSBicmFuY2hbbGFzdF07XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZ2l2ZW4gdmlydHVhbCBvciB2aXJ0dWFscyBmcm9tIHRoZSBzY2hlbWEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBhdGggVGhlIHZpcnV0YWwgcGF0aChzKSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7U2NoZW1hfSB0aGUgU2NoZW1hIGluc3RhbmNlLCBvciBhIG1vbmdvb3NlIGVycm9yIGlmIHRoZSB2aXJ0dWFsIGRvZXMgbm90IGV4aXN0LlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnJlbW92ZVZpcnR1YWwgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXRoID0gW3BhdGhdO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgZm9yIChjb25zdCB2aXJ0dWFsIG9mIHBhdGgpIHtcbiAgICAgIGlmICh0aGlzLnZpcnR1YWxzW3ZpcnR1YWxdID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoYEF0dGVtcHRpbmcgdG8gcmVtb3ZlIHZpcnR1YWwgXCIke3ZpcnR1YWx9XCIgdGhhdCBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHZpcnR1YWwgb2YgcGF0aCkge1xuICAgICAgZGVsZXRlIHRoaXMucGF0aHNbdmlydHVhbF07XG4gICAgICBkZWxldGUgdGhpcy52aXJ0dWFsc1t2aXJ0dWFsXTtcbiAgICAgIGlmICh2aXJ0dWFsLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgbXBhdGgudW5zZXQodmlydHVhbCwgdGhpcy50cmVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRyZWVbdmlydHVhbF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMb2FkcyBhbiBFUzYgY2xhc3MgaW50byBhIHNjaGVtYS4gTWFwcyBbc2V0dGVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL3NldCkgKyBbZ2V0dGVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL2dldCksIFtzdGF0aWMgbWV0aG9kc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvQ2xhc3Nlcy9zdGF0aWMpLFxuICogYW5kIFtpbnN0YW5jZSBtZXRob2RzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9DbGFzc2VzI0NsYXNzX2JvZHlfYW5kX21ldGhvZF9kZWZpbml0aW9ucylcbiAqIHRvIHNjaGVtYSBbdmlydHVhbHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3ZpcnR1YWxzKSxcbiAqIFtzdGF0aWNzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdGF0aWNzKSwgYW5kXG4gKiBbbWV0aG9kc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjbWV0aG9kcykuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IG1kNSA9IHJlcXVpcmUoJ21kNScpO1xuICogY29uc3QgdXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoeyBlbWFpbDogU3RyaW5nIH0pO1xuICogY2xhc3MgVXNlckNsYXNzIHtcbiAqICAgLy8gYGdyYXZhdGFySW1hZ2VgIGJlY29tZXMgYSB2aXJ0dWFsXG4gKiAgIGdldCBncmF2YXRhckltYWdlKCkge1xuICogICAgIGNvbnN0IGhhc2ggPSBtZDUodGhpcy5lbWFpbC50b0xvd2VyQ2FzZSgpKTtcbiAqICAgICByZXR1cm4gYGh0dHBzOi8vd3d3LmdyYXZhdGFyLmNvbS9hdmF0YXIvJHtoYXNofWA7XG4gKiAgIH1cbiAqXG4gKiAgIC8vIGBnZXRQcm9maWxlVXJsKClgIGJlY29tZXMgYSBkb2N1bWVudCBtZXRob2RcbiAqICAgZ2V0UHJvZmlsZVVybCgpIHtcbiAqICAgICByZXR1cm4gYGh0dHBzOi8vbXlzaXRlLmNvbS8ke3RoaXMuZW1haWx9YDtcbiAqICAgfVxuICpcbiAqICAgLy8gYGZpbmRCeUVtYWlsKClgIGJlY29tZXMgYSBzdGF0aWNcbiAqICAgc3RhdGljIGZpbmRCeUVtYWlsKGVtYWlsKSB7XG4gKiAgICAgcmV0dXJuIHRoaXMuZmluZE9uZSh7IGVtYWlsIH0pO1xuICogICB9XG4gKiB9XG4gKlxuICogLy8gYHNjaGVtYWAgd2lsbCBub3cgaGF2ZSBhIGBncmF2YXRhckltYWdlYCB2aXJ0dWFsLCBhIGBnZXRQcm9maWxlVXJsKClgIG1ldGhvZCxcbiAqIC8vIGFuZCBhIGBmaW5kQnlFbWFpbCgpYCBzdGF0aWNcbiAqIHVzZXJTY2hlbWEubG9hZENsYXNzKFVzZXJDbGFzcyk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RlbCBUaGUgQ2xhc3MgdG8gbG9hZFxuICogQHBhcmFtIHtCb29sZWFufSBbdmlydHVhbHNPbmx5XSBpZiB0cnV0aHksIG9ubHkgcHVsbHMgdmlydHVhbHMgZnJvbSB0aGUgY2xhc3MsIG5vdCBtZXRob2RzIG9yIHN0YXRpY3NcbiAqL1xuU2NoZW1hLnByb3RvdHlwZS5sb2FkQ2xhc3MgPSBmdW5jdGlvbihtb2RlbCwgdmlydHVhbHNPbmx5KSB7XG4gIC8vIFN0b3AgY29weWluZyB3aGVuIGhpdCBjZXJ0YWluIGJhc2UgY2xhc3Nlc1xuICBpZiAobW9kZWwgPT09IE9iamVjdC5wcm90b3R5cGUgfHxcbiAgICAgIG1vZGVsID09PSBGdW5jdGlvbi5wcm90b3R5cGUgfHxcbiAgICAgIG1vZGVsLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnJGlzTW9uZ29vc2VNb2RlbFByb3RvdHlwZScpIHx8XG4gICAgICBtb2RlbC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJyRpc01vbmdvb3NlRG9jdW1lbnRQcm90b3R5cGUnKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5sb2FkQ2xhc3MoT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZGVsKSwgdmlydHVhbHNPbmx5KTtcblxuICAvLyBBZGQgc3RhdGljIG1ldGhvZHNcbiAgaWYgKCF2aXJ0dWFsc09ubHkpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtb2RlbCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAobmFtZS5tYXRjaCgvXihsZW5ndGh8bmFtZXxwcm90b3R5cGV8Y29uc3RydWN0b3J8X19wcm90b19fKSQvKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtb2RlbCwgbmFtZSk7XG4gICAgICBpZiAocHJvcC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgICB0aGlzLnN0YXRpYyhuYW1lLCBwcm9wLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIC8vIEFkZCBtZXRob2RzIGFuZCB2aXJ0dWFsc1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtb2RlbC5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChuYW1lLm1hdGNoKC9eKGNvbnN0cnVjdG9yKSQvKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG1vZGVsLnByb3RvdHlwZSwgbmFtZSk7XG4gICAgaWYgKCF2aXJ0dWFsc09ubHkpIHtcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMubWV0aG9kKG5hbWUsIG1ldGhvZC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0aG9kLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHRoaXMudmlydHVhbHNbbmFtZV0pIHtcbiAgICAgICAgdGhpcy52aXJ0dWFsc1tuYW1lXS5nZXR0ZXJzID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLnZpcnR1YWwobmFtZSkuZ2V0KG1ldGhvZC5nZXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1ldGhvZC5zZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLnZpcnR1YWxzW25hbWVdKSB7XG4gICAgICAgIHRoaXMudmlydHVhbHNbbmFtZV0uc2V0dGVycyA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy52aXJ0dWFsKG5hbWUpLnNldChtZXRob2Quc2V0KTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLl9nZXRTY2hlbWEgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgY29uc3QgcGF0aHNjaGVtYSA9IF90aGlzLnBhdGgocGF0aCk7XG4gIGNvbnN0IHJlc3VsdFBhdGggPSBbXTtcblxuICBpZiAocGF0aHNjaGVtYSkge1xuICAgIHBhdGhzY2hlbWEuJGZ1bGxQYXRoID0gcGF0aDtcbiAgICByZXR1cm4gcGF0aHNjaGVtYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaChwYXJ0cywgc2NoZW1hKSB7XG4gICAgbGV0IHAgPSBwYXJ0cy5sZW5ndGggKyAxO1xuICAgIGxldCBmb3VuZHNjaGVtYTtcbiAgICBsZXQgdHJ5cGF0aDtcblxuICAgIHdoaWxlIChwLS0pIHtcbiAgICAgIHRyeXBhdGggPSBwYXJ0cy5zbGljZSgwLCBwKS5qb2luKCcuJyk7XG4gICAgICBmb3VuZHNjaGVtYSA9IHNjaGVtYS5wYXRoKHRyeXBhdGgpO1xuICAgICAgaWYgKGZvdW5kc2NoZW1hKSB7XG4gICAgICAgIHJlc3VsdFBhdGgucHVzaCh0cnlwYXRoKTtcblxuICAgICAgICBpZiAoZm91bmRzY2hlbWEuY2FzdGVyKSB7XG4gICAgICAgICAgLy8gYXJyYXkgb2YgTWl4ZWQ/XG4gICAgICAgICAgaWYgKGZvdW5kc2NoZW1hLmNhc3RlciBpbnN0YW5jZW9mIE1vbmdvb3NlVHlwZXMuTWl4ZWQpIHtcbiAgICAgICAgICAgIGZvdW5kc2NoZW1hLmNhc3Rlci4kZnVsbFBhdGggPSByZXN1bHRQYXRoLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZHNjaGVtYS5jYXN0ZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTm93IHRoYXQgd2UgZm91bmQgdGhlIGFycmF5LCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlXG4gICAgICAgICAgLy8gYXJlIHJlbWFpbmluZyBkb2N1bWVudCBwYXRocyB0byBsb29rIHVwIGZvciBjYXN0aW5nLlxuICAgICAgICAgIC8vIEFsc28gd2UgbmVlZCB0byBoYW5kbGUgYXJyYXkuJC5wYXRoIHNpbmNlIHNjaGVtYS5wYXRoXG4gICAgICAgICAgLy8gZG9lc24ndCB3b3JrIGZvciB0aGF0LlxuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGZvdW5kc2NoZW1hLnNjaGVtYSB3ZSBhcmUgZGVhbGluZyB3aXRoXG4gICAgICAgICAgLy8gYSBwYXRoIGxpa2UgYXJyYXkuJFxuICAgICAgICAgIGlmIChwICE9PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChwICsgMSA9PT0gcGFydHMubGVuZ3RoICYmIGZvdW5kc2NoZW1hLiRlbWJlZGRlZFNjaGVtYVR5cGUgJiYgKHBhcnRzW3BdID09PSAnJCcgfHwgaXNBcnJheUZpbHRlcihwYXJ0c1twXSkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmb3VuZHNjaGVtYS4kZW1iZWRkZWRTY2hlbWFUeXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm91bmRzY2hlbWEuc2NoZW1hKSB7XG4gICAgICAgICAgICAgIGxldCByZXQ7XG4gICAgICAgICAgICAgIGlmIChwYXJ0c1twXSA9PT0gJyQnIHx8IGlzQXJyYXlGaWx0ZXIocGFydHNbcF0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAgKyAxID09PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbW1lbnRzLiRcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZHNjaGVtYS4kZW1iZWRkZWRTY2hlbWFUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb21tZW50cy4kLmNvbW1lbnRzLiQudGl0bGVcbiAgICAgICAgICAgICAgICByZXQgPSBzZWFyY2gocGFydHMuc2xpY2UocCArIDEpLCBmb3VuZHNjaGVtYS5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICAgIHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPSByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5IHx8XG4gICAgICAgICAgICAgICAgICAgIChmb3VuZHNjaGVtYS5zY2hlbWEuJGlzU2luZ2xlTmVzdGVkID8gbnVsbCA6IGZvdW5kc2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBsYXN0IHBhdGggb2YgdGhlIHNlbGVjdG9yXG4gICAgICAgICAgICAgIHJldCA9IHNlYXJjaChwYXJ0cy5zbGljZShwKSwgZm91bmRzY2hlbWEuc2NoZW1hKTtcbiAgICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICAgIHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPSByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5IHx8XG4gICAgICAgICAgICAgICAgICAoZm91bmRzY2hlbWEuc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCA/IG51bGwgOiBmb3VuZHNjaGVtYSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZm91bmRzY2hlbWEuJGlzU2NoZW1hTWFwKSB7XG4gICAgICAgICAgaWYgKHAgPj0gcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRzY2hlbWE7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFueSBwYXRoIGluIHRoZSBtYXAgd2lsbCBiZSBhbiBpbnN0YW5jZSBvZiB0aGUgbWFwJ3MgZW1iZWRkZWQgc2NoZW1hdHlwZVxuICAgICAgICAgIGlmIChwICsgMSA+PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZHNjaGVtYS4kX19zY2hlbWFUeXBlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmb3VuZHNjaGVtYS4kX19zY2hlbWFUeXBlIGluc3RhbmNlb2YgTW9uZ29vc2VUeXBlcy5NaXhlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hLiRfX3NjaGVtYVR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3VuZHNjaGVtYS4kX19zY2hlbWFUeXBlLnNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBNYXAgb2YgZG9jc1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gc2VhcmNoKHBhcnRzLnNsaWNlKHAgKyAxKSwgZm91bmRzY2hlbWEuJF9fc2NoZW1hVHlwZS5zY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3VuZHNjaGVtYS4kZnVsbFBhdGggPSByZXN1bHRQYXRoLmpvaW4oJy4nKTtcblxuICAgICAgICByZXR1cm4gZm91bmRzY2hlbWE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbG9vayBmb3IgYXJyYXlzXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHBhcnRzW2ldID09PSAnJCcgfHwgaXNBcnJheUZpbHRlcihwYXJ0c1tpXSkpIHtcbiAgICAgIC8vIFJlOiBnaC01NjI4LCBiZWNhdXNlIGBzY2hlbWEucGF0aCgpYCBkb2Vzbid0IHRha2UgJCBpbnRvIGFjY291bnQuXG4gICAgICBwYXJ0c1tpXSA9ICcwJztcbiAgICB9XG4gICAgaWYgKG51bWJlclJFLnRlc3QocGFydHNbaV0pKSB7XG4gICAgICBwYXJ0c1tpXSA9ICckJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlYXJjaChwYXJ0cywgX3RoaXMpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLl9nZXRQYXRoVHlwZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBjb25zdCBwYXRoc2NoZW1hID0gX3RoaXMucGF0aChwYXRoKTtcblxuICBpZiAocGF0aHNjaGVtYSkge1xuICAgIHJldHVybiAncmVhbCc7XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2gocGFydHMsIHNjaGVtYSkge1xuICAgIGxldCBwID0gcGFydHMubGVuZ3RoICsgMSxcbiAgICAgICAgZm91bmRzY2hlbWEsXG4gICAgICAgIHRyeXBhdGg7XG5cbiAgICB3aGlsZSAocC0tKSB7XG4gICAgICB0cnlwYXRoID0gcGFydHMuc2xpY2UoMCwgcCkuam9pbignLicpO1xuICAgICAgZm91bmRzY2hlbWEgPSBzY2hlbWEucGF0aCh0cnlwYXRoKTtcbiAgICAgIGlmIChmb3VuZHNjaGVtYSkge1xuICAgICAgICBpZiAoZm91bmRzY2hlbWEuY2FzdGVyKSB7XG4gICAgICAgICAgLy8gYXJyYXkgb2YgTWl4ZWQ/XG4gICAgICAgICAgaWYgKGZvdW5kc2NoZW1hLmNhc3RlciBpbnN0YW5jZW9mIE1vbmdvb3NlVHlwZXMuTWl4ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogZm91bmRzY2hlbWEsIHBhdGhUeXBlOiAnbWl4ZWQnIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTm93IHRoYXQgd2UgZm91bmQgdGhlIGFycmF5LCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlXG4gICAgICAgICAgLy8gYXJlIHJlbWFpbmluZyBkb2N1bWVudCBwYXRocyB0byBsb29rIHVwIGZvciBjYXN0aW5nLlxuICAgICAgICAgIC8vIEFsc28gd2UgbmVlZCB0byBoYW5kbGUgYXJyYXkuJC5wYXRoIHNpbmNlIHNjaGVtYS5wYXRoXG4gICAgICAgICAgLy8gZG9lc24ndCB3b3JrIGZvciB0aGF0LlxuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGZvdW5kc2NoZW1hLnNjaGVtYSB3ZSBhcmUgZGVhbGluZyB3aXRoXG4gICAgICAgICAgLy8gYSBwYXRoIGxpa2UgYXJyYXkuJFxuICAgICAgICAgIGlmIChwICE9PSBwYXJ0cy5sZW5ndGggJiYgZm91bmRzY2hlbWEuc2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAocGFydHNbcF0gPT09ICckJyB8fCBpc0FycmF5RmlsdGVyKHBhcnRzW3BdKSkge1xuICAgICAgICAgICAgICBpZiAocCA9PT0gcGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogZm91bmRzY2hlbWEsIHBhdGhUeXBlOiAnbmVzdGVkJyB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGNvbW1lbnRzLiQuY29tbWVudHMuJC50aXRsZVxuICAgICAgICAgICAgICByZXR1cm4gc2VhcmNoKHBhcnRzLnNsaWNlKHAgKyAxKSwgZm91bmRzY2hlbWEuc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGxhc3QgcGF0aCBvZiB0aGUgc2VsZWN0b3JcbiAgICAgICAgICAgIHJldHVybiBzZWFyY2gocGFydHMuc2xpY2UocCksIGZvdW5kc2NoZW1hLnNjaGVtYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWE6IGZvdW5kc2NoZW1hLFxuICAgICAgICAgICAgcGF0aFR5cGU6IGZvdW5kc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCA/ICduZXN0ZWQnIDogJ2FycmF5J1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiBmb3VuZHNjaGVtYSwgcGF0aFR5cGU6ICdyZWFsJyB9O1xuICAgICAgfSBlbHNlIGlmIChwID09PSBwYXJ0cy5sZW5ndGggJiYgc2NoZW1hLm5lc3RlZFt0cnlwYXRoXSkge1xuICAgICAgICByZXR1cm4geyBzY2hlbWE6IHNjaGVtYSwgcGF0aFR5cGU6ICduZXN0ZWQnIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHNjaGVtYTogZm91bmRzY2hlbWEgfHwgc2NoZW1hLCBwYXRoVHlwZTogJ3VuZGVmaW5lZCcgfTtcbiAgfVxuXG4gIC8vIGxvb2sgZm9yIGFycmF5c1xuICByZXR1cm4gc2VhcmNoKHBhdGguc3BsaXQoJy4nKSwgX3RoaXMpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBpc0FycmF5RmlsdGVyKHBpZWNlKSB7XG4gIHJldHVybiBwaWVjZS5zdGFydHNXaXRoKCckWycpICYmIHBpZWNlLmVuZHNXaXRoKCddJyk7XG59XG5cbi8qKlxuICogQ2FsbGVkIGJ5IGBjb21waWxlKClgIF9yaWdodCBiZWZvcmVfIGNvbXBpbGluZy4gR29vZCBmb3IgbWFraW5nIGFueSBjaGFuZ2VzIHRvXG4gKiB0aGUgc2NoZW1hIHRoYXQgc2hvdWxkIHJlc3BlY3Qgb3B0aW9ucyBzZXQgYnkgcGx1Z2lucywgbGlrZSBgaWRgXG4gKiBAbWV0aG9kIF9wcmVDb21waWxlXG4gKiBAbWVtYmVyT2YgU2NoZW1hXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUuX3ByZUNvbXBpbGUgPSBmdW5jdGlvbiBfcHJlQ29tcGlsZSgpIHtcbiAgdGhpcy5wbHVnaW4oaWRHZXR0ZXIsIHsgZGVkdXBsaWNhdGU6IHRydWUgfSk7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNjaGVtYTtcblxuLy8gcmVxdWlyZSBkb3duIGhlcmUgYmVjYXVzZSBvZiByZWZlcmVuY2UgaXNzdWVzXG5cbi8qKlxuICogVGhlIHZhcmlvdXMgYnVpbHQtaW4gTW9uZ29vc2UgU2NoZW1hIFR5cGVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIGNvbnN0IE9iamVjdElkID0gbW9uZ29vc2UuU2NoZW1hLlR5cGVzLk9iamVjdElkO1xuICpcbiAqICMjIyMgVHlwZXM6XG4gKlxuICogLSBbU3RyaW5nXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNzdHJpbmdzKVxuICogLSBbTnVtYmVyXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNudW1iZXJzKVxuICogLSBbQm9vbGVhbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjYm9vbGVhbnMpIHwgQm9vbFxuICogLSBbQXJyYXldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI2FycmF5cylcbiAqIC0gW0J1ZmZlcl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjYnVmZmVycylcbiAqIC0gW0RhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI2RhdGVzKVxuICogLSBbT2JqZWN0SWRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI29iamVjdGlkcykgfCBPaWRcbiAqIC0gW01peGVkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNtaXhlZClcbiAqIC0gW1VVSURdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI3V1aWQpXG4gKiAtIFtCaWdJbnRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI2JpZ2ludClcbiAqXG4gKiBVc2luZyB0aGlzIGV4cG9zZWQgYWNjZXNzIHRvIHRoZSBgTWl4ZWRgIFNjaGVtYVR5cGUsIHdlIGNhbiB1c2UgdGhlbSBpbiBvdXIgc2NoZW1hLlxuICpcbiAqICAgICBjb25zdCBNaXhlZCA9IG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5NaXhlZDtcbiAqICAgICBuZXcgbW9uZ29vc2UuU2NoZW1hKHsgX3VzZXI6IE1peGVkIH0pXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEuVHlwZXMgPSBNb25nb29zZVR5cGVzID0gcmVxdWlyZSgnLi9zY2hlbWEvaW5kZXgnKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLk9iamVjdElkID0gTW9uZ29vc2VUeXBlcy5PYmplY3RJZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/DocumentArrayElement.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/DocumentArrayElement.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst SubdocumentPath = __webpack_require__(/*! ./SubdocumentPath */ \"(api)/../server/node_modules/mongoose/lib/schema/SubdocumentPath.js\");\nconst getConstructor = __webpack_require__(/*! ../helpers/discriminator/getConstructor */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\");\n\n/**\n * DocumentArrayElement SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction DocumentArrayElement(path, options) {\n  this.$parentSchemaType = options && options.$parentSchemaType;\n  if (!this.$parentSchemaType) {\n    throw new MongooseError('Cannot create DocumentArrayElement schematype without a parent');\n  }\n  delete options.$parentSchemaType;\n\n  SchemaType.call(this, path, options, 'DocumentArrayElement');\n\n  this.$isMongooseDocumentArrayElement = true;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDocumentArrayElement.schemaName = 'DocumentArrayElement';\n\nDocumentArrayElement.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nDocumentArrayElement.prototype = Object.create(SchemaType.prototype);\nDocumentArrayElement.prototype.constructor = DocumentArrayElement;\n\n/**\n * Casts `val` for DocumentArrayElement.\n *\n * @param {Object} value to cast\n * @api private\n */\n\nDocumentArrayElement.prototype.cast = function(...args) {\n  return this.$parentSchemaType.cast(...args)[0];\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $cond\n * @param {any} [val]\n * @api private\n */\n\nDocumentArrayElement.prototype.doValidate = function(value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, scope, null, null, options && options.index != null ? options.index : null);\n  }\n\n  return SubdocumentPath.prototype.doValidate.call(this, value, fn, scope, options);\n};\n\n/**\n * Clone the current SchemaType\n *\n * @return {DocumentArrayElement} The cloned instance\n * @api private\n */\n\nDocumentArrayElement.prototype.clone = function() {\n  this.options.$parentSchemaType = this.$parentSchemaType;\n  const ret = SchemaType.prototype.clone.apply(this, arguments);\n  delete this.options.$parentSchemaType;\n\n  ret.caster = this.caster;\n  ret.schema = this.schema;\n\n  return ret;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArrayElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL0RvY3VtZW50QXJyYXlFbGVtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBd0I7QUFDdEQsbUJBQW1CLG1CQUFPLENBQUMsOEVBQWU7QUFDMUMsd0JBQXdCLG1CQUFPLENBQUMsOEZBQW1CO0FBQ25ELHVCQUF1QixtQkFBTyxDQUFDLGtJQUF5Qzs7QUFFeEU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcc2NoZW1hXFxEb2N1bWVudEFycmF5RWxlbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYXR5cGUnKTtcbmNvbnN0IFN1YmRvY3VtZW50UGF0aCA9IHJlcXVpcmUoJy4vU3ViZG9jdW1lbnRQYXRoJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRDb25zdHJ1Y3RvcicpO1xuXG4vKipcbiAqIERvY3VtZW50QXJyYXlFbGVtZW50IFNjaGVtYVR5cGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBEb2N1bWVudEFycmF5RWxlbWVudChwYXRoLCBvcHRpb25zKSB7XG4gIHRoaXMuJHBhcmVudFNjaGVtYVR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMuJHBhcmVudFNjaGVtYVR5cGU7XG4gIGlmICghdGhpcy4kcGFyZW50U2NoZW1hVHlwZSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3QgY3JlYXRlIERvY3VtZW50QXJyYXlFbGVtZW50IHNjaGVtYXR5cGUgd2l0aG91dCBhIHBhcmVudCcpO1xuICB9XG4gIGRlbGV0ZSBvcHRpb25zLiRwYXJlbnRTY2hlbWFUeXBlO1xuXG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBwYXRoLCBvcHRpb25zLCAnRG9jdW1lbnRBcnJheUVsZW1lbnQnKTtcblxuICB0aGlzLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheUVsZW1lbnQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbkRvY3VtZW50QXJyYXlFbGVtZW50LnNjaGVtYU5hbWUgPSAnRG9jdW1lbnRBcnJheUVsZW1lbnQnO1xuXG5Eb2N1bWVudEFycmF5RWxlbWVudC5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuRG9jdW1lbnRBcnJheUVsZW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5Eb2N1bWVudEFycmF5RWxlbWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEb2N1bWVudEFycmF5RWxlbWVudDtcblxuLyoqXG4gKiBDYXN0cyBgdmFsYCBmb3IgRG9jdW1lbnRBcnJheUVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRvIGNhc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkRvY3VtZW50QXJyYXlFbGVtZW50LnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24oLi4uYXJncykge1xuICByZXR1cm4gdGhpcy4kcGFyZW50U2NoZW1hVHlwZS5jYXN0KC4uLmFyZ3MpWzBdO1xufTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50cyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRcbiAqIEBwYXJhbSB7YW55fSBbdmFsXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuRG9jdW1lbnRBcnJheUVsZW1lbnQucHJvdG90eXBlLmRvVmFsaWRhdGUgPSBmdW5jdGlvbih2YWx1ZSwgZm4sIHNjb3BlLCBvcHRpb25zKSB7XG4gIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXIsIHZhbHVlKTtcblxuICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHZhbHVlID0gbmV3IENvbnN0cnVjdG9yKHZhbHVlLCBzY29wZSwgbnVsbCwgbnVsbCwgb3B0aW9ucyAmJiBvcHRpb25zLmluZGV4ICE9IG51bGwgPyBvcHRpb25zLmluZGV4IDogbnVsbCk7XG4gIH1cblxuICByZXR1cm4gU3ViZG9jdW1lbnRQYXRoLnByb3RvdHlwZS5kb1ZhbGlkYXRlLmNhbGwodGhpcywgdmFsdWUsIGZuLCBzY29wZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENsb25lIHRoZSBjdXJyZW50IFNjaGVtYVR5cGVcbiAqXG4gKiBAcmV0dXJuIHtEb2N1bWVudEFycmF5RWxlbWVudH0gVGhlIGNsb25lZCBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuRG9jdW1lbnRBcnJheUVsZW1lbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMub3B0aW9ucy4kcGFyZW50U2NoZW1hVHlwZSA9IHRoaXMuJHBhcmVudFNjaGVtYVR5cGU7XG4gIGNvbnN0IHJldCA9IFNjaGVtYVR5cGUucHJvdG90eXBlLmNsb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGRlbGV0ZSB0aGlzLm9wdGlvbnMuJHBhcmVudFNjaGVtYVR5cGU7XG5cbiAgcmV0LmNhc3RlciA9IHRoaXMuY2FzdGVyO1xuICByZXQuc2NoZW1hID0gdGhpcy5zY2hlbWE7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBEb2N1bWVudEFycmF5RWxlbWVudDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/DocumentArrayElement.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/SubdocumentPath.js":
/*!*********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/SubdocumentPath.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst ObjectExpectedError = __webpack_require__(/*! ../error/objectExpected */ \"(api)/../server/node_modules/mongoose/lib/error/objectExpected.js\");\nconst SchemaSubdocumentOptions = __webpack_require__(/*! ../options/SchemaSubdocumentOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaSubdocumentOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst applyDefaults = __webpack_require__(/*! ../helpers/document/applyDefaults */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/applyDefaults.js\");\nconst $exists = __webpack_require__(/*! ./operators/exists */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/exists.js\");\nconst castToNumber = (__webpack_require__(/*! ./operators/helpers */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/helpers.js\").castToNumber);\nconst discriminator = __webpack_require__(/*! ../helpers/model/discriminator */ \"(api)/../server/node_modules/mongoose/lib/helpers/model/discriminator.js\");\nconst geospatial = __webpack_require__(/*! ./operators/geospatial */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/geospatial.js\");\nconst getConstructor = __webpack_require__(/*! ../helpers/discriminator/getConstructor */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\");\nconst handleIdOption = __webpack_require__(/*! ../helpers/schema/handleIdOption */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/handleIdOption.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../options */ \"(api)/../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst isExclusive = __webpack_require__(/*! ../helpers/projection/isExclusive */ \"(api)/../server/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst InvalidSchemaOptionError = __webpack_require__(/*! ../error/invalidSchemaOption */ \"(api)/../server/node_modules/mongoose/lib/error/invalidSchemaOption.js\");\n\nlet Subdocument;\n\nmodule.exports = SubdocumentPath;\n\n/**\n * Single nested subdocument SchemaType constructor.\n *\n * @param {Schema} schema\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SubdocumentPath(schema, path, options) {\n  if (schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(path, 'timeseries');\n  }\n  const schemaTypeIdOption = SubdocumentPath.defaultOptions &&\n    SubdocumentPath.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    options = options || {};\n    options._id = schemaTypeIdOption;\n  }\n\n  schema = handleIdOption(schema, options);\n\n  this.caster = _createConstructor(schema, null, options);\n  this.caster.path = path;\n  this.caster.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  this.base = schema.base;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n\n/*!\n * ignore\n */\n\nSubdocumentPath.prototype = Object.create(SchemaType.prototype);\nSubdocumentPath.prototype.constructor = SubdocumentPath;\nSubdocumentPath.prototype.OptionsConstructor = SchemaSubdocumentOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, baseClass, options) {\n  // lazy load\n  Subdocument || (Subdocument = __webpack_require__(/*! ../types/subdocument */ \"(api)/../server/node_modules/mongoose/lib/types/subdocument.js\"));\n\n  const _embedded = function SingleNested(value, path, parent) {\n    this.$__parent = parent;\n    Subdocument.apply(this, arguments);\n\n    if (parent == null) {\n      return;\n    }\n    this.$session(parent.$session());\n  };\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  _embedded.prototype = Object.create(proto);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.$__required = options?.required;\n  _embedded.base = schema.base;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n  _embedded.prototype.toBSON = function() {\n    return this.toObject(internalToObjectOptions);\n  };\n\n  // apply methods\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n\n  return _embedded;\n}\n\n/**\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\nSubdocumentPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val, context) {\n  return { $geometry: this.castForQuery(null, val.$geometry, context) };\n};\n\n/*!\n * ignore\n */\n\nSubdocumentPath.prototype.$conditionalHandlers.$near =\nSubdocumentPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\n\nSubdocumentPath.prototype.$conditionalHandlers.$within =\nSubdocumentPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\n\nSubdocumentPath.prototype.$conditionalHandlers.$geoIntersects =\n  geospatial.cast$geoIntersects;\n\nSubdocumentPath.prototype.$conditionalHandlers.$minDistance = castToNumber;\nSubdocumentPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;\n\nSubdocumentPath.prototype.$conditionalHandlers.$exists = $exists;\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nSubdocumentPath.prototype.cast = function(val, doc, init, priorVal, options) {\n  if (val && val.$isSingleNested && val.parent === doc) {\n    return val;\n  }\n\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n\n  const discriminatorKeyPath = this.schema.path(this.schema.options.discriminatorKey);\n  const defaultDiscriminatorValue = discriminatorKeyPath == null ? null : discriminatorKeyPath.getDefault(doc);\n  const Constructor = getConstructor(this.caster, val, defaultDiscriminatorValue);\n\n  let subdoc;\n\n  // Only pull relevant selected paths and pull out the base path\n  const parentSelected = doc && doc.$__ && doc.$__.selected;\n  const path = this.path;\n  const selected = parentSelected == null ? null : Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj = obj || {};\n      obj[key.substring(path.length + 1)] = parentSelected[key];\n    }\n    return obj;\n  }, null);\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc, false, { defaults: false });\n    delete subdoc.$__.defaults;\n    subdoc.$init(val);\n    const exclude = isExclusive(selected);\n    applyDefaults(subdoc, selected, exclude);\n  } else {\n    options = Object.assign({}, options, { priorDoc: priorVal });\n    if (Object.keys(val).length === 0) {\n      return new Constructor({}, selected, doc, undefined, options);\n    }\n\n    return new Constructor(val, selected, doc, undefined, options);\n  }\n\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nSubdocumentPath.prototype.castForQuery = function($conditional, val, context, options) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  if (val == null) {\n    return val;\n  }\n\n  const Constructor = getConstructor(this.caster, val);\n  if (val instanceof Constructor) {\n    return val;\n  }\n\n  if (this.options.runSetters) {\n    val = this._applySetters(val, context);\n  }\n\n  const overrideStrict = options != null && options.strict != null ?\n    options.strict :\n    void 0;\n\n  try {\n    val = new Constructor(val, overrideStrict);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error, this);\n    }\n    throw error;\n  }\n  return val;\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\nSubdocumentPath.prototype.doValidate = function(value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, null, (scope != null && scope.$__ != null) ? scope : null);\n  }\n\n  if (options && options.skipSchemaValidators) {\n    if (!value) {\n      return fn(null);\n    }\n    return value.validate().then(() => fn(null), err => fn(err));\n  }\n\n  SchemaType.prototype.doValidate.call(this, value, function(error) {\n    if (error) {\n      return fn(error);\n    }\n    if (!value) {\n      return fn(null);\n    }\n\n    value.validate().then(() => fn(null), err => fn(err));\n  }, scope, options);\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nSubdocumentPath.prototype.doValidateSync = function(value, scope, options) {\n  if (!options || !options.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n\n/**\n * Adds a discriminator to this single nested subdocument.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shape: shapeSchema });\n *\n *     const singleNestedPath = parentSchema.path('shape');\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @api public\n */\n\nSubdocumentPath.prototype.discriminator = function(name, schema, options) {\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean'\n    ? options.clone\n    : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.caster, name, schema, value);\n\n  this.caster.discriminators[name] = _createConstructor(schema, this.caster);\n\n  return this.caster.discriminators[name];\n};\n\n/*!\n * ignore\n */\n\nSubdocumentPath.defaultOptions = {};\n\n/**\n * Sets a default option for all SubdocumentPath instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.SubdocumentPath.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSubdocumentPath.set = SchemaType.set;\n\nSubdocumentPath.setters = [];\n\n/**\n * Attaches a getter for all SubdocumentPath instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSubdocumentPath.get = SchemaType.get;\n\n/*!\n * ignore\n */\n\nSubdocumentPath.prototype.toJSON = function toJSON() {\n  return { path: this.path, options: this.options };\n};\n\n/*!\n * ignore\n */\n\nSubdocumentPath.prototype.clone = function() {\n  const schematype = new this.constructor(\n    this.schema,\n    this.path,\n    { ...this.options, _skipApplyDiscriminators: true }\n  );\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);\n  return schematype;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL1N1YmRvY3VtZW50UGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMsOEVBQWU7QUFDekMscUJBQXFCLDBEQUE4QjtBQUNuRCw0QkFBNEIsbUJBQU8sQ0FBQyxrR0FBeUI7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMsMEhBQXFDO0FBQzlFLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFlO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLHNIQUFtQztBQUNqRSxnQkFBZ0IsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDNUMscUJBQXFCLHNJQUEyQztBQUNoRSxzQkFBc0IsbUJBQU8sQ0FBQyxnSEFBZ0M7QUFDOUQsbUJBQW1CLG1CQUFPLENBQUMsd0dBQXdCO0FBQ25ELHVCQUF1QixtQkFBTyxDQUFDLGtJQUF5QztBQUN4RSx1QkFBdUIsbUJBQU8sQ0FBQyxvSEFBa0M7QUFDakUsZ0NBQWdDLHVIQUE2QztBQUM3RSxvQkFBb0IsbUJBQU8sQ0FBQyxzSEFBbUM7QUFDL0QsY0FBYyxtQkFBTyxDQUFDLG9FQUFVO0FBQ2hDLGlDQUFpQyxtQkFBTyxDQUFDLDRHQUE4Qjs7QUFFdkU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLDRGQUFzQjs7QUFFOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDZEQUE2RCxpQkFBaUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOEJBQThCLGFBQWEsb0JBQW9CO0FBQy9EO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYyxJQUFJLDBCQUEwQjtBQUNoRiwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxzY2hlbWFcXFN1YmRvY3VtZW50UGF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9jYXN0Jyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBPYmplY3RFeHBlY3RlZEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3Ivb2JqZWN0RXhwZWN0ZWQnKTtcbmNvbnN0IFNjaGVtYVN1YmRvY3VtZW50T3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvU2NoZW1hU3ViZG9jdW1lbnRPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hdHlwZScpO1xuY29uc3QgYXBwbHlEZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9jdW1lbnQvYXBwbHlEZWZhdWx0cycpO1xuY29uc3QgJGV4aXN0cyA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2V4aXN0cycpO1xuY29uc3QgY2FzdFRvTnVtYmVyID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvaGVscGVycycpLmNhc3RUb051bWJlcjtcbmNvbnN0IGRpc2NyaW1pbmF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL21vZGVsL2Rpc2NyaW1pbmF0b3InKTtcbmNvbnN0IGdlb3NwYXRpYWwgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9nZW9zcGF0aWFsJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRDb25zdHJ1Y3RvcicpO1xuY29uc3QgaGFuZGxlSWRPcHRpb24gPSByZXF1aXJlKCcuLi9oZWxwZXJzL3NjaGVtYS9oYW5kbGVJZE9wdGlvbicpO1xuY29uc3QgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgPSByZXF1aXJlKCcuLi9vcHRpb25zJykuaW50ZXJuYWxUb09iamVjdE9wdGlvbnM7XG5jb25zdCBpc0V4Y2x1c2l2ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJvamVjdGlvbi9pc0V4Y2x1c2l2ZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgSW52YWxpZFNjaGVtYU9wdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvaW52YWxpZFNjaGVtYU9wdGlvbicpO1xuXG5sZXQgU3ViZG9jdW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ViZG9jdW1lbnRQYXRoO1xuXG4vKipcbiAqIFNpbmdsZSBuZXN0ZWQgc3ViZG9jdW1lbnQgU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFN1YmRvY3VtZW50UGF0aChzY2hlbWEsIHBhdGgsIG9wdGlvbnMpIHtcbiAgaWYgKHNjaGVtYS5vcHRpb25zLnRpbWVzZXJpZXMpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFNjaGVtYU9wdGlvbkVycm9yKHBhdGgsICd0aW1lc2VyaWVzJyk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hVHlwZUlkT3B0aW9uID0gU3ViZG9jdW1lbnRQYXRoLmRlZmF1bHRPcHRpb25zICYmXG4gICAgU3ViZG9jdW1lbnRQYXRoLmRlZmF1bHRPcHRpb25zLl9pZDtcbiAgaWYgKHNjaGVtYVR5cGVJZE9wdGlvbiAhPSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5faWQgPSBzY2hlbWFUeXBlSWRPcHRpb247XG4gIH1cblxuICBzY2hlbWEgPSBoYW5kbGVJZE9wdGlvbihzY2hlbWEsIG9wdGlvbnMpO1xuXG4gIHRoaXMuY2FzdGVyID0gX2NyZWF0ZUNvbnN0cnVjdG9yKHNjaGVtYSwgbnVsbCwgb3B0aW9ucyk7XG4gIHRoaXMuY2FzdGVyLnBhdGggPSBwYXRoO1xuICB0aGlzLmNhc3Rlci5wcm90b3R5cGUuJGJhc2VQYXRoID0gcGF0aDtcbiAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIHRoaXMuJGlzU2luZ2xlTmVzdGVkID0gdHJ1ZTtcbiAgdGhpcy5iYXNlID0gc2NoZW1hLmJhc2U7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBwYXRoLCBvcHRpb25zLCAnRW1iZWRkZWQnKTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdWJkb2N1bWVudFBhdGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TdWJkb2N1bWVudFBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViZG9jdW1lbnRQYXRoO1xuU3ViZG9jdW1lbnRQYXRoLnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFTdWJkb2N1bWVudE9wdGlvbnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2NyZWF0ZUNvbnN0cnVjdG9yKHNjaGVtYSwgYmFzZUNsYXNzLCBvcHRpb25zKSB7XG4gIC8vIGxhenkgbG9hZFxuICBTdWJkb2N1bWVudCB8fCAoU3ViZG9jdW1lbnQgPSByZXF1aXJlKCcuLi90eXBlcy9zdWJkb2N1bWVudCcpKTtcblxuICBjb25zdCBfZW1iZWRkZWQgPSBmdW5jdGlvbiBTaW5nbGVOZXN0ZWQodmFsdWUsIHBhdGgsIHBhcmVudCkge1xuICAgIHRoaXMuJF9fcGFyZW50ID0gcGFyZW50O1xuICAgIFN1YmRvY3VtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4kc2Vzc2lvbihwYXJlbnQuJHNlc3Npb24oKSk7XG4gIH07XG5cbiAgc2NoZW1hLl9wcmVDb21waWxlKCk7XG5cbiAgY29uc3QgcHJvdG8gPSBiYXNlQ2xhc3MgIT0gbnVsbCA/IGJhc2VDbGFzcy5wcm90b3R5cGUgOiBTdWJkb2N1bWVudC5wcm90b3R5cGU7XG4gIF9lbWJlZGRlZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgX2VtYmVkZGVkLnByb3RvdHlwZS4kX19zZXRTY2hlbWEoc2NoZW1hKTtcbiAgX2VtYmVkZGVkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9lbWJlZGRlZDtcbiAgX2VtYmVkZGVkLiRfX3JlcXVpcmVkID0gb3B0aW9ucz8ucmVxdWlyZWQ7XG4gIF9lbWJlZGRlZC5iYXNlID0gc2NoZW1hLmJhc2U7XG4gIF9lbWJlZGRlZC5zY2hlbWEgPSBzY2hlbWE7XG4gIF9lbWJlZGRlZC4kaXNTaW5nbGVOZXN0ZWQgPSB0cnVlO1xuICBfZW1iZWRkZWQuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBfZW1iZWRkZWQucHJvdG90eXBlLnRvQlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgfTtcblxuICAvLyBhcHBseSBtZXRob2RzXG4gIGZvciAoY29uc3QgaSBpbiBzY2hlbWEubWV0aG9kcykge1xuICAgIF9lbWJlZGRlZC5wcm90b3R5cGVbaV0gPSBzY2hlbWEubWV0aG9kc1tpXTtcbiAgfVxuXG4gIC8vIGFwcGx5IHN0YXRpY3NcbiAgZm9yIChjb25zdCBpIGluIHNjaGVtYS5zdGF0aWNzKSB7XG4gICAgX2VtYmVkZGVkW2ldID0gc2NoZW1hLnN0YXRpY3NbaV07XG4gIH1cblxuICBmb3IgKGNvbnN0IGkgaW4gRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIF9lbWJlZGRlZFtpXSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGVbaV07XG4gIH1cblxuICByZXR1cm4gX2VtYmVkZGVkO1xufVxuXG4vKipcbiAqIFNwZWNpYWwgY2FzZSBmb3Igd2hlbiB1c2VycyB1c2UgYSBjb21tb24gbG9jYXRpb24gc2NoZW1hIHRvIHJlcHJlc2VudFxuICogbG9jYXRpb25zIGZvciB1c2Ugd2l0aCAkZ2VvV2l0aGluLlxuICogaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2dlb1dpdGhpbi9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdWJkb2N1bWVudFBhdGgucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRnZW9XaXRoaW4gPSBmdW5jdGlvbiBoYW5kbGUkZ2VvV2l0aGluKHZhbCwgY29udGV4dCkge1xuICByZXR1cm4geyAkZ2VvbWV0cnk6IHRoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbC4kZ2VvbWV0cnksIGNvbnRleHQpIH07XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblN1YmRvY3VtZW50UGF0aC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJG5lYXIgPVxuU3ViZG9jdW1lbnRQYXRoLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycy4kbmVhclNwaGVyZSA9IGdlb3NwYXRpYWwuY2FzdCRuZWFyO1xuXG5TdWJkb2N1bWVudFBhdGgucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiR3aXRoaW4gPVxuU3ViZG9jdW1lbnRQYXRoLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycy4kZ2VvV2l0aGluID0gZ2Vvc3BhdGlhbC5jYXN0JHdpdGhpbjtcblxuU3ViZG9jdW1lbnRQYXRoLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycy4kZ2VvSW50ZXJzZWN0cyA9XG4gIGdlb3NwYXRpYWwuY2FzdCRnZW9JbnRlcnNlY3RzO1xuXG5TdWJkb2N1bWVudFBhdGgucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRtaW5EaXN0YW5jZSA9IGNhc3RUb051bWJlcjtcblN1YmRvY3VtZW50UGF0aC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJG1heERpc3RhbmNlID0gY2FzdFRvTnVtYmVyO1xuXG5TdWJkb2N1bWVudFBhdGgucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRleGlzdHMgPSAkZXhpc3RzO1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdWJkb2N1bWVudFBhdGgucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWwsIGRvYywgaW5pdCwgcHJpb3JWYWwsIG9wdGlvbnMpIHtcbiAgaWYgKHZhbCAmJiB2YWwuJGlzU2luZ2xlTmVzdGVkICYmIHZhbC5wYXJlbnQgPT09IGRvYykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodmFsICE9IG51bGwgJiYgKHR5cGVvZiB2YWwgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkodmFsKSkpIHtcbiAgICB0aHJvdyBuZXcgT2JqZWN0RXhwZWN0ZWRFcnJvcih0aGlzLnBhdGgsIHZhbCk7XG4gIH1cblxuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5UGF0aCA9IHRoaXMuc2NoZW1hLnBhdGgodGhpcy5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5KTtcbiAgY29uc3QgZGVmYXVsdERpc2NyaW1pbmF0b3JWYWx1ZSA9IGRpc2NyaW1pbmF0b3JLZXlQYXRoID09IG51bGwgPyBudWxsIDogZGlzY3JpbWluYXRvcktleVBhdGguZ2V0RGVmYXVsdChkb2MpO1xuICBjb25zdCBDb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yKHRoaXMuY2FzdGVyLCB2YWwsIGRlZmF1bHREaXNjcmltaW5hdG9yVmFsdWUpO1xuXG4gIGxldCBzdWJkb2M7XG5cbiAgLy8gT25seSBwdWxsIHJlbGV2YW50IHNlbGVjdGVkIHBhdGhzIGFuZCBwdWxsIG91dCB0aGUgYmFzZSBwYXRoXG4gIGNvbnN0IHBhcmVudFNlbGVjdGVkID0gZG9jICYmIGRvYy4kX18gJiYgZG9jLiRfXy5zZWxlY3RlZDtcbiAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgY29uc3Qgc2VsZWN0ZWQgPSBwYXJlbnRTZWxlY3RlZCA9PSBudWxsID8gbnVsbCA6IE9iamVjdC5rZXlzKHBhcmVudFNlbGVjdGVkKS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKHBhdGggKyAnLicpKSB7XG4gICAgICBvYmogPSBvYmogfHwge307XG4gICAgICBvYmpba2V5LnN1YnN0cmluZyhwYXRoLmxlbmd0aCArIDEpXSA9IHBhcmVudFNlbGVjdGVkW2tleV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH0sIG51bGwpO1xuICBpZiAoaW5pdCkge1xuICAgIHN1YmRvYyA9IG5ldyBDb25zdHJ1Y3Rvcih2b2lkIDAsIHNlbGVjdGVkLCBkb2MsIGZhbHNlLCB7IGRlZmF1bHRzOiBmYWxzZSB9KTtcbiAgICBkZWxldGUgc3ViZG9jLiRfXy5kZWZhdWx0cztcbiAgICBzdWJkb2MuJGluaXQodmFsKTtcbiAgICBjb25zdCBleGNsdWRlID0gaXNFeGNsdXNpdmUoc2VsZWN0ZWQpO1xuICAgIGFwcGx5RGVmYXVsdHMoc3ViZG9jLCBzZWxlY3RlZCwgZXhjbHVkZSk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgcHJpb3JEb2M6IHByaW9yVmFsIH0pO1xuICAgIGlmIChPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih7fSwgc2VsZWN0ZWQsIGRvYywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHZhbCwgc2VsZWN0ZWQsIGRvYywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBzdWJkb2M7XG59O1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyeVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbJGNvbmRpdGlvbmFsXSBvcHRpb25hbCBxdWVyeSBvcGVyYXRvciAobGlrZSBgJGVxYCBvciBgJGluYClcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3ViZG9jdW1lbnRQYXRoLnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZGl0aW9uYWwsIHZhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICBsZXQgaGFuZGxlcjtcbiAgaWYgKCRjb25kaXRpb25hbCAhPSBudWxsKSB7XG4gICAgaGFuZGxlciA9IHRoaXMuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgJyArICRjb25kaXRpb25hbCk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsKTtcbiAgfVxuICBpZiAodmFsID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY29uc3QgQ29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzLmNhc3RlciwgdmFsKTtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMucnVuU2V0dGVycykge1xuICAgIHZhbCA9IHRoaXMuX2FwcGx5U2V0dGVycyh2YWwsIGNvbnRleHQpO1xuICB9XG5cbiAgY29uc3Qgb3ZlcnJpZGVTdHJpY3QgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5zdHJpY3QgIT0gbnVsbCA/XG4gICAgb3B0aW9ucy5zdHJpY3QgOlxuICAgIHZvaWQgMDtcblxuICB0cnkge1xuICAgIHZhbCA9IG5ldyBDb25zdHJ1Y3Rvcih2YWwsIG92ZXJyaWRlU3RyaWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBNYWtlIHN1cmUgd2UgYWx3YXlzIHdyYXAgaW4gYSBDYXN0RXJyb3IgKGdoLTY4MDMpXG4gICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBDYXN0RXJyb3IpKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdFbWJlZGRlZCcsIHZhbCwgdGhpcy5wYXRoLCBlcnJvciwgdGhpcyk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIEFzeW5jIHZhbGlkYXRpb24gb24gdGhpcyBzaW5nbGUgbmVzdGVkIGRvYy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdWJkb2N1bWVudFBhdGgucHJvdG90eXBlLmRvVmFsaWRhdGUgPSBmdW5jdGlvbih2YWx1ZSwgZm4sIHNjb3BlLCBvcHRpb25zKSB7XG4gIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXIsIHZhbHVlKTtcblxuICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHZhbHVlID0gbmV3IENvbnN0cnVjdG9yKHZhbHVlLCBudWxsLCAoc2NvcGUgIT0gbnVsbCAmJiBzY29wZS4kX18gIT0gbnVsbCkgPyBzY29wZSA6IG51bGwpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwU2NoZW1hVmFsaWRhdG9ycykge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBmbihudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnZhbGlkYXRlKCkudGhlbigoKSA9PiBmbihudWxsKSwgZXJyID0+IGZuKGVycikpO1xuICB9XG5cbiAgU2NoZW1hVHlwZS5wcm90b3R5cGUuZG9WYWxpZGF0ZS5jYWxsKHRoaXMsIHZhbHVlLCBmdW5jdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZuKGVycm9yKTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZuKG51bGwpO1xuICAgIH1cblxuICAgIHZhbHVlLnZhbGlkYXRlKCkudGhlbigoKSA9PiBmbihudWxsKSwgZXJyID0+IGZuKGVycikpO1xuICB9LCBzY29wZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgdmFsaWRhdGUgdGhpcyBzaW5nbGUgbmVzdGVkIGRvY1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN1YmRvY3VtZW50UGF0aC5wcm90b3R5cGUuZG9WYWxpZGF0ZVN5bmMgPSBmdW5jdGlvbih2YWx1ZSwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnNraXBTY2hlbWFWYWxpZGF0b3JzKSB7XG4gICAgY29uc3Qgc2NoZW1hVHlwZUVycm9yID0gU2NoZW1hVHlwZS5wcm90b3R5cGUuZG9WYWxpZGF0ZVN5bmMuY2FsbCh0aGlzLCB2YWx1ZSwgc2NvcGUpO1xuICAgIGlmIChzY2hlbWFUeXBlRXJyb3IpIHtcbiAgICAgIHJldHVybiBzY2hlbWFUeXBlRXJyb3I7XG4gICAgfVxuICB9XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHZhbHVlLnZhbGlkYXRlU3luYygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgZGlzY3JpbWluYXRvciB0byB0aGlzIHNpbmdsZSBuZXN0ZWQgc3ViZG9jdW1lbnQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzaGFwZVNjaGVtYSA9IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9LCB7IGRpc2NyaW1pbmF0b3JLZXk6ICdraW5kJyB9KTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEoeyBzaGFwZTogc2hhcGVTY2hlbWEgfSk7XG4gKlxuICogICAgIGNvbnN0IHNpbmdsZU5lc3RlZFBhdGggPSBwYXJlbnRTY2hlbWEucGF0aCgnc2hhcGUnKTtcbiAqICAgICBzaW5nbGVOZXN0ZWRQYXRoLmRpc2NyaW1pbmF0b3IoJ0NpcmNsZScsIFNjaGVtYSh7IHJhZGl1czogTnVtYmVyIH0pKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYSBmaWVsZHMgdG8gYWRkIHRvIHRoZSBzY2hlbWEgZm9yIGluc3RhbmNlcyBvZiB0aGlzIHN1Yi1jbGFzc1xuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0aW9uc10gSWYgc3RyaW5nLCBzYW1lIGFzIGBvcHRpb25zLnZhbHVlYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy52YWx1ZV0gdGhlIHN0cmluZyBzdG9yZWQgaW4gdGhlIGBkaXNjcmltaW5hdG9yS2V5YCBwcm9wZXJ0eS4gSWYgbm90IHNwZWNpZmllZCwgTW9uZ29vc2UgdXNlcyB0aGUgYG5hbWVgIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xvbmU9dHJ1ZV0gQnkgZGVmYXVsdCwgYGRpc2NyaW1pbmF0b3IoKWAgY2xvbmVzIHRoZSBnaXZlbiBgc2NoZW1hYC4gU2V0IHRvIGBmYWxzZWAgdG8gc2tpcCBjbG9uaW5nLlxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBjb25zdHJ1Y3RvciBNb25nb29zZSB3aWxsIHVzZSBmb3IgY3JlYXRpbmcgaW5zdGFuY2VzIG9mIHRoaXMgZGlzY3JpbWluYXRvciBtb2RlbFxuICogQHNlZSBkaXNjcmltaW5hdG9ycyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZGlzY3JpbWluYXRvcnMuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TdWJkb2N1bWVudFBhdGgucHJvdG90eXBlLmRpc2NyaW1pbmF0b3IgPSBmdW5jdGlvbihuYW1lLCBzY2hlbWEsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHZhbHVlID0gdXRpbHMuaXNQT0pPKG9wdGlvbnMpID8gb3B0aW9ucy52YWx1ZSA6IG9wdGlvbnM7XG4gIGNvbnN0IGNsb25lID0gdHlwZW9mIG9wdGlvbnMuY2xvbmUgPT09ICdib29sZWFuJ1xuICAgID8gb3B0aW9ucy5jbG9uZVxuICAgIDogdHJ1ZTtcblxuICBpZiAoc2NoZW1hLmluc3RhbmNlT2ZTY2hlbWEgJiYgY2xvbmUpIHtcbiAgICBzY2hlbWEgPSBzY2hlbWEuY2xvbmUoKTtcbiAgfVxuXG4gIHNjaGVtYSA9IGRpc2NyaW1pbmF0b3IodGhpcy5jYXN0ZXIsIG5hbWUsIHNjaGVtYSwgdmFsdWUpO1xuXG4gIHRoaXMuY2FzdGVyLmRpc2NyaW1pbmF0b3JzW25hbWVdID0gX2NyZWF0ZUNvbnN0cnVjdG9yKHNjaGVtYSwgdGhpcy5jYXN0ZXIpO1xuXG4gIHJldHVybiB0aGlzLmNhc3Rlci5kaXNjcmltaW5hdG9yc1tuYW1lXTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnRQYXRoLmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgU3ViZG9jdW1lbnRQYXRoIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIG51bWJlcnMgaGF2ZSBvcHRpb24gYG1pbmAgZXF1YWwgdG8gMC5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuU3ViZG9jdW1lbnRQYXRoLnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblN1YmRvY3VtZW50UGF0aC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU3ViZG9jdW1lbnRQYXRoLnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIFN1YmRvY3VtZW50UGF0aCBpbnN0YW5jZXNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblN1YmRvY3VtZW50UGF0aC5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdWJkb2N1bWVudFBhdGgucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgcmV0dXJuIHsgcGF0aDogdGhpcy5wYXRoLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMgfTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnRQYXRoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzY2hlbWF0eXBlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoXG4gICAgdGhpcy5zY2hlbWEsXG4gICAgdGhpcy5wYXRoLFxuICAgIHsgLi4udGhpcy5vcHRpb25zLCBfc2tpcEFwcGx5RGlzY3JpbWluYXRvcnM6IHRydWUgfVxuICApO1xuICBzY2hlbWF0eXBlLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuc2xpY2UoKTtcbiAgaWYgKHRoaXMucmVxdWlyZWRWYWxpZGF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgIHNjaGVtYXR5cGUucmVxdWlyZWRWYWxpZGF0b3IgPSB0aGlzLnJlcXVpcmVkVmFsaWRhdG9yO1xuICB9XG4gIHNjaGVtYXR5cGUuY2FzdGVyLmRpc2NyaW1pbmF0b3JzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jYXN0ZXIuZGlzY3JpbWluYXRvcnMpO1xuICByZXR1cm4gc2NoZW1hdHlwZTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/SubdocumentPath.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/array.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/array.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = __webpack_require__(/*! ./operators/exists */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/exists.js\");\nconst $type = __webpack_require__(/*! ./operators/type */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/type.js\");\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst SchemaArrayOptions = __webpack_require__(/*! ../options/SchemaArrayOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaArrayOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst CastError = SchemaType.CastError;\nconst Mixed = __webpack_require__(/*! ./mixed */ \"(api)/../server/node_modules/mongoose/lib/schema/mixed.js\");\nconst arrayDepth = __webpack_require__(/*! ../helpers/arrayDepth */ \"(api)/../server/node_modules/mongoose/lib/helpers/arrayDepth.js\");\nconst cast = __webpack_require__(/*! ../cast */ \"(api)/../server/node_modules/mongoose/lib/cast.js\");\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst isOperator = __webpack_require__(/*! ../helpers/query/isOperator */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/isOperator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst castToNumber = (__webpack_require__(/*! ./operators/helpers */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/helpers.js\").castToNumber);\nconst geospatial = __webpack_require__(/*! ./operators/geospatial */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/geospatial.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../helpers/discriminator/getDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = (__webpack_require__(/*! ../types */ \"(api)/../server/node_modules/mongoose/lib/types/index.js\").Embedded));\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = __webpack_require__(/*! ./index.js */ \"(api)/../server/node_modules/mongoose/lib/schema/index.js\");\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n\n    this.$embeddedSchemaType = this.caster;\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function() {\n      // Leave it up to `cast()` to convert the array\n      return fn\n        ? defaultArr.call(this)\n        : defaultArr != null\n          ? [].concat(defaultArr)\n          : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\nSchemaArray.setters = [];\n\n/**\n * Attaches a getter for all Array instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaArray.get = SchemaType.get;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = arr &&\n    arr.caster &&\n    arr.caster.instance;\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray &&\n      SchemaArray.options.castNonArrays &&\n      !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr.$isMongooseArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = (__webpack_require__(/*! ../types */ \"(api)/../server/node_modules/mongoose/lib/types/index.js\").Array));\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    let path = options.path || this.path;\n    if (options.arrayPathIndex != null) {\n      path += '.' + options.arrayPathIndex;\n    }\n    value = MongooseArray(rawValue, path, doc, this);\n    rawValue = value.__array;\n\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;\n  if (init || castNonArraysOption) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = (__webpack_require__(/*! ../types */ \"(api)/../server/node_modules/mongoose/lib/types/index.js\").Array));\n\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.discriminator = function(...args) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(...args);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\nSchemaArray.prototype._castForQuery = function(val, context) {\n  let Constructor = this.casterConstructor;\n\n  if (val &&\n      Constructor.discriminators &&\n      Constructor.schema &&\n      Constructor.schema.options &&\n      Constructor.schema.options.discriminatorKey) {\n    if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  const proto = this.casterConstructor.prototype;\n  const protoCastForQuery = proto && proto.castForQuery;\n  const protoCast = proto && proto.cast;\n  const constructorCastForQuery = Constructor.castForQuery;\n  const caster = this.caster;\n\n  if (Array.isArray(val)) {\n    this.setters.reverse().forEach(setter => {\n      val = setter.call(this, val, this);\n    });\n    val = val.map(function(v) {\n      if (utils.isObject(v) && v.$elemMatch) {\n        return v;\n      }\n      if (protoCastForQuery) {\n        v = protoCastForQuery.call(caster, null, v, context);\n        return v;\n      } else if (protoCast) {\n        v = protoCast.call(caster, v);\n        return v;\n      } else if (constructorCastForQuery) {\n        v = constructorCastForQuery.call(caster, null, v, context);\n        return v;\n      }\n      if (v != null) {\n        v = new Constructor(v);\n        return v;\n      }\n      return v;\n    });\n  } else if (protoCastForQuery) {\n    val = protoCastForQuery.call(caster, null, val, context);\n  } else if (protoCast) {\n    val = protoCast.call(caster, val);\n  } else if (constructorCastForQuery) {\n    val = constructorCastForQuery.call(caster, null, val, context);\n  } else if (val != null) {\n    val = new Constructor(val);\n  }\n\n  return val;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    return handler.call(this, val, context);\n  } else {\n    return this._castForQuery(val, context);\n  }\n};\n\nfunction cast$all(val, context) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map((v) => {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return { $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context) };\n    }\n\n    const o = {};\n    o[this.path] = v;\n    return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];\n  }, this);\n\n  return this.castForQuery(null, val, context);\n}\n\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this &&\n    this.casterConstructor &&\n    this.casterConstructor.schema &&\n    this.casterConstructor.schema.options &&\n    this.casterConstructor.schema.options.discriminatorKey;\n  const discriminators = this &&\n  this.casterConstructor &&\n  this.casterConstructor.schema &&\n  this.casterConstructor.schema.discriminators || {};\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);\n  }\n  const schema = this.casterConstructor.schema ?? context.schema;\n  return cast(schema, val, null, this && this.$$context);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema, obj, null, this && this.$$context));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$not =\nhandle.$regex =\nhandle.$ne = SchemaArray.prototype._castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2FycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLDRGQUFrQjtBQUN4QyxzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBd0I7QUFDdEQsMkJBQTJCLG1CQUFPLENBQUMsOEdBQStCO0FBQ2xFLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFlO0FBQzFDO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDBFQUFTO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLDhGQUF1QjtBQUNsRCxhQUFhLG1CQUFPLENBQUMsa0VBQVM7QUFDOUIsY0FBYyxtQkFBTyxDQUFDLG9GQUFrQjtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQywwR0FBNkI7QUFDeEQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxvRUFBVTtBQUNoQyxxQkFBcUIsc0lBQTJDO0FBQ2hFLG1CQUFtQixtQkFBTyxDQUFDLHdHQUF3QjtBQUNuRCxnQ0FBZ0MsbUJBQU8sQ0FBQyxvSkFBa0Q7O0FBRTFGO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQywwR0FBNEI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFP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ZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcc2NoZW1hXFxhcnJheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCAkZXhpc3RzID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZXhpc3RzJyk7XG5jb25zdCAkdHlwZSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3R5cGUnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBTY2hlbWFBcnJheU9wdGlvbnMgPSByZXF1aXJlKCcuLi9vcHRpb25zL1NjaGVtYUFycmF5T3B0aW9ucycpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYXR5cGUnKTtcbmNvbnN0IENhc3RFcnJvciA9IFNjaGVtYVR5cGUuQ2FzdEVycm9yO1xuY29uc3QgTWl4ZWQgPSByZXF1aXJlKCcuL21peGVkJyk7XG5jb25zdCBhcnJheURlcHRoID0gcmVxdWlyZSgnLi4vaGVscGVycy9hcnJheURlcHRoJyk7XG5jb25zdCBjYXN0ID0gcmVxdWlyZSgnLi4vY2FzdCcpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBpc09wZXJhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9xdWVyeS9pc09wZXJhdG9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgY2FzdFRvTnVtYmVyID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvaGVscGVycycpLmNhc3RUb051bWJlcjtcbmNvbnN0IGdlb3NwYXRpYWwgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9nZW9zcGF0aWFsJyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuXG5sZXQgTW9uZ29vc2VBcnJheTtcbmxldCBFbWJlZGRlZERvYztcblxuY29uc3QgaXNOZXN0ZWRBcnJheVN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjaXNOZXN0ZWRBcnJheScpO1xuY29uc3QgZW1wdHlPcHRzID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8qKlxuICogQXJyYXkgU2NoZW1hVHlwZSBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U2NoZW1hVHlwZX0gY2FzdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFPcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFBcnJheShrZXksIGNhc3QsIG9wdGlvbnMsIHNjaGVtYU9wdGlvbnMpIHtcbiAgLy8gbGF6eSBsb2FkXG4gIEVtYmVkZGVkRG9jIHx8IChFbWJlZGRlZERvYyA9IHJlcXVpcmUoJy4uL3R5cGVzJykuRW1iZWRkZWQpO1xuXG4gIGxldCB0eXBlS2V5ID0gJ3R5cGUnO1xuICBpZiAoc2NoZW1hT3B0aW9ucyAmJiBzY2hlbWFPcHRpb25zLnR5cGVLZXkpIHtcbiAgICB0eXBlS2V5ID0gc2NoZW1hT3B0aW9ucy50eXBlS2V5O1xuICB9XG4gIHRoaXMuc2NoZW1hT3B0aW9ucyA9IHNjaGVtYU9wdGlvbnM7XG5cbiAgaWYgKGNhc3QpIHtcbiAgICBsZXQgY2FzdE9wdGlvbnMgPSB7fTtcblxuICAgIGlmICh1dGlscy5pc1BPSk8oY2FzdCkpIHtcbiAgICAgIGlmIChjYXN0W3R5cGVLZXldKSB7XG4gICAgICAgIC8vIHN1cHBvcnQgeyB0eXBlOiBXb290IH1cbiAgICAgICAgY2FzdE9wdGlvbnMgPSBjbG9uZShjYXN0KTsgLy8gZG8gbm90IGFsdGVyIHVzZXIgYXJndW1lbnRzXG4gICAgICAgIGRlbGV0ZSBjYXN0T3B0aW9uc1t0eXBlS2V5XTtcbiAgICAgICAgY2FzdCA9IGNhc3RbdHlwZUtleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXN0ID0gTWl4ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnJlZiAhPSBudWxsICYmIGNhc3RPcHRpb25zLnJlZiA9PSBudWxsKSB7XG4gICAgICBjYXN0T3B0aW9ucy5yZWYgPSBvcHRpb25zLnJlZjtcbiAgICB9XG5cbiAgICBpZiAoY2FzdCA9PT0gT2JqZWN0KSB7XG4gICAgICBjYXN0ID0gTWl4ZWQ7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydCB7IHR5cGU6ICdTdHJpbmcnIH1cbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIGNhc3QgPT09ICdzdHJpbmcnXG4gICAgICA/IGNhc3RcbiAgICAgIDogdXRpbHMuZ2V0RnVuY3Rpb25OYW1lKGNhc3QpO1xuXG4gICAgY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG4gICAgY29uc3QgY2FzdGVyID0gVHlwZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBUeXBlc1tuYW1lXSA6IGNhc3Q7XG5cbiAgICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yID0gY2FzdGVyO1xuXG4gICAgaWYgKHRoaXMuY2FzdGVyQ29uc3RydWN0b3IgaW5zdGFuY2VvZiBTY2hlbWFBcnJheSkge1xuICAgICAgdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvcltpc05lc3RlZEFycmF5U3ltYm9sXSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYXN0ZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgIWNhc3Rlci4kaXNBcnJheVN1YmRvY3VtZW50ICYmXG4gICAgICAgICFjYXN0ZXIuJGlzU2NoZW1hTWFwKSB7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5jYXN0ZXIgaW5zdGFuY2VvZiBFbWJlZGRlZERvYyA/IG51bGwgOiBrZXk7XG4gICAgICB0aGlzLmNhc3RlciA9IG5ldyBjYXN0ZXIocGF0aCwgY2FzdE9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhc3RlciA9IGNhc3RlcjtcbiAgICAgIGlmICghKHRoaXMuY2FzdGVyIGluc3RhbmNlb2YgRW1iZWRkZWREb2MpKSB7XG4gICAgICAgIHRoaXMuY2FzdGVyLnBhdGggPSBrZXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4kZW1iZWRkZWRTY2hlbWFUeXBlID0gdGhpcy5jYXN0ZXI7XG4gIH1cblxuICB0aGlzLiRpc01vbmdvb3NlQXJyYXkgPSB0cnVlO1xuXG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdBcnJheScpO1xuXG4gIGxldCBkZWZhdWx0QXJyO1xuICBsZXQgZm47XG5cbiAgaWYgKHRoaXMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBkZWZhdWx0QXJyID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgZm4gPSB0eXBlb2YgZGVmYXVsdEFyciA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghKCdkZWZhdWx0VmFsdWUnIGluIHRoaXMpIHx8IHRoaXMuZGVmYXVsdFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBkZWZhdWx0Rm4gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIExlYXZlIGl0IHVwIHRvIGBjYXN0KClgIHRvIGNvbnZlcnQgdGhlIGFycmF5XG4gICAgICByZXR1cm4gZm5cbiAgICAgICAgPyBkZWZhdWx0QXJyLmNhbGwodGhpcylcbiAgICAgICAgOiBkZWZhdWx0QXJyICE9IG51bGxcbiAgICAgICAgICA/IFtdLmNvbmNhdChkZWZhdWx0QXJyKVxuICAgICAgICAgIDogW107XG4gICAgfTtcbiAgICBkZWZhdWx0Rm4uJHJ1bkJlZm9yZVNldHRlcnMgPSAhZm47XG4gICAgdGhpcy5kZWZhdWx0KGRlZmF1bHRGbik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFBcnJheS5zY2hlbWFOYW1lID0gJ0FycmF5JztcblxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGFsbCBhcnJheXMuXG4gKlxuICogLSBgY2FzdE5vbkFycmF5c2A6IGB0cnVlYCBieSBkZWZhdWx0LiBJZiBgZmFsc2VgLCBNb25nb29zZSB3aWxsIHRocm93IGEgQ2FzdEVycm9yIHdoZW4gYSB2YWx1ZSBpc24ndCBhbiBhcnJheS4gSWYgYHRydWVgLCBNb25nb29zZSB3aWxsIHdyYXAgdGhlIHByb3ZpZGVkIHZhbHVlIGluIGFuIGFycmF5IGJlZm9yZSBjYXN0aW5nLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQXJyYXkub3B0aW9ucyA9IHsgY2FzdE5vbkFycmF5czogdHJ1ZSB9O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUFycmF5LmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgQXJyYXkgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgQXJyYXkgaW5zdGFuY2VzIGhhdmUgYHJlcXVpcmVkYCBvZiB0cnVlIGJ5IGRlZmF1bHQuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkFycmF5LnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IHRlc3Q6IEFycmF5IH0pKTtcbiAqICAgICBuZXcgVXNlcih7IH0pLnZhbGlkYXRlU3luYygpLmVycm9ycy50ZXN0Lm1lc3NhZ2U7IC8vIFBhdGggYHRlc3RgIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hQXJyYXkuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYUFycmF5LnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIEFycmF5IGluc3RhbmNlc1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQXJyYXkuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFBcnJheS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYUFycmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYUFycmF5O1xuU2NoZW1hQXJyYXkucHJvdG90eXBlLk9wdGlvbnNDb25zdHJ1Y3RvciA9IFNjaGVtYUFycmF5T3B0aW9ucztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFBcnJheS5fY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGFuIGFycmF5XG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBSZXF1aXJlIG5vbi1lbXB0eSBhcnJheSB0byBwYXNzIGByZXF1aXJlZGAgY2hlY2tcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuQXJyYXkuY2hlY2tSZXF1aXJlZCh2ID0+IEFycmF5LmlzQXJyYXkodikgJiYgdi5sZW5ndGgpO1xuICpcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoeyBhcnI6IHsgdHlwZTogQXJyYXksIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgbmV3IE0oeyBhcnI6IFtdIH0pLnZhbGlkYXRlU3luYygpOyAvLyBgbnVsbGAsIHZhbGlkYXRpb24gZmFpbHMhXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQXJyYXkuY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIHRoZSBgcmVxdWlyZWRgIHZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbiBjaGVja1JlcXVpcmVkKHZhbHVlLCBkb2MpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgdHJ1ZSkpIHtcbiAgICByZXR1cm4gISF2YWx1ZTtcbiAgfVxuXG4gIC8vIGByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoKWAgZG9lcyAqKm5vdCoqIGNvcHkgc3RhdGljIHByb3BlcnRpZXMsIGFuZFxuICAvLyBwbHVnaW5zIGxpa2UgbW9uZ29vc2UtZmxvYXQgdXNlIGBpbmhlcml0cygpYCBmb3IgcHJlLUVTNi5cbiAgY29uc3QgX2NoZWNrUmVxdWlyZWQgPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQoKSA6XG4gICAgU2NoZW1hQXJyYXkuY2hlY2tSZXF1aXJlZCgpO1xuXG4gIHJldHVybiBfY2hlY2tSZXF1aXJlZCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gZW51bSB2YWxpZGF0b3IgaWYgdGhpcyBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIG9yIG51bWJlcnMuIEVxdWl2YWxlbnQgdG9cbiAqIGBTY2hlbWFTdHJpbmcucHJvdG90eXBlLmVudW0oKWAgb3IgYFNjaGVtYU51bWJlci5wcm90b3R5cGUuZW51bSgpYFxuICpcbiAqIEBwYXJhbSB7Li4uU3RyaW5nfE9iamVjdH0gW2FyZ3NdIGVudW1lcmF0aW9uIHZhbHVlc1xuICogQHJldHVybiB7U2NoZW1hQXJyYXl9IHRoaXNcbiAqL1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuZW51bSA9IGZ1bmN0aW9uKCkge1xuICBsZXQgYXJyID0gdGhpcztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGFyciAmJlxuICAgIGFyci5jYXN0ZXIgJiZcbiAgICBhcnIuY2FzdGVyLmluc3RhbmNlO1xuICAgIGlmIChpbnN0YW5jZSA9PT0gJ0FycmF5Jykge1xuICAgICAgYXJyID0gYXJyLmNhc3RlcjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UgIT09ICdTdHJpbmcnICYmIGluc3RhbmNlICE9PSAnTnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZW51bWAgY2FuIG9ubHkgYmUgc2V0IG9uIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgbnVtYmVycyAnICtcbiAgICAgICAgJywgbm90ICcgKyBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgbGV0IGVudW1BcnJheSA9IGFyZ3VtZW50cztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3VtZW50cykgJiYgdXRpbHMuaXNPYmplY3QoYXJndW1lbnRzKSkge1xuICAgIGVudW1BcnJheSA9IHV0aWxzLm9iamVjdC52YWxzKGVudW1BcnJheSk7XG4gIH1cblxuICBhcnIuY2FzdGVyLmVudW0uYXBwbHkoYXJyLmNhc3RlciwgZW51bUFycmF5KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlcyB0aGUgZ2V0dGVycyBhcHBsaWNhdGlvbiBmb3IgdGhlIHBvcHVsYXRpb24gc3BlY2lhbC1jYXNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5hcHBseUdldHRlcnMgPSBmdW5jdGlvbih2YWx1ZSwgc2NvcGUpIHtcbiAgaWYgKHNjb3BlICE9IG51bGwgJiYgc2NvcGUuJF9fICE9IG51bGwgJiYgc2NvcGUuJHBvcHVsYXRlZCh0aGlzLnBhdGgpKSB7XG4gICAgLy8gbWVhbnMgdGhlIG9iamVjdCBpZCB3YXMgcG9wdWxhdGVkXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgY29uc3QgcmV0ID0gU2NoZW1hVHlwZS5wcm90b3R5cGUuYXBwbHlHZXR0ZXJzLmNhbGwodGhpcywgdmFsdWUsIHNjb3BlKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5fYXBwbHlTZXR0ZXJzID0gZnVuY3Rpb24odmFsdWUsIHNjb3BlLCBpbml0LCBwcmlvclZhbCkge1xuICBpZiAodGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci4kaXNNb25nb29zZUFycmF5ICYmXG4gICAgICBTY2hlbWFBcnJheS5vcHRpb25zLmNhc3ROb25BcnJheXMgJiZcbiAgICAgICF0aGlzW2lzTmVzdGVkQXJyYXlTeW1ib2xdKSB7XG4gICAgLy8gQ2hlY2sgbmVzdGluZyBsZXZlbHMgYW5kIHdyYXAgaW4gYXJyYXkgaWYgbmVjZXNzYXJ5XG4gICAgbGV0IGRlcHRoID0gMDtcbiAgICBsZXQgYXJyID0gdGhpcztcbiAgICB3aGlsZSAoYXJyICE9IG51bGwgJiZcbiAgICAgIGFyci4kaXNNb25nb29zZUFycmF5ICYmXG4gICAgICAhYXJyLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgKytkZXB0aDtcbiAgICAgIGFyciA9IGFyci5jYXN0ZXJDb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICAvLyBObyBuZWVkIHRvIHdyYXAgZW1wdHkgYXJyYXlzXG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCB2YWx1ZURlcHRoID0gYXJyYXlEZXB0aCh2YWx1ZSk7XG4gICAgICBpZiAodmFsdWVEZXB0aC5taW4gPT09IHZhbHVlRGVwdGgubWF4ICYmIHZhbHVlRGVwdGgubWF4IDwgZGVwdGggJiYgdmFsdWVEZXB0aC5jb250YWluc05vbkFycmF5SXRlbSkge1xuICAgICAgICBmb3IgKGxldCBpID0gdmFsdWVEZXB0aC5tYXg7IGkgPCBkZXB0aDsgKytpKSB7XG4gICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFNjaGVtYVR5cGUucHJvdG90eXBlLl9hcHBseVNldHRlcnMuY2FsbCh0aGlzLCB2YWx1ZSwgc2NvcGUsIGluaXQsIHByaW9yVmFsKTtcbn07XG5cbi8qKlxuICogQ2FzdHMgdmFsdWVzIGZvciBzZXQoKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBkb2N1bWVudCB0aGF0IHRyaWdnZXJzIHRoZSBjYXN0aW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXQgd2hldGhlciB0aGlzIGlzIGFuIGluaXRpYWxpemF0aW9uIGNhc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUsIGRvYywgaW5pdCwgcHJldiwgb3B0aW9ucykge1xuICAvLyBsYXp5IGxvYWRcbiAgTW9uZ29vc2VBcnJheSB8fCAoTW9uZ29vc2VBcnJheSA9IHJlcXVpcmUoJy4uL3R5cGVzJykuQXJyYXkpO1xuXG4gIGxldCBpO1xuICBsZXQgbDtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgaWYgKCFsZW4gJiYgZG9jKSB7XG4gICAgICBjb25zdCBpbmRleGVzID0gZG9jLnNjaGVtYS5pbmRleGVkUGF0aHMoKTtcblxuICAgICAgY29uc3QgYXJyYXlQYXRoID0gdGhpcy5wYXRoO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBhdGhJbmRleCA9IGluZGV4ZXNbaV1bMF1bYXJyYXlQYXRoXTtcbiAgICAgICAgaWYgKHBhdGhJbmRleCA9PT0gJzJkc3BoZXJlJyB8fCBwYXRoSW5kZXggPT09ICcyZCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU3BlY2lhbCBjYXNlOiBpZiB0aGlzIGluZGV4IGlzIG9uIHRoZSBwYXJlbnQgb2Ygd2hhdCBsb29rcyBsaWtlXG4gICAgICAvLyBHZW9KU09OLCBza2lwIHNldHRpbmcgdGhlIGRlZmF1bHQgdG8gZW1wdHkgYXJyYXkgcmU6ICMxNjY4LCAjMzIzM1xuICAgICAgY29uc3QgYXJyYXlHZW9qc29uUGF0aCA9IHRoaXMucGF0aC5lbmRzV2l0aCgnLmNvb3JkaW5hdGVzJykgP1xuICAgICAgICB0aGlzLnBhdGguc3Vic3RyaW5nKDAsIHRoaXMucGF0aC5sYXN0SW5kZXhPZignLicpKSA6IG51bGw7XG4gICAgICBpZiAoYXJyYXlHZW9qc29uUGF0aCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBpbmRleGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHBhdGhJbmRleCA9IGluZGV4ZXNbaV1bMF1bYXJyYXlHZW9qc29uUGF0aF07XG4gICAgICAgICAgaWYgKHBhdGhJbmRleCA9PT0gJzJkc3BoZXJlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IGVtcHR5T3B0cztcblxuICAgIGxldCByYXdWYWx1ZSA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh2YWx1ZSkgPyB2YWx1ZS5fX2FycmF5IDogdmFsdWU7XG4gICAgbGV0IHBhdGggPSBvcHRpb25zLnBhdGggfHwgdGhpcy5wYXRoO1xuICAgIGlmIChvcHRpb25zLmFycmF5UGF0aEluZGV4ICE9IG51bGwpIHtcbiAgICAgIHBhdGggKz0gJy4nICsgb3B0aW9ucy5hcnJheVBhdGhJbmRleDtcbiAgICB9XG4gICAgdmFsdWUgPSBNb25nb29zZUFycmF5KHJhd1ZhbHVlLCBwYXRoLCBkb2MsIHRoaXMpO1xuICAgIHJhd1ZhbHVlID0gdmFsdWUuX19hcnJheTtcblxuICAgIGlmIChpbml0ICYmIGRvYyAhPSBudWxsICYmIGRvYy4kX18gIT0gbnVsbCAmJiBkb2MuJHBvcHVsYXRlZCh0aGlzLnBhdGgpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgY2FzdGVyID0gdGhpcy5jYXN0ZXI7XG4gICAgY29uc3QgaXNNb25nb29zZUFycmF5ID0gY2FzdGVyLiRpc01vbmdvb3NlQXJyYXk7XG4gICAgaWYgKGNhc3RlciAmJiB0aGlzLmNhc3RlckNvbnN0cnVjdG9yICE9PSBNaXhlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbGVuID0gcmF3VmFsdWUubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICAgICAgLy8gUGVyZjogY3JlYXRpbmcgYGFycmF5UGF0aGAgaXMgZXhwZW5zaXZlIGZvciBsYXJnZSBhcnJheXMuXG4gICAgICAgICAgLy8gV2Ugb25seSBuZWVkIGBhcnJheVBhdGhgIGlmIHRoaXMgaXMgYSBuZXN0ZWQgYXJyYXksIHNvXG4gICAgICAgICAgLy8gc2tpcCBpZiBwb3NzaWJsZS5cbiAgICAgICAgICBpZiAoaXNNb25nb29zZUFycmF5KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBvcHRzLmFycmF5UGF0aEluZGV4ID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FzdGVyLl9hcnJheVBhcmVudFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBvcHRzLmFycmF5UGF0aEluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmF3VmFsdWVbaV0gPSBjYXN0ZXIuYXBwbHlTZXR0ZXJzKHJhd1ZhbHVlW2ldLCBkb2MsIGluaXQsIHZvaWQgMCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gcmV0aHJvd1xuICAgICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdbJyArIGUua2luZCArICddJywgdXRpbC5pbnNwZWN0KHZhbHVlKSwgdGhpcy5wYXRoICsgJy4nICsgaSwgZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgY29uc3QgY2FzdE5vbkFycmF5c09wdGlvbiA9IHRoaXMub3B0aW9ucy5jYXN0Tm9uQXJyYXlzICE9IG51bGwgPyB0aGlzLm9wdGlvbnMuY2FzdE5vbkFycmF5cyA6IFNjaGVtYUFycmF5Lm9wdGlvbnMuY2FzdE5vbkFycmF5cztcbiAgaWYgKGluaXQgfHwgY2FzdE5vbkFycmF5c09wdGlvbikge1xuICAgIC8vIGdoLTI0NDI6IGlmIHdlJ3JlIGxvYWRpbmcgdGhpcyBmcm9tIHRoZSBkYiBhbmQgaXRzIG5vdCBhbiBhcnJheSwgbWFya1xuICAgIC8vIHRoZSB3aG9sZSBhcnJheSBhcyBtb2RpZmllZC5cbiAgICBpZiAoISFkb2MgJiYgISFpbml0KSB7XG4gICAgICBkb2MubWFya01vZGlmaWVkKHRoaXMucGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhc3QoW3ZhbHVlXSwgZG9jLCBpbml0KTtcbiAgfVxuXG4gIHRocm93IG5ldyBDYXN0RXJyb3IoJ0FycmF5JywgdXRpbC5pbnNwZWN0KHZhbHVlKSwgdGhpcy5wYXRoLCBudWxsLCB0aGlzKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLl9jYXN0Rm9yUG9wdWxhdGUgPSBmdW5jdGlvbiBfY2FzdEZvclBvcHVsYXRlKHZhbHVlLCBkb2MpIHtcbiAgLy8gbGF6eSBsb2FkXG4gIE1vbmdvb3NlQXJyYXkgfHwgKE1vbmdvb3NlQXJyYXkgPSByZXF1aXJlKCcuLi90eXBlcycpLkFycmF5KTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBsZXQgaTtcbiAgICBjb25zdCByYXdWYWx1ZSA9IHZhbHVlLl9fYXJyYXkgPyB2YWx1ZS5fX2FycmF5IDogdmFsdWU7XG4gICAgY29uc3QgbGVuID0gcmF3VmFsdWUubGVuZ3RoO1xuXG4gICAgY29uc3QgY2FzdGVyID0gdGhpcy5jYXN0ZXI7XG4gICAgaWYgKGNhc3RlciAmJiB0aGlzLmNhc3RlckNvbnN0cnVjdG9yICE9PSBNaXhlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgICAgICAgIC8vIFBlcmY6IGNyZWF0aW5nIGBhcnJheVBhdGhgIGlzIGV4cGVuc2l2ZSBmb3IgbGFyZ2UgYXJyYXlzLlxuICAgICAgICAgIC8vIFdlIG9ubHkgbmVlZCBgYXJyYXlQYXRoYCBpZiB0aGlzIGlzIGEgbmVzdGVkIGFycmF5LCBzb1xuICAgICAgICAgIC8vIHNraXAgaWYgcG9zc2libGUuXG4gICAgICAgICAgaWYgKGNhc3Rlci4kaXNNb25nb29zZUFycmF5ICYmIGNhc3Rlci5fYXJyYXlQYXJlbnRQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9wdHMuYXJyYXlQYXRoSW5kZXggPSBpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJhd1ZhbHVlW2ldID0gY2FzdGVyLmNhc3QocmF3VmFsdWVbaV0sIGRvYywgZmFsc2UsIHZvaWQgMCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gcmV0aHJvd1xuICAgICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdbJyArIGUua2luZCArICddJywgdXRpbC5pbnNwZWN0KHZhbHVlKSwgdGhpcy5wYXRoICsgJy4nICsgaSwgZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdGhyb3cgbmV3IENhc3RFcnJvcignQXJyYXknLCB1dGlsLmluc3BlY3QodmFsdWUpLCB0aGlzLnBhdGgsIG51bGwsIHRoaXMpO1xufTtcblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLiR0b09iamVjdCA9IFNjaGVtYUFycmF5LnByb3RvdHlwZS50b09iamVjdDtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuZGlzY3JpbWluYXRvciA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgbGV0IGFyciA9IHRoaXM7XG4gIHdoaWxlIChhcnIuJGlzTW9uZ29vc2VBcnJheSAmJiAhYXJyLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgIGFyciA9IGFyci5jYXN0ZXJDb25zdHJ1Y3RvcjtcbiAgICBpZiAoYXJyID09IG51bGwgfHwgdHlwZW9mIGFyciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1lvdSBjYW4gb25seSBhZGQgYW4gZW1iZWRkZWQgZGlzY3JpbWluYXRvciBvbiAnICtcbiAgICAgICAgJ2EgZG9jdW1lbnQgYXJyYXksICcgKyB0aGlzLnBhdGggKyAnIGlzIGEgcGxhaW4gYXJyYXknKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyci5kaXNjcmltaW5hdG9yKC4uLmFyZ3MpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7XG4gIGNvbnN0IHNjaGVtYXR5cGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnBhdGgsIHRoaXMuY2FzdGVyLCBvcHRpb25zLCB0aGlzLnNjaGVtYU9wdGlvbnMpO1xuICBzY2hlbWF0eXBlLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuc2xpY2UoKTtcbiAgaWYgKHRoaXMucmVxdWlyZWRWYWxpZGF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgIHNjaGVtYXR5cGUucmVxdWlyZWRWYWxpZGF0b3IgPSB0aGlzLnJlcXVpcmVkVmFsaWRhdG9yO1xuICB9XG4gIHJldHVybiBzY2hlbWF0eXBlO1xufTtcblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLl9jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbih2YWwsIGNvbnRleHQpIHtcbiAgbGV0IENvbnN0cnVjdG9yID0gdGhpcy5jYXN0ZXJDb25zdHJ1Y3RvcjtcblxuICBpZiAodmFsICYmXG4gICAgICBDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9ycyAmJlxuICAgICAgQ29uc3RydWN0b3Iuc2NoZW1hICYmXG4gICAgICBDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucyAmJlxuICAgICAgQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSkge1xuICAgIGlmICh0eXBlb2YgdmFsW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1t2YWxbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV1dKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW3ZhbFtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yQnlWYWx1ZSA9IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzLCB2YWxbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0pO1xuICAgICAgaWYgKGNvbnN0cnVjdG9yQnlWYWx1ZSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yQnlWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBwcm90byA9IHRoaXMuY2FzdGVyQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICBjb25zdCBwcm90b0Nhc3RGb3JRdWVyeSA9IHByb3RvICYmIHByb3RvLmNhc3RGb3JRdWVyeTtcbiAgY29uc3QgcHJvdG9DYXN0ID0gcHJvdG8gJiYgcHJvdG8uY2FzdDtcbiAgY29uc3QgY29uc3RydWN0b3JDYXN0Rm9yUXVlcnkgPSBDb25zdHJ1Y3Rvci5jYXN0Rm9yUXVlcnk7XG4gIGNvbnN0IGNhc3RlciA9IHRoaXMuY2FzdGVyO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICB0aGlzLnNldHRlcnMucmV2ZXJzZSgpLmZvckVhY2goc2V0dGVyID0+IHtcbiAgICAgIHZhbCA9IHNldHRlci5jYWxsKHRoaXMsIHZhbCwgdGhpcyk7XG4gICAgfSk7XG4gICAgdmFsID0gdmFsLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICBpZiAodXRpbHMuaXNPYmplY3QodikgJiYgdi4kZWxlbU1hdGNoKSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfVxuICAgICAgaWYgKHByb3RvQ2FzdEZvclF1ZXJ5KSB7XG4gICAgICAgIHYgPSBwcm90b0Nhc3RGb3JRdWVyeS5jYWxsKGNhc3RlciwgbnVsbCwgdiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlIGlmIChwcm90b0Nhc3QpIHtcbiAgICAgICAgdiA9IHByb3RvQ2FzdC5jYWxsKGNhc3Rlciwgdik7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvckNhc3RGb3JRdWVyeSkge1xuICAgICAgICB2ID0gY29uc3RydWN0b3JDYXN0Rm9yUXVlcnkuY2FsbChjYXN0ZXIsIG51bGwsIHYsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgICAgdiA9IG5ldyBDb25zdHJ1Y3Rvcih2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm90b0Nhc3RGb3JRdWVyeSkge1xuICAgIHZhbCA9IHByb3RvQ2FzdEZvclF1ZXJ5LmNhbGwoY2FzdGVyLCBudWxsLCB2YWwsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHByb3RvQ2FzdCkge1xuICAgIHZhbCA9IHByb3RvQ2FzdC5jYWxsKGNhc3RlciwgdmFsKTtcbiAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvckNhc3RGb3JRdWVyeSkge1xuICAgIHZhbCA9IGNvbnN0cnVjdG9yQ2FzdEZvclF1ZXJ5LmNhbGwoY2FzdGVyLCBudWxsLCB2YWwsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgdmFsID0gbmV3IENvbnN0cnVjdG9yKHZhbCk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBDYXN0cyB2YWx1ZXMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kaXRpb25hbFxuICogQHBhcmFtIHthbnl9IFt2YWx1ZV1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZGl0aW9uYWwsIHZhbCwgY29udGV4dCkge1xuICBsZXQgaGFuZGxlcjtcblxuICBpZiAoJGNvbmRpdGlvbmFsICE9IG51bGwpIHtcbiAgICBoYW5kbGVyID0gdGhpcy4kY29uZGl0aW9uYWxIYW5kbGVyc1skY29uZGl0aW9uYWxdO1xuXG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlICcgKyAkY29uZGl0aW9uYWwgKyAnIHdpdGggQXJyYXkuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB2YWwsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9jYXN0Rm9yUXVlcnkodmFsLCBjb250ZXh0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2FzdCRhbGwodmFsLCBjb250ZXh0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgdmFsID0gW3ZhbF07XG4gIH1cblxuICB2YWwgPSB2YWwubWFwKCh2KSA9PiB7XG4gICAgaWYgKCF1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGlmICh2LiRlbGVtTWF0Y2ggIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgJGVsZW1NYXRjaDogY2FzdCh0aGlzLmNhc3RlckNvbnN0cnVjdG9yLnNjaGVtYSwgdi4kZWxlbU1hdGNoLCBudWxsLCB0aGlzICYmIHRoaXMuJCRjb250ZXh0KSB9O1xuICAgIH1cblxuICAgIGNvbnN0IG8gPSB7fTtcbiAgICBvW3RoaXMucGF0aF0gPSB2O1xuICAgIHJldHVybiBjYXN0KHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hLCBvLCBudWxsLCB0aGlzICYmIHRoaXMuJCRjb250ZXh0KVt0aGlzLnBhdGhdO1xuICB9LCB0aGlzKTtcblxuICByZXR1cm4gdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgdmFsLCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gY2FzdCRlbGVtTWF0Y2godmFsLCBjb250ZXh0KSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbFtrZXldO1xuICAgIGlmIChpc09wZXJhdG9yKGtleSkgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFsW2tleV0gPSB0aGlzLmNhc3RGb3JRdWVyeShrZXksIHZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICAvLyBJcyB0aGlzIGFuIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3IgYW5kIGlzIHRoZSBkaXNjcmltaW5hdG9yIGtleSBzZXQ/XG4gIC8vIElmIHNvLCB1c2UgdGhlIGRpc2NyaW1pbmF0b3Igc2NoZW1hLiBTZWUgZ2gtNzQ0OVxuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gdGhpcyAmJlxuICAgIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IgJiZcbiAgICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yLnNjaGVtYSAmJlxuICAgIHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JzID0gdGhpcyAmJlxuICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yICYmXG4gIHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hICYmXG4gIHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hLmRpc2NyaW1pbmF0b3JzIHx8IHt9O1xuICBpZiAoZGlzY3JpbWluYXRvcktleSAhPSBudWxsICYmXG4gICAgICB2YWxbZGlzY3JpbWluYXRvcktleV0gIT0gbnVsbCAmJlxuICAgICAgZGlzY3JpbWluYXRvcnNbdmFsW2Rpc2NyaW1pbmF0b3JLZXldXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGNhc3QoZGlzY3JpbWluYXRvcnNbdmFsW2Rpc2NyaW1pbmF0b3JLZXldXSwgdmFsLCBudWxsLCB0aGlzICYmIHRoaXMuJCRjb250ZXh0KTtcbiAgfVxuICBjb25zdCBzY2hlbWEgPSB0aGlzLmNhc3RlckNvbnN0cnVjdG9yLnNjaGVtYSA/PyBjb250ZXh0LnNjaGVtYTtcbiAgcmV0dXJuIGNhc3Qoc2NoZW1hLCB2YWwsIG51bGwsIHRoaXMgJiYgdGhpcy4kJGNvbnRleHQpO1xufVxuXG5jb25zdCBoYW5kbGUgPSBTY2hlbWFBcnJheS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7fTtcblxuaGFuZGxlLiRhbGwgPSBjYXN0JGFsbDtcbmhhbmRsZS4kb3B0aW9ucyA9IFN0cmluZztcbmhhbmRsZS4kZWxlbU1hdGNoID0gY2FzdCRlbGVtTWF0Y2g7XG5oYW5kbGUuJGdlb0ludGVyc2VjdHMgPSBnZW9zcGF0aWFsLmNhc3QkZ2VvSW50ZXJzZWN0cztcbmhhbmRsZS4kb3IgPSBjcmVhdGVMb2dpY2FsUXVlcnlPcGVyYXRvckhhbmRsZXIoJyRvcicpO1xuaGFuZGxlLiRhbmQgPSBjcmVhdGVMb2dpY2FsUXVlcnlPcGVyYXRvckhhbmRsZXIoJyRhbmQnKTtcbmhhbmRsZS4kbm9yID0gY3JlYXRlTG9naWNhbFF1ZXJ5T3BlcmF0b3JIYW5kbGVyKCckbm9yJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvZ2ljYWxRdWVyeU9wZXJhdG9ySGFuZGxlcihvcCkge1xuICByZXR1cm4gZnVuY3Rpb24gbG9naWNhbFF1ZXJ5T3BlcmF0b3JIYW5kbGVyKHZhbCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb25kaXRpb25hbCAnICsgb3AgKyAnIHJlcXVpcmVzIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgZm9yIChjb25zdCBvYmogb2YgdmFsKSB7XG4gICAgICByZXQucHVzaChjYXN0KHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hLCBvYmosIG51bGwsIHRoaXMgJiYgdGhpcy4kJGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuXG5oYW5kbGUuJG5lYXIgPVxuaGFuZGxlLiRuZWFyU3BoZXJlID0gZ2Vvc3BhdGlhbC5jYXN0JG5lYXI7XG5cbmhhbmRsZS4kd2l0aGluID1cbmhhbmRsZS4kZ2VvV2l0aGluID0gZ2Vvc3BhdGlhbC5jYXN0JHdpdGhpbjtcblxuaGFuZGxlLiRzaXplID1cbmhhbmRsZS4kbWluRGlzdGFuY2UgPVxuaGFuZGxlLiRtYXhEaXN0YW5jZSA9IGNhc3RUb051bWJlcjtcblxuaGFuZGxlLiRleGlzdHMgPSAkZXhpc3RzO1xuaGFuZGxlLiR0eXBlID0gJHR5cGU7XG5cbmhhbmRsZS4kZXEgPVxuaGFuZGxlLiRndCA9XG5oYW5kbGUuJGd0ZSA9XG5oYW5kbGUuJGx0ID1cbmhhbmRsZS4kbHRlID1cbmhhbmRsZS4kbm90ID1cbmhhbmRsZS4kcmVnZXggPVxuaGFuZGxlLiRuZSA9IFNjaGVtYUFycmF5LnByb3RvdHlwZS5fY2FzdEZvclF1ZXJ5O1xuXG4vLyBgJGluYCBpcyBzcGVjaWFsIGJlY2F1c2UgeW91IGNhbiBhbHNvIGluY2x1ZGUgYW4gZW1wdHkgYXJyYXkgaW4gdGhlIHF1ZXJ5XG4vLyBsaWtlIGAkaW46IFsxLCBbXV1gLCBzZWUgZ2gtNTkxM1xuaGFuZGxlLiRuaW4gPSBTY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycy4kbmluO1xuaGFuZGxlLiRpbiA9IFNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRpbjtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYUFycmF5O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/array.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/bigint.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/bigint.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst castBigInt = __webpack_require__(/*! ../cast/bigint */ \"(api)/../server/node_modules/mongoose/lib/cast/bigint.js\");\n\n/**\n * BigInt SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBigInt(path, options) {\n  SchemaType.call(this, path, options, 'BigInt');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBigInt.schemaName = 'BigInt';\n\nSchemaBigInt.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBigInt.prototype = Object.create(SchemaType.prototype);\nSchemaBigInt.prototype.constructor = SchemaBigInt;\n\n/*!\n * ignore\n */\n\nSchemaBigInt._cast = castBigInt;\n\n/**\n * Sets a default option for all BigInt instances.\n *\n * #### Example:\n *\n *     // Make all bigints required by default\n *     mongoose.Schema.BigInt.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBigInt.set = SchemaType.set;\n\nSchemaBigInt.setters = [];\n\n/**\n * Attaches a getter for all BigInt instances\n *\n * #### Example:\n *\n *     // Convert bigints to numbers\n *     mongoose.Schema.BigInt.get(v => v == null ? v : Number(v));\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBigInt.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to booleans.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty string '' to false.\n *     const original = mongoose.Schema.BigInt.cast();\n *     mongoose.Schema.BigInt.cast(v => {\n *       if (v === '') {\n *         return false;\n *       }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.BigInt.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBigInt.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaBigInt._checkRequired = v => v != null;\n\n/**\n * Override the function the required validator uses to check whether a value\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBigInt.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaBigInt.prototype.checkRequired = function(value) {\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Casts to bigint\n *\n * @param {Object} value\n * @param {Object} model this value is optional\n * @api private\n */\n\nSchemaBigInt.prototype.cast = function(value) {\n  let castBigInt;\n  if (typeof this._castFunction === 'function') {\n    castBigInt = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castBigInt = this.constructor.cast();\n  } else {\n    castBigInt = SchemaBigInt.cast();\n  }\n\n  try {\n    return castBigInt(value);\n  } catch (error) {\n    throw new CastError('BigInt', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nSchemaBigInt.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaBigInt.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = SchemaBigInt.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this.applySetters(null, val, context);\n  }\n\n  return this.applySetters(val, context);\n};\n\n/**\n *\n * @api private\n */\n\nSchemaBigInt.prototype._castNullish = function _castNullish(v) {\n  if (typeof v === 'undefined') {\n    return v;\n  }\n  const castBigInt = typeof this.constructor.cast === 'function' ?\n    this.constructor.cast() :\n    SchemaBigInt.cast();\n  if (castBigInt == null) {\n    return v;\n  }\n  return v;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBigInt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2JpZ2ludC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMsOEVBQWU7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsOEVBQWU7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWdCOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcc2NoZW1hXFxiaWdpbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvY2FzdCcpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYXR5cGUnKTtcbmNvbnN0IGNhc3RCaWdJbnQgPSByZXF1aXJlKCcuLi9jYXN0L2JpZ2ludCcpO1xuXG4vKipcbiAqIEJpZ0ludCBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hQmlnSW50KHBhdGgsIG9wdGlvbnMpIHtcbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIHBhdGgsIG9wdGlvbnMsICdCaWdJbnQnKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFCaWdJbnQuc2NoZW1hTmFtZSA9ICdCaWdJbnQnO1xuXG5TY2hlbWFCaWdJbnQuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYUJpZ0ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYUJpZ0ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFCaWdJbnQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQmlnSW50Ll9jYXN0ID0gY2FzdEJpZ0ludDtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBCaWdJbnQgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgYmlnaW50cyByZXF1aXJlZCBieSBkZWZhdWx0XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJpZ0ludC5zZXQoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJpZ0ludC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hQmlnSW50LnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIEJpZ0ludCBpbnN0YW5jZXNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIENvbnZlcnQgYmlnaW50cyB0byBudW1iZXJzXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJpZ0ludC5nZXQodiA9PiB2ID09IG51bGwgPyB2IDogTnVtYmVyKHYpKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJpZ0ludC5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBib29sZWFucy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgTW9uZ29vc2UgY2FzdCBlbXB0eSBzdHJpbmcgJycgdG8gZmFsc2UuXG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5TY2hlbWEuQmlnSW50LmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5TY2hlbWEuQmlnSW50LmNhc3QodiA9PiB7XG4gKiAgICAgICBpZiAodiA9PT0gJycpIHtcbiAqICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICogICAgICAgfVxuICogICAgICAgcmV0dXJuIG9yaWdpbmFsKHYpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBPciBkaXNhYmxlIGNhc3RpbmcgZW50aXJlbHlcbiAqICAgICBtb25nb29zZS5TY2hlbWEuQmlnSW50LmNhc3QoZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhc3RlclxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJpZ0ludC5jYXN0ID0gZnVuY3Rpb24gY2FzdChjYXN0ZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdDtcbiAgfVxuICBpZiAoY2FzdGVyID09PSBmYWxzZSkge1xuICAgIGNhc3RlciA9IHRoaXMuX2RlZmF1bHRDYXN0ZXI7XG4gIH1cbiAgdGhpcy5fY2FzdCA9IGNhc3RlcjtcblxuICByZXR1cm4gdGhpcy5fY2FzdDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQmlnSW50Ll9jaGVja1JlcXVpcmVkID0gdiA9PiB2ICE9IG51bGw7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgdmFsdWVcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCaWdJbnQuY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIGEgcmVxdWlyZWQgdmFsaWRhdG9yLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQmlnSW50LnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBDYXN0cyB0byBiaWdpbnRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCB0aGlzIHZhbHVlIGlzIG9wdGlvbmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFCaWdJbnQucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBsZXQgY2FzdEJpZ0ludDtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0QmlnSW50ID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0QmlnSW50ID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdEJpZ0ludCA9IFNjaGVtYUJpZ0ludC5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0QmlnSW50KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdCaWdJbnQnLCB2YWx1ZSwgdGhpcy5wYXRoLCBlcnJvciwgdGhpcyk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQmlnSW50LiRjb25kaXRpb25hbEhhbmRsZXJzID0ge1xuICAuLi5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyxcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsLCBjb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpO1xufVxuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZGl0aW9uYWxcbiAqIEBwYXJhbSB7YW55fSB2YWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUJpZ0ludC5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSBTY2hlbWFCaWdJbnQuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcblxuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTZXR0ZXJzKG51bGwsIHZhbCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbn07XG5cbi8qKlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUJpZ0ludC5wcm90b3R5cGUuX2Nhc3ROdWxsaXNoID0gZnVuY3Rpb24gX2Nhc3ROdWxsaXNoKHYpIHtcbiAgaWYgKHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB2O1xuICB9XG4gIGNvbnN0IGNhc3RCaWdJbnQgPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhc3QoKSA6XG4gICAgU2NoZW1hQmlnSW50LmNhc3QoKTtcbiAgaWYgKGNhc3RCaWdJbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiB2O1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYUJpZ0ludDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/bigint.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/boolean.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/boolean.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst castBoolean = __webpack_require__(/*! ../cast/boolean */ \"(api)/../server/node_modules/mongoose/lib/cast/boolean.js\");\n\n/**\n * Boolean SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBoolean(path, options) {\n  SchemaType.call(this, path, options, 'Boolean');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBoolean.schemaName = 'Boolean';\n\nSchemaBoolean.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBoolean.prototype = Object.create(SchemaType.prototype);\nSchemaBoolean.prototype.constructor = SchemaBoolean;\n\n/*!\n * ignore\n */\n\nSchemaBoolean._cast = castBoolean;\n\n/**\n * Sets a default option for all Boolean instances.\n *\n * #### Example:\n *\n *     // Make all booleans have `default` of false.\n *     mongoose.Schema.Boolean.set('default', false);\n *\n *     const Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\n *     new Order({ }).isPaid; // false\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBoolean.set = SchemaType.set;\n\nSchemaBoolean.setters = [];\n\n/**\n * Attaches a getter for all Boolean instances\n *\n * #### Example:\n *\n *     mongoose.Schema.Boolean.get(v => v === true ? 'yes' : 'no');\n *\n *     const Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\n *     new Order({ isPaid: false }).isPaid; // 'no'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBoolean.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to booleans.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty string '' to false.\n *     const original = mongoose.Schema.Boolean.cast();\n *     mongoose.Schema.Boolean.cast(v => {\n *       if (v === '') {\n *         return false;\n *       }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Boolean.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBoolean.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaBoolean._defaultCaster = v => {\n  if (v != null && typeof v !== 'boolean') {\n    throw new Error();\n  }\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaBoolean._checkRequired = v => v === true || v === false;\n\n/**\n * Override the function the required validator uses to check whether a boolean\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBoolean.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. For a boolean\n * to satisfy a required validator, it must be strictly equal to true or to\n * false.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaBoolean.prototype.checkRequired = function(value) {\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Configure which values get casted to `true`.\n *\n * #### Example:\n *\n *     const M = mongoose.model('Test', new Schema({ b: Boolean }));\n *     new M({ b: 'affirmative' }).b; // undefined\n *     mongoose.Schema.Boolean.convertToTrue.add('affirmative');\n *     new M({ b: 'affirmative' }).b; // true\n *\n * @property convertToTrue\n * @static\n * @memberOf SchemaBoolean\n * @type {Set}\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean, 'convertToTrue', {\n  get: () => castBoolean.convertToTrue,\n  set: v => { castBoolean.convertToTrue = v; }\n});\n\n/**\n * Configure which values get casted to `false`.\n *\n * #### Example:\n *\n *     const M = mongoose.model('Test', new Schema({ b: Boolean }));\n *     new M({ b: 'nay' }).b; // undefined\n *     mongoose.Schema.Types.Boolean.convertToFalse.add('nay');\n *     new M({ b: 'nay' }).b; // false\n *\n * @property convertToFalse\n * @static\n * @memberOf SchemaBoolean\n * @type {Set}\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean, 'convertToFalse', {\n  get: () => castBoolean.convertToFalse,\n  set: v => { castBoolean.convertToFalse = v; }\n});\n\n/**\n * Casts to boolean\n *\n * @param {Object} value\n * @param {Object} model this value is optional\n * @api private\n */\n\nSchemaBoolean.prototype.cast = function(value) {\n  let castBoolean;\n  if (typeof this._castFunction === 'function') {\n    castBoolean = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castBoolean = this.constructor.cast();\n  } else {\n    castBoolean = SchemaBoolean.cast();\n  }\n\n  try {\n    return castBoolean(value);\n  } catch (error) {\n    throw new CastError('Boolean', value, this.path, error, this);\n  }\n};\n\nSchemaBoolean.$conditionalHandlers = { ...SchemaType.prototype.$conditionalHandlers };\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaBoolean.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = SchemaBoolean.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this.applySetters(null, val, context);\n  }\n\n  return this.applySetters(val, context);\n};\n\n/**\n *\n * @api private\n */\n\nSchemaBoolean.prototype._castNullish = function _castNullish(v) {\n  if (typeof v === 'undefined') {\n    return v;\n  }\n  const castBoolean = typeof this.constructor.cast === 'function' ?\n    this.constructor.cast() :\n    SchemaBoolean.cast();\n  if (castBoolean == null) {\n    return v;\n  }\n  if (castBoolean.convertToFalse instanceof Set && castBoolean.convertToFalse.has(v)) {\n    return false;\n  }\n  if (castBoolean.convertToTrue instanceof Set && castBoolean.convertToTrue.has(v)) {\n    return true;\n  }\n  return v;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBoolean;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2Jvb2xlYW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFlO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFlO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLGtGQUFpQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCO0FBQzNFLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCO0FBQzNFLG1CQUFtQixlQUFlLFVBQVU7QUFDNUM7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakUsZUFBZSxrQkFBa0IsS0FBSztBQUN0QztBQUNBLGVBQWUsa0JBQWtCLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFLGVBQWUsVUFBVSxLQUFLO0FBQzlCO0FBQ0EsZUFBZSxVQUFVLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcc2NoZW1hXFxib29sZWFuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2Nhc3QnKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWF0eXBlJyk7XG5jb25zdCBjYXN0Qm9vbGVhbiA9IHJlcXVpcmUoJy4uL2Nhc3QvYm9vbGVhbicpO1xuXG4vKipcbiAqIEJvb2xlYW4gU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYUJvb2xlYW4ocGF0aCwgb3B0aW9ucykge1xuICBTY2hlbWFUeXBlLmNhbGwodGhpcywgcGF0aCwgb3B0aW9ucywgJ0Jvb2xlYW4nKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFCb29sZWFuLnNjaGVtYU5hbWUgPSAnQm9vbGVhbic7XG5cblNjaGVtYUJvb2xlYW4uZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYUJvb2xlYW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFCb29sZWFuLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYUJvb2xlYW47XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5fY2FzdCA9IGNhc3RCb29sZWFuO1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIEJvb2xlYW4gaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgYm9vbGVhbnMgaGF2ZSBgZGVmYXVsdGAgb2YgZmFsc2UuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJvb2xlYW4uc2V0KCdkZWZhdWx0JywgZmFsc2UpO1xuICpcbiAqICAgICBjb25zdCBPcmRlciA9IG1vbmdvb3NlLm1vZGVsKCdPcmRlcicsIG5ldyBTY2hlbWEoeyBpc1BhaWQ6IEJvb2xlYW4gfSkpO1xuICogICAgIG5ldyBPcmRlcih7IH0pLmlzUGFpZDsgLy8gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hQm9vbGVhbi5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBCb29sZWFuIGluc3RhbmNlc1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJvb2xlYW4uZ2V0KHYgPT4gdiA9PT0gdHJ1ZSA/ICd5ZXMnIDogJ25vJyk7XG4gKlxuICogICAgIGNvbnN0IE9yZGVyID0gbW9uZ29vc2UubW9kZWwoJ09yZGVyJywgbmV3IFNjaGVtYSh7IGlzUGFpZDogQm9vbGVhbiB9KSk7XG4gKiAgICAgbmV3IE9yZGVyKHsgaXNQYWlkOiBmYWxzZSB9KS5pc1BhaWQ7IC8vICdubydcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJvb2xlYW4uZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gYm9vbGVhbnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIE1vbmdvb3NlIGNhc3QgZW1wdHkgc3RyaW5nICcnIHRvIGZhbHNlLlxuICogICAgIGNvbnN0IG9yaWdpbmFsID0gbW9uZ29vc2UuU2NoZW1hLkJvb2xlYW4uY2FzdCgpO1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5Cb29sZWFuLmNhc3QodiA9PiB7XG4gKiAgICAgICBpZiAodiA9PT0gJycpIHtcbiAqICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICogICAgICAgfVxuICogICAgICAgcmV0dXJuIG9yaWdpbmFsKHYpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBPciBkaXNhYmxlIGNhc3RpbmcgZW50aXJlbHlcbiAqICAgICBtb25nb29zZS5TY2hlbWEuQm9vbGVhbi5jYXN0KGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYXN0ZXJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCb29sZWFuLmNhc3QgPSBmdW5jdGlvbiBjYXN0KGNhc3Rlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0O1xuICB9XG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdGhpcy5fZGVmYXVsdENhc3RlcjtcbiAgfVxuICB0aGlzLl9jYXN0ID0gY2FzdGVyO1xuXG4gIHJldHVybiB0aGlzLl9jYXN0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFCb29sZWFuLl9kZWZhdWx0Q2FzdGVyID0gdiA9PiB7XG4gIGlmICh2ICE9IG51bGwgJiYgdHlwZW9mIHYgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFCb29sZWFuLl9jaGVja1JlcXVpcmVkID0gdiA9PiB2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlO1xuXG4vKipcbiAqIE92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yIHVzZXMgdG8gY2hlY2sgd2hldGhlciBhIGJvb2xlYW5cbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCb29sZWFuLmNoZWNrUmVxdWlyZWQgPSBTY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyBhIHJlcXVpcmVkIHZhbGlkYXRvci4gRm9yIGEgYm9vbGVhblxuICogdG8gc2F0aXNmeSBhIHJlcXVpcmVkIHZhbGlkYXRvciwgaXQgbXVzdCBiZSBzdHJpY3RseSBlcXVhbCB0byB0cnVlIG9yIHRvXG4gKiBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJvb2xlYW4ucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5fY2hlY2tSZXF1aXJlZCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyZSB3aGljaCB2YWx1ZXMgZ2V0IGNhc3RlZCB0byBgdHJ1ZWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgYjogQm9vbGVhbiB9KSk7XG4gKiAgICAgbmV3IE0oeyBiOiAnYWZmaXJtYXRpdmUnIH0pLmI7IC8vIHVuZGVmaW5lZFxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5Cb29sZWFuLmNvbnZlcnRUb1RydWUuYWRkKCdhZmZpcm1hdGl2ZScpO1xuICogICAgIG5ldyBNKHsgYjogJ2FmZmlybWF0aXZlJyB9KS5iOyAvLyB0cnVlXG4gKlxuICogQHByb3BlcnR5IGNvbnZlcnRUb1RydWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFCb29sZWFuXG4gKiBAdHlwZSB7U2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hQm9vbGVhbiwgJ2NvbnZlcnRUb1RydWUnLCB7XG4gIGdldDogKCkgPT4gY2FzdEJvb2xlYW4uY29udmVydFRvVHJ1ZSxcbiAgc2V0OiB2ID0+IHsgY2FzdEJvb2xlYW4uY29udmVydFRvVHJ1ZSA9IHY7IH1cbn0pO1xuXG4vKipcbiAqIENvbmZpZ3VyZSB3aGljaCB2YWx1ZXMgZ2V0IGNhc3RlZCB0byBgZmFsc2VgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IGI6IEJvb2xlYW4gfSkpO1xuICogICAgIG5ldyBNKHsgYjogJ25heScgfSkuYjsgLy8gdW5kZWZpbmVkXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLkJvb2xlYW4uY29udmVydFRvRmFsc2UuYWRkKCduYXknKTtcbiAqICAgICBuZXcgTSh7IGI6ICduYXknIH0pLmI7IC8vIGZhbHNlXG4gKlxuICogQHByb3BlcnR5IGNvbnZlcnRUb0ZhbHNlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hQm9vbGVhblxuICogQHR5cGUge1NldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYUJvb2xlYW4sICdjb252ZXJ0VG9GYWxzZScsIHtcbiAgZ2V0OiAoKSA9PiBjYXN0Qm9vbGVhbi5jb252ZXJ0VG9GYWxzZSxcbiAgc2V0OiB2ID0+IHsgY2FzdEJvb2xlYW4uY29udmVydFRvRmFsc2UgPSB2OyB9XG59KTtcblxuLyoqXG4gKiBDYXN0cyB0byBib29sZWFuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgdGhpcyB2YWx1ZSBpcyBvcHRpb25hbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGxldCBjYXN0Qm9vbGVhbjtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0Qm9vbGVhbiA9IHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdEJvb2xlYW4gPSB0aGlzLmNvbnN0cnVjdG9yLmNhc3QoKTtcbiAgfSBlbHNlIHtcbiAgICBjYXN0Qm9vbGVhbiA9IFNjaGVtYUJvb2xlYW4uY2FzdCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdEJvb2xlYW4odmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ0Jvb2xlYW4nLCB2YWx1ZSwgdGhpcy5wYXRoLCBlcnJvciwgdGhpcyk7XG4gIH1cbn07XG5cblNjaGVtYUJvb2xlYW4uJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7IC4uLlNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzIH07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kaXRpb25hbFxuICogQHBhcmFtIHthbnl9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSBTY2hlbWFCb29sZWFuLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG5cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB2YWwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFwcGx5U2V0dGVycyhudWxsLCB2YWwsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXBwbHlTZXR0ZXJzKHZhbCwgY29udGV4dCk7XG59O1xuXG4vKipcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFCb29sZWFuLnByb3RvdHlwZS5fY2FzdE51bGxpc2ggPSBmdW5jdGlvbiBfY2FzdE51bGxpc2godikge1xuICBpZiAodHlwZW9mIHYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgY29uc3QgY2FzdEJvb2xlYW4gPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhc3QoKSA6XG4gICAgU2NoZW1hQm9vbGVhbi5jYXN0KCk7XG4gIGlmIChjYXN0Qm9vbGVhbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgaWYgKGNhc3RCb29sZWFuLmNvbnZlcnRUb0ZhbHNlIGluc3RhbmNlb2YgU2V0ICYmIGNhc3RCb29sZWFuLmNvbnZlcnRUb0ZhbHNlLmhhcyh2KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY2FzdEJvb2xlYW4uY29udmVydFRvVHJ1ZSBpbnN0YW5jZW9mIFNldCAmJiBjYXN0Qm9vbGVhbi5jb252ZXJ0VG9UcnVlLmhhcyh2KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYUJvb2xlYW47XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/boolean.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/buffer.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/buffer.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseBuffer = __webpack_require__(/*! ../types/buffer */ \"(api)/../server/node_modules/mongoose/lib/types/buffer.js\");\nconst SchemaBufferOptions = __webpack_require__(/*! ../options/SchemaBufferOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaBufferOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst handleBitwiseOperator = __webpack_require__(/*! ./operators/bitwise */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/bitwise.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nconst Binary = MongooseBuffer.Binary;\nconst CastError = SchemaType.CastError;\n\n/**\n * Buffer SchemaType constructor\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBuffer(key, options) {\n  SchemaType.call(this, key, options, 'Buffer');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBuffer.schemaName = 'Buffer';\n\nSchemaBuffer.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBuffer.prototype = Object.create(SchemaType.prototype);\nSchemaBuffer.prototype.constructor = SchemaBuffer;\nSchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;\n\n/*!\n * ignore\n */\n\nSchemaBuffer._checkRequired = v => !!(v && v.length);\n\n/**\n * Sets a default option for all Buffer instances.\n *\n * #### Example:\n *\n *     // Make all buffers have `required` of true by default.\n *     mongoose.Schema.Buffer.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Buffer }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBuffer.set = SchemaType.set;\n\nSchemaBuffer.setters = [];\n\n/**\n * Attaches a getter for all Buffer instances\n *\n * #### Example:\n *\n *     // Always convert to string when getting an ObjectId\n *     mongoose.Schema.Types.Buffer.get(v => v.toString('hex'));\n *\n *     const Model = mongoose.model('Test', new Schema({ buf: Buffer } }));\n *     typeof (new Model({ buf: Buffer.fromString('hello') }).buf); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBuffer.get = SchemaType.get;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ buf: { type: Buffer, required: true } });\n *     new M({ buf: Buffer.from('') }).validateSync(); // validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBuffer.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy a\n * required validator, a buffer must not be null or undefined and have\n * non-zero length.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaBuffer.prototype.checkRequired = function(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaBuffer.prototype.cast = function(value, doc, init) {\n  let ret;\n  if (SchemaType._isRef(this, value, doc, init)) {\n    if (value && value.isMongooseBuffer) {\n      return value;\n    }\n\n    if (Buffer.isBuffer(value)) {\n      if (!value || !value.isMongooseBuffer) {\n        value = new MongooseBuffer(value, [this.path, doc]);\n        if (this.options.subtype != null) {\n          value._subtype = this.options.subtype;\n        }\n      }\n      return value;\n    }\n\n    if (value instanceof Binary) {\n      ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n      if (typeof value.sub_type !== 'number') {\n        throw new CastError('Buffer', value, this.path, null, this);\n      }\n      ret._subtype = value.sub_type;\n      return ret;\n    }\n\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init);\n    }\n  }\n\n  // documents\n  if (value && value._id) {\n    value = value._id;\n  }\n\n  if (value && value.isMongooseBuffer) {\n    return value;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    if (!value || !value.isMongooseBuffer) {\n      value = new MongooseBuffer(value, [this.path, doc]);\n      if (this.options.subtype != null) {\n        value._subtype = this.options.subtype;\n      }\n    }\n    return value;\n  }\n\n  if (value instanceof Binary) {\n    ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n    if (typeof value.sub_type !== 'number') {\n      throw new CastError('Buffer', value, this.path, null, this);\n    }\n    ret._subtype = value.sub_type;\n    return ret;\n  }\n\n  if (value === null) {\n    return value;\n  }\n\n\n  const type = typeof value;\n  if (\n    type === 'string' || type === 'number' || Array.isArray(value) ||\n    (type === 'object' && value.type === 'Buffer' && Array.isArray(value.data)) // gh-6863\n  ) {\n    if (type === 'number') {\n      value = [value];\n    }\n    ret = new MongooseBuffer(value, [this.path, doc]);\n    if (this.options.subtype != null) {\n      ret._subtype = this.options.subtype;\n    }\n    return ret;\n  }\n\n  throw new CastError('Buffer', value, this.path, null, this);\n};\n\n/**\n * Sets the default [subtype](https://studio3t.com/whats-new/best-practices-uuid-mongodb/)\n * for this buffer. You can find a [list of allowed subtypes here](https://api.mongodb.com/python/current/api/bson/binary.html).\n *\n * #### Example:\n *\n *     const s = new Schema({ uuid: { type: Buffer, subtype: 4 });\n *     const M = db.model('M', s);\n *     const m = new M({ uuid: 'test string' });\n *     m.uuid._subtype; // 4\n *\n * @param {Number} subtype the default subtype\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaBuffer.prototype.subtype = function(subtype) {\n  this.options.subtype = subtype;\n  return this;\n};\n\n/*!\n * ignore\n */\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\nSchemaBuffer.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaBuffer.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Buffer.');\n    }\n    return handler.call(this, val);\n  }\n  const casted = this.applySetters(val, context);\n  return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsdUJBQXVCLG1CQUFPLENBQUMsa0ZBQWlCO0FBQ2hELDRCQUE0QixtQkFBTyxDQUFDLGdIQUFnQztBQUNwRSxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBZTtBQUMxQyw4QkFBOEIsbUJBQU8sQ0FBQyxrR0FBcUI7QUFDM0QsY0FBYyxtQkFBTyxDQUFDLG9FQUFVOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsY0FBYztBQUN0RSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxlQUFlO0FBQ3hFLDJCQUEyQixpQ0FBaUMsUUFBUTtBQUNwRTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8sZ0NBQWdDO0FBQ3pFLGVBQWUsc0JBQXNCLGtCQUFrQjtBQUN2RDtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUSwwQkFBMEI7QUFDaEU7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDLHdCQUF3QjtBQUN4QjtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFlBQVk7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUNBQW1DO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHNjaGVtYVxcYnVmZmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlQnVmZmVyID0gcmVxdWlyZSgnLi4vdHlwZXMvYnVmZmVyJyk7XG5jb25zdCBTY2hlbWFCdWZmZXJPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucy9TY2hlbWFCdWZmZXJPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hdHlwZScpO1xuY29uc3QgaGFuZGxlQml0d2lzZU9wZXJhdG9yID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvYml0d2lzZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5jb25zdCBCaW5hcnkgPSBNb25nb29zZUJ1ZmZlci5CaW5hcnk7XG5jb25zdCBDYXN0RXJyb3IgPSBTY2hlbWFUeXBlLkNhc3RFcnJvcjtcblxuLyoqXG4gKiBCdWZmZXIgU2NoZW1hVHlwZSBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFCdWZmZXIoa2V5LCBvcHRpb25zKSB7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdCdWZmZXInKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFCdWZmZXIuc2NoZW1hTmFtZSA9ICdCdWZmZXInO1xuXG5TY2hlbWFCdWZmZXIuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFCdWZmZXI7XG5TY2hlbWFCdWZmZXIucHJvdG90eXBlLk9wdGlvbnNDb25zdHJ1Y3RvciA9IFNjaGVtYUJ1ZmZlck9wdGlvbnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQnVmZmVyLl9jaGVja1JlcXVpcmVkID0gdiA9PiAhISh2ICYmIHYubGVuZ3RoKTtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBCdWZmZXIgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgYnVmZmVycyBoYXZlIGByZXF1aXJlZGAgb2YgdHJ1ZSBieSBkZWZhdWx0LlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5CdWZmZXIuc2V0KCdyZXF1aXJlZCcsIHRydWUpO1xuICpcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgdGVzdDogQnVmZmVyIH0pKTtcbiAqICAgICBuZXcgVXNlcih7IH0pLnZhbGlkYXRlU3luYygpLmVycm9ycy50ZXN0Lm1lc3NhZ2U7IC8vIFBhdGggYHRlc3RgIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCdWZmZXIuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYUJ1ZmZlci5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBCdWZmZXIgaW5zdGFuY2VzXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbHdheXMgY29udmVydCB0byBzdHJpbmcgd2hlbiBnZXR0aW5nIGFuIE9iamVjdElkXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLkJ1ZmZlci5nZXQodiA9PiB2LnRvU3RyaW5nKCdoZXgnKSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgYnVmOiBCdWZmZXIgfSB9KSk7XG4gKiAgICAgdHlwZW9mIChuZXcgTW9kZWwoeyBidWY6IEJ1ZmZlci5mcm9tU3RyaW5nKCdoZWxsbycpIH0pLmJ1Zik7IC8vICdzdHJpbmcnXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCdWZmZXIuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbGxvdyBlbXB0eSBzdHJpbmdzIHRvIHBhc3MgYHJlcXVpcmVkYCBjaGVja1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5TdHJpbmcuY2hlY2tSZXF1aXJlZCh2ID0+IHYgIT0gbnVsbCk7XG4gKlxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCh7IGJ1ZjogeyB0eXBlOiBCdWZmZXIsIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgbmV3IE0oeyBidWY6IEJ1ZmZlci5mcm9tKCcnKSB9KS52YWxpZGF0ZVN5bmMoKTsgLy8gdmFsaWRhdGlvbiBwYXNzZXMhXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQnVmZmVyLmNoZWNrUmVxdWlyZWQgPSBTY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyBhIHJlcXVpcmVkIHZhbGlkYXRvci4gVG8gc2F0aXNmeSBhXG4gKiByZXF1aXJlZCB2YWxpZGF0b3IsIGEgYnVmZmVyIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGFuZCBoYXZlXG4gKiBub24temVybyBsZW5ndGguXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MpIHtcbiAgaWYgKFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIHRydWUpKSB7XG4gICAgcmV0dXJuICEhdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIGRvY3VtZW50IHRoYXQgdHJpZ2dlcnMgdGhlIGNhc3RpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQnVmZmVyLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUsIGRvYywgaW5pdCkge1xuICBsZXQgcmV0O1xuICBpZiAoU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgaW5pdCkpIHtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuaXNNb25nb29zZUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICBpZiAoIXZhbHVlIHx8ICF2YWx1ZS5pc01vbmdvb3NlQnVmZmVyKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IE1vbmdvb3NlQnVmZmVyKHZhbHVlLCBbdGhpcy5wYXRoLCBkb2NdKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdWJ0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZS5fc3VidHlwZSA9IHRoaXMub3B0aW9ucy5zdWJ0eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmluYXJ5KSB7XG4gICAgICByZXQgPSBuZXcgTW9uZ29vc2VCdWZmZXIodmFsdWUudmFsdWUodHJ1ZSksIFt0aGlzLnBhdGgsIGRvY10pO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZS5zdWJfdHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignQnVmZmVyJywgdmFsdWUsIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXQuX3N1YnR5cGUgPSB2YWx1ZS5zdWJfdHlwZTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdXRpbHMuaXNOb25CdWlsdGluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nhc3RSZWYodmFsdWUsIGRvYywgaW5pdCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZG9jdW1lbnRzXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS5faWQpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLl9pZDtcbiAgfVxuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS5pc01vbmdvb3NlQnVmZmVyKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICBpZiAoIXZhbHVlIHx8ICF2YWx1ZS5pc01vbmdvb3NlQnVmZmVyKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBNb25nb29zZUJ1ZmZlcih2YWx1ZSwgW3RoaXMucGF0aCwgZG9jXSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN1YnR5cGUgIT0gbnVsbCkge1xuICAgICAgICB2YWx1ZS5fc3VidHlwZSA9IHRoaXMub3B0aW9ucy5zdWJ0eXBlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaW5hcnkpIHtcbiAgICByZXQgPSBuZXcgTW9uZ29vc2VCdWZmZXIodmFsdWUudmFsdWUodHJ1ZSksIFt0aGlzLnBhdGgsIGRvY10pO1xuICAgIGlmICh0eXBlb2YgdmFsdWUuc3ViX3R5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdCdWZmZXInLCB2YWx1ZSwgdGhpcy5wYXRoLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0Ll9zdWJ0eXBlID0gdmFsdWUuc3ViX3R5cGU7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG5cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKFxuICAgIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpIC8vIGdoLTY4NjNcbiAgKSB7XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgfVxuICAgIHJldCA9IG5ldyBNb25nb29zZUJ1ZmZlcih2YWx1ZSwgW3RoaXMucGF0aCwgZG9jXSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdWJ0eXBlICE9IG51bGwpIHtcbiAgICAgIHJldC5fc3VidHlwZSA9IHRoaXMub3B0aW9ucy5zdWJ0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgdGhyb3cgbmV3IENhc3RFcnJvcignQnVmZmVyJywgdmFsdWUsIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRlZmF1bHQgW3N1YnR5cGVdKGh0dHBzOi8vc3R1ZGlvM3QuY29tL3doYXRzLW5ldy9iZXN0LXByYWN0aWNlcy11dWlkLW1vbmdvZGIvKVxuICogZm9yIHRoaXMgYnVmZmVyLiBZb3UgY2FuIGZpbmQgYSBbbGlzdCBvZiBhbGxvd2VkIHN1YnR5cGVzIGhlcmVdKGh0dHBzOi8vYXBpLm1vbmdvZGIuY29tL3B5dGhvbi9jdXJyZW50L2FwaS9ic29uL2JpbmFyeS5odG1sKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgdXVpZDogeyB0eXBlOiBCdWZmZXIsIHN1YnR5cGU6IDQgfSk7XG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcyk7XG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgdXVpZDogJ3Rlc3Qgc3RyaW5nJyB9KTtcbiAqICAgICBtLnV1aWQuX3N1YnR5cGU7IC8vIDRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3VidHlwZSB0aGUgZGVmYXVsdCBzdWJ0eXBlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUuc3VidHlwZSA9IGZ1bmN0aW9uKHN1YnR5cGUpIHtcbiAgdGhpcy5vcHRpb25zLnN1YnR5cGUgPSBzdWJ0eXBlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZSh2YWwsIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbCwgY29udGV4dCk7XG59XG5cblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7XG4gIC4uLlNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLFxuICAkYml0c0FsbENsZWFyOiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRiaXRzQW55Q2xlYXI6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGJpdHNBbGxTZXQ6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGJpdHNBbnlTZXQ6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZVxufTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50cyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge2FueX0gW3ZhbHVlXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQnVmZmVyLnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZGl0aW9uYWwsIHZhbCwgY29udGV4dCkge1xuICBsZXQgaGFuZGxlcjtcbiAgaWYgKCRjb25kaXRpb25hbCAhPSBudWxsKSB7XG4gICAgaGFuZGxlciA9IHRoaXMuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgJyArICRjb25kaXRpb25hbCArICcgd2l0aCBCdWZmZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsKTtcbiAgfVxuICBjb25zdCBjYXN0ZWQgPSB0aGlzLmFwcGx5U2V0dGVycyh2YWwsIGNvbnRleHQpO1xuICByZXR1cm4gY2FzdGVkID8gY2FzdGVkLnRvT2JqZWN0KHsgdHJhbnNmb3JtOiBmYWxzZSwgdmlydHVhbHM6IGZhbHNlIH0pIDogY2FzdGVkO1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYUJ1ZmZlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/buffer.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/date.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/date.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nconst SchemaDateOptions = __webpack_require__(/*! ../options/SchemaDateOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaDateOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst castDate = __webpack_require__(/*! ../cast/date */ \"(api)/../server/node_modules/mongoose/lib/cast/date.js\");\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options) {\n  SchemaType.call(this, key, options, 'Date');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDate.schemaName = 'Date';\n\nSchemaDate.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\nSchemaDate.prototype.OptionsConstructor = SchemaDateOptions;\n\n/*!\n * ignore\n */\n\nSchemaDate._cast = castDate;\n\n/**\n * Sets a default option for all Date instances.\n *\n * #### Example:\n *\n *     // Make all dates have `required` of true by default.\n *     mongoose.Schema.Date.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Date }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDate.set = SchemaType.set;\n\nSchemaDate.setters = [];\n\n/**\n * Attaches a getter for all Date instances\n *\n * #### Example:\n *\n *     // Always convert Dates to string\n *     mongoose.Date.get(v => v.toString());\n *\n *     const Model = mongoose.model('Test', new Schema({ date: { type: Date, default: () => new Date() } }));\n *     typeof (new Model({}).date); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to dates.\n *\n * #### Example:\n *\n *     // Mongoose converts empty string '' into `null` for date types. You\n *     // can create a custom caster to disable it.\n *     const original = mongoose.Schema.Types.Date.cast();\n *     mongoose.Schema.Types.Date.cast(v => {\n *       assert.ok(v !== '');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.Date.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._defaultCaster = v => {\n  if (v != null && !(v instanceof Date)) {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     const schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function(when) {\n  if (getConstructorName(this._index) !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._checkRequired = v => v instanceof Date;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDate.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaDate.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     const min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     const schema = new Schema({ d: { type: Date, min: min })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.min;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.minValidator = function(val) {\n        let _value = value;\n        if (typeof value === 'function' && value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const min = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     const max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     const schema = new Schema({ d: { type: Date, max: max })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.max;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.maxValidator = function(val) {\n        let _value = value;\n        if (typeof _value === 'function' && _value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const max = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDate.prototype.cast = function(value) {\n  let castDate;\n  if (typeof this._castFunction === 'function') {\n    castDate = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDate = this.constructor.cast();\n  } else {\n    castDate = SchemaDate.cast();\n  }\n\n  try {\n    return castDate(value);\n  } catch (error) {\n    throw new CastError('date', value, this.path, error, this);\n  }\n};\n\n/**\n * Date Query casting.\n *\n * @param {Any} val\n * @api private\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDate.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function($conditional, val, context) {\n  if ($conditional == null) {\n    return this.applySetters(val, context);\n  }\n\n  const handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLGdGQUFnQjtBQUM5QywwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBOEI7QUFDaEUsbUJBQW1CLG1CQUFPLENBQUMsOEVBQWU7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsNEVBQWM7QUFDdkMsMkJBQTJCLG1CQUFPLENBQUMsOEdBQStCO0FBQ2xFLGNBQWMsbUJBQU8sQ0FBQyxvRUFBVTs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVEseUNBQXlDO0FBQzFHLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7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RUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcc2NoZW1hXFxkYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU2NoZW1hRGF0ZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9vcHRpb25zL1NjaGVtYURhdGVPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hdHlwZScpO1xuY29uc3QgY2FzdERhdGUgPSByZXF1aXJlKCcuLi9jYXN0L2RhdGUnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmNvbnN0IENhc3RFcnJvciA9IFNjaGVtYVR5cGUuQ2FzdEVycm9yO1xuXG4vKipcbiAqIERhdGUgU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hRGF0ZShrZXksIG9wdGlvbnMpIHtcbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIGtleSwgb3B0aW9ucywgJ0RhdGUnKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFEYXRlLnNjaGVtYU5hbWUgPSAnRGF0ZSc7XG5cblNjaGVtYURhdGUuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYURhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFEYXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYURhdGU7XG5TY2hlbWFEYXRlLnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFEYXRlT3B0aW9ucztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEYXRlLl9jYXN0ID0gY2FzdERhdGU7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgRGF0ZSBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBkYXRlcyBoYXZlIGByZXF1aXJlZGAgb2YgdHJ1ZSBieSBkZWZhdWx0LlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5EYXRlLnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IHRlc3Q6IERhdGUgfSkpO1xuICogICAgIG5ldyBVc2VyKHsgfSkudmFsaWRhdGVTeW5jKCkuZXJyb3JzLnRlc3QubWVzc2FnZTsgLy8gUGF0aCBgdGVzdGAgaXMgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYURhdGUuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgRGF0ZSBpbnN0YW5jZXNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEFsd2F5cyBjb252ZXJ0IERhdGVzIHRvIHN0cmluZ1xuICogICAgIG1vbmdvb3NlLkRhdGUuZ2V0KHYgPT4gdi50b1N0cmluZygpKTtcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoeyBkYXRlOiB7IHR5cGU6IERhdGUsIGRlZmF1bHQ6ICgpID0+IG5ldyBEYXRlKCkgfSB9KSk7XG4gKiAgICAgdHlwZW9mIChuZXcgTW9kZWwoe30pLmRhdGUpOyAvLyAnc3RyaW5nJ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGF0ZS5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBkYXRlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1vbmdvb3NlIGNvbnZlcnRzIGVtcHR5IHN0cmluZyAnJyBpbnRvIGBudWxsYCBmb3IgZGF0ZSB0eXBlcy4gWW91XG4gKiAgICAgLy8gY2FuIGNyZWF0ZSBhIGN1c3RvbSBjYXN0ZXIgdG8gZGlzYWJsZSBpdC5cbiAqICAgICBjb25zdCBvcmlnaW5hbCA9IG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5EYXRlLmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuRGF0ZS5jYXN0KHYgPT4ge1xuICogICAgICAgYXNzZXJ0Lm9rKHYgIT09ICcnKTtcbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLkRhdGUuY2FzdChmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FzdGVyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGF0ZS5jYXN0ID0gZnVuY3Rpb24gY2FzdChjYXN0ZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdDtcbiAgfVxuICBpZiAoY2FzdGVyID09PSBmYWxzZSkge1xuICAgIGNhc3RlciA9IHRoaXMuX2RlZmF1bHRDYXN0ZXI7XG4gIH1cbiAgdGhpcy5fY2FzdCA9IGNhc3RlcjtcblxuICByZXR1cm4gdGhpcy5fY2FzdDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hRGF0ZS5fZGVmYXVsdENhc3RlciA9IHYgPT4ge1xuICBpZiAodiAhPSBudWxsICYmICEodiBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGEgVFRMIGluZGV4IChyb3VuZGVkIHRvIHRoZSBuZWFyZXN0IHNlY29uZCkgZm9yIF9EYXRlXyB0eXBlcyBvbmx5LlxuICpcbiAqIFRoaXMgc2V0cyB0aGUgYGV4cGlyZUFmdGVyU2Vjb25kc2AgaW5kZXggb3B0aW9uIGF2YWlsYWJsZSBpbiBNb25nb0RCID49IDIuMS4yLlxuICogVGhpcyBpbmRleCB0eXBlIGlzIG9ubHkgY29tcGF0aWJsZSB3aXRoIERhdGUgdHlwZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBleHBpcmUgaW4gMjQgaG91cnNcbiAqICAgICBuZXcgU2NoZW1hKHsgY3JlYXRlZEF0OiB7IHR5cGU6IERhdGUsIGV4cGlyZXM6IDYwKjYwKjI0IH19KTtcbiAqXG4gKiBgZXhwaXJlc2AgdXRpbGl6ZXMgdGhlIGBtc2AgbW9kdWxlIGZyb20gW2d1aWxsZV0oaHR0cHM6Ly9naXRodWIuY29tL2d1aWxsZS8pIGFsbG93aW5nIHVzIHRvIHVzZSBhIGZyaWVuZGxpZXIgc3ludGF4OlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gZXhwaXJlIGluIDI0IGhvdXJzXG4gKiAgICAgbmV3IFNjaGVtYSh7IGNyZWF0ZWRBdDogeyB0eXBlOiBEYXRlLCBleHBpcmVzOiAnMjRoJyB9fSk7XG4gKlxuICogICAgIC8vIGV4cGlyZSBpbiAxLjUgaG91cnNcbiAqICAgICBuZXcgU2NoZW1hKHsgY3JlYXRlZEF0OiB7IHR5cGU6IERhdGUsIGV4cGlyZXM6ICcxLjVoJyB9fSk7XG4gKlxuICogICAgIC8vIGV4cGlyZSBpbiA3IGRheXNcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgY3JlYXRlZEF0OiBEYXRlIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdjcmVhdGVkQXQnKS5leHBpcmVzKCc3ZCcpO1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gd2hlblxuICogQGFkZGVkIDMuMC4wXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUucHJvdG90eXBlLmV4cGlyZXMgPSBmdW5jdGlvbih3aGVuKSB7XG4gIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUodGhpcy5faW5kZXgpICE9PSAnT2JqZWN0Jykge1xuICAgIHRoaXMuX2luZGV4ID0ge307XG4gIH1cblxuICB0aGlzLl9pbmRleC5leHBpcmVzID0gd2hlbjtcbiAgdXRpbHMuZXhwaXJlcyh0aGlzLl9pbmRleCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEYXRlLl9jaGVja1JlcXVpcmVkID0gdiA9PiB2IGluc3RhbmNlb2YgRGF0ZTtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmdcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEFsbG93IGVtcHR5IHN0cmluZ3MgdG8gcGFzcyBgcmVxdWlyZWRgIGNoZWNrXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLlN0cmluZy5jaGVja1JlcXVpcmVkKHYgPT4gdiAhPSBudWxsKTtcbiAqXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKHsgc3RyOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSB9KTtcbiAqICAgICBuZXcgTSh7IHN0cjogJycgfSkudmFsaWRhdGVTeW5jKCk7IC8vIGBudWxsYCwgdmFsaWRhdGlvbiBwYXNzZXMhXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGF0ZS5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuIFRvIHNhdGlzZnlcbiAqIGEgcmVxdWlyZWQgdmFsaWRhdG9yLCB0aGUgZ2l2ZW4gdmFsdWUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBgRGF0ZWAuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbih2YWx1ZSwgZG9jKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIHRydWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG4gIH1cblxuICAvLyBgcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzKClgIGRvZXMgKipub3QqKiBjb3B5IHN0YXRpYyBwcm9wZXJ0aWVzLCBhbmRcbiAgLy8gcGx1Z2lucyBsaWtlIG1vbmdvb3NlLWZsb2F0IHVzZSBgaW5oZXJpdHMoKWAgZm9yIHByZS1FUzYuXG4gIGNvbnN0IF9jaGVja1JlcXVpcmVkID0gdHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkKCkgOlxuICAgIFNjaGVtYURhdGUuY2hlY2tSZXF1aXJlZCgpO1xuICByZXR1cm4gX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgbWluaW11bSBkYXRlIHZhbGlkYXRvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgZDogeyB0eXBlOiBEYXRlLCBtaW46IERhdGUoJzE5NzAtMDEtMDEnKSB9KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgZDogRGF0ZSgnMTk2OS0xMi0zMScpIH0pXG4gKiAgICAgbS5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKSAvLyB2YWxpZGF0b3IgZXJyb3JcbiAqICAgICAgIG0uZCA9IERhdGUoJzIwMTQtMTItMDgnKTtcbiAqICAgICAgIG0uc2F2ZSgpIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBjdXN0b20gZXJyb3IgbWVzc2FnZXNcbiAqICAgICAvLyBXZSBjYW4gYWxzbyB1c2UgdGhlIHNwZWNpYWwge01JTn0gdG9rZW4gd2hpY2ggd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBpbnZhbGlkIHZhbHVlXG4gKiAgICAgY29uc3QgbWluID0gW0RhdGUoJzE5NzAtMDEtMDEnKSwgJ1RoZSB2YWx1ZSBvZiBwYXRoIGB7UEFUSH1gICh7VkFMVUV9KSBpcyBiZW5lYXRoIHRoZSBsaW1pdCAoe01JTn0pLiddO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBkOiB7IHR5cGU6IERhdGUsIG1pbjogbWluIH0pXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKCdNJywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBzPSBuZXcgTSh7IGQ6IERhdGUoJzE5NjktMTItMzEnKSB9KTtcbiAqICAgICBzLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IFRoZSB2YWx1ZSBvZiBwYXRoIGBkYCAoMTk2OS0xMi0zMSkgaXMgYmVmb3JlIHRoZSBsaW1pdCAoMTk3MC0wMS0wMSkuXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge0RhdGV9IHZhbHVlIG1pbmltdW0gZGF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBDdXN0b21pemVkIEVycm9yIE1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEYXRlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5taW5WYWxpZGF0b3IpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvciAhPT0gdGhpcy5taW5WYWxpZGF0b3I7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICBpZiAodmFsdWUpIHtcbiAgICBsZXQgbXNnID0gbWVzc2FnZSB8fCBNb25nb29zZUVycm9yLm1lc3NhZ2VzLkRhdGUubWluO1xuICAgIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL3tNSU59LywgKHZhbHVlID09PSBEYXRlLm5vdyA/ICdEYXRlLm5vdygpJyA6IHZhbHVlLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMudmFsaWRhdG9ycy5wdXNoKHtcbiAgICAgIHZhbGlkYXRvcjogdGhpcy5taW5WYWxpZGF0b3IgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgbGV0IF92YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHZhbHVlICE9PSBEYXRlLm5vdykge1xuICAgICAgICAgIF92YWx1ZSA9IF92YWx1ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbiA9IChfdmFsdWUgPT09IERhdGUubm93ID8gX3ZhbHVlKCkgOiBfdGhpcy5jYXN0KF92YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdmFsID09PSBudWxsIHx8IHZhbC52YWx1ZU9mKCkgPj0gbWluLnZhbHVlT2YoKTtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiBtc2csXG4gICAgICB0eXBlOiAnbWluJyxcbiAgICAgIG1pbjogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgbWF4aW11bSBkYXRlIHZhbGlkYXRvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgZDogeyB0eXBlOiBEYXRlLCBtYXg6IERhdGUoJzIwMTQtMDEtMDEnKSB9KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgZDogRGF0ZSgnMjAxNC0xMi0wOCcpIH0pXG4gKiAgICAgbS5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKSAvLyB2YWxpZGF0b3IgZXJyb3JcbiAqICAgICAgIG0uZCA9IERhdGUoJzIwMTMtMTItMzEnKTtcbiAqICAgICAgIG0uc2F2ZSgpIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBjdXN0b20gZXJyb3IgbWVzc2FnZXNcbiAqICAgICAvLyBXZSBjYW4gYWxzbyB1c2UgdGhlIHNwZWNpYWwge01BWH0gdG9rZW4gd2hpY2ggd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBpbnZhbGlkIHZhbHVlXG4gKiAgICAgY29uc3QgbWF4ID0gW0RhdGUoJzIwMTQtMDEtMDEnKSwgJ1RoZSB2YWx1ZSBvZiBwYXRoIGB7UEFUSH1gICh7VkFMVUV9KSBleGNlZWRzIHRoZSBsaW1pdCAoe01BWH0pLiddO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBkOiB7IHR5cGU6IERhdGUsIG1heDogbWF4IH0pXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKCdNJywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBzPSBuZXcgTSh7IGQ6IERhdGUoJzIwMTQtMTItMDgnKSB9KTtcbiAqICAgICBzLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IFRoZSB2YWx1ZSBvZiBwYXRoIGBkYCAoMjAxNC0xMi0wOCkgZXhjZWVkcyB0aGUgbGltaXQgKDIwMTQtMDEtMDEpLlxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtEYXRlfSBtYXhpbXVtIGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGF0ZS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMubWF4VmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMubWF4VmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgaWYgKHZhbHVlKSB7XG4gICAgbGV0IG1zZyA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5EYXRlLm1heDtcbiAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC97TUFYfS8sICh2YWx1ZSA9PT0gRGF0ZS5ub3cgPyAnRGF0ZS5ub3coKScgOiB2YWx1ZS50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgICB2YWxpZGF0b3I6IHRoaXMubWF4VmFsaWRhdG9yID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGxldCBfdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBfdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgX3ZhbHVlICE9PSBEYXRlLm5vdykge1xuICAgICAgICAgIF92YWx1ZSA9IF92YWx1ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heCA9IChfdmFsdWUgPT09IERhdGUubm93ID8gX3ZhbHVlKCkgOiBfdGhpcy5jYXN0KF92YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdmFsID09PSBudWxsIHx8IHZhbC52YWx1ZU9mKCkgPD0gbWF4LnZhbHVlT2YoKTtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiBtc2csXG4gICAgICB0eXBlOiAnbWF4JyxcbiAgICAgIG1heDogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYXN0cyB0byBkYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRvIGNhc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYURhdGUucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBsZXQgY2FzdERhdGU7XG4gIGlmICh0eXBlb2YgdGhpcy5fY2FzdEZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdERhdGUgPSB0aGlzLl9jYXN0RnVuY3Rpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2FzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3REYXRlID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdERhdGUgPSBTY2hlbWFEYXRlLmNhc3QoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhc3REYXRlKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdkYXRlJywgdmFsdWUsIHRoaXMucGF0aCwgZXJyb3IsIHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIERhdGUgUXVlcnkgY2FzdGluZy5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsKSB7XG4gIHJldHVybiB0aGlzLmNhc3QodmFsKTtcbn1cblxuU2NoZW1hRGF0ZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7XG4gIC4uLlNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLFxuICAkZ3Q6IGhhbmRsZVNpbmdsZSxcbiAgJGd0ZTogaGFuZGxlU2luZ2xlLFxuICAkbHQ6IGhhbmRsZVNpbmdsZSxcbiAgJGx0ZTogaGFuZGxlU2luZ2xlXG59O1xuXG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kaXRpb25hbFxuICogQHBhcmFtIHthbnl9IFt2YWx1ZV1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYURhdGUucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kaXRpb25hbCwgdmFsLCBjb250ZXh0KSB7XG4gIGlmICgkY29uZGl0aW9uYWwgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmFwcGx5U2V0dGVycyh2YWwsIGNvbnRleHQpO1xuICB9XG5cbiAgY29uc3QgaGFuZGxlciA9IHRoaXMuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcblxuICBpZiAoIWhhbmRsZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlICcgKyAkY29uZGl0aW9uYWwgKyAnIHdpdGggRGF0ZS4nKTtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsKTtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFEYXRlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/date.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/decimal128.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/decimal128.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst CastError = SchemaType.CastError;\nconst castDecimal128 = __webpack_require__(/*! ../cast/decimal128 */ \"(api)/../server/node_modules/mongoose/lib/cast/decimal128.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\n/**\n * Decimal128 SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction Decimal128(key, options) {\n  SchemaType.call(this, key, options, 'Decimal128');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDecimal128.schemaName = 'Decimal128';\n\nDecimal128.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nDecimal128.prototype = Object.create(SchemaType.prototype);\nDecimal128.prototype.constructor = Decimal128;\n\n/*!\n * ignore\n */\n\nDecimal128._cast = castDecimal128;\n\n/**\n * Sets a default option for all Decimal128 instances.\n *\n * #### Example:\n *\n *     // Make all decimal 128s have `required` of true by default.\n *     mongoose.Schema.Decimal128.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.Decimal128 }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nDecimal128.set = SchemaType.set;\n\nDecimal128.setters = [];\n\n/**\n * Attaches a getter for all Decimal128 instances\n *\n * #### Example:\n *\n *     // Automatically convert Decimal128s to Numbers\n *     mongoose.Schema.Decimal128.get(v => v == null ? v : Number(v));\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nDecimal128.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to decimals.\n *\n * #### Example:\n *\n *     // Make Mongoose only refuse to cast numbers as decimal128\n *     const original = mongoose.Schema.Types.Decimal128.cast();\n *     mongoose.Decimal128.cast(v => {\n *       assert.ok(typeof v !== 'number');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Decimal128.cast(false);\n *\n * @param {Function} [caster]\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nDecimal128.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nDecimal128._defaultCaster = v => {\n  if (v != null && !isBsonType(v, 'Decimal128')) {\n    throw new Error();\n  }\n  return v;\n};\n\n/*!\n * ignore\n */\n\nDecimal128._checkRequired = v => isBsonType(v, 'Decimal128');\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nDecimal128.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nDecimal128.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    Decimal128.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to Decimal128\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nDecimal128.prototype.cast = function(value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    if (isBsonType(value, 'Decimal128')) {\n      return value;\n    }\n\n    return this._castRef(value, doc, init);\n  }\n\n  let castDecimal128;\n  if (typeof this._castFunction === 'function') {\n    castDecimal128 = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDecimal128 = this.constructor.cast();\n  } else {\n    castDecimal128 = Decimal128.cast();\n  }\n\n  try {\n    return castDecimal128(value);\n  } catch (error) {\n    throw new CastError('Decimal128', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nDecimal128.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Decimal128;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RlY2ltYWwxMjguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFlO0FBQzFDO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQW9CO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLDhGQUF1Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsMkJBQTJCO0FBQ25GLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHNjaGVtYVxcZGVjaW1hbDEyOC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hdHlwZScpO1xuY29uc3QgQ2FzdEVycm9yID0gU2NoZW1hVHlwZS5DYXN0RXJyb3I7XG5jb25zdCBjYXN0RGVjaW1hbDEyOCA9IHJlcXVpcmUoJy4uL2Nhc3QvZGVjaW1hbDEyOCcpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuXG4vKipcbiAqIERlY2ltYWwxMjggU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjaW1hbDEyOChrZXksIG9wdGlvbnMpIHtcbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIGtleSwgb3B0aW9ucywgJ0RlY2ltYWwxMjgnKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5EZWNpbWFsMTI4LnNjaGVtYU5hbWUgPSAnRGVjaW1hbDEyOCc7XG5cbkRlY2ltYWwxMjguZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cbkRlY2ltYWwxMjgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5EZWNpbWFsMTI4LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERlY2ltYWwxMjg7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRGVjaW1hbDEyOC5fY2FzdCA9IGNhc3REZWNpbWFsMTI4O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIERlY2ltYWwxMjggaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgZGVjaW1hbCAxMjhzIGhhdmUgYHJlcXVpcmVkYCBvZiB0cnVlIGJ5IGRlZmF1bHQuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkRlY2ltYWwxMjguc2V0KCdyZXF1aXJlZCcsIHRydWUpO1xuICpcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgdGVzdDogbW9uZ29vc2UuRGVjaW1hbDEyOCB9KSk7XG4gKiAgICAgbmV3IFVzZXIoeyB9KS52YWxpZGF0ZVN5bmMoKS5lcnJvcnMudGVzdC5tZXNzYWdlOyAvLyBQYXRoIGB0ZXN0YCBpcyByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjaW1hbDEyOC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuRGVjaW1hbDEyOC5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBEZWNpbWFsMTI4IGluc3RhbmNlc1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQXV0b21hdGljYWxseSBjb252ZXJ0IERlY2ltYWwxMjhzIHRvIE51bWJlcnNcbiAqICAgICBtb25nb29zZS5TY2hlbWEuRGVjaW1hbDEyOC5nZXQodiA9PiB2ID09IG51bGwgPyB2IDogTnVtYmVyKHYpKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY2ltYWwxMjguZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gZGVjaW1hbHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIE1vbmdvb3NlIG9ubHkgcmVmdXNlIHRvIGNhc3QgbnVtYmVycyBhcyBkZWNpbWFsMTI4XG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5TY2hlbWEuVHlwZXMuRGVjaW1hbDEyOC5jYXN0KCk7XG4gKiAgICAgbW9uZ29vc2UuRGVjaW1hbDEyOC5jYXN0KHYgPT4ge1xuICogICAgICAgYXNzZXJ0Lm9rKHR5cGVvZiB2ICE9PSAnbnVtYmVyJyk7XG4gKiAgICAgICByZXR1cm4gb3JpZ2luYWwodik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIE9yIGRpc2FibGUgY2FzdGluZyBlbnRpcmVseVxuICogICAgIG1vbmdvb3NlLkRlY2ltYWwxMjguY2FzdChmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2Nhc3Rlcl1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNpbWFsMTI4LmNhc3QgPSBmdW5jdGlvbiBjYXN0KGNhc3Rlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0O1xuICB9XG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdGhpcy5fZGVmYXVsdENhc3RlcjtcbiAgfVxuICB0aGlzLl9jYXN0ID0gY2FzdGVyO1xuXG4gIHJldHVybiB0aGlzLl9jYXN0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5EZWNpbWFsMTI4Ll9kZWZhdWx0Q2FzdGVyID0gdiA9PiB7XG4gIGlmICh2ICE9IG51bGwgJiYgIWlzQnNvblR5cGUodiwgJ0RlY2ltYWwxMjgnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5EZWNpbWFsMTI4Ll9jaGVja1JlcXVpcmVkID0gdiA9PiBpc0Jzb25UeXBlKHYsICdEZWNpbWFsMTI4Jyk7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjaW1hbDEyOC5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY2ltYWwxMjgucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbiBjaGVja1JlcXVpcmVkKHZhbHVlLCBkb2MpIHtcbiAgaWYgKFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIHRydWUpKSB7XG4gICAgcmV0dXJuICEhdmFsdWU7XG4gIH1cblxuICAvLyBgcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzKClgIGRvZXMgKipub3QqKiBjb3B5IHN0YXRpYyBwcm9wZXJ0aWVzLCBhbmRcbiAgLy8gcGx1Z2lucyBsaWtlIG1vbmdvb3NlLWZsb2F0IHVzZSBgaW5oZXJpdHMoKWAgZm9yIHByZS1FUzYuXG4gIGNvbnN0IF9jaGVja1JlcXVpcmVkID0gdHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkKCkgOlxuICAgIERlY2ltYWwxMjguY2hlY2tSZXF1aXJlZCgpO1xuXG4gIHJldHVybiBfY2hlY2tSZXF1aXJlZCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIENhc3RzIHRvIERlY2ltYWwxMjhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdCB3aGV0aGVyIHRoaXMgaXMgYW4gaW5pdGlhbGl6YXRpb24gY2FzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuRGVjaW1hbDEyOC5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgaWYgKFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIGluaXQpKSB7XG4gICAgaWYgKGlzQnNvblR5cGUodmFsdWUsICdEZWNpbWFsMTI4JykpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY2FzdFJlZih2YWx1ZSwgZG9jLCBpbml0KTtcbiAgfVxuXG4gIGxldCBjYXN0RGVjaW1hbDEyODtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0RGVjaW1hbDEyOCA9IHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdERlY2ltYWwxMjggPSB0aGlzLmNvbnN0cnVjdG9yLmNhc3QoKTtcbiAgfSBlbHNlIHtcbiAgICBjYXN0RGVjaW1hbDEyOCA9IERlY2ltYWwxMjguY2FzdCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdERlY2ltYWwxMjgodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ0RlY2ltYWwxMjgnLCB2YWx1ZSwgdGhpcy5wYXRoLCBlcnJvciwgdGhpcyk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHZhbCkge1xuICByZXR1cm4gdGhpcy5jYXN0KHZhbCk7XG59XG5cbkRlY2ltYWwxMjgucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzID0ge1xuICAuLi5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyxcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZVxufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlY2ltYWwxMjg7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/decimal128.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/documentarray.js":
/*!*******************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/documentarray.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ArrayType = __webpack_require__(/*! ./array */ \"(api)/../server/node_modules/mongoose/lib/schema/array.js\");\nconst CastError = __webpack_require__(/*! ../error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\nconst DocumentArrayElement = __webpack_require__(/*! ./DocumentArrayElement */ \"(api)/../server/node_modules/mongoose/lib/schema/DocumentArrayElement.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst SchemaDocumentArrayOptions =\n  __webpack_require__(/*! ../options/SchemaDocumentArrayOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst discriminator = __webpack_require__(/*! ../helpers/model/discriminator */ \"(api)/../server/node_modules/mongoose/lib/helpers/model/discriminator.js\");\nconst handleIdOption = __webpack_require__(/*! ../helpers/schema/handleIdOption */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/handleIdOption.js\");\nconst handleSpreadDoc = __webpack_require__(/*! ../helpers/document/handleSpreadDoc */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst getConstructor = __webpack_require__(/*! ../helpers/discriminator/getConstructor */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\");\nconst InvalidSchemaOptionError = __webpack_require__(/*! ../error/invalidSchemaOption */ \"(api)/../server/node_modules/mongoose/lib/error/invalidSchemaOption.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst documentArrayParent = (__webpack_require__(/*! ../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArrayPath(key, schema, options, schemaOptions) {\n  if (schema.options && schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(key, 'timeseries');\n  }\n  const schemaTypeIdOption = DocumentArrayPath.defaultOptions &&\n    DocumentArrayPath.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    schemaOptions = schemaOptions || {};\n    schemaOptions._id = schemaTypeIdOption;\n  }\n\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  ArrayType.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n\n  EmbeddedDocument.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n\n  const $parentSchemaType = this;\n  this.$embeddedSchemaType = new DocumentArrayElement(key + '.$', {\n    required: this &&\n      this.schemaOptions &&\n      this.schemaOptions.required || false,\n    $parentSchemaType\n  });\n\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDocumentArrayPath.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nDocumentArrayPath.options = { castNonArrays: true };\n\n/*!\n * Inherits from ArrayType.\n */\nDocumentArrayPath.prototype = Object.create(ArrayType.prototype);\nDocumentArrayPath.prototype.constructor = DocumentArrayPath;\nDocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = __webpack_require__(/*! ../types/ArraySubdocument */ \"(api)/../server/node_modules/mongoose/lib/types/ArraySubdocument.js\"));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {\n      return;\n    }\n    this.$session(this.__parentArray.getArrayParent().$session());\n  }\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n  EmbeddedDocument.base = schema.base;\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nDocumentArrayPath.prototype.discriminator = function(name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(/*! ../types/DocumentArray */ \"(api)/../server/node_modules/mongoose/lib/types/DocumentArray/index.js\"));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!utils.isMongooseDocumentArray(array)) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidateSync = function(array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.getDefault = function(scope, init, options) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  if (options && options.skipCast) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(/*! ../types/DocumentArray */ \"(api)/../server/node_modules/mongoose/lib/types/DocumentArray/index.js\"));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined,\n      undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\nconst _toObjectOptions = Object.freeze({ transform: false, virtuals: false });\nconst initDocumentOptions = Object.freeze({ skipId: false, willInit: true });\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nDocumentArrayPath.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(/*! ../types/DocumentArray */ \"(api)/../server/node_modules/mongoose/lib/types/DocumentArray/index.js\"));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n\n  options = options || {};\n\n  const path = options.path || this.path;\n\n  if (!Array.isArray(value)) {\n    if (!init && !DocumentArrayPath.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, path, doc);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = path + '.' + options.arrayPathIndex;\n  }\n\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, rawArray[i]);\n\n    const spreadDoc = handleSpreadDoc(rawArray[i], true);\n    if (rawArray[i] !== spreadDoc) {\n      rawArray[i] = spreadDoc;\n    }\n\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      }\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i],\n              value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.applyGetters = function(value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array the array to scope `fields` paths\n * @param {Object|undefined} fields the root fields selected in the query\n * @param {Boolean|undefined} init if we are being created part of a query result\n * @api private\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.defaultOptions = {};\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nDocumentArrayPath.set = SchemaType.set;\n\nDocumentArrayPath.setters = [];\n\n/**\n * Attaches a getter for all DocumentArrayPath instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nDocumentArrayPath.get = SchemaType.get;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArrayPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RvY3VtZW50YXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLDBFQUFTO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFlO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLHdHQUF3QjtBQUM3RCxxQkFBcUIsMERBQThCO0FBQ25EO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLDhIQUF1QztBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBZTtBQUMxQyxzQkFBc0IsbUJBQU8sQ0FBQyxnSEFBZ0M7QUFDOUQsdUJBQXVCLG1CQUFPLENBQUMsb0hBQWtDO0FBQ2pFLHdCQUF3QixtQkFBTyxDQUFDLDBIQUFxQztBQUNyRSxjQUFjLG1CQUFPLENBQUMsb0VBQVU7QUFDaEMsdUJBQXVCLG1CQUFPLENBQUMsa0lBQXlDO0FBQ3hFLGlDQUFpQyxtQkFBTyxDQUFDLDRHQUE4Qjs7QUFFdkUsMkJBQTJCLGtJQUFnRDtBQUMzRSx3QkFBd0IsK0hBQTZDO0FBQ3JFLDRCQUE0QixtSUFBaUQ7O0FBRTdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FB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Q0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxzY2hlbWFcXGRvY3VtZW50YXJyYXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQXJyYXlUeXBlID0gcmVxdWlyZSgnLi9hcnJheScpO1xuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvY2FzdCcpO1xuY29uc3QgRG9jdW1lbnRBcnJheUVsZW1lbnQgPSByZXF1aXJlKCcuL0RvY3VtZW50QXJyYXlFbGVtZW50Jyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucyA9XG4gIHJlcXVpcmUoJy4uL29wdGlvbnMvU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMnKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWF0eXBlJyk7XG5jb25zdCBkaXNjcmltaW5hdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9tb2RlbC9kaXNjcmltaW5hdG9yJyk7XG5jb25zdCBoYW5kbGVJZE9wdGlvbiA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc2NoZW1hL2hhbmRsZUlkT3B0aW9uJyk7XG5jb25zdCBoYW5kbGVTcHJlYWREb2MgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvY3VtZW50L2hhbmRsZVNwcmVhZERvYycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgZ2V0Q29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0Q29uc3RydWN0b3InKTtcbmNvbnN0IEludmFsaWRTY2hlbWFPcHRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2ludmFsaWRTY2hlbWFPcHRpb24nKTtcblxuY29uc3QgYXJyYXlBdG9taWNzU3ltYm9sID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzU3ltYm9sO1xuY29uc3QgYXJyYXlQYXRoU3ltYm9sID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXRoU3ltYm9sO1xuY29uc3QgZG9jdW1lbnRBcnJheVBhcmVudCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc3ltYm9scycpLmRvY3VtZW50QXJyYXlQYXJlbnQ7XG5cbmxldCBNb25nb29zZURvY3VtZW50QXJyYXk7XG5sZXQgU3ViZG9jdW1lbnQ7XG5cbi8qKlxuICogU3ViZG9jc0FycmF5IFNjaGVtYVR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYU9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFBcnJheVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBEb2N1bWVudEFycmF5UGF0aChrZXksIHNjaGVtYSwgb3B0aW9ucywgc2NoZW1hT3B0aW9ucykge1xuICBpZiAoc2NoZW1hLm9wdGlvbnMgJiYgc2NoZW1hLm9wdGlvbnMudGltZXNlcmllcykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkU2NoZW1hT3B0aW9uRXJyb3Ioa2V5LCAndGltZXNlcmllcycpO1xuICB9XG4gIGNvbnN0IHNjaGVtYVR5cGVJZE9wdGlvbiA9IERvY3VtZW50QXJyYXlQYXRoLmRlZmF1bHRPcHRpb25zICYmXG4gICAgRG9jdW1lbnRBcnJheVBhdGguZGVmYXVsdE9wdGlvbnMuX2lkO1xuICBpZiAoc2NoZW1hVHlwZUlkT3B0aW9uICE9IG51bGwpIHtcbiAgICBzY2hlbWFPcHRpb25zID0gc2NoZW1hT3B0aW9ucyB8fCB7fTtcbiAgICBzY2hlbWFPcHRpb25zLl9pZCA9IHNjaGVtYVR5cGVJZE9wdGlvbjtcbiAgfVxuXG4gIGlmIChzY2hlbWFPcHRpb25zICE9IG51bGwgJiYgc2NoZW1hT3B0aW9ucy5faWQgIT0gbnVsbCkge1xuICAgIHNjaGVtYSA9IGhhbmRsZUlkT3B0aW9uKHNjaGVtYSwgc2NoZW1hT3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuX2lkICE9IG51bGwpIHtcbiAgICBzY2hlbWEgPSBoYW5kbGVJZE9wdGlvbihzY2hlbWEsIG9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgRW1iZWRkZWREb2N1bWVudCA9IF9jcmVhdGVDb25zdHJ1Y3RvcihzY2hlbWEsIG9wdGlvbnMpO1xuICBFbWJlZGRlZERvY3VtZW50LnByb3RvdHlwZS4kYmFzZVBhdGggPSBrZXk7XG5cbiAgQXJyYXlUeXBlLmNhbGwodGhpcywga2V5LCBFbWJlZGRlZERvY3VtZW50LCBvcHRpb25zKTtcblxuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgdGhpcy5zY2hlbWFPcHRpb25zID0gc2NoZW1hT3B0aW9ucyB8fCB7fTtcbiAgdGhpcy4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgPSB0cnVlO1xuICB0aGlzLkNvbnN0cnVjdG9yID0gRW1iZWRkZWREb2N1bWVudDtcblxuICBFbWJlZGRlZERvY3VtZW50LmJhc2UgPSBzY2hlbWEuYmFzZTtcblxuICBjb25zdCBmbiA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuXG4gIGlmICghKCdkZWZhdWx0VmFsdWUnIGluIHRoaXMpIHx8IGZuICE9PSB2b2lkIDApIHtcbiAgICB0aGlzLmRlZmF1bHQoZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgYXJyID0gZm4uY2FsbCh0aGlzKTtcbiAgICAgIGlmIChhcnIgIT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGFyciA9IFthcnJdO1xuICAgICAgfVxuICAgICAgLy8gTGVhdmUgaXQgdXAgdG8gYGNhc3QoKWAgdG8gY29udmVydCB0aGlzIHRvIGEgZG9jdW1lbnRhcnJheVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0ICRwYXJlbnRTY2hlbWFUeXBlID0gdGhpcztcbiAgdGhpcy4kZW1iZWRkZWRTY2hlbWFUeXBlID0gbmV3IERvY3VtZW50QXJyYXlFbGVtZW50KGtleSArICcuJCcsIHtcbiAgICByZXF1aXJlZDogdGhpcyAmJlxuICAgICAgdGhpcy5zY2hlbWFPcHRpb25zICYmXG4gICAgICB0aGlzLnNjaGVtYU9wdGlvbnMucmVxdWlyZWQgfHwgZmFsc2UsXG4gICAgJHBhcmVudFNjaGVtYVR5cGVcbiAgfSk7XG5cbiAgdGhpcy4kZW1iZWRkZWRTY2hlbWFUeXBlLmNhc3RlciA9IHRoaXMuQ29uc3RydWN0b3I7XG4gIHRoaXMuJGVtYmVkZGVkU2NoZW1hVHlwZS5zY2hlbWEgPSB0aGlzLnNjaGVtYTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5Eb2N1bWVudEFycmF5UGF0aC5zY2hlbWFOYW1lID0gJ0RvY3VtZW50QXJyYXknO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGFsbCBkb2N1bWVudCBhcnJheXMuXG4gKlxuICogLSBgY2FzdE5vbkFycmF5c2A6IGB0cnVlYCBieSBkZWZhdWx0LiBJZiBgZmFsc2VgLCBNb25nb29zZSB3aWxsIHRocm93IGEgQ2FzdEVycm9yIHdoZW4gYSB2YWx1ZSBpc24ndCBhbiBhcnJheS4gSWYgYHRydWVgLCBNb25nb29zZSB3aWxsIHdyYXAgdGhlIHByb3ZpZGVkIHZhbHVlIGluIGFuIGFycmF5IGJlZm9yZSBjYXN0aW5nLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnRBcnJheVBhdGgub3B0aW9ucyA9IHsgY2FzdE5vbkFycmF5czogdHJ1ZSB9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gQXJyYXlUeXBlLlxuICovXG5Eb2N1bWVudEFycmF5UGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFycmF5VHlwZS5wcm90b3R5cGUpO1xuRG9jdW1lbnRBcnJheVBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9jdW1lbnRBcnJheVBhdGg7XG5Eb2N1bWVudEFycmF5UGF0aC5wcm90b3R5cGUuT3B0aW9uc0NvbnN0cnVjdG9yID0gU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2NyZWF0ZUNvbnN0cnVjdG9yKHNjaGVtYSwgb3B0aW9ucywgYmFzZUNsYXNzKSB7XG4gIFN1YmRvY3VtZW50IHx8IChTdWJkb2N1bWVudCA9IHJlcXVpcmUoJy4uL3R5cGVzL0FycmF5U3ViZG9jdW1lbnQnKSk7XG5cbiAgLy8gY29tcGlsZSBhbiBlbWJlZGRlZCBkb2N1bWVudCBmb3IgdGhpcyBzY2hlbWFcbiAgZnVuY3Rpb24gRW1iZWRkZWREb2N1bWVudCgpIHtcbiAgICBTdWJkb2N1bWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLl9fcGFyZW50QXJyYXkgPT0gbnVsbCB8fCB0aGlzLl9fcGFyZW50QXJyYXkuZ2V0QXJyYXlQYXJlbnQoKSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuJHNlc3Npb24odGhpcy5fX3BhcmVudEFycmF5LmdldEFycmF5UGFyZW50KCkuJHNlc3Npb24oKSk7XG4gIH1cblxuICBzY2hlbWEuX3ByZUNvbXBpbGUoKTtcblxuICBjb25zdCBwcm90byA9IGJhc2VDbGFzcyAhPSBudWxsID8gYmFzZUNsYXNzLnByb3RvdHlwZSA6IFN1YmRvY3VtZW50LnByb3RvdHlwZTtcbiAgRW1iZWRkZWREb2N1bWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgRW1iZWRkZWREb2N1bWVudC5wcm90b3R5cGUuJF9fc2V0U2NoZW1hKHNjaGVtYSk7XG4gIEVtYmVkZGVkRG9jdW1lbnQuc2NoZW1hID0gc2NoZW1hO1xuICBFbWJlZGRlZERvY3VtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVtYmVkZGVkRG9jdW1lbnQ7XG4gIEVtYmVkZGVkRG9jdW1lbnQuJGlzQXJyYXlTdWJkb2N1bWVudCA9IHRydWU7XG4gIEVtYmVkZGVkRG9jdW1lbnQuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBFbWJlZGRlZERvY3VtZW50LmJhc2UgPSBzY2hlbWEuYmFzZTtcblxuICAvLyBhcHBseSBtZXRob2RzXG4gIGZvciAoY29uc3QgaSBpbiBzY2hlbWEubWV0aG9kcykge1xuICAgIEVtYmVkZGVkRG9jdW1lbnQucHJvdG90eXBlW2ldID0gc2NoZW1hLm1ldGhvZHNbaV07XG4gIH1cblxuICAvLyBhcHBseSBzdGF0aWNzXG4gIGZvciAoY29uc3QgaSBpbiBzY2hlbWEuc3RhdGljcykge1xuICAgIEVtYmVkZGVkRG9jdW1lbnRbaV0gPSBzY2hlbWEuc3RhdGljc1tpXTtcbiAgfVxuXG4gIGZvciAoY29uc3QgaSBpbiBFdmVudEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgRW1iZWRkZWREb2N1bWVudFtpXSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGVbaV07XG4gIH1cblxuICBFbWJlZGRlZERvY3VtZW50Lm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gIHJldHVybiBFbWJlZGRlZERvY3VtZW50O1xufVxuXG4vKipcbiAqIEFkZHMgYSBkaXNjcmltaW5hdG9yIHRvIHRoaXMgZG9jdW1lbnQgYXJyYXkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzaGFwZVNjaGVtYSA9IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9LCB7IGRpc2NyaW1pbmF0b3JLZXk6ICdraW5kJyB9KTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEoeyBzaGFwZXM6IFtzaGFwZVNjaGVtYV0gfSk7XG4gKlxuICogICAgIGNvbnN0IGRvY0FycmF5UGF0aCA9IHBhcmVudFNjaGVtYS5wYXRoKCdzaGFwZXMnKTtcbiAqICAgICBkb2NBcnJheVBhdGguZGlzY3JpbWluYXRvcignQ2lyY2xlJywgU2NoZW1hKHsgcmFkaXVzOiBOdW1iZXIgfSkpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hIGZpZWxkcyB0byBhZGQgdG8gdGhlIHNjaGVtYSBmb3IgaW5zdGFuY2VzIG9mIHRoaXMgc3ViLWNsYXNzXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBJZiBzdHJpbmcsIHNhbWUgYXMgYG9wdGlvbnMudmFsdWVgLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnZhbHVlXSB0aGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgYGRpc2NyaW1pbmF0b3JLZXlgIHByb3BlcnR5LiBJZiBub3Qgc3BlY2lmaWVkLCBNb25nb29zZSB1c2VzIHRoZSBgbmFtZWAgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbG9uZT10cnVlXSBCeSBkZWZhdWx0LCBgZGlzY3JpbWluYXRvcigpYCBjbG9uZXMgdGhlIGdpdmVuIGBzY2hlbWFgLiBTZXQgdG8gYGZhbHNlYCB0byBza2lwIGNsb25pbmcuXG4gKiBAc2VlIGRpc2NyaW1pbmF0b3JzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9kaXNjcmltaW5hdG9ycy5odG1sXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGNvbnN0cnVjdG9yIE1vbmdvb3NlIHdpbGwgdXNlIGZvciBjcmVhdGluZyBpbnN0YW5jZXMgb2YgdGhpcyBkaXNjcmltaW5hdG9yIG1vZGVsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50QXJyYXlQYXRoLnByb3RvdHlwZS5kaXNjcmltaW5hdG9yID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG5hbWUgPSB1dGlscy5nZXRGdW5jdGlvbk5hbWUobmFtZSk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgdGllZFZhbHVlID0gdXRpbHMuaXNQT0pPKG9wdGlvbnMpID8gb3B0aW9ucy52YWx1ZSA6IG9wdGlvbnM7XG4gIGNvbnN0IGNsb25lID0gdHlwZW9mIG9wdGlvbnMuY2xvbmUgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuY2xvbmUgOiB0cnVlO1xuXG4gIGlmIChzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSAmJiBjbG9uZSkge1xuICAgIHNjaGVtYSA9IHNjaGVtYS5jbG9uZSgpO1xuICB9XG5cbiAgc2NoZW1hID0gZGlzY3JpbWluYXRvcih0aGlzLmNhc3RlckNvbnN0cnVjdG9yLCBuYW1lLCBzY2hlbWEsIHRpZWRWYWx1ZSk7XG5cbiAgY29uc3QgRW1iZWRkZWREb2N1bWVudCA9IF9jcmVhdGVDb25zdHJ1Y3RvcihzY2hlbWEsIG51bGwsIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IpO1xuICBFbWJlZGRlZERvY3VtZW50LmJhc2VDYXN0ZXJDb25zdHJ1Y3RvciA9IHRoaXMuY2FzdGVyQ29uc3RydWN0b3I7XG5cbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1iZWRkZWREb2N1bWVudCwgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogbmFtZVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIElnbm9yZSBlcnJvciwgb25seSBoYXBwZW5zIG9uIG9sZCB2ZXJzaW9ucyBvZiBub2RlXG4gIH1cblxuICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW25hbWVdID0gRW1iZWRkZWREb2N1bWVudDtcblxuICByZXR1cm4gdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1tuYW1lXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgbG9jYWwgdmFsaWRhdGlvbnMgZmlyc3QsIHRoZW4gdmFsaWRhdGlvbnMgb24gZWFjaCBlbWJlZGRlZCBkb2NcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Eb2N1bWVudEFycmF5UGF0aC5wcm90b3R5cGUuZG9WYWxpZGF0ZSA9IGZ1bmN0aW9uKGFycmF5LCBmbiwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgLy8gbGF6eSBsb2FkXG4gIE1vbmdvb3NlRG9jdW1lbnRBcnJheSB8fCAoTW9uZ29vc2VEb2N1bWVudEFycmF5ID0gcmVxdWlyZSgnLi4vdHlwZXMvRG9jdW1lbnRBcnJheScpKTtcblxuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIHRyeSB7XG4gICAgU2NoZW1hVHlwZS5wcm90b3R5cGUuZG9WYWxpZGF0ZS5jYWxsKHRoaXMsIGFycmF5LCBjYiwgc2NvcGUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZm4oZXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNiKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBmbihlcnIpO1xuICAgIH1cblxuICAgIGxldCBjb3VudCA9IGFycmF5ICYmIGFycmF5Lmxlbmd0aDtcbiAgICBsZXQgZXJyb3I7XG5cbiAgICBpZiAoIWNvdW50KSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51cGRhdGVWYWxpZGF0b3IpIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICBpZiAoIXV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KGFycmF5KSkge1xuICAgICAgYXJyYXkgPSBuZXcgTW9uZ29vc2VEb2N1bWVudEFycmF5KGFycmF5LCBfdGhpcy5wYXRoLCBzY29wZSk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHNwYXJzZSBhcnJheXMsIGRvIG5vdCB1c2UgYXJyYXkuZm9yRWFjaCB3aGljaCBkb2VzIG5vdFxuICAgIC8vIGl0ZXJhdGUgb3ZlciBzcGFyc2UgZWxlbWVudHMgeWV0IHJlcG9ydHMgYXJyYXkubGVuZ3RoIGluY2x1ZGluZ1xuICAgIC8vIHRoZW0gOihcblxuICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGVycikge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgICAgLS1jb3VudCB8fCBmbihlcnJvcik7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNvdW50OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIC8vIHNpZGVzdGVwIHNwYXJzZSBlbnRyaWVzXG4gICAgICBsZXQgZG9jID0gYXJyYXlbaV07XG4gICAgICBpZiAoZG9jID09IG51bGwpIHtcbiAgICAgICAgLS1jb3VudCB8fCBmbihlcnJvcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB5b3Ugc2V0IHRoZSBhcnJheSBpbmRleCBkaXJlY3RseSwgdGhlIGRvYyBtaWdodCBub3QgeWV0IGJlXG4gICAgICAvLyBhIGZ1bGwgZmxlZGdlZCBtb25nb29zZSBzdWJkb2MsIHNvIG1ha2UgaXQgaW50byBvbmUuXG4gICAgICBpZiAoIShkb2MgaW5zdGFuY2VvZiBTdWJkb2N1bWVudCkpIHtcbiAgICAgICAgY29uc3QgQ29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3RvcihfdGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciwgYXJyYXlbaV0pO1xuICAgICAgICBkb2MgPSBhcnJheVtpXSA9IG5ldyBDb25zdHJ1Y3Rvcihkb2MsIGFycmF5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seSAmJiAhZG9jLiRpc01vZGlmaWVkKCkpIHtcbiAgICAgICAgLS1jb3VudCB8fCBmbihlcnJvcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkb2MuJF9fdmFsaWRhdGUoY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBsb2NhbCB2YWxpZGF0aW9ucyBmaXJzdCwgdGhlbiB2YWxpZGF0aW9ucyBvbiBlYWNoIGVtYmVkZGVkIGRvYy5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogVGhpcyBtZXRob2QgaWdub3JlcyB0aGUgYXN5bmNocm9ub3VzIHZhbGlkYXRvcnMuXG4gKlxuICogQHJldHVybiB7TW9uZ29vc2VFcnJvcnx1bmRlZmluZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Eb2N1bWVudEFycmF5UGF0aC5wcm90b3R5cGUuZG9WYWxpZGF0ZVN5bmMgPSBmdW5jdGlvbihhcnJheSwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1hVHlwZUVycm9yID0gU2NoZW1hVHlwZS5wcm90b3R5cGUuZG9WYWxpZGF0ZVN5bmMuY2FsbCh0aGlzLCBhcnJheSwgc2NvcGUpO1xuICBpZiAoc2NoZW1hVHlwZUVycm9yICE9IG51bGwpIHtcbiAgICByZXR1cm4gc2NoZW1hVHlwZUVycm9yO1xuICB9XG5cbiAgY29uc3QgY291bnQgPSBhcnJheSAmJiBhcnJheS5sZW5ndGg7XG4gIGxldCByZXN1bHRFcnJvciA9IG51bGw7XG5cbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGhhbmRsZSBzcGFyc2UgYXJyYXlzLCBkbyBub3QgdXNlIGFycmF5LmZvckVhY2ggd2hpY2ggZG9lcyBub3RcbiAgLy8gaXRlcmF0ZSBvdmVyIHNwYXJzZSBlbGVtZW50cyB5ZXQgcmVwb3J0cyBhcnJheS5sZW5ndGggaW5jbHVkaW5nXG4gIC8vIHRoZW0gOihcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gY291bnQ7IGkgPCBsZW47ICsraSkge1xuICAgIC8vIHNpZGVzdGVwIHNwYXJzZSBlbnRyaWVzXG4gICAgbGV0IGRvYyA9IGFycmF5W2ldO1xuICAgIGlmICghZG9jKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB5b3Ugc2V0IHRoZSBhcnJheSBpbmRleCBkaXJlY3RseSwgdGhlIGRvYyBtaWdodCBub3QgeWV0IGJlXG4gICAgLy8gYSBmdWxsIGZsZWRnZWQgbW9uZ29vc2Ugc3ViZG9jLCBzbyBtYWtlIGl0IGludG8gb25lLlxuICAgIGlmICghKGRvYyBpbnN0YW5jZW9mIFN1YmRvY3VtZW50KSkge1xuICAgICAgY29uc3QgQ29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzLmNhc3RlckNvbnN0cnVjdG9yLCBhcnJheVtpXSk7XG4gICAgICBkb2MgPSBhcnJheVtpXSA9IG5ldyBDb25zdHJ1Y3Rvcihkb2MsIGFycmF5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5ICYmICFkb2MuJGlzTW9kaWZpZWQoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ViZG9jVmFsaWRhdGVFcnJvciA9IGRvYy52YWxpZGF0ZVN5bmMoKTtcblxuICAgIGlmIChzdWJkb2NWYWxpZGF0ZUVycm9yICYmIHJlc3VsdEVycm9yID09IG51bGwpIHtcbiAgICAgIHJlc3VsdEVycm9yID0gc3ViZG9jVmFsaWRhdGVFcnJvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0RXJyb3I7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50QXJyYXlQYXRoLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24oc2NvcGUsIGluaXQsIG9wdGlvbnMpIHtcbiAgbGV0IHJldCA9IHR5cGVvZiB0aGlzLmRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gdGhpcy5kZWZhdWx0VmFsdWUuY2FsbChzY29wZSlcbiAgICA6IHRoaXMuZGVmYXVsdFZhbHVlO1xuXG4gIGlmIChyZXQgPT0gbnVsbCkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNraXBDYXN0KSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIGxhenkgbG9hZFxuICBNb25nb29zZURvY3VtZW50QXJyYXkgfHwgKE1vbmdvb3NlRG9jdW1lbnRBcnJheSA9IHJlcXVpcmUoJy4uL3R5cGVzL0RvY3VtZW50QXJyYXknKSk7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHJldCkpIHtcbiAgICByZXQgPSBbcmV0XTtcbiAgfVxuXG4gIHJldCA9IG5ldyBNb25nb29zZURvY3VtZW50QXJyYXkocmV0LCB0aGlzLnBhdGgsIHNjb3BlKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciwgcmV0W2ldKTtcbiAgICBjb25zdCBfc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKHt9LCByZXQsIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCwgaSk7XG4gICAgX3N1YmRvYy4kaW5pdChyZXRbaV0pO1xuICAgIF9zdWJkb2MuaXNOZXcgPSB0cnVlO1xuXG4gICAgLy8gTWFrZSBzdXJlIGFsbCBwYXRocyBpbiB0aGUgc3ViZG9jIGFyZSBzZXQgdG8gYGRlZmF1bHRgIGluc3RlYWRcbiAgICAvLyBvZiBgaW5pdGAgc2luY2Ugd2UgdXNlZCBgaW5pdGAuXG4gICAgT2JqZWN0LmFzc2lnbihfc3ViZG9jLiRfXy5hY3RpdmVQYXRocy5kZWZhdWx0LCBfc3ViZG9jLiRfXy5hY3RpdmVQYXRocy5pbml0KTtcbiAgICBfc3ViZG9jLiRfXy5hY3RpdmVQYXRocy5pbml0ID0ge307XG5cbiAgICByZXRbaV0gPSBfc3ViZG9jO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmNvbnN0IF90b09iamVjdE9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHsgdHJhbnNmb3JtOiBmYWxzZSwgdmlydHVhbHM6IGZhbHNlIH0pO1xuY29uc3QgaW5pdERvY3VtZW50T3B0aW9ucyA9IE9iamVjdC5mcmVlemUoeyBza2lwSWQ6IGZhbHNlLCB3aWxsSW5pdDogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jdW1lbnQgdGhhdCB0cmlnZ2VycyB0aGUgY2FzdGluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuRG9jdW1lbnRBcnJheVBhdGgucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSwgZG9jLCBpbml0LCBwcmV2LCBvcHRpb25zKSB7XG4gIC8vIGxhenkgbG9hZFxuICBNb25nb29zZURvY3VtZW50QXJyYXkgfHwgKE1vbmdvb3NlRG9jdW1lbnRBcnJheSA9IHJlcXVpcmUoJy4uL3R5cGVzL0RvY3VtZW50QXJyYXknKSk7XG5cbiAgLy8gU2tpcCBjYXN0aW5nIGlmIGB2YWx1ZWAgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHZhbHVlLCBubyBuZWVkIHRvIGNhc3QuIFNlZSBnaC05MjY2XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlW2FycmF5UGF0aFN5bWJvbF0gIT0gbnVsbCAmJiB2YWx1ZSA9PT0gcHJldikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGxldCBzZWxlY3RlZDtcbiAgbGV0IHN1YmRvYztcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBwYXRoID0gb3B0aW9ucy5wYXRoIHx8IHRoaXMucGF0aDtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgaWYgKCFpbml0ICYmICFEb2N1bWVudEFycmF5UGF0aC5vcHRpb25zLmNhc3ROb25BcnJheXMpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ0RvY3VtZW50QXJyYXknLCB2YWx1ZSwgdGhpcy5wYXRoLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgLy8gZ2gtMjQ0MiBtYXJrIHdob2xlIGFycmF5IGFzIG1vZGlmaWVkIGlmIHdlJ3JlIGluaXRpYWxpemluZyBhIGRvYyBmcm9tXG4gICAgLy8gdGhlIGRiIGFuZCB0aGUgcGF0aCBpc24ndCBhbiBhcnJheSBpbiB0aGUgZG9jdW1lbnRcbiAgICBpZiAoISFkb2MgJiYgaW5pdCkge1xuICAgICAgZG9jLm1hcmtNb2RpZmllZChwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FzdChbdmFsdWVdLCBkb2MsIGluaXQsIHByZXYsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gV2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgYXJyYXksIG90aGVyd2lzZSBjaGFuZ2UgdHJhY2tpbmcgd2lsbFxuICAvLyB1cGRhdGUgdGhlIG9sZCBkb2MgKGdoLTQ0NDkpXG4gIGlmICghb3B0aW9ucy5za2lwRG9jdW1lbnRBcnJheUNhc3QgfHwgdXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBuZXcgTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbHVlLCBwYXRoLCBkb2MpO1xuICB9XG5cbiAgaWYgKHByZXYgIT0gbnVsbCkge1xuICAgIHZhbHVlW2FycmF5QXRvbWljc1N5bWJvbF0gPSBwcmV2W2FycmF5QXRvbWljc1N5bWJvbF0gfHwge307XG4gIH1cblxuICBpZiAob3B0aW9ucy5hcnJheVBhdGhJbmRleCAhPSBudWxsKSB7XG4gICAgdmFsdWVbYXJyYXlQYXRoU3ltYm9sXSA9IHBhdGggKyAnLicgKyBvcHRpb25zLmFycmF5UGF0aEluZGV4O1xuICB9XG5cbiAgY29uc3QgcmF3QXJyYXkgPSB1dGlscy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWx1ZSkgPyB2YWx1ZS5fX2FycmF5IDogdmFsdWU7XG4gIGNvbnN0IGxlbiA9IHJhd0FycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKCFyYXdBcnJheVtpXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgQ29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzLmNhc3RlckNvbnN0cnVjdG9yLCByYXdBcnJheVtpXSk7XG5cbiAgICBjb25zdCBzcHJlYWREb2MgPSBoYW5kbGVTcHJlYWREb2MocmF3QXJyYXlbaV0sIHRydWUpO1xuICAgIGlmIChyYXdBcnJheVtpXSAhPT0gc3ByZWFkRG9jKSB7XG4gICAgICByYXdBcnJheVtpXSA9IHNwcmVhZERvYztcbiAgICB9XG5cbiAgICBpZiAocmF3QXJyYXlbaV0gaW5zdGFuY2VvZiBTdWJkb2N1bWVudCkge1xuICAgICAgaWYgKHJhd0FycmF5W2ldW2RvY3VtZW50QXJyYXlQYXJlbnRdICE9PSBkb2MpIHtcbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICBjb25zdCBzdWJkb2MgPSBuZXcgQ29uc3RydWN0b3IobnVsbCwgdmFsdWUsIGluaXREb2N1bWVudE9wdGlvbnMsIHNlbGVjdGVkLCBpKTtcbiAgICAgICAgICByYXdBcnJheVtpXSA9IHN1YmRvYy4kaW5pdChyYXdBcnJheVtpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKHJhd0FycmF5W2ldLCB2YWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGkpO1xuICAgICAgICAgIHJhd0FycmF5W2ldID0gc3ViZG9jO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBNaWdodCBub3QgaGF2ZSB0aGUgY29ycmVjdCBpbmRleCB5ZXQsIHNvIGVuc3VyZSBpdCBkb2VzLlxuICAgICAgaWYgKHJhd0FycmF5W2ldLl9faW5kZXggPT0gbnVsbCkge1xuICAgICAgICByYXdBcnJheVtpXS4kc2V0SW5kZXgoaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyYXdBcnJheVtpXSAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5pdCkge1xuICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgfHwgKHNlbGVjdGVkID0gc2NvcGVQYXRocyh0aGlzLCBkb2MuJF9fLnNlbGVjdGVkLCBpbml0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKG51bGwsIHZhbHVlLCBpbml0RG9jdW1lbnRPcHRpb25zLCBzZWxlY3RlZCwgaSk7XG4gICAgICAgIHJhd0FycmF5W2ldID0gc3ViZG9jLiRpbml0KHJhd0FycmF5W2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2ICYmIHR5cGVvZiBwcmV2LmlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc3ViZG9jID0gcHJldi5pZChyYXdBcnJheVtpXS5faWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXYgJiYgc3ViZG9jICYmIHV0aWxzLmRlZXBFcXVhbChzdWJkb2MudG9PYmplY3QoX3RvT2JqZWN0T3B0aW9ucyksIHJhd0FycmF5W2ldKSkge1xuICAgICAgICAgIC8vIGhhbmRsZSByZXNldHRpbmcgZG9jIHdpdGggZXhpc3RpbmcgaWQgYW5kIHNhbWUgZGF0YVxuICAgICAgICAgIHN1YmRvYy5zZXQocmF3QXJyYXlbaV0pO1xuICAgICAgICAgIC8vIGlmIHNldCgpIGlzIGhvb2tlZCBpdCB3aWxsIGhhdmUgbm8gcmV0dXJuIHZhbHVlXG4gICAgICAgICAgLy8gc2VlIGdoLTc0NlxuICAgICAgICAgIHJhd0FycmF5W2ldID0gc3ViZG9jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWJkb2MgPSBuZXcgQ29uc3RydWN0b3IocmF3QXJyYXlbaV0sIHZhbHVlLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCwgaSk7XG4gICAgICAgICAgICAvLyBpZiBzZXQoKSBpcyBob29rZWQgaXQgd2lsbCBoYXZlIG5vIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgLy8gc2VlIGdoLTc0NlxuICAgICAgICAgICAgcmF3QXJyYXlbaV0gPSBzdWJkb2M7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ2VtYmVkZGVkJywgcmF3QXJyYXlbaV0sXG4gICAgICAgICAgICAgIHZhbHVlW2FycmF5UGF0aFN5bWJvbF0sIGVycm9yLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50QXJyYXlQYXRoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgY29uc3Qgc2NoZW1hdHlwZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucGF0aCwgdGhpcy5zY2hlbWEsIG9wdGlvbnMsIHRoaXMuc2NoZW1hT3B0aW9ucyk7XG4gIHNjaGVtYXR5cGUudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5zbGljZSgpO1xuICBpZiAodGhpcy5yZXF1aXJlZFZhbGlkYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2NoZW1hdHlwZS5yZXF1aXJlZFZhbGlkYXRvciA9IHRoaXMucmVxdWlyZWRWYWxpZGF0b3I7XG4gIH1cbiAgc2NoZW1hdHlwZS5Db25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9ycyA9IE9iamVjdC5hc3NpZ24oe30sXG4gICAgdGhpcy5Db25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9ycyk7XG4gIHJldHVybiBzY2hlbWF0eXBlO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Eb2N1bWVudEFycmF5UGF0aC5wcm90b3R5cGUuYXBwbHlHZXR0ZXJzID0gZnVuY3Rpb24odmFsdWUsIHNjb3BlKSB7XG4gIHJldHVybiBTY2hlbWFUeXBlLnByb3RvdHlwZS5hcHBseUdldHRlcnMuY2FsbCh0aGlzLCB2YWx1ZSwgc2NvcGUpO1xufTtcblxuLyoqXG4gKiBTY29wZXMgcGF0aHMgc2VsZWN0ZWQgaW4gYSBxdWVyeSB0byB0aGlzIGFycmF5LlxuICogTmVjZXNzYXJ5IGZvciBwcm9wZXIgZGVmYXVsdCBhcHBsaWNhdGlvbiBvZiBzdWJkb2N1bWVudCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudEFycmF5UGF0aH0gYXJyYXkgdGhlIGFycmF5IHRvIHNjb3BlIGBmaWVsZHNgIHBhdGhzXG4gKiBAcGFyYW0ge09iamVjdHx1bmRlZmluZWR9IGZpZWxkcyB0aGUgcm9vdCBmaWVsZHMgc2VsZWN0ZWQgaW4gdGhlIHF1ZXJ5XG4gKiBAcGFyYW0ge0Jvb2xlYW58dW5kZWZpbmVkfSBpbml0IGlmIHdlIGFyZSBiZWluZyBjcmVhdGVkIHBhcnQgb2YgYSBxdWVyeSByZXN1bHRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNjb3BlUGF0aHMoYXJyYXksIGZpZWxkcywgaW5pdCkge1xuICBpZiAoIShpbml0ICYmIGZpZWxkcykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgcGF0aCA9IGFycmF5LnBhdGggKyAnLic7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmaWVsZHMpO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICBjb25zdCBzZWxlY3RlZCA9IHt9O1xuICBsZXQgaGFzS2V5cztcbiAgbGV0IGtleTtcbiAgbGV0IHN1YjtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgocGF0aCkpIHtcbiAgICAgIHN1YiA9IGtleS5zdWJzdHJpbmcocGF0aC5sZW5ndGgpO1xuICAgICAgaWYgKHN1YiA9PT0gJyQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN1Yi5zdGFydHNXaXRoKCckLicpKSB7XG4gICAgICAgIHN1YiA9IHN1Yi5zdWJzdHJpbmcoMik7XG4gICAgICB9XG4gICAgICBoYXNLZXlzIHx8IChoYXNLZXlzID0gdHJ1ZSk7XG4gICAgICBzZWxlY3RlZFtzdWJdID0gZmllbGRzW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhc0tleXMgJiYgc2VsZWN0ZWQgfHwgdW5kZWZpbmVkO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50QXJyYXlQYXRoLmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgRG9jdW1lbnRBcnJheSBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBudW1iZXJzIGhhdmUgb3B0aW9uIGBtaW5gIGVxdWFsIHRvIDAuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkRvY3VtZW50QXJyYXkuc2V0KCdfaWQnLCBmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IChlLmcuIHRyaW0sIGxvd2VyY2FzZSwgZXRjLi4uKVxuICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0LlxuICogQHJldHVybiB7dm9pZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnRBcnJheVBhdGguc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cbkRvY3VtZW50QXJyYXlQYXRoLnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIERvY3VtZW50QXJyYXlQYXRoIGluc3RhbmNlc1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnRBcnJheVBhdGguZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBEb2N1bWVudEFycmF5UGF0aDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/documentarray.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/index.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module exports.\n */\n\n\n\nexports.Array = __webpack_require__(/*! ./array */ \"(api)/../server/node_modules/mongoose/lib/schema/array.js\");\nexports.Boolean = __webpack_require__(/*! ./boolean */ \"(api)/../server/node_modules/mongoose/lib/schema/boolean.js\");\nexports.BigInt = __webpack_require__(/*! ./bigint */ \"(api)/../server/node_modules/mongoose/lib/schema/bigint.js\");\nexports.Buffer = __webpack_require__(/*! ./buffer */ \"(api)/../server/node_modules/mongoose/lib/schema/buffer.js\");\nexports.Date = __webpack_require__(/*! ./date */ \"(api)/../server/node_modules/mongoose/lib/schema/date.js\");\nexports.Decimal128 = exports.Decimal = __webpack_require__(/*! ./decimal128 */ \"(api)/../server/node_modules/mongoose/lib/schema/decimal128.js\");\nexports.DocumentArray = __webpack_require__(/*! ./documentarray */ \"(api)/../server/node_modules/mongoose/lib/schema/documentarray.js\");\nexports.Map = __webpack_require__(/*! ./map */ \"(api)/../server/node_modules/mongoose/lib/schema/map.js\");\nexports.Mixed = __webpack_require__(/*! ./mixed */ \"(api)/../server/node_modules/mongoose/lib/schema/mixed.js\");\nexports.Number = __webpack_require__(/*! ./number */ \"(api)/../server/node_modules/mongoose/lib/schema/number.js\");\nexports.ObjectId = __webpack_require__(/*! ./objectid */ \"(api)/../server/node_modules/mongoose/lib/schema/objectid.js\");\nexports.String = __webpack_require__(/*! ./string */ \"(api)/../server/node_modules/mongoose/lib/schema/string.js\");\nexports.Subdocument = __webpack_require__(/*! ./SubdocumentPath */ \"(api)/../server/node_modules/mongoose/lib/schema/SubdocumentPath.js\");\nexports.UUID = __webpack_require__(/*! ./uuid */ \"(api)/../server/node_modules/mongoose/lib/schema/uuid.js\");\n\n// alias\n\nexports.Oid = exports.ObjectId;\nexports.Object = exports.Mixed;\nexports.Bool = exports.Boolean;\nexports.ObjectID = exports.ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsK0dBQWtDO0FBQ2xDLHFIQUFzQztBQUN0QyxrSEFBb0M7QUFDcEMsa0hBQW9DO0FBQ3BDLDRHQUFnQztBQUNoQyxrQkFBa0IsR0FBRywySEFBeUM7QUFDOUQsdUlBQWtEO0FBQ2xELHlHQUE4QjtBQUM5QiwrR0FBa0M7QUFDbEMsa0hBQW9DO0FBQ3BDLHdIQUF3QztBQUN4QyxrSEFBb0M7QUFDcEMseUlBQWtEO0FBQ2xELDRHQUFnQzs7QUFFaEM7O0FBRUEsV0FBVztBQUNYLGNBQWM7QUFDZCxZQUFZO0FBQ1osZ0JBQWdCIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcc2NoZW1hXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkFycmF5ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuZXhwb3J0cy5Cb29sZWFuID0gcmVxdWlyZSgnLi9ib29sZWFuJyk7XG5leHBvcnRzLkJpZ0ludCA9IHJlcXVpcmUoJy4vYmlnaW50Jyk7XG5leHBvcnRzLkJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5leHBvcnRzLkRhdGUgPSByZXF1aXJlKCcuL2RhdGUnKTtcbmV4cG9ydHMuRGVjaW1hbDEyOCA9IGV4cG9ydHMuRGVjaW1hbCA9IHJlcXVpcmUoJy4vZGVjaW1hbDEyOCcpO1xuZXhwb3J0cy5Eb2N1bWVudEFycmF5ID0gcmVxdWlyZSgnLi9kb2N1bWVudGFycmF5Jyk7XG5leHBvcnRzLk1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG5leHBvcnRzLk1peGVkID0gcmVxdWlyZSgnLi9taXhlZCcpO1xuZXhwb3J0cy5OdW1iZXIgPSByZXF1aXJlKCcuL251bWJlcicpO1xuZXhwb3J0cy5PYmplY3RJZCA9IHJlcXVpcmUoJy4vb2JqZWN0aWQnKTtcbmV4cG9ydHMuU3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcnKTtcbmV4cG9ydHMuU3ViZG9jdW1lbnQgPSByZXF1aXJlKCcuL1N1YmRvY3VtZW50UGF0aCcpO1xuZXhwb3J0cy5VVUlEID0gcmVxdWlyZSgnLi91dWlkJyk7XG5cbi8vIGFsaWFzXG5cbmV4cG9ydHMuT2lkID0gZXhwb3J0cy5PYmplY3RJZDtcbmV4cG9ydHMuT2JqZWN0ID0gZXhwb3J0cy5NaXhlZDtcbmV4cG9ydHMuQm9vbCA9IGV4cG9ydHMuQm9vbGVhbjtcbmV4cG9ydHMuT2JqZWN0SUQgPSBleHBvcnRzLk9iamVjdElkO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/index.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/map.js":
/*!*********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/map.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nconst MongooseMap = __webpack_require__(/*! ../types/map */ \"(api)/../server/node_modules/mongoose/lib/types/map.js\");\nconst SchemaMapOptions = __webpack_require__(/*! ../options/SchemaMapOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaMapOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\n/*!\n * ignore\n */\n\nclass Map extends SchemaType {\n  constructor(key, options) {\n    super(key, options, 'Map');\n    this.$isSchemaMap = true;\n  }\n\n  set(option, value) {\n    return SchemaType.set(option, value);\n  }\n\n  cast(val, doc, init) {\n    if (val instanceof MongooseMap) {\n      return val;\n    }\n\n    const path = this.path;\n\n    if (init) {\n      const map = new MongooseMap({}, path, doc, this.$__schemaType);\n\n      if (val instanceof global.Map) {\n        for (const key of val.keys()) {\n          let _val = val.get(key);\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + '.' + key });\n          }\n          map.$init(key, _val);\n        }\n      } else {\n        for (const key of Object.keys(val)) {\n          let _val = val[key];\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + '.' + key });\n          }\n          map.$init(key, _val);\n        }\n      }\n\n      return map;\n    }\n\n    return new MongooseMap(val, path, doc, this.$__schemaType);\n  }\n\n  clone() {\n    const schematype = super.clone();\n\n    if (this.$__schemaType != null) {\n      schematype.$__schemaType = this.$__schemaType.clone();\n    }\n    return schematype;\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nMap.schemaName = 'Map';\n\nMap.prototype.OptionsConstructor = SchemaMapOptions;\n\nMap.defaultOptions = {};\n\nmodule.exports = Map;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL21hcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFPLENBQUMsNEVBQWM7QUFDMUMseUJBQXlCLG1CQUFPLENBQUMsMEdBQTZCO0FBQzlELG1CQUFtQixtQkFBTyxDQUFDLDhFQUFlO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixtRUFBbUUsd0JBQXdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixtRUFBbUUsd0JBQXdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHNjaGVtYVxcbWFwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBNb25nb29zZU1hcCA9IHJlcXVpcmUoJy4uL3R5cGVzL21hcCcpO1xuY29uc3QgU2NoZW1hTWFwT3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvU2NoZW1hTWFwT3B0aW9ucycpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYXR5cGUnKTtcbi8qIVxuICogaWdub3JlXG4gKi9cblxuY2xhc3MgTWFwIGV4dGVuZHMgU2NoZW1hVHlwZSB7XG4gIGNvbnN0cnVjdG9yKGtleSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGtleSwgb3B0aW9ucywgJ01hcCcpO1xuICAgIHRoaXMuJGlzU2NoZW1hTWFwID0gdHJ1ZTtcbiAgfVxuXG4gIHNldChvcHRpb24sIHZhbHVlKSB7XG4gICAgcmV0dXJuIFNjaGVtYVR5cGUuc2V0KG9wdGlvbiwgdmFsdWUpO1xuICB9XG5cbiAgY2FzdCh2YWwsIGRvYywgaW5pdCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBNb25nb29zZU1hcCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoO1xuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBNb25nb29zZU1hcCh7fSwgcGF0aCwgZG9jLCB0aGlzLiRfX3NjaGVtYVR5cGUpO1xuXG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgZ2xvYmFsLk1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB2YWwua2V5cygpKSB7XG4gICAgICAgICAgbGV0IF92YWwgPSB2YWwuZ2V0KGtleSk7XG4gICAgICAgICAgaWYgKF92YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgX3ZhbCA9IG1hcC4kX19zY2hlbWFUeXBlLl9jYXN0TnVsbGlzaChfdmFsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3ZhbCA9IG1hcC4kX19zY2hlbWFUeXBlLmNhc3QoX3ZhbCwgZG9jLCB0cnVlLCBudWxsLCB7IHBhdGg6IHBhdGggKyAnLicgKyBrZXkgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcC4kaW5pdChrZXksIF92YWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWwpKSB7XG4gICAgICAgICAgbGV0IF92YWwgPSB2YWxba2V5XTtcbiAgICAgICAgICBpZiAoX3ZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBfdmFsID0gbWFwLiRfX3NjaGVtYVR5cGUuX2Nhc3ROdWxsaXNoKF92YWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdmFsID0gbWFwLiRfX3NjaGVtYVR5cGUuY2FzdChfdmFsLCBkb2MsIHRydWUsIG51bGwsIHsgcGF0aDogcGF0aCArICcuJyArIGtleSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwLiRpbml0KGtleSwgX3ZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1vbmdvb3NlTWFwKHZhbCwgcGF0aCwgZG9jLCB0aGlzLiRfX3NjaGVtYVR5cGUpO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc2NoZW1hdHlwZSA9IHN1cGVyLmNsb25lKCk7XG5cbiAgICBpZiAodGhpcy4kX19zY2hlbWFUeXBlICE9IG51bGwpIHtcbiAgICAgIHNjaGVtYXR5cGUuJF9fc2NoZW1hVHlwZSA9IHRoaXMuJF9fc2NoZW1hVHlwZS5jbG9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hdHlwZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1hcC5zY2hlbWFOYW1lID0gJ01hcCc7XG5cbk1hcC5wcm90b3R5cGUuT3B0aW9uc0NvbnN0cnVjdG9yID0gU2NoZW1hTWFwT3B0aW9ucztcblxuTWFwLmRlZmF1bHRPcHRpb25zID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/map.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/mixed.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/mixed.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst symbols = __webpack_require__(/*! ./symbols */ \"(api)/../server/node_modules/mongoose/lib/schema/symbols.js\");\nconst isObject = __webpack_require__(/*! ../helpers/isObject */ \"(api)/../server/node_modules/mongoose/lib/helpers/isObject.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\n/**\n * Mixed SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction Mixed(path, options) {\n  if (options && options.default) {\n    const def = options.default;\n    if (Array.isArray(def) && def.length === 0) {\n      // make sure empty array defaults are handled\n      options.default = Array;\n    } else if (!options.shared && isObject(def) && Object.keys(def).length === 0) {\n      // prevent odd \"shared\" objects between documents\n      options.default = function() {\n        return {};\n      };\n    }\n  }\n\n  SchemaType.call(this, path, options, 'Mixed');\n\n  this[symbols.schemaMixedSymbol] = true;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nMixed.schemaName = 'Mixed';\n\nMixed.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nMixed.prototype = Object.create(SchemaType.prototype);\nMixed.prototype.constructor = Mixed;\n\n/**\n * Attaches a getter for all Mixed paths.\n *\n * #### Example:\n *\n *     // Hide the 'hidden' path\n *     mongoose.Schema.Mixed.get(v => Object.assign({}, v, { hidden: null }));\n *\n *     const Model = mongoose.model('Test', new Schema({ test: {} }));\n *     new Model({ test: { hidden: 'Secret!' } }).test.hidden; // null\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nMixed.get = SchemaType.get;\n\n/**\n * Sets a default option for all Mixed instances.\n *\n * #### Example:\n *\n *     // Make all mixed instances have `required` of true by default.\n *     mongoose.Schema.Mixed.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.Mixed }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nMixed.set = SchemaType.set;\n\nMixed.setters = [];\n\n/**\n * Casts `val` for Mixed.\n *\n * _this is a no-op_\n *\n * @param {Object} value to cast\n * @api private\n */\n\nMixed.prototype.cast = function(val) {\n  if (val instanceof Error) {\n    return utils.errorToPOJO(val);\n  }\n  return val;\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $cond\n * @param {any} [val]\n * @api private\n */\n\nMixed.prototype.castForQuery = function($cond, val) {\n  return val;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Mixed;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL21peGVkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBZTtBQUMxQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBVztBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQywwRkFBcUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLG9FQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTyxjQUFjO0FBQzNFO0FBQ0EseURBQXlELFVBQVU7QUFDbkUsbUJBQW1CLFFBQVEscUJBQXFCLGVBQWU7QUFDL0Q7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsc0JBQXNCO0FBQzlFLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcc2NoZW1hXFxtaXhlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hdHlwZScpO1xuY29uc3Qgc3ltYm9scyA9IHJlcXVpcmUoJy4vc3ltYm9scycpO1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzT2JqZWN0Jyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogTWl4ZWQgU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1peGVkKHBhdGgsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWZhdWx0KSB7XG4gICAgY29uc3QgZGVmID0gb3B0aW9ucy5kZWZhdWx0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZikgJiYgZGVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gbWFrZSBzdXJlIGVtcHR5IGFycmF5IGRlZmF1bHRzIGFyZSBoYW5kbGVkXG4gICAgICBvcHRpb25zLmRlZmF1bHQgPSBBcnJheTtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLnNoYXJlZCAmJiBpc09iamVjdChkZWYpICYmIE9iamVjdC5rZXlzKGRlZikubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBwcmV2ZW50IG9kZCBcInNoYXJlZFwiIG9iamVjdHMgYmV0d2VlbiBkb2N1bWVudHNcbiAgICAgIG9wdGlvbnMuZGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBwYXRoLCBvcHRpb25zLCAnTWl4ZWQnKTtcblxuICB0aGlzW3N5bWJvbHMuc2NoZW1hTWl4ZWRTeW1ib2xdID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5NaXhlZC5zY2hlbWFOYW1lID0gJ01peGVkJztcblxuTWl4ZWQuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cbk1peGVkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hVHlwZS5wcm90b3R5cGUpO1xuTWl4ZWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWl4ZWQ7XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBNaXhlZCBwYXRocy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEhpZGUgdGhlICdoaWRkZW4nIHBhdGhcbiAqICAgICBtb25nb29zZS5TY2hlbWEuTWl4ZWQuZ2V0KHYgPT4gT2JqZWN0LmFzc2lnbih7fSwgdiwgeyBoaWRkZW46IG51bGwgfSkpO1xuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IHRlc3Q6IHt9IH0pKTtcbiAqICAgICBuZXcgTW9kZWwoeyB0ZXN0OiB7IGhpZGRlbjogJ1NlY3JldCEnIH0gfSkudGVzdC5oaWRkZW47IC8vIG51bGxcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1peGVkLmdldCA9IFNjaGVtYVR5cGUuZ2V0O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIE1peGVkIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIG1peGVkIGluc3RhbmNlcyBoYXZlIGByZXF1aXJlZGAgb2YgdHJ1ZSBieSBkZWZhdWx0LlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5NaXhlZC5zZXQoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gKlxuICogICAgIGNvbnN0IFVzZXIgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIG5ldyBTY2hlbWEoeyB0ZXN0OiBtb25nb29zZS5NaXhlZCB9KSk7XG4gKiAgICAgbmV3IFVzZXIoeyB9KS52YWxpZGF0ZVN5bmMoKS5lcnJvcnMudGVzdC5tZXNzYWdlOyAvLyBQYXRoIGB0ZXN0YCBpcyByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWl4ZWQuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cbk1peGVkLnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsYCBmb3IgTWl4ZWQuXG4gKlxuICogX3RoaXMgaXMgYSBuby1vcF9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdG8gY2FzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWl4ZWQucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVycm9yVG9QT0pPKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kXG4gKiBAcGFyYW0ge2FueX0gW3ZhbF1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1peGVkLnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZCwgdmFsKSB7XG4gIHJldHVybiB2YWw7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWl4ZWQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/mixed.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/number.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/number.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module requirements.\n */\n\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nconst SchemaNumberOptions = __webpack_require__(/*! ../options/SchemaNumberOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaNumberOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst castNumber = __webpack_require__(/*! ../cast/number */ \"(api)/../server/node_modules/mongoose/lib/cast/number.js\");\nconst handleBitwiseOperator = __webpack_require__(/*! ./operators/bitwise */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/bitwise.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Number SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaNumber(key, options) {\n  SchemaType.call(this, key, options, 'Number');\n}\n\n/**\n * Attaches a getter for all Number instances.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Number.get(function(v) { return Math.floor(v); });\n *\n *     const Model = mongoose.model('Test', new Schema({ test: Number }));\n *     new Model({ test: 3.14 }).test; // 3\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaNumber.get = SchemaType.get;\n\n/**\n * Sets a default option for all Number instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Number.set('min', 0);\n *\n *     const Order = mongoose.model('Order', new Schema({ amount: Number }));\n *     new Order({ amount: -10 }).validateSync().errors.amount.message; // Path `amount` must be larger than 0.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaNumber.set = SchemaType.set;\n\nSchemaNumber.setters = [];\n\n/*!\n * ignore\n */\n\nSchemaNumber._cast = castNumber;\n\n/**\n * Get/set the function used to cast arbitrary values to numbers.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty strings '' to 0 for paths declared as numbers\n *     const original = mongoose.Number.cast();\n *     mongoose.Number.cast(v => {\n *       if (v === '') { return 0; }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Number.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaNumber.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaNumber._defaultCaster = v => {\n  if (typeof v !== 'number') {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaNumber.schemaName = 'Number';\n\nSchemaNumber.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaNumber.prototype = Object.create(SchemaType.prototype);\nSchemaNumber.prototype.constructor = SchemaNumber;\nSchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;\n\n/*!\n * ignore\n */\n\nSchemaNumber._checkRequired = v => typeof v === 'number' || v instanceof Number;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaNumber.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaNumber.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum number validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, min: 10 })\n *     const M = db.model('M', s)\n *     const m = new M({ n: 9 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     const min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     const schema = new Schema({ n: { type: Number, min: min })\n *     const M = mongoose.model('Measurement', schema);\n *     const s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n *     })\n *\n * @param {Number} value minimum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.Number.min;\n    msg = msg.replace(/{MIN}/, value);\n    this.validators.push({\n      validator: this.minValidator = function(v) {\n        return v == null || v >= value;\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum number validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, max: 10 })\n *     const M = db.model('M', s)\n *     const m = new M({ n: 11 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     const max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     const schema = new Schema({ n: { type: Number, max: max })\n *     const M = mongoose.model('Measurement', schema);\n *     const s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n *     })\n *\n * @param {Number} maximum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.Number.max;\n    msg = msg.replace(/{MAX}/, value);\n    this.validators.push({\n      validator: this.maxValidator = function(v) {\n        return v == null || v <= value;\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a enum validator\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, enum: [1, 2, 3] });\n *     const M = db.model('M', s);\n *\n *     const m = new M({ n: 4 });\n *     await m.save(); // throws validation error\n *\n *     m.n = 3;\n *     await m.save(); // succeeds\n *\n * @param {Array} values allowed values\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.enum = function(values, message) {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.enumValidator;\n    }, this);\n  }\n\n\n  if (!Array.isArray(values)) {\n    const isObjectSyntax = utils.isPOJO(values) && values.values != null;\n    if (isObjectSyntax) {\n      message = values.message;\n      values = values.values;\n    } else if (typeof values === 'number') {\n      values = Array.prototype.slice.call(arguments);\n      message = null;\n    }\n\n    if (utils.isPOJO(values)) {\n      values = Object.values(values);\n    }\n    message = message || MongooseError.messages.Number.enum;\n  }\n\n  message = message == null ? MongooseError.messages.Number.enum : message;\n\n  this.enumValidator = v => v == null || values.indexOf(v) !== -1;\n  this.validators.push({\n    validator: this.enumValidator,\n    message: message,\n    type: 'enum',\n    enumValues: values\n  });\n\n  return this;\n};\n\n/**\n * Casts to number\n *\n * @param {Object} value value to cast\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaNumber.prototype.cast = function(value, doc, init) {\n  if (typeof value !== 'number' && SchemaType._isRef(this, value, doc, init)) {\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init);\n    }\n  }\n\n  const val = value && typeof value._id !== 'undefined' ?\n    value._id : // documents\n    value;\n\n  let castNumber;\n  if (typeof this._castFunction === 'function') {\n    castNumber = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castNumber = this.constructor.cast();\n  } else {\n    castNumber = SchemaNumber.cast();\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val, this.path, err, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nfunction handleArray(val) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.cast(val)];\n  }\n  return val.map(function(m) {\n    return _this.cast(m);\n  });\n}\n\nSchemaNumber.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $mod: handleArray\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaNumber.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new CastError('number', val, this.path, null, this);\n    }\n    return handler.call(this, val, context);\n  }\n  val = this.applySetters(val, context);\n  return val;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL251bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQzlDLDRCQUE0QixtQkFBTyxDQUFDLGdIQUFnQztBQUNwRSxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBZTtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDM0MsOEJBQThCLG1CQUFPLENBQUMsa0dBQXFCO0FBQzNELGNBQWMsbUJBQU8sQ0FBQyxvRUFBVTs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1QkFBdUI7QUFDaEU7QUFDQSx5REFBeUQsY0FBYztBQUN2RSxtQkFBbUIsWUFBWSxRQUFRO0FBQ3ZDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRSxtQkFBbUIsYUFBYSx3Q0FBd0M7QUFDeEU7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcc2NoZW1hXFxudW1iZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2luZGV4Jyk7XG5jb25zdCBTY2hlbWFOdW1iZXJPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucy9TY2hlbWFOdW1iZXJPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hdHlwZScpO1xuY29uc3QgY2FzdE51bWJlciA9IHJlcXVpcmUoJy4uL2Nhc3QvbnVtYmVyJyk7XG5jb25zdCBoYW5kbGVCaXR3aXNlT3BlcmF0b3IgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9iaXR3aXNlJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmNvbnN0IENhc3RFcnJvciA9IFNjaGVtYVR5cGUuQ2FzdEVycm9yO1xuXG4vKipcbiAqIE51bWJlciBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFOdW1iZXIoa2V5LCBvcHRpb25zKSB7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdOdW1iZXInKTtcbn1cblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIE51bWJlciBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBudW1iZXJzIHJvdW5kIGRvd25cbiAqICAgICBtb25nb29zZS5OdW1iZXIuZ2V0KGZ1bmN0aW9uKHYpIHsgcmV0dXJuIE1hdGguZmxvb3Iodik7IH0pO1xuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IHRlc3Q6IE51bWJlciB9KSk7XG4gKiAgICAgbmV3IE1vZGVsKHsgdGVzdDogMy4xNCB9KS50ZXN0OyAvLyAzXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgTnVtYmVyIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIG51bWJlcnMgaGF2ZSBvcHRpb24gYG1pbmAgZXF1YWwgdG8gMC5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuTnVtYmVyLnNldCgnbWluJywgMCk7XG4gKlxuICogICAgIGNvbnN0IE9yZGVyID0gbW9uZ29vc2UubW9kZWwoJ09yZGVyJywgbmV3IFNjaGVtYSh7IGFtb3VudDogTnVtYmVyIH0pKTtcbiAqICAgICBuZXcgT3JkZXIoeyBhbW91bnQ6IC0xMCB9KS52YWxpZGF0ZVN5bmMoKS5lcnJvcnMuYW1vdW50Lm1lc3NhZ2U7IC8vIFBhdGggYGFtb3VudGAgbXVzdCBiZSBsYXJnZXIgdGhhbiAwLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYU51bWJlci5zZXR0ZXJzID0gW107XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hTnVtYmVyLl9jYXN0ID0gY2FzdE51bWJlcjtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBudW1iZXJzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBNb25nb29zZSBjYXN0IGVtcHR5IHN0cmluZ3MgJycgdG8gMCBmb3IgcGF0aHMgZGVjbGFyZWQgYXMgbnVtYmVyc1xuICogICAgIGNvbnN0IG9yaWdpbmFsID0gbW9uZ29vc2UuTnVtYmVyLmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5OdW1iZXIuY2FzdCh2ID0+IHtcbiAqICAgICAgIGlmICh2ID09PSAnJykgeyByZXR1cm4gMDsgfVxuICogICAgICAgcmV0dXJuIG9yaWdpbmFsKHYpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBPciBkaXNhYmxlIGNhc3RpbmcgZW50aXJlbHlcbiAqICAgICBtb25nb29zZS5OdW1iZXIuY2FzdChmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FzdGVyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTnVtYmVyLmNhc3QgPSBmdW5jdGlvbiBjYXN0KGNhc3Rlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0O1xuICB9XG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdGhpcy5fZGVmYXVsdENhc3RlcjtcbiAgfVxuICB0aGlzLl9jYXN0ID0gY2FzdGVyO1xuXG4gIHJldHVybiB0aGlzLl9jYXN0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFOdW1iZXIuX2RlZmF1bHRDYXN0ZXIgPSB2ID0+IHtcbiAgaWYgKHR5cGVvZiB2ICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFOdW1iZXIuc2NoZW1hTmFtZSA9ICdOdW1iZXInO1xuXG5TY2hlbWFOdW1iZXIuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYU51bWJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYU51bWJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFOdW1iZXI7XG5TY2hlbWFOdW1iZXIucHJvdG90eXBlLk9wdGlvbnNDb25zdHJ1Y3RvciA9IFNjaGVtYU51bWJlck9wdGlvbnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hTnVtYmVyLl9jaGVja1JlcXVpcmVkID0gdiA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicgfHwgdiBpbnN0YW5jZW9mIE51bWJlcjtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmdcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIuY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIGEgcmVxdWlyZWQgdmFsaWRhdG9yLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbiBjaGVja1JlcXVpcmVkKHZhbHVlLCBkb2MpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgdHJ1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbDtcbiAgfVxuXG4gIC8vIGByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoKWAgZG9lcyAqKm5vdCoqIGNvcHkgc3RhdGljIHByb3BlcnRpZXMsIGFuZFxuICAvLyBwbHVnaW5zIGxpa2UgbW9uZ29vc2UtZmxvYXQgdXNlIGBpbmhlcml0cygpYCBmb3IgcHJlLUVTNi5cbiAgY29uc3QgX2NoZWNrUmVxdWlyZWQgPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQoKSA6XG4gICAgU2NoZW1hTnVtYmVyLmNoZWNrUmVxdWlyZWQoKTtcblxuICByZXR1cm4gX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgbWluaW11bSBudW1iZXIgdmFsaWRhdG9yLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuOiB7IHR5cGU6IE51bWJlciwgbWluOiAxMCB9KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgbjogOSB9KVxuICogICAgIG0uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKGVycikgLy8gdmFsaWRhdG9yIGVycm9yXG4gKiAgICAgICBtLm4gPSAxMDtcbiAqICAgICAgIG0uc2F2ZSgpIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBjdXN0b20gZXJyb3IgbWVzc2FnZXNcbiAqICAgICAvLyBXZSBjYW4gYWxzbyB1c2UgdGhlIHNwZWNpYWwge01JTn0gdG9rZW4gd2hpY2ggd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBpbnZhbGlkIHZhbHVlXG4gKiAgICAgY29uc3QgbWluID0gWzEwLCAnVGhlIHZhbHVlIG9mIHBhdGggYHtQQVRIfWAgKHtWQUxVRX0pIGlzIGJlbmVhdGggdGhlIGxpbWl0ICh7TUlOfSkuJ107XG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG46IHsgdHlwZTogTnVtYmVyLCBtaW46IG1pbiB9KVxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCgnTWVhc3VyZW1lbnQnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IHM9IG5ldyBNKHsgbjogNCB9KTtcbiAqICAgICBzLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IFRoZSB2YWx1ZSBvZiBwYXRoIGBuYCAoNCkgaXMgYmVuZWF0aCB0aGUgbGltaXQgKDEwKS5cbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBtaW5pbXVtIG51bWJlclxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBDdXN0b21pemVkIEVycm9yIE1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLm1pblZhbGlkYXRvcikge1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5maWx0ZXIoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9yICE9PSB0aGlzLm1pblZhbGlkYXRvcjtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IG1zZyA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5OdW1iZXIubWluO1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKC97TUlOfS8sIHZhbHVlKTtcbiAgICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgICB2YWxpZGF0b3I6IHRoaXMubWluVmFsaWRhdG9yID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdiA9PSBudWxsIHx8IHYgPj0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgdHlwZTogJ21pbicsXG4gICAgICBtaW46IHZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhIG1heGltdW0gbnVtYmVyIHZhbGlkYXRvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbjogeyB0eXBlOiBOdW1iZXIsIG1heDogMTAgfSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IG46IDExIH0pXG4gKiAgICAgbS5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKSAvLyB2YWxpZGF0b3IgZXJyb3JcbiAqICAgICAgIG0ubiA9IDEwO1xuICogICAgICAgbS5zYXZlKCkgLy8gc3VjY2Vzc1xuICogICAgIH0pXG4gKlxuICogICAgIC8vIGN1c3RvbSBlcnJvciBtZXNzYWdlc1xuICogICAgIC8vIFdlIGNhbiBhbHNvIHVzZSB0aGUgc3BlY2lhbCB7TUFYfSB0b2tlbiB3aGljaCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGludmFsaWQgdmFsdWVcbiAqICAgICBjb25zdCBtYXggPSBbMTAsICdUaGUgdmFsdWUgb2YgcGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgZXhjZWVkcyB0aGUgbGltaXQgKHtNQVh9KS4nXTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbjogeyB0eXBlOiBOdW1iZXIsIG1heDogbWF4IH0pXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKCdNZWFzdXJlbWVudCcsIHNjaGVtYSk7XG4gKiAgICAgY29uc3Qgcz0gbmV3IE0oeyBuOiA0IH0pO1xuICogICAgIHMudmFsaWRhdGUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5sb2coU3RyaW5nKGVycikpIC8vIFZhbGlkYXRpb25FcnJvcjogVGhlIHZhbHVlIG9mIHBhdGggYG5gICg0KSBleGNlZWRzIHRoZSBsaW1pdCAoMTApLlxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heGltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIEN1c3RvbWl6ZWQgRXJyb3IgTWVzc2FnZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU51bWJlci5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMubWF4VmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMubWF4VmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgbXNnID0gbWVzc2FnZSB8fCBNb25nb29zZUVycm9yLm1lc3NhZ2VzLk51bWJlci5tYXg7XG4gICAgbXNnID0gbXNnLnJlcGxhY2UoL3tNQVh9LywgdmFsdWUpO1xuICAgIHRoaXMudmFsaWRhdG9ycy5wdXNoKHtcbiAgICAgIHZhbGlkYXRvcjogdGhpcy5tYXhWYWxpZGF0b3IgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2ID09IG51bGwgfHwgdiA8PSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiBtc2csXG4gICAgICB0eXBlOiAnbWF4JyxcbiAgICAgIG1heDogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgZW51bSB2YWxpZGF0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbjogeyB0eXBlOiBOdW1iZXIsIGVudW06IFsxLCAyLCAzXSB9KTtcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKTtcbiAqXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgbjogNCB9KTtcbiAqICAgICBhd2FpdCBtLnNhdmUoKTsgLy8gdGhyb3dzIHZhbGlkYXRpb24gZXJyb3JcbiAqXG4gKiAgICAgbS5uID0gMztcbiAqICAgICBhd2FpdCBtLnNhdmUoKTsgLy8gc3VjY2VlZHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgYWxsb3dlZCB2YWx1ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5lbnVtID0gZnVuY3Rpb24odmFsdWVzLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLmVudW1WYWxpZGF0b3IpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvciAhPT0gdGhpcy5lbnVtVmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cblxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIGNvbnN0IGlzT2JqZWN0U3ludGF4ID0gdXRpbHMuaXNQT0pPKHZhbHVlcykgJiYgdmFsdWVzLnZhbHVlcyAhPSBudWxsO1xuICAgIGlmIChpc09iamVjdFN5bnRheCkge1xuICAgICAgbWVzc2FnZSA9IHZhbHVlcy5tZXNzYWdlO1xuICAgICAgdmFsdWVzID0gdmFsdWVzLnZhbHVlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgbWVzc2FnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzUE9KTyh2YWx1ZXMpKSB7XG4gICAgICB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKHZhbHVlcyk7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuTnVtYmVyLmVudW07XG4gIH1cblxuICBtZXNzYWdlID0gbWVzc2FnZSA9PSBudWxsID8gTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5OdW1iZXIuZW51bSA6IG1lc3NhZ2U7XG5cbiAgdGhpcy5lbnVtVmFsaWRhdG9yID0gdiA9PiB2ID09IG51bGwgfHwgdmFsdWVzLmluZGV4T2YodikgIT09IC0xO1xuICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgdmFsaWRhdG9yOiB0aGlzLmVudW1WYWxpZGF0b3IsXG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICB0eXBlOiAnZW51bScsXG4gICAgZW51bVZhbHVlczogdmFsdWVzXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYXN0cyB0byBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdmFsdWUgdG8gY2FzdFxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIGRvY3VtZW50IHRoYXQgdHJpZ2dlcnMgdGhlIGNhc3RpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUsIGRvYywgaW5pdCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiBTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCBpbml0KSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHV0aWxzLmlzTm9uQnVpbHRpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYXN0UmVmKHZhbHVlLCBkb2MsIGluaXQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5faWQgIT09ICd1bmRlZmluZWQnID9cbiAgICB2YWx1ZS5faWQgOiAvLyBkb2N1bWVudHNcbiAgICB2YWx1ZTtcblxuICBsZXQgY2FzdE51bWJlcjtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0TnVtYmVyID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0TnVtYmVyID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdE51bWJlciA9IFNjaGVtYU51bWJlci5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0TnVtYmVyKHZhbCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ051bWJlcicsIHZhbCwgdGhpcy5wYXRoLCBlcnIsIHRoaXMpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZSh2YWwpIHtcbiAgcmV0dXJuIHRoaXMuY2FzdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVBcnJheSh2YWwpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBbdGhpcy5jYXN0KHZhbCldO1xuICB9XG4gIHJldHVybiB2YWwubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gX3RoaXMuY2FzdChtKTtcbiAgfSk7XG59XG5cblNjaGVtYU51bWJlci5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7XG4gIC4uLlNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLFxuICAkYml0c0FsbENsZWFyOiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRiaXRzQW55Q2xlYXI6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGJpdHNBbGxTZXQ6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGJpdHNBbnlTZXQ6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZSxcbiAgJG1vZDogaGFuZGxlQXJyYXlcbn07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kaXRpb25hbFxuICogQHBhcmFtIHthbnl9IFt2YWx1ZV1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYU51bWJlci5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdudW1iZXInLCB2YWwsIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsLCBjb250ZXh0KTtcbiAgfVxuICB2YWwgPSB0aGlzLmFwcGx5U2V0dGVycyh2YWwsIGNvbnRleHQpO1xuICByZXR1cm4gdmFsO1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYU51bWJlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/number.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/objectid.js":
/*!**************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/objectid.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst SchemaObjectIdOptions = __webpack_require__(/*! ../options/SchemaObjectIdOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaObjectIdOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst castObjectId = __webpack_require__(/*! ../cast/objectid */ \"(api)/../server/node_modules/mongoose/lib/cast/objectid.js\");\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst oid = __webpack_require__(/*! ../types/objectid */ \"(api)/../server/node_modules/mongoose/lib/types/objectid.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nconst CastError = SchemaType.CastError;\nlet Document;\n\n/**\n * ObjectId SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction ObjectId(key, options) {\n  const isKeyHexStr = typeof key === 'string' && key.length === 24 && /^[a-f0-9]+$/i.test(key);\n  const suppressWarning = options && options.suppressWarning;\n  if ((isKeyHexStr || typeof key === 'undefined') && !suppressWarning) {\n    utils.warn('mongoose: To create a new ObjectId please try ' +\n      '`Mongoose.Types.ObjectId` instead of using ' +\n      '`Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if ' +\n      'you\\'re trying to create a hex char path in your schema.');\n  }\n  SchemaType.call(this, key, options, 'ObjectId');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nObjectId.schemaName = 'ObjectId';\n\nObjectId.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nObjectId.prototype = Object.create(SchemaType.prototype);\nObjectId.prototype.constructor = ObjectId;\nObjectId.prototype.OptionsConstructor = SchemaObjectIdOptions;\n\n/**\n * Attaches a getter for all ObjectId instances\n *\n * #### Example:\n *\n *     // Always convert to string when getting an ObjectId\n *     mongoose.ObjectId.get(v => v.toString());\n *\n *     const Model = mongoose.model('Test', new Schema({}));\n *     typeof (new Model({})._id); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nObjectId.get = SchemaType.get;\n\n/**\n * Sets a default option for all ObjectId instances.\n *\n * #### Example:\n *\n *     // Make all object ids have option `required` equal to true.\n *     mongoose.Schema.ObjectId.set('required', true);\n *\n *     const Order = mongoose.model('Order', new Schema({ userId: ObjectId }));\n *     new Order({ }).validateSync().errors.userId.message; // Path `userId` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nObjectId.set = SchemaType.set;\n\nObjectId.setters = [];\n\n/**\n * Adds an auto-generated ObjectId default if turnOn is true.\n * @param {Boolean} turnOn auto generated ObjectId defaults\n * @api public\n * @return {SchemaType} this\n */\n\nObjectId.prototype.auto = function(turnOn) {\n  if (turnOn) {\n    this.default(defaultId);\n    this.set(resetId);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nObjectId._checkRequired = v => isBsonType(v, 'ObjectId');\n\n/*!\n * ignore\n */\n\nObjectId._cast = castObjectId;\n\n/**\n * Get/set the function used to cast arbitrary values to objectids.\n *\n * #### Example:\n *\n *     // Make Mongoose only try to cast length 24 strings. By default, any 12\n *     // char string is a valid ObjectId.\n *     const original = mongoose.ObjectId.cast();\n *     mongoose.ObjectId.cast(v => {\n *       assert.ok(typeof v !== 'string' || v.length === 24);\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.ObjectId.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nObjectId.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nObjectId._defaultCaster = v => {\n  if (!(isBsonType(v, 'ObjectId'))) {\n    throw new Error(v + ' is not an instance of ObjectId');\n  }\n  return v;\n};\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nObjectId.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nObjectId.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    ObjectId.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to ObjectId\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nObjectId.prototype.cast = function(value, doc, init) {\n  if (!(isBsonType(value, 'ObjectId')) && SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n    if ((getConstructorName(value) || '').toLowerCase() === 'objectid') {\n      return new oid(value.toHexString());\n    }\n\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init);\n    }\n  }\n\n  let castObjectId;\n  if (typeof this._castFunction === 'function') {\n    castObjectId = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castObjectId = this.constructor.cast();\n  } else {\n    castObjectId = ObjectId.cast();\n  }\n\n  try {\n    return castObjectId(value);\n  } catch (error) {\n    throw new CastError('ObjectId', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nObjectId.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/*!\n * ignore\n */\n\nfunction defaultId() {\n  return new oid();\n}\n\ndefaultId.$runBeforeSetters = true;\n\nfunction resetId(v) {\n  Document || (Document = __webpack_require__(/*! ./../document */ \"(api)/../server/node_modules/mongoose/lib/document.js\"));\n\n  if (this instanceof Document) {\n    if (v === void 0) {\n      const _v = new oid();\n      return _v;\n    }\n  }\n\n  return v;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29iamVjdGlkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiw4QkFBOEIsbUJBQU8sQ0FBQyxvSEFBa0M7QUFDeEUsbUJBQW1CLG1CQUFPLENBQUMsOEVBQWU7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWtCO0FBQy9DLDJCQUEyQixtQkFBTyxDQUFDLDhHQUErQjtBQUNsRSxZQUFZLG1CQUFPLENBQUMsc0ZBQW1CO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLDhGQUF1QjtBQUNsRCxjQUFjLG1CQUFPLENBQUMsb0VBQVU7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCwyQkFBMkIsUUFBUTtBQUNuQztBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrQkFBa0I7QUFDNUUsb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFZLFlBQVk7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU8sZ0NBQWdDO0FBQ3pFLGVBQWUsU0FBUyxrQkFBa0I7QUFDMUM7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLDRFQUFlOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxzY2hlbWFcXG9iamVjdGlkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYU9iamVjdElkT3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvU2NoZW1hT2JqZWN0SWRPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hdHlwZScpO1xuY29uc3QgY2FzdE9iamVjdElkID0gcmVxdWlyZSgnLi4vY2FzdC9vYmplY3RpZCcpO1xuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi4vaGVscGVycy9nZXRDb25zdHJ1Y3Rvck5hbWUnKTtcbmNvbnN0IG9pZCA9IHJlcXVpcmUoJy4uL3R5cGVzL29iamVjdGlkJyk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmNvbnN0IENhc3RFcnJvciA9IFNjaGVtYVR5cGUuQ2FzdEVycm9yO1xubGV0IERvY3VtZW50O1xuXG4vKipcbiAqIE9iamVjdElkIFNjaGVtYVR5cGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE9iamVjdElkKGtleSwgb3B0aW9ucykge1xuICBjb25zdCBpc0tleUhleFN0ciA9IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5sZW5ndGggPT09IDI0ICYmIC9eW2EtZjAtOV0rJC9pLnRlc3Qoa2V5KTtcbiAgY29uc3Qgc3VwcHJlc3NXYXJuaW5nID0gb3B0aW9ucyAmJiBvcHRpb25zLnN1cHByZXNzV2FybmluZztcbiAgaWYgKChpc0tleUhleFN0ciB8fCB0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykgJiYgIXN1cHByZXNzV2FybmluZykge1xuICAgIHV0aWxzLndhcm4oJ21vbmdvb3NlOiBUbyBjcmVhdGUgYSBuZXcgT2JqZWN0SWQgcGxlYXNlIHRyeSAnICtcbiAgICAgICdgTW9uZ29vc2UuVHlwZXMuT2JqZWN0SWRgIGluc3RlYWQgb2YgdXNpbmcgJyArXG4gICAgICAnYE1vbmdvb3NlLlNjaGVtYS5PYmplY3RJZGAuIFNldCB0aGUgYHN1cHByZXNzV2FybmluZ2Agb3B0aW9uIGlmICcgK1xuICAgICAgJ3lvdVxcJ3JlIHRyeWluZyB0byBjcmVhdGUgYSBoZXggY2hhciBwYXRoIGluIHlvdXIgc2NoZW1hLicpO1xuICB9XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdPYmplY3RJZCcpO1xufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbk9iamVjdElkLnNjaGVtYU5hbWUgPSAnT2JqZWN0SWQnO1xuXG5PYmplY3RJZC5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuT2JqZWN0SWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5PYmplY3RJZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPYmplY3RJZDtcbk9iamVjdElkLnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFPYmplY3RJZE9wdGlvbnM7XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBPYmplY3RJZCBpbnN0YW5jZXNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEFsd2F5cyBjb252ZXJ0IHRvIHN0cmluZyB3aGVuIGdldHRpbmcgYW4gT2JqZWN0SWRcbiAqICAgICBtb25nb29zZS5PYmplY3RJZC5nZXQodiA9PiB2LnRvU3RyaW5nKCkpO1xuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7fSkpO1xuICogICAgIHR5cGVvZiAobmV3IE1vZGVsKHt9KS5faWQpOyAvLyAnc3RyaW5nJ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0SWQuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgT2JqZWN0SWQgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgb2JqZWN0IGlkcyBoYXZlIG9wdGlvbiBgcmVxdWlyZWRgIGVxdWFsIHRvIHRydWUuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLk9iamVjdElkLnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgT3JkZXIgPSBtb25nb29zZS5tb2RlbCgnT3JkZXInLCBuZXcgU2NoZW1hKHsgdXNlcklkOiBPYmplY3RJZCB9KSk7XG4gKiAgICAgbmV3IE9yZGVyKHsgfSkudmFsaWRhdGVTeW5jKCkuZXJyb3JzLnVzZXJJZC5tZXNzYWdlOyAvLyBQYXRoIGB1c2VySWRgIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3RJZC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuT2JqZWN0SWQuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEFkZHMgYW4gYXV0by1nZW5lcmF0ZWQgT2JqZWN0SWQgZGVmYXVsdCBpZiB0dXJuT24gaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHVybk9uIGF1dG8gZ2VuZXJhdGVkIE9iamVjdElkIGRlZmF1bHRzXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICovXG5cbk9iamVjdElkLnByb3RvdHlwZS5hdXRvID0gZnVuY3Rpb24odHVybk9uKSB7XG4gIGlmICh0dXJuT24pIHtcbiAgICB0aGlzLmRlZmF1bHQoZGVmYXVsdElkKTtcbiAgICB0aGlzLnNldChyZXNldElkKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5PYmplY3RJZC5fY2hlY2tSZXF1aXJlZCA9IHYgPT4gaXNCc29uVHlwZSh2LCAnT2JqZWN0SWQnKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5PYmplY3RJZC5fY2FzdCA9IGNhc3RPYmplY3RJZDtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBvYmplY3RpZHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIE1vbmdvb3NlIG9ubHkgdHJ5IHRvIGNhc3QgbGVuZ3RoIDI0IHN0cmluZ3MuIEJ5IGRlZmF1bHQsIGFueSAxMlxuICogICAgIC8vIGNoYXIgc3RyaW5nIGlzIGEgdmFsaWQgT2JqZWN0SWQuXG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5PYmplY3RJZC5jYXN0KCk7XG4gKiAgICAgbW9uZ29vc2UuT2JqZWN0SWQuY2FzdCh2ID0+IHtcbiAqICAgICAgIGFzc2VydC5vayh0eXBlb2YgdiAhPT0gJ3N0cmluZycgfHwgdi5sZW5ndGggPT09IDI0KTtcbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuT2JqZWN0SWQuY2FzdChmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FzdGVyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0SWQuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbk9iamVjdElkLl9kZWZhdWx0Q2FzdGVyID0gdiA9PiB7XG4gIGlmICghKGlzQnNvblR5cGUodiwgJ09iamVjdElkJykpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHYgKyAnIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBPYmplY3RJZCcpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmdcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEFsbG93IGVtcHR5IHN0cmluZ3MgdG8gcGFzcyBgcmVxdWlyZWRgIGNoZWNrXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLlN0cmluZy5jaGVja1JlcXVpcmVkKHYgPT4gdiAhPSBudWxsKTtcbiAqXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKHsgc3RyOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSB9KTtcbiAqICAgICBuZXcgTSh7IHN0cjogJycgfSkudmFsaWRhdGVTeW5jKCk7IC8vIGBudWxsYCwgdmFsaWRhdGlvbiBwYXNzZXMhXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0SWQuY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIGEgcmVxdWlyZWQgdmFsaWRhdG9yLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3RJZC5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWQodmFsdWUsIGRvYykge1xuICBpZiAoU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgdHJ1ZSkpIHtcbiAgICByZXR1cm4gISF2YWx1ZTtcbiAgfVxuXG4gIC8vIGByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoKWAgZG9lcyAqKm5vdCoqIGNvcHkgc3RhdGljIHByb3BlcnRpZXMsIGFuZFxuICAvLyBwbHVnaW5zIGxpa2UgbW9uZ29vc2UtZmxvYXQgdXNlIGBpbmhlcml0cygpYCBmb3IgcHJlLUVTNi5cbiAgY29uc3QgX2NoZWNrUmVxdWlyZWQgPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQoKSA6XG4gICAgT2JqZWN0SWQuY2hlY2tSZXF1aXJlZCgpO1xuXG4gIHJldHVybiBfY2hlY2tSZXF1aXJlZCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIENhc3RzIHRvIE9iamVjdElkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXQgd2hldGhlciB0aGlzIGlzIGFuIGluaXRpYWxpemF0aW9uIGNhc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk9iamVjdElkLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUsIGRvYywgaW5pdCkge1xuICBpZiAoIShpc0Jzb25UeXBlKHZhbHVlLCAnT2JqZWN0SWQnKSkgJiYgU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgaW5pdCkpIHtcbiAgICAvLyB3YWl0ISB3ZSBtYXkgbmVlZCB0byBjYXN0IHRoaXMgdG8gYSBkb2N1bWVudFxuICAgIGlmICgoZ2V0Q29uc3RydWN0b3JOYW1lKHZhbHVlKSB8fCAnJykudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdGlkJykge1xuICAgICAgcmV0dXJuIG5ldyBvaWQodmFsdWUudG9IZXhTdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdXRpbHMuaXNOb25CdWlsdGluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nhc3RSZWYodmFsdWUsIGRvYywgaW5pdCk7XG4gICAgfVxuICB9XG5cbiAgbGV0IGNhc3RPYmplY3RJZDtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0T2JqZWN0SWQgPSB0aGlzLl9jYXN0RnVuY3Rpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2FzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3RPYmplY3RJZCA9IHRoaXMuY29uc3RydWN0b3IuY2FzdCgpO1xuICB9IGVsc2Uge1xuICAgIGNhc3RPYmplY3RJZCA9IE9iamVjdElkLmNhc3QoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhc3RPYmplY3RJZCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignT2JqZWN0SWQnLCB2YWx1ZSwgdGhpcy5wYXRoLCBlcnJvciwgdGhpcyk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHZhbCkge1xuICByZXR1cm4gdGhpcy5jYXN0KHZhbCk7XG59XG5cbk9iamVjdElkLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyA9IHtcbiAgLi4uU2NoZW1hVHlwZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMsXG4gICRndDogaGFuZGxlU2luZ2xlLFxuICAkZ3RlOiBoYW5kbGVTaW5nbGUsXG4gICRsdDogaGFuZGxlU2luZ2xlLFxuICAkbHRlOiBoYW5kbGVTaW5nbGVcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZGVmYXVsdElkKCkge1xuICByZXR1cm4gbmV3IG9pZCgpO1xufVxuXG5kZWZhdWx0SWQuJHJ1bkJlZm9yZVNldHRlcnMgPSB0cnVlO1xuXG5mdW5jdGlvbiByZXNldElkKHYpIHtcbiAgRG9jdW1lbnQgfHwgKERvY3VtZW50ID0gcmVxdWlyZSgnLi8uLi9kb2N1bWVudCcpKTtcblxuICBpZiAodGhpcyBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgaWYgKHYgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgX3YgPSBuZXcgb2lkKCk7XG4gICAgICByZXR1cm4gX3Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHY7XG59XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RJZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/objectid.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/operators/bitwise.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/operators/bitwise.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements.\n */\n\n\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\n\n/*!\n * ignore\n */\n\nfunction handleBitwiseOperator(val) {\n  const _this = this;\n  if (Array.isArray(val)) {\n    return val.map(function(v) {\n      return _castNumber(_this.path, v);\n    });\n  } else if (Buffer.isBuffer(val)) {\n    return val;\n  }\n  // Assume trying to cast to number\n  return _castNumber(_this.path, val);\n}\n\n/*!\n * ignore\n */\n\nfunction _castNumber(path, num) {\n  const v = Number(num);\n  if (isNaN(v)) {\n    throw new CastError('number', num, path);\n  }\n  return v;\n}\n\nmodule.exports = handleBitwiseOperator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9iaXR3aXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBa0I7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHNjaGVtYVxcb3BlcmF0b3JzXFxiaXR3aXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL2Nhc3QnKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IodmFsKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiB2YWwubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBfY2FzdE51bWJlcihfdGhpcy5wYXRoLCB2KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgLy8gQXNzdW1lIHRyeWluZyB0byBjYXN0IHRvIG51bWJlclxuICByZXR1cm4gX2Nhc3ROdW1iZXIoX3RoaXMucGF0aCwgdmFsKTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfY2FzdE51bWJlcihwYXRoLCBudW0pIHtcbiAgY29uc3QgdiA9IE51bWJlcihudW0pO1xuICBpZiAoaXNOYU4odikpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdudW1iZXInLCBudW0sIHBhdGgpO1xuICB9XG4gIHJldHVybiB2O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhbmRsZUJpdHdpc2VPcGVyYXRvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/operators/bitwise.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/operators/exists.js":
/*!**********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/operators/exists.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst castBoolean = __webpack_require__(/*! ../../cast/boolean */ \"(api)/../server/node_modules/mongoose/lib/cast/boolean.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  const path = this != null ? this.path : null;\n  return castBoolean(val, path);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9leGlzdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMscUZBQW9COztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxzY2hlbWFcXG9wZXJhdG9yc1xcZXhpc3RzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2FzdEJvb2xlYW4gPSByZXF1aXJlKCcuLi8uLi9jYXN0L2Jvb2xlYW4nKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCkge1xuICBjb25zdCBwYXRoID0gdGhpcyAhPSBudWxsID8gdGhpcy5wYXRoIDogbnVsbDtcbiAgcmV0dXJuIGNhc3RCb29sZWFuKHZhbCwgcGF0aCk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/operators/exists.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/operators/geospatial.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/operators/geospatial.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements.\n */\n\n\n\nconst castArraysOfNumbers = (__webpack_require__(/*! ./helpers */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/helpers.js\").castArraysOfNumbers);\nconst castToNumber = (__webpack_require__(/*! ./helpers */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/helpers.js\").castToNumber);\n\n/*!\n * ignore\n */\n\nexports.cast$geoIntersects = cast$geoIntersects;\nexports.cast$near = cast$near;\nexports.cast$within = cast$within;\n\nfunction cast$near(val) {\n  const SchemaArray = __webpack_require__(/*! ../array */ \"(api)/../server/node_modules/mongoose/lib/schema/array.js\");\n\n  if (Array.isArray(val)) {\n    castArraysOfNumbers(val, this);\n    return val;\n  }\n\n  _castMinMaxDistance(this, val);\n\n  if (val && val.$geometry) {\n    return cast$geometry(val, this);\n  }\n\n  if (!Array.isArray(val)) {\n    throw new TypeError('$near must be either an array or an object ' +\n      'with a $geometry property');\n  }\n\n  return SchemaArray.prototype.castForQuery.call(this, null, val);\n}\n\nfunction cast$geometry(val, self) {\n  switch (val.$geometry.type) {\n    case 'Polygon':\n    case 'LineString':\n    case 'Point':\n      castArraysOfNumbers(val.$geometry.coordinates, self);\n      break;\n    default:\n      // ignore unknowns\n      break;\n  }\n\n  _castMinMaxDistance(self, val);\n\n  return val;\n}\n\nfunction cast$within(val) {\n  _castMinMaxDistance(this, val);\n\n  if (val.$box || val.$polygon) {\n    const type = val.$box ? '$box' : '$polygon';\n    val[type].forEach(arr => {\n      if (!Array.isArray(arr)) {\n        const msg = 'Invalid $within $box argument. '\n            + 'Expected an array, received ' + arr;\n        throw new TypeError(msg);\n      }\n      arr.forEach((v, i) => {\n        arr[i] = castToNumber.call(this, v);\n      });\n    });\n  } else if (val.$center || val.$centerSphere) {\n    const type = val.$center ? '$center' : '$centerSphere';\n    val[type].forEach((item, i) => {\n      if (Array.isArray(item)) {\n        item.forEach((v, j) => {\n          item[j] = castToNumber.call(this, v);\n        });\n      } else {\n        val[type][i] = castToNumber.call(this, item);\n      }\n    });\n  } else if (val.$geometry) {\n    cast$geometry(val, this);\n  }\n\n  return val;\n}\n\nfunction cast$geoIntersects(val) {\n  const geo = val.$geometry;\n  if (!geo) {\n    return;\n  }\n\n  cast$geometry(val, this);\n  return val;\n}\n\nfunction _castMinMaxDistance(self, val) {\n  if (val.$maxDistance) {\n    val.$maxDistance = castToNumber.call(self, val.$maxDistance);\n  }\n  if (val.$minDistance) {\n    val.$minDistance = castToNumber.call(self, val.$minDistance);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9nZW9zcGF0aWFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiw0QkFBNEIsbUlBQXdDO0FBQ3BFLHFCQUFxQiw0SEFBaUM7O0FBRXREO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsaUJBQWlCO0FBQ2pCLG1CQUFtQjs7QUFFbkI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQywyRUFBVTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHNjaGVtYVxcb3BlcmF0b3JzXFxnZW9zcGF0aWFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNhc3RBcnJheXNPZk51bWJlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5jYXN0QXJyYXlzT2ZOdW1iZXJzO1xuY29uc3QgY2FzdFRvTnVtYmVyID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuY2FzdFRvTnVtYmVyO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuY2FzdCRnZW9JbnRlcnNlY3RzID0gY2FzdCRnZW9JbnRlcnNlY3RzO1xuZXhwb3J0cy5jYXN0JG5lYXIgPSBjYXN0JG5lYXI7XG5leHBvcnRzLmNhc3Qkd2l0aGluID0gY2FzdCR3aXRoaW47XG5cbmZ1bmN0aW9uIGNhc3QkbmVhcih2YWwpIHtcbiAgY29uc3QgU2NoZW1hQXJyYXkgPSByZXF1aXJlKCcuLi9hcnJheScpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBjYXN0QXJyYXlzT2ZOdW1iZXJzKHZhbCwgdGhpcyk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIF9jYXN0TWluTWF4RGlzdGFuY2UodGhpcywgdmFsKTtcblxuICBpZiAodmFsICYmIHZhbC4kZ2VvbWV0cnkpIHtcbiAgICByZXR1cm4gY2FzdCRnZW9tZXRyeSh2YWwsIHRoaXMpO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCckbmVhciBtdXN0IGJlIGVpdGhlciBhbiBhcnJheSBvciBhbiBvYmplY3QgJyArXG4gICAgICAnd2l0aCBhICRnZW9tZXRyeSBwcm9wZXJ0eScpO1xuICB9XG5cbiAgcmV0dXJuIFNjaGVtYUFycmF5LnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkuY2FsbCh0aGlzLCBudWxsLCB2YWwpO1xufVxuXG5mdW5jdGlvbiBjYXN0JGdlb21ldHJ5KHZhbCwgc2VsZikge1xuICBzd2l0Y2ggKHZhbC4kZ2VvbWV0cnkudHlwZSkge1xuICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgIGNhc3RBcnJheXNPZk51bWJlcnModmFsLiRnZW9tZXRyeS5jb29yZGluYXRlcywgc2VsZik7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gaWdub3JlIHVua25vd25zXG4gICAgICBicmVhaztcbiAgfVxuXG4gIF9jYXN0TWluTWF4RGlzdGFuY2Uoc2VsZiwgdmFsKTtcblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBjYXN0JHdpdGhpbih2YWwpIHtcbiAgX2Nhc3RNaW5NYXhEaXN0YW5jZSh0aGlzLCB2YWwpO1xuXG4gIGlmICh2YWwuJGJveCB8fCB2YWwuJHBvbHlnb24pIHtcbiAgICBjb25zdCB0eXBlID0gdmFsLiRib3ggPyAnJGJveCcgOiAnJHBvbHlnb24nO1xuICAgIHZhbFt0eXBlXS5mb3JFYWNoKGFyciA9PiB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICBjb25zdCBtc2cgPSAnSW52YWxpZCAkd2l0aGluICRib3ggYXJndW1lbnQuICdcbiAgICAgICAgICAgICsgJ0V4cGVjdGVkIGFuIGFycmF5LCByZWNlaXZlZCAnICsgYXJyO1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICBhcnIuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICBhcnJbaV0gPSBjYXN0VG9OdW1iZXIuY2FsbCh0aGlzLCB2KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHZhbC4kY2VudGVyIHx8IHZhbC4kY2VudGVyU3BoZXJlKSB7XG4gICAgY29uc3QgdHlwZSA9IHZhbC4kY2VudGVyID8gJyRjZW50ZXInIDogJyRjZW50ZXJTcGhlcmUnO1xuICAgIHZhbFt0eXBlXS5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICBpdGVtLmZvckVhY2goKHYsIGopID0+IHtcbiAgICAgICAgICBpdGVtW2pdID0gY2FzdFRvTnVtYmVyLmNhbGwodGhpcywgdik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsW3R5cGVdW2ldID0gY2FzdFRvTnVtYmVyLmNhbGwodGhpcywgaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodmFsLiRnZW9tZXRyeSkge1xuICAgIGNhc3QkZ2VvbWV0cnkodmFsLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGNhc3QkZ2VvSW50ZXJzZWN0cyh2YWwpIHtcbiAgY29uc3QgZ2VvID0gdmFsLiRnZW9tZXRyeTtcbiAgaWYgKCFnZW8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjYXN0JGdlb21ldHJ5KHZhbCwgdGhpcyk7XG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIF9jYXN0TWluTWF4RGlzdGFuY2Uoc2VsZiwgdmFsKSB7XG4gIGlmICh2YWwuJG1heERpc3RhbmNlKSB7XG4gICAgdmFsLiRtYXhEaXN0YW5jZSA9IGNhc3RUb051bWJlci5jYWxsKHNlbGYsIHZhbC4kbWF4RGlzdGFuY2UpO1xuICB9XG4gIGlmICh2YWwuJG1pbkRpc3RhbmNlKSB7XG4gICAgdmFsLiRtaW5EaXN0YW5jZSA9IGNhc3RUb051bWJlci5jYWxsKHNlbGYsIHZhbC4kbWluRGlzdGFuY2UpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/operators/geospatial.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/operators/helpers.js":
/*!***********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/operators/helpers.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module requirements.\n */\n\nconst SchemaNumber = __webpack_require__(/*! ../number */ \"(api)/../server/node_modules/mongoose/lib/schema/number.js\");\n\n/*!\n * ignore\n */\n\nexports.castToNumber = castToNumber;\nexports.castArraysOfNumbers = castArraysOfNumbers;\n\n/*!\n * ignore\n */\n\nfunction castToNumber(val) {\n  return SchemaNumber.cast()(val);\n}\n\nfunction castArraysOfNumbers(arr, self) {\n  arr.forEach(function(v, i) {\n    if (Array.isArray(v)) {\n      castArraysOfNumbers(v, self);\n    } else {\n      arr[i] = castToNumber.call(self, v);\n    }\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBVzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHNjaGVtYVxcb3BlcmF0b3JzXFxoZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbmNvbnN0IFNjaGVtYU51bWJlciA9IHJlcXVpcmUoJy4uL251bWJlcicpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuY2FzdFRvTnVtYmVyID0gY2FzdFRvTnVtYmVyO1xuZXhwb3J0cy5jYXN0QXJyYXlzT2ZOdW1iZXJzID0gY2FzdEFycmF5c09mTnVtYmVycztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBjYXN0VG9OdW1iZXIodmFsKSB7XG4gIHJldHVybiBTY2hlbWFOdW1iZXIuY2FzdCgpKHZhbCk7XG59XG5cbmZ1bmN0aW9uIGNhc3RBcnJheXNPZk51bWJlcnMoYXJyLCBzZWxmKSB7XG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgY2FzdEFycmF5c09mTnVtYmVycyh2LCBzZWxmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyW2ldID0gY2FzdFRvTnVtYmVyLmNhbGwoc2VsZiwgdik7XG4gICAgfVxuICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/operators/helpers.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/operators/text.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/operators/text.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"(api)/../server/node_modules/mongoose/lib/error/cast.js\");\nconst castBoolean = __webpack_require__(/*! ../../cast/boolean */ \"(api)/../server/node_modules/mongoose/lib/cast/boolean.js\");\nconst castString = __webpack_require__(/*! ../../cast/string */ \"(api)/../server/node_modules/mongoose/lib/cast/string.js\");\n\n/**\n * Casts val to an object suitable for `$text`. Throws an error if the object\n * can't be casted.\n *\n * @param {Any} val value to cast\n * @param {String} [path] path to associate with any errors that occured\n * @return {Object} casted object\n * @see https://www.mongodb.com/docs/manual/reference/operator/query/text/\n * @api private\n */\n\nmodule.exports = function castTextSearch(val, path) {\n  if (val == null || typeof val !== 'object') {\n    throw new CastError('$text', val, path);\n  }\n\n  if (val.$search != null) {\n    val.$search = castString(val.$search, path + '.$search');\n  }\n  if (val.$language != null) {\n    val.$language = castString(val.$language, path + '.$language');\n  }\n  if (val.$caseSensitive != null) {\n    val.$caseSensitive = castBoolean(val.$caseSensitive,\n      path + '.$castSensitive');\n  }\n  if (val.$diacriticSensitive != null) {\n    val.$diacriticSensitive = castBoolean(val.$diacriticSensitive,\n      path + '.$diacriticSensitive');\n  }\n\n  return val;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy90ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFrQjtBQUM1QyxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsbUZBQW1COztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxzY2hlbWFcXG9wZXJhdG9yc1xcdGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL2Nhc3QnKTtcbmNvbnN0IGNhc3RCb29sZWFuID0gcmVxdWlyZSgnLi4vLi4vY2FzdC9ib29sZWFuJyk7XG5jb25zdCBjYXN0U3RyaW5nID0gcmVxdWlyZSgnLi4vLi4vY2FzdC9zdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyB2YWwgdG8gYW4gb2JqZWN0IHN1aXRhYmxlIGZvciBgJHRleHRgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIG9iamVjdFxuICogY2FuJ3QgYmUgY2FzdGVkLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWwgdmFsdWUgdG8gY2FzdFxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSBwYXRoIHRvIGFzc29jaWF0ZSB3aXRoIGFueSBlcnJvcnMgdGhhdCBvY2N1cmVkXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNhc3RlZCBvYmplY3RcbiAqIEBzZWUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L3RleHQvXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3RUZXh0U2VhcmNoKHZhbCwgcGF0aCkge1xuICBpZiAodmFsID09IG51bGwgfHwgdHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCckdGV4dCcsIHZhbCwgcGF0aCk7XG4gIH1cblxuICBpZiAodmFsLiRzZWFyY2ggIT0gbnVsbCkge1xuICAgIHZhbC4kc2VhcmNoID0gY2FzdFN0cmluZyh2YWwuJHNlYXJjaCwgcGF0aCArICcuJHNlYXJjaCcpO1xuICB9XG4gIGlmICh2YWwuJGxhbmd1YWdlICE9IG51bGwpIHtcbiAgICB2YWwuJGxhbmd1YWdlID0gY2FzdFN0cmluZyh2YWwuJGxhbmd1YWdlLCBwYXRoICsgJy4kbGFuZ3VhZ2UnKTtcbiAgfVxuICBpZiAodmFsLiRjYXNlU2Vuc2l0aXZlICE9IG51bGwpIHtcbiAgICB2YWwuJGNhc2VTZW5zaXRpdmUgPSBjYXN0Qm9vbGVhbih2YWwuJGNhc2VTZW5zaXRpdmUsXG4gICAgICBwYXRoICsgJy4kY2FzdFNlbnNpdGl2ZScpO1xuICB9XG4gIGlmICh2YWwuJGRpYWNyaXRpY1NlbnNpdGl2ZSAhPSBudWxsKSB7XG4gICAgdmFsLiRkaWFjcml0aWNTZW5zaXRpdmUgPSBjYXN0Qm9vbGVhbih2YWwuJGRpYWNyaXRpY1NlbnNpdGl2ZSxcbiAgICAgIHBhdGggKyAnLiRkaWFjcml0aWNTZW5zaXRpdmUnKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/operators/text.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/operators/type.js":
/*!********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/operators/type.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  if (Array.isArray(val)) {\n    if (!val.every(v => typeof v === 'number' || typeof v === 'string')) {\n      throw new Error('$type array values must be strings or numbers');\n    }\n    return val;\n  }\n\n  if (typeof val !== 'number' && typeof val !== 'string') {\n    throw new Error('$type parameter must be number, string, or array of numbers and strings');\n  }\n\n  return val;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy90eXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHNjaGVtYVxcb3BlcmF0b3JzXFx0eXBlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgaWYgKCF2YWwuZXZlcnkodiA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHYgPT09ICdzdHJpbmcnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCckdHlwZSBhcnJheSB2YWx1ZXMgbXVzdCBiZSBzdHJpbmdzIG9yIG51bWJlcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignJHR5cGUgcGFyYW1ldGVyIG11c3QgYmUgbnVtYmVyLCBzdHJpbmcsIG9yIGFycmF5IG9mIG51bWJlcnMgYW5kIHN0cmluZ3MnKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/operators/type.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/string.js":
/*!************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/string.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nconst SchemaStringOptions = __webpack_require__(/*! ../options/SchemaStringOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaStringOptions.js\");\nconst castString = __webpack_require__(/*! ../cast/string */ \"(api)/../server/node_modules/mongoose/lib/cast/string.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst CastError = SchemaType.CastError;\n\n/**\n * String SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaString(key, options) {\n  this.enumValues = [];\n  this.regExp = null;\n  SchemaType.call(this, key, options, 'String');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaString.schemaName = 'String';\n\nSchemaString.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaString.prototype = Object.create(SchemaType.prototype);\nSchemaString.prototype.constructor = SchemaString;\nObject.defineProperty(SchemaString.prototype, 'OptionsConstructor', {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: SchemaStringOptions\n});\n\n/*!\n * ignore\n */\n\nSchemaString._cast = castString;\n\n/**\n * Get/set the function used to cast arbitrary values to strings.\n *\n * #### Example:\n *\n *     // Throw an error if you pass in an object. Normally, Mongoose allows\n *     // objects with custom `toString()` functions.\n *     const original = mongoose.Schema.Types.String.cast();\n *     mongoose.Schema.Types.String.cast(v => {\n *       assert.ok(v == null || typeof v !== 'object');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.String.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaString.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaString._defaultCaster = v => {\n  if (v != null && typeof v !== 'string') {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * Attaches a getter for all String instances.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Schema.String.get(v => v.toLowerCase());\n *\n *     const Model = mongoose.model('Test', new Schema({ test: String }));\n *     new Model({ test: 'FOO' }).test; // 'foo'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaString.get = SchemaType.get;\n\n/**\n * Sets a default option for all String instances.\n *\n * #### Example:\n *\n *     // Make all strings have option `trim` equal to true.\n *     mongoose.Schema.String.set('trim', true);\n *\n *     const User = mongoose.model('User', new Schema({ name: String }));\n *     new User({ name: '   John Doe   ' }).name; // 'John Doe'\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaString.set = SchemaType.set;\n\nSchemaString.setters = [];\n\n/*!\n * ignore\n */\n\nSchemaString._checkRequired = v => (v instanceof String || typeof v === 'string') && v.length;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaString.checkRequired = SchemaType.checkRequired;\n\n/**\n * Adds an enum validator\n *\n * #### Example:\n *\n *     const states = ['opening', 'open', 'closing', 'closed']\n *     const s = new Schema({ state: { type: String, enum: states }})\n *     const M = db.model('M', s)\n *     const m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n *     // or with custom error messages\n *     const enum = {\n *       values: ['opening', 'open', 'closing', 'closed'],\n *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'\n *     }\n *     const s = new Schema({ state: { type: String, enum: enum })\n *     const M = db.model('M', s)\n *     const m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @see Enums in JavaScript https://masteringjs.io/tutorials/fundamentals/enum\n * @api public\n */\n\nSchemaString.prototype.enum = function() {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.enumValidator;\n    }, this);\n    this.enumValidator = false;\n  }\n\n  if (arguments[0] === void 0 || arguments[0] === false) {\n    return this;\n  }\n\n  let values;\n  let errorMessage;\n\n  if (utils.isObject(arguments[0])) {\n    if (Array.isArray(arguments[0].values)) {\n      values = arguments[0].values;\n      errorMessage = arguments[0].message;\n    } else {\n      values = utils.object.vals(arguments[0]);\n      errorMessage = MongooseError.messages.String.enum;\n    }\n  } else {\n    values = arguments;\n    errorMessage = MongooseError.messages.String.enum;\n  }\n\n  for (const value of values) {\n    if (value !== undefined) {\n      this.enumValues.push(this.cast(value));\n    }\n  }\n\n  const vals = this.enumValues;\n  this.enumValidator = function(v) {\n    return undefined === v || ~vals.indexOf(v);\n  };\n  this.validators.push({\n    validator: this.enumValidator,\n    message: errorMessage,\n    type: 'enum',\n    enumValues: vals\n  });\n\n  return this;\n};\n\n/**\n * Adds a lowercase [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * #### Example:\n *\n *     const s = new Schema({ email: { type: String, lowercase: true }})\n *     const M = db.model('M', s);\n *     const m = new M({ email: 'SomeEmail@example.COM' });\n *     console.log(m.email) // someemail@example.com\n *     M.find({ email: 'SomeEmail@example.com' }); // Queries by 'someemail@example.com'\n *\n * Note that `lowercase` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Still queries for documents whose `email` matches the regular\n *     // expression /SomeEmail/. Mongoose does **not** convert the RegExp\n *     // to lowercase.\n *     M.find({ email: /SomeEmail/ });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.lowercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.toLowerCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds an uppercase [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * #### Example:\n *\n *     const s = new Schema({ caps: { type: String, uppercase: true }})\n *     const M = db.model('M', s);\n *     const m = new M({ caps: 'an example' });\n *     console.log(m.caps) // AN EXAMPLE\n *     M.find({ caps: 'an example' }) // Matches documents where caps = 'AN EXAMPLE'\n *\n * Note that `uppercase` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Mongoose does **not** convert the RegExp to uppercase.\n *     M.find({ email: /an example/ });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.uppercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.toUpperCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds a trim [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * The string value will be [trimmed](https://masteringjs.io/tutorials/fundamentals/trim-string) when set.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, trim: true }});\n *     const M = db.model('M', s);\n *     const string = ' some name ';\n *     console.log(string.length); // 11\n *     const m = new M({ name: string });\n *     console.log(m.name.length); // 9\n *\n *     // Equivalent to `findOne({ name: string.trim() })`\n *     M.findOne({ name: string });\n *\n * Note that `trim` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Mongoose does **not** trim whitespace from the RegExp.\n *     M.find({ name: / some name / });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.trim = function(shouldTrim) {\n  if (arguments.length > 0 && !shouldTrim) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.trim();\n    }\n    return v;\n  });\n};\n\n/**\n * Sets a minimum length validator.\n *\n * #### Example:\n *\n *     const schema = new Schema({ postalCode: { type: String, minlength: 5 })\n *     const Address = db.model('Address', schema)\n *     const address = new Address({ postalCode: '9512' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length\n *     const minlength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];\n *     const schema = new Schema({ postalCode: { type: String, minlength: minlength })\n *     const Address = mongoose.model('Address', schema);\n *     const address = new Address({ postalCode: '9512' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).\n *     })\n *\n * @param {Number} value minimum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.minlength = function(value, message) {\n  if (this.minlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.String.minlength;\n    msg = msg.replace(/{MINLENGTH}/, value);\n    this.validators.push({\n      validator: this.minlengthValidator = function(v) {\n        return v === null || v.length >= value;\n      },\n      message: msg,\n      type: 'minlength',\n      minlength: value\n    });\n  }\n\n  return this;\n};\n\nSchemaString.prototype.minLength = SchemaString.prototype.minlength;\n\n/**\n * Sets a maximum length validator.\n *\n * #### Example:\n *\n *     const schema = new Schema({ postalCode: { type: String, maxlength: 9 })\n *     const Address = db.model('Address', schema)\n *     const address = new Address({ postalCode: '9512512345' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length\n *     const maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];\n *     const schema = new Schema({ postalCode: { type: String, maxlength: maxlength })\n *     const Address = mongoose.model('Address', schema);\n *     const address = new Address({ postalCode: '9512512345' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (9).\n *     })\n *\n * @param {Number} value maximum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.maxlength = function(value, message) {\n  if (this.maxlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.String.maxlength;\n    msg = msg.replace(/{MAXLENGTH}/, value);\n    this.validators.push({\n      validator: this.maxlengthValidator = function(v) {\n        return v === null || v.length <= value;\n      },\n      message: msg,\n      type: 'maxlength',\n      maxlength: value\n    });\n  }\n\n  return this;\n};\n\nSchemaString.prototype.maxLength = SchemaString.prototype.maxlength;\n\n/**\n * Sets a regexp validator.\n *\n * Any value that does not pass `regExp`.test(val) will fail validation.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, match: /^a/ }})\n *     const M = db.model('M', s)\n *     const m = new M({ name: 'I am invalid' })\n *     m.validate(function (err) {\n *       console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"\n *       m.name = 'apples'\n *       m.validate(function (err) {\n *         assert.ok(err) // success\n *       })\n *     })\n *\n *     // using a custom error message\n *     const match = [ /\\.html$/, \"That file doesn't end in .html ({VALUE})\" ];\n *     const s = new Schema({ file: { type: String, match: match }})\n *     const M = db.model('M', s);\n *     const m = new M({ file: 'invalid' });\n *     m.validate(function (err) {\n *       console.log(String(err)) // \"ValidationError: That file doesn't end in .html (invalid)\"\n *     })\n *\n * Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.\n *\n *     const s = new Schema({ name: { type: String, match: /^a/, required: true }})\n *\n * @param {RegExp} regExp regular expression to test against\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.match = function match(regExp, message) {\n  // yes, we allow multiple match validators\n\n  const msg = message || MongooseError.messages.String.match;\n\n  const matchValidator = function(v) {\n    if (!regExp) {\n      return false;\n    }\n\n    // In case RegExp happens to have `/g` flag set, we need to reset the\n    // `lastIndex`, otherwise `match` will intermittently fail.\n    regExp.lastIndex = 0;\n\n    const ret = ((v != null && v !== '')\n      ? regExp.test(v)\n      : true);\n    return ret;\n  };\n\n  this.validators.push({\n    validator: matchValidator,\n    message: msg,\n    type: 'regexp',\n    regexp: regExp\n  });\n  return this;\n};\n\n/**\n * Check if the given value satisfies the `required` validator. The value is\n * considered valid if it is a string (that is, not `null` or `undefined`) and\n * has positive length. The `required` validator **will** fail for empty\n * strings.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaString.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaString.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to String\n *\n * @api private\n */\n\nSchemaString.prototype.cast = function(value, doc, init) {\n  if (typeof value !== 'string' && SchemaType._isRef(this, value, doc, init)) {\n    return this._castRef(value, doc, init);\n  }\n\n  let castString;\n  if (typeof this._castFunction === 'function') {\n    castString = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castString = this.constructor.cast();\n  } else {\n    castString = SchemaString.cast();\n  }\n\n  try {\n    return castString(value);\n  } catch (error) {\n    throw new CastError('string', value, this.path, null, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction handleSingleNoSetters(val) {\n  if (val == null) {\n    return this._castNullish(val);\n  }\n\n  return this.cast(val, this);\n}\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $all: handleArray,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $options: handleSingleNoSetters,\n  $regex: function handle$regex(val) {\n    if (Object.prototype.toString.call(val) === '[object RegExp]') {\n      return val;\n    }\n\n    return handleSingleNoSetters.call(this, val);\n  },\n  $not: handleSingle\n};\n\nObject.defineProperty(SchemaString.prototype, '$conditionalHandlers', {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: Object.freeze($conditionalHandlers)\n});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [val]\n * @api private\n */\n\nSchemaString.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with String.');\n    }\n    return handler.call(this, val, context);\n  }\n\n  if (Object.prototype.toString.call(val) === '[object RegExp]' || isBsonType(val, 'BSONRegExp')) {\n    return val;\n  }\n\n  return this.applySetters(val, context);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL3N0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsOEVBQWU7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMsZ0ZBQWdCO0FBQzlDLDRCQUE0QixtQkFBTyxDQUFDLGdIQUFnQztBQUNwRSxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBZ0I7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLG9FQUFVO0FBQ2hDLG1CQUFtQixtQkFBTyxDQUFDLDhGQUF1Qjs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsY0FBYztBQUN2RSxtQkFBbUIsYUFBYSxRQUFRO0FBQ3hDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcc2NoZW1hXFxzdHJpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYXR5cGUnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU2NoZW1hU3RyaW5nT3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvU2NoZW1hU3RyaW5nT3B0aW9ucycpO1xuY29uc3QgY2FzdFN0cmluZyA9IHJlcXVpcmUoJy4uL2Nhc3Qvc3RyaW5nJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5cbmNvbnN0IENhc3RFcnJvciA9IFNjaGVtYVR5cGUuQ2FzdEVycm9yO1xuXG4vKipcbiAqIFN0cmluZyBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFTdHJpbmcoa2V5LCBvcHRpb25zKSB7XG4gIHRoaXMuZW51bVZhbHVlcyA9IFtdO1xuICB0aGlzLnJlZ0V4cCA9IG51bGw7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdTdHJpbmcnKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFTdHJpbmcuc2NoZW1hTmFtZSA9ICdTdHJpbmcnO1xuXG5TY2hlbWFTdHJpbmcuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYVN0cmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYVN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFTdHJpbmc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nLnByb3RvdHlwZSwgJ09wdGlvbnNDb25zdHJ1Y3RvcicsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IFNjaGVtYVN0cmluZ09wdGlvbnNcbn0pO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVN0cmluZy5fY2FzdCA9IGNhc3RTdHJpbmc7XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gc3RyaW5ncy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHlvdSBwYXNzIGluIGFuIG9iamVjdC4gTm9ybWFsbHksIE1vbmdvb3NlIGFsbG93c1xuICogICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvU3RyaW5nKClgIGZ1bmN0aW9ucy5cbiAqICAgICBjb25zdCBvcmlnaW5hbCA9IG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5TdHJpbmcuY2FzdCgpO1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5TdHJpbmcuY2FzdCh2ID0+IHtcbiAqICAgICAgIGFzc2VydC5vayh2ID09IG51bGwgfHwgdHlwZW9mIHYgIT09ICdvYmplY3QnKTtcbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLlN0cmluZy5jYXN0KGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYXN0ZXJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdHJpbmcuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVN0cmluZy5fZGVmYXVsdENhc3RlciA9IHYgPT4ge1xuICBpZiAodiAhPSBudWxsICYmIHR5cGVvZiB2ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIFN0cmluZyBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBudW1iZXJzIHJvdW5kIGRvd25cbiAqICAgICBtb25nb29zZS5TY2hlbWEuU3RyaW5nLmdldCh2ID0+IHYudG9Mb3dlckNhc2UoKSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgdGVzdDogU3RyaW5nIH0pKTtcbiAqICAgICBuZXcgTW9kZWwoeyB0ZXN0OiAnRk9PJyB9KS50ZXN0OyAvLyAnZm9vJ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3RyaW5nLmdldCA9IFNjaGVtYVR5cGUuZ2V0O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIFN0cmluZyBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBzdHJpbmdzIGhhdmUgb3B0aW9uIGB0cmltYCBlcXVhbCB0byB0cnVlLlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5TdHJpbmcuc2V0KCd0cmltJywgdHJ1ZSk7XG4gKlxuICogICAgIGNvbnN0IFVzZXIgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSkpO1xuICogICAgIG5ldyBVc2VyKHsgbmFtZTogJyAgIEpvaG4gRG9lICAgJyB9KS5uYW1lOyAvLyAnSm9obiBEb2UnXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hU3RyaW5nLnNldHRlcnMgPSBbXTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFTdHJpbmcuX2NoZWNrUmVxdWlyZWQgPSB2ID0+ICh2IGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiB2ID09PSAnc3RyaW5nJykgJiYgdi5sZW5ndGg7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbGxvdyBlbXB0eSBzdHJpbmdzIHRvIHBhc3MgYHJlcXVpcmVkYCBjaGVja1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5TdHJpbmcuY2hlY2tSZXF1aXJlZCh2ID0+IHYgIT0gbnVsbCk7XG4gKlxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCh7IHN0cjogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgbmV3IE0oeyBzdHI6ICcnIH0pLnZhbGlkYXRlU3luYygpOyAvLyBgbnVsbGAsIHZhbGlkYXRpb24gcGFzc2VzIVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBjaGVja1JlcXVpcmVkXG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIEFkZHMgYW4gZW51bSB2YWxpZGF0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHN0YXRlcyA9IFsnb3BlbmluZycsICdvcGVuJywgJ2Nsb3NpbmcnLCAnY2xvc2VkJ11cbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IHN0YXRlOiB7IHR5cGU6IFN0cmluZywgZW51bTogc3RhdGVzIH19KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgc3RhdGU6ICdpbnZhbGlkJyB9KVxuICogICAgIG0uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IGBpbnZhbGlkYCBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIGZvciBwYXRoIGBzdGF0ZWAuXG4gKiAgICAgICBtLnN0YXRlID0gJ29wZW4nXG4gKiAgICAgICBtLnNhdmUoY2FsbGJhY2spIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBvciB3aXRoIGN1c3RvbSBlcnJvciBtZXNzYWdlc1xuICogICAgIGNvbnN0IGVudW0gPSB7XG4gKiAgICAgICB2YWx1ZXM6IFsnb3BlbmluZycsICdvcGVuJywgJ2Nsb3NpbmcnLCAnY2xvc2VkJ10sXG4gKiAgICAgICBtZXNzYWdlOiAnZW51bSB2YWxpZGF0b3IgZmFpbGVkIGZvciBwYXRoIGB7UEFUSH1gIHdpdGggdmFsdWUgYHtWQUxVRX1gJ1xuICogICAgIH1cbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IHN0YXRlOiB7IHR5cGU6IFN0cmluZywgZW51bTogZW51bSB9KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgc3RhdGU6ICdpbnZhbGlkJyB9KVxuICogICAgIG0uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IGVudW0gdmFsaWRhdG9yIGZhaWxlZCBmb3IgcGF0aCBgc3RhdGVgIHdpdGggdmFsdWUgYGludmFsaWRgXG4gKiAgICAgICBtLnN0YXRlID0gJ29wZW4nXG4gKiAgICAgICBtLnNhdmUoY2FsbGJhY2spIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7Li4uU3RyaW5nfE9iamVjdH0gW2FyZ3NdIGVudW1lcmF0aW9uIHZhbHVlc1xuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBDdXN0b21pemVkIEVycm9yIE1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQHNlZSBFbnVtcyBpbiBKYXZhU2NyaXB0IGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9lbnVtXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUuZW51bSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5lbnVtVmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMuZW51bVZhbGlkYXRvcjtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLmVudW1WYWxpZGF0b3IgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHNbMF0gPT09IHZvaWQgMCB8fCBhcmd1bWVudHNbMF0gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsZXQgdmFsdWVzO1xuICBsZXQgZXJyb3JNZXNzYWdlO1xuXG4gIGlmICh1dGlscy5pc09iamVjdChhcmd1bWVudHNbMF0pKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdLnZhbHVlcykpIHtcbiAgICAgIHZhbHVlcyA9IGFyZ3VtZW50c1swXS52YWx1ZXM7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBhcmd1bWVudHNbMF0ubWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzID0gdXRpbHMub2JqZWN0LnZhbHMoYXJndW1lbnRzWzBdKTtcbiAgICAgIGVycm9yTWVzc2FnZSA9IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuU3RyaW5nLmVudW07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICBlcnJvck1lc3NhZ2UgPSBNb25nb29zZUVycm9yLm1lc3NhZ2VzLlN0cmluZy5lbnVtO1xuICB9XG5cbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5lbnVtVmFsdWVzLnB1c2godGhpcy5jYXN0KHZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdmFscyA9IHRoaXMuZW51bVZhbHVlcztcbiAgdGhpcy5lbnVtVmFsaWRhdG9yID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB1bmRlZmluZWQgPT09IHYgfHwgfnZhbHMuaW5kZXhPZih2KTtcbiAgfTtcbiAgdGhpcy52YWxpZGF0b3JzLnB1c2goe1xuICAgIHZhbGlkYXRvcjogdGhpcy5lbnVtVmFsaWRhdG9yLFxuICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICB0eXBlOiAnZW51bScsXG4gICAgZW51bVZhbHVlczogdmFsc1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGxvd2VyY2FzZSBbc2V0dGVyXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXR5cGUuaHRtbCNTY2hlbWFUeXBlLnByb3RvdHlwZS5zZXQoKSkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGVtYWlsOiB7IHR5cGU6IFN0cmluZywgbG93ZXJjYXNlOiB0cnVlIH19KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpO1xuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IGVtYWlsOiAnU29tZUVtYWlsQGV4YW1wbGUuQ09NJyB9KTtcbiAqICAgICBjb25zb2xlLmxvZyhtLmVtYWlsKSAvLyBzb21lZW1haWxAZXhhbXBsZS5jb21cbiAqICAgICBNLmZpbmQoeyBlbWFpbDogJ1NvbWVFbWFpbEBleGFtcGxlLmNvbScgfSk7IC8vIFF1ZXJpZXMgYnkgJ3NvbWVlbWFpbEBleGFtcGxlLmNvbSdcbiAqXG4gKiBOb3RlIHRoYXQgYGxvd2VyY2FzZWAgZG9lcyAqKm5vdCoqIGFmZmVjdCByZWd1bGFyIGV4cHJlc3Npb24gcXVlcmllczpcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFN0aWxsIHF1ZXJpZXMgZm9yIGRvY3VtZW50cyB3aG9zZSBgZW1haWxgIG1hdGNoZXMgdGhlIHJlZ3VsYXJcbiAqICAgICAvLyBleHByZXNzaW9uIC9Tb21lRW1haWwvLiBNb25nb29zZSBkb2VzICoqbm90KiogY29udmVydCB0aGUgUmVnRXhwXG4gKiAgICAgLy8gdG8gbG93ZXJjYXNlLlxuICogICAgIE0uZmluZCh7IGVtYWlsOiAvU29tZUVtYWlsLyB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUubG93ZXJjYXNlID0gZnVuY3Rpb24oc2hvdWxkQXBwbHkpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmICFzaG91bGRBcHBseSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJldHVybiB0aGlzLnNldCh2ID0+IHtcbiAgICBpZiAodHlwZW9mIHYgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gdGhpcy5jYXN0KHYpO1xuICAgIH1cbiAgICBpZiAodikge1xuICAgICAgcmV0dXJuIHYudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIHVwcGVyY2FzZSBbc2V0dGVyXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXR5cGUuaHRtbCNTY2hlbWFUeXBlLnByb3RvdHlwZS5zZXQoKSkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGNhcHM6IHsgdHlwZTogU3RyaW5nLCB1cHBlcmNhc2U6IHRydWUgfX0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcyk7XG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgY2FwczogJ2FuIGV4YW1wbGUnIH0pO1xuICogICAgIGNvbnNvbGUubG9nKG0uY2FwcykgLy8gQU4gRVhBTVBMRVxuICogICAgIE0uZmluZCh7IGNhcHM6ICdhbiBleGFtcGxlJyB9KSAvLyBNYXRjaGVzIGRvY3VtZW50cyB3aGVyZSBjYXBzID0gJ0FOIEVYQU1QTEUnXG4gKlxuICogTm90ZSB0aGF0IGB1cHBlcmNhc2VgIGRvZXMgKipub3QqKiBhZmZlY3QgcmVndWxhciBleHByZXNzaW9uIHF1ZXJpZXM6XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNb25nb29zZSBkb2VzICoqbm90KiogY29udmVydCB0aGUgUmVnRXhwIHRvIHVwcGVyY2FzZS5cbiAqICAgICBNLmZpbmQoeyBlbWFpbDogL2FuIGV4YW1wbGUvIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS51cHBlcmNhc2UgPSBmdW5jdGlvbihzaG91bGRBcHBseSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgIXNob3VsZEFwcGx5KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc2V0KHYgPT4ge1xuICAgIGlmICh0eXBlb2YgdiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHYgPSB0aGlzLmNhc3Qodik7XG4gICAgfVxuICAgIGlmICh2KSB7XG4gICAgICByZXR1cm4gdi50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSB0cmltIFtzZXR0ZXJdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hdHlwZS5odG1sI1NjaGVtYVR5cGUucHJvdG90eXBlLnNldCgpKS5cbiAqXG4gKiBUaGUgc3RyaW5nIHZhbHVlIHdpbGwgYmUgW3RyaW1tZWRdKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cmltLXN0cmluZykgd2hlbiBzZXQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCB0cmltOiB0cnVlIH19KTtcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKTtcbiAqICAgICBjb25zdCBzdHJpbmcgPSAnIHNvbWUgbmFtZSAnO1xuICogICAgIGNvbnNvbGUubG9nKHN0cmluZy5sZW5ndGgpOyAvLyAxMVxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IG5hbWU6IHN0cmluZyB9KTtcbiAqICAgICBjb25zb2xlLmxvZyhtLm5hbWUubGVuZ3RoKTsgLy8gOVxuICpcbiAqICAgICAvLyBFcXVpdmFsZW50IHRvIGBmaW5kT25lKHsgbmFtZTogc3RyaW5nLnRyaW0oKSB9KWBcbiAqICAgICBNLmZpbmRPbmUoeyBuYW1lOiBzdHJpbmcgfSk7XG4gKlxuICogTm90ZSB0aGF0IGB0cmltYCBkb2VzICoqbm90KiogYWZmZWN0IHJlZ3VsYXIgZXhwcmVzc2lvbiBxdWVyaWVzOlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTW9uZ29vc2UgZG9lcyAqKm5vdCoqIHRyaW0gd2hpdGVzcGFjZSBmcm9tIHRoZSBSZWdFeHAuXG4gKiAgICAgTS5maW5kKHsgbmFtZTogLyBzb21lIG5hbWUgLyB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKHNob3VsZFRyaW0pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmICFzaG91bGRUcmltKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc2V0KHYgPT4ge1xuICAgIGlmICh0eXBlb2YgdiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHYgPSB0aGlzLmNhc3Qodik7XG4gICAgfVxuICAgIGlmICh2KSB7XG4gICAgICByZXR1cm4gdi50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9KTtcbn07XG5cbi8qKlxuICogU2V0cyBhIG1pbmltdW0gbGVuZ3RoIHZhbGlkYXRvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBwb3N0YWxDb2RlOiB7IHR5cGU6IFN0cmluZywgbWlubGVuZ3RoOiA1IH0pXG4gKiAgICAgY29uc3QgQWRkcmVzcyA9IGRiLm1vZGVsKCdBZGRyZXNzJywgc2NoZW1hKVxuICogICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgQWRkcmVzcyh7IHBvc3RhbENvZGU6ICc5NTEyJyB9KVxuICogICAgIGFkZHJlc3Muc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKGVycikgLy8gdmFsaWRhdG9yIGVycm9yXG4gKiAgICAgICBhZGRyZXNzLnBvc3RhbENvZGUgPSAnOTUxMjUnO1xuICogICAgICAgYWRkcmVzcy5zYXZlKCkgLy8gc3VjY2Vzc1xuICogICAgIH0pXG4gKlxuICogICAgIC8vIGN1c3RvbSBlcnJvciBtZXNzYWdlc1xuICogICAgIC8vIFdlIGNhbiBhbHNvIHVzZSB0aGUgc3BlY2lhbCB7TUlOTEVOR1RIfSB0b2tlbiB3aGljaCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIG1pbmltdW0gYWxsb3dlZCBsZW5ndGhcbiAqICAgICBjb25zdCBtaW5sZW5ndGggPSBbNSwgJ1RoZSB2YWx1ZSBvZiBwYXRoIGB7UEFUSH1gIChge1ZBTFVFfWApIGlzIHNob3J0ZXIgdGhhbiB0aGUgbWluaW11bSBhbGxvd2VkIGxlbmd0aCAoe01JTkxFTkdUSH0pLiddO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBwb3N0YWxDb2RlOiB7IHR5cGU6IFN0cmluZywgbWlubGVuZ3RoOiBtaW5sZW5ndGggfSlcbiAqICAgICBjb25zdCBBZGRyZXNzID0gbW9uZ29vc2UubW9kZWwoJ0FkZHJlc3MnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgQWRkcmVzcyh7IHBvc3RhbENvZGU6ICc5NTEyJyB9KTtcbiAqICAgICBhZGRyZXNzLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IFRoZSB2YWx1ZSBvZiBwYXRoIGBwb3N0YWxDb2RlYCAoYDk1MTJgKSBpcyBzaG9ydGVyIHRoYW4gdGhlIG1pbmltdW0gbGVuZ3RoICg1KS5cbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBtaW5pbXVtIHN0cmluZyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5taW5sZW5ndGggPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5taW5sZW5ndGhWYWxpZGF0b3IpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvciAhPT0gdGhpcy5taW5sZW5ndGhWYWxpZGF0b3I7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBtc2cgPSBtZXNzYWdlIHx8IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuU3RyaW5nLm1pbmxlbmd0aDtcbiAgICBtc2cgPSBtc2cucmVwbGFjZSgve01JTkxFTkdUSH0vLCB2YWx1ZSk7XG4gICAgdGhpcy52YWxpZGF0b3JzLnB1c2goe1xuICAgICAgdmFsaWRhdG9yOiB0aGlzLm1pbmxlbmd0aFZhbGlkYXRvciA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgPT09IG51bGwgfHwgdi5sZW5ndGggPj0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgdHlwZTogJ21pbmxlbmd0aCcsXG4gICAgICBtaW5sZW5ndGg6IHZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUubWluTGVuZ3RoID0gU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5taW5sZW5ndGg7XG5cbi8qKlxuICogU2V0cyBhIG1heGltdW0gbGVuZ3RoIHZhbGlkYXRvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBwb3N0YWxDb2RlOiB7IHR5cGU6IFN0cmluZywgbWF4bGVuZ3RoOiA5IH0pXG4gKiAgICAgY29uc3QgQWRkcmVzcyA9IGRiLm1vZGVsKCdBZGRyZXNzJywgc2NoZW1hKVxuICogICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgQWRkcmVzcyh7IHBvc3RhbENvZGU6ICc5NTEyNTEyMzQ1JyB9KVxuICogICAgIGFkZHJlc3Muc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKGVycikgLy8gdmFsaWRhdG9yIGVycm9yXG4gKiAgICAgICBhZGRyZXNzLnBvc3RhbENvZGUgPSAnOTUxMjUnO1xuICogICAgICAgYWRkcmVzcy5zYXZlKCkgLy8gc3VjY2Vzc1xuICogICAgIH0pXG4gKlxuICogICAgIC8vIGN1c3RvbSBlcnJvciBtZXNzYWdlc1xuICogICAgIC8vIFdlIGNhbiBhbHNvIHVzZSB0aGUgc3BlY2lhbCB7TUFYTEVOR1RIfSB0b2tlbiB3aGljaCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIG1heGltdW0gYWxsb3dlZCBsZW5ndGhcbiAqICAgICBjb25zdCBtYXhsZW5ndGggPSBbOSwgJ1RoZSB2YWx1ZSBvZiBwYXRoIGB7UEFUSH1gIChge1ZBTFVFfWApIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBsZW5ndGggKHtNQVhMRU5HVEh9KS4nXTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgcG9zdGFsQ29kZTogeyB0eXBlOiBTdHJpbmcsIG1heGxlbmd0aDogbWF4bGVuZ3RoIH0pXG4gKiAgICAgY29uc3QgQWRkcmVzcyA9IG1vbmdvb3NlLm1vZGVsKCdBZGRyZXNzJywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBhZGRyZXNzID0gbmV3IEFkZHJlc3MoeyBwb3N0YWxDb2RlOiAnOTUxMjUxMjM0NScgfSk7XG4gKiAgICAgYWRkcmVzcy52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhTdHJpbmcoZXJyKSkgLy8gVmFsaWRhdGlvbkVycm9yOiBUaGUgdmFsdWUgb2YgcGF0aCBgcG9zdGFsQ29kZWAgKGA5NTEyNTEyMzQ1YCkgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIGxlbmd0aCAoOSkuXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIEN1c3RvbWl6ZWQgRXJyb3IgTWVzc2FnZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUubWF4bGVuZ3RoID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMubWF4bGVuZ3RoVmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMubWF4bGVuZ3RoVmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgbXNnID0gbWVzc2FnZSB8fCBNb25nb29zZUVycm9yLm1lc3NhZ2VzLlN0cmluZy5tYXhsZW5ndGg7XG4gICAgbXNnID0gbXNnLnJlcGxhY2UoL3tNQVhMRU5HVEh9LywgdmFsdWUpO1xuICAgIHRoaXMudmFsaWRhdG9ycy5wdXNoKHtcbiAgICAgIHZhbGlkYXRvcjogdGhpcy5tYXhsZW5ndGhWYWxpZGF0b3IgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2ID09PSBudWxsIHx8IHYubGVuZ3RoIDw9IHZhbHVlO1xuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgIHR5cGU6ICdtYXhsZW5ndGgnLFxuICAgICAgbWF4bGVuZ3RoOiB2YWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLm1heExlbmd0aCA9IFNjaGVtYVN0cmluZy5wcm90b3R5cGUubWF4bGVuZ3RoO1xuXG4vKipcbiAqIFNldHMgYSByZWdleHAgdmFsaWRhdG9yLlxuICpcbiAqIEFueSB2YWx1ZSB0aGF0IGRvZXMgbm90IHBhc3MgYHJlZ0V4cGAudGVzdCh2YWwpIHdpbGwgZmFpbCB2YWxpZGF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgbWF0Y2g6IC9eYS8gfX0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcylcbiAqICAgICBjb25zdCBtID0gbmV3IE0oeyBuYW1lOiAnSSBhbSBpbnZhbGlkJyB9KVxuICogICAgIG0udmFsaWRhdGUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5lcnJvcihTdHJpbmcoZXJyKSkgLy8gXCJWYWxpZGF0aW9uRXJyb3I6IFBhdGggYG5hbWVgIGlzIGludmFsaWQgKEkgYW0gaW52YWxpZCkuXCJcbiAqICAgICAgIG0ubmFtZSA9ICdhcHBsZXMnXG4gKiAgICAgICBtLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgICAgYXNzZXJ0Lm9rKGVycikgLy8gc3VjY2Vzc1xuICogICAgICAgfSlcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyB1c2luZyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiAgICAgY29uc3QgbWF0Y2ggPSBbIC9cXC5odG1sJC8sIFwiVGhhdCBmaWxlIGRvZXNuJ3QgZW5kIGluIC5odG1sICh7VkFMVUV9KVwiIF07XG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBmaWxlOiB7IHR5cGU6IFN0cmluZywgbWF0Y2g6IG1hdGNoIH19KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpO1xuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IGZpbGU6ICdpbnZhbGlkJyB9KTtcbiAqICAgICBtLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFN0cmluZyhlcnIpKSAvLyBcIlZhbGlkYXRpb25FcnJvcjogVGhhdCBmaWxlIGRvZXNuJ3QgZW5kIGluIC5odG1sIChpbnZhbGlkKVwiXG4gKiAgICAgfSlcbiAqXG4gKiBFbXB0eSBzdHJpbmdzLCBgdW5kZWZpbmVkYCwgYW5kIGBudWxsYCB2YWx1ZXMgYWx3YXlzIHBhc3MgdGhlIG1hdGNoIHZhbGlkYXRvci4gSWYgeW91IHJlcXVpcmUgdGhlc2UgdmFsdWVzLCBlbmFibGUgdGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yIGFsc28uXG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIG1hdGNoOiAvXmEvLCByZXF1aXJlZDogdHJ1ZSB9fSlcbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnRXhwIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKHJlZ0V4cCwgbWVzc2FnZSkge1xuICAvLyB5ZXMsIHdlIGFsbG93IG11bHRpcGxlIG1hdGNoIHZhbGlkYXRvcnNcblxuICBjb25zdCBtc2cgPSBtZXNzYWdlIHx8IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuU3RyaW5nLm1hdGNoO1xuXG4gIGNvbnN0IG1hdGNoVmFsaWRhdG9yID0gZnVuY3Rpb24odikge1xuICAgIGlmICghcmVnRXhwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSW4gY2FzZSBSZWdFeHAgaGFwcGVucyB0byBoYXZlIGAvZ2AgZmxhZyBzZXQsIHdlIG5lZWQgdG8gcmVzZXQgdGhlXG4gICAgLy8gYGxhc3RJbmRleGAsIG90aGVyd2lzZSBgbWF0Y2hgIHdpbGwgaW50ZXJtaXR0ZW50bHkgZmFpbC5cbiAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcblxuICAgIGNvbnN0IHJldCA9ICgodiAhPSBudWxsICYmIHYgIT09ICcnKVxuICAgICAgPyByZWdFeHAudGVzdCh2KVxuICAgICAgOiB0cnVlKTtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHRoaXMudmFsaWRhdG9ycy5wdXNoKHtcbiAgICB2YWxpZGF0b3I6IG1hdGNoVmFsaWRhdG9yLFxuICAgIG1lc3NhZ2U6IG1zZyxcbiAgICB0eXBlOiAncmVnZXhwJyxcbiAgICByZWdleHA6IHJlZ0V4cFxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgdGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yLiBUaGUgdmFsdWUgaXNcbiAqIGNvbnNpZGVyZWQgdmFsaWQgaWYgaXQgaXMgYSBzdHJpbmcgKHRoYXQgaXMsIG5vdCBgbnVsbGAgb3IgYHVuZGVmaW5lZGApIGFuZFxuICogaGFzIHBvc2l0aXZlIGxlbmd0aC4gVGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yICoqd2lsbCoqIGZhaWwgZm9yIGVtcHR5XG4gKiBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbiBjaGVja1JlcXVpcmVkKHZhbHVlLCBkb2MpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgdHJ1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbDtcbiAgfVxuXG4gIC8vIGByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoKWAgZG9lcyAqKm5vdCoqIGNvcHkgc3RhdGljIHByb3BlcnRpZXMsIGFuZFxuICAvLyBwbHVnaW5zIGxpa2UgbW9uZ29vc2UtZmxvYXQgdXNlIGBpbmhlcml0cygpYCBmb3IgcHJlLUVTNi5cbiAgY29uc3QgX2NoZWNrUmVxdWlyZWQgPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQoKSA6XG4gICAgU2NoZW1hU3RyaW5nLmNoZWNrUmVxdWlyZWQoKTtcblxuICByZXR1cm4gX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBDYXN0cyB0byBTdHJpbmdcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSwgZG9jLCBpbml0KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIGluaXQpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3RSZWYodmFsdWUsIGRvYywgaW5pdCk7XG4gIH1cblxuICBsZXQgY2FzdFN0cmluZztcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0U3RyaW5nID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0U3RyaW5nID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdFN0cmluZyA9IFNjaGVtYVN0cmluZy5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0U3RyaW5nKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdzdHJpbmcnLCB2YWx1ZSwgdGhpcy5wYXRoLCBudWxsLCB0aGlzKTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsLCBjb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbCwgY29udGV4dCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFt0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpXTtcbiAgfVxuICByZXR1cm4gdmFsLm1hcChmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIF90aGlzLmNhc3RGb3JRdWVyeShudWxsLCBtLCBjb250ZXh0KTtcbiAgfSk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlTm9TZXR0ZXJzKHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdE51bGxpc2godmFsKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmNhc3QodmFsLCB0aGlzKTtcbn1cblxuY29uc3QgJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7XG4gIC4uLlNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLFxuICAkYWxsOiBoYW5kbGVBcnJheSxcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZSxcbiAgJG9wdGlvbnM6IGhhbmRsZVNpbmdsZU5vU2V0dGVycyxcbiAgJHJlZ2V4OiBmdW5jdGlvbiBoYW5kbGUkcmVnZXgodmFsKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlU2luZ2xlTm9TZXR0ZXJzLmNhbGwodGhpcywgdmFsKTtcbiAgfSxcbiAgJG5vdDogaGFuZGxlU2luZ2xlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nLnByb3RvdHlwZSwgJyRjb25kaXRpb25hbEhhbmRsZXJzJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICB2YWx1ZTogT2JqZWN0LmZyZWV6ZSgkY29uZGl0aW9uYWxIYW5kbGVycylcbn0pO1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZGl0aW9uYWxcbiAqIEBwYXJhbSB7YW55fSBbdmFsXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZGl0aW9uYWwsIHZhbCwgY29udGV4dCkge1xuICBsZXQgaGFuZGxlcjtcbiAgaWYgKCRjb25kaXRpb25hbCAhPSBudWxsKSB7XG4gICAgaGFuZGxlciA9IHRoaXMuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgJyArICRjb25kaXRpb25hbCArICcgd2l0aCBTdHJpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsLCBjb250ZXh0KTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgfHwgaXNCc29uVHlwZSh2YWwsICdCU09OUmVnRXhwJykpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXBwbHlTZXR0ZXJzKHZhbCwgY29udGV4dCk7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hU3RyaW5nO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/string.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/symbols.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/symbols.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.schemaMixedSymbol = Symbol.for('mongoose:schema_mixed');\n\nexports.builtInMiddleware = Symbol.for('mongoose:built-in-middleware');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIseUJBQXlCOztBQUV6Qix5QkFBeUIiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFxzY2hlbWFcXHN5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnNjaGVtYU1peGVkU3ltYm9sID0gU3ltYm9sLmZvcignbW9uZ29vc2U6c2NoZW1hX21peGVkJyk7XG5cbmV4cG9ydHMuYnVpbHRJbk1pZGRsZXdhcmUgPSBTeW1ib2wuZm9yKCdtb25nb29zZTpidWlsdC1pbi1taWRkbGV3YXJlJyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/symbols.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schema/uuid.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schema/uuid.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseBuffer = __webpack_require__(/*! ../types/buffer */ \"(api)/../server/node_modules/mongoose/lib/types/buffer.js\");\nconst SchemaType = __webpack_require__(/*! ../schematype */ \"(api)/../server/node_modules/mongoose/lib/schematype.js\");\nconst CastError = SchemaType.CastError;\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst handleBitwiseOperator = __webpack_require__(/*! ./operators/bitwise */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/bitwise.js\");\n\nconst UUID_FORMAT = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i;\nconst Binary = MongooseBuffer.Binary;\n\n/**\n * Helper function to convert the input hex-string to a buffer\n * @param {String} hex The hex string to convert\n * @returns {Buffer} The hex as buffer\n * @api private\n */\n\nfunction hex2buffer(hex) {\n  // use buffer built-in function to convert from hex-string to buffer\n  const buff = hex != null && Buffer.from(hex, 'hex');\n  return buff;\n}\n\n/**\n * Helper function to convert the buffer input to a string\n * @param {Buffer} buf The buffer to convert to a hex-string\n * @returns {String} The buffer as a hex-string\n * @api private\n */\n\nfunction binary2hex(buf) {\n  // use buffer built-in function to convert from buffer to hex-string\n  const hex = buf != null && buf.toString('hex');\n  return hex;\n}\n\n/**\n * Convert a String to Binary\n * @param {String} uuidStr The value to process\n * @returns {MongooseBuffer} The binary to store\n * @api private\n */\n\nfunction stringToBinary(uuidStr) {\n  // Protect against undefined & throwing err\n  if (typeof uuidStr !== 'string') uuidStr = '';\n  const hex = uuidStr.replace(/[{}-]/g, ''); // remove extra characters\n  const bytes = hex2buffer(hex);\n  const buff = new MongooseBuffer(bytes);\n  buff._subtype = 4;\n\n  return buff;\n}\n\n/**\n * Convert binary to a uuid string\n * @param {Buffer|Binary|String} uuidBin The value to process\n * @returns {String} The completed uuid-string\n * @api private\n */\nfunction binaryToString(uuidBin) {\n  // i(hasezoey) dont quite know why, but \"uuidBin\" may sometimes also be the already processed string\n  let hex;\n  if (typeof uuidBin !== 'string' && uuidBin != null) {\n    hex = binary2hex(uuidBin);\n    const uuidStr = hex.substring(0, 8) + '-' + hex.substring(8, 8 + 4) + '-' + hex.substring(12, 12 + 4) + '-' + hex.substring(16, 16 + 4) + '-' + hex.substring(20, 20 + 12);\n    return uuidStr;\n  }\n  return uuidBin;\n}\n\n/**\n * UUIDv1 SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaUUID(key, options) {\n  SchemaType.call(this, key, options, 'UUID');\n  this.getters.push(function(value) {\n    // For populated\n    if (value != null && value.$__ != null) {\n      return value;\n    }\n    return binaryToString(value);\n  });\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaUUID.schemaName = 'UUID';\n\nSchemaUUID.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaUUID.prototype = Object.create(SchemaType.prototype);\nSchemaUUID.prototype.constructor = SchemaUUID;\n\n/*!\n * ignore\n */\n\nSchemaUUID._cast = function(value) {\n  if (value == null) {\n    return value;\n  }\n\n  function newBuffer(initbuff) {\n    const buff = new MongooseBuffer(initbuff);\n    buff._subtype = 4;\n    return buff;\n  }\n\n  if (typeof value === 'string') {\n    if (UUID_FORMAT.test(value)) {\n      return stringToBinary(value);\n    } else {\n      throw new CastError(SchemaUUID.schemaName, value, this.path);\n    }\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return newBuffer(value);\n  }\n\n  if (value instanceof Binary) {\n    return newBuffer(value.value(true));\n  }\n\n  // Re: gh-647 and gh-3030, we're ok with casting using `toString()`\n  // **unless** its the default Object.toString, because \"[object Object]\"\n  // doesn't really qualify as useful data\n  if (value.toString && value.toString !== Object.prototype.toString) {\n    if (UUID_FORMAT.test(value.toString())) {\n      return stringToBinary(value.toString());\n    }\n  }\n\n  throw new CastError(SchemaUUID.schemaName, value, this.path);\n};\n\n/**\n * Attaches a getter for all UUID instances.\n *\n * #### Example:\n *\n *     // Note that `v` is a string by default\n *     mongoose.Schema.UUID.get(v => v.toUpperCase());\n *\n *     const Model = mongoose.model('Test', new Schema({ test: 'UUID' }));\n *     new Model({ test: uuid.v4() }).test; // UUID with all uppercase\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaUUID.get = SchemaType.get;\n\n/**\n * Sets a default option for all UUID instances.\n *\n * #### Example:\n *\n *     // Make all UUIDs have `required` of true by default.\n *     mongoose.Schema.UUID.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.UUID }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaUUID.set = SchemaType.set;\n\nSchemaUUID.setters = [];\n\n/**\n * Get/set the function used to cast arbitrary values to UUIDs.\n *\n * #### Example:\n *\n *     // Make Mongoose refuse to cast UUIDs with 0 length\n *     const original = mongoose.Schema.Types.UUID.cast();\n *     mongoose.UUID.cast(v => {\n *       assert.ok(typeof v === \"string\" && v.length > 0);\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.UUID.cast(false);\n *\n * @param {Function} [caster]\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaUUID.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaUUID._checkRequired = v => v != null;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaUUID.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaUUID.prototype.checkRequired = function checkRequired(value) {\n  if (Buffer.isBuffer(value)) {\n    value = binaryToString(value);\n  }\n  return value != null && UUID_FORMAT.test(value);\n};\n\n/**\n * Casts to UUID\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaUUID.prototype.cast = function(value, doc, init) {\n  if (utils.isNonBuiltinObject(value) &&\n      SchemaType._isRef(this, value, doc, init)) {\n    return this._castRef(value, doc, init);\n  }\n\n  let castFn;\n  if (typeof this._castFunction === 'function') {\n    castFn = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castFn = this.constructor.cast();\n  } else {\n    castFn = SchemaUUID.cast();\n  }\n\n  try {\n    return castFn(value);\n  } catch (error) {\n    throw new CastError(SchemaUUID.schemaName, value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val) {\n  return val.map((m) => {\n    return this.cast(m);\n  });\n}\n\nSchemaUUID.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $all: handleArray,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $in: handleArray,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $ne: handleSingle,\n  $nin: handleArray\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaUUID.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler)\n      throw new Error('Can\\'t use ' + $conditional + ' with UUID.');\n    return handler.call(this, val, context);\n  } else {\n    return this.cast(val);\n  }\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaUUID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL3V1aWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHVCQUF1QixtQkFBTyxDQUFDLGtGQUFpQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBZTtBQUMxQztBQUNBLGNBQWMsbUJBQU8sQ0FBQyxvRUFBVTtBQUNoQyw4QkFBOEIsbUJBQU8sQ0FBQyxrR0FBcUI7O0FBRTNELDhCQUE4QixFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxHQUFHO0FBQzVGOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsY0FBYztBQUN2RSxtQkFBbUIsaUJBQWlCLFFBQVE7QUFDNUM7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHNjaGVtYVxcdXVpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUJ1ZmZlciA9IHJlcXVpcmUoJy4uL3R5cGVzL2J1ZmZlcicpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYXR5cGUnKTtcbmNvbnN0IENhc3RFcnJvciA9IFNjaGVtYVR5cGUuQ2FzdEVycm9yO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgaGFuZGxlQml0d2lzZU9wZXJhdG9yID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvYml0d2lzZScpO1xuXG5jb25zdCBVVUlEX0ZPUk1BVCA9IC9bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfS9pO1xuY29uc3QgQmluYXJ5ID0gTW9uZ29vc2VCdWZmZXIuQmluYXJ5O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IHRoZSBpbnB1dCBoZXgtc3RyaW5nIHRvIGEgYnVmZmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4IFRoZSBoZXggc3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFRoZSBoZXggYXMgYnVmZmVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBoZXgyYnVmZmVyKGhleCkge1xuICAvLyB1c2UgYnVmZmVyIGJ1aWx0LWluIGZ1bmN0aW9uIHRvIGNvbnZlcnQgZnJvbSBoZXgtc3RyaW5nIHRvIGJ1ZmZlclxuICBjb25zdCBidWZmID0gaGV4ICE9IG51bGwgJiYgQnVmZmVyLmZyb20oaGV4LCAnaGV4Jyk7XG4gIHJldHVybiBidWZmO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IHRoZSBidWZmZXIgaW5wdXQgdG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjb252ZXJ0IHRvIGEgaGV4LXN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gVGhlIGJ1ZmZlciBhcyBhIGhleC1zdHJpbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGJpbmFyeTJoZXgoYnVmKSB7XG4gIC8vIHVzZSBidWZmZXIgYnVpbHQtaW4gZnVuY3Rpb24gdG8gY29udmVydCBmcm9tIGJ1ZmZlciB0byBoZXgtc3RyaW5nXG4gIGNvbnN0IGhleCA9IGJ1ZiAhPSBudWxsICYmIGJ1Zi50b1N0cmluZygnaGV4Jyk7XG4gIHJldHVybiBoZXg7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFN0cmluZyB0byBCaW5hcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSB1dWlkU3RyIFRoZSB2YWx1ZSB0byBwcm9jZXNzXG4gKiBAcmV0dXJucyB7TW9uZ29vc2VCdWZmZXJ9IFRoZSBiaW5hcnkgdG8gc3RvcmVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvQmluYXJ5KHV1aWRTdHIpIHtcbiAgLy8gUHJvdGVjdCBhZ2FpbnN0IHVuZGVmaW5lZCAmIHRocm93aW5nIGVyclxuICBpZiAodHlwZW9mIHV1aWRTdHIgIT09ICdzdHJpbmcnKSB1dWlkU3RyID0gJyc7XG4gIGNvbnN0IGhleCA9IHV1aWRTdHIucmVwbGFjZSgvW3t9LV0vZywgJycpOyAvLyByZW1vdmUgZXh0cmEgY2hhcmFjdGVyc1xuICBjb25zdCBieXRlcyA9IGhleDJidWZmZXIoaGV4KTtcbiAgY29uc3QgYnVmZiA9IG5ldyBNb25nb29zZUJ1ZmZlcihieXRlcyk7XG4gIGJ1ZmYuX3N1YnR5cGUgPSA0O1xuXG4gIHJldHVybiBidWZmO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYmluYXJ5IHRvIGEgdXVpZCBzdHJpbmdcbiAqIEBwYXJhbSB7QnVmZmVyfEJpbmFyeXxTdHJpbmd9IHV1aWRCaW4gVGhlIHZhbHVlIHRvIHByb2Nlc3NcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBjb21wbGV0ZWQgdXVpZC1zdHJpbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBiaW5hcnlUb1N0cmluZyh1dWlkQmluKSB7XG4gIC8vIGkoaGFzZXpvZXkpIGRvbnQgcXVpdGUga25vdyB3aHksIGJ1dCBcInV1aWRCaW5cIiBtYXkgc29tZXRpbWVzIGFsc28gYmUgdGhlIGFscmVhZHkgcHJvY2Vzc2VkIHN0cmluZ1xuICBsZXQgaGV4O1xuICBpZiAodHlwZW9mIHV1aWRCaW4gIT09ICdzdHJpbmcnICYmIHV1aWRCaW4gIT0gbnVsbCkge1xuICAgIGhleCA9IGJpbmFyeTJoZXgodXVpZEJpbik7XG4gICAgY29uc3QgdXVpZFN0ciA9IGhleC5zdWJzdHJpbmcoMCwgOCkgKyAnLScgKyBoZXguc3Vic3RyaW5nKDgsIDggKyA0KSArICctJyArIGhleC5zdWJzdHJpbmcoMTIsIDEyICsgNCkgKyAnLScgKyBoZXguc3Vic3RyaW5nKDE2LCAxNiArIDQpICsgJy0nICsgaGV4LnN1YnN0cmluZygyMCwgMjAgKyAxMik7XG4gICAgcmV0dXJuIHV1aWRTdHI7XG4gIH1cbiAgcmV0dXJuIHV1aWRCaW47XG59XG5cbi8qKlxuICogVVVJRHYxIFNjaGVtYVR5cGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYVVVSUQoa2V5LCBvcHRpb25zKSB7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdVVUlEJyk7XG4gIHRoaXMuZ2V0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gRm9yIHBvcHVsYXRlZFxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLiRfXyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBiaW5hcnlUb1N0cmluZyh2YWx1ZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYVVVSUQuc2NoZW1hTmFtZSA9ICdVVUlEJztcblxuU2NoZW1hVVVJRC5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuU2NoZW1hVVVJRC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYVVVSUQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hVVVJRDtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFVVUlELl9jYXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBuZXdCdWZmZXIoaW5pdGJ1ZmYpIHtcbiAgICBjb25zdCBidWZmID0gbmV3IE1vbmdvb3NlQnVmZmVyKGluaXRidWZmKTtcbiAgICBidWZmLl9zdWJ0eXBlID0gNDtcbiAgICByZXR1cm4gYnVmZjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKFVVSURfRk9STUFULnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc3RyaW5nVG9CaW5hcnkodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKFNjaGVtYVVVSUQuc2NoZW1hTmFtZSwgdmFsdWUsIHRoaXMucGF0aCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3QnVmZmVyKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpbmFyeSkge1xuICAgIHJldHVybiBuZXdCdWZmZXIodmFsdWUudmFsdWUodHJ1ZSkpO1xuICB9XG5cbiAgLy8gUmU6IGdoLTY0NyBhbmQgZ2gtMzAzMCwgd2UncmUgb2sgd2l0aCBjYXN0aW5nIHVzaW5nIGB0b1N0cmluZygpYFxuICAvLyAqKnVubGVzcyoqIGl0cyB0aGUgZGVmYXVsdCBPYmplY3QudG9TdHJpbmcsIGJlY2F1c2UgXCJbb2JqZWN0IE9iamVjdF1cIlxuICAvLyBkb2Vzbid0IHJlYWxseSBxdWFsaWZ5IGFzIHVzZWZ1bCBkYXRhXG4gIGlmICh2YWx1ZS50b1N0cmluZyAmJiB2YWx1ZS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuICAgIGlmIChVVUlEX0ZPUk1BVC50ZXN0KHZhbHVlLnRvU3RyaW5nKCkpKSB7XG4gICAgICByZXR1cm4gc3RyaW5nVG9CaW5hcnkodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IENhc3RFcnJvcihTY2hlbWFVVUlELnNjaGVtYU5hbWUsIHZhbHVlLCB0aGlzLnBhdGgpO1xufTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIFVVSUQgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTm90ZSB0aGF0IGB2YCBpcyBhIHN0cmluZyBieSBkZWZhdWx0XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlVVSUQuZ2V0KHYgPT4gdi50b1VwcGVyQ2FzZSgpKTtcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoeyB0ZXN0OiAnVVVJRCcgfSkpO1xuICogICAgIG5ldyBNb2RlbCh7IHRlc3Q6IHV1aWQudjQoKSB9KS50ZXN0OyAvLyBVVUlEIHdpdGggYWxsIHVwcGVyY2FzZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVVVJRC5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBVVUlEIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIFVVSURzIGhhdmUgYHJlcXVpcmVkYCBvZiB0cnVlIGJ5IGRlZmF1bHQuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlVVSUQuc2V0KCdyZXF1aXJlZCcsIHRydWUpO1xuICpcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgdGVzdDogbW9uZ29vc2UuVVVJRCB9KSk7XG4gKiAgICAgbmV3IFVzZXIoeyB9KS52YWxpZGF0ZVN5bmMoKS5lcnJvcnMudGVzdC5tZXNzYWdlOyAvLyBQYXRoIGB0ZXN0YCBpcyByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVVVJRC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hVVVJRC5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gVVVJRHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIE1vbmdvb3NlIHJlZnVzZSB0byBjYXN0IFVVSURzIHdpdGggMCBsZW5ndGhcbiAqICAgICBjb25zdCBvcmlnaW5hbCA9IG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5VVUlELmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5VVUlELmNhc3QodiA9PiB7XG4gKiAgICAgICBhc3NlcnQub2sodHlwZW9mIHYgPT09IFwic3RyaW5nXCIgJiYgdi5sZW5ndGggPiAwKTtcbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuVVVJRC5jYXN0KGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FzdGVyXVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVVVSUQuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVVVSUQuX2NoZWNrUmVxdWlyZWQgPSB2ID0+IHYgIT0gbnVsbDtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmdcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFVVUlELmNoZWNrUmVxdWlyZWQgPSBTY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyBhIHJlcXVpcmVkIHZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVVVSUQucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbiBjaGVja1JlcXVpcmVkKHZhbHVlKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBiaW5hcnlUb1N0cmluZyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgVVVJRF9GT1JNQVQudGVzdCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIENhc3RzIHRvIFVVSURcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdCB3aGV0aGVyIHRoaXMgaXMgYW4gaW5pdGlhbGl6YXRpb24gY2FzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVVVJRC5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgaWYgKHV0aWxzLmlzTm9uQnVpbHRpbk9iamVjdCh2YWx1ZSkgJiZcbiAgICAgIFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIGluaXQpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3RSZWYodmFsdWUsIGRvYywgaW5pdCk7XG4gIH1cblxuICBsZXQgY2FzdEZuO1xuICBpZiAodHlwZW9mIHRoaXMuX2Nhc3RGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3RGbiA9IHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdEZuID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdEZuID0gU2NoZW1hVVVJRC5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0Rm4odmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBDYXN0RXJyb3IoU2NoZW1hVVVJRC5zY2hlbWFOYW1lLCB2YWx1ZSwgdGhpcy5wYXRoLCBlcnJvciwgdGhpcyk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHZhbCkge1xuICByZXR1cm4gdGhpcy5jYXN0KHZhbCk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsKSB7XG4gIHJldHVybiB2YWwubWFwKChtKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2FzdChtKTtcbiAgfSk7XG59XG5cblNjaGVtYVVVSUQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzID0ge1xuICAuLi5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyxcbiAgJGJpdHNBbGxDbGVhcjogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAkYml0c0FueUNsZWFyOiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRiaXRzQWxsU2V0OiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRiaXRzQW55U2V0OiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRhbGw6IGhhbmRsZUFycmF5LFxuICAkZ3Q6IGhhbmRsZVNpbmdsZSxcbiAgJGd0ZTogaGFuZGxlU2luZ2xlLFxuICAkaW46IGhhbmRsZUFycmF5LFxuICAkbHQ6IGhhbmRsZVNpbmdsZSxcbiAgJGx0ZTogaGFuZGxlU2luZ2xlLFxuICAkbmU6IGhhbmRsZVNpbmdsZSxcbiAgJG5pbjogaGFuZGxlQXJyYXlcbn07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kaXRpb25hbFxuICogQHBhcmFtIHthbnl9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVVVJRC5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG4gICAgaWYgKCFoYW5kbGVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHVzZSAnICsgJGNvbmRpdGlvbmFsICsgJyB3aXRoIFVVSUQuJyk7XG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB2YWwsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmNhc3QodmFsKTtcbiAgfVxufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYVVVSUQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schema/uuid.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/schematype.js":
/*!*********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/schematype.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"(api)/../server/node_modules/mongoose/lib/error/index.js\");\nconst SchemaTypeOptions = __webpack_require__(/*! ./options/SchemaTypeOptions */ \"(api)/../server/node_modules/mongoose/lib/options/SchemaTypeOptions.js\");\nconst $exists = __webpack_require__(/*! ./schema/operators/exists */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/exists.js\");\nconst $type = __webpack_require__(/*! ./schema/operators/type */ \"(api)/../server/node_modules/mongoose/lib/schema/operators/type.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst handleImmutable = __webpack_require__(/*! ./helpers/schematype/handleImmutable */ \"(api)/../server/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js\");\nconst isAsyncFunction = __webpack_require__(/*! ./helpers/isAsyncFunction */ \"(api)/../server/node_modules/mongoose/lib/helpers/isAsyncFunction.js\");\nconst isSimpleValidator = __webpack_require__(/*! ./helpers/isSimpleValidator */ \"(api)/../server/node_modules/mongoose/lib/helpers/isSimpleValidator.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst schemaTypeSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").schemaTypeSymbol);\nconst utils = __webpack_require__(/*! ./utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst validatorErrorSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").validatorErrorSymbol);\nconst documentIsModified = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").documentIsModified);\n\nconst populateModelSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\n\nconst CastError = MongooseError.CastError;\nconst ValidatorError = MongooseError.ValidatorError;\n\nconst setOptionsForDefaults = { _skipMarkModified: true };\n\n/**\n * SchemaType constructor. Do **not** instantiate `SchemaType` directly.\n * Mongoose converts your schema paths into SchemaTypes automatically.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name') instanceof SchemaType; // true\n *\n * @param {String} path\n * @param {SchemaTypeOptions} [options] See [SchemaTypeOptions docs](https://mongoosejs.com/docs/api/schematypeoptions.html)\n * @param {String} [instance]\n * @api public\n */\n\nfunction SchemaType(path, options, instance) {\n  this[schemaTypeSymbol] = true;\n  this.path = path;\n  this.instance = instance;\n  this.validators = [];\n  this.getters = this.constructor.hasOwnProperty('getters') ?\n    this.constructor.getters.slice() :\n    [];\n  this.setters = this.constructor.hasOwnProperty('setters') ?\n    this.constructor.setters.slice() :\n    [];\n\n  this.splitPath();\n\n  options = options || {};\n  const defaultOptions = this.constructor.defaultOptions || {};\n  const defaultOptionsKeys = Object.keys(defaultOptions);\n\n  for (const option of defaultOptionsKeys) {\n    if (defaultOptions.hasOwnProperty(option) && !Object.prototype.hasOwnProperty.call(options, option)) {\n      options[option] = defaultOptions[option];\n    }\n  }\n\n  if (options.select == null) {\n    delete options.select;\n  }\n\n  const Options = this.OptionsConstructor || SchemaTypeOptions;\n  this.options = new Options(options);\n  this._index = null;\n\n\n  if (utils.hasUserDefinedProperty(this.options, 'immutable')) {\n    this.$immutable = this.options.immutable;\n\n    handleImmutable(this);\n  }\n\n  const keys = Object.keys(this.options);\n  for (const prop of keys) {\n    if (prop === 'cast') {\n      if (Array.isArray(this.options[prop])) {\n        this.castFunction.apply(this, this.options[prop]);\n      } else {\n        this.castFunction(this.options[prop]);\n      }\n      continue;\n    }\n    if (utils.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === 'function') {\n      // { unique: true, index: true }\n      if (prop === 'index' && this._index) {\n        if (options.index === false) {\n          const index = this._index;\n          if (typeof index === 'object' && index != null) {\n            if (index.unique) {\n              throw new Error('Path \"' + this.path + '\" may not have `index` ' +\n                'set to false and `unique` set to true');\n            }\n            if (index.sparse) {\n              throw new Error('Path \"' + this.path + '\" may not have `index` ' +\n                'set to false and `sparse` set to true');\n            }\n          }\n\n          this._index = false;\n        }\n        continue;\n      }\n\n      const val = options[prop];\n      // Special case so we don't screw up array defaults, see gh-5780\n      if (prop === 'default') {\n        this.default(val);\n        continue;\n      }\n\n      const opts = Array.isArray(val) ? val : [val];\n\n      this[prop].apply(this, opts);\n    }\n  }\n\n  Object.defineProperty(this, '$$context', {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value: null\n  });\n}\n\n/**\n * The class that Mongoose uses internally to instantiate this SchemaType's `options` property.\n * @memberOf SchemaType\n * @instance\n * @api private\n */\n\nSchemaType.prototype.OptionsConstructor = SchemaTypeOptions;\n\n/**\n * The path to this SchemaType in a Schema.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name').path; // 'name'\n *\n * @property path\n * @api public\n * @memberOf SchemaType\n */\n\nSchemaType.prototype.path;\n\n/**\n * The validators that Mongoose should run to validate properties at this SchemaType's path.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, required: true } });\n *     schema.path('name').validators.length; // 1, the `required` validator\n *\n * @property validators\n * @api public\n * @memberOf SchemaType\n */\n\nSchemaType.prototype.validators;\n\n/**\n * True if this SchemaType has a required validator. False otherwise.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, required: true } });\n *     schema.path('name').isRequired; // true\n *\n *     schema.path('name').required(false);\n *     schema.path('name').isRequired; // false\n *\n * @property isRequired\n * @api public\n * @memberOf SchemaType\n */\n\nSchemaType.prototype.isRequired;\n\n/**\n * Split the current dottet path into segments\n *\n * @return {String[]|undefined}\n * @api private\n */\n\nSchemaType.prototype.splitPath = function() {\n  if (this._presplitPath != null) {\n    return this._presplitPath;\n  }\n  if (this.path == null) {\n    return undefined;\n  }\n\n  this._presplitPath = this.path.indexOf('.') === -1 ? [this.path] : this.path.split('.');\n  return this._presplitPath;\n};\n\n/**\n * Get/set the function used to cast arbitrary values to this type.\n *\n * #### Example:\n *\n *     // Disallow `null` for numbers, and don't try to cast any values to\n *     // numbers, so even strings like '123' will cause a CastError.\n *     mongoose.Number.cast(function(v) {\n *       assert.ok(v === undefined || typeof v === 'number');\n *       return v;\n *     });\n *\n * @param {Function|false} caster Function that casts arbitrary values to this type, or throws an error if casting failed\n * @return {Function}\n * @static\n * @memberOf SchemaType\n * @function cast\n * @api public\n */\n\nSchemaType.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = v => v;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/**\n * Get/set the function used to cast arbitrary values to this particular schematype instance.\n * Overrides `SchemaType.cast()`.\n *\n * #### Example:\n *\n *     // Disallow `null` for numbers, and don't try to cast any values to\n *     // numbers, so even strings like '123' will cause a CastError.\n *     const number = new mongoose.Number('mypath', {});\n *     number.cast(function(v) {\n *       assert.ok(v === undefined || typeof v === 'number');\n *       return v;\n *     });\n *\n * @param {Function|false} caster Function that casts arbitrary values to this type, or throws an error if casting failed\n * @return {Function}\n * @memberOf SchemaType\n * @api public\n */\n\nSchemaType.prototype.castFunction = function castFunction(caster, message) {\n  if (arguments.length === 0) {\n    return this._castFunction;\n  }\n\n  if (caster === false) {\n    caster = this.constructor._defaultCaster || (v => v);\n  }\n  if (typeof caster === 'string') {\n    this._castErrorMessage = caster;\n    return this._castFunction;\n  }\n  if (caster != null) {\n    this._castFunction = caster;\n  }\n  if (message != null) {\n    this._castErrorMessage = message;\n  }\n\n  return this._castFunction;\n};\n\n/**\n * The function that Mongoose calls to cast arbitrary values to this SchemaType.\n *\n * @param {Object} value value to cast\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api public\n */\n\nSchemaType.prototype.cast = function cast() {\n  throw new Error('Base SchemaType class does not implement a `cast()` function');\n};\n\n/**\n * Sets a default option for this schema type.\n *\n * #### Example:\n *\n *     // Make all strings be trimmed by default\n *     mongoose.SchemaTypes.String.set('trim', true);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @static\n * @memberOf SchemaType\n * @function set\n * @api public\n */\n\nSchemaType.set = function set(option, value) {\n  if (!this.hasOwnProperty('defaultOptions')) {\n    this.defaultOptions = Object.assign({}, this.defaultOptions);\n  }\n  this.defaultOptions[option] = value;\n};\n\n/**\n * Attaches a getter for all instances of this schema type.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Number.get(function(v) { return Math.floor(v); });\n *\n * @param {Function} getter\n * @return {this}\n * @static\n * @memberOf SchemaType\n * @function get\n * @api public\n */\n\nSchemaType.get = function(getter) {\n  this.getters = this.hasOwnProperty('getters') ? this.getters : [];\n  this.getters.push(getter);\n};\n\n/**\n * Sets a default value for this SchemaType.\n *\n * #### Example:\n *\n *     const schema = new Schema({ n: { type: Number, default: 10 })\n *     const M = db.model('M', schema)\n *     const m = new M;\n *     console.log(m.n) // 10\n *\n * Defaults can be either `functions` which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.\n *\n * #### Example:\n *\n *     // values are cast:\n *     const schema = new Schema({ aNumber: { type: Number, default: 4.815162342 }})\n *     const M = db.model('M', schema)\n *     const m = new M;\n *     console.log(m.aNumber) // 4.815162342\n *\n *     // default unique objects for Mixed types:\n *     const schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default(function () {\n *       return {};\n *     });\n *\n *     // if we don't use a function to return object literals for Mixed defaults,\n *     // each document will receive a reference to the same object literal creating\n *     // a \"shared\" object instance:\n *     const schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default({});\n *     const M = db.model('M', schema);\n *     const m1 = new M;\n *     m1.mixed.added = 1;\n *     console.log(m1.mixed); // { added: 1 }\n *     const m2 = new M;\n *     console.log(m2.mixed); // { added: 1 }\n *\n * @param {Function|any} val The default value to set\n * @return {Any|undefined} Returns the set default value.\n * @api public\n */\n\nSchemaType.prototype.default = function(val) {\n  if (arguments.length === 1) {\n    if (val === void 0) {\n      this.defaultValue = void 0;\n      return void 0;\n    }\n\n    if (val != null && val.instanceOfSchema) {\n      throw new MongooseError('Cannot set default value of path `' + this.path +\n        '` to a mongoose Schema instance.');\n    }\n\n    this.defaultValue = val;\n    return this.defaultValue;\n  } else if (arguments.length > 1) {\n    this.defaultValue = [...arguments];\n  }\n  return this.defaultValue;\n};\n\n/**\n * Declares the index options for this schematype.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, index: true })\n *     const s = new Schema({ name: { type: String, index: -1 })\n *     const s = new Schema({ loc: { type: [Number], index: 'hashed' })\n *     const s = new Schema({ loc: { type: [Number], index: '2d', sparse: true })\n *     const s = new Schema({ loc: { type: [Number], index: { type: '2dsphere', sparse: true }})\n *     const s = new Schema({ date: { type: Date, index: { unique: true, expires: '1d' }})\n *     s.path('my.path').index(true);\n *     s.path('my.date').index({ expires: 60 });\n *     s.path('my.path').index({ unique: true, sparse: true });\n *\n * #### Note:\n *\n * _Indexes are created [in the background](https://www.mongodb.com/docs/manual/core/index-creation/#index-creation-background)\n * by default. If `background` is set to `false`, MongoDB will not execute any\n * read/write operations you send until the index build.\n * Specify `background: false` to override Mongoose's default._\n *\n * @param {Object|Boolean|String|Number} options\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.index = function(options) {\n  this._index = options;\n  utils.expires(this._index);\n  return this;\n};\n\n/**\n * Declares an unique index.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, unique: true } });\n *     s.path('name').index({ unique: true });\n *\n * _NOTE: violating the constraint returns an `E11000` error from MongoDB when saving, not a Mongoose validation error._\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.unique = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `unique` set to true');\n  }\n\n  if (!this.options.hasOwnProperty('index') && bool === false) {\n    return this;\n  }\n\n  if (this._index == null || this._index === true) {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = { type: this._index };\n  }\n\n  this._index.unique = bool;\n  return this;\n};\n\n/**\n * Declares a full text index.\n *\n * ### Example:\n *\n *      const s = new Schema({ name : { type: String, text : true } })\n *      s.path('name').index({ text : true });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.text = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return this;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `text` set to true');\n  }\n\n  if (!this.options.hasOwnProperty('index') && bool === false) {\n    return this;\n  }\n\n  if (this._index === null || this._index === undefined ||\n    typeof this._index === 'boolean') {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = { type: this._index };\n  }\n\n  this._index.text = bool;\n  return this;\n};\n\n/**\n * Declares a sparse index.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, sparse: true } });\n *     s.path('name').index({ sparse: true });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.sparse = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return this;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `sparse` set to true');\n  }\n\n  if (!this.options.hasOwnProperty('index') && bool === false) {\n    return this;\n  }\n\n  if (this._index == null || typeof this._index === 'boolean') {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = { type: this._index };\n  }\n\n  this._index.sparse = bool;\n  return this;\n};\n\n/**\n * Defines this path as immutable. Mongoose prevents you from changing\n * immutable paths unless the parent document has [`isNew: true`](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()).\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       name: { type: String, immutable: true },\n *       age: Number\n *     });\n *     const Model = mongoose.model('Test', schema);\n *\n *     await Model.create({ name: 'test' });\n *     const doc = await Model.findOne();\n *\n *     doc.isNew; // false\n *     doc.name = 'new name';\n *     doc.name; // 'test', because `name` is immutable\n *\n * Mongoose also prevents changing immutable properties using `updateOne()`\n * and `updateMany()` based on [strict mode](https://mongoosejs.com/docs/guide.html#strict).\n *\n * #### Example:\n *\n *     // Mongoose will strip out the `name` update, because `name` is immutable\n *     Model.updateOne({}, { $set: { name: 'test2' }, $inc: { age: 1 } });\n *\n *     // If `strict` is set to 'throw', Mongoose will throw an error if you\n *     // update `name`\n *     const err = await Model.updateOne({}, { name: 'test2' }, { strict: 'throw' }).\n *       then(() => null, err => err);\n *     err.name; // StrictModeError\n *\n *     // If `strict` is `false`, Mongoose allows updating `name` even though\n *     // the property is immutable.\n *     Model.updateOne({}, { name: 'test2' }, { strict: false });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @see isNew https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()\n * @api public\n */\n\nSchemaType.prototype.immutable = function(bool) {\n  this.$immutable = bool;\n  handleImmutable(this);\n\n  return this;\n};\n\n/**\n * Defines a custom function for transforming this path when converting a document to JSON.\n *\n * Mongoose calls this function with one parameter: the current `value` of the path. Mongoose\n * then uses the return value in the JSON output.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       date: { type: Date, transform: v => v.getFullYear() }\n *     });\n *     const Model = mongoose.model('Test', schema);\n *\n *     await Model.create({ date: new Date('2016-06-01') });\n *     const doc = await Model.findOne();\n *\n *     doc.date instanceof Date; // true\n *\n *     doc.toJSON().date; // 2016 as a number\n *     JSON.stringify(doc); // '{\"_id\":...,\"date\":2016}'\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.transform = function(fn) {\n  this.options.transform = fn;\n\n  return this;\n};\n\n/**\n * Adds a setter to this schematype.\n *\n * #### Example:\n *\n *     function capitalize (val) {\n *       if (typeof val !== 'string') val = '';\n *       return val.charAt(0).toUpperCase() + val.substring(1);\n *     }\n *\n *     // defining within the schema\n *     const s = new Schema({ name: { type: String, set: capitalize }});\n *\n *     // or with the SchemaType\n *     const s = new Schema({ name: String })\n *     s.path('name').set(capitalize);\n *\n * Setters allow you to transform the data before it gets to the raw mongodb\n * document or query.\n *\n * Suppose you are implementing user registration for a website. Users provide\n * an email and password, which gets saved to mongodb. The email is a string\n * that you will want to normalize to lower case, in order to avoid one email\n * having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.\n *\n * You can set up email lower case normalization easily via a Mongoose setter.\n *\n *     function toLower(v) {\n *       return v.toLowerCase();\n *     }\n *\n *     const UserSchema = new Schema({\n *       email: { type: String, set: toLower }\n *     });\n *\n *     const User = db.model('User', UserSchema);\n *\n *     const user = new User({email: 'AVENUE@Q.COM'});\n *     console.log(user.email); // 'avenue@q.com'\n *\n *     // or\n *     const user = new User();\n *     user.email = 'Avenue@Q.com';\n *     console.log(user.email); // 'avenue@q.com'\n *     User.updateOne({ _id: _id }, { $set: { email: 'AVENUE@Q.COM' } }); // update to 'avenue@q.com'\n *\n * As you can see above, setters allow you to transform the data before it\n * stored in MongoDB, or before executing a query.\n *\n * _NOTE: we could have also just used the built-in `lowercase: true` SchemaType option instead of defining our own function._\n *\n *     new Schema({ email: { type: String, lowercase: true }})\n *\n * Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, priorValue, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return val;\n *       }\n *     }\n *\n *     const VirusSchema = new Schema({\n *       name: { type: String, required: true, set: inspector },\n *       taxonomy: { type: String, set: inspector }\n *     })\n *\n *     const Virus = db.model('Virus', VirusSchema);\n *     const v = new Virus({ name: 'Parvoviridae', taxonomy: 'Parvovirinae' });\n *\n *     console.log(v.name);     // name is required\n *     console.log(v.taxonomy); // Parvovirinae\n *\n * You can also use setters to modify other properties on the document. If\n * you're setting a property `name` on a document, the setter will run with\n * `this` as the document. Be careful, in mongoose 5 setters will also run\n * when querying by `name` with `this` as the query.\n *\n *     const nameSchema = new Schema({ name: String, keywords: [String] });\n *     nameSchema.path('name').set(function(v) {\n *       // Need to check if `this` is a document, because in mongoose 5\n *       // setters will also run on queries, in which case `this` will be a\n *       // mongoose query object.\n *       if (this instanceof Document && v != null) {\n *         this.keywords = v.split(' ');\n *       }\n *       return v;\n *     });\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.set = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('A setter must be a function.');\n  }\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Adds a getter to this schematype.\n *\n * #### Example:\n *\n *     function dob (val) {\n *       if (!val) return val;\n *       return (val.getMonth() + 1) + \"/\" + val.getDate() + \"/\" + val.getFullYear();\n *     }\n *\n *     // defining within the schema\n *     const s = new Schema({ born: { type: Date, get: dob })\n *\n *     // or by retreiving its SchemaType\n *     const s = new Schema({ born: Date })\n *     s.path('born').get(dob)\n *\n * Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.\n *\n * Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:\n *\n *     function obfuscate (cc) {\n *       return '****-****-****-' + cc.slice(cc.length-4, cc.length);\n *     }\n *\n *     const AccountSchema = new Schema({\n *       creditCardNumber: { type: String, get: obfuscate }\n *     });\n *\n *     const Account = db.model('Account', AccountSchema);\n *\n *     Account.findById(id, function (err, found) {\n *       console.log(found.creditCardNumber); // '****-****-****-1234'\n *     });\n *\n * Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, priorValue, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return schematype.path + ' is not';\n *       }\n *     }\n *\n *     const VirusSchema = new Schema({\n *       name: { type: String, required: true, get: inspector },\n *       taxonomy: { type: String, get: inspector }\n *     })\n *\n *     const Virus = db.model('Virus', VirusSchema);\n *\n *     Virus.findById(id, function (err, virus) {\n *       console.log(virus.name);     // name is required\n *       console.log(virus.taxonomy); // taxonomy is not\n *     })\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.get = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('A getter must be a function.');\n  }\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Adds validator(s) for this document path.\n *\n * Validators always receive the value to validate as their first argument and\n * must return `Boolean`. Returning `false` or throwing an error means\n * validation failed.\n *\n * The error message argument is optional. If not passed, the [default generic error message template](https://mongoosejs.com/docs/api/error.html#Error.messages) will be used.\n *\n * #### Example:\n *\n *     // make sure every value is equal to \"something\"\n *     function validator (val) {\n *       return val === 'something';\n *     }\n *     new Schema({ name: { type: String, validate: validator }});\n *\n *     // with a custom error message\n *\n *     const custom = [validator, 'Uh oh, {PATH} does not equal \"something\".']\n *     new Schema({ name: { type: String, validate: custom }});\n *\n *     // adding many validators at a time\n *\n *     const many = [\n *         { validator: validator, message: 'uh oh' }\n *       , { validator: anotherValidator, message: 'failed' }\n *     ]\n *     new Schema({ name: { type: String, validate: many }});\n *\n *     // or utilizing SchemaType methods directly:\n *\n *     const schema = new Schema({ name: 'string' });\n *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');\n *\n * #### Error message templates:\n *\n * Below is a list of supported template keywords:\n *\n * - PATH: The schema path where the error is being triggered.\n * - VALUE: The value assigned to the PATH that is triggering the error.\n * - KIND: The validation property that triggered the error i.e. required.\n * - REASON: The error object that caused this error if there was one.\n *\n * If Mongoose's built-in error message templating isn't enough, Mongoose\n * supports setting the `message` property to a function.\n *\n *     schema.path('name').validate({\n *       validator: function(v) { return v.length > 5; },\n *       // `errors['name']` will be \"name must have length 5, got 'foo'\"\n *       message: function(props) {\n *         return `${props.path} must have length 5, got '${props.value}'`;\n *       }\n *     });\n *\n * To bypass Mongoose's error messages and just copy the error message that\n * the validator throws, do this:\n *\n *     schema.path('name').validate({\n *       validator: function() { throw new Error('Oops!'); },\n *       // `errors['name']` will be \"Oops!\"\n *       message: function(props) { return props.reason.message; }\n *     });\n *\n * #### Asynchronous validation:\n *\n * Mongoose supports validators that return a promise. A validator that returns\n * a promise is called an _async validator_. Async validators run in\n * parallel, and `validate()` will wait until all async validators have settled.\n *\n *     schema.path('name').validate({\n *       validator: function (value) {\n *         return new Promise(function (resolve, reject) {\n *           resolve(false); // validation failed\n *         });\n *       }\n *     });\n *\n * You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.\n *\n * Validation occurs `pre('save')` or whenever you manually execute [document#validate](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()).\n *\n * If validation fails during `pre('save')` and no callback was passed to receive the error, an `error` event will be emitted on your Models associated db [connection](https://mongoosejs.com/docs/api/connection.html#Connection()), passing the validation error object along.\n *\n *     const conn = mongoose.createConnection(..);\n *     conn.on('error', handleError);\n *\n *     const Product = conn.model('Product', yourSchema);\n *     const dvd = new Product(..);\n *     dvd.save(); // emits error on the `conn` above\n *\n * If you want to handle these errors at the Model level, add an `error`\n * listener to your Model as shown below.\n *\n *     // registering an error listener on the Model lets us handle errors more locally\n *     Product.on('error', handleError);\n *\n * @param {RegExp|Function|Object} obj validator function, or hash describing options\n * @param {Function} [obj.validator] validator function. If the validator function returns `undefined` or a truthy value, validation succeeds. If it returns [falsy](https://masteringjs.io/tutorials/fundamentals/falsy) (except `undefined`) or throws an error, validation fails.\n * @param {String|Function} [obj.message] optional error message. If function, should return the error message as a string\n * @param {Boolean} [obj.propsParameter=false] If true, Mongoose will pass the validator properties object (with the `validator` function, `message`, etc.) as the 2nd arg to the validator function. This is disabled by default because many validators [rely on positional args](https://github.com/chriso/validator.js#validators), so turning this on may cause unpredictable behavior in external validators.\n * @param {String|Function} [errorMsg] optional error message. If function, should return the error message as a string\n * @param {String} [type] optional validator type\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.validate = function(obj, message, type) {\n  if (typeof obj === 'function' || obj && utils.getFunctionName(obj.constructor) === 'RegExp') {\n    let properties;\n    if (typeof message === 'function') {\n      properties = { validator: obj, message: message };\n      properties.type = type || 'user defined';\n    } else if (message instanceof Object && !type) {\n      properties = isSimpleValidator(message) ? Object.assign({}, message) : clone(message);\n      if (!properties.message) {\n        properties.message = properties.msg;\n      }\n      properties.validator = obj;\n      properties.type = properties.type || 'user defined';\n    } else {\n      if (message == null) {\n        message = MongooseError.messages.general.default;\n      }\n      if (!type) {\n        type = 'user defined';\n      }\n      properties = { message: message, type: type, validator: obj };\n    }\n\n    this.validators.push(properties);\n    return this;\n  }\n\n  let i;\n  let length;\n  let arg;\n\n  for (i = 0, length = arguments.length; i < length; i++) {\n    arg = arguments[i];\n    if (!utils.isPOJO(arg)) {\n      const msg = 'Invalid validator. Received (' + typeof arg + ') '\n        + arg\n        + '. See https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.validate()';\n\n      throw new Error(msg);\n    }\n    this.validate(arg.validator, arg);\n  }\n\n  return this;\n};\n\n/**\n * Adds a required validator to this SchemaType. The validator gets added\n * to the front of this SchemaType's validators array using `unshift()`.\n *\n * #### Example:\n *\n *     const s = new Schema({ born: { type: Date, required: true })\n *\n *     // or with custom error message\n *\n *     const s = new Schema({ born: { type: Date, required: '{PATH} is required!' })\n *\n *     // or with a function\n *\n *     const s = new Schema({\n *       userId: ObjectId,\n *       username: {\n *         type: String,\n *         required: function() { return this.userId != null; }\n *       }\n *     })\n *\n *     // or with a function and a custom message\n *     const s = new Schema({\n *       userId: ObjectId,\n *       username: {\n *         type: String,\n *         required: [\n *           function() { return this.userId != null; },\n *           'username is required if id is specified'\n *         ]\n *       }\n *     })\n *\n *     // or through the path API\n *\n *     s.path('name').required(true);\n *\n *     // with custom error messaging\n *\n *     s.path('name').required(true, 'grrr :( ');\n *\n *     // or make a path conditionally required based on a function\n *     const isOver18 = function() { return this.age >= 18; };\n *     s.path('voterRegistrationId').required(isOver18);\n *\n * The required validator uses the SchemaType's `checkRequired` function to\n * determine whether a given value satisfies the required validator. By default,\n * a value satisfies the required validator if `val != null` (that is, if\n * the value is not null nor undefined). However, most built-in mongoose schema\n * types override the default `checkRequired` function:\n *\n * @param {Boolean|Function|Object} required enable/disable the validator, or function that returns required boolean, or options object\n * @param {Boolean|Function} [options.isRequired] enable/disable the validator, or function that returns required boolean\n * @param {Function} [options.ErrorConstructor] custom error constructor. The constructor receives 1 parameter, an object containing the validator properties.\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @see SchemaArray#checkRequired https://mongoosejs.com/docs/api/schemaarray.html#SchemaArray.prototype.checkRequired()\n * @see SchemaBoolean#checkRequired https://mongoosejs.com/docs/api/schemaboolean.html#SchemaBoolean.prototype.checkRequired()\n * @see SchemaBuffer#checkRequired https://mongoosejs.com/docs/api/schemabuffer.html#SchemaBuffer.prototype.checkRequired()\n * @see SchemaNumber#checkRequired https://mongoosejs.com/docs/api/schemanumber.html#SchemaNumber.prototype.checkRequired()\n * @see SchemaObjectId#checkRequired https://mongoosejs.com/docs/api/schemaobjectid.html#ObjectId.prototype.checkRequired()\n * @see SchemaString#checkRequired https://mongoosejs.com/docs/api/schemastring.html#SchemaString.prototype.checkRequired()\n * @api public\n */\n\nSchemaType.prototype.required = function(required, message) {\n  let customOptions = {};\n\n  if (arguments.length > 0 && required == null) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.requiredValidator;\n    }, this);\n\n    this.isRequired = false;\n    delete this.originalRequiredValue;\n    return this;\n  }\n\n  if (typeof required === 'object') {\n    customOptions = required;\n    message = customOptions.message || message;\n    required = required.isRequired;\n  }\n\n  if (required === false) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.requiredValidator;\n    }, this);\n\n    this.isRequired = false;\n    delete this.originalRequiredValue;\n    return this;\n  }\n\n  const _this = this;\n  this.isRequired = true;\n\n  this.requiredValidator = function(v) {\n    const cachedRequired = this && this.$__ && this.$__.cachedRequired;\n\n    // no validation when this path wasn't selected in the query.\n    if (cachedRequired != null && !this.$__isSelected(_this.path) && !this[documentIsModified](_this.path)) {\n      return true;\n    }\n\n    // `$cachedRequired` gets set in `_evaluateRequiredFunctions()` so we\n    // don't call required functions multiple times in one validate call\n    // See gh-6801\n    if (cachedRequired != null && _this.path in cachedRequired) {\n      const res = cachedRequired[_this.path] ?\n        _this.checkRequired(v, this) :\n        true;\n      delete cachedRequired[_this.path];\n      return res;\n    } else if (typeof required === 'function') {\n      return required.apply(this) ? _this.checkRequired(v, this) : true;\n    }\n\n    return _this.checkRequired(v, this);\n  };\n  this.originalRequiredValue = required;\n\n  if (typeof required === 'string') {\n    message = required;\n    required = undefined;\n  }\n\n  const msg = message || MongooseError.messages.general.required;\n  this.validators.unshift(Object.assign({}, customOptions, {\n    validator: this.requiredValidator,\n    message: msg,\n    type: 'required'\n  }));\n\n  return this;\n};\n\n/**\n * Set the model that this path refers to. This is the option that [populate](https://mongoosejs.com/docs/populate.html)\n * looks at to determine the foreign collection it should query.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String });\n *     const User = mongoose.model('User', userSchema);\n *\n *     const postSchema = new Schema({ user: mongoose.ObjectId });\n *     postSchema.path('user').ref('User'); // Can set ref to a model name\n *     postSchema.path('user').ref(User); // Or a model class\n *     postSchema.path('user').ref(() => 'User'); // Or a function that returns the model name\n *     postSchema.path('user').ref(() => User); // Or a function that returns the model class\n *\n *     // Or you can just declare the `ref` inline in your schema\n *     const postSchema2 = new Schema({\n *       user: { type: mongoose.ObjectId, ref: User }\n *     });\n *\n * @param {String|Model|Function} ref either a model name, a [Model](https://mongoosejs.com/docs/models.html), or a function that returns a model name or model.\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.ref = function(ref) {\n  this.options.ref = ref;\n  return this;\n};\n\n/**\n * Gets the default value\n *\n * @param {Object} scope the scope which callback are executed\n * @param {Boolean} init\n * @return {Any} The Stored default value.\n * @api private\n */\n\nSchemaType.prototype.getDefault = function(scope, init, options) {\n  let ret;\n  if (typeof this.defaultValue === 'function') {\n    if (\n      this.defaultValue === Date.now ||\n      this.defaultValue === Array ||\n      this.defaultValue.name.toLowerCase() === 'objectid'\n    ) {\n      ret = this.defaultValue.call(scope);\n    } else {\n      ret = this.defaultValue.call(scope, scope);\n    }\n  } else {\n    ret = this.defaultValue;\n  }\n\n  if (ret !== null && ret !== undefined) {\n    if (typeof ret === 'object' && (!this.options || !this.options.shared)) {\n      ret = clone(ret);\n    }\n\n    if (options && options.skipCast) {\n      return this._applySetters(ret, scope);\n    }\n\n    const casted = this.applySetters(ret, scope, init, undefined, setOptionsForDefaults);\n    if (casted && !Array.isArray(casted) && casted.$isSingleNested) {\n      casted.$__parent = scope;\n    }\n    return casted;\n  }\n  return ret;\n};\n\n/**\n * Applies setters without casting\n *\n * @param {Any} value\n * @param {Any} scope\n * @param {Boolean} init\n * @param {Any} priorVal\n * @param {Object} [options]\n * @instance\n * @api private\n */\n\nSchemaType.prototype._applySetters = function(value, scope, init, priorVal, options) {\n  let v = value;\n  if (init) {\n    return v;\n  }\n  const setters = this.setters;\n\n  for (let i = setters.length - 1; i >= 0; i--) {\n    v = setters[i].call(scope, v, priorVal, this, options);\n  }\n\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaType.prototype._castNullish = function _castNullish(v) {\n  return v;\n};\n\n/**\n * Applies setters\n *\n * @param {Object} value\n * @param {Object} scope\n * @param {Boolean} init\n * @return {Any}\n * @api private\n */\n\nSchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {\n  let v = this._applySetters(value, scope, init, priorVal, options);\n  if (v == null) {\n    return this._castNullish(v);\n  }\n  // do not cast until all setters are applied #665\n  v = this.cast(v, scope, init, priorVal, options);\n\n  return v;\n};\n\n/**\n * Applies getters to a value\n *\n * @param {Object} value\n * @param {Object} scope\n * @return {Any}\n * @api private\n */\n\nSchemaType.prototype.applyGetters = function(value, scope) {\n  let v = value;\n  const getters = this.getters;\n  const len = getters.length;\n\n  if (len === 0) {\n    return v;\n  }\n\n  for (let i = 0; i < len; ++i) {\n    v = getters[i].call(scope, v, this);\n  }\n\n  return v;\n};\n\n/**\n * Sets default `select()` behavior for this path.\n *\n * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.\n *\n * #### Example:\n *\n *     T = db.model('T', new Schema({ x: { type: String, select: true }}));\n *     T.find(..); // field x will always be selected ..\n *     // .. unless overridden;\n *     T.find().select('-x').exec(callback);\n *\n * @param {Boolean} val\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.select = function select(val) {\n  this.selected = !!val;\n  return this;\n};\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * @param {Any} value\n * @param {Function} callback\n * @param {Object} scope\n * @param {Object} [options]\n * @param {String} [options.path]\n * @return {Any} If no validators, returns the output from calling `fn`, otherwise no return\n * @api public\n */\n\nSchemaType.prototype.doValidate = function(value, fn, scope, options) {\n  let err = false;\n  const path = this.path;\n\n  // Avoid non-object `validators`\n  const validators = this.validators.\n    filter(v => typeof v === 'object' && v !== null);\n\n  let count = validators.length;\n\n  if (!count) {\n    return fn(null);\n  }\n\n  for (let i = 0, len = validators.length; i < len; ++i) {\n    if (err) {\n      break;\n    }\n\n    const v = validators[i];\n    const validator = v.validator;\n    let ok;\n\n    const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone(v);\n    validatorProperties.path = options && options.path ? options.path : path;\n    validatorProperties.fullPath = this.$fullPath;\n    validatorProperties.value = value;\n\n    if (validator instanceof RegExp) {\n      validate(validator.test(value), validatorProperties, scope);\n      continue;\n    }\n\n    if (typeof validator !== 'function') {\n      continue;\n    }\n\n    if (value === undefined && validator !== this.requiredValidator) {\n      validate(true, validatorProperties, scope);\n      continue;\n    }\n\n    try {\n      if (validatorProperties.propsParameter) {\n        ok = validator.call(scope, value, validatorProperties);\n      } else {\n        ok = validator.call(scope, value);\n      }\n    } catch (error) {\n      ok = false;\n      validatorProperties.reason = error;\n      if (error.message) {\n        validatorProperties.message = error.message;\n      }\n    }\n\n    if (ok != null && typeof ok.then === 'function') {\n      ok.then(\n        function(ok) { validate(ok, validatorProperties, scope); },\n        function(error) {\n          validatorProperties.reason = error;\n          validatorProperties.message = error.message;\n          ok = false;\n          validate(ok, validatorProperties, scope);\n        });\n    } else {\n      validate(ok, validatorProperties, scope);\n    }\n  }\n\n  function validate(ok, validatorProperties, scope) {\n    if (err) {\n      return;\n    }\n    if (ok === undefined || ok) {\n      if (--count <= 0) {\n        immediate(function() {\n          fn(null);\n        });\n      }\n    } else {\n      const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;\n      err = new ErrorConstructor(validatorProperties, scope);\n      err[validatorErrorSymbol] = true;\n      immediate(function() {\n        fn(err);\n      });\n    }\n  }\n};\n\n\nfunction _validate(ok, validatorProperties) {\n  if (ok !== undefined && !ok) {\n    const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;\n    const err = new ErrorConstructor(validatorProperties);\n    err[validatorErrorSymbol] = true;\n    return err;\n  }\n}\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @param {Any} value\n * @param {Object} scope\n * @param {Object} [options]\n * @param {Object} [options.path]\n * @return {MongooseError|null}\n * @api private\n */\n\nSchemaType.prototype.doValidateSync = function(value, scope, options) {\n  const path = this.path;\n  const count = this.validators.length;\n\n  if (!count) {\n    return null;\n  }\n\n  let validators = this.validators;\n  if (value === void 0) {\n    if (this.validators.length !== 0 && this.validators[0].type === 'required') {\n      validators = [this.validators[0]];\n    } else {\n      return null;\n    }\n  }\n\n  let err = null;\n  let i = 0;\n  const len = validators.length;\n  for (i = 0; i < len; ++i) {\n\n    const v = validators[i];\n\n    if (v === null || typeof v !== 'object') {\n      continue;\n    }\n\n    const validator = v.validator;\n    const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone(v);\n    validatorProperties.path = options && options.path ? options.path : path;\n    validatorProperties.fullPath = this.$fullPath;\n    validatorProperties.value = value;\n    let ok = false;\n\n    // Skip any explicit async validators. Validators that return a promise\n    // will still run, but won't trigger any errors.\n    if (isAsyncFunction(validator)) {\n      continue;\n    }\n\n    if (validator instanceof RegExp) {\n      err = _validate(validator.test(value), validatorProperties);\n      continue;\n    }\n\n    if (typeof validator !== 'function') {\n      continue;\n    }\n\n    try {\n      if (validatorProperties.propsParameter) {\n        ok = validator.call(scope, value, validatorProperties);\n      } else {\n        ok = validator.call(scope, value);\n      }\n    } catch (error) {\n      ok = false;\n      validatorProperties.reason = error;\n    }\n\n    // Skip any validators that return a promise, we can't handle those\n    // synchronously\n    if (ok != null && typeof ok.then === 'function') {\n      continue;\n    }\n    err = _validate(ok, validatorProperties);\n    if (err) {\n      break;\n    }\n  }\n\n  return err;\n};\n\n/**\n * Determines if value is a valid Reference.\n *\n * @param {SchemaType} self\n * @param {Object} value\n * @param {Document} doc\n * @param {Boolean} init\n * @return {Boolean}\n * @api private\n */\n\nSchemaType._isRef = function(self, value, doc, init) {\n  // fast path\n  let ref = init && self.options && (self.options.ref || self.options.refPath);\n\n  if (!ref && doc && doc.$__ != null) {\n    // checks for\n    // - this populated with adhoc model and no ref was set in schema OR\n    // - setting / pushing values after population\n    const path = doc.$__fullPath(self.path, true);\n\n    const owner = doc.ownerDocument();\n    ref = (path != null && owner.$populated(path)) || doc.$populated(self.path);\n  }\n\n  if (ref) {\n    if (value == null) {\n      return true;\n    }\n    if (!Buffer.isBuffer(value) && // buffers are objects too\n      value._bsontype !== 'Binary' // raw binary value from the db\n      && utils.isObject(value) // might have deselected _id in population query\n    ) {\n      return true;\n    }\n\n    return init;\n  }\n\n  return false;\n};\n\n/*!\n * ignore\n */\n\nSchemaType.prototype._castRef = function _castRef(value, doc, init) {\n  if (value == null) {\n    return value;\n  }\n\n  if (value.$__ != null) {\n    value.$__.wasPopulated = value.$__.wasPopulated || { value: value._id };\n    return value;\n  }\n\n  // setting a populated path\n  if (Buffer.isBuffer(value) || !utils.isObject(value)) {\n    if (init) {\n      return value;\n    }\n    throw new CastError(this.instance, value, this.path, null, this);\n  }\n\n  // Handle the case where user directly sets a populated\n  // path to a plain object; cast to the Model used in\n  // the population query.\n  const path = doc.$__fullPath(this.path, true);\n  const owner = doc.ownerDocument();\n  const pop = owner.$populated(path, true);\n\n  let ret = value;\n  if (!doc.$__.populated ||\n    !doc.$__.populated[path] ||\n    !doc.$__.populated[path].options ||\n    !doc.$__.populated[path].options.options ||\n    !doc.$__.populated[path].options.options.lean) {\n    ret = new pop.options[populateModelSymbol](value);\n    ret.$__.wasPopulated = { value: ret._id };\n  }\n\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/**\n * Just like handleArray, except also allows `[]` because surprisingly\n * `$in: [1, []]` works fine\n * @api private\n */\n\nfunction handle$in(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    if (Array.isArray(m) && m.length === 0) {\n      return m;\n    }\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/*!\n * ignore\n */\n\nSchemaType.prototype.$conditionalHandlers = {\n  $all: handleArray,\n  $eq: handleSingle,\n  $in: handle$in,\n  $ne: handleSingle,\n  $nin: handle$in,\n  $exists: $exists,\n  $type: $type\n};\n\n/**\n * Cast the given value with the given optional query operator.\n *\n * @param {String} [$conditional] query operator, like `$eq` or `$in`\n * @param {Any} val\n * @param {Query} context\n * @return {Any}\n * @api private\n */\n\nSchemaType.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val, context);\n  }\n\n  return this.applySetters(val, context);\n};\n\n/**\n * Set & Get the `checkRequired` function\n * Override the function the required validator uses to check whether a value\n * passes the `required` check. Override this on the individual SchemaType.\n *\n * #### Example:\n *\n *     // Use this to allow empty strings to pass the `required` validator\n *     mongoose.Schema.Types.String.checkRequired(v => typeof v === 'string');\n *\n * @param {Function} [fn] If set, will overwrite the current set function\n * @return {Function} The input `fn` or the already set function\n * @static\n * @memberOf SchemaType\n * @function checkRequired\n * @api public\n */\n\nSchemaType.checkRequired = function(fn) {\n  if (arguments.length !== 0) {\n    this._checkRequired = fn;\n  }\n\n  return this._checkRequired;\n};\n\n/**\n * Default check for if this path satisfies the `required` validator.\n *\n * @param {Any} val\n * @return {Boolean} `true` when the value is not `null`, `false` otherwise\n * @api private\n */\n\nSchemaType.prototype.checkRequired = function(val) {\n  return val != null;\n};\n\n/**\n * Clone the current SchemaType\n *\n * @return {SchemaType} The cloned SchemaType instance\n * @api private\n */\n\nSchemaType.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, options, this.instance);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) schematype.requiredValidator = this.requiredValidator;\n  if (this.defaultValue !== undefined) schematype.defaultValue = this.defaultValue;\n  if (this.$immutable !== undefined && this.options.immutable === undefined) {\n    schematype.$immutable = this.$immutable;\n\n    handleImmutable(schematype);\n  }\n  if (this._index !== undefined) schematype._index = this._index;\n  if (this.selected !== undefined) schematype.selected = this.selected;\n  if (this.isRequired !== undefined) schematype.isRequired = this.isRequired;\n  if (this.originalRequiredValue !== undefined) schematype.originalRequiredValue = this.originalRequiredValue;\n  schematype.getters = this.getters.slice();\n  schematype.setters = this.setters.slice();\n  return schematype;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = SchemaType;\n\nexports.CastError = CastError;\n\nexports.ValidatorError = ValidatorError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsK0VBQWU7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsMkdBQTZCO0FBQy9ELGdCQUFnQixtQkFBTyxDQUFDLHVHQUEyQjtBQUNuRCxjQUFjLG1CQUFPLENBQUMsbUdBQXlCO0FBQy9DLGNBQWMsbUJBQU8sQ0FBQyxtRkFBaUI7QUFDdkMsd0JBQXdCLG1CQUFPLENBQUMsNkhBQXNDO0FBQ3RFLHdCQUF3QixtQkFBTyxDQUFDLHVHQUEyQjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQywyR0FBNkI7QUFDL0Qsa0JBQWtCLG1CQUFPLENBQUMsMkZBQXFCO0FBQy9DLHlCQUF5QiwrSEFBNkM7QUFDdEUsY0FBYyxtQkFBTyxDQUFDLG1FQUFTO0FBQy9CLDZCQUE2QixtSUFBaUQ7QUFDOUUsMkJBQTJCLGlJQUErQzs7QUFFMUUsNEJBQTRCLGtJQUFnRDs7QUFFNUU7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELGtEQUFrRDtBQUNsRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFD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eEI7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQjs7QUFFakIsc0JBQXNCIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcc2NoZW1hdHlwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMvU2NoZW1hVHlwZU9wdGlvbnMnKTtcbmNvbnN0ICRleGlzdHMgPSByZXF1aXJlKCcuL3NjaGVtYS9vcGVyYXRvcnMvZXhpc3RzJyk7XG5jb25zdCAkdHlwZSA9IHJlcXVpcmUoJy4vc2NoZW1hL29wZXJhdG9ycy90eXBlJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgaGFuZGxlSW1tdXRhYmxlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYXR5cGUvaGFuZGxlSW1tdXRhYmxlJyk7XG5jb25zdCBpc0FzeW5jRnVuY3Rpb24gPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBc3luY0Z1bmN0aW9uJyk7XG5jb25zdCBpc1NpbXBsZVZhbGlkYXRvciA9IHJlcXVpcmUoJy4vaGVscGVycy9pc1NpbXBsZVZhbGlkYXRvcicpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3Qgc2NoZW1hVHlwZVN5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuc2NoZW1hVHlwZVN5bWJvbDtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgdmFsaWRhdG9yRXJyb3JTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnZhbGlkYXRvckVycm9yU3ltYm9sO1xuY29uc3QgZG9jdW1lbnRJc01vZGlmaWVkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS5kb2N1bWVudElzTW9kaWZpZWQ7XG5cbmNvbnN0IHBvcHVsYXRlTW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnBvcHVsYXRlTW9kZWxTeW1ib2w7XG5cbmNvbnN0IENhc3RFcnJvciA9IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yO1xuY29uc3QgVmFsaWRhdG9yRXJyb3IgPSBNb25nb29zZUVycm9yLlZhbGlkYXRvckVycm9yO1xuXG5jb25zdCBzZXRPcHRpb25zRm9yRGVmYXVsdHMgPSB7IF9za2lwTWFya01vZGlmaWVkOiB0cnVlIH07XG5cbi8qKlxuICogU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci4gRG8gKipub3QqKiBpbnN0YW50aWF0ZSBgU2NoZW1hVHlwZWAgZGlyZWN0bHkuXG4gKiBNb25nb29zZSBjb252ZXJ0cyB5b3VyIHNjaGVtYSBwYXRocyBpbnRvIFNjaGVtYVR5cGVzIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykgaW5zdGFuY2VvZiBTY2hlbWFUeXBlOyAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7U2NoZW1hVHlwZU9wdGlvbnN9IFtvcHRpb25zXSBTZWUgW1NjaGVtYVR5cGVPcHRpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hdHlwZW9wdGlvbnMuaHRtbClcbiAqIEBwYXJhbSB7U3RyaW5nfSBbaW5zdGFuY2VdXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYVR5cGUocGF0aCwgb3B0aW9ucywgaW5zdGFuY2UpIHtcbiAgdGhpc1tzY2hlbWFUeXBlU3ltYm9sXSA9IHRydWU7XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgdGhpcy52YWxpZGF0b3JzID0gW107XG4gIHRoaXMuZ2V0dGVycyA9IHRoaXMuY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkoJ2dldHRlcnMnKSA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5nZXR0ZXJzLnNsaWNlKCkgOlxuICAgIFtdO1xuICB0aGlzLnNldHRlcnMgPSB0aGlzLmNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KCdzZXR0ZXJzJykgP1xuICAgIHRoaXMuY29uc3RydWN0b3Iuc2V0dGVycy5zbGljZSgpIDpcbiAgICBbXTtcblxuICB0aGlzLnNwbGl0UGF0aCgpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdE9wdGlvbnMgfHwge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zS2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRPcHRpb25zKTtcblxuICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkZWZhdWx0T3B0aW9uc0tleXMpIHtcbiAgICBpZiAoZGVmYXVsdE9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIG9wdGlvbikpIHtcbiAgICAgIG9wdGlvbnNbb3B0aW9uXSA9IGRlZmF1bHRPcHRpb25zW29wdGlvbl07XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuc2VsZWN0ID09IG51bGwpIHtcbiAgICBkZWxldGUgb3B0aW9ucy5zZWxlY3Q7XG4gIH1cblxuICBjb25zdCBPcHRpb25zID0gdGhpcy5PcHRpb25zQ29uc3RydWN0b3IgfHwgU2NoZW1hVHlwZU9wdGlvbnM7XG4gIHRoaXMub3B0aW9ucyA9IG5ldyBPcHRpb25zKG9wdGlvbnMpO1xuICB0aGlzLl9pbmRleCA9IG51bGw7XG5cblxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh0aGlzLm9wdGlvbnMsICdpbW11dGFibGUnKSkge1xuICAgIHRoaXMuJGltbXV0YWJsZSA9IHRoaXMub3B0aW9ucy5pbW11dGFibGU7XG5cbiAgICBoYW5kbGVJbW11dGFibGUodGhpcyk7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIGtleXMpIHtcbiAgICBpZiAocHJvcCA9PT0gJ2Nhc3QnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnNbcHJvcF0pKSB7XG4gICAgICAgIHRoaXMuY2FzdEZ1bmN0aW9uLmFwcGx5KHRoaXMsIHRoaXMub3B0aW9uc1twcm9wXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhc3RGdW5jdGlvbih0aGlzLm9wdGlvbnNbcHJvcF0pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KHRoaXMub3B0aW9ucywgcHJvcCkgJiYgdHlwZW9mIHRoaXNbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIHsgdW5pcXVlOiB0cnVlLCBpbmRleDogdHJ1ZSB9XG4gICAgICBpZiAocHJvcCA9PT0gJ2luZGV4JyAmJiB0aGlzLl9pbmRleCkge1xuICAgICAgICBpZiAob3B0aW9ucy5pbmRleCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2luZGV4O1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdvYmplY3QnICYmIGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbmRleC51bmlxdWUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIFwiJyArIHRoaXMucGF0aCArICdcIiBtYXkgbm90IGhhdmUgYGluZGV4YCAnICtcbiAgICAgICAgICAgICAgICAnc2V0IHRvIGZhbHNlIGFuZCBgdW5pcXVlYCBzZXQgdG8gdHJ1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4LnNwYXJzZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggXCInICsgdGhpcy5wYXRoICsgJ1wiIG1heSBub3QgaGF2ZSBgaW5kZXhgICcgK1xuICAgICAgICAgICAgICAgICdzZXQgdG8gZmFsc2UgYW5kIGBzcGFyc2VgIHNldCB0byB0cnVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5faW5kZXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBzbyB3ZSBkb24ndCBzY3JldyB1cCBhcnJheSBkZWZhdWx0cywgc2VlIGdoLTU3ODBcbiAgICAgIGlmIChwcm9wID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0KHZhbCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcHRzID0gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF07XG5cbiAgICAgIHRoaXNbcHJvcF0uYXBwbHkodGhpcywgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICckJGNvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBUaGUgY2xhc3MgdGhhdCBNb25nb29zZSB1c2VzIGludGVybmFsbHkgdG8gaW5zdGFudGlhdGUgdGhpcyBTY2hlbWFUeXBlJ3MgYG9wdGlvbnNgIHByb3BlcnR5LlxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuT3B0aW9uc0NvbnN0cnVjdG9yID0gU2NoZW1hVHlwZU9wdGlvbnM7XG5cbi8qKlxuICogVGhlIHBhdGggdG8gdGhpcyBTY2hlbWFUeXBlIGluIGEgU2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLnBhdGg7IC8vICduYW1lJ1xuICpcbiAqIEBwcm9wZXJ0eSBwYXRoXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIFNjaGVtYVR5cGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5wYXRoO1xuXG4vKipcbiAqIFRoZSB2YWxpZGF0b3JzIHRoYXQgTW9uZ29vc2Ugc2hvdWxkIHJ1biB0byB2YWxpZGF0ZSBwcm9wZXJ0aWVzIGF0IHRoaXMgU2NoZW1hVHlwZSdzIHBhdGguXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS52YWxpZGF0b3JzLmxlbmd0aDsgLy8gMSwgdGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yXG4gKlxuICogQHByb3BlcnR5IHZhbGlkYXRvcnNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnZhbGlkYXRvcnM7XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGlzIFNjaGVtYVR5cGUgaGFzIGEgcmVxdWlyZWQgdmFsaWRhdG9yLiBGYWxzZSBvdGhlcndpc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS5pc1JlcXVpcmVkOyAvLyB0cnVlXG4gKlxuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykucmVxdWlyZWQoZmFsc2UpO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykuaXNSZXF1aXJlZDsgLy8gZmFsc2VcbiAqXG4gKiBAcHJvcGVydHkgaXNSZXF1aXJlZFxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuaXNSZXF1aXJlZDtcblxuLyoqXG4gKiBTcGxpdCB0aGUgY3VycmVudCBkb3R0ZXQgcGF0aCBpbnRvIHNlZ21lbnRzXG4gKlxuICogQHJldHVybiB7U3RyaW5nW118dW5kZWZpbmVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuc3BsaXRQYXRoID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9wcmVzcGxpdFBhdGggIT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVzcGxpdFBhdGg7XG4gIH1cbiAgaWYgKHRoaXMucGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRoaXMuX3ByZXNwbGl0UGF0aCA9IHRoaXMucGF0aC5pbmRleE9mKCcuJykgPT09IC0xID8gW3RoaXMucGF0aF0gOiB0aGlzLnBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIHRoaXMuX3ByZXNwbGl0UGF0aDtcbn07XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gdGhpcyB0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gRGlzYWxsb3cgYG51bGxgIGZvciBudW1iZXJzLCBhbmQgZG9uJ3QgdHJ5IHRvIGNhc3QgYW55IHZhbHVlcyB0b1xuICogICAgIC8vIG51bWJlcnMsIHNvIGV2ZW4gc3RyaW5ncyBsaWtlICcxMjMnIHdpbGwgY2F1c2UgYSBDYXN0RXJyb3IuXG4gKiAgICAgbW9uZ29vc2UuTnVtYmVyLmNhc3QoZnVuY3Rpb24odikge1xuICogICAgICAgYXNzZXJ0Lm9rKHYgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpO1xuICogICAgICAgcmV0dXJuIHY7XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxmYWxzZX0gY2FzdGVyIEZ1bmN0aW9uIHRoYXQgY2FzdHMgYXJiaXRyYXJ5IHZhbHVlcyB0byB0aGlzIHR5cGUsIG9yIHRocm93cyBhbiBlcnJvciBpZiBjYXN0aW5nIGZhaWxlZFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICogQGZ1bmN0aW9uIGNhc3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5jYXN0ID0gZnVuY3Rpb24gY2FzdChjYXN0ZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdDtcbiAgfVxuICBpZiAoY2FzdGVyID09PSBmYWxzZSkge1xuICAgIGNhc3RlciA9IHYgPT4gdjtcbiAgfVxuICB0aGlzLl9jYXN0ID0gY2FzdGVyO1xuXG4gIHJldHVybiB0aGlzLl9jYXN0O1xufTtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byB0aGlzIHBhcnRpY3VsYXIgc2NoZW1hdHlwZSBpbnN0YW5jZS5cbiAqIE92ZXJyaWRlcyBgU2NoZW1hVHlwZS5jYXN0KClgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gRGlzYWxsb3cgYG51bGxgIGZvciBudW1iZXJzLCBhbmQgZG9uJ3QgdHJ5IHRvIGNhc3QgYW55IHZhbHVlcyB0b1xuICogICAgIC8vIG51bWJlcnMsIHNvIGV2ZW4gc3RyaW5ncyBsaWtlICcxMjMnIHdpbGwgY2F1c2UgYSBDYXN0RXJyb3IuXG4gKiAgICAgY29uc3QgbnVtYmVyID0gbmV3IG1vbmdvb3NlLk51bWJlcignbXlwYXRoJywge30pO1xuICogICAgIG51bWJlci5jYXN0KGZ1bmN0aW9uKHYpIHtcbiAqICAgICAgIGFzc2VydC5vayh2ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKTtcbiAqICAgICAgIHJldHVybiB2O1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258ZmFsc2V9IGNhc3RlciBGdW5jdGlvbiB0aGF0IGNhc3RzIGFyYml0cmFyeSB2YWx1ZXMgdG8gdGhpcyB0eXBlLCBvciB0aHJvd3MgYW4gZXJyb3IgaWYgY2FzdGluZyBmYWlsZWRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuY2FzdEZ1bmN0aW9uID0gZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKGNhc3RlciwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0RnVuY3Rpb247XG4gIH1cblxuICBpZiAoY2FzdGVyID09PSBmYWxzZSkge1xuICAgIGNhc3RlciA9IHRoaXMuY29uc3RydWN0b3IuX2RlZmF1bHRDYXN0ZXIgfHwgKHYgPT4gdik7XG4gIH1cbiAgaWYgKHR5cGVvZiBjYXN0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5fY2FzdEVycm9yTWVzc2FnZSA9IGNhc3RlcjtcbiAgICByZXR1cm4gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9XG4gIGlmIChjYXN0ZXIgIT0gbnVsbCkge1xuICAgIHRoaXMuX2Nhc3RGdW5jdGlvbiA9IGNhc3RlcjtcbiAgfVxuICBpZiAobWVzc2FnZSAhPSBudWxsKSB7XG4gICAgdGhpcy5fY2FzdEVycm9yTWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fY2FzdEZ1bmN0aW9uO1xufTtcblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gdGhhdCBNb25nb29zZSBjYWxscyB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gdGhpcyBTY2hlbWFUeXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB2YWx1ZSB0byBjYXN0XG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgZG9jdW1lbnQgdGhhdCB0cmlnZ2VycyB0aGUgY2FzdGluZ1xuICogQHBhcmFtIHtCb29sZWFufSBpbml0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbiBjYXN0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Jhc2UgU2NoZW1hVHlwZSBjbGFzcyBkb2VzIG5vdCBpbXBsZW1lbnQgYSBgY2FzdCgpYCBmdW5jdGlvbicpO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIHRoaXMgc2NoZW1hIHR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBzdHJpbmdzIGJlIHRyaW1tZWQgYnkgZGVmYXVsdFxuICogICAgIG1vbmdvb3NlLlNjaGVtYVR5cGVzLlN0cmluZy5zZXQoJ3RyaW0nLCB0cnVlKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBuYW1lIG9mIHRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgKGUuZy4gdHJpbSwgbG93ZXJjYXNlLCBldGMuLi4pXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQuXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIFNjaGVtYVR5cGVcbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9uLCB2YWx1ZSkge1xuICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRPcHRpb25zJykpIHtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gIH1cbiAgdGhpcy5kZWZhdWx0T3B0aW9uc1tvcHRpb25dID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgaW5zdGFuY2VzIG9mIHRoaXMgc2NoZW1hIHR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBudW1iZXJzIHJvdW5kIGRvd25cbiAqICAgICBtb25nb29zZS5OdW1iZXIuZ2V0KGZ1bmN0aW9uKHYpIHsgcmV0dXJuIE1hdGguZmxvb3Iodik7IH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlXG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUuZ2V0ID0gZnVuY3Rpb24oZ2V0dGVyKSB7XG4gIHRoaXMuZ2V0dGVycyA9IHRoaXMuaGFzT3duUHJvcGVydHkoJ2dldHRlcnMnKSA/IHRoaXMuZ2V0dGVycyA6IFtdO1xuICB0aGlzLmdldHRlcnMucHVzaChnZXR0ZXIpO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBTY2hlbWFUeXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG46IHsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiAxMCB9KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHNjaGVtYSlcbiAqICAgICBjb25zdCBtID0gbmV3IE07XG4gKiAgICAgY29uc29sZS5sb2cobS5uKSAvLyAxMFxuICpcbiAqIERlZmF1bHRzIGNhbiBiZSBlaXRoZXIgYGZ1bmN0aW9uc2Agd2hpY2ggcmV0dXJuIHRoZSB2YWx1ZSB0byB1c2UgYXMgdGhlIGRlZmF1bHQgb3IgdGhlIGxpdGVyYWwgdmFsdWUgaXRzZWxmLiBFaXRoZXIgd2F5LCB0aGUgdmFsdWUgd2lsbCBiZSBjYXN0IGJhc2VkIG9uIGl0cyBzY2hlbWEgdHlwZSBiZWZvcmUgYmVpbmcgc2V0IGR1cmluZyBkb2N1bWVudCBjcmVhdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHZhbHVlcyBhcmUgY2FzdDpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgYU51bWJlcjogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDQuODE1MTYyMzQyIH19KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHNjaGVtYSlcbiAqICAgICBjb25zdCBtID0gbmV3IE07XG4gKiAgICAgY29uc29sZS5sb2cobS5hTnVtYmVyKSAvLyA0LjgxNTE2MjM0MlxuICpcbiAqICAgICAvLyBkZWZhdWx0IHVuaXF1ZSBvYmplY3RzIGZvciBNaXhlZCB0eXBlczpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbWl4ZWQ6IFNjaGVtYS5UeXBlcy5NaXhlZCB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbWl4ZWQnKS5kZWZhdWx0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHJldHVybiB7fTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gaWYgd2UgZG9uJ3QgdXNlIGEgZnVuY3Rpb24gdG8gcmV0dXJuIG9iamVjdCBsaXRlcmFscyBmb3IgTWl4ZWQgZGVmYXVsdHMsXG4gKiAgICAgLy8gZWFjaCBkb2N1bWVudCB3aWxsIHJlY2VpdmUgYSByZWZlcmVuY2UgdG8gdGhlIHNhbWUgb2JqZWN0IGxpdGVyYWwgY3JlYXRpbmdcbiAqICAgICAvLyBhIFwic2hhcmVkXCIgb2JqZWN0IGluc3RhbmNlOlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBtaXhlZDogU2NoZW1hLlR5cGVzLk1peGVkIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdtaXhlZCcpLmRlZmF1bHQoe30pO1xuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHNjaGVtYSk7XG4gKiAgICAgY29uc3QgbTEgPSBuZXcgTTtcbiAqICAgICBtMS5taXhlZC5hZGRlZCA9IDE7XG4gKiAgICAgY29uc29sZS5sb2cobTEubWl4ZWQpOyAvLyB7IGFkZGVkOiAxIH1cbiAqICAgICBjb25zdCBtMiA9IG5ldyBNO1xuICogICAgIGNvbnNvbGUubG9nKG0yLm1peGVkKTsgLy8geyBhZGRlZDogMSB9XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxhbnl9IHZhbCBUaGUgZGVmYXVsdCB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm4ge0FueXx1bmRlZmluZWR9IFJldHVybnMgdGhlIHNldCBkZWZhdWx0IHZhbHVlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5kZWZhdWx0ID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHZvaWQgMDtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuXG4gICAgaWYgKHZhbCAhPSBudWxsICYmIHZhbC5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ2Fubm90IHNldCBkZWZhdWx0IHZhbHVlIG9mIHBhdGggYCcgKyB0aGlzLnBhdGggK1xuICAgICAgICAnYCB0byBhIG1vbmdvb3NlIFNjaGVtYSBpbnN0YW5jZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHZhbDtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0VmFsdWU7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IFsuLi5hcmd1bWVudHNdO1xuICB9XG4gIHJldHVybiB0aGlzLmRlZmF1bHRWYWx1ZTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgdGhlIGluZGV4IG9wdGlvbnMgZm9yIHRoaXMgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIGluZGV4OiB0cnVlIH0pXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgaW5kZXg6IC0xIH0pXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBsb2M6IHsgdHlwZTogW051bWJlcl0sIGluZGV4OiAnaGFzaGVkJyB9KVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbG9jOiB7IHR5cGU6IFtOdW1iZXJdLCBpbmRleDogJzJkJywgc3BhcnNlOiB0cnVlIH0pXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBsb2M6IHsgdHlwZTogW051bWJlcl0sIGluZGV4OiB7IHR5cGU6ICcyZHNwaGVyZScsIHNwYXJzZTogdHJ1ZSB9fSlcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGRhdGU6IHsgdHlwZTogRGF0ZSwgaW5kZXg6IHsgdW5pcXVlOiB0cnVlLCBleHBpcmVzOiAnMWQnIH19KVxuICogICAgIHMucGF0aCgnbXkucGF0aCcpLmluZGV4KHRydWUpO1xuICogICAgIHMucGF0aCgnbXkuZGF0ZScpLmluZGV4KHsgZXhwaXJlczogNjAgfSk7XG4gKiAgICAgcy5wYXRoKCdteS5wYXRoJykuaW5kZXgoeyB1bmlxdWU6IHRydWUsIHNwYXJzZTogdHJ1ZSB9KTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogX0luZGV4ZXMgYXJlIGNyZWF0ZWQgW2luIHRoZSBiYWNrZ3JvdW5kXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2luZGV4LWNyZWF0aW9uLyNpbmRleC1jcmVhdGlvbi1iYWNrZ3JvdW5kKVxuICogYnkgZGVmYXVsdC4gSWYgYGJhY2tncm91bmRgIGlzIHNldCB0byBgZmFsc2VgLCBNb25nb0RCIHdpbGwgbm90IGV4ZWN1dGUgYW55XG4gKiByZWFkL3dyaXRlIG9wZXJhdGlvbnMgeW91IHNlbmQgdW50aWwgdGhlIGluZGV4IGJ1aWxkLlxuICogU3BlY2lmeSBgYmFja2dyb3VuZDogZmFsc2VgIHRvIG92ZXJyaWRlIE1vbmdvb3NlJ3MgZGVmYXVsdC5fXG4gKlxuICogQHBhcmFtIHtPYmplY3R8Qm9vbGVhbnxTdHJpbmd8TnVtYmVyfSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLl9pbmRleCA9IG9wdGlvbnM7XG4gIHV0aWxzLmV4cGlyZXModGhpcy5faW5kZXgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYW4gdW5pcXVlIGluZGV4LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgdW5pcXVlOiB0cnVlIH0gfSk7XG4gKiAgICAgcy5wYXRoKCduYW1lJykuaW5kZXgoeyB1bmlxdWU6IHRydWUgfSk7XG4gKlxuICogX05PVEU6IHZpb2xhdGluZyB0aGUgY29uc3RyYWludCByZXR1cm5zIGFuIGBFMTEwMDBgIGVycm9yIGZyb20gTW9uZ29EQiB3aGVuIHNhdmluZywgbm90IGEgTW9uZ29vc2UgdmFsaWRhdGlvbiBlcnJvci5fXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBib29sXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnVuaXF1ZSA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgaWYgKHRoaXMuX2luZGV4ID09PSBmYWxzZSkge1xuICAgIGlmICghYm9vbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggXCInICsgdGhpcy5wYXRoICsgJ1wiIG1heSBub3QgaGF2ZSBgaW5kZXhgIHNldCB0byAnICtcbiAgICAgICdmYWxzZSBhbmQgYHVuaXF1ZWAgc2V0IHRvIHRydWUnKTtcbiAgfVxuXG4gIGlmICghdGhpcy5vcHRpb25zLmhhc093blByb3BlcnR5KCdpbmRleCcpICYmIGJvb2wgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodGhpcy5faW5kZXggPT0gbnVsbCB8fCB0aGlzLl9pbmRleCA9PT0gdHJ1ZSkge1xuICAgIHRoaXMuX2luZGV4ID0ge307XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2luZGV4ID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuX2luZGV4ID0geyB0eXBlOiB0aGlzLl9pbmRleCB9O1xuICB9XG5cbiAgdGhpcy5faW5kZXgudW5pcXVlID0gYm9vbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGEgZnVsbCB0ZXh0IGluZGV4LlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lIDogeyB0eXBlOiBTdHJpbmcsIHRleHQgOiB0cnVlIH0gfSlcbiAqICAgICAgcy5wYXRoKCduYW1lJykuaW5kZXgoeyB0ZXh0IDogdHJ1ZSB9KTtcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJvb2xcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgaWYgKHRoaXMuX2luZGV4ID09PSBmYWxzZSkge1xuICAgIGlmICghYm9vbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBcIicgKyB0aGlzLnBhdGggKyAnXCIgbWF5IG5vdCBoYXZlIGBpbmRleGAgc2V0IHRvICcgK1xuICAgICAgJ2ZhbHNlIGFuZCBgdGV4dGAgc2V0IHRvIHRydWUnKTtcbiAgfVxuXG4gIGlmICghdGhpcy5vcHRpb25zLmhhc093blByb3BlcnR5KCdpbmRleCcpICYmIGJvb2wgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodGhpcy5faW5kZXggPT09IG51bGwgfHwgdGhpcy5faW5kZXggPT09IHVuZGVmaW5lZCB8fFxuICAgIHR5cGVvZiB0aGlzLl9pbmRleCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdGhpcy5faW5kZXggPSB7fTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faW5kZXggPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5faW5kZXggPSB7IHR5cGU6IHRoaXMuX2luZGV4IH07XG4gIH1cblxuICB0aGlzLl9pbmRleC50ZXh0ID0gYm9vbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGEgc3BhcnNlIGluZGV4LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgc3BhcnNlOiB0cnVlIH0gfSk7XG4gKiAgICAgcy5wYXRoKCduYW1lJykuaW5kZXgoeyBzcGFyc2U6IHRydWUgfSk7XG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBib29sXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnNwYXJzZSA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgaWYgKHRoaXMuX2luZGV4ID09PSBmYWxzZSkge1xuICAgIGlmICghYm9vbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBcIicgKyB0aGlzLnBhdGggKyAnXCIgbWF5IG5vdCBoYXZlIGBpbmRleGAgc2V0IHRvICcgK1xuICAgICAgJ2ZhbHNlIGFuZCBgc3BhcnNlYCBzZXQgdG8gdHJ1ZScpO1xuICB9XG5cbiAgaWYgKCF0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2luZGV4JykgJiYgYm9vbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh0aGlzLl9pbmRleCA9PSBudWxsIHx8IHR5cGVvZiB0aGlzLl9pbmRleCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdGhpcy5faW5kZXggPSB7fTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faW5kZXggPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5faW5kZXggPSB7IHR5cGU6IHRoaXMuX2luZGV4IH07XG4gIH1cblxuICB0aGlzLl9pbmRleC5zcGFyc2UgPSBib29sO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyB0aGlzIHBhdGggYXMgaW1tdXRhYmxlLiBNb25nb29zZSBwcmV2ZW50cyB5b3UgZnJvbSBjaGFuZ2luZ1xuICogaW1tdXRhYmxlIHBhdGhzIHVubGVzcyB0aGUgcGFyZW50IGRvY3VtZW50IGhhcyBbYGlzTmV3OiB0cnVlYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5pc05ldygpKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgbmFtZTogeyB0eXBlOiBTdHJpbmcsIGltbXV0YWJsZTogdHJ1ZSB9LFxuICogICAgICAgYWdlOiBOdW1iZXJcbiAqICAgICB9KTtcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0Jywgc2NoZW1hKTtcbiAqXG4gKiAgICAgYXdhaXQgTW9kZWwuY3JlYXRlKHsgbmFtZTogJ3Rlc3QnIH0pO1xuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRPbmUoKTtcbiAqXG4gKiAgICAgZG9jLmlzTmV3OyAvLyBmYWxzZVxuICogICAgIGRvYy5uYW1lID0gJ25ldyBuYW1lJztcbiAqICAgICBkb2MubmFtZTsgLy8gJ3Rlc3QnLCBiZWNhdXNlIGBuYW1lYCBpcyBpbW11dGFibGVcbiAqXG4gKiBNb25nb29zZSBhbHNvIHByZXZlbnRzIGNoYW5naW5nIGltbXV0YWJsZSBwcm9wZXJ0aWVzIHVzaW5nIGB1cGRhdGVPbmUoKWBcbiAqIGFuZCBgdXBkYXRlTWFueSgpYCBiYXNlZCBvbiBbc3RyaWN0IG1vZGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdCkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNb25nb29zZSB3aWxsIHN0cmlwIG91dCB0aGUgYG5hbWVgIHVwZGF0ZSwgYmVjYXVzZSBgbmFtZWAgaXMgaW1tdXRhYmxlXG4gKiAgICAgTW9kZWwudXBkYXRlT25lKHt9LCB7ICRzZXQ6IHsgbmFtZTogJ3Rlc3QyJyB9LCAkaW5jOiB7IGFnZTogMSB9IH0pO1xuICpcbiAqICAgICAvLyBJZiBgc3RyaWN0YCBpcyBzZXQgdG8gJ3Rocm93JywgTW9uZ29vc2Ugd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3VcbiAqICAgICAvLyB1cGRhdGUgYG5hbWVgXG4gKiAgICAgY29uc3QgZXJyID0gYXdhaXQgTW9kZWwudXBkYXRlT25lKHt9LCB7IG5hbWU6ICd0ZXN0MicgfSwgeyBzdHJpY3Q6ICd0aHJvdycgfSkuXG4gKiAgICAgICB0aGVuKCgpID0+IG51bGwsIGVyciA9PiBlcnIpO1xuICogICAgIGVyci5uYW1lOyAvLyBTdHJpY3RNb2RlRXJyb3JcbiAqXG4gKiAgICAgLy8gSWYgYHN0cmljdGAgaXMgYGZhbHNlYCwgTW9uZ29vc2UgYWxsb3dzIHVwZGF0aW5nIGBuYW1lYCBldmVuIHRob3VnaFxuICogICAgIC8vIHRoZSBwcm9wZXJ0eSBpcyBpbW11dGFibGUuXG4gKiAgICAgTW9kZWwudXBkYXRlT25lKHt9LCB7IG5hbWU6ICd0ZXN0MicgfSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYm9vbFxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBpc05ldyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLmlzTmV3KClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuaW1tdXRhYmxlID0gZnVuY3Rpb24oYm9vbCkge1xuICB0aGlzLiRpbW11dGFibGUgPSBib29sO1xuICBoYW5kbGVJbW11dGFibGUodGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlZmluZXMgYSBjdXN0b20gZnVuY3Rpb24gZm9yIHRyYW5zZm9ybWluZyB0aGlzIHBhdGggd2hlbiBjb252ZXJ0aW5nIGEgZG9jdW1lbnQgdG8gSlNPTi5cbiAqXG4gKiBNb25nb29zZSBjYWxscyB0aGlzIGZ1bmN0aW9uIHdpdGggb25lIHBhcmFtZXRlcjogdGhlIGN1cnJlbnQgYHZhbHVlYCBvZiB0aGUgcGF0aC4gTW9uZ29vc2VcbiAqIHRoZW4gdXNlcyB0aGUgcmV0dXJuIHZhbHVlIGluIHRoZSBKU09OIG91dHB1dC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgZGF0ZTogeyB0eXBlOiBEYXRlLCB0cmFuc2Zvcm06IHYgPT4gdi5nZXRGdWxsWWVhcigpIH1cbiAqICAgICB9KTtcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0Jywgc2NoZW1hKTtcbiAqXG4gKiAgICAgYXdhaXQgTW9kZWwuY3JlYXRlKHsgZGF0ZTogbmV3IERhdGUoJzIwMTYtMDYtMDEnKSB9KTtcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNb2RlbC5maW5kT25lKCk7XG4gKlxuICogICAgIGRvYy5kYXRlIGluc3RhbmNlb2YgRGF0ZTsgLy8gdHJ1ZVxuICpcbiAqICAgICBkb2MudG9KU09OKCkuZGF0ZTsgLy8gMjAxNiBhcyBhIG51bWJlclxuICogICAgIEpTT04uc3RyaW5naWZ5KGRvYyk7IC8vICd7XCJfaWRcIjouLi4sXCJkYXRlXCI6MjAxNn0nXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oZm4pIHtcbiAgdGhpcy5vcHRpb25zLnRyYW5zZm9ybSA9IGZuO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgc2V0dGVyIHRvIHRoaXMgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUgKHZhbCkge1xuICogICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB2YWwgPSAnJztcbiAqICAgICAgIHJldHVybiB2YWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2YWwuc3Vic3RyaW5nKDEpO1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gZGVmaW5pbmcgd2l0aGluIHRoZSBzY2hlbWFcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCBzZXQ6IGNhcGl0YWxpemUgfX0pO1xuICpcbiAqICAgICAvLyBvciB3aXRoIHRoZSBTY2hlbWFUeXBlXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSlcbiAqICAgICBzLnBhdGgoJ25hbWUnKS5zZXQoY2FwaXRhbGl6ZSk7XG4gKlxuICogU2V0dGVycyBhbGxvdyB5b3UgdG8gdHJhbnNmb3JtIHRoZSBkYXRhIGJlZm9yZSBpdCBnZXRzIHRvIHRoZSByYXcgbW9uZ29kYlxuICogZG9jdW1lbnQgb3IgcXVlcnkuXG4gKlxuICogU3VwcG9zZSB5b3UgYXJlIGltcGxlbWVudGluZyB1c2VyIHJlZ2lzdHJhdGlvbiBmb3IgYSB3ZWJzaXRlLiBVc2VycyBwcm92aWRlXG4gKiBhbiBlbWFpbCBhbmQgcGFzc3dvcmQsIHdoaWNoIGdldHMgc2F2ZWQgdG8gbW9uZ29kYi4gVGhlIGVtYWlsIGlzIGEgc3RyaW5nXG4gKiB0aGF0IHlvdSB3aWxsIHdhbnQgdG8gbm9ybWFsaXplIHRvIGxvd2VyIGNhc2UsIGluIG9yZGVyIHRvIGF2b2lkIG9uZSBlbWFpbFxuICogaGF2aW5nIG1vcmUgdGhhbiBvbmUgYWNjb3VudCAtLSBlLmcuLCBvdGhlcndpc2UsIGF2ZW51ZUBxLmNvbSBjYW4gYmUgcmVnaXN0ZXJlZCBmb3IgMiBhY2NvdW50cyB2aWEgYXZlbnVlQHEuY29tIGFuZCBBdkVuVWVAUS5Db00uXG4gKlxuICogWW91IGNhbiBzZXQgdXAgZW1haWwgbG93ZXIgY2FzZSBub3JtYWxpemF0aW9uIGVhc2lseSB2aWEgYSBNb25nb29zZSBzZXR0ZXIuXG4gKlxuICogICAgIGZ1bmN0aW9uIHRvTG93ZXIodikge1xuICogICAgICAgcmV0dXJuIHYudG9Mb3dlckNhc2UoKTtcbiAqICAgICB9XG4gKlxuICogICAgIGNvbnN0IFVzZXJTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIGVtYWlsOiB7IHR5cGU6IFN0cmluZywgc2V0OiB0b0xvd2VyIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IGRiLm1vZGVsKCdVc2VyJywgVXNlclNjaGVtYSk7XG4gKlxuICogICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcih7ZW1haWw6ICdBVkVOVUVAUS5DT00nfSk7XG4gKiAgICAgY29uc29sZS5sb2codXNlci5lbWFpbCk7IC8vICdhdmVudWVAcS5jb20nXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgY29uc3QgdXNlciA9IG5ldyBVc2VyKCk7XG4gKiAgICAgdXNlci5lbWFpbCA9ICdBdmVudWVAUS5jb20nO1xuICogICAgIGNvbnNvbGUubG9nKHVzZXIuZW1haWwpOyAvLyAnYXZlbnVlQHEuY29tJ1xuICogICAgIFVzZXIudXBkYXRlT25lKHsgX2lkOiBfaWQgfSwgeyAkc2V0OiB7IGVtYWlsOiAnQVZFTlVFQFEuQ09NJyB9IH0pOyAvLyB1cGRhdGUgdG8gJ2F2ZW51ZUBxLmNvbSdcbiAqXG4gKiBBcyB5b3UgY2FuIHNlZSBhYm92ZSwgc2V0dGVycyBhbGxvdyB5b3UgdG8gdHJhbnNmb3JtIHRoZSBkYXRhIGJlZm9yZSBpdFxuICogc3RvcmVkIGluIE1vbmdvREIsIG9yIGJlZm9yZSBleGVjdXRpbmcgYSBxdWVyeS5cbiAqXG4gKiBfTk9URTogd2UgY291bGQgaGF2ZSBhbHNvIGp1c3QgdXNlZCB0aGUgYnVpbHQtaW4gYGxvd2VyY2FzZTogdHJ1ZWAgU2NoZW1hVHlwZSBvcHRpb24gaW5zdGVhZCBvZiBkZWZpbmluZyBvdXIgb3duIGZ1bmN0aW9uLl9cbiAqXG4gKiAgICAgbmV3IFNjaGVtYSh7IGVtYWlsOiB7IHR5cGU6IFN0cmluZywgbG93ZXJjYXNlOiB0cnVlIH19KVxuICpcbiAqIFNldHRlcnMgYXJlIGFsc28gcGFzc2VkIGEgc2Vjb25kIGFyZ3VtZW50LCB0aGUgc2NoZW1hdHlwZSBvbiB3aGljaCB0aGUgc2V0dGVyIHdhcyBkZWZpbmVkLiBUaGlzIGFsbG93cyBmb3IgdGFpbG9yZWQgYmVoYXZpb3IgYmFzZWQgb24gb3B0aW9ucyBwYXNzZWQgaW4gdGhlIHNjaGVtYS5cbiAqXG4gKiAgICAgZnVuY3Rpb24gaW5zcGVjdG9yICh2YWwsIHByaW9yVmFsdWUsIHNjaGVtYXR5cGUpIHtcbiAqICAgICAgIGlmIChzY2hlbWF0eXBlLm9wdGlvbnMucmVxdWlyZWQpIHtcbiAqICAgICAgICAgcmV0dXJuIHNjaGVtYXR5cGUucGF0aCArICcgaXMgcmVxdWlyZWQnO1xuICogICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgcmV0dXJuIHZhbDtcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogICAgIGNvbnN0IFZpcnVzU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUsIHNldDogaW5zcGVjdG9yIH0sXG4gKiAgICAgICB0YXhvbm9teTogeyB0eXBlOiBTdHJpbmcsIHNldDogaW5zcGVjdG9yIH1cbiAqICAgICB9KVxuICpcbiAqICAgICBjb25zdCBWaXJ1cyA9IGRiLm1vZGVsKCdWaXJ1cycsIFZpcnVzU2NoZW1hKTtcbiAqICAgICBjb25zdCB2ID0gbmV3IFZpcnVzKHsgbmFtZTogJ1BhcnZvdmlyaWRhZScsIHRheG9ub215OiAnUGFydm92aXJpbmFlJyB9KTtcbiAqXG4gKiAgICAgY29uc29sZS5sb2codi5uYW1lKTsgICAgIC8vIG5hbWUgaXMgcmVxdWlyZWRcbiAqICAgICBjb25zb2xlLmxvZyh2LnRheG9ub215KTsgLy8gUGFydm92aXJpbmFlXG4gKlxuICogWW91IGNhbiBhbHNvIHVzZSBzZXR0ZXJzIHRvIG1vZGlmeSBvdGhlciBwcm9wZXJ0aWVzIG9uIHRoZSBkb2N1bWVudC4gSWZcbiAqIHlvdSdyZSBzZXR0aW5nIGEgcHJvcGVydHkgYG5hbWVgIG9uIGEgZG9jdW1lbnQsIHRoZSBzZXR0ZXIgd2lsbCBydW4gd2l0aFxuICogYHRoaXNgIGFzIHRoZSBkb2N1bWVudC4gQmUgY2FyZWZ1bCwgaW4gbW9uZ29vc2UgNSBzZXR0ZXJzIHdpbGwgYWxzbyBydW5cbiAqIHdoZW4gcXVlcnlpbmcgYnkgYG5hbWVgIHdpdGggYHRoaXNgIGFzIHRoZSBxdWVyeS5cbiAqXG4gKiAgICAgY29uc3QgbmFtZVNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGtleXdvcmRzOiBbU3RyaW5nXSB9KTtcbiAqICAgICBuYW1lU2NoZW1hLnBhdGgoJ25hbWUnKS5zZXQoZnVuY3Rpb24odikge1xuICogICAgICAgLy8gTmVlZCB0byBjaGVjayBpZiBgdGhpc2AgaXMgYSBkb2N1bWVudCwgYmVjYXVzZSBpbiBtb25nb29zZSA1XG4gKiAgICAgICAvLyBzZXR0ZXJzIHdpbGwgYWxzbyBydW4gb24gcXVlcmllcywgaW4gd2hpY2ggY2FzZSBgdGhpc2Agd2lsbCBiZSBhXG4gKiAgICAgICAvLyBtb25nb29zZSBxdWVyeSBvYmplY3QuXG4gKiAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIERvY3VtZW50ICYmIHYgIT0gbnVsbCkge1xuICogICAgICAgICB0aGlzLmtleXdvcmRzID0gdi5zcGxpdCgnICcpO1xuICogICAgICAgfVxuICogICAgICAgcmV0dXJuIHY7XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Egc2V0dGVyIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuICB0aGlzLnNldHRlcnMucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgZ2V0dGVyIHRvIHRoaXMgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGZ1bmN0aW9uIGRvYiAodmFsKSB7XG4gKiAgICAgICBpZiAoIXZhbCkgcmV0dXJuIHZhbDtcbiAqICAgICAgIHJldHVybiAodmFsLmdldE1vbnRoKCkgKyAxKSArIFwiL1wiICsgdmFsLmdldERhdGUoKSArIFwiL1wiICsgdmFsLmdldEZ1bGxZZWFyKCk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBkZWZpbmluZyB3aXRoaW4gdGhlIHNjaGVtYVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgYm9ybjogeyB0eXBlOiBEYXRlLCBnZXQ6IGRvYiB9KVxuICpcbiAqICAgICAvLyBvciBieSByZXRyZWl2aW5nIGl0cyBTY2hlbWFUeXBlXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBib3JuOiBEYXRlIH0pXG4gKiAgICAgcy5wYXRoKCdib3JuJykuZ2V0KGRvYilcbiAqXG4gKiBHZXR0ZXJzIGFsbG93IHlvdSB0byB0cmFuc2Zvcm0gdGhlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXRhIGFzIGl0IHRyYXZlbHMgZnJvbSB0aGUgcmF3IG1vbmdvZGIgZG9jdW1lbnQgdG8gdGhlIHZhbHVlIHRoYXQgeW91IHNlZS5cbiAqXG4gKiBTdXBwb3NlIHlvdSBhcmUgc3RvcmluZyBjcmVkaXQgY2FyZCBudW1iZXJzIGFuZCB5b3Ugd2FudCB0byBoaWRlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBsYXN0IDQgZGlnaXRzIHRvIHRoZSBtb25nb29zZSB1c2VyLiBZb3UgY2FuIGRvIHNvIGJ5IGRlZmluaW5nIGEgZ2V0dGVyIGluIHRoZSBmb2xsb3dpbmcgd2F5OlxuICpcbiAqICAgICBmdW5jdGlvbiBvYmZ1c2NhdGUgKGNjKSB7XG4gKiAgICAgICByZXR1cm4gJyoqKiotKioqKi0qKioqLScgKyBjYy5zbGljZShjYy5sZW5ndGgtNCwgY2MubGVuZ3RoKTtcbiAqICAgICB9XG4gKlxuICogICAgIGNvbnN0IEFjY291bnRTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIGNyZWRpdENhcmROdW1iZXI6IHsgdHlwZTogU3RyaW5nLCBnZXQ6IG9iZnVzY2F0ZSB9XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGNvbnN0IEFjY291bnQgPSBkYi5tb2RlbCgnQWNjb3VudCcsIEFjY291bnRTY2hlbWEpO1xuICpcbiAqICAgICBBY2NvdW50LmZpbmRCeUlkKGlkLCBmdW5jdGlvbiAoZXJyLCBmb3VuZCkge1xuICogICAgICAgY29uc29sZS5sb2coZm91bmQuY3JlZGl0Q2FyZE51bWJlcik7IC8vICcqKioqLSoqKiotKioqKi0xMjM0J1xuICogICAgIH0pO1xuICpcbiAqIEdldHRlcnMgYXJlIGFsc28gcGFzc2VkIGEgc2Vjb25kIGFyZ3VtZW50LCB0aGUgc2NoZW1hdHlwZSBvbiB3aGljaCB0aGUgZ2V0dGVyIHdhcyBkZWZpbmVkLiBUaGlzIGFsbG93cyBmb3IgdGFpbG9yZWQgYmVoYXZpb3IgYmFzZWQgb24gb3B0aW9ucyBwYXNzZWQgaW4gdGhlIHNjaGVtYS5cbiAqXG4gKiAgICAgZnVuY3Rpb24gaW5zcGVjdG9yICh2YWwsIHByaW9yVmFsdWUsIHNjaGVtYXR5cGUpIHtcbiAqICAgICAgIGlmIChzY2hlbWF0eXBlLm9wdGlvbnMucmVxdWlyZWQpIHtcbiAqICAgICAgICAgcmV0dXJuIHNjaGVtYXR5cGUucGF0aCArICcgaXMgcmVxdWlyZWQnO1xuICogICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgcmV0dXJuIHNjaGVtYXR5cGUucGF0aCArICcgaXMgbm90JztcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogICAgIGNvbnN0IFZpcnVzU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUsIGdldDogaW5zcGVjdG9yIH0sXG4gKiAgICAgICB0YXhvbm9teTogeyB0eXBlOiBTdHJpbmcsIGdldDogaW5zcGVjdG9yIH1cbiAqICAgICB9KVxuICpcbiAqICAgICBjb25zdCBWaXJ1cyA9IGRiLm1vZGVsKCdWaXJ1cycsIFZpcnVzU2NoZW1hKTtcbiAqXG4gKiAgICAgVmlydXMuZmluZEJ5SWQoaWQsIGZ1bmN0aW9uIChlcnIsIHZpcnVzKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyh2aXJ1cy5uYW1lKTsgICAgIC8vIG5hbWUgaXMgcmVxdWlyZWRcbiAqICAgICAgIGNvbnNvbGUubG9nKHZpcnVzLnRheG9ub215KTsgLy8gdGF4b25vbXkgaXMgbm90XG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmbikge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBnZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG4gIHRoaXMuZ2V0dGVycy5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgdmFsaWRhdG9yKHMpIGZvciB0aGlzIGRvY3VtZW50IHBhdGguXG4gKlxuICogVmFsaWRhdG9ycyBhbHdheXMgcmVjZWl2ZSB0aGUgdmFsdWUgdG8gdmFsaWRhdGUgYXMgdGhlaXIgZmlyc3QgYXJndW1lbnQgYW5kXG4gKiBtdXN0IHJldHVybiBgQm9vbGVhbmAuIFJldHVybmluZyBgZmFsc2VgIG9yIHRocm93aW5nIGFuIGVycm9yIG1lYW5zXG4gKiB2YWxpZGF0aW9uIGZhaWxlZC5cbiAqXG4gKiBUaGUgZXJyb3IgbWVzc2FnZSBhcmd1bWVudCBpcyBvcHRpb25hbC4gSWYgbm90IHBhc3NlZCwgdGhlIFtkZWZhdWx0IGdlbmVyaWMgZXJyb3IgbWVzc2FnZSB0ZW1wbGF0ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzKSB3aWxsIGJlIHVzZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBtYWtlIHN1cmUgZXZlcnkgdmFsdWUgaXMgZXF1YWwgdG8gXCJzb21ldGhpbmdcIlxuICogICAgIGZ1bmN0aW9uIHZhbGlkYXRvciAodmFsKSB7XG4gKiAgICAgICByZXR1cm4gdmFsID09PSAnc29tZXRoaW5nJztcbiAqICAgICB9XG4gKiAgICAgbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCB2YWxpZGF0ZTogdmFsaWRhdG9yIH19KTtcbiAqXG4gKiAgICAgLy8gd2l0aCBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKlxuICogICAgIGNvbnN0IGN1c3RvbSA9IFt2YWxpZGF0b3IsICdVaCBvaCwge1BBVEh9IGRvZXMgbm90IGVxdWFsIFwic29tZXRoaW5nXCIuJ11cbiAqICAgICBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHZhbGlkYXRlOiBjdXN0b20gfX0pO1xuICpcbiAqICAgICAvLyBhZGRpbmcgbWFueSB2YWxpZGF0b3JzIGF0IGEgdGltZVxuICpcbiAqICAgICBjb25zdCBtYW55ID0gW1xuICogICAgICAgICB7IHZhbGlkYXRvcjogdmFsaWRhdG9yLCBtZXNzYWdlOiAndWggb2gnIH1cbiAqICAgICAgICwgeyB2YWxpZGF0b3I6IGFub3RoZXJWYWxpZGF0b3IsIG1lc3NhZ2U6ICdmYWlsZWQnIH1cbiAqICAgICBdXG4gKiAgICAgbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCB2YWxpZGF0ZTogbWFueSB9fSk7XG4gKlxuICogICAgIC8vIG9yIHV0aWxpemluZyBTY2hlbWFUeXBlIG1ldGhvZHMgZGlyZWN0bHk6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiAnc3RyaW5nJyB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLnZhbGlkYXRlKHZhbGlkYXRvciwgJ3ZhbGlkYXRpb24gb2YgYHtQQVRIfWAgZmFpbGVkIHdpdGggdmFsdWUgYHtWQUxVRX1gJyk7XG4gKlxuICogIyMjIyBFcnJvciBtZXNzYWdlIHRlbXBsYXRlczpcbiAqXG4gKiBCZWxvdyBpcyBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHRlbXBsYXRlIGtleXdvcmRzOlxuICpcbiAqIC0gUEFUSDogVGhlIHNjaGVtYSBwYXRoIHdoZXJlIHRoZSBlcnJvciBpcyBiZWluZyB0cmlnZ2VyZWQuXG4gKiAtIFZBTFVFOiBUaGUgdmFsdWUgYXNzaWduZWQgdG8gdGhlIFBBVEggdGhhdCBpcyB0cmlnZ2VyaW5nIHRoZSBlcnJvci5cbiAqIC0gS0lORDogVGhlIHZhbGlkYXRpb24gcHJvcGVydHkgdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yIGkuZS4gcmVxdWlyZWQuXG4gKiAtIFJFQVNPTjogVGhlIGVycm9yIG9iamVjdCB0aGF0IGNhdXNlZCB0aGlzIGVycm9yIGlmIHRoZXJlIHdhcyBvbmUuXG4gKlxuICogSWYgTW9uZ29vc2UncyBidWlsdC1pbiBlcnJvciBtZXNzYWdlIHRlbXBsYXRpbmcgaXNuJ3QgZW5vdWdoLCBNb25nb29zZVxuICogc3VwcG9ydHMgc2V0dGluZyB0aGUgYG1lc3NhZ2VgIHByb3BlcnR5IHRvIGEgZnVuY3Rpb24uXG4gKlxuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykudmFsaWRhdGUoe1xuICogICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbih2KSB7IHJldHVybiB2Lmxlbmd0aCA+IDU7IH0sXG4gKiAgICAgICAvLyBgZXJyb3JzWyduYW1lJ11gIHdpbGwgYmUgXCJuYW1lIG11c3QgaGF2ZSBsZW5ndGggNSwgZ290ICdmb28nXCJcbiAqICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uKHByb3BzKSB7XG4gKiAgICAgICAgIHJldHVybiBgJHtwcm9wcy5wYXRofSBtdXN0IGhhdmUgbGVuZ3RoIDUsIGdvdCAnJHtwcm9wcy52YWx1ZX0nYDtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBUbyBieXBhc3MgTW9uZ29vc2UncyBlcnJvciBtZXNzYWdlcyBhbmQganVzdCBjb3B5IHRoZSBlcnJvciBtZXNzYWdlIHRoYXRcbiAqIHRoZSB2YWxpZGF0b3IgdGhyb3dzLCBkbyB0aGlzOlxuICpcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLnZhbGlkYXRlKHtcbiAqICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcignT29wcyEnKTsgfSxcbiAqICAgICAgIC8vIGBlcnJvcnNbJ25hbWUnXWAgd2lsbCBiZSBcIk9vcHMhXCJcbiAqICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uKHByb3BzKSB7IHJldHVybiBwcm9wcy5yZWFzb24ubWVzc2FnZTsgfVxuICogICAgIH0pO1xuICpcbiAqICMjIyMgQXN5bmNocm9ub3VzIHZhbGlkYXRpb246XG4gKlxuICogTW9uZ29vc2Ugc3VwcG9ydHMgdmFsaWRhdG9ycyB0aGF0IHJldHVybiBhIHByb21pc2UuIEEgdmFsaWRhdG9yIHRoYXQgcmV0dXJuc1xuICogYSBwcm9taXNlIGlzIGNhbGxlZCBhbiBfYXN5bmMgdmFsaWRhdG9yXy4gQXN5bmMgdmFsaWRhdG9ycyBydW4gaW5cbiAqIHBhcmFsbGVsLCBhbmQgYHZhbGlkYXRlKClgIHdpbGwgd2FpdCB1bnRpbCBhbGwgYXN5bmMgdmFsaWRhdG9ycyBoYXZlIHNldHRsZWQuXG4gKlxuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykudmFsaWRhdGUoe1xuICogICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAqICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAqICAgICAgICAgICByZXNvbHZlKGZhbHNlKTsgLy8gdmFsaWRhdGlvbiBmYWlsZWRcbiAqICAgICAgICAgfSk7XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogWW91IG1pZ2h0IHVzZSBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyB0byByZXRyZWl2ZSBvdGhlciBkb2N1bWVudHMgZnJvbSB0aGUgZGF0YWJhc2UgdG8gdmFsaWRhdGUgYWdhaW5zdCBvciB0byBtZWV0IG90aGVyIEkvTyBib3VuZCB2YWxpZGF0aW9uIG5lZWRzLlxuICpcbiAqIFZhbGlkYXRpb24gb2NjdXJzIGBwcmUoJ3NhdmUnKWAgb3Igd2hlbmV2ZXIgeW91IG1hbnVhbGx5IGV4ZWN1dGUgW2RvY3VtZW50I3ZhbGlkYXRlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlKCkpLlxuICpcbiAqIElmIHZhbGlkYXRpb24gZmFpbHMgZHVyaW5nIGBwcmUoJ3NhdmUnKWAgYW5kIG5vIGNhbGxiYWNrIHdhcyBwYXNzZWQgdG8gcmVjZWl2ZSB0aGUgZXJyb3IsIGFuIGBlcnJvcmAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIG9uIHlvdXIgTW9kZWxzIGFzc29jaWF0ZWQgZGIgW2Nvbm5lY3Rpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvY29ubmVjdGlvbi5odG1sI0Nvbm5lY3Rpb24oKSksIHBhc3NpbmcgdGhlIHZhbGlkYXRpb24gZXJyb3Igb2JqZWN0IGFsb25nLlxuICpcbiAqICAgICBjb25zdCBjb25uID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbiguLik7XG4gKiAgICAgY29ubi5vbignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gKlxuICogICAgIGNvbnN0IFByb2R1Y3QgPSBjb25uLm1vZGVsKCdQcm9kdWN0JywgeW91clNjaGVtYSk7XG4gKiAgICAgY29uc3QgZHZkID0gbmV3IFByb2R1Y3QoLi4pO1xuICogICAgIGR2ZC5zYXZlKCk7IC8vIGVtaXRzIGVycm9yIG9uIHRoZSBgY29ubmAgYWJvdmVcbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBoYW5kbGUgdGhlc2UgZXJyb3JzIGF0IHRoZSBNb2RlbCBsZXZlbCwgYWRkIGFuIGBlcnJvcmBcbiAqIGxpc3RlbmVyIHRvIHlvdXIgTW9kZWwgYXMgc2hvd24gYmVsb3cuXG4gKlxuICogICAgIC8vIHJlZ2lzdGVyaW5nIGFuIGVycm9yIGxpc3RlbmVyIG9uIHRoZSBNb2RlbCBsZXRzIHVzIGhhbmRsZSBlcnJvcnMgbW9yZSBsb2NhbGx5XG4gKiAgICAgUHJvZHVjdC5vbignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gKlxuICogQHBhcmFtIHtSZWdFeHB8RnVuY3Rpb258T2JqZWN0fSBvYmogdmFsaWRhdG9yIGZ1bmN0aW9uLCBvciBoYXNoIGRlc2NyaWJpbmcgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW29iai52YWxpZGF0b3JdIHZhbGlkYXRvciBmdW5jdGlvbi4gSWYgdGhlIHZhbGlkYXRvciBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgIG9yIGEgdHJ1dGh5IHZhbHVlLCB2YWxpZGF0aW9uIHN1Y2NlZWRzLiBJZiBpdCByZXR1cm5zIFtmYWxzeV0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL2ZhbHN5KSAoZXhjZXB0IGB1bmRlZmluZWRgKSBvciB0aHJvd3MgYW4gZXJyb3IsIHZhbGlkYXRpb24gZmFpbHMuXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW29iai5tZXNzYWdlXSBvcHRpb25hbCBlcnJvciBtZXNzYWdlLiBJZiBmdW5jdGlvbiwgc2hvdWxkIHJldHVybiB0aGUgZXJyb3IgbWVzc2FnZSBhcyBhIHN0cmluZ1xuICogQHBhcmFtIHtCb29sZWFufSBbb2JqLnByb3BzUGFyYW1ldGVyPWZhbHNlXSBJZiB0cnVlLCBNb25nb29zZSB3aWxsIHBhc3MgdGhlIHZhbGlkYXRvciBwcm9wZXJ0aWVzIG9iamVjdCAod2l0aCB0aGUgYHZhbGlkYXRvcmAgZnVuY3Rpb24sIGBtZXNzYWdlYCwgZXRjLikgYXMgdGhlIDJuZCBhcmcgdG8gdGhlIHZhbGlkYXRvciBmdW5jdGlvbi4gVGhpcyBpcyBkaXNhYmxlZCBieSBkZWZhdWx0IGJlY2F1c2UgbWFueSB2YWxpZGF0b3JzIFtyZWx5IG9uIHBvc2l0aW9uYWwgYXJnc10oaHR0cHM6Ly9naXRodWIuY29tL2Nocmlzby92YWxpZGF0b3IuanMjdmFsaWRhdG9ycyksIHNvIHR1cm5pbmcgdGhpcyBvbiBtYXkgY2F1c2UgdW5wcmVkaWN0YWJsZSBiZWhhdmlvciBpbiBleHRlcm5hbCB2YWxpZGF0b3JzLlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtlcnJvck1zZ10gb3B0aW9uYWwgZXJyb3IgbWVzc2FnZS4gSWYgZnVuY3Rpb24sIHNob3VsZCByZXR1cm4gdGhlIGVycm9yIG1lc3NhZ2UgYXMgYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gb3B0aW9uYWwgdmFsaWRhdG9yIHR5cGVcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbihvYmosIG1lc3NhZ2UsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicgfHwgb2JqICYmIHV0aWxzLmdldEZ1bmN0aW9uTmFtZShvYmouY29uc3RydWN0b3IpID09PSAnUmVnRXhwJykge1xuICAgIGxldCBwcm9wZXJ0aWVzO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcGVydGllcyA9IHsgdmFsaWRhdG9yOiBvYmosIG1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgICAgIHByb3BlcnRpZXMudHlwZSA9IHR5cGUgfHwgJ3VzZXIgZGVmaW5lZCc7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgT2JqZWN0ICYmICF0eXBlKSB7XG4gICAgICBwcm9wZXJ0aWVzID0gaXNTaW1wbGVWYWxpZGF0b3IobWVzc2FnZSkgPyBPYmplY3QuYXNzaWduKHt9LCBtZXNzYWdlKSA6IGNsb25lKG1lc3NhZ2UpO1xuICAgICAgaWYgKCFwcm9wZXJ0aWVzLm1lc3NhZ2UpIHtcbiAgICAgICAgcHJvcGVydGllcy5tZXNzYWdlID0gcHJvcGVydGllcy5tc2c7XG4gICAgICB9XG4gICAgICBwcm9wZXJ0aWVzLnZhbGlkYXRvciA9IG9iajtcbiAgICAgIHByb3BlcnRpZXMudHlwZSA9IHByb3BlcnRpZXMudHlwZSB8fCAndXNlciBkZWZpbmVkJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlID0gTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5nZW5lcmFsLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdHlwZSA9ICd1c2VyIGRlZmluZWQnO1xuICAgICAgfVxuICAgICAgcHJvcGVydGllcyA9IHsgbWVzc2FnZTogbWVzc2FnZSwgdHlwZTogdHlwZSwgdmFsaWRhdG9yOiBvYmogfTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbGlkYXRvcnMucHVzaChwcm9wZXJ0aWVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxldCBpO1xuICBsZXQgbGVuZ3RoO1xuICBsZXQgYXJnO1xuXG4gIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoIXV0aWxzLmlzUE9KTyhhcmcpKSB7XG4gICAgICBjb25zdCBtc2cgPSAnSW52YWxpZCB2YWxpZGF0b3IuIFJlY2VpdmVkICgnICsgdHlwZW9mIGFyZyArICcpICdcbiAgICAgICAgKyBhcmdcbiAgICAgICAgKyAnLiBTZWUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWF0eXBlLmh0bWwjU2NoZW1hVHlwZS5wcm90b3R5cGUudmFsaWRhdGUoKSc7XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICB0aGlzLnZhbGlkYXRlKGFyZy52YWxpZGF0b3IsIGFyZyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIHJlcXVpcmVkIHZhbGlkYXRvciB0byB0aGlzIFNjaGVtYVR5cGUuIFRoZSB2YWxpZGF0b3IgZ2V0cyBhZGRlZFxuICogdG8gdGhlIGZyb250IG9mIHRoaXMgU2NoZW1hVHlwZSdzIHZhbGlkYXRvcnMgYXJyYXkgdXNpbmcgYHVuc2hpZnQoKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGJvcm46IHsgdHlwZTogRGF0ZSwgcmVxdWlyZWQ6IHRydWUgfSlcbiAqXG4gKiAgICAgLy8gb3Igd2l0aCBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGJvcm46IHsgdHlwZTogRGF0ZSwgcmVxdWlyZWQ6ICd7UEFUSH0gaXMgcmVxdWlyZWQhJyB9KVxuICpcbiAqICAgICAvLyBvciB3aXRoIGEgZnVuY3Rpb25cbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgdXNlcklkOiBPYmplY3RJZCxcbiAqICAgICAgIHVzZXJuYW1lOiB7XG4gKiAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAqICAgICAgICAgcmVxdWlyZWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy51c2VySWQgIT0gbnVsbDsgfVxuICogICAgICAgfVxuICogICAgIH0pXG4gKlxuICogICAgIC8vIG9yIHdpdGggYSBmdW5jdGlvbiBhbmQgYSBjdXN0b20gbWVzc2FnZVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIHVzZXJJZDogT2JqZWN0SWQsXG4gKiAgICAgICB1c2VybmFtZToge1xuICogICAgICAgICB0eXBlOiBTdHJpbmcsXG4gKiAgICAgICAgIHJlcXVpcmVkOiBbXG4gKiAgICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnVzZXJJZCAhPSBudWxsOyB9LFxuICogICAgICAgICAgICd1c2VybmFtZSBpcyByZXF1aXJlZCBpZiBpZCBpcyBzcGVjaWZpZWQnXG4gKiAgICAgICAgIF1cbiAqICAgICAgIH1cbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBvciB0aHJvdWdoIHRoZSBwYXRoIEFQSVxuICpcbiAqICAgICBzLnBhdGgoJ25hbWUnKS5yZXF1aXJlZCh0cnVlKTtcbiAqXG4gKiAgICAgLy8gd2l0aCBjdXN0b20gZXJyb3IgbWVzc2FnaW5nXG4gKlxuICogICAgIHMucGF0aCgnbmFtZScpLnJlcXVpcmVkKHRydWUsICdncnJyIDooICcpO1xuICpcbiAqICAgICAvLyBvciBtYWtlIGEgcGF0aCBjb25kaXRpb25hbGx5IHJlcXVpcmVkIGJhc2VkIG9uIGEgZnVuY3Rpb25cbiAqICAgICBjb25zdCBpc092ZXIxOCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5hZ2UgPj0gMTg7IH07XG4gKiAgICAgcy5wYXRoKCd2b3RlclJlZ2lzdHJhdGlvbklkJykucmVxdWlyZWQoaXNPdmVyMTgpO1xuICpcbiAqIFRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0aGUgU2NoZW1hVHlwZSdzIGBjaGVja1JlcXVpcmVkYCBmdW5jdGlvbiB0b1xuICogZGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgdGhlIHJlcXVpcmVkIHZhbGlkYXRvci4gQnkgZGVmYXVsdCxcbiAqIGEgdmFsdWUgc2F0aXNmaWVzIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgaWYgYHZhbCAhPSBudWxsYCAodGhhdCBpcywgaWZcbiAqIHRoZSB2YWx1ZSBpcyBub3QgbnVsbCBub3IgdW5kZWZpbmVkKS4gSG93ZXZlciwgbW9zdCBidWlsdC1pbiBtb25nb29zZSBzY2hlbWFcbiAqIHR5cGVzIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGBjaGVja1JlcXVpcmVkYCBmdW5jdGlvbjpcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb258T2JqZWN0fSByZXF1aXJlZCBlbmFibGUvZGlzYWJsZSB0aGUgdmFsaWRhdG9yLCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgcmVxdWlyZWQgYm9vbGVhbiwgb3Igb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMuaXNSZXF1aXJlZF0gZW5hYmxlL2Rpc2FibGUgdGhlIHZhbGlkYXRvciwgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHJlcXVpcmVkIGJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLkVycm9yQ29uc3RydWN0b3JdIGN1c3RvbSBlcnJvciBjb25zdHJ1Y3Rvci4gVGhlIGNvbnN0cnVjdG9yIHJlY2VpdmVzIDEgcGFyYW1ldGVyLCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgdmFsaWRhdG9yIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIEN1c3RvbWl6ZWQgRXJyb3IgTWVzc2FnZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzXG4gKiBAc2VlIFNjaGVtYUFycmF5I2NoZWNrUmVxdWlyZWQgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWFhcnJheS5odG1sI1NjaGVtYUFycmF5LnByb3RvdHlwZS5jaGVja1JlcXVpcmVkKClcbiAqIEBzZWUgU2NoZW1hQm9vbGVhbiNjaGVja1JlcXVpcmVkIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hYm9vbGVhbi5odG1sI1NjaGVtYUJvb2xlYW4ucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQoKVxuICogQHNlZSBTY2hlbWFCdWZmZXIjY2hlY2tSZXF1aXJlZCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYWJ1ZmZlci5odG1sI1NjaGVtYUJ1ZmZlci5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCgpXG4gKiBAc2VlIFNjaGVtYU51bWJlciNjaGVja1JlcXVpcmVkIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hbnVtYmVyLmh0bWwjU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkKClcbiAqIEBzZWUgU2NoZW1hT2JqZWN0SWQjY2hlY2tSZXF1aXJlZCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYW9iamVjdGlkLmh0bWwjT2JqZWN0SWQucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQoKVxuICogQHNlZSBTY2hlbWFTdHJpbmcjY2hlY2tSZXF1aXJlZCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXN0cmluZy5odG1sI1NjaGVtYVN0cmluZy5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCgpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnJlcXVpcmVkID0gZnVuY3Rpb24ocmVxdWlyZWQsIG1lc3NhZ2UpIHtcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSB7fTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgcmVxdWlyZWQgPT0gbnVsbCkge1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5maWx0ZXIoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9yICE9PSB0aGlzLnJlcXVpcmVkVmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5pc1JlcXVpcmVkID0gZmFsc2U7XG4gICAgZGVsZXRlIHRoaXMub3JpZ2luYWxSZXF1aXJlZFZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ29iamVjdCcpIHtcbiAgICBjdXN0b21PcHRpb25zID0gcmVxdWlyZWQ7XG4gICAgbWVzc2FnZSA9IGN1c3RvbU9wdGlvbnMubWVzc2FnZSB8fCBtZXNzYWdlO1xuICAgIHJlcXVpcmVkID0gcmVxdWlyZWQuaXNSZXF1aXJlZDtcbiAgfVxuXG4gIGlmIChyZXF1aXJlZCA9PT0gZmFsc2UpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvciAhPT0gdGhpcy5yZXF1aXJlZFZhbGlkYXRvcjtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuaXNSZXF1aXJlZCA9IGZhbHNlO1xuICAgIGRlbGV0ZSB0aGlzLm9yaWdpbmFsUmVxdWlyZWRWYWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgdGhpcy5pc1JlcXVpcmVkID0gdHJ1ZTtcblxuICB0aGlzLnJlcXVpcmVkVmFsaWRhdG9yID0gZnVuY3Rpb24odikge1xuICAgIGNvbnN0IGNhY2hlZFJlcXVpcmVkID0gdGhpcyAmJiB0aGlzLiRfXyAmJiB0aGlzLiRfXy5jYWNoZWRSZXF1aXJlZDtcblxuICAgIC8vIG5vIHZhbGlkYXRpb24gd2hlbiB0aGlzIHBhdGggd2Fzbid0IHNlbGVjdGVkIGluIHRoZSBxdWVyeS5cbiAgICBpZiAoY2FjaGVkUmVxdWlyZWQgIT0gbnVsbCAmJiAhdGhpcy4kX19pc1NlbGVjdGVkKF90aGlzLnBhdGgpICYmICF0aGlzW2RvY3VtZW50SXNNb2RpZmllZF0oX3RoaXMucGF0aCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGAkY2FjaGVkUmVxdWlyZWRgIGdldHMgc2V0IGluIGBfZXZhbHVhdGVSZXF1aXJlZEZ1bmN0aW9ucygpYCBzbyB3ZVxuICAgIC8vIGRvbid0IGNhbGwgcmVxdWlyZWQgZnVuY3Rpb25zIG11bHRpcGxlIHRpbWVzIGluIG9uZSB2YWxpZGF0ZSBjYWxsXG4gICAgLy8gU2VlIGdoLTY4MDFcbiAgICBpZiAoY2FjaGVkUmVxdWlyZWQgIT0gbnVsbCAmJiBfdGhpcy5wYXRoIGluIGNhY2hlZFJlcXVpcmVkKSB7XG4gICAgICBjb25zdCByZXMgPSBjYWNoZWRSZXF1aXJlZFtfdGhpcy5wYXRoXSA/XG4gICAgICAgIF90aGlzLmNoZWNrUmVxdWlyZWQodiwgdGhpcykgOlxuICAgICAgICB0cnVlO1xuICAgICAgZGVsZXRlIGNhY2hlZFJlcXVpcmVkW190aGlzLnBhdGhdO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHJlcXVpcmVkLmFwcGx5KHRoaXMpID8gX3RoaXMuY2hlY2tSZXF1aXJlZCh2LCB0aGlzKSA6IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzLmNoZWNrUmVxdWlyZWQodiwgdGhpcyk7XG4gIH07XG4gIHRoaXMub3JpZ2luYWxSZXF1aXJlZFZhbHVlID0gcmVxdWlyZWQ7XG5cbiAgaWYgKHR5cGVvZiByZXF1aXJlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gcmVxdWlyZWQ7XG4gICAgcmVxdWlyZWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBtc2cgPSBtZXNzYWdlIHx8IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuZ2VuZXJhbC5yZXF1aXJlZDtcbiAgdGhpcy52YWxpZGF0b3JzLnVuc2hpZnQoT2JqZWN0LmFzc2lnbih7fSwgY3VzdG9tT3B0aW9ucywge1xuICAgIHZhbGlkYXRvcjogdGhpcy5yZXF1aXJlZFZhbGlkYXRvcixcbiAgICBtZXNzYWdlOiBtc2csXG4gICAgdHlwZTogJ3JlcXVpcmVkJ1xuICB9KSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbW9kZWwgdGhhdCB0aGlzIHBhdGggcmVmZXJzIHRvLiBUaGlzIGlzIHRoZSBvcHRpb24gdGhhdCBbcG9wdWxhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sKVxuICogbG9va3MgYXQgdG8gZGV0ZXJtaW5lIHRoZSBmb3JlaWduIGNvbGxlY3Rpb24gaXQgc2hvdWxkIHF1ZXJ5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgdXNlclNjaGVtYSk7XG4gKlxuICogICAgIGNvbnN0IHBvc3RTY2hlbWEgPSBuZXcgU2NoZW1hKHsgdXNlcjogbW9uZ29vc2UuT2JqZWN0SWQgfSk7XG4gKiAgICAgcG9zdFNjaGVtYS5wYXRoKCd1c2VyJykucmVmKCdVc2VyJyk7IC8vIENhbiBzZXQgcmVmIHRvIGEgbW9kZWwgbmFtZVxuICogICAgIHBvc3RTY2hlbWEucGF0aCgndXNlcicpLnJlZihVc2VyKTsgLy8gT3IgYSBtb2RlbCBjbGFzc1xuICogICAgIHBvc3RTY2hlbWEucGF0aCgndXNlcicpLnJlZigoKSA9PiAnVXNlcicpOyAvLyBPciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbW9kZWwgbmFtZVxuICogICAgIHBvc3RTY2hlbWEucGF0aCgndXNlcicpLnJlZigoKSA9PiBVc2VyKTsgLy8gT3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1vZGVsIGNsYXNzXG4gKlxuICogICAgIC8vIE9yIHlvdSBjYW4ganVzdCBkZWNsYXJlIHRoZSBgcmVmYCBpbmxpbmUgaW4geW91ciBzY2hlbWFcbiAqICAgICBjb25zdCBwb3N0U2NoZW1hMiA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgdXNlcjogeyB0eXBlOiBtb25nb29zZS5PYmplY3RJZCwgcmVmOiBVc2VyIH1cbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xNb2RlbHxGdW5jdGlvbn0gcmVmIGVpdGhlciBhIG1vZGVsIG5hbWUsIGEgW01vZGVsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbW9kZWxzLmh0bWwpLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIG1vZGVsIG5hbWUgb3IgbW9kZWwuXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKHJlZikge1xuICB0aGlzLm9wdGlvbnMucmVmID0gcmVmO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgZGVmYXVsdCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSB0aGUgc2NvcGUgd2hpY2ggY2FsbGJhY2sgYXJlIGV4ZWN1dGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEByZXR1cm4ge0FueX0gVGhlIFN0b3JlZCBkZWZhdWx0IHZhbHVlLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uKHNjb3BlLCBpbml0LCBvcHRpb25zKSB7XG4gIGxldCByZXQ7XG4gIGlmICh0eXBlb2YgdGhpcy5kZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9PT0gRGF0ZS5ub3cgfHxcbiAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID09PSBBcnJheSB8fFxuICAgICAgdGhpcy5kZWZhdWx0VmFsdWUubmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0aWQnXG4gICAgKSB7XG4gICAgICByZXQgPSB0aGlzLmRlZmF1bHRWYWx1ZS5jYWxsKHNjb3BlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ID0gdGhpcy5kZWZhdWx0VmFsdWUuY2FsbChzY29wZSwgc2NvcGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXQgPSB0aGlzLmRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwgJiYgcmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ29iamVjdCcgJiYgKCF0aGlzLm9wdGlvbnMgfHwgIXRoaXMub3B0aW9ucy5zaGFyZWQpKSB7XG4gICAgICByZXQgPSBjbG9uZShyZXQpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2tpcENhc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBseVNldHRlcnMocmV0LCBzY29wZSk7XG4gICAgfVxuXG4gICAgY29uc3QgY2FzdGVkID0gdGhpcy5hcHBseVNldHRlcnMocmV0LCBzY29wZSwgaW5pdCwgdW5kZWZpbmVkLCBzZXRPcHRpb25zRm9yRGVmYXVsdHMpO1xuICAgIGlmIChjYXN0ZWQgJiYgIUFycmF5LmlzQXJyYXkoY2FzdGVkKSAmJiBjYXN0ZWQuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICBjYXN0ZWQuJF9fcGFyZW50ID0gc2NvcGU7XG4gICAgfVxuICAgIHJldHVybiBjYXN0ZWQ7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQXBwbGllcyBzZXR0ZXJzIHdpdGhvdXQgY2FzdGluZ1xuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtBbnl9IHNjb3BlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEBwYXJhbSB7QW55fSBwcmlvclZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5fYXBwbHlTZXR0ZXJzID0gZnVuY3Rpb24odmFsdWUsIHNjb3BlLCBpbml0LCBwcmlvclZhbCwgb3B0aW9ucykge1xuICBsZXQgdiA9IHZhbHVlO1xuICBpZiAoaW5pdCkge1xuICAgIHJldHVybiB2O1xuICB9XG4gIGNvbnN0IHNldHRlcnMgPSB0aGlzLnNldHRlcnM7XG5cbiAgZm9yIChsZXQgaSA9IHNldHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2ID0gc2V0dGVyc1tpXS5jYWxsKHNjb3BlLCB2LCBwcmlvclZhbCwgdGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdjtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuX2Nhc3ROdWxsaXNoID0gZnVuY3Rpb24gX2Nhc3ROdWxsaXNoKHYpIHtcbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgc2V0dGVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEByZXR1cm4ge0FueX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmFwcGx5U2V0dGVycyA9IGZ1bmN0aW9uKHZhbHVlLCBzY29wZSwgaW5pdCwgcHJpb3JWYWwsIG9wdGlvbnMpIHtcbiAgbGV0IHYgPSB0aGlzLl9hcHBseVNldHRlcnModmFsdWUsIHNjb3BlLCBpbml0LCBwcmlvclZhbCwgb3B0aW9ucyk7XG4gIGlmICh2ID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdE51bGxpc2godik7XG4gIH1cbiAgLy8gZG8gbm90IGNhc3QgdW50aWwgYWxsIHNldHRlcnMgYXJlIGFwcGxpZWQgIzY2NVxuICB2ID0gdGhpcy5jYXN0KHYsIHNjb3BlLCBpbml0LCBwcmlvclZhbCwgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgZ2V0dGVycyB0byBhIHZhbHVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEByZXR1cm4ge0FueX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmFwcGx5R2V0dGVycyA9IGZ1bmN0aW9uKHZhbHVlLCBzY29wZSkge1xuICBsZXQgdiA9IHZhbHVlO1xuICBjb25zdCBnZXR0ZXJzID0gdGhpcy5nZXR0ZXJzO1xuICBjb25zdCBsZW4gPSBnZXR0ZXJzLmxlbmd0aDtcblxuICBpZiAobGVuID09PSAwKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdiA9IGdldHRlcnNbaV0uY2FsbChzY29wZSwgdiwgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogU2V0cyBkZWZhdWx0IGBzZWxlY3QoKWAgYmVoYXZpb3IgZm9yIHRoaXMgcGF0aC5cbiAqXG4gKiBTZXQgdG8gYHRydWVgIGlmIHRoaXMgcGF0aCBzaG91bGQgYWx3YXlzIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRzLCBgZmFsc2VgIGlmIGl0IHNob3VsZCBiZSBleGNsdWRlZCBieSBkZWZhdWx0LiBUaGlzIHNldHRpbmcgY2FuIGJlIG92ZXJyaWRkZW4gYXQgdGhlIHF1ZXJ5IGxldmVsLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgVCA9IGRiLm1vZGVsKCdUJywgbmV3IFNjaGVtYSh7IHg6IHsgdHlwZTogU3RyaW5nLCBzZWxlY3Q6IHRydWUgfX0pKTtcbiAqICAgICBULmZpbmQoLi4pOyAvLyBmaWVsZCB4IHdpbGwgYWx3YXlzIGJlIHNlbGVjdGVkIC4uXG4gKiAgICAgLy8gLi4gdW5sZXNzIG92ZXJyaWRkZW47XG4gKiAgICAgVC5maW5kKCkuc2VsZWN0KCcteCcpLmV4ZWMoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdCh2YWwpIHtcbiAgdGhpcy5zZWxlY3RlZCA9ICEhdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSB2YWxpZGF0aW9uIG9mIGB2YWx1ZWAgdXNpbmcgdGhlIHZhbGlkYXRvcnMgZGVjbGFyZWQgZm9yIHRoaXMgU2NoZW1hVHlwZS5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXVxuICogQHJldHVybiB7QW55fSBJZiBubyB2YWxpZGF0b3JzLCByZXR1cm5zIHRoZSBvdXRwdXQgZnJvbSBjYWxsaW5nIGBmbmAsIG90aGVyd2lzZSBubyByZXR1cm5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuZG9WYWxpZGF0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBmbiwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgbGV0IGVyciA9IGZhbHNlO1xuICBjb25zdCBwYXRoID0gdGhpcy5wYXRoO1xuXG4gIC8vIEF2b2lkIG5vbi1vYmplY3QgYHZhbGlkYXRvcnNgXG4gIGNvbnN0IHZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuXG4gICAgZmlsdGVyKHYgPT4gdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGwpO1xuXG4gIGxldCBjb3VudCA9IHZhbGlkYXRvcnMubGVuZ3RoO1xuXG4gIGlmICghY291bnQpIHtcbiAgICByZXR1cm4gZm4obnVsbCk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsaWRhdG9ycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnN0IHYgPSB2YWxpZGF0b3JzW2ldO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IHYudmFsaWRhdG9yO1xuICAgIGxldCBvaztcblxuICAgIGNvbnN0IHZhbGlkYXRvclByb3BlcnRpZXMgPSBpc1NpbXBsZVZhbGlkYXRvcih2KSA/IE9iamVjdC5hc3NpZ24oe30sIHYpIDogY2xvbmUodik7XG4gICAgdmFsaWRhdG9yUHJvcGVydGllcy5wYXRoID0gb3B0aW9ucyAmJiBvcHRpb25zLnBhdGggPyBvcHRpb25zLnBhdGggOiBwYXRoO1xuICAgIHZhbGlkYXRvclByb3BlcnRpZXMuZnVsbFBhdGggPSB0aGlzLiRmdWxsUGF0aDtcbiAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLnZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAodmFsaWRhdG9yIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICB2YWxpZGF0ZSh2YWxpZGF0b3IudGVzdCh2YWx1ZSksIHZhbGlkYXRvclByb3BlcnRpZXMsIHNjb3BlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiB2YWxpZGF0b3IgIT09IHRoaXMucmVxdWlyZWRWYWxpZGF0b3IpIHtcbiAgICAgIHZhbGlkYXRlKHRydWUsIHZhbGlkYXRvclByb3BlcnRpZXMsIHNjb3BlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAodmFsaWRhdG9yUHJvcGVydGllcy5wcm9wc1BhcmFtZXRlcikge1xuICAgICAgICBvayA9IHZhbGlkYXRvci5jYWxsKHNjb3BlLCB2YWx1ZSwgdmFsaWRhdG9yUHJvcGVydGllcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvayA9IHZhbGlkYXRvci5jYWxsKHNjb3BlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9rID0gZmFsc2U7XG4gICAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLnJlYXNvbiA9IGVycm9yO1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgdmFsaWRhdG9yUHJvcGVydGllcy5tZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2sgIT0gbnVsbCAmJiB0eXBlb2Ygb2sudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb2sudGhlbihcbiAgICAgICAgZnVuY3Rpb24ob2spIHsgdmFsaWRhdGUob2ssIHZhbGlkYXRvclByb3BlcnRpZXMsIHNjb3BlKTsgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgIHZhbGlkYXRvclByb3BlcnRpZXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgICAgICB2YWxpZGF0ZShvaywgdmFsaWRhdG9yUHJvcGVydGllcywgc2NvcGUpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGUob2ssIHZhbGlkYXRvclByb3BlcnRpZXMsIHNjb3BlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShvaywgdmFsaWRhdG9yUHJvcGVydGllcywgc2NvcGUpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvayA9PT0gdW5kZWZpbmVkIHx8IG9rKSB7XG4gICAgICBpZiAoLS1jb3VudCA8PSAwKSB7XG4gICAgICAgIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBmbihudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IEVycm9yQ29uc3RydWN0b3IgPSB2YWxpZGF0b3JQcm9wZXJ0aWVzLkVycm9yQ29uc3RydWN0b3IgfHwgVmFsaWRhdG9yRXJyb3I7XG4gICAgICBlcnIgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWxpZGF0b3JQcm9wZXJ0aWVzLCBzY29wZSk7XG4gICAgICBlcnJbdmFsaWRhdG9yRXJyb3JTeW1ib2xdID0gdHJ1ZTtcbiAgICAgIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgZm4oZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuXG5mdW5jdGlvbiBfdmFsaWRhdGUob2ssIHZhbGlkYXRvclByb3BlcnRpZXMpIHtcbiAgaWYgKG9rICE9PSB1bmRlZmluZWQgJiYgIW9rKSB7XG4gICAgY29uc3QgRXJyb3JDb25zdHJ1Y3RvciA9IHZhbGlkYXRvclByb3BlcnRpZXMuRXJyb3JDb25zdHJ1Y3RvciB8fCBWYWxpZGF0b3JFcnJvcjtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWxpZGF0b3JQcm9wZXJ0aWVzKTtcbiAgICBlcnJbdmFsaWRhdG9yRXJyb3JTeW1ib2xdID0gdHJ1ZTtcbiAgICByZXR1cm4gZXJyO1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSB2YWxpZGF0aW9uIG9mIGB2YWx1ZWAgdXNpbmcgdGhlIHZhbGlkYXRvcnMgZGVjbGFyZWQgZm9yIHRoaXMgU2NoZW1hVHlwZS5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogVGhpcyBtZXRob2QgaWdub3JlcyB0aGUgYXN5bmNocm9ub3VzIHZhbGlkYXRvcnMuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wYXRoXVxuICogQHJldHVybiB7TW9uZ29vc2VFcnJvcnxudWxsfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuZG9WYWxpZGF0ZVN5bmMgPSBmdW5jdGlvbih2YWx1ZSwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgY29uc3QgY291bnQgPSB0aGlzLnZhbGlkYXRvcnMubGVuZ3RoO1xuXG4gIGlmICghY291bnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCB2YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzO1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGlmICh0aGlzLnZhbGlkYXRvcnMubGVuZ3RoICE9PSAwICYmIHRoaXMudmFsaWRhdG9yc1swXS50eXBlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICB2YWxpZGF0b3JzID0gW3RoaXMudmFsaWRhdG9yc1swXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGxldCBlcnIgPSBudWxsO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbiA9IHZhbGlkYXRvcnMubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcblxuICAgIGNvbnN0IHYgPSB2YWxpZGF0b3JzW2ldO1xuXG4gICAgaWYgKHYgPT09IG51bGwgfHwgdHlwZW9mIHYgIT09ICdvYmplY3QnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZGF0b3IgPSB2LnZhbGlkYXRvcjtcbiAgICBjb25zdCB2YWxpZGF0b3JQcm9wZXJ0aWVzID0gaXNTaW1wbGVWYWxpZGF0b3IodikgPyBPYmplY3QuYXNzaWduKHt9LCB2KSA6IGNsb25lKHYpO1xuICAgIHZhbGlkYXRvclByb3BlcnRpZXMucGF0aCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoID8gb3B0aW9ucy5wYXRoIDogcGF0aDtcbiAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLmZ1bGxQYXRoID0gdGhpcy4kZnVsbFBhdGg7XG4gICAgdmFsaWRhdG9yUHJvcGVydGllcy52YWx1ZSA9IHZhbHVlO1xuICAgIGxldCBvayA9IGZhbHNlO1xuXG4gICAgLy8gU2tpcCBhbnkgZXhwbGljaXQgYXN5bmMgdmFsaWRhdG9ycy4gVmFsaWRhdG9ycyB0aGF0IHJldHVybiBhIHByb21pc2VcbiAgICAvLyB3aWxsIHN0aWxsIHJ1biwgYnV0IHdvbid0IHRyaWdnZXIgYW55IGVycm9ycy5cbiAgICBpZiAoaXNBc3luY0Z1bmN0aW9uKHZhbGlkYXRvcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh2YWxpZGF0b3IgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIGVyciA9IF92YWxpZGF0ZSh2YWxpZGF0b3IudGVzdCh2YWx1ZSksIHZhbGlkYXRvclByb3BlcnRpZXMpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAodmFsaWRhdG9yUHJvcGVydGllcy5wcm9wc1BhcmFtZXRlcikge1xuICAgICAgICBvayA9IHZhbGlkYXRvci5jYWxsKHNjb3BlLCB2YWx1ZSwgdmFsaWRhdG9yUHJvcGVydGllcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvayA9IHZhbGlkYXRvci5jYWxsKHNjb3BlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9rID0gZmFsc2U7XG4gICAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLnJlYXNvbiA9IGVycm9yO1xuICAgIH1cblxuICAgIC8vIFNraXAgYW55IHZhbGlkYXRvcnMgdGhhdCByZXR1cm4gYSBwcm9taXNlLCB3ZSBjYW4ndCBoYW5kbGUgdGhvc2VcbiAgICAvLyBzeW5jaHJvbm91c2x5XG4gICAgaWYgKG9rICE9IG51bGwgJiYgdHlwZW9mIG9rLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBlcnIgPSBfdmFsaWRhdGUob2ssIHZhbGlkYXRvclByb3BlcnRpZXMpO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdmFsdWUgaXMgYSB2YWxpZCBSZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHtTY2hlbWFUeXBlfSBzZWxmXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHBhcmFtIHtCb29sZWFufSBpbml0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5faXNSZWYgPSBmdW5jdGlvbihzZWxmLCB2YWx1ZSwgZG9jLCBpbml0KSB7XG4gIC8vIGZhc3QgcGF0aFxuICBsZXQgcmVmID0gaW5pdCAmJiBzZWxmLm9wdGlvbnMgJiYgKHNlbGYub3B0aW9ucy5yZWYgfHwgc2VsZi5vcHRpb25zLnJlZlBhdGgpO1xuXG4gIGlmICghcmVmICYmIGRvYyAmJiBkb2MuJF9fICE9IG51bGwpIHtcbiAgICAvLyBjaGVja3MgZm9yXG4gICAgLy8gLSB0aGlzIHBvcHVsYXRlZCB3aXRoIGFkaG9jIG1vZGVsIGFuZCBubyByZWYgd2FzIHNldCBpbiBzY2hlbWEgT1JcbiAgICAvLyAtIHNldHRpbmcgLyBwdXNoaW5nIHZhbHVlcyBhZnRlciBwb3B1bGF0aW9uXG4gICAgY29uc3QgcGF0aCA9IGRvYy4kX19mdWxsUGF0aChzZWxmLnBhdGgsIHRydWUpO1xuXG4gICAgY29uc3Qgb3duZXIgPSBkb2Mub3duZXJEb2N1bWVudCgpO1xuICAgIHJlZiA9IChwYXRoICE9IG51bGwgJiYgb3duZXIuJHBvcHVsYXRlZChwYXRoKSkgfHwgZG9jLiRwb3B1bGF0ZWQoc2VsZi5wYXRoKTtcbiAgfVxuXG4gIGlmIChyZWYpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSAmJiAvLyBidWZmZXJzIGFyZSBvYmplY3RzIHRvb1xuICAgICAgdmFsdWUuX2Jzb250eXBlICE9PSAnQmluYXJ5JyAvLyByYXcgYmluYXJ5IHZhbHVlIGZyb20gdGhlIGRiXG4gICAgICAmJiB1dGlscy5pc09iamVjdCh2YWx1ZSkgLy8gbWlnaHQgaGF2ZSBkZXNlbGVjdGVkIF9pZCBpbiBwb3B1bGF0aW9uIHF1ZXJ5XG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5pdDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuX2Nhc3RSZWYgPSBmdW5jdGlvbiBfY2FzdFJlZih2YWx1ZSwgZG9jLCBpbml0KSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHZhbHVlLiRfXyAhPSBudWxsKSB7XG4gICAgdmFsdWUuJF9fLndhc1BvcHVsYXRlZCA9IHZhbHVlLiRfXy53YXNQb3B1bGF0ZWQgfHwgeyB2YWx1ZTogdmFsdWUuX2lkIH07XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gc2V0dGluZyBhIHBvcHVsYXRlZCBwYXRoXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8ICF1dGlscy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICBpZiAoaW5pdCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKHRoaXMuaW5zdGFuY2UsIHZhbHVlLCB0aGlzLnBhdGgsIG51bGwsIHRoaXMpO1xuICB9XG5cbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHVzZXIgZGlyZWN0bHkgc2V0cyBhIHBvcHVsYXRlZFxuICAvLyBwYXRoIHRvIGEgcGxhaW4gb2JqZWN0OyBjYXN0IHRvIHRoZSBNb2RlbCB1c2VkIGluXG4gIC8vIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5LlxuICBjb25zdCBwYXRoID0gZG9jLiRfX2Z1bGxQYXRoKHRoaXMucGF0aCwgdHJ1ZSk7XG4gIGNvbnN0IG93bmVyID0gZG9jLm93bmVyRG9jdW1lbnQoKTtcbiAgY29uc3QgcG9wID0gb3duZXIuJHBvcHVsYXRlZChwYXRoLCB0cnVlKTtcblxuICBsZXQgcmV0ID0gdmFsdWU7XG4gIGlmICghZG9jLiRfXy5wb3B1bGF0ZWQgfHxcbiAgICAhZG9jLiRfXy5wb3B1bGF0ZWRbcGF0aF0gfHxcbiAgICAhZG9jLiRfXy5wb3B1bGF0ZWRbcGF0aF0ub3B0aW9ucyB8fFxuICAgICFkb2MuJF9fLnBvcHVsYXRlZFtwYXRoXS5vcHRpb25zLm9wdGlvbnMgfHxcbiAgICAhZG9jLiRfXy5wb3B1bGF0ZWRbcGF0aF0ub3B0aW9ucy5vcHRpb25zLmxlYW4pIHtcbiAgICByZXQgPSBuZXcgcG9wLm9wdGlvbnNbcG9wdWxhdGVNb2RlbFN5bWJvbF0odmFsdWUpO1xuICAgIHJldC4kX18ud2FzUG9wdWxhdGVkID0geyB2YWx1ZTogcmV0Ll9pZCB9O1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHZhbCwgY29udGV4dCkge1xuICByZXR1cm4gdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgdmFsLCBjb250ZXh0KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVBcnJheSh2YWwsIGNvbnRleHQpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBbdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgdmFsLCBjb250ZXh0KV07XG4gIH1cbiAgcmV0dXJuIHZhbC5tYXAoZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBfdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgbSwgY29udGV4dCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEp1c3QgbGlrZSBoYW5kbGVBcnJheSwgZXhjZXB0IGFsc28gYWxsb3dzIGBbXWAgYmVjYXVzZSBzdXJwcmlzaW5nbHlcbiAqIGAkaW46IFsxLCBbXV1gIHdvcmtzIGZpbmVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZSRpbih2YWwsIGNvbnRleHQpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBbdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgdmFsLCBjb250ZXh0KV07XG4gIH1cbiAgcmV0dXJuIHZhbC5tYXAoZnVuY3Rpb24obSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG0pICYmIG0ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzLmNhc3RGb3JRdWVyeShudWxsLCBtLCBjb250ZXh0KTtcbiAgfSk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7XG4gICRhbGw6IGhhbmRsZUFycmF5LFxuICAkZXE6IGhhbmRsZVNpbmdsZSxcbiAgJGluOiBoYW5kbGUkaW4sXG4gICRuZTogaGFuZGxlU2luZ2xlLFxuICAkbmluOiBoYW5kbGUkaW4sXG4gICRleGlzdHM6ICRleGlzdHMsXG4gICR0eXBlOiAkdHlwZVxufTtcblxuLyoqXG4gKiBDYXN0IHRoZSBnaXZlbiB2YWx1ZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25hbCBxdWVyeSBvcGVyYXRvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gWyRjb25kaXRpb25hbF0gcXVlcnkgb3BlcmF0b3IsIGxpa2UgYCRlcWAgb3IgYCRpbmBcbiAqIEBwYXJhbSB7QW55fSB2YWxcbiAqIEBwYXJhbSB7UXVlcnl9IGNvbnRleHRcbiAqIEByZXR1cm4ge0FueX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kaXRpb25hbCwgdmFsLCBjb250ZXh0KSB7XG4gIGxldCBoYW5kbGVyO1xuICBpZiAoJGNvbmRpdGlvbmFsICE9IG51bGwpIHtcbiAgICBoYW5kbGVyID0gdGhpcy4kY29uZGl0aW9uYWxIYW5kbGVyc1skY29uZGl0aW9uYWxdO1xuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHVzZSAnICsgJGNvbmRpdGlvbmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB2YWwsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXBwbHlTZXR0ZXJzKHZhbCwgY29udGV4dCk7XG59O1xuXG4vKipcbiAqIFNldCAmIEdldCB0aGUgYGNoZWNrUmVxdWlyZWRgIGZ1bmN0aW9uXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSB2YWx1ZVxuICogcGFzc2VzIHRoZSBgcmVxdWlyZWRgIGNoZWNrLiBPdmVycmlkZSB0aGlzIG9uIHRoZSBpbmRpdmlkdWFsIFNjaGVtYVR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBVc2UgdGhpcyB0byBhbGxvdyBlbXB0eSBzdHJpbmdzIHRvIHBhc3MgdGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLlN0cmluZy5jaGVja1JlcXVpcmVkKHYgPT4gdHlwZW9mIHYgPT09ICdzdHJpbmcnKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIElmIHNldCwgd2lsbCBvdmVyd3JpdGUgdGhlIGN1cnJlbnQgc2V0IGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGlucHV0IGBmbmAgb3IgdGhlIGFscmVhZHkgc2V0IGZ1bmN0aW9uXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24oZm4pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICB0aGlzLl9jaGVja1JlcXVpcmVkID0gZm47XG4gIH1cblxuICByZXR1cm4gdGhpcy5fY2hlY2tSZXF1aXJlZDtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjaGVjayBmb3IgaWYgdGhpcyBwYXRoIHNhdGlzZmllcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIHdoZW4gdGhlIHZhbHVlIGlzIG5vdCBgbnVsbGAsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xvbmUgdGhlIGN1cnJlbnQgU2NoZW1hVHlwZVxuICpcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IFRoZSBjbG9uZWQgU2NoZW1hVHlwZSBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7XG4gIGNvbnN0IHNjaGVtYXR5cGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnBhdGgsIG9wdGlvbnMsIHRoaXMuaW5zdGFuY2UpO1xuICBzY2hlbWF0eXBlLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuc2xpY2UoKTtcbiAgaWYgKHRoaXMucmVxdWlyZWRWYWxpZGF0b3IgIT09IHVuZGVmaW5lZCkgc2NoZW1hdHlwZS5yZXF1aXJlZFZhbGlkYXRvciA9IHRoaXMucmVxdWlyZWRWYWxpZGF0b3I7XG4gIGlmICh0aGlzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSBzY2hlbWF0eXBlLmRlZmF1bHRWYWx1ZSA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuICBpZiAodGhpcy4kaW1tdXRhYmxlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLmltbXV0YWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2NoZW1hdHlwZS4kaW1tdXRhYmxlID0gdGhpcy4kaW1tdXRhYmxlO1xuXG4gICAgaGFuZGxlSW1tdXRhYmxlKHNjaGVtYXR5cGUpO1xuICB9XG4gIGlmICh0aGlzLl9pbmRleCAhPT0gdW5kZWZpbmVkKSBzY2hlbWF0eXBlLl9pbmRleCA9IHRoaXMuX2luZGV4O1xuICBpZiAodGhpcy5zZWxlY3RlZCAhPT0gdW5kZWZpbmVkKSBzY2hlbWF0eXBlLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZDtcbiAgaWYgKHRoaXMuaXNSZXF1aXJlZCAhPT0gdW5kZWZpbmVkKSBzY2hlbWF0eXBlLmlzUmVxdWlyZWQgPSB0aGlzLmlzUmVxdWlyZWQ7XG4gIGlmICh0aGlzLm9yaWdpbmFsUmVxdWlyZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSBzY2hlbWF0eXBlLm9yaWdpbmFsUmVxdWlyZWRWYWx1ZSA9IHRoaXMub3JpZ2luYWxSZXF1aXJlZFZhbHVlO1xuICBzY2hlbWF0eXBlLmdldHRlcnMgPSB0aGlzLmdldHRlcnMuc2xpY2UoKTtcbiAgc2NoZW1hdHlwZS5zZXR0ZXJzID0gdGhpcy5zZXR0ZXJzLnNsaWNlKCk7XG4gIHJldHVybiBzY2hlbWF0eXBlO1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTY2hlbWFUeXBlO1xuXG5leHBvcnRzLkNhc3RFcnJvciA9IENhc3RFcnJvcjtcblxuZXhwb3J0cy5WYWxpZGF0b3JFcnJvciA9IFZhbGlkYXRvckVycm9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/schematype.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/statemachine.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/statemachine.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst utils = __webpack_require__(/*! ./utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\"); // eslint-disable-line no-unused-vars\n\n/**\n * StateMachine represents a minimal `interface` for the\n * constructors it builds via StateMachine.ctor(...).\n *\n * @api private\n */\n\nconst StateMachine = module.exports = exports = function StateMachine() {\n};\n\n/**\n * StateMachine.ctor('state1', 'state2', ...)\n * A factory method for subclassing StateMachine.\n * The arguments are a list of states. For each state,\n * the constructor's prototype gets state transition\n * methods named after each state. These transition methods\n * place their path argument into the given state.\n *\n * @param {String} state\n * @param {String} [state]\n * @return {Function} subclass constructor\n * @api private\n */\n\nStateMachine.ctor = function() {\n  const states = [...arguments];\n\n  const ctor = function() {\n    StateMachine.apply(this, arguments);\n    this.paths = {};\n    this.states = {};\n  };\n\n  ctor.prototype = new StateMachine();\n\n  ctor.prototype.stateNames = states;\n\n  states.forEach(function(state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function(path) {\n      this._changeState(path, state);\n    };\n  });\n\n  return ctor;\n};\n\n/**\n * This function is wrapped by the state change functions:\n *\n * - `require(path)`\n * - `modify(path)`\n * - `init(path)`\n *\n * @api private\n */\n\nStateMachine.prototype._changeState = function _changeState(path, nextState) {\n  const prevState = this.paths[path];\n  if (prevState === nextState) {\n    return;\n  }\n  const prevBucket = this.states[prevState];\n  if (prevBucket) delete prevBucket[path];\n\n  this.paths[path] = nextState;\n  this.states[nextState] = this.states[nextState] || {};\n  this.states[nextState][path] = true;\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clear = function clear(state) {\n  if (this.states[state] == null) {\n    return;\n  }\n  const keys = Object.keys(this.states[state]);\n  let i = keys.length;\n  let path;\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clearPath = function clearPath(path) {\n  const state = this.paths[path];\n  if (!state) {\n    return;\n  }\n  delete this.paths[path];\n  delete this.states[state][path];\n};\n\n/**\n * Gets the paths for the given state, or empty object `{}` if none.\n * @api private\n */\n\nStateMachine.prototype.getStatePaths = function getStatePaths(state) {\n  if (this.states[state] != null) {\n    return this.states[state];\n  }\n  return {};\n};\n\n/**\n * Checks to see if at least one path is in the states passed in via `arguments`\n * e.g., this.some('required', 'inited')\n *\n * @param {String} state that we want to check for.\n * @api private\n */\n\nStateMachine.prototype.some = function some() {\n  const _this = this;\n  const what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function(state) {\n    if (_this.states[state] == null) {\n      return false;\n    }\n    return Object.keys(_this.states[state]).length;\n  });\n};\n\n/**\n * This function builds the functions that get assigned to `forEach` and `map`,\n * since both of those methods share a lot of the same logic.\n *\n * @param {String} iterMethod is either 'forEach' or 'map'\n * @return {Function}\n * @api private\n */\n\nStateMachine.prototype._iter = function _iter(iterMethod) {\n  return function() {\n    let states = [...arguments];\n    const callback = states.pop();\n\n    if (!states.length) states = this.stateNames;\n\n    const _this = this;\n\n    const paths = states.reduce(function(paths, state) {\n      if (_this.states[state] == null) {\n        return paths;\n      }\n      return paths.concat(Object.keys(_this.states[state]));\n    }, []);\n\n    return paths[iterMethod](function(path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};\n\n/**\n * Iterates over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @api private\n */\n\nStateMachine.prototype.forEach = function forEach() {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};\n\n/**\n * Maps over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @return {Array}\n * @api private\n */\n\nStateMachine.prototype.map = function map() {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc3RhdGVtYWNoaW5lLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLG1FQUFTLEdBQUc7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksVUFBVTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcc3RhdGVtYWNoaW5lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqXG4gKiBTdGF0ZU1hY2hpbmUgcmVwcmVzZW50cyBhIG1pbmltYWwgYGludGVyZmFjZWAgZm9yIHRoZVxuICogY29uc3RydWN0b3JzIGl0IGJ1aWxkcyB2aWEgU3RhdGVNYWNoaW5lLmN0b3IoLi4uKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jb25zdCBTdGF0ZU1hY2hpbmUgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiBTdGF0ZU1hY2hpbmUoKSB7XG59O1xuXG4vKipcbiAqIFN0YXRlTWFjaGluZS5jdG9yKCdzdGF0ZTEnLCAnc3RhdGUyJywgLi4uKVxuICogQSBmYWN0b3J5IG1ldGhvZCBmb3Igc3ViY2xhc3NpbmcgU3RhdGVNYWNoaW5lLlxuICogVGhlIGFyZ3VtZW50cyBhcmUgYSBsaXN0IG9mIHN0YXRlcy4gRm9yIGVhY2ggc3RhdGUsXG4gKiB0aGUgY29uc3RydWN0b3IncyBwcm90b3R5cGUgZ2V0cyBzdGF0ZSB0cmFuc2l0aW9uXG4gKiBtZXRob2RzIG5hbWVkIGFmdGVyIGVhY2ggc3RhdGUuIFRoZXNlIHRyYW5zaXRpb24gbWV0aG9kc1xuICogcGxhY2UgdGhlaXIgcGF0aCBhcmd1bWVudCBpbnRvIHRoZSBnaXZlbiBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGVdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gc3ViY2xhc3MgY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN0YXRlTWFjaGluZS5jdG9yID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHN0YXRlcyA9IFsuLi5hcmd1bWVudHNdO1xuXG4gIGNvbnN0IGN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICBTdGF0ZU1hY2hpbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnBhdGhzID0ge307XG4gICAgdGhpcy5zdGF0ZXMgPSB7fTtcbiAgfTtcblxuICBjdG9yLnByb3RvdHlwZSA9IG5ldyBTdGF0ZU1hY2hpbmUoKTtcblxuICBjdG9yLnByb3RvdHlwZS5zdGF0ZU5hbWVzID0gc3RhdGVzO1xuXG4gIHN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgLy8gQ2hhbmdlcyB0aGUgYHBhdGhgJ3Mgc3RhdGUgdG8gYHN0YXRlYC5cbiAgICBjdG9yLnByb3RvdHlwZVtzdGF0ZV0gPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VTdGF0ZShwYXRoLCBzdGF0ZSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGN0b3I7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgd3JhcHBlZCBieSB0aGUgc3RhdGUgY2hhbmdlIGZ1bmN0aW9uczpcbiAqXG4gKiAtIGByZXF1aXJlKHBhdGgpYFxuICogLSBgbW9kaWZ5KHBhdGgpYFxuICogLSBgaW5pdChwYXRoKWBcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLl9jaGFuZ2VTdGF0ZSA9IGZ1bmN0aW9uIF9jaGFuZ2VTdGF0ZShwYXRoLCBuZXh0U3RhdGUpIHtcbiAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5wYXRoc1twYXRoXTtcbiAgaWYgKHByZXZTdGF0ZSA9PT0gbmV4dFN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByZXZCdWNrZXQgPSB0aGlzLnN0YXRlc1twcmV2U3RhdGVdO1xuICBpZiAocHJldkJ1Y2tldCkgZGVsZXRlIHByZXZCdWNrZXRbcGF0aF07XG5cbiAgdGhpcy5wYXRoc1twYXRoXSA9IG5leHRTdGF0ZTtcbiAgdGhpcy5zdGF0ZXNbbmV4dFN0YXRlXSA9IHRoaXMuc3RhdGVzW25leHRTdGF0ZV0gfHwge307XG4gIHRoaXMuc3RhdGVzW25leHRTdGF0ZV1bcGF0aF0gPSB0cnVlO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoc3RhdGUpIHtcbiAgaWYgKHRoaXMuc3RhdGVzW3N0YXRlXSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnN0YXRlc1tzdGF0ZV0pO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICBsZXQgcGF0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcGF0aCA9IGtleXNbaV07XG4gICAgZGVsZXRlIHRoaXMuc3RhdGVzW3N0YXRlXVtwYXRoXTtcbiAgICBkZWxldGUgdGhpcy5wYXRoc1twYXRoXTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLmNsZWFyUGF0aCA9IGZ1bmN0aW9uIGNsZWFyUGF0aChwYXRoKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5wYXRoc1twYXRoXTtcbiAgaWYgKCFzdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkZWxldGUgdGhpcy5wYXRoc1twYXRoXTtcbiAgZGVsZXRlIHRoaXMuc3RhdGVzW3N0YXRlXVtwYXRoXTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgcGF0aHMgZm9yIHRoZSBnaXZlbiBzdGF0ZSwgb3IgZW1wdHkgb2JqZWN0IGB7fWAgaWYgbm9uZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN0YXRlTWFjaGluZS5wcm90b3R5cGUuZ2V0U3RhdGVQYXRocyA9IGZ1bmN0aW9uIGdldFN0YXRlUGF0aHMoc3RhdGUpIHtcbiAgaWYgKHRoaXMuc3RhdGVzW3N0YXRlXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzW3N0YXRlXTtcbiAgfVxuICByZXR1cm4ge307XG59O1xuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgYXQgbGVhc3Qgb25lIHBhdGggaXMgaW4gdGhlIHN0YXRlcyBwYXNzZWQgaW4gdmlhIGBhcmd1bWVudHNgXG4gKiBlLmcuLCB0aGlzLnNvbWUoJ3JlcXVpcmVkJywgJ2luaXRlZCcpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlIHRoYXQgd2Ugd2FudCB0byBjaGVjayBmb3IuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiBzb21lKCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGNvbnN0IHdoYXQgPSBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzIDogdGhpcy5zdGF0ZU5hbWVzO1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbCh3aGF0LCBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChfdGhpcy5zdGF0ZXNbc3RhdGVdID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKF90aGlzLnN0YXRlc1tzdGF0ZV0pLmxlbmd0aDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYnVpbGRzIHRoZSBmdW5jdGlvbnMgdGhhdCBnZXQgYXNzaWduZWQgdG8gYGZvckVhY2hgIGFuZCBgbWFwYCxcbiAqIHNpbmNlIGJvdGggb2YgdGhvc2UgbWV0aG9kcyBzaGFyZSBhIGxvdCBvZiB0aGUgc2FtZSBsb2dpYy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaXRlck1ldGhvZCBpcyBlaXRoZXIgJ2ZvckVhY2gnIG9yICdtYXAnXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN0YXRlTWFjaGluZS5wcm90b3R5cGUuX2l0ZXIgPSBmdW5jdGlvbiBfaXRlcihpdGVyTWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBsZXQgc3RhdGVzID0gWy4uLmFyZ3VtZW50c107XG4gICAgY29uc3QgY2FsbGJhY2sgPSBzdGF0ZXMucG9wKCk7XG5cbiAgICBpZiAoIXN0YXRlcy5sZW5ndGgpIHN0YXRlcyA9IHRoaXMuc3RhdGVOYW1lcztcblxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcblxuICAgIGNvbnN0IHBhdGhzID0gc3RhdGVzLnJlZHVjZShmdW5jdGlvbihwYXRocywgc3RhdGUpIHtcbiAgICAgIGlmIChfdGhpcy5zdGF0ZXNbc3RhdGVdID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhzLmNvbmNhdChPYmplY3Qua2V5cyhfdGhpcy5zdGF0ZXNbc3RhdGVdKSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHBhdGhzW2l0ZXJNZXRob2RdKGZ1bmN0aW9uKHBhdGgsIGksIHBhdGhzKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2socGF0aCwgaSwgcGF0aHMpO1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIHRoZSBwYXRocyB0aGF0IGJlbG9uZyB0byBvbmUgb2YgdGhlIHBhcmFtZXRlciBzdGF0ZXMuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHByb2ZpbGUgY2FuIGxvb2sgbGlrZTpcbiAqIHRoaXMuZm9yRWFjaChzdGF0ZTEsIGZuKTsgICAgICAgICAvLyBpdGVyYXRlcyBvdmVyIGFsbCBwYXRocyBpbiBzdGF0ZTFcbiAqIHRoaXMuZm9yRWFjaChzdGF0ZTEsIHN0YXRlMiwgZm4pOyAvLyBpdGVyYXRlcyBvdmVyIGFsbCBwYXRocyBpbiBzdGF0ZTEgb3Igc3RhdGUyXG4gKiB0aGlzLmZvckVhY2goZm4pOyAgICAgICAgICAgICAgICAgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgcGF0aHMgaW4gYWxsIHN0YXRlc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGVdXG4gKiBAcGFyYW0ge1N0cmluZ30gW3N0YXRlXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN0YXRlTWFjaGluZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goKSB7XG4gIHRoaXMuZm9yRWFjaCA9IHRoaXMuX2l0ZXIoJ2ZvckVhY2gnKTtcbiAgcmV0dXJuIHRoaXMuZm9yRWFjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBNYXBzIG92ZXIgdGhlIHBhdGhzIHRoYXQgYmVsb25nIHRvIG9uZSBvZiB0aGUgcGFyYW1ldGVyIHN0YXRlcy5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gcHJvZmlsZSBjYW4gbG9vayBsaWtlOlxuICogdGhpcy5mb3JFYWNoKHN0YXRlMSwgZm4pOyAgICAgICAgIC8vIGl0ZXJhdGVzIG92ZXIgYWxsIHBhdGhzIGluIHN0YXRlMVxuICogdGhpcy5mb3JFYWNoKHN0YXRlMSwgc3RhdGUyLCBmbik7IC8vIGl0ZXJhdGVzIG92ZXIgYWxsIHBhdGhzIGluIHN0YXRlMSBvciBzdGF0ZTJcbiAqIHRoaXMuZm9yRWFjaChmbik7ICAgICAgICAgICAgICAgICAvLyBpdGVyYXRlcyBvdmVyIGFsbCBwYXRocyBpbiBhbGwgc3RhdGVzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtzdGF0ZV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCgpIHtcbiAgdGhpcy5tYXAgPSB0aGlzLl9pdGVyKCdtYXAnKTtcbiAgcmV0dXJuIHRoaXMubWFwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/statemachine.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/ArraySubdocument.js":
/*!*********************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/ArraySubdocument.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Subdocument = __webpack_require__(/*! ./subdocument */ \"(api)/../server/node_modules/mongoose/lib/types/subdocument.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nconst documentArrayParent = (__webpack_require__(/*! ../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\n\n/**\n * A constructor.\n *\n * @param {Object} obj js object returned from the db\n * @param {MongooseDocumentArray} parentArr the parent array of this document\n * @param {Boolean} skipId\n * @param {Object} fields\n * @param {Number} index\n * @inherits Document\n * @api private\n */\n\nfunction ArraySubdocument(obj, parentArr, skipId, fields, index) {\n  if (utils.isMongooseDocumentArray(parentArr)) {\n    this.__parentArray = parentArr;\n    this[documentArrayParent] = parentArr.$parent();\n  } else {\n    this.__parentArray = undefined;\n    this[documentArrayParent] = undefined;\n  }\n  this.$setIndex(index);\n  this.$__parent = this[documentArrayParent];\n\n  let options;\n  if (typeof skipId === 'object' && skipId != null) {\n    options = { isNew: true, ...skipId };\n    skipId = undefined;\n  } else {\n    options = { isNew: true };\n  }\n\n  Subdocument.call(this, obj, fields, this[documentArrayParent], skipId, options);\n}\n\n/*!\n * Inherit from Subdocument\n */\nArraySubdocument.prototype = Object.create(Subdocument.prototype);\nArraySubdocument.prototype.constructor = ArraySubdocument;\n\nObject.defineProperty(ArraySubdocument.prototype, '$isSingleNested', {\n  configurable: false,\n  writable: false,\n  value: false\n});\n\nObject.defineProperty(ArraySubdocument.prototype, '$isDocumentArrayElement', {\n  configurable: false,\n  writable: false,\n  value: true\n});\n\nfor (const i in EventEmitter.prototype) {\n  ArraySubdocument[i] = EventEmitter.prototype[i];\n}\n\n/*!\n * ignore\n */\n\nArraySubdocument.prototype.$setIndex = function(index) {\n  this.__index = index;\n\n  if (this.$__ != null && this.$__.validationError != null) {\n    const keys = Object.keys(this.$__.validationError.errors);\n    for (const key of keys) {\n      this.invalidate(key, this.$__.validationError.errors[key]);\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nArraySubdocument.prototype.populate = function() {\n  throw new Error('Mongoose does not support calling populate() on nested ' +\n    'docs. Instead of `doc.arr[0].populate(\"path\")`, use ' +\n    '`doc.populate(\"arr.0.path\")`');\n};\n\n/*!\n * ignore\n */\n\nArraySubdocument.prototype.$__removeFromParent = function() {\n  const _id = this._doc._id;\n  if (!_id) {\n    throw new Error('For your own good, Mongoose does not know ' +\n      'how to remove an ArraySubdocument that has no _id');\n  }\n  this.__parentArray.pull({ _id: _id });\n};\n\n/**\n * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.\n *\n * @param {String} [path]\n * @param {Boolean} [skipIndex] Skip adding the array index. For example `arr.foo` instead of `arr.0.foo`.\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf ArraySubdocument\n * @instance\n */\n\nArraySubdocument.prototype.$__fullPath = function(path, skipIndex) {\n  if (this.__index == null) {\n    return null;\n  }\n  if (!this.$__.fullPath) {\n    this.ownerDocument();\n  }\n\n  if (skipIndex) {\n    return path ?\n      this.$__.fullPath + '.' + path :\n      this.$__.fullPath;\n  }\n\n  return path ?\n    this.$__.fullPath + '.' + this.__index + '.' + path :\n    this.$__.fullPath + '.' + this.__index;\n};\n\n/**\n * Given a path relative to this document, return the path relative\n * to the top-level document.\n * @method $__pathRelativeToParent\n * @memberOf ArraySubdocument\n * @instance\n * @api private\n */\n\nArraySubdocument.prototype.$__pathRelativeToParent = function(path, skipIndex) {\n  if (this.__index == null || (!this.__parentArray || !this.__parentArray.$path)) {\n    return null;\n  }\n  if (skipIndex) {\n    return path == null ? this.__parentArray.$path() : this.__parentArray.$path() + '.' + path;\n  }\n  if (path == null) {\n    return this.__parentArray.$path() + '.' + this.__index;\n  }\n  return this.__parentArray.$path() + '.' + this.__index + '.' + path;\n};\n\n/**\n * Returns this sub-documents parent document.\n * @method $parent\n * @memberOf ArraySubdocument\n * @instance\n * @api public\n */\n\nArraySubdocument.prototype.$parent = function() {\n  return this[documentArrayParent];\n};\n\n/**\n * Returns this subdocument's parent array.\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', new Schema({\n *       docArr: [{ name: String }]\n *     }));\n *     const doc = new Test({ docArr: [{ name: 'test subdoc' }] });\n *\n *     doc.docArr[0].parentArray() === doc.docArr; // true\n *\n * @api public\n * @method parentArray\n * @returns DocumentArray\n */\n\nArraySubdocument.prototype.parentArray = function() {\n  return this.__parentArray;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = ArraySubdocument;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvQXJyYXlTdWJkb2N1bWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIscUJBQXFCLDBEQUE4QjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBZTtBQUMzQyxjQUFjLG1CQUFPLENBQUMsb0VBQVU7O0FBRWhDLDRCQUE0QixtSUFBaUQ7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsSUFBSTtBQUNKLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsUUFBUTtBQUNSLDhCQUE4QixXQUFXLHFCQUFxQixHQUFHO0FBQ2pFO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHR5cGVzXFxBcnJheVN1YmRvY3VtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IFN1YmRvY3VtZW50ID0gcmVxdWlyZSgnLi9zdWJkb2N1bWVudCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5jb25zdCBkb2N1bWVudEFycmF5UGFyZW50ID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRBcnJheVBhcmVudDtcblxuLyoqXG4gKiBBIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoganMgb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIGRiXG4gKiBAcGFyYW0ge01vbmdvb3NlRG9jdW1lbnRBcnJheX0gcGFyZW50QXJyIHRoZSBwYXJlbnQgYXJyYXkgb2YgdGhpcyBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBza2lwSWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQGluaGVyaXRzIERvY3VtZW50XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBBcnJheVN1YmRvY3VtZW50KG9iaiwgcGFyZW50QXJyLCBza2lwSWQsIGZpZWxkcywgaW5kZXgpIHtcbiAgaWYgKHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHBhcmVudEFycikpIHtcbiAgICB0aGlzLl9fcGFyZW50QXJyYXkgPSBwYXJlbnRBcnI7XG4gICAgdGhpc1tkb2N1bWVudEFycmF5UGFyZW50XSA9IHBhcmVudEFyci4kcGFyZW50KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fX3BhcmVudEFycmF5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXNbZG9jdW1lbnRBcnJheVBhcmVudF0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgdGhpcy4kc2V0SW5kZXgoaW5kZXgpO1xuICB0aGlzLiRfX3BhcmVudCA9IHRoaXNbZG9jdW1lbnRBcnJheVBhcmVudF07XG5cbiAgbGV0IG9wdGlvbnM7XG4gIGlmICh0eXBlb2Ygc2tpcElkID09PSAnb2JqZWN0JyAmJiBza2lwSWQgIT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSB7IGlzTmV3OiB0cnVlLCAuLi5za2lwSWQgfTtcbiAgICBza2lwSWQgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IHsgaXNOZXc6IHRydWUgfTtcbiAgfVxuXG4gIFN1YmRvY3VtZW50LmNhbGwodGhpcywgb2JqLCBmaWVsZHMsIHRoaXNbZG9jdW1lbnRBcnJheVBhcmVudF0sIHNraXBJZCwgb3B0aW9ucyk7XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIFN1YmRvY3VtZW50XG4gKi9cbkFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdWJkb2N1bWVudC5wcm90b3R5cGUpO1xuQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcnJheVN1YmRvY3VtZW50O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUsICckaXNTaW5nbGVOZXN0ZWQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IGZhbHNlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlLCAnJGlzRG9jdW1lbnRBcnJheUVsZW1lbnQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mb3IgKGNvbnN0IGkgaW4gRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkge1xuICBBcnJheVN1YmRvY3VtZW50W2ldID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZVtpXTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS4kc2V0SW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICB0aGlzLl9faW5kZXggPSBpbmRleDtcblxuICBpZiAodGhpcy4kX18gIT0gbnVsbCAmJiB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgIT0gbnVsbCkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoa2V5LCB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzW2tleV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ01vbmdvb3NlIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZyBwb3B1bGF0ZSgpIG9uIG5lc3RlZCAnICtcbiAgICAnZG9jcy4gSW5zdGVhZCBvZiBgZG9jLmFyclswXS5wb3B1bGF0ZShcInBhdGhcIilgLCB1c2UgJyArXG4gICAgJ2Bkb2MucG9wdWxhdGUoXCJhcnIuMC5wYXRoXCIpYCcpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19yZW1vdmVGcm9tUGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IF9pZCA9IHRoaXMuX2RvYy5faWQ7XG4gIGlmICghX2lkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3IgeW91ciBvd24gZ29vZCwgTW9uZ29vc2UgZG9lcyBub3Qga25vdyAnICtcbiAgICAgICdob3cgdG8gcmVtb3ZlIGFuIEFycmF5U3ViZG9jdW1lbnQgdGhhdCBoYXMgbm8gX2lkJyk7XG4gIH1cbiAgdGhpcy5fX3BhcmVudEFycmF5LnB1bGwoeyBfaWQ6IF9pZCB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVsbCBwYXRoIHRvIHRoaXMgZG9jdW1lbnQuIElmIG9wdGlvbmFsIGBwYXRoYCBpcyBwYXNzZWQsIGl0IGlzIGFwcGVuZGVkIHRvIHRoZSBmdWxsIHBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtCb29sZWFufSBbc2tpcEluZGV4XSBTa2lwIGFkZGluZyB0aGUgYXJyYXkgaW5kZXguIEZvciBleGFtcGxlIGBhcnIuZm9vYCBpbnN0ZWFkIG9mIGBhcnIuMC5mb29gLlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX2Z1bGxQYXRoXG4gKiBAbWVtYmVyT2YgQXJyYXlTdWJkb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUuJF9fZnVsbFBhdGggPSBmdW5jdGlvbihwYXRoLCBza2lwSW5kZXgpIHtcbiAgaWYgKHRoaXMuX19pbmRleCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCF0aGlzLiRfXy5mdWxsUGF0aCkge1xuICAgIHRoaXMub3duZXJEb2N1bWVudCgpO1xuICB9XG5cbiAgaWYgKHNraXBJbmRleCkge1xuICAgIHJldHVybiBwYXRoID9cbiAgICAgIHRoaXMuJF9fLmZ1bGxQYXRoICsgJy4nICsgcGF0aCA6XG4gICAgICB0aGlzLiRfXy5mdWxsUGF0aDtcbiAgfVxuXG4gIHJldHVybiBwYXRoID9cbiAgICB0aGlzLiRfXy5mdWxsUGF0aCArICcuJyArIHRoaXMuX19pbmRleCArICcuJyArIHBhdGggOlxuICAgIHRoaXMuJF9fLmZ1bGxQYXRoICsgJy4nICsgdGhpcy5fX2luZGV4O1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIHBhdGggcmVsYXRpdmUgdG8gdGhpcyBkb2N1bWVudCwgcmV0dXJuIHRoZSBwYXRoIHJlbGF0aXZlXG4gKiB0byB0aGUgdG9wLWxldmVsIGRvY3VtZW50LlxuICogQG1ldGhvZCAkX19wYXRoUmVsYXRpdmVUb1BhcmVudFxuICogQG1lbWJlck9mIEFycmF5U3ViZG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQgPSBmdW5jdGlvbihwYXRoLCBza2lwSW5kZXgpIHtcbiAgaWYgKHRoaXMuX19pbmRleCA9PSBudWxsIHx8ICghdGhpcy5fX3BhcmVudEFycmF5IHx8ICF0aGlzLl9fcGFyZW50QXJyYXkuJHBhdGgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHNraXBJbmRleCkge1xuICAgIHJldHVybiBwYXRoID09IG51bGwgPyB0aGlzLl9fcGFyZW50QXJyYXkuJHBhdGgoKSA6IHRoaXMuX19wYXJlbnRBcnJheS4kcGF0aCgpICsgJy4nICsgcGF0aDtcbiAgfVxuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wYXJlbnRBcnJheS4kcGF0aCgpICsgJy4nICsgdGhpcy5fX2luZGV4O1xuICB9XG4gIHJldHVybiB0aGlzLl9fcGFyZW50QXJyYXkuJHBhdGgoKSArICcuJyArIHRoaXMuX19pbmRleCArICcuJyArIHBhdGg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBzdWItZG9jdW1lbnRzIHBhcmVudCBkb2N1bWVudC5cbiAqIEBtZXRob2QgJHBhcmVudFxuICogQG1lbWJlck9mIEFycmF5U3ViZG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS4kcGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzW2RvY3VtZW50QXJyYXlQYXJlbnRdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgc3ViZG9jdW1lbnQncyBwYXJlbnQgYXJyYXkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBUZXN0ID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHtcbiAqICAgICAgIGRvY0FycjogW3sgbmFtZTogU3RyaW5nIH1dXG4gKiAgICAgfSkpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBUZXN0KHsgZG9jQXJyOiBbeyBuYW1lOiAndGVzdCBzdWJkb2MnIH1dIH0pO1xuICpcbiAqICAgICBkb2MuZG9jQXJyWzBdLnBhcmVudEFycmF5KCkgPT09IGRvYy5kb2NBcnI7IC8vIHRydWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBwYXJlbnRBcnJheVxuICogQHJldHVybnMgRG9jdW1lbnRBcnJheVxuICovXG5cbkFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlLnBhcmVudEFycmF5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fcGFyZW50QXJyYXk7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXlTdWJkb2N1bWVudDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/ArraySubdocument.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/DocumentArray/index.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/DocumentArray/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ArrayMethods = __webpack_require__(/*! ../array/methods */ \"(api)/../server/node_modules/mongoose/lib/types/array/methods/index.js\");\nconst DocumentArrayMethods = __webpack_require__(/*! ./methods */ \"(api)/../server/node_modules/mongoose/lib/types/DocumentArray/methods/index.js\");\nconst Document = __webpack_require__(/*! ../../document */ \"(api)/../server/node_modules/mongoose/lib/document.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayAtomicsBackupSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsBackupSymbol);\nconst arrayParentSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\n\nconst _basePush = Array.prototype.push;\nconst numberRE = /^\\d+$/;\n/**\n * DocumentArray constructor\n *\n * @param {Array} values\n * @param {String} path the path to this array\n * @param {Document} doc parent document\n * @api private\n * @return {MongooseDocumentArray}\n * @inherits MongooseArray\n * @see https://bit.ly/f6CnZU\n */\n\nfunction MongooseDocumentArray(values, path, doc) {\n  const __array = [];\n\n  const internals = {\n    [arrayAtomicsSymbol]: {},\n    [arrayAtomicsBackupSymbol]: void 0,\n    [arrayPathSymbol]: path,\n    [arraySchemaSymbol]: void 0,\n    [arrayParentSymbol]: void 0\n  };\n\n  if (Array.isArray(values)) {\n    if (values[arrayPathSymbol] === path &&\n        values[arrayParentSymbol] === doc) {\n      internals[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);\n    }\n    values.forEach(v => {\n      _basePush.call(__array, v);\n    });\n  }\n  internals[arrayPathSymbol] = path;\n  internals.__array = __array;\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020 && #3034)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc && doc instanceof Document) {\n    internals[arrayParentSymbol] = doc;\n    internals[arraySchemaSymbol] = doc.$__schema.path(path);\n\n    // `schema.path()` doesn't drill into nested arrays properly yet, see\n    // gh-6398, gh-6602. This is a workaround because nested arrays are\n    // always plain non-document arrays, so once you get to a document array\n    // nesting is done. Matryoshka code.\n    while (internals[arraySchemaSymbol] != null &&\n        internals[arraySchemaSymbol].$isMongooseArray &&\n        !internals[arraySchemaSymbol].$isMongooseDocumentArray) {\n      internals[arraySchemaSymbol] = internals[arraySchemaSymbol].casterConstructor;\n    }\n  }\n\n  const proxy = new Proxy(__array, {\n    get: function(target, prop) {\n      if (prop === 'isMongooseArray' ||\n          prop === 'isMongooseArrayProxy' ||\n          prop === 'isMongooseDocumentArray' ||\n          prop === 'isMongooseDocumentArrayProxy') {\n        return true;\n      }\n      if (internals.hasOwnProperty(prop)) {\n        return internals[prop];\n      }\n      if (DocumentArrayMethods.hasOwnProperty(prop)) {\n        return DocumentArrayMethods[prop];\n      }\n      if (ArrayMethods.hasOwnProperty(prop)) {\n        return ArrayMethods[prop];\n      }\n\n      return __array[prop];\n    },\n    set: function(target, prop, value) {\n      if (typeof prop === 'string' && numberRE.test(prop)) {\n        DocumentArrayMethods.set.call(proxy, prop, value, false);\n      } else if (internals.hasOwnProperty(prop)) {\n        internals[prop] = value;\n      } else {\n        __array[prop] = value;\n      }\n\n      return true;\n    }\n  });\n\n  return proxy;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = MongooseDocumentArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvRG9jdW1lbnRBcnJheS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMsZ0dBQWtCO0FBQy9DLDZCQUE2QixtQkFBTyxDQUFDLGlHQUFXO0FBQ2hELGlCQUFpQixtQkFBTyxDQUFDLDZFQUFnQjs7QUFFekMsMkJBQTJCLHFJQUFtRDtBQUM5RSxpQ0FBaUMsMklBQXlEO0FBQzFGLDBCQUEwQixvSUFBa0Q7QUFDNUUsd0JBQXdCLGtJQUFnRDtBQUN4RSwwQkFBMEIsb0lBQWtEOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcdHlwZXNcXERvY3VtZW50QXJyYXlcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IEFycmF5TWV0aG9kcyA9IHJlcXVpcmUoJy4uL2FycmF5L21ldGhvZHMnKTtcbmNvbnN0IERvY3VtZW50QXJyYXlNZXRob2RzID0gcmVxdWlyZSgnLi9tZXRob2RzJyk7XG5jb25zdCBEb2N1bWVudCA9IHJlcXVpcmUoJy4uLy4uL2RvY3VtZW50Jyk7XG5cbmNvbnN0IGFycmF5QXRvbWljc1N5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc1N5bWJvbDtcbmNvbnN0IGFycmF5QXRvbWljc0JhY2t1cFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc0JhY2t1cFN5bWJvbDtcbmNvbnN0IGFycmF5UGFyZW50U3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXJlbnRTeW1ib2w7XG5jb25zdCBhcnJheVBhdGhTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVBhdGhTeW1ib2w7XG5jb25zdCBhcnJheVNjaGVtYVN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5U2NoZW1hU3ltYm9sO1xuXG5jb25zdCBfYmFzZVB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbmNvbnN0IG51bWJlclJFID0gL15cXGQrJC87XG4vKipcbiAqIERvY3VtZW50QXJyYXkgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIHRoaXMgYXJyYXlcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBwYXJlbnQgZG9jdW1lbnRcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHJldHVybiB7TW9uZ29vc2VEb2N1bWVudEFycmF5fVxuICogQGluaGVyaXRzIE1vbmdvb3NlQXJyYXlcbiAqIEBzZWUgaHR0cHM6Ly9iaXQubHkvZjZDblpVXG4gKi9cblxuZnVuY3Rpb24gTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbHVlcywgcGF0aCwgZG9jKSB7XG4gIGNvbnN0IF9fYXJyYXkgPSBbXTtcblxuICBjb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgW2FycmF5QXRvbWljc1N5bWJvbF06IHt9LFxuICAgIFthcnJheUF0b21pY3NCYWNrdXBTeW1ib2xdOiB2b2lkIDAsXG4gICAgW2FycmF5UGF0aFN5bWJvbF06IHBhdGgsXG4gICAgW2FycmF5U2NoZW1hU3ltYm9sXTogdm9pZCAwLFxuICAgIFthcnJheVBhcmVudFN5bWJvbF06IHZvaWQgMFxuICB9O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICBpZiAodmFsdWVzW2FycmF5UGF0aFN5bWJvbF0gPT09IHBhdGggJiZcbiAgICAgICAgdmFsdWVzW2FycmF5UGFyZW50U3ltYm9sXSA9PT0gZG9jKSB7XG4gICAgICBpbnRlcm5hbHNbYXJyYXlBdG9taWNzU3ltYm9sXSA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlc1thcnJheUF0b21pY3NTeW1ib2xdKTtcbiAgICB9XG4gICAgdmFsdWVzLmZvckVhY2godiA9PiB7XG4gICAgICBfYmFzZVB1c2guY2FsbChfX2FycmF5LCB2KTtcbiAgICB9KTtcbiAgfVxuICBpbnRlcm5hbHNbYXJyYXlQYXRoU3ltYm9sXSA9IHBhdGg7XG4gIGludGVybmFscy5fX2FycmF5ID0gX19hcnJheTtcblxuICAvLyBCZWNhdXNlIGRvYyBjb21lcyBmcm9tIHRoZSBjb250ZXh0IG9mIGFub3RoZXIgZnVuY3Rpb24sIGRvYyA9PT0gZ2xvYmFsXG4gIC8vIGNhbiBoYXBwZW4gaWYgdGhlcmUgd2FzIGEgbnVsbCBzb21ld2hlcmUgdXAgdGhlIGNoYWluIChzZWUgIzMwMjAgJiYgIzMwMzQpXG4gIC8vIFJCIEp1biAxNywgMjAxNSB1cGRhdGVkIHRvIGNoZWNrIGZvciBwcmVzZW5jZSBvZiBleHBlY3RlZCBwYXRocyBpbnN0ZWFkXG4gIC8vIHRvIG1ha2UgbW9yZSBwcm9vZiBhZ2FpbnN0IHVudXN1YWwgbm9kZSBlbnZpcm9ubWVudHNcbiAgaWYgKGRvYyAmJiBkb2MgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgIGludGVybmFsc1thcnJheVBhcmVudFN5bWJvbF0gPSBkb2M7XG4gICAgaW50ZXJuYWxzW2FycmF5U2NoZW1hU3ltYm9sXSA9IGRvYy4kX19zY2hlbWEucGF0aChwYXRoKTtcblxuICAgIC8vIGBzY2hlbWEucGF0aCgpYCBkb2Vzbid0IGRyaWxsIGludG8gbmVzdGVkIGFycmF5cyBwcm9wZXJseSB5ZXQsIHNlZVxuICAgIC8vIGdoLTYzOTgsIGdoLTY2MDIuIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGJlY2F1c2UgbmVzdGVkIGFycmF5cyBhcmVcbiAgICAvLyBhbHdheXMgcGxhaW4gbm9uLWRvY3VtZW50IGFycmF5cywgc28gb25jZSB5b3UgZ2V0IHRvIGEgZG9jdW1lbnQgYXJyYXlcbiAgICAvLyBuZXN0aW5nIGlzIGRvbmUuIE1hdHJ5b3Noa2EgY29kZS5cbiAgICB3aGlsZSAoaW50ZXJuYWxzW2FycmF5U2NoZW1hU3ltYm9sXSAhPSBudWxsICYmXG4gICAgICAgIGludGVybmFsc1thcnJheVNjaGVtYVN5bWJvbF0uJGlzTW9uZ29vc2VBcnJheSAmJlxuICAgICAgICAhaW50ZXJuYWxzW2FycmF5U2NoZW1hU3ltYm9sXS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgIGludGVybmFsc1thcnJheVNjaGVtYVN5bWJvbF0gPSBpbnRlcm5hbHNbYXJyYXlTY2hlbWFTeW1ib2xdLmNhc3RlckNvbnN0cnVjdG9yO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KF9fYXJyYXksIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKHByb3AgPT09ICdpc01vbmdvb3NlQXJyYXknIHx8XG4gICAgICAgICAgcHJvcCA9PT0gJ2lzTW9uZ29vc2VBcnJheVByb3h5JyB8fFxuICAgICAgICAgIHByb3AgPT09ICdpc01vbmdvb3NlRG9jdW1lbnRBcnJheScgfHxcbiAgICAgICAgICBwcm9wID09PSAnaXNNb25nb29zZURvY3VtZW50QXJyYXlQcm94eScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW50ZXJuYWxzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHNbcHJvcF07XG4gICAgICB9XG4gICAgICBpZiAoRG9jdW1lbnRBcnJheU1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIERvY3VtZW50QXJyYXlNZXRob2RzW3Byb3BdO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5TWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICByZXR1cm4gQXJyYXlNZXRob2RzW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX19hcnJheVtwcm9wXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyAmJiBudW1iZXJSRS50ZXN0KHByb3ApKSB7XG4gICAgICAgIERvY3VtZW50QXJyYXlNZXRob2RzLnNldC5jYWxsKHByb3h5LCBwcm9wLCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcm5hbHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgaW50ZXJuYWxzW3Byb3BdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfX2FycmF5W3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHByb3h5O1xufVxuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTW9uZ29vc2VEb2N1bWVudEFycmF5O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/DocumentArray/index.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/DocumentArray/isMongooseDocumentArray.js":
/*!******************************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/DocumentArray/isMongooseDocumentArray.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.isMongooseDocumentArray = function(mongooseDocumentArray) {\n  return Array.isArray(mongooseDocumentArray) && mongooseDocumentArray.isMongooseDocumentArray;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvRG9jdW1lbnRBcnJheS9pc01vbmdvb3NlRG9jdW1lbnRBcnJheS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwrQkFBK0I7QUFDL0I7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHR5cGVzXFxEb2N1bWVudEFycmF5XFxpc01vbmdvb3NlRG9jdW1lbnRBcnJheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkgPSBmdW5jdGlvbihtb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobW9uZ29vc2VEb2N1bWVudEFycmF5KSAmJiBtb25nb29zZURvY3VtZW50QXJyYXkuaXNNb25nb29zZURvY3VtZW50QXJyYXk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/DocumentArray/isMongooseDocumentArray.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/DocumentArray/methods/index.js":
/*!********************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/DocumentArray/methods/index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst ArrayMethods = __webpack_require__(/*! ../../array/methods */ \"(api)/../server/node_modules/mongoose/lib/types/array/methods/index.js\");\nconst Document = __webpack_require__(/*! ../../../document */ \"(api)/../server/node_modules/mongoose/lib/document.js\");\nconst castObjectId = __webpack_require__(/*! ../../../cast/objectid */ \"(api)/../server/node_modules/mongoose/lib/cast/objectid.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../../../helpers/discriminator/getDiscriminatorByValue */ \"(api)/../server/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../../../options */ \"(api)/../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst utils = __webpack_require__(/*! ../../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../../../helpers/isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst arrayParentSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\nconst documentArrayParent = (__webpack_require__(/*! ../../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\n\nconst methods = {\n  /*!\n   * ignore\n   */\n\n  toBSON() {\n    return this.toObject(internalToObjectOptions);\n  },\n\n  /*!\n   * ignore\n   */\n\n  getArrayParent() {\n    return this[arrayParentSymbol];\n  },\n\n  /**\n   * Overrides MongooseArray#cast\n   *\n   * @method _cast\n   * @api private\n   * @memberOf MongooseDocumentArray\n   */\n\n  _cast(value, index, options) {\n    if (this[arraySchemaSymbol] == null) {\n      return value;\n    }\n    let Constructor = this[arraySchemaSymbol].casterConstructor;\n    const isInstance = Constructor.$isMongooseDocumentArray ?\n      utils.isMongooseDocumentArray(value) :\n      value instanceof Constructor;\n    if (isInstance ||\n        // Hack re: #5001, see #5005\n        (value && value.constructor && value.constructor.baseCasterConstructor === Constructor)) {\n      if (!(value[documentArrayParent] && value.__parentArray)) {\n        // value may have been created using array.create()\n        value[documentArrayParent] = this[arrayParentSymbol];\n        value.__parentArray = this;\n      }\n      value.$setIndex(index);\n      return value;\n    }\n\n    if (value === undefined || value === null) {\n      return null;\n    }\n\n    // handle cast('string') or cast(ObjectId) etc.\n    // only objects are permitted so we can safely assume that\n    // non-objects are to be interpreted as _id\n    if (Buffer.isBuffer(value) ||\n        isBsonType(value, 'ObjectId') || !utils.isObject(value)) {\n      value = { _id: value };\n    }\n\n    if (value &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof value[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    if (Constructor.$isMongooseDocumentArray) {\n      return Constructor.cast(value, this, undefined, undefined, index);\n    }\n    const ret = new Constructor(value, this, options, undefined, index);\n    ret.isNew = true;\n    return ret;\n  },\n\n  /**\n   * Searches array items for the first document with a matching _id.\n   *\n   * #### Example:\n   *\n   *     const embeddedDoc = m.array.id(some_id);\n   *\n   * @return {EmbeddedDocument|null} the subdocument or null if not found.\n   * @param {ObjectId|String|Number|Buffer} id\n   * @TODO cast to the _id based on schema for proper comparison\n   * @method id\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  id(id) {\n    let casted;\n    let sid;\n    let _id;\n\n    try {\n      casted = castObjectId(id).toString();\n    } catch (e) {\n      casted = null;\n    }\n\n    for (const val of this) {\n      if (!val) {\n        continue;\n      }\n\n      _id = val.get('_id');\n\n      if (_id === null || typeof _id === 'undefined') {\n        continue;\n      } else if (_id instanceof Document) {\n        sid || (sid = String(id));\n        if (sid == _id._id) {\n          return val;\n        }\n      } else if (!isBsonType(id, 'ObjectId') && !isBsonType(_id, 'ObjectId')) {\n        if (id == _id || utils.deepEqual(id, _id)) {\n          return val;\n        }\n      } else if (casted == _id) {\n        return val;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Returns a native js Array of plain js objects\n   *\n   * #### Note:\n   *\n   * _Each sub-document is converted to a plain object by calling its `#toObject` method._\n   *\n   * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion\n   * @return {Array}\n   * @method toObject\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  toObject(options) {\n    // `[].concat` coerces the return value into a vanilla JS array, rather\n    // than a Mongoose array.\n    return [].concat(this.map(function(doc) {\n      if (doc == null) {\n        return null;\n      }\n      if (typeof doc.toObject !== 'function') {\n        return doc;\n      }\n      return doc.toObject(options);\n    }));\n  },\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * @param {...Object} [args]\n   * @api public\n   * @method push\n   * @memberOf MongooseDocumentArray\n   */\n\n  push() {\n    const ret = ArrayMethods.push.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically.\n   *\n   * @param {...Object} [args]\n   * @api public\n   * @method pull\n   * @memberOf MongooseDocumentArray\n   */\n\n  pull() {\n    const ret = ArrayMethods.pull.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   * @api private\n   */\n\n  shift() {\n    const ret = ArrayMethods.shift.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   * @api private\n   */\n\n  splice() {\n    const ret = ArrayMethods.splice.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @method inspect\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  inspect() {\n    return this.toObject();\n  },\n\n  /**\n   * Creates a subdocument casted to this schema.\n   *\n   * This is the same subdocument constructor used for casting.\n   *\n   * @param {Object} obj the value to cast to this arrays SubDocument schema\n   * @method create\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  create(obj) {\n    let Constructor = this[arraySchemaSymbol].casterConstructor;\n    if (obj &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof obj[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, obj[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    return new Constructor(obj, this);\n  },\n\n  /*!\n   * ignore\n   */\n\n  notify(event) {\n    const _this = this;\n    return function notify(val, _arr) {\n      _arr = _arr || _this;\n      let i = _arr.length;\n      while (i--) {\n        if (_arr[i] == null) {\n          continue;\n        }\n        switch (event) {\n          // only swap for save event for now, we may change this to all event types later\n          case 'save':\n            val = _this[i];\n            break;\n          default:\n            // NO-OP\n            break;\n        }\n\n        if (utils.isMongooseArray(_arr[i])) {\n          notify(val, _arr[i]);\n        } else if (_arr[i]) {\n          _arr[i].emit(event, val);\n        }\n      }\n    };\n  },\n\n  set(i, val, skipModified) {\n    const arr = this.__array;\n    if (skipModified) {\n      arr[i] = val;\n      return this;\n    }\n    const value = methods._cast.call(this, val, i);\n    methods._markModified.call(this, i);\n    arr[i] = value;\n    return this;\n  },\n\n  _markModified(elem, embeddedPath) {\n    const parent = this[arrayParentSymbol];\n    let dirtyPath;\n\n    if (parent) {\n      dirtyPath = this[arrayPathSymbol];\n\n      if (arguments.length) {\n        if (embeddedPath != null) {\n          // an embedded doc bubbled up the change\n          const index = elem.__index;\n          dirtyPath = dirtyPath + '.' + index + '.' + embeddedPath;\n        } else {\n          // directly set an index\n          dirtyPath = dirtyPath + '.' + elem;\n        }\n      }\n\n      if (dirtyPath != null && dirtyPath.endsWith('.$')) {\n        return this;\n      }\n\n      parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);\n    }\n\n    return this;\n  }\n};\n\nmodule.exports = methods;\n\n/**\n * If this is a document array, each element may contain single\n * populated paths, so we need to modify the top-level document's\n * populated cache. See gh-8247, gh-8265.\n * @param {Array} arr\n * @api private\n */\n\nfunction _updateParentPopulated(arr) {\n  const parent = arr[arrayParentSymbol];\n  if (!parent || parent.$__.populated == null) return;\n\n  const populatedPaths = Object.keys(parent.$__.populated).\n    filter(p => p.startsWith(arr[arrayPathSymbol] + '.'));\n\n  for (const path of populatedPaths) {\n    const remnant = path.slice((arr[arrayPathSymbol] + '.').length);\n    if (!Array.isArray(parent.$__.populated[path].value)) {\n      continue;\n    }\n\n    parent.$__.populated[path].value = arr.map(val => val.$populated(remnant));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvRG9jdW1lbnRBcnJheS9tZXRob2RzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLG1HQUFxQjtBQUNsRCxpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsMEZBQXdCO0FBQ3JELGdDQUFnQyxtQkFBTyxDQUFDLDBKQUF3RDtBQUNoRyxnQ0FBZ0MsNkhBQW1EO0FBQ25GLGNBQWMsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDdEMsbUJBQW1CLG1CQUFPLENBQUMsb0dBQTZCOztBQUV4RCwwQkFBMEIsdUlBQXFEO0FBQy9FLHdCQUF3QixxSUFBbUQ7QUFDM0UsMEJBQTBCLHVJQUFxRDtBQUMvRSw0QkFBNEIseUlBQXVEOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcdHlwZXNcXERvY3VtZW50QXJyYXlcXG1ldGhvZHNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXJyYXlNZXRob2RzID0gcmVxdWlyZSgnLi4vLi4vYXJyYXkvbWV0aG9kcycpO1xuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9kb2N1bWVudCcpO1xuY29uc3QgY2FzdE9iamVjdElkID0gcmVxdWlyZSgnLi4vLi4vLi4vY2FzdC9vYmplY3RpZCcpO1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi4vLi4vLi4vb3B0aW9ucycpLmludGVybmFsVG9PYmplY3RPcHRpb25zO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuXG5jb25zdCBhcnJheVBhcmVudFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGFyZW50U3ltYm9sO1xuY29uc3QgYXJyYXlQYXRoU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXRoU3ltYm9sO1xuY29uc3QgYXJyYXlTY2hlbWFTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVNjaGVtYVN5bWJvbDtcbmNvbnN0IGRvY3VtZW50QXJyYXlQYXJlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5kb2N1bWVudEFycmF5UGFyZW50O1xuXG5jb25zdCBtZXRob2RzID0ge1xuICAvKiFcbiAgICogaWdub3JlXG4gICAqL1xuXG4gIHRvQlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gIH0sXG5cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cblxuICBnZXRBcnJheVBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpc1thcnJheVBhcmVudFN5bWJvbF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBNb25nb29zZUFycmF5I2Nhc3RcbiAgICpcbiAgICogQG1ldGhvZCBfY2FzdFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlRG9jdW1lbnRBcnJheVxuICAgKi9cblxuICBfY2FzdCh2YWx1ZSwgaW5kZXgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpc1thcnJheVNjaGVtYVN5bWJvbF0gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgQ29uc3RydWN0b3IgPSB0aGlzW2FycmF5U2NoZW1hU3ltYm9sXS5jYXN0ZXJDb25zdHJ1Y3RvcjtcbiAgICBjb25zdCBpc0luc3RhbmNlID0gQ29uc3RydWN0b3IuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ID9cbiAgICAgIHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbHVlKSA6XG4gICAgICB2YWx1ZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yO1xuICAgIGlmIChpc0luc3RhbmNlIHx8XG4gICAgICAgIC8vIEhhY2sgcmU6ICM1MDAxLCBzZWUgIzUwMDVcbiAgICAgICAgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLmJhc2VDYXN0ZXJDb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpKSB7XG4gICAgICBpZiAoISh2YWx1ZVtkb2N1bWVudEFycmF5UGFyZW50XSAmJiB2YWx1ZS5fX3BhcmVudEFycmF5KSkge1xuICAgICAgICAvLyB2YWx1ZSBtYXkgaGF2ZSBiZWVuIGNyZWF0ZWQgdXNpbmcgYXJyYXkuY3JlYXRlKClcbiAgICAgICAgdmFsdWVbZG9jdW1lbnRBcnJheVBhcmVudF0gPSB0aGlzW2FycmF5UGFyZW50U3ltYm9sXTtcbiAgICAgICAgdmFsdWUuX19wYXJlbnRBcnJheSA9IHRoaXM7XG4gICAgICB9XG4gICAgICB2YWx1ZS4kc2V0SW5kZXgoaW5kZXgpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgY2FzdCgnc3RyaW5nJykgb3IgY2FzdChPYmplY3RJZCkgZXRjLlxuICAgIC8vIG9ubHkgb2JqZWN0cyBhcmUgcGVybWl0dGVkIHNvIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoYXRcbiAgICAvLyBub24tb2JqZWN0cyBhcmUgdG8gYmUgaW50ZXJwcmV0ZWQgYXMgX2lkXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgfHxcbiAgICAgICAgaXNCc29uVHlwZSh2YWx1ZSwgJ09iamVjdElkJykgfHwgIXV0aWxzLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB7IF9pZDogdmFsdWUgfTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMgJiZcbiAgICAgICAgQ29uc3RydWN0b3Iuc2NoZW1hICYmXG4gICAgICAgIENvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zICYmXG4gICAgICAgIENvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnNbdmFsdWVbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV1dKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnNbdmFsdWVbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3JCeVZhbHVlID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUoQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMsIHZhbHVlW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldKTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yQnlWYWx1ZSkge1xuICAgICAgICAgIENvbnN0cnVjdG9yID0gY29uc3RydWN0b3JCeVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKENvbnN0cnVjdG9yLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLmNhc3QodmFsdWUsIHRoaXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IG5ldyBDb25zdHJ1Y3Rvcih2YWx1ZSwgdGhpcywgb3B0aW9ucywgdW5kZWZpbmVkLCBpbmRleCk7XG4gICAgcmV0LmlzTmV3ID0gdHJ1ZTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyBhcnJheSBpdGVtcyBmb3IgdGhlIGZpcnN0IGRvY3VtZW50IHdpdGggYSBtYXRjaGluZyBfaWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICpcbiAgICogICAgIGNvbnN0IGVtYmVkZGVkRG9jID0gbS5hcnJheS5pZChzb21lX2lkKTtcbiAgICpcbiAgICogQHJldHVybiB7RW1iZWRkZWREb2N1bWVudHxudWxsfSB0aGUgc3ViZG9jdW1lbnQgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAqIEBwYXJhbSB7T2JqZWN0SWR8U3RyaW5nfE51bWJlcnxCdWZmZXJ9IGlkXG4gICAqIEBUT0RPIGNhc3QgdG8gdGhlIF9pZCBiYXNlZCBvbiBzY2hlbWEgZm9yIHByb3BlciBjb21wYXJpc29uXG4gICAqIEBtZXRob2QgaWRcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlRG9jdW1lbnRBcnJheVxuICAgKi9cblxuICBpZChpZCkge1xuICAgIGxldCBjYXN0ZWQ7XG4gICAgbGV0IHNpZDtcbiAgICBsZXQgX2lkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhc3RlZCA9IGNhc3RPYmplY3RJZChpZCkudG9TdHJpbmcoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYXN0ZWQgPSBudWxsO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMpIHtcbiAgICAgIGlmICghdmFsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBfaWQgPSB2YWwuZ2V0KCdfaWQnKTtcblxuICAgICAgaWYgKF9pZCA9PT0gbnVsbCB8fCB0eXBlb2YgX2lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoX2lkIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgc2lkIHx8IChzaWQgPSBTdHJpbmcoaWQpKTtcbiAgICAgICAgaWYgKHNpZCA9PSBfaWQuX2lkKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNCc29uVHlwZShpZCwgJ09iamVjdElkJykgJiYgIWlzQnNvblR5cGUoX2lkLCAnT2JqZWN0SWQnKSkge1xuICAgICAgICBpZiAoaWQgPT0gX2lkIHx8IHV0aWxzLmRlZXBFcXVhbChpZCwgX2lkKSkge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2FzdGVkID09IF9pZCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmF0aXZlIGpzIEFycmF5IG9mIHBsYWluIGpzIG9iamVjdHNcbiAgICpcbiAgICogIyMjIyBOb3RlOlxuICAgKlxuICAgKiBfRWFjaCBzdWItZG9jdW1lbnQgaXMgY29udmVydGVkIHRvIGEgcGxhaW4gb2JqZWN0IGJ5IGNhbGxpbmcgaXRzIGAjdG9PYmplY3RgIG1ldGhvZC5fXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIGVhY2ggZG9jdW1lbnRzIGB0b09iamVjdGAgbWV0aG9kIGNhbGwgZHVyaW5nIGNvbnZlcnNpb25cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlRG9jdW1lbnRBcnJheVxuICAgKi9cblxuICB0b09iamVjdChvcHRpb25zKSB7XG4gICAgLy8gYFtdLmNvbmNhdGAgY29lcmNlcyB0aGUgcmV0dXJuIHZhbHVlIGludG8gYSB2YW5pbGxhIEpTIGFycmF5LCByYXRoZXJcbiAgICAvLyB0aGFuIGEgTW9uZ29vc2UgYXJyYXkuXG4gICAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLm1hcChmdW5jdGlvbihkb2MpIHtcbiAgICAgIGlmIChkb2MgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZG9jLnRvT2JqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9jLnRvT2JqZWN0KG9wdGlvbnMpO1xuICAgIH0pKTtcbiAgfSxcblxuICAkdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnRvT2JqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjcHVzaGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3B1c2gpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IFthcmdzXVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHB1c2hcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlRG9jdW1lbnRBcnJheVxuICAgKi9cblxuICBwdXNoKCkge1xuICAgIGNvbnN0IHJldCA9IEFycmF5TWV0aG9kcy5wdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBfdXBkYXRlUGFyZW50UG9wdWxhdGVkKHRoaXMpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogUHVsbHMgaXRlbXMgZnJvbSB0aGUgYXJyYXkgYXRvbWljYWxseS5cbiAgICpcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IFthcmdzXVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHB1bGxcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlRG9jdW1lbnRBcnJheVxuICAgKi9cblxuICBwdWxsKCkge1xuICAgIGNvbnN0IHJldCA9IEFycmF5TWV0aG9kcy5wdWxsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBfdXBkYXRlUGFyZW50UG9wdWxhdGVkKHRoaXMpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogV3JhcHMgW2BBcnJheSNzaGlmdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3Vuc2hpZnQpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIHNoaWZ0KCkge1xuICAgIGNvbnN0IHJldCA9IEFycmF5TWV0aG9kcy5zaGlmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgX3VwZGF0ZVBhcmVudFBvcHVsYXRlZCh0aGlzKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjc3BsaWNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc3BsaWNlKSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcgYW5kIGNhc3RpbmcuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBzcGxpY2UoKSB7XG4gICAgY29uc3QgcmV0ID0gQXJyYXlNZXRob2RzLnNwbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgX3VwZGF0ZVBhcmVudFBvcHVsYXRlZCh0aGlzKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgY29uc29sZS5sb2dcbiAgICpcbiAgICogQG1ldGhvZCBpbnNwZWN0XG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZURvY3VtZW50QXJyYXlcbiAgICovXG5cbiAgaW5zcGVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy50b09iamVjdCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3ViZG9jdW1lbnQgY2FzdGVkIHRvIHRoaXMgc2NoZW1hLlxuICAgKlxuICAgKiBUaGlzIGlzIHRoZSBzYW1lIHN1YmRvY3VtZW50IGNvbnN0cnVjdG9yIHVzZWQgZm9yIGNhc3RpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIHZhbHVlIHRvIGNhc3QgdG8gdGhpcyBhcnJheXMgU3ViRG9jdW1lbnQgc2NoZW1hXG4gICAqIEBtZXRob2QgY3JlYXRlXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZURvY3VtZW50QXJyYXlcbiAgICovXG5cbiAgY3JlYXRlKG9iaikge1xuICAgIGxldCBDb25zdHJ1Y3RvciA9IHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdLmNhc3RlckNvbnN0cnVjdG9yO1xuICAgIGlmIChvYmogJiZcbiAgICAgICAgQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMgJiZcbiAgICAgICAgQ29uc3RydWN0b3Iuc2NoZW1hICYmXG4gICAgICAgIENvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zICYmXG4gICAgICAgIENvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgIENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW29ialtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1tvYmpbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3JCeVZhbHVlID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUoQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMsIG9ialtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSk7XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvckJ5VmFsdWUpIHtcbiAgICAgICAgICBDb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yQnlWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3Iob2JqLCB0aGlzKTtcbiAgfSxcblxuICAvKiFcbiAgICogaWdub3JlXG4gICAqL1xuXG4gIG5vdGlmeShldmVudCkge1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24gbm90aWZ5KHZhbCwgX2Fycikge1xuICAgICAgX2FyciA9IF9hcnIgfHwgX3RoaXM7XG4gICAgICBsZXQgaSA9IF9hcnIubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoX2FycltpXSA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICAgIC8vIG9ubHkgc3dhcCBmb3Igc2F2ZSBldmVudCBmb3Igbm93LCB3ZSBtYXkgY2hhbmdlIHRoaXMgdG8gYWxsIGV2ZW50IHR5cGVzIGxhdGVyXG4gICAgICAgICAgY2FzZSAnc2F2ZSc6XG4gICAgICAgICAgICB2YWwgPSBfdGhpc1tpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBOTy1PUFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNNb25nb29zZUFycmF5KF9hcnJbaV0pKSB7XG4gICAgICAgICAgbm90aWZ5KHZhbCwgX2FycltpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2FycltpXSkge1xuICAgICAgICAgIF9hcnJbaV0uZW1pdChldmVudCwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgc2V0KGksIHZhbCwgc2tpcE1vZGlmaWVkKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5fX2FycmF5O1xuICAgIGlmIChza2lwTW9kaWZpZWQpIHtcbiAgICAgIGFycltpXSA9IHZhbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IG1ldGhvZHMuX2Nhc3QuY2FsbCh0aGlzLCB2YWwsIGkpO1xuICAgIG1ldGhvZHMuX21hcmtNb2RpZmllZC5jYWxsKHRoaXMsIGkpO1xuICAgIGFycltpXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9tYXJrTW9kaWZpZWQoZWxlbSwgZW1iZWRkZWRQYXRoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpc1thcnJheVBhcmVudFN5bWJvbF07XG4gICAgbGV0IGRpcnR5UGF0aDtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGRpcnR5UGF0aCA9IHRoaXNbYXJyYXlQYXRoU3ltYm9sXTtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGVtYmVkZGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gYW4gZW1iZWRkZWQgZG9jIGJ1YmJsZWQgdXAgdGhlIGNoYW5nZVxuICAgICAgICAgIGNvbnN0IGluZGV4ID0gZWxlbS5fX2luZGV4O1xuICAgICAgICAgIGRpcnR5UGF0aCA9IGRpcnR5UGF0aCArICcuJyArIGluZGV4ICsgJy4nICsgZW1iZWRkZWRQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRpcmVjdGx5IHNldCBhbiBpbmRleFxuICAgICAgICAgIGRpcnR5UGF0aCA9IGRpcnR5UGF0aCArICcuJyArIGVsZW07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5UGF0aCAhPSBudWxsICYmIGRpcnR5UGF0aC5lbmRzV2l0aCgnLiQnKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcGFyZW50Lm1hcmtNb2RpZmllZChkaXJ0eVBhdGgsIGFyZ3VtZW50cy5sZW5ndGggIT09IDAgPyBlbGVtIDogcGFyZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXRob2RzO1xuXG4vKipcbiAqIElmIHRoaXMgaXMgYSBkb2N1bWVudCBhcnJheSwgZWFjaCBlbGVtZW50IG1heSBjb250YWluIHNpbmdsZVxuICogcG9wdWxhdGVkIHBhdGhzLCBzbyB3ZSBuZWVkIHRvIG1vZGlmeSB0aGUgdG9wLWxldmVsIGRvY3VtZW50J3NcbiAqIHBvcHVsYXRlZCBjYWNoZS4gU2VlIGdoLTgyNDcsIGdoLTgyNjUuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF91cGRhdGVQYXJlbnRQb3B1bGF0ZWQoYXJyKSB7XG4gIGNvbnN0IHBhcmVudCA9IGFyclthcnJheVBhcmVudFN5bWJvbF07XG4gIGlmICghcGFyZW50IHx8IHBhcmVudC4kX18ucG9wdWxhdGVkID09IG51bGwpIHJldHVybjtcblxuICBjb25zdCBwb3B1bGF0ZWRQYXRocyA9IE9iamVjdC5rZXlzKHBhcmVudC4kX18ucG9wdWxhdGVkKS5cbiAgICBmaWx0ZXIocCA9PiBwLnN0YXJ0c1dpdGgoYXJyW2FycmF5UGF0aFN5bWJvbF0gKyAnLicpKTtcblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcG9wdWxhdGVkUGF0aHMpIHtcbiAgICBjb25zdCByZW1uYW50ID0gcGF0aC5zbGljZSgoYXJyW2FycmF5UGF0aFN5bWJvbF0gKyAnLicpLmxlbmd0aCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmVudC4kX18ucG9wdWxhdGVkW3BhdGhdLnZhbHVlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGFyZW50LiRfXy5wb3B1bGF0ZWRbcGF0aF0udmFsdWUgPSBhcnIubWFwKHZhbCA9PiB2YWwuJHBvcHVsYXRlZChyZW1uYW50KSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/DocumentArray/methods/index.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/array/index.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/array/index.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst Document = __webpack_require__(/*! ../../document */ \"(api)/../server/node_modules/mongoose/lib/document.js\");\nconst mongooseArrayMethods = __webpack_require__(/*! ./methods */ \"(api)/../server/node_modules/mongoose/lib/types/array/methods/index.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayAtomicsBackupSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsBackupSymbol);\nconst arrayParentSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\n\n/**\n * Mongoose Array constructor.\n *\n * #### Note:\n *\n * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._\n *\n * @param {Array} values\n * @param {String} path\n * @param {Document} doc parent document\n * @api private\n * @inherits Array https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\n * @see https://bit.ly/f6CnZU\n */\nconst _basePush = Array.prototype.push;\nconst numberRE = /^\\d+$/;\n\nfunction MongooseArray(values, path, doc, schematype) {\n  let __array;\n\n  if (Array.isArray(values)) {\n    const len = values.length;\n\n    // Perf optimizations for small arrays: much faster to use `...` than `for` + `push`,\n    // but large arrays may cause stack overflows. And for arrays of length 0/1, just\n    // modifying the array is faster. Seems small, but adds up when you have a document\n    // with thousands of nested arrays.\n    if (len === 0) {\n      __array = new Array();\n    } else if (len === 1) {\n      __array = new Array(1);\n      __array[0] = values[0];\n    } else if (len < 10000) {\n      __array = new Array();\n      _basePush.apply(__array, values);\n    } else {\n      __array = new Array();\n      for (let i = 0; i < len; ++i) {\n        _basePush.call(__array, values[i]);\n      }\n    }\n  } else {\n    __array = [];\n  }\n\n  const internals = {\n    [arrayAtomicsSymbol]: {},\n    [arrayAtomicsBackupSymbol]: void 0,\n    [arrayPathSymbol]: path,\n    [arraySchemaSymbol]: schematype,\n    [arrayParentSymbol]: void 0,\n    isMongooseArray: true,\n    isMongooseArrayProxy: true,\n    __array: __array\n  };\n\n  if (values && values[arrayAtomicsSymbol] != null) {\n    internals[arrayAtomicsSymbol] = values[arrayAtomicsSymbol];\n  }\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc != null && doc instanceof Document) {\n    internals[arrayParentSymbol] = doc;\n    internals[arraySchemaSymbol] = schematype || doc.schema.path(path);\n  }\n\n  const proxy = new Proxy(__array, {\n    get: function(target, prop) {\n      if (internals.hasOwnProperty(prop)) {\n        return internals[prop];\n      }\n      if (mongooseArrayMethods.hasOwnProperty(prop)) {\n        return mongooseArrayMethods[prop];\n      }\n      if (typeof prop === 'string' && numberRE.test(prop) && schematype?.$embeddedSchemaType != null) {\n        return schematype.$embeddedSchemaType.applyGetters(__array[prop], doc);\n      }\n\n      return __array[prop];\n    },\n    set: function(target, prop, value) {\n      if (typeof prop === 'string' && numberRE.test(prop)) {\n        mongooseArrayMethods.set.call(proxy, prop, value, false);\n      } else if (internals.hasOwnProperty(prop)) {\n        internals[prop] = value;\n      } else {\n        __array[prop] = value;\n      }\n\n      return true;\n    }\n  });\n\n  return proxy;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYXJyYXkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFnQjtBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyx5RkFBVzs7QUFFaEQsMkJBQTJCLHFJQUFtRDtBQUM5RSxpQ0FBaUMsMklBQXlEO0FBQzFGLDBCQUEwQixvSUFBa0Q7QUFDNUUsd0JBQXdCLGtJQUFnRDtBQUN4RSwwQkFBMEIsb0lBQWtEOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHR5cGVzXFxhcnJheVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi8uLi9kb2N1bWVudCcpO1xuY29uc3QgbW9uZ29vc2VBcnJheU1ldGhvZHMgPSByZXF1aXJlKCcuL21ldGhvZHMnKTtcblxuY29uc3QgYXJyYXlBdG9taWNzU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzU3ltYm9sO1xuY29uc3QgYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sO1xuY29uc3QgYXJyYXlQYXJlbnRTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVBhcmVudFN5bWJvbDtcbmNvbnN0IGFycmF5UGF0aFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGF0aFN5bWJvbDtcbmNvbnN0IGFycmF5U2NoZW1hU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlTY2hlbWFTeW1ib2w7XG5cbi8qKlxuICogTW9uZ29vc2UgQXJyYXkgY29uc3RydWN0b3IuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIF9WYWx1ZXMgYWx3YXlzIGhhdmUgdG8gYmUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciB0byBpbml0aWFsaXplLCBvdGhlcndpc2UgYE1vbmdvb3NlQXJyYXkjcHVzaGAgd2lsbCBtYXJrIHRoZSBhcnJheSBhcyBtb2RpZmllZC5fXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIHBhcmVudCBkb2N1bWVudFxuICogQGFwaSBwcml2YXRlXG4gKiBAaW5oZXJpdHMgQXJyYXkgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXlcbiAqIEBzZWUgaHR0cHM6Ly9iaXQubHkvZjZDblpVXG4gKi9cbmNvbnN0IF9iYXNlUHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuY29uc3QgbnVtYmVyUkUgPSAvXlxcZCskLztcblxuZnVuY3Rpb24gTW9uZ29vc2VBcnJheSh2YWx1ZXMsIHBhdGgsIGRvYywgc2NoZW1hdHlwZSkge1xuICBsZXQgX19hcnJheTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgY29uc3QgbGVuID0gdmFsdWVzLmxlbmd0aDtcblxuICAgIC8vIFBlcmYgb3B0aW1pemF0aW9ucyBmb3Igc21hbGwgYXJyYXlzOiBtdWNoIGZhc3RlciB0byB1c2UgYC4uLmAgdGhhbiBgZm9yYCArIGBwdXNoYCxcbiAgICAvLyBidXQgbGFyZ2UgYXJyYXlzIG1heSBjYXVzZSBzdGFjayBvdmVyZmxvd3MuIEFuZCBmb3IgYXJyYXlzIG9mIGxlbmd0aCAwLzEsIGp1c3RcbiAgICAvLyBtb2RpZnlpbmcgdGhlIGFycmF5IGlzIGZhc3Rlci4gU2VlbXMgc21hbGwsIGJ1dCBhZGRzIHVwIHdoZW4geW91IGhhdmUgYSBkb2N1bWVudFxuICAgIC8vIHdpdGggdGhvdXNhbmRzIG9mIG5lc3RlZCBhcnJheXMuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgX19hcnJheSA9IG5ldyBBcnJheSgpO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAxKSB7XG4gICAgICBfX2FycmF5ID0gbmV3IEFycmF5KDEpO1xuICAgICAgX19hcnJheVswXSA9IHZhbHVlc1swXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAwKSB7XG4gICAgICBfX2FycmF5ID0gbmV3IEFycmF5KCk7XG4gICAgICBfYmFzZVB1c2guYXBwbHkoX19hcnJheSwgdmFsdWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX19hcnJheSA9IG5ldyBBcnJheSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBfYmFzZVB1c2guY2FsbChfX2FycmF5LCB2YWx1ZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBfX2FycmF5ID0gW107XG4gIH1cblxuICBjb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgW2FycmF5QXRvbWljc1N5bWJvbF06IHt9LFxuICAgIFthcnJheUF0b21pY3NCYWNrdXBTeW1ib2xdOiB2b2lkIDAsXG4gICAgW2FycmF5UGF0aFN5bWJvbF06IHBhdGgsXG4gICAgW2FycmF5U2NoZW1hU3ltYm9sXTogc2NoZW1hdHlwZSxcbiAgICBbYXJyYXlQYXJlbnRTeW1ib2xdOiB2b2lkIDAsXG4gICAgaXNNb25nb29zZUFycmF5OiB0cnVlLFxuICAgIGlzTW9uZ29vc2VBcnJheVByb3h5OiB0cnVlLFxuICAgIF9fYXJyYXk6IF9fYXJyYXlcbiAgfTtcblxuICBpZiAodmFsdWVzICYmIHZhbHVlc1thcnJheUF0b21pY3NTeW1ib2xdICE9IG51bGwpIHtcbiAgICBpbnRlcm5hbHNbYXJyYXlBdG9taWNzU3ltYm9sXSA9IHZhbHVlc1thcnJheUF0b21pY3NTeW1ib2xdO1xuICB9XG5cbiAgLy8gQmVjYXVzZSBkb2MgY29tZXMgZnJvbSB0aGUgY29udGV4dCBvZiBhbm90aGVyIGZ1bmN0aW9uLCBkb2MgPT09IGdsb2JhbFxuICAvLyBjYW4gaGFwcGVuIGlmIHRoZXJlIHdhcyBhIG51bGwgc29tZXdoZXJlIHVwIHRoZSBjaGFpbiAoc2VlICMzMDIwKVxuICAvLyBSQiBKdW4gMTcsIDIwMTUgdXBkYXRlZCB0byBjaGVjayBmb3IgcHJlc2VuY2Ugb2YgZXhwZWN0ZWQgcGF0aHMgaW5zdGVhZFxuICAvLyB0byBtYWtlIG1vcmUgcHJvb2YgYWdhaW5zdCB1bnVzdWFsIG5vZGUgZW52aXJvbm1lbnRzXG4gIGlmIChkb2MgIT0gbnVsbCAmJiBkb2MgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgIGludGVybmFsc1thcnJheVBhcmVudFN5bWJvbF0gPSBkb2M7XG4gICAgaW50ZXJuYWxzW2FycmF5U2NoZW1hU3ltYm9sXSA9IHNjaGVtYXR5cGUgfHwgZG9jLnNjaGVtYS5wYXRoKHBhdGgpO1xuICB9XG5cbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoX19hcnJheSwge1xuICAgIGdldDogZnVuY3Rpb24odGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAoaW50ZXJuYWxzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHNbcHJvcF07XG4gICAgICB9XG4gICAgICBpZiAobW9uZ29vc2VBcnJheU1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIG1vbmdvb3NlQXJyYXlNZXRob2RzW3Byb3BdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyAmJiBudW1iZXJSRS50ZXN0KHByb3ApICYmIHNjaGVtYXR5cGU/LiRlbWJlZGRlZFNjaGVtYVR5cGUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2NoZW1hdHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLmFwcGx5R2V0dGVycyhfX2FycmF5W3Byb3BdLCBkb2MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX19hcnJheVtwcm9wXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyAmJiBudW1iZXJSRS50ZXN0KHByb3ApKSB7XG4gICAgICAgIG1vbmdvb3NlQXJyYXlNZXRob2RzLnNldC5jYWxsKHByb3h5LCBwcm9wLCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcm5hbHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgaW50ZXJuYWxzW3Byb3BdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfX2FycmF5W3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHByb3h5O1xufVxuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IE1vbmdvb3NlQXJyYXk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/array/index.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/array/isMongooseArray.js":
/*!**************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/array/isMongooseArray.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.isMongooseArray = function(mongooseArray) {\n  return Array.isArray(mongooseArray) && mongooseArray.isMongooseArray;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYXJyYXkvaXNNb25nb29zZUFycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHVCQUF1QjtBQUN2QjtBQUNBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcdHlwZXNcXGFycmF5XFxpc01vbmdvb3NlQXJyYXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmlzTW9uZ29vc2VBcnJheSA9IGZ1bmN0aW9uKG1vbmdvb3NlQXJyYXkpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobW9uZ29vc2VBcnJheSkgJiYgbW9uZ29vc2VBcnJheS5pc01vbmdvb3NlQXJyYXk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/array/isMongooseArray.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/array/methods/index.js":
/*!************************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/array/methods/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Document = __webpack_require__(/*! ../../../document */ \"(api)/../server/node_modules/mongoose/lib/document.js\");\nconst ArraySubdocument = __webpack_require__(/*! ../../ArraySubdocument */ \"(api)/../server/node_modules/mongoose/lib/types/ArraySubdocument.js\");\nconst MongooseError = __webpack_require__(/*! ../../../error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst cleanModifiedSubpaths = __webpack_require__(/*! ../../../helpers/document/cleanModifiedSubpaths */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js\");\nconst clone = __webpack_require__(/*! ../../../helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../../../options */ \"(api)/../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst mpath = __webpack_require__(/*! mpath */ \"(api)/../server/node_modules/mpath/index.js\");\nconst utils = __webpack_require__(/*! ../../../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../../../helpers/isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayParentSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\nconst populateModelSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\nconst slicedSymbol = Symbol('mongoose#Array#sliced');\n\nconst _basePush = Array.prototype.push;\n\n/*!\n * ignore\n */\n\nconst methods = {\n  /**\n   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.\n   *\n   * If no atomics exist, we return all array values after conversion.\n   *\n   * @return {Array}\n   * @method $__getAtomics\n   * @memberOf MongooseArray\n   * @instance\n   * @api private\n   */\n\n  $__getAtomics() {\n    const ret = [];\n    const keys = Object.keys(this[arrayAtomicsSymbol] || {});\n    let i = keys.length;\n\n    const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });\n\n    if (i === 0) {\n      ret[0] = ['$set', this.toObject(opts)];\n      return ret;\n    }\n\n    while (i--) {\n      const op = keys[i];\n      let val = this[arrayAtomicsSymbol][op];\n\n      // the atomic values which are arrays are not MongooseArrays. we\n      // need to convert their elements as if they were MongooseArrays\n      // to handle populated arrays versus DocumentArrays properly.\n      if (utils.isMongooseObject(val)) {\n        val = val.toObject(opts);\n      } else if (Array.isArray(val)) {\n        val = this.toObject.call(val, opts);\n      } else if (val != null && Array.isArray(val.$each)) {\n        val.$each = this.toObject.call(val.$each, opts);\n      } else if (val != null && typeof val.valueOf === 'function') {\n        val = val.valueOf();\n      }\n\n      if (op === '$addToSet') {\n        val = { $each: val };\n      }\n\n      ret.push([op, val]);\n    }\n\n    return ret;\n  },\n\n  /*!\n   * ignore\n   */\n\n  $atomics() {\n    return this[arrayAtomicsSymbol];\n  },\n\n  /*!\n   * ignore\n   */\n\n  $parent() {\n    return this[arrayParentSymbol];\n  },\n\n  /*!\n   * ignore\n   */\n\n  $path() {\n    return this[arrayPathSymbol];\n  },\n\n  /**\n   * Atomically shifts the array at most one time per document `save()`.\n   *\n   * #### Note:\n   *\n   * _Calling this multiple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      const shifted = doc.array.$shift();\n   *      console.log(shifted); // 1\n   *      console.log(doc.array); // [2,3]\n   *\n   *      // no affect\n   *      shifted = doc.array.$shift();\n   *      console.log(doc.array); // [2,3]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $shift works again\n   *        shifted = doc.array.$shift();\n   *        console.log(shifted ); // 2\n   *        console.log(doc.array); // [3]\n   *      })\n   *\n   * @api public\n   * @memberOf MongooseArray\n   * @instance\n   * @method $shift\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pop/\n   */\n\n  $shift() {\n    this._registerAtomic('$pop', -1);\n    this._markModified();\n\n    // only allow shifting once\n    const __array = this.__array;\n    if (__array._shifted) {\n      return;\n    }\n    __array._shifted = true;\n\n    return [].shift.call(__array);\n  },\n\n  /**\n   * Pops the array atomically at most one time per document `save()`.\n   *\n   * #### NOTE:\n   *\n   * _Calling this multiple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      const popped = doc.array.$pop();\n   *      console.log(popped); // 3\n   *      console.log(doc.array); // [1,2]\n   *\n   *      // no affect\n   *      popped = doc.array.$pop();\n   *      console.log(doc.array); // [1,2]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $pop works again\n   *        popped = doc.array.$pop();\n   *        console.log(popped); // 2\n   *        console.log(doc.array); // [1]\n   *      })\n   *\n   * @api public\n   * @method $pop\n   * @memberOf MongooseArray\n   * @instance\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pop/\n   * @method $pop\n   * @memberOf MongooseArray\n   */\n\n  $pop() {\n    this._registerAtomic('$pop', 1);\n    this._markModified();\n\n    // only allow popping once\n    if (this._popped) {\n      return;\n    }\n    this._popped = true;\n\n    return [].pop.call(this);\n  },\n\n  /*!\n   * ignore\n   */\n\n  $schema() {\n    return this[arraySchemaSymbol];\n  },\n\n  /**\n   * Casts a member based on this arrays schema.\n   *\n   * @param {any} value\n   * @return value the casted value\n   * @method _cast\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _cast(value) {\n    let populated = false;\n    let Model;\n\n    const parent = this[arrayParentSymbol];\n    if (parent) {\n      populated = parent.$populated(this[arrayPathSymbol], true);\n    }\n\n    if (populated && value !== null && value !== undefined) {\n      // cast to the populated Models schema\n      Model = populated.options[populateModelSymbol];\n      if (Model == null) {\n        throw new MongooseError('No populated model found for path `' + this[arrayPathSymbol] + '`. This is likely a bug in Mongoose, please report an issue on github.com/Automattic/mongoose.');\n      }\n\n      // only objects are permitted so we can safely assume that\n      // non-objects are to be interpreted as _id\n      if (Buffer.isBuffer(value) ||\n          isBsonType(value, 'ObjectId') || !utils.isObject(value)) {\n        value = { _id: value };\n      }\n\n      // gh-2399\n      // we should cast model only when it's not a discriminator\n      const isDisc = value.schema && value.schema.discriminatorMapping &&\n          value.schema.discriminatorMapping.key !== undefined;\n      if (!isDisc) {\n        value = new Model(value);\n      }\n      return this[arraySchemaSymbol].caster.applySetters(value, parent, true);\n    }\n\n    return this[arraySchemaSymbol].caster.applySetters(value, parent, false);\n  },\n\n  /**\n   * Internal helper for .map()\n   *\n   * @api private\n   * @return {Number}\n   * @method _mapCast\n   * @memberOf MongooseArray\n   */\n\n  _mapCast(val, index) {\n    return this._cast(val, this.length + index);\n  },\n\n  /**\n   * Marks this array as modified.\n   *\n   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)\n   *\n   * @param {ArraySubdocument} subdoc the embedded doc that invoked this method on the Array\n   * @param {String} embeddedPath the path which changed in the subdoc\n   * @method _markModified\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _markModified(elem) {\n    const parent = this[arrayParentSymbol];\n    let dirtyPath;\n\n    if (parent) {\n      dirtyPath = this[arrayPathSymbol];\n\n      if (arguments.length) {\n        dirtyPath = dirtyPath + '.' + elem;\n      }\n\n      if (dirtyPath != null && dirtyPath.endsWith('.$')) {\n        return this;\n      }\n\n      parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);\n    }\n\n    return this;\n  },\n\n  /**\n   * Register an atomic operation with the parent.\n   *\n   * @param {Array} op operation\n   * @param {any} val\n   * @method _registerAtomic\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _registerAtomic(op, val) {\n    if (this[slicedSymbol]) {\n      return;\n    }\n    if (op === '$set') {\n      // $set takes precedence over all other ops.\n      // mark entire array modified.\n      this[arrayAtomicsSymbol] = { $set: val };\n      cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);\n      this._markModified();\n      return this;\n    }\n\n    const atomics = this[arrayAtomicsSymbol];\n\n    // reset pop/shift after save\n    if (op === '$pop' && !('$pop' in atomics)) {\n      const _this = this;\n      this[arrayParentSymbol].once('save', function() {\n        _this._popped = _this._shifted = null;\n      });\n    }\n\n    // check for impossible $atomic combos (Mongo denies more than one\n    // $atomic op on a single path\n    if (atomics.$set || Object.keys(atomics).length && !(op in atomics)) {\n      // a different op was previously registered.\n      // save the entire thing.\n      this[arrayAtomicsSymbol] = { $set: this };\n      return this;\n    }\n\n    let selector;\n\n    if (op === '$pullAll' || op === '$addToSet') {\n      atomics[op] || (atomics[op] = []);\n      atomics[op] = atomics[op].concat(val);\n    } else if (op === '$pullDocs') {\n      const pullOp = atomics['$pull'] || (atomics['$pull'] = {});\n      if (val[0] instanceof ArraySubdocument) {\n        selector = pullOp['$or'] || (pullOp['$or'] = []);\n        Array.prototype.push.apply(selector, val.map(v => {\n          return v.toObject({\n            transform: (doc, ret) => {\n              if (v == null || v.$__ == null) {\n                return ret;\n              }\n\n              Object.keys(v.$__.activePaths.getStatePaths('default')).forEach(path => {\n                mpath.unset(path, ret);\n\n                _minimizePath(ret, path);\n              });\n\n              return ret;\n            },\n            virtuals: false\n          });\n        }));\n      } else {\n        selector = pullOp['_id'] || (pullOp['_id'] = { $in: [] });\n        selector['$in'] = selector['$in'].concat(val);\n      }\n    } else if (op === '$push') {\n      atomics.$push = atomics.$push || { $each: [] };\n      if (val != null && utils.hasUserDefinedProperty(val, '$each')) {\n        atomics.$push = val;\n      } else {\n        if (val.length === 1) {\n          atomics.$push.$each.push(val[0]);\n        } else if (val.length < 10000) {\n          atomics.$push.$each.push(...val);\n        } else {\n          for (const v of val) {\n            atomics.$push.$each.push(v);\n          }\n        }\n      }\n    } else {\n      atomics[op] = val;\n    }\n\n    return this;\n  },\n\n  /**\n   * Adds values to the array if not already present.\n   *\n   * #### Example:\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *     const added = doc.array.addToSet(4,5);\n   *     console.log(doc.array) // [2,3,4,5]\n   *     console.log(added)     // [5]\n   *\n   * @param {...any} [args]\n   * @return {Array} the values that were added\n   * @memberOf MongooseArray\n   * @api public\n   * @method addToSet\n   */\n\n  addToSet() {\n    _checkManualPopulation(this, arguments);\n\n    const values = [].map.call(arguments, this._mapCast, this);\n    const added = [];\n    let type = '';\n    if (values[0] instanceof ArraySubdocument) {\n      type = 'doc';\n    } else if (values[0] instanceof Date) {\n      type = 'date';\n    } else if (isBsonType(values[0], 'ObjectId')) {\n      type = 'ObjectId';\n    }\n\n    const rawValues = utils.isMongooseArray(values) ? values.__array : values;\n    const rawArray = utils.isMongooseArray(this) ? this.__array : this;\n\n    rawValues.forEach(function(v) {\n      let found;\n      const val = +v;\n      switch (type) {\n        case 'doc':\n          found = this.some(function(doc) {\n            return doc.equals(v);\n          });\n          break;\n        case 'date':\n          found = this.some(function(d) {\n            return +d === val;\n          });\n          break;\n        case 'ObjectId':\n          found = this.find(o => o.toString() === v.toString());\n          break;\n        default:\n          found = ~this.indexOf(v);\n          break;\n      }\n\n      if (!found) {\n        this._markModified();\n        rawArray.push(v);\n        this._registerAtomic('$addToSet', v);\n        [].push.call(added, v);\n      }\n    }, this);\n\n    return added;\n  },\n\n  /**\n   * Returns the number of pending atomic operations to send to the db for this array.\n   *\n   * @api private\n   * @return {Number}\n   * @method hasAtomics\n   * @memberOf MongooseArray\n   */\n\n  hasAtomics() {\n    if (!utils.isPOJO(this[arrayAtomicsSymbol])) {\n      return 0;\n    }\n\n    return Object.keys(this[arrayAtomicsSymbol]).length;\n  },\n\n  /**\n   * Return whether or not the `obj` is included in the array.\n   *\n   * @param {Object} obj the item to check\n   * @param {Number} fromIndex\n   * @return {Boolean}\n   * @api public\n   * @method includes\n   * @memberOf MongooseArray\n   */\n\n  includes(obj, fromIndex) {\n    const ret = this.indexOf(obj, fromIndex);\n    return ret !== -1;\n  },\n\n  /**\n   * Return the index of `obj` or `-1` if not found.\n   *\n   * @param {Object} obj the item to look for\n   * @param {Number} fromIndex\n   * @return {Number}\n   * @api public\n   * @method indexOf\n   * @memberOf MongooseArray\n   */\n\n  indexOf(obj, fromIndex) {\n    if (isBsonType(obj, 'ObjectId')) {\n      obj = obj.toString();\n    }\n\n    fromIndex = fromIndex == null ? 0 : fromIndex;\n    const len = this.length;\n    for (let i = fromIndex; i < len; ++i) {\n      if (obj == this[i]) {\n        return i;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @api public\n   * @method inspect\n   * @memberOf MongooseArray\n   */\n\n  inspect() {\n    return JSON.stringify(this);\n  },\n\n  /**\n   * Pushes items to the array non-atomically.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @param {...any} [args]\n   * @api public\n   * @method nonAtomicPush\n   * @memberOf MongooseArray\n   */\n\n  nonAtomicPush() {\n    const values = [].map.call(arguments, this._mapCast, this);\n    this._markModified();\n    const ret = [].push.apply(this, values);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified which will pass the entire thing to $set potentially overwriting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @see MongooseArray#$pop https://mongoosejs.com/docs/api/array.html#MongooseArray.prototype.$pop()\n   * @api public\n   * @method pop\n   * @memberOf MongooseArray\n   */\n\n  pop() {\n    this._markModified();\n    const ret = [].pop.call(this);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically. Equality is determined by casting\n   * the provided value to an embedded document and comparing using\n   * [the `Document.equals()` function.](https://mongoosejs.com/docs/api/document.html#Document.prototype.equals())\n   *\n   * #### Example:\n   *\n   *     doc.array.pull(ObjectId)\n   *     doc.array.pull({ _id: 'someId' })\n   *     doc.array.pull(36)\n   *     doc.array.pull('tag 1', 'tag 2')\n   *\n   * To remove a document from a subdocument array we may pass an object with a matching `_id`.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull({ _id: 4815162342 }) // removed\n   *\n   * Or we may passing the _id directly and let mongoose take care of it.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull(4815162342); // works\n   *\n   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.\n   *\n   * @param {...any} [args]\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pull/\n   * @api public\n   * @method pull\n   * @memberOf MongooseArray\n   */\n\n  pull() {\n    const values = [].map.call(arguments, (v, i) => this._cast(v, i, { defaults: false }), this);\n    let cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);\n    if (utils.isMongooseArray(cur)) {\n      cur = cur.__array;\n    }\n    let i = cur.length;\n    let mem;\n    this._markModified();\n\n    while (i--) {\n      mem = cur[i];\n      if (mem instanceof Document) {\n        const some = values.some(function(v) {\n          return mem.equals(v);\n        });\n        if (some) {\n          cur.splice(i, 1);\n        }\n      } else if (~this.indexOf.call(values, mem)) {\n        cur.splice(i, 1);\n      }\n    }\n\n    if (values[0] instanceof ArraySubdocument) {\n      this._registerAtomic('$pullDocs', values.map(function(v) {\n        const _id = v.$__getValue('_id');\n        if (_id === undefined || v.$isDefault('_id')) {\n          return v;\n        }\n        return _id;\n      }));\n    } else {\n      this._registerAtomic('$pullAll', values);\n    }\n\n\n    // Might have modified child paths and then pulled, like\n    // `doc.children[1].name = 'test';` followed by\n    // `doc.children.remove(doc.children[0]);`. In this case we fall back\n    // to a `$set` on the whole array. See #3511\n    if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {\n      this._registerAtomic('$set', this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * #### Example:\n   *\n   *     const schema = Schema({ nums: [Number] });\n   *     const Model = mongoose.model('Test', schema);\n   *\n   *     const doc = await Model.create({ nums: [3, 4] });\n   *     doc.nums.push(5); // Add 5 to the end of the array\n   *     await doc.save();\n   *\n   *     // You can also pass an object with `$each` as the\n   *     // first parameter to use MongoDB's `$position`\n   *     doc.nums.push({\n   *       $each: [1, 2],\n   *       $position: 0\n   *     });\n   *     doc.nums; // [1, 2, 3, 4, 5]\n   *\n   * @param {...Object} [args]\n   * @api public\n   * @method push\n   * @memberOf MongooseArray\n   */\n\n  push() {\n    let values = arguments;\n    let atomic = values;\n    const isOverwrite = values[0] != null &&\n      utils.hasUserDefinedProperty(values[0], '$each');\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    if (isOverwrite) {\n      atomic = values[0];\n      values = values[0].$each;\n    }\n\n    if (this[arraySchemaSymbol] == null) {\n      return _basePush.apply(this, values);\n    }\n\n    _checkManualPopulation(this, values);\n\n    values = [].map.call(values, this._mapCast, this);\n    let ret;\n    const atomics = this[arrayAtomicsSymbol];\n    this._markModified();\n    if (isOverwrite) {\n      atomic.$each = values;\n\n      if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 &&\n          atomics.$push.$position != atomic.$position) {\n        if (atomic.$position != null) {\n          [].splice.apply(arr, [atomic.$position, 0].concat(values));\n          ret = arr.length;\n        } else {\n          ret = [].push.apply(arr, values);\n        }\n\n        this._registerAtomic('$set', this);\n      } else if (atomic.$position != null) {\n        [].splice.apply(arr, [atomic.$position, 0].concat(values));\n        ret = this.length;\n      } else {\n        ret = [].push.apply(arr, values);\n      }\n    } else {\n      atomic = values;\n      ret = _basePush.apply(arr, values);\n    }\n\n    this._registerAtomic('$push', atomic);\n    return ret;\n  },\n\n  /**\n   * Alias of [pull](https://mongoosejs.com/docs/api/array.html#MongooseArray.prototype.pull())\n   *\n   * @see MongooseArray#pull https://mongoosejs.com/docs/api/array.html#MongooseArray.prototype.pull()\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pull/\n   * @api public\n   * @memberOf MongooseArray\n   * @instance\n   * @method remove\n   */\n\n  remove() {\n    return this.pull.apply(this, arguments);\n  },\n\n  /**\n   * Sets the casted `val` at index `i` and marks the array modified.\n   *\n   * #### Example:\n   *\n   *     // given documents based on the following\n   *     const Doc = mongoose.model('Doc', new Schema({ array: [Number] }));\n   *\n   *     const doc = new Doc({ array: [2,3,4] })\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *\n   *     doc.array.set(1,\"5\");\n   *     console.log(doc.array); // [2,5,4] // properly cast to number\n   *     doc.save() // the change is saved\n   *\n   *     // VS not using array#set\n   *     doc.array[1] = \"5\";\n   *     console.log(doc.array); // [2,\"5\",4] // no casting\n   *     doc.save() // change is not saved\n   *\n   * @return {Array} this\n   * @api public\n   * @method set\n   * @memberOf MongooseArray\n   */\n\n  set(i, val, skipModified) {\n    const arr = this.__array;\n    if (skipModified) {\n      arr[i] = val;\n      return this;\n    }\n    const value = methods._cast.call(this, val, i);\n    methods._markModified.call(this, i);\n    arr[i] = value;\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * #### Example:\n   *\n   *     doc.array = [2,3];\n   *     const res = doc.array.shift();\n   *     console.log(res) // 2\n   *     console.log(doc.array) // [3]\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method shift\n   * @memberOf MongooseArray\n   */\n\n  shift() {\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    this._markModified();\n    const ret = [].shift.call(arr);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method sort\n   * @memberOf MongooseArray\n   * @see MasteringJS: Array sort https://masteringjs.io/tutorials/fundamentals/array-sort\n   */\n\n  sort() {\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    const ret = [].sort.apply(arr, arguments);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method splice\n   * @memberOf MongooseArray\n   * @see MasteringJS: Array splice https://masteringjs.io/tutorials/fundamentals/array-splice\n   */\n\n  splice() {\n    let ret;\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n\n    this._markModified();\n    _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));\n\n    if (arguments.length) {\n      let vals;\n      if (this[arraySchemaSymbol] == null) {\n        vals = arguments;\n      } else {\n        vals = [];\n        for (let i = 0; i < arguments.length; ++i) {\n          vals[i] = i < 2 ?\n            arguments[i] :\n            this._cast(arguments[i], arguments[0] + (i - 2));\n        }\n      }\n\n      ret = [].splice.apply(arr, vals);\n      this._registerAtomic('$set', this);\n    }\n\n    return ret;\n  },\n\n  /*!\n   * ignore\n   */\n\n  toBSON() {\n    return this.toObject(internalToObjectOptions);\n  },\n\n  /**\n   * Returns a native js Array.\n   *\n   * @param {Object} options\n   * @return {Array}\n   * @api public\n   * @method toObject\n   * @memberOf MongooseArray\n   */\n\n  toObject(options) {\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    if (options && options.depopulate) {\n      options = clone(options);\n      options._isNested = true;\n      // Ensure return value is a vanilla array, because in Node.js 6+ `map()`\n      // is smart enough to use the inherited array's constructor.\n      return [].concat(arr).map(function(doc) {\n        return doc instanceof Document\n          ? doc.toObject(options)\n          : doc;\n      });\n    }\n\n    return [].concat(arr);\n  },\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  },\n  /**\n   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwriting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method unshift\n   * @memberOf MongooseArray\n   */\n\n  unshift() {\n    _checkManualPopulation(this, arguments);\n\n    let values;\n    if (this[arraySchemaSymbol] == null) {\n      values = arguments;\n    } else {\n      values = [].map.call(arguments, this._cast, this);\n    }\n\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    this._markModified();\n    [].unshift.apply(arr, values);\n    this._registerAtomic('$set', this);\n    return this.length;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _isAllSubdocs(docs, ref) {\n  if (!ref) {\n    return false;\n  }\n\n  for (const arg of docs) {\n    if (arg == null) {\n      return false;\n    }\n    const model = arg.constructor;\n    if (!(arg instanceof Document) ||\n      (model.modelName !== ref && model.baseModelName !== ref)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/*!\n * Minimize _just_ empty objects along the path chain specified\n * by `parts`, ignoring all other paths. Useful in cases where\n * you want to minimize after unsetting a path.\n *\n * #### Example:\n *\n *     const obj = { foo: { bar: { baz: {} } }, a: {} };\n *     _minimizePath(obj, 'foo.bar.baz');\n *     obj; // { a: {} }\n */\n\nfunction _minimizePath(obj, parts, i) {\n  if (typeof parts === 'string') {\n    if (parts.indexOf('.') === -1) {\n      return;\n    }\n\n    parts = mpath.stringToParts(parts);\n  }\n  i = i || 0;\n  if (i >= parts.length) {\n    return;\n  }\n  if (obj == null || typeof obj !== 'object') {\n    return;\n  }\n\n  _minimizePath(obj[parts[0]], parts, i + 1);\n  if (obj[parts[0]] != null && typeof obj[parts[0]] === 'object' && Object.keys(obj[parts[0]]).length === 0) {\n    delete obj[parts[0]];\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkManualPopulation(arr, docs) {\n  const ref = arr == null ?\n    null :\n    arr[arraySchemaSymbol] && arr[arraySchemaSymbol].caster && arr[arraySchemaSymbol].caster.options && arr[arraySchemaSymbol].caster.options.ref || null;\n  if (arr.length === 0 &&\n      docs.length !== 0) {\n    if (_isAllSubdocs(docs, ref)) {\n      arr[arrayParentSymbol].$populated(arr[arrayPathSymbol], [], {\n        [populateModelSymbol]: docs[0].constructor\n      });\n    }\n  }\n}\n\nconst returnVanillaArrayMethods = [\n  'filter',\n  'flat',\n  'flatMap',\n  'map',\n  'slice'\n];\nfor (const method of returnVanillaArrayMethods) {\n  if (Array.prototype[method] == null) {\n    continue;\n  }\n\n  methods[method] = function() {\n    const _arr = utils.isMongooseArray(this) ? this.__array : this;\n    const arr = [].concat(_arr);\n\n    return arr[method].apply(arr, arguments);\n  };\n}\n\nmodule.exports = methods;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYXJyYXkvbWV0aG9kcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDNUMseUJBQXlCLG1CQUFPLENBQUMsbUdBQXdCO0FBQ3pELHNCQUFzQixtQkFBTyxDQUFDLHNHQUE4QjtBQUM1RCw4QkFBOEIsbUJBQU8sQ0FBQyw0SUFBaUQ7QUFDdkYsY0FBYyxtQkFBTyxDQUFDLDBGQUF3QjtBQUM5QyxnQ0FBZ0MsNkhBQW1EO0FBQ25GLGNBQWMsbUJBQU8sQ0FBQywwREFBTztBQUM3QixjQUFjLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3RDLG1CQUFtQixtQkFBTyxDQUFDLG9HQUE2Qjs7QUFFeEQsMkJBQTJCLHdJQUFzRDtBQUNqRiwwQkFBMEIsdUlBQXFEO0FBQy9FLHdCQUF3QixxSUFBbUQ7QUFDM0UsMEJBQTBCLHVJQUFxRDtBQUMvRSw0QkFBNEIseUlBQXVEO0FBQ25GOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBLGlDQUFpQyw2QkFBNkIsaUJBQWlCOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPLE9BQU8sV0FBVztBQUM5QztBQUNBLFlBQVksS0FBSztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHR5cGVzXFxhcnJheVxcbWV0aG9kc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEb2N1bWVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2RvY3VtZW50Jyk7XG5jb25zdCBBcnJheVN1YmRvY3VtZW50ID0gcmVxdWlyZSgnLi4vLi4vQXJyYXlTdWJkb2N1bWVudCcpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IGNsZWFuTW9kaWZpZWRTdWJwYXRocyA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvZG9jdW1lbnQvY2xlYW5Nb2RpZmllZFN1YnBhdGhzJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi4vLi4vLi4vb3B0aW9ucycpLmludGVybmFsVG9PYmplY3RPcHRpb25zO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheUF0b21pY3NTeW1ib2w7XG5jb25zdCBhcnJheVBhcmVudFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGFyZW50U3ltYm9sO1xuY29uc3QgYXJyYXlQYXRoU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXRoU3ltYm9sO1xuY29uc3QgYXJyYXlTY2hlbWFTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVNjaGVtYVN5bWJvbDtcbmNvbnN0IHBvcHVsYXRlTW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5wb3B1bGF0ZU1vZGVsU3ltYm9sO1xuY29uc3Qgc2xpY2VkU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNBcnJheSNzbGljZWQnKTtcblxuY29uc3QgX2Jhc2VQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3QgbWV0aG9kcyA9IHtcbiAgLyoqXG4gICAqIERlcG9wdWxhdGVzIHN0b3JlZCBhdG9taWMgb3BlcmF0aW9uIHZhbHVlcyBhcyBuZWNlc3NhcnkgZm9yIGRpcmVjdCBpbnNlcnRpb24gdG8gTW9uZ29EQi5cbiAgICpcbiAgICogSWYgbm8gYXRvbWljcyBleGlzdCwgd2UgcmV0dXJuIGFsbCBhcnJheSB2YWx1ZXMgYWZ0ZXIgY29udmVyc2lvbi5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqIEBtZXRob2QgJF9fZ2V0QXRvbWljc1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gICRfX2dldEF0b21pY3MoKSB7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXSB8fCB7fSk7XG4gICAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcblxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucywgeyBfaXNOZXN0ZWQ6IHRydWUgfSk7XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0WzBdID0gWyckc2V0JywgdGhpcy50b09iamVjdChvcHRzKV07XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IG9wID0ga2V5c1tpXTtcbiAgICAgIGxldCB2YWwgPSB0aGlzW2FycmF5QXRvbWljc1N5bWJvbF1bb3BdO1xuXG4gICAgICAvLyB0aGUgYXRvbWljIHZhbHVlcyB3aGljaCBhcmUgYXJyYXlzIGFyZSBub3QgTW9uZ29vc2VBcnJheXMuIHdlXG4gICAgICAvLyBuZWVkIHRvIGNvbnZlcnQgdGhlaXIgZWxlbWVudHMgYXMgaWYgdGhleSB3ZXJlIE1vbmdvb3NlQXJyYXlzXG4gICAgICAvLyB0byBoYW5kbGUgcG9wdWxhdGVkIGFycmF5cyB2ZXJzdXMgRG9jdW1lbnRBcnJheXMgcHJvcGVybHkuXG4gICAgICBpZiAodXRpbHMuaXNNb25nb29zZU9iamVjdCh2YWwpKSB7XG4gICAgICAgIHZhbCA9IHZhbC50b09iamVjdChvcHRzKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbCA9IHRoaXMudG9PYmplY3QuY2FsbCh2YWwsIG9wdHMpO1xuICAgICAgfSBlbHNlIGlmICh2YWwgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbC4kZWFjaCkpIHtcbiAgICAgICAgdmFsLiRlYWNoID0gdGhpcy50b09iamVjdC5jYWxsKHZhbC4kZWFjaCwgb3B0cyk7XG4gICAgICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsICYmIHR5cGVvZiB2YWwudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWwgPSB2YWwudmFsdWVPZigpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3AgPT09ICckYWRkVG9TZXQnKSB7XG4gICAgICAgIHZhbCA9IHsgJGVhY2g6IHZhbCB9O1xuICAgICAgfVxuXG4gICAgICByZXQucHVzaChbb3AsIHZhbF0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cblxuICAkYXRvbWljcygpIHtcbiAgICByZXR1cm4gdGhpc1thcnJheUF0b21pY3NTeW1ib2xdO1xuICB9LFxuXG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG5cbiAgJHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpc1thcnJheVBhcmVudFN5bWJvbF07XG4gIH0sXG5cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cblxuICAkcGF0aCgpIHtcbiAgICByZXR1cm4gdGhpc1thcnJheVBhdGhTeW1ib2xdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBdG9taWNhbGx5IHNoaWZ0cyB0aGUgYXJyYXkgYXQgbW9zdCBvbmUgdGltZSBwZXIgZG9jdW1lbnQgYHNhdmUoKWAuXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX0NhbGxpbmcgdGhpcyBtdWx0aXBsZSB0aW1lcyBvbiBhbiBhcnJheSBiZWZvcmUgc2F2aW5nIHNlbmRzIHRoZSBzYW1lIGNvbW1hbmQgYXMgY2FsbGluZyBpdCBvbmNlLl9cbiAgICogX1RoaXMgdXBkYXRlIGlzIGltcGxlbWVudGVkIHVzaW5nIHRoZSBNb25nb0RCIFskcG9wXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlL3BvcC8pIG1ldGhvZCB3aGljaCBlbmZvcmNlcyB0aGlzIHJlc3RyaWN0aW9uLl9cbiAgICpcbiAgICogICAgICBkb2MuYXJyYXkgPSBbMSwyLDNdO1xuICAgKlxuICAgKiAgICAgIGNvbnN0IHNoaWZ0ZWQgPSBkb2MuYXJyYXkuJHNoaWZ0KCk7XG4gICAqICAgICAgY29uc29sZS5sb2coc2hpZnRlZCk7IC8vIDFcbiAgICogICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpOyAvLyBbMiwzXVxuICAgKlxuICAgKiAgICAgIC8vIG5vIGFmZmVjdFxuICAgKiAgICAgIHNoaWZ0ZWQgPSBkb2MuYXJyYXkuJHNoaWZ0KCk7XG4gICAqICAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KTsgLy8gWzIsM11cbiAgICpcbiAgICogICAgICBkb2Muc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gICAqICAgICAgICBpZiAoZXJyKSByZXR1cm4gaGFuZGxlRXJyb3IoZXJyKTtcbiAgICpcbiAgICogICAgICAgIC8vIHdlIHNhdmVkLCBub3cgJHNoaWZ0IHdvcmtzIGFnYWluXG4gICAqICAgICAgICBzaGlmdGVkID0gZG9jLmFycmF5LiRzaGlmdCgpO1xuICAgKiAgICAgICAgY29uc29sZS5sb2coc2hpZnRlZCApOyAvLyAyXG4gICAqICAgICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpOyAvLyBbM11cbiAgICogICAgICB9KVxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1ldGhvZCAkc2hpZnRcbiAgICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci91cGRhdGUvcG9wL1xuICAgKi9cblxuICAkc2hpZnQoKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRwb3AnLCAtMSk7XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG5cbiAgICAvLyBvbmx5IGFsbG93IHNoaWZ0aW5nIG9uY2VcbiAgICBjb25zdCBfX2FycmF5ID0gdGhpcy5fX2FycmF5O1xuICAgIGlmIChfX2FycmF5Ll9zaGlmdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9fYXJyYXkuX3NoaWZ0ZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIFtdLnNoaWZ0LmNhbGwoX19hcnJheSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvcHMgdGhlIGFycmF5IGF0b21pY2FsbHkgYXQgbW9zdCBvbmUgdGltZSBwZXIgZG9jdW1lbnQgYHNhdmUoKWAuXG4gICAqXG4gICAqICMjIyMgTk9URTpcbiAgICpcbiAgICogX0NhbGxpbmcgdGhpcyBtdWx0aXBsZSB0aW1lcyBvbiBhbiBhcnJheSBiZWZvcmUgc2F2aW5nIHNlbmRzIHRoZSBzYW1lIGNvbW1hbmQgYXMgY2FsbGluZyBpdCBvbmNlLl9cbiAgICogX1RoaXMgdXBkYXRlIGlzIGltcGxlbWVudGVkIHVzaW5nIHRoZSBNb25nb0RCIFskcG9wXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlL3BvcC8pIG1ldGhvZCB3aGljaCBlbmZvcmNlcyB0aGlzIHJlc3RyaWN0aW9uLl9cbiAgICpcbiAgICogICAgICBkb2MuYXJyYXkgPSBbMSwyLDNdO1xuICAgKlxuICAgKiAgICAgIGNvbnN0IHBvcHBlZCA9IGRvYy5hcnJheS4kcG9wKCk7XG4gICAqICAgICAgY29uc29sZS5sb2cocG9wcGVkKTsgLy8gM1xuICAgKiAgICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSk7IC8vIFsxLDJdXG4gICAqXG4gICAqICAgICAgLy8gbm8gYWZmZWN0XG4gICAqICAgICAgcG9wcGVkID0gZG9jLmFycmF5LiRwb3AoKTtcbiAgICogICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpOyAvLyBbMSwyXVxuICAgKlxuICAgKiAgICAgIGRvYy5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAgICogICAgICAgIGlmIChlcnIpIHJldHVybiBoYW5kbGVFcnJvcihlcnIpO1xuICAgKlxuICAgKiAgICAgICAgLy8gd2Ugc2F2ZWQsIG5vdyAkcG9wIHdvcmtzIGFnYWluXG4gICAqICAgICAgICBwb3BwZWQgPSBkb2MuYXJyYXkuJHBvcCgpO1xuICAgKiAgICAgICAgY29uc29sZS5sb2cocG9wcGVkKTsgLy8gMlxuICAgKiAgICAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KTsgLy8gWzFdXG4gICAqICAgICAgfSlcbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCAkcG9wXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS9wb3AvXG4gICAqIEBtZXRob2QgJHBvcFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICAkcG9wKCkge1xuICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckcG9wJywgMSk7XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG5cbiAgICAvLyBvbmx5IGFsbG93IHBvcHBpbmcgb25jZVxuICAgIGlmICh0aGlzLl9wb3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcG9wcGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBbXS5wb3AuY2FsbCh0aGlzKTtcbiAgfSxcblxuICAvKiFcbiAgICogaWdub3JlXG4gICAqL1xuXG4gICRzY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYXN0cyBhIG1lbWJlciBiYXNlZCBvbiB0aGlzIGFycmF5cyBzY2hlbWEuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiBAcmV0dXJuIHZhbHVlIHRoZSBjYXN0ZWQgdmFsdWVcbiAgICogQG1ldGhvZCBfY2FzdFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgX2Nhc3QodmFsdWUpIHtcbiAgICBsZXQgcG9wdWxhdGVkID0gZmFsc2U7XG4gICAgbGV0IE1vZGVsO1xuXG4gICAgY29uc3QgcGFyZW50ID0gdGhpc1thcnJheVBhcmVudFN5bWJvbF07XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcG9wdWxhdGVkID0gcGFyZW50LiRwb3B1bGF0ZWQodGhpc1thcnJheVBhdGhTeW1ib2xdLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAocG9wdWxhdGVkICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNhc3QgdG8gdGhlIHBvcHVsYXRlZCBNb2RlbHMgc2NoZW1hXG4gICAgICBNb2RlbCA9IHBvcHVsYXRlZC5vcHRpb25zW3BvcHVsYXRlTW9kZWxTeW1ib2xdO1xuICAgICAgaWYgKE1vZGVsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ05vIHBvcHVsYXRlZCBtb2RlbCBmb3VuZCBmb3IgcGF0aCBgJyArIHRoaXNbYXJyYXlQYXRoU3ltYm9sXSArICdgLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBNb25nb29zZSwgcGxlYXNlIHJlcG9ydCBhbiBpc3N1ZSBvbiBnaXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgb2JqZWN0cyBhcmUgcGVybWl0dGVkIHNvIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoYXRcbiAgICAgIC8vIG5vbi1vYmplY3RzIGFyZSB0byBiZSBpbnRlcnByZXRlZCBhcyBfaWRcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8XG4gICAgICAgICAgaXNCc29uVHlwZSh2YWx1ZSwgJ09iamVjdElkJykgfHwgIXV0aWxzLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHsgX2lkOiB2YWx1ZSB9O1xuICAgICAgfVxuXG4gICAgICAvLyBnaC0yMzk5XG4gICAgICAvLyB3ZSBzaG91bGQgY2FzdCBtb2RlbCBvbmx5IHdoZW4gaXQncyBub3QgYSBkaXNjcmltaW5hdG9yXG4gICAgICBjb25zdCBpc0Rpc2MgPSB2YWx1ZS5zY2hlbWEgJiYgdmFsdWUuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nICYmXG4gICAgICAgICAgdmFsdWUuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLmtleSAhPT0gdW5kZWZpbmVkO1xuICAgICAgaWYgKCFpc0Rpc2MpIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgTW9kZWwodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdLmNhc3Rlci5hcHBseVNldHRlcnModmFsdWUsIHBhcmVudCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdLmNhc3Rlci5hcHBseVNldHRlcnModmFsdWUsIHBhcmVudCwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgZm9yIC5tYXAoKVxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAbWV0aG9kIF9tYXBDYXN0XG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIF9tYXBDYXN0KHZhbCwgaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdCh2YWwsIHRoaXMubGVuZ3RoICsgaW5kZXgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNYXJrcyB0aGlzIGFycmF5IGFzIG1vZGlmaWVkLlxuICAgKlxuICAgKiBJZiBpdCBidWJibGVzIHVwIGZyb20gYW4gZW1iZWRkZWQgZG9jdW1lbnQgY2hhbmdlLCB0aGVuIGl0IHRha2VzIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzIChvdGhlcndpc2UsIHRha2VzIDAgYXJndW1lbnRzKVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5U3ViZG9jdW1lbnR9IHN1YmRvYyB0aGUgZW1iZWRkZWQgZG9jIHRoYXQgaW52b2tlZCB0aGlzIG1ldGhvZCBvbiB0aGUgQXJyYXlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVtYmVkZGVkUGF0aCB0aGUgcGF0aCB3aGljaCBjaGFuZ2VkIGluIHRoZSBzdWJkb2NcbiAgICogQG1ldGhvZCBfbWFya01vZGlmaWVkXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBfbWFya01vZGlmaWVkKGVsZW0pIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzW2FycmF5UGFyZW50U3ltYm9sXTtcbiAgICBsZXQgZGlydHlQYXRoO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgZGlydHlQYXRoID0gdGhpc1thcnJheVBhdGhTeW1ib2xdO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBkaXJ0eVBhdGggPSBkaXJ0eVBhdGggKyAnLicgKyBlbGVtO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHlQYXRoICE9IG51bGwgJiYgZGlydHlQYXRoLmVuZHNXaXRoKCcuJCcpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnQubWFya01vZGlmaWVkKGRpcnR5UGF0aCwgYXJndW1lbnRzLmxlbmd0aCAhPT0gMCA/IGVsZW0gOiBwYXJlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBhdG9taWMgb3BlcmF0aW9uIHdpdGggdGhlIHBhcmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb3Agb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7YW55fSB2YWxcbiAgICogQG1ldGhvZCBfcmVnaXN0ZXJBdG9taWNcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIF9yZWdpc3RlckF0b21pYyhvcCwgdmFsKSB7XG4gICAgaWYgKHRoaXNbc2xpY2VkU3ltYm9sXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3AgPT09ICckc2V0Jykge1xuICAgICAgLy8gJHNldCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYWxsIG90aGVyIG9wcy5cbiAgICAgIC8vIG1hcmsgZW50aXJlIGFycmF5IG1vZGlmaWVkLlxuICAgICAgdGhpc1thcnJheUF0b21pY3NTeW1ib2xdID0geyAkc2V0OiB2YWwgfTtcbiAgICAgIGNsZWFuTW9kaWZpZWRTdWJwYXRocyh0aGlzW2FycmF5UGFyZW50U3ltYm9sXSwgdGhpc1thcnJheVBhdGhTeW1ib2xdKTtcbiAgICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgYXRvbWljcyA9IHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXTtcblxuICAgIC8vIHJlc2V0IHBvcC9zaGlmdCBhZnRlciBzYXZlXG4gICAgaWYgKG9wID09PSAnJHBvcCcgJiYgISgnJHBvcCcgaW4gYXRvbWljcykpIHtcbiAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgIHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdLm9uY2UoJ3NhdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX3BvcHBlZCA9IF90aGlzLl9zaGlmdGVkID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBpbXBvc3NpYmxlICRhdG9taWMgY29tYm9zIChNb25nbyBkZW5pZXMgbW9yZSB0aGFuIG9uZVxuICAgIC8vICRhdG9taWMgb3Agb24gYSBzaW5nbGUgcGF0aFxuICAgIGlmIChhdG9taWNzLiRzZXQgfHwgT2JqZWN0LmtleXMoYXRvbWljcykubGVuZ3RoICYmICEob3AgaW4gYXRvbWljcykpIHtcbiAgICAgIC8vIGEgZGlmZmVyZW50IG9wIHdhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQuXG4gICAgICAvLyBzYXZlIHRoZSBlbnRpcmUgdGhpbmcuXG4gICAgICB0aGlzW2FycmF5QXRvbWljc1N5bWJvbF0gPSB7ICRzZXQ6IHRoaXMgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGxldCBzZWxlY3RvcjtcblxuICAgIGlmIChvcCA9PT0gJyRwdWxsQWxsJyB8fCBvcCA9PT0gJyRhZGRUb1NldCcpIHtcbiAgICAgIGF0b21pY3Nbb3BdIHx8IChhdG9taWNzW29wXSA9IFtdKTtcbiAgICAgIGF0b21pY3Nbb3BdID0gYXRvbWljc1tvcF0uY29uY2F0KHZhbCk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyRwdWxsRG9jcycpIHtcbiAgICAgIGNvbnN0IHB1bGxPcCA9IGF0b21pY3NbJyRwdWxsJ10gfHwgKGF0b21pY3NbJyRwdWxsJ10gPSB7fSk7XG4gICAgICBpZiAodmFsWzBdIGluc3RhbmNlb2YgQXJyYXlTdWJkb2N1bWVudCkge1xuICAgICAgICBzZWxlY3RvciA9IHB1bGxPcFsnJG9yJ10gfHwgKHB1bGxPcFsnJG9yJ10gPSBbXSk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHNlbGVjdG9yLCB2YWwubWFwKHYgPT4ge1xuICAgICAgICAgIHJldHVybiB2LnRvT2JqZWN0KHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogKGRvYywgcmV0KSA9PiB7XG4gICAgICAgICAgICAgIGlmICh2ID09IG51bGwgfHwgdi4kX18gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2LiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdkZWZhdWx0JykpLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgbXBhdGgudW5zZXQocGF0aCwgcmV0KTtcblxuICAgICAgICAgICAgICAgIF9taW5pbWl6ZVBhdGgocmV0LCBwYXRoKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXJ0dWFsczogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0b3IgPSBwdWxsT3BbJ19pZCddIHx8IChwdWxsT3BbJ19pZCddID0geyAkaW46IFtdIH0pO1xuICAgICAgICBzZWxlY3RvclsnJGluJ10gPSBzZWxlY3RvclsnJGluJ10uY29uY2F0KHZhbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyRwdXNoJykge1xuICAgICAgYXRvbWljcy4kcHVzaCA9IGF0b21pY3MuJHB1c2ggfHwgeyAkZWFjaDogW10gfTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCAmJiB1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KHZhbCwgJyRlYWNoJykpIHtcbiAgICAgICAgYXRvbWljcy4kcHVzaCA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgYXRvbWljcy4kcHVzaC4kZWFjaC5wdXNoKHZhbFswXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsLmxlbmd0aCA8IDEwMDAwKSB7XG4gICAgICAgICAgYXRvbWljcy4kcHVzaC4kZWFjaC5wdXNoKC4uLnZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbCkge1xuICAgICAgICAgICAgYXRvbWljcy4kcHVzaC4kZWFjaC5wdXNoKHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhdG9taWNzW29wXSA9IHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyB2YWx1ZXMgdG8gdGhlIGFycmF5IGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICpcbiAgICogICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSkgLy8gWzIsMyw0XVxuICAgKiAgICAgY29uc3QgYWRkZWQgPSBkb2MuYXJyYXkuYWRkVG9TZXQoNCw1KTtcbiAgICogICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSkgLy8gWzIsMyw0LDVdXG4gICAqICAgICBjb25zb2xlLmxvZyhhZGRlZCkgICAgIC8vIFs1XVxuICAgKlxuICAgKiBAcGFyYW0gey4uLmFueX0gW2FyZ3NdXG4gICAqIEByZXR1cm4ge0FycmF5fSB0aGUgdmFsdWVzIHRoYXQgd2VyZSBhZGRlZFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIGFkZFRvU2V0XG4gICAqL1xuXG4gIGFkZFRvU2V0KCkge1xuICAgIF9jaGVja01hbnVhbFBvcHVsYXRpb24odGhpcywgYXJndW1lbnRzKTtcblxuICAgIGNvbnN0IHZhbHVlcyA9IFtdLm1hcC5jYWxsKGFyZ3VtZW50cywgdGhpcy5fbWFwQ2FzdCwgdGhpcyk7XG4gICAgY29uc3QgYWRkZWQgPSBbXTtcbiAgICBsZXQgdHlwZSA9ICcnO1xuICAgIGlmICh2YWx1ZXNbMF0gaW5zdGFuY2VvZiBBcnJheVN1YmRvY3VtZW50KSB7XG4gICAgICB0eXBlID0gJ2RvYyc7XG4gICAgfSBlbHNlIGlmICh2YWx1ZXNbMF0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICB0eXBlID0gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAoaXNCc29uVHlwZSh2YWx1ZXNbMF0sICdPYmplY3RJZCcpKSB7XG4gICAgICB0eXBlID0gJ09iamVjdElkJztcbiAgICB9XG5cbiAgICBjb25zdCByYXdWYWx1ZXMgPSB1dGlscy5pc01vbmdvb3NlQXJyYXkodmFsdWVzKSA/IHZhbHVlcy5fX2FycmF5IDogdmFsdWVzO1xuICAgIGNvbnN0IHJhd0FycmF5ID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHRoaXMpID8gdGhpcy5fX2FycmF5IDogdGhpcztcblxuICAgIHJhd1ZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGxldCBmb3VuZDtcbiAgICAgIGNvbnN0IHZhbCA9ICt2O1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvYyc6XG4gICAgICAgICAgZm91bmQgPSB0aGlzLnNvbWUoZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jLmVxdWFscyh2KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgZm91bmQgPSB0aGlzLnNvbWUoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuICtkID09PSB2YWw7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ09iamVjdElkJzpcbiAgICAgICAgICBmb3VuZCA9IHRoaXMuZmluZChvID0+IG8udG9TdHJpbmcoKSA9PT0gdi50b1N0cmluZygpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmb3VuZCA9IH50aGlzLmluZGV4T2Yodik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgICAgIHJhd0FycmF5LnB1c2godik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckYWRkVG9TZXQnLCB2KTtcbiAgICAgICAgW10ucHVzaC5jYWxsKGFkZGVkLCB2KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHJldHVybiBhZGRlZDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgYXRvbWljIG9wZXJhdGlvbnMgdG8gc2VuZCB0byB0aGUgZGIgZm9yIHRoaXMgYXJyYXkuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBtZXRob2QgaGFzQXRvbWljc1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBoYXNBdG9taWNzKCkge1xuICAgIGlmICghdXRpbHMuaXNQT0pPKHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzW2FycmF5QXRvbWljc1N5bWJvbF0pLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBgb2JqYCBpcyBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIGl0ZW0gdG8gY2hlY2tcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIGluY2x1ZGVzXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIGluY2x1ZGVzKG9iaiwgZnJvbUluZGV4KSB7XG4gICAgY29uc3QgcmV0ID0gdGhpcy5pbmRleE9mKG9iaiwgZnJvbUluZGV4KTtcbiAgICByZXR1cm4gcmV0ICE9PSAtMTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBpbmRleCBvZiBgb2JqYCBvciBgLTFgIGlmIG5vdCBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgaXRlbSB0byBsb29rIGZvclxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJvbUluZGV4XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBpbmRleE9mXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIGluZGV4T2Yob2JqLCBmcm9tSW5kZXgpIHtcbiAgICBpZiAoaXNCc29uVHlwZShvYmosICdPYmplY3RJZCcpKSB7XG4gICAgICBvYmogPSBvYmoudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBmcm9tSW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiBmcm9tSW5kZXg7XG4gICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IGZyb21JbmRleDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAob2JqID09IHRoaXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogSGVscGVyIGZvciBjb25zb2xlLmxvZ1xuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIGluc3BlY3RcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgaW5zcGVjdCgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFB1c2hlcyBpdGVtcyB0byB0aGUgYXJyYXkgbm9uLWF0b21pY2FsbHkuXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX21hcmtzIHRoZSBlbnRpcmUgYXJyYXkgYXMgbW9kaWZpZWQsIHdoaWNoIGlmIHNhdmVkLCB3aWxsIHN0b3JlIGl0IGFzIGEgYCRzZXRgIG9wZXJhdGlvbiwgcG90ZW50aWFsbHkgb3ZlcndyaXR0aW5nIGFueSBjaGFuZ2VzIHRoYXQgaGFwcGVuIGJldHdlZW4gd2hlbiB5b3UgcmV0cmlldmVkIHRoZSBvYmplY3QgYW5kIHdoZW4geW91IHNhdmUgaXQuX1xuICAgKlxuICAgKiBAcGFyYW0gey4uLmFueX0gW2FyZ3NdXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2Qgbm9uQXRvbWljUHVzaFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBub25BdG9taWNQdXNoKCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdLm1hcC5jYWxsKGFyZ3VtZW50cywgdGhpcy5fbWFwQ2FzdCwgdGhpcyk7XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgY29uc3QgcmV0ID0gW10ucHVzaC5hcHBseSh0aGlzLCB2YWx1ZXMpO1xuICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckc2V0JywgdGhpcyk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogV3JhcHMgW2BBcnJheSNwb3BgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9wb3ApIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogIyMjIyBOb3RlOlxuICAgKlxuICAgKiBfbWFya3MgdGhlIGVudGlyZSBhcnJheSBhcyBtb2RpZmllZCB3aGljaCB3aWxsIHBhc3MgdGhlIGVudGlyZSB0aGluZyB0byAkc2V0IHBvdGVudGlhbGx5IG92ZXJ3cml0aW5nIGFueSBjaGFuZ2VzIHRoYXQgaGFwcGVuIGJldHdlZW4gd2hlbiB5b3UgcmV0cmlldmVkIHRoZSBvYmplY3QgYW5kIHdoZW4geW91IHNhdmUgaXQuX1xuICAgKlxuICAgKiBAc2VlIE1vbmdvb3NlQXJyYXkjJHBvcCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FycmF5Lmh0bWwjTW9uZ29vc2VBcnJheS5wcm90b3R5cGUuJHBvcCgpXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgcG9wXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIHBvcCgpIHtcbiAgICB0aGlzLl9tYXJrTW9kaWZpZWQoKTtcbiAgICBjb25zdCByZXQgPSBbXS5wb3AuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHRoaXMpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFB1bGxzIGl0ZW1zIGZyb20gdGhlIGFycmF5IGF0b21pY2FsbHkuIEVxdWFsaXR5IGlzIGRldGVybWluZWQgYnkgY2FzdGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgdmFsdWUgdG8gYW4gZW1iZWRkZWQgZG9jdW1lbnQgYW5kIGNvbXBhcmluZyB1c2luZ1xuICAgKiBbdGhlIGBEb2N1bWVudC5lcXVhbHMoKWAgZnVuY3Rpb24uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLmVxdWFscygpKVxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBkb2MuYXJyYXkucHVsbChPYmplY3RJZClcbiAgICogICAgIGRvYy5hcnJheS5wdWxsKHsgX2lkOiAnc29tZUlkJyB9KVxuICAgKiAgICAgZG9jLmFycmF5LnB1bGwoMzYpXG4gICAqICAgICBkb2MuYXJyYXkucHVsbCgndGFnIDEnLCAndGFnIDInKVxuICAgKlxuICAgKiBUbyByZW1vdmUgYSBkb2N1bWVudCBmcm9tIGEgc3ViZG9jdW1lbnQgYXJyYXkgd2UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggYSBtYXRjaGluZyBgX2lkYC5cbiAgICpcbiAgICogICAgIGRvYy5zdWJkb2NzLnB1c2goeyBfaWQ6IDQ4MTUxNjIzNDIgfSlcbiAgICogICAgIGRvYy5zdWJkb2NzLnB1bGwoeyBfaWQ6IDQ4MTUxNjIzNDIgfSkgLy8gcmVtb3ZlZFxuICAgKlxuICAgKiBPciB3ZSBtYXkgcGFzc2luZyB0aGUgX2lkIGRpcmVjdGx5IGFuZCBsZXQgbW9uZ29vc2UgdGFrZSBjYXJlIG9mIGl0LlxuICAgKlxuICAgKiAgICAgZG9jLnN1YmRvY3MucHVzaCh7IF9pZDogNDgxNTE2MjM0MiB9KVxuICAgKiAgICAgZG9jLnN1YmRvY3MucHVsbCg0ODE1MTYyMzQyKTsgLy8gd29ya3NcbiAgICpcbiAgICogVGhlIGZpcnN0IHB1bGwgY2FsbCB3aWxsIHJlc3VsdCBpbiBhIGF0b21pYyBvcGVyYXRpb24gb24gdGhlIGRhdGFiYXNlLCBpZiBwdWxsIGlzIGNhbGxlZCByZXBlYXRlZGx5IHdpdGhvdXQgc2F2aW5nIHRoZSBkb2N1bWVudCwgYSAkc2V0IG9wZXJhdGlvbiBpcyB1c2VkIG9uIHRoZSBjb21wbGV0ZSBhcnJheSBpbnN0ZWFkLCBvdmVyd3JpdGluZyBwb3NzaWJsZSBjaGFuZ2VzIHRoYXQgaGFwcGVuZWQgb24gdGhlIGRhdGFiYXNlIGluIHRoZSBtZWFudGltZS5cbiAgICpcbiAgICogQHBhcmFtIHsuLi5hbnl9IFthcmdzXVxuICAgKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS9wdWxsL1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHB1bGxcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgcHVsbCgpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5tYXAuY2FsbChhcmd1bWVudHMsICh2LCBpKSA9PiB0aGlzLl9jYXN0KHYsIGksIHsgZGVmYXVsdHM6IGZhbHNlIH0pLCB0aGlzKTtcbiAgICBsZXQgY3VyID0gdGhpc1thcnJheVBhcmVudFN5bWJvbF0uZ2V0KHRoaXNbYXJyYXlQYXRoU3ltYm9sXSk7XG4gICAgaWYgKHV0aWxzLmlzTW9uZ29vc2VBcnJheShjdXIpKSB7XG4gICAgICBjdXIgPSBjdXIuX19hcnJheTtcbiAgICB9XG4gICAgbGV0IGkgPSBjdXIubGVuZ3RoO1xuICAgIGxldCBtZW07XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBtZW0gPSBjdXJbaV07XG4gICAgICBpZiAobWVtIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3Qgc29tZSA9IHZhbHVlcy5zb21lKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4gbWVtLmVxdWFscyh2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzb21lKSB7XG4gICAgICAgICAgY3VyLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh+dGhpcy5pbmRleE9mLmNhbGwodmFsdWVzLCBtZW0pKSB7XG4gICAgICAgIGN1ci5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlc1swXSBpbnN0YW5jZW9mIEFycmF5U3ViZG9jdW1lbnQpIHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckcHVsbERvY3MnLCB2YWx1ZXMubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgY29uc3QgX2lkID0gdi4kX19nZXRWYWx1ZSgnX2lkJyk7XG4gICAgICAgIGlmIChfaWQgPT09IHVuZGVmaW5lZCB8fCB2LiRpc0RlZmF1bHQoJ19pZCcpKSB7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRwdWxsQWxsJywgdmFsdWVzKTtcbiAgICB9XG5cblxuICAgIC8vIE1pZ2h0IGhhdmUgbW9kaWZpZWQgY2hpbGQgcGF0aHMgYW5kIHRoZW4gcHVsbGVkLCBsaWtlXG4gICAgLy8gYGRvYy5jaGlsZHJlblsxXS5uYW1lID0gJ3Rlc3QnO2AgZm9sbG93ZWQgYnlcbiAgICAvLyBgZG9jLmNoaWxkcmVuLnJlbW92ZShkb2MuY2hpbGRyZW5bMF0pO2AuIEluIHRoaXMgY2FzZSB3ZSBmYWxsIGJhY2tcbiAgICAvLyB0byBhIGAkc2V0YCBvbiB0aGUgd2hvbGUgYXJyYXkuIFNlZSAjMzUxMVxuICAgIGlmIChjbGVhbk1vZGlmaWVkU3VicGF0aHModGhpc1thcnJheVBhcmVudFN5bWJvbF0sIHRoaXNbYXJyYXlQYXRoU3ltYm9sXSkgPiAwKSB7XG4gICAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXcmFwcyBbYEFycmF5I3B1c2hgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9wdXNoKSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICpcbiAgICogICAgIGNvbnN0IHNjaGVtYSA9IFNjaGVtYSh7IG51bXM6IFtOdW1iZXJdIH0pO1xuICAgKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gICAqXG4gICAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNb2RlbC5jcmVhdGUoeyBudW1zOiBbMywgNF0gfSk7XG4gICAqICAgICBkb2MubnVtcy5wdXNoKDUpOyAvLyBBZGQgNSB0byB0aGUgZW5kIG9mIHRoZSBhcnJheVxuICAgKiAgICAgYXdhaXQgZG9jLnNhdmUoKTtcbiAgICpcbiAgICogICAgIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIG9iamVjdCB3aXRoIGAkZWFjaGAgYXMgdGhlXG4gICAqICAgICAvLyBmaXJzdCBwYXJhbWV0ZXIgdG8gdXNlIE1vbmdvREIncyBgJHBvc2l0aW9uYFxuICAgKiAgICAgZG9jLm51bXMucHVzaCh7XG4gICAqICAgICAgICRlYWNoOiBbMSwgMl0sXG4gICAqICAgICAgICRwb3NpdGlvbjogMFxuICAgKiAgICAgfSk7XG4gICAqICAgICBkb2MubnVtczsgLy8gWzEsIDIsIDMsIDQsIDVdXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbYXJnc11cbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBwdXNoXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIHB1c2goKSB7XG4gICAgbGV0IHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICBsZXQgYXRvbWljID0gdmFsdWVzO1xuICAgIGNvbnN0IGlzT3ZlcndyaXRlID0gdmFsdWVzWzBdICE9IG51bGwgJiZcbiAgICAgIHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkodmFsdWVzWzBdLCAnJGVhY2gnKTtcbiAgICBjb25zdCBhcnIgPSB1dGlscy5pc01vbmdvb3NlQXJyYXkodGhpcykgPyB0aGlzLl9fYXJyYXkgOiB0aGlzO1xuICAgIGlmIChpc092ZXJ3cml0ZSkge1xuICAgICAgYXRvbWljID0gdmFsdWVzWzBdO1xuICAgICAgdmFsdWVzID0gdmFsdWVzWzBdLiRlYWNoO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2FycmF5U2NoZW1hU3ltYm9sXSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gX2Jhc2VQdXNoLmFwcGx5KHRoaXMsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgX2NoZWNrTWFudWFsUG9wdWxhdGlvbih0aGlzLCB2YWx1ZXMpO1xuXG4gICAgdmFsdWVzID0gW10ubWFwLmNhbGwodmFsdWVzLCB0aGlzLl9tYXBDYXN0LCB0aGlzKTtcbiAgICBsZXQgcmV0O1xuICAgIGNvbnN0IGF0b21pY3MgPSB0aGlzW2FycmF5QXRvbWljc1N5bWJvbF07XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgaWYgKGlzT3ZlcndyaXRlKSB7XG4gICAgICBhdG9taWMuJGVhY2ggPSB2YWx1ZXM7XG5cbiAgICAgIGlmICgoYXRvbWljcy4kcHVzaCAmJiBhdG9taWNzLiRwdXNoLiRlYWNoICYmIGF0b21pY3MuJHB1c2guJGVhY2gubGVuZ3RoIHx8IDApICE9PSAwICYmXG4gICAgICAgICAgYXRvbWljcy4kcHVzaC4kcG9zaXRpb24gIT0gYXRvbWljLiRwb3NpdGlvbikge1xuICAgICAgICBpZiAoYXRvbWljLiRwb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgW10uc3BsaWNlLmFwcGx5KGFyciwgW2F0b21pYy4kcG9zaXRpb24sIDBdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgICAgICAgICByZXQgPSBhcnIubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IFtdLnB1c2guYXBwbHkoYXJyLCB2YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoYXRvbWljLiRwb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIFtdLnNwbGljZS5hcHBseShhcnIsIFthdG9taWMuJHBvc2l0aW9uLCAwXS5jb25jYXQodmFsdWVzKSk7XG4gICAgICAgIHJldCA9IHRoaXMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gW10ucHVzaC5hcHBseShhcnIsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0b21pYyA9IHZhbHVlcztcbiAgICAgIHJldCA9IF9iYXNlUHVzaC5hcHBseShhcnIsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRwdXNoJywgYXRvbWljKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBvZiBbcHVsbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hcnJheS5odG1sI01vbmdvb3NlQXJyYXkucHJvdG90eXBlLnB1bGwoKSlcbiAgICpcbiAgICogQHNlZSBNb25nb29zZUFycmF5I3B1bGwgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hcnJheS5odG1sI01vbmdvb3NlQXJyYXkucHJvdG90eXBlLnB1bGwoKVxuICAgKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS9wdWxsL1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1ldGhvZCByZW1vdmVcbiAgICovXG5cbiAgcmVtb3ZlKCkge1xuICAgIHJldHVybiB0aGlzLnB1bGwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgY2FzdGVkIGB2YWxgIGF0IGluZGV4IGBpYCBhbmQgbWFya3MgdGhlIGFycmF5IG1vZGlmaWVkLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICAvLyBnaXZlbiBkb2N1bWVudHMgYmFzZWQgb24gdGhlIGZvbGxvd2luZ1xuICAgKiAgICAgY29uc3QgRG9jID0gbW9uZ29vc2UubW9kZWwoJ0RvYycsIG5ldyBTY2hlbWEoeyBhcnJheTogW051bWJlcl0gfSkpO1xuICAgKlxuICAgKiAgICAgY29uc3QgZG9jID0gbmV3IERvYyh7IGFycmF5OiBbMiwzLDRdIH0pXG4gICAqXG4gICAqICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpIC8vIFsyLDMsNF1cbiAgICpcbiAgICogICAgIGRvYy5hcnJheS5zZXQoMSxcIjVcIik7XG4gICAqICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpOyAvLyBbMiw1LDRdIC8vIHByb3Blcmx5IGNhc3QgdG8gbnVtYmVyXG4gICAqICAgICBkb2Muc2F2ZSgpIC8vIHRoZSBjaGFuZ2UgaXMgc2F2ZWRcbiAgICpcbiAgICogICAgIC8vIFZTIG5vdCB1c2luZyBhcnJheSNzZXRcbiAgICogICAgIGRvYy5hcnJheVsxXSA9IFwiNVwiO1xuICAgKiAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KTsgLy8gWzIsXCI1XCIsNF0gLy8gbm8gY2FzdGluZ1xuICAgKiAgICAgZG9jLnNhdmUoKSAvLyBjaGFuZ2UgaXMgbm90IHNhdmVkXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSB0aGlzXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIHNldChpLCB2YWwsIHNraXBNb2RpZmllZCkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuX19hcnJheTtcbiAgICBpZiAoc2tpcE1vZGlmaWVkKSB7XG4gICAgICBhcnJbaV0gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBtZXRob2RzLl9jYXN0LmNhbGwodGhpcywgdmFsLCBpKTtcbiAgICBtZXRob2RzLl9tYXJrTW9kaWZpZWQuY2FsbCh0aGlzLCBpKTtcbiAgICBhcnJbaV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogV3JhcHMgW2BBcnJheSNzaGlmdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3Vuc2hpZnQpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgZG9jLmFycmF5ID0gWzIsM107XG4gICAqICAgICBjb25zdCByZXMgPSBkb2MuYXJyYXkuc2hpZnQoKTtcbiAgICogICAgIGNvbnNvbGUubG9nKHJlcykgLy8gMlxuICAgKiAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KSAvLyBbM11cbiAgICpcbiAgICogIyMjIyBOb3RlOlxuICAgKlxuICAgKiBfbWFya3MgdGhlIGVudGlyZSBhcnJheSBhcyBtb2RpZmllZCwgd2hpY2ggaWYgc2F2ZWQsIHdpbGwgc3RvcmUgaXQgYXMgYSBgJHNldGAgb3BlcmF0aW9uLCBwb3RlbnRpYWxseSBvdmVyd3JpdHRpbmcgYW55IGNoYW5nZXMgdGhhdCBoYXBwZW4gYmV0d2VlbiB3aGVuIHlvdSByZXRyaWV2ZWQgdGhlIG9iamVjdCBhbmQgd2hlbiB5b3Ugc2F2ZSBpdC5fXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2Qgc2hpZnRcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgc2hpZnQoKSB7XG4gICAgY29uc3QgYXJyID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHRoaXMpID8gdGhpcy5fX2FycmF5IDogdGhpcztcbiAgICB0aGlzLl9tYXJrTW9kaWZpZWQoKTtcbiAgICBjb25zdCByZXQgPSBbXS5zaGlmdC5jYWxsKGFycik7XG4gICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB0aGlzKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBXcmFwcyBbYEFycmF5I3NvcnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0KSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX21hcmtzIHRoZSBlbnRpcmUgYXJyYXkgYXMgbW9kaWZpZWQsIHdoaWNoIGlmIHNhdmVkLCB3aWxsIHN0b3JlIGl0IGFzIGEgYCRzZXRgIG9wZXJhdGlvbiwgcG90ZW50aWFsbHkgb3ZlcndyaXR0aW5nIGFueSBjaGFuZ2VzIHRoYXQgaGFwcGVuIGJldHdlZW4gd2hlbiB5b3UgcmV0cmlldmVkIHRoZSBvYmplY3QgYW5kIHdoZW4geW91IHNhdmUgaXQuX1xuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHNvcnRcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICogQHNlZSBNYXN0ZXJpbmdKUzogQXJyYXkgc29ydCBodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvYXJyYXktc29ydFxuICAgKi9cblxuICBzb3J0KCkge1xuICAgIGNvbnN0IGFyciA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh0aGlzKSA/IHRoaXMuX19hcnJheSA6IHRoaXM7XG4gICAgY29uc3QgcmV0ID0gW10uc29ydC5hcHBseShhcnIsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB0aGlzKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBXcmFwcyBbYEFycmF5I3NwbGljZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NwbGljZSkgd2l0aCBwcm9wZXIgY2hhbmdlIHRyYWNraW5nIGFuZCBjYXN0aW5nLlxuICAgKlxuICAgKiAjIyMjIE5vdGU6XG4gICAqXG4gICAqIF9tYXJrcyB0aGUgZW50aXJlIGFycmF5IGFzIG1vZGlmaWVkLCB3aGljaCBpZiBzYXZlZCwgd2lsbCBzdG9yZSBpdCBhcyBhIGAkc2V0YCBvcGVyYXRpb24sIHBvdGVudGlhbGx5IG92ZXJ3cml0dGluZyBhbnkgY2hhbmdlcyB0aGF0IGhhcHBlbiBiZXR3ZWVuIHdoZW4geW91IHJldHJpZXZlZCB0aGUgb2JqZWN0IGFuZCB3aGVuIHlvdSBzYXZlIGl0Ll9cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBzcGxpY2VcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICogQHNlZSBNYXN0ZXJpbmdKUzogQXJyYXkgc3BsaWNlIGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9hcnJheS1zcGxpY2VcbiAgICovXG5cbiAgc3BsaWNlKCkge1xuICAgIGxldCByZXQ7XG4gICAgY29uc3QgYXJyID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHRoaXMpID8gdGhpcy5fX2FycmF5IDogdGhpcztcblxuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgIF9jaGVja01hbnVhbFBvcHVsYXRpb24odGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgbGV0IHZhbHM7XG4gICAgICBpZiAodGhpc1thcnJheVNjaGVtYVN5bWJvbF0gPT0gbnVsbCkge1xuICAgICAgICB2YWxzID0gYXJndW1lbnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFscyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhbHNbaV0gPSBpIDwgMiA/XG4gICAgICAgICAgICBhcmd1bWVudHNbaV0gOlxuICAgICAgICAgICAgdGhpcy5fY2FzdChhcmd1bWVudHNbaV0sIGFyZ3VtZW50c1swXSArIChpIC0gMikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldCA9IFtdLnNwbGljZS5hcHBseShhcnIsIHZhbHMpO1xuICAgICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG5cbiAgdG9CU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5hdGl2ZSBqcyBBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgdG9PYmplY3Qob3B0aW9ucykge1xuICAgIGNvbnN0IGFyciA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh0aGlzKSA/IHRoaXMuX19hcnJheSA6IHRoaXM7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZXBvcHVsYXRlKSB7XG4gICAgICBvcHRpb25zID0gY2xvbmUob3B0aW9ucyk7XG4gICAgICBvcHRpb25zLl9pc05lc3RlZCA9IHRydWU7XG4gICAgICAvLyBFbnN1cmUgcmV0dXJuIHZhbHVlIGlzIGEgdmFuaWxsYSBhcnJheSwgYmVjYXVzZSBpbiBOb2RlLmpzIDYrIGBtYXAoKWBcbiAgICAgIC8vIGlzIHNtYXJ0IGVub3VnaCB0byB1c2UgdGhlIGluaGVyaXRlZCBhcnJheSdzIGNvbnN0cnVjdG9yLlxuICAgICAgcmV0dXJuIFtdLmNvbmNhdChhcnIpLm1hcChmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIGRvYyBpbnN0YW5jZW9mIERvY3VtZW50XG4gICAgICAgICAgPyBkb2MudG9PYmplY3Qob3B0aW9ucylcbiAgICAgICAgICA6IGRvYztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBbXS5jb25jYXQoYXJyKTtcbiAgfSxcblxuICAkdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnRvT2JqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIC8qKlxuICAgKiBXcmFwcyBbYEFycmF5I3Vuc2hpZnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS91bnNoaWZ0KSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX21hcmtzIHRoZSBlbnRpcmUgYXJyYXkgYXMgbW9kaWZpZWQsIHdoaWNoIGlmIHNhdmVkLCB3aWxsIHN0b3JlIGl0IGFzIGEgYCRzZXRgIG9wZXJhdGlvbiwgcG90ZW50aWFsbHkgb3ZlcndyaXRpbmcgYW55IGNoYW5nZXMgdGhhdCBoYXBwZW4gYmV0d2VlbiB3aGVuIHlvdSByZXRyaWV2ZWQgdGhlIG9iamVjdCBhbmQgd2hlbiB5b3Ugc2F2ZSBpdC5fXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgdW5zaGlmdFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICB1bnNoaWZ0KCkge1xuICAgIF9jaGVja01hbnVhbFBvcHVsYXRpb24odGhpcywgYXJndW1lbnRzKTtcblxuICAgIGxldCB2YWx1ZXM7XG4gICAgaWYgKHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdID09IG51bGwpIHtcbiAgICAgIHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzID0gW10ubWFwLmNhbGwoYXJndW1lbnRzLCB0aGlzLl9jYXN0LCB0aGlzKTtcbiAgICB9XG5cbiAgICBjb25zdCBhcnIgPSB1dGlscy5pc01vbmdvb3NlQXJyYXkodGhpcykgPyB0aGlzLl9fYXJyYXkgOiB0aGlzO1xuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgIFtdLnVuc2hpZnQuYXBwbHkoYXJyLCB2YWx1ZXMpO1xuICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckc2V0JywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9pc0FsbFN1YmRvY3MoZG9jcywgcmVmKSB7XG4gIGlmICghcmVmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBhcmcgb2YgZG9jcykge1xuICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtb2RlbCA9IGFyZy5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiBEb2N1bWVudCkgfHxcbiAgICAgIChtb2RlbC5tb2RlbE5hbWUgIT09IHJlZiAmJiBtb2RlbC5iYXNlTW9kZWxOYW1lICE9PSByZWYpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qIVxuICogTWluaW1pemUgX2p1c3RfIGVtcHR5IG9iamVjdHMgYWxvbmcgdGhlIHBhdGggY2hhaW4gc3BlY2lmaWVkXG4gKiBieSBgcGFydHNgLCBpZ25vcmluZyBhbGwgb3RoZXIgcGF0aHMuIFVzZWZ1bCBpbiBjYXNlcyB3aGVyZVxuICogeW91IHdhbnQgdG8gbWluaW1pemUgYWZ0ZXIgdW5zZXR0aW5nIGEgcGF0aC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG9iaiA9IHsgZm9vOiB7IGJhcjogeyBiYXo6IHt9IH0gfSwgYToge30gfTtcbiAqICAgICBfbWluaW1pemVQYXRoKG9iaiwgJ2Zvby5iYXIuYmF6Jyk7XG4gKiAgICAgb2JqOyAvLyB7IGE6IHt9IH1cbiAqL1xuXG5mdW5jdGlvbiBfbWluaW1pemVQYXRoKG9iaiwgcGFydHMsIGkpIHtcbiAgaWYgKHR5cGVvZiBwYXJ0cyA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAocGFydHMuaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhcnRzID0gbXBhdGguc3RyaW5nVG9QYXJ0cyhwYXJ0cyk7XG4gIH1cbiAgaSA9IGkgfHwgMDtcbiAgaWYgKGkgPj0gcGFydHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIF9taW5pbWl6ZVBhdGgob2JqW3BhcnRzWzBdXSwgcGFydHMsIGkgKyAxKTtcbiAgaWYgKG9ialtwYXJ0c1swXV0gIT0gbnVsbCAmJiB0eXBlb2Ygb2JqW3BhcnRzWzBdXSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMob2JqW3BhcnRzWzBdXSkubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIG9ialtwYXJ0c1swXV07XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfY2hlY2tNYW51YWxQb3B1bGF0aW9uKGFyciwgZG9jcykge1xuICBjb25zdCByZWYgPSBhcnIgPT0gbnVsbCA/XG4gICAgbnVsbCA6XG4gICAgYXJyW2FycmF5U2NoZW1hU3ltYm9sXSAmJiBhcnJbYXJyYXlTY2hlbWFTeW1ib2xdLmNhc3RlciAmJiBhcnJbYXJyYXlTY2hlbWFTeW1ib2xdLmNhc3Rlci5vcHRpb25zICYmIGFyclthcnJheVNjaGVtYVN5bWJvbF0uY2FzdGVyLm9wdGlvbnMucmVmIHx8IG51bGw7XG4gIGlmIChhcnIubGVuZ3RoID09PSAwICYmXG4gICAgICBkb2NzLmxlbmd0aCAhPT0gMCkge1xuICAgIGlmIChfaXNBbGxTdWJkb2NzKGRvY3MsIHJlZikpIHtcbiAgICAgIGFyclthcnJheVBhcmVudFN5bWJvbF0uJHBvcHVsYXRlZChhcnJbYXJyYXlQYXRoU3ltYm9sXSwgW10sIHtcbiAgICAgICAgW3BvcHVsYXRlTW9kZWxTeW1ib2xdOiBkb2NzWzBdLmNvbnN0cnVjdG9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcmV0dXJuVmFuaWxsYUFycmF5TWV0aG9kcyA9IFtcbiAgJ2ZpbHRlcicsXG4gICdmbGF0JyxcbiAgJ2ZsYXRNYXAnLFxuICAnbWFwJyxcbiAgJ3NsaWNlJ1xuXTtcbmZvciAoY29uc3QgbWV0aG9kIG9mIHJldHVyblZhbmlsbGFBcnJheU1ldGhvZHMpIHtcbiAgaWYgKEFycmF5LnByb3RvdHlwZVttZXRob2RdID09IG51bGwpIHtcbiAgICBjb250aW51ZTtcbiAgfVxuXG4gIG1ldGhvZHNbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IF9hcnIgPSB1dGlscy5pc01vbmdvb3NlQXJyYXkodGhpcykgPyB0aGlzLl9fYXJyYXkgOiB0aGlzO1xuICAgIGNvbnN0IGFyciA9IFtdLmNvbmNhdChfYXJyKTtcblxuICAgIHJldHVybiBhcnJbbWV0aG9kXS5hcHBseShhcnIsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWV0aG9kcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/array/methods/index.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/buffer.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/buffer.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst Binary = (__webpack_require__(/*! bson */ \"(api)/../server/node_modules/bson/lib/bson.cjs\").Binary);\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\n/**\n * Mongoose Buffer constructor.\n *\n * Values always have to be passed to the constructor to initialize.\n *\n * @param {Buffer} value\n * @param {String} encode\n * @param {Number} offset\n * @api private\n * @inherits Buffer https://nodejs.org/api/buffer.html\n * @see https://bit.ly/f6CnZU\n */\n\nfunction MongooseBuffer(value, encode, offset) {\n  let val = value;\n  if (value == null) {\n    val = 0;\n  }\n\n  let encoding;\n  let path;\n  let doc;\n\n  if (Array.isArray(encode)) {\n    // internal casting\n    path = encode[0];\n    doc = encode[1];\n  } else {\n    encoding = encode;\n  }\n\n  let buf;\n  if (typeof val === 'number' || val instanceof Number) {\n    buf = Buffer.alloc(val);\n  } else { // string, array or object { type: 'Buffer', data: [...] }\n    buf = Buffer.from(val, encoding, offset);\n  }\n  utils.decorate(buf, MongooseBuffer.mixin);\n  buf.isMongooseBuffer = true;\n\n  // make sure these internal props don't show up in Object.keys()\n  buf[MongooseBuffer.pathSymbol] = path;\n  buf[parentSymbol] = doc;\n\n  buf._subtype = 0;\n  return buf;\n}\n\nconst pathSymbol = Symbol.for('mongoose#Buffer#_path');\nconst parentSymbol = Symbol.for('mongoose#Buffer#_parent');\nMongooseBuffer.pathSymbol = pathSymbol;\n\n/*!\n * Inherit from Buffer.\n */\n\nMongooseBuffer.mixin = {\n\n  /**\n   * Default subtype for the Binary representing this Buffer\n   *\n   * @api private\n   * @property _subtype\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  _subtype: undefined,\n\n  /**\n   * Marks this buffer as modified.\n   *\n   * @api private\n   * @method _markModified\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  _markModified: function() {\n    const parent = this[parentSymbol];\n\n    if (parent) {\n      parent.markModified(this[MongooseBuffer.pathSymbol]);\n    }\n    return this;\n  },\n\n  /**\n   * Writes the buffer.\n   *\n   * @api public\n   * @method write\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  write: function() {\n    const written = Buffer.prototype.write.apply(this, arguments);\n\n    if (written > 0) {\n      this._markModified();\n    }\n\n    return written;\n  },\n\n  /**\n   * Copies the buffer.\n   *\n   * #### Note:\n   *\n   * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.\n   *\n   * @return {Number} The number of bytes copied.\n   * @param {Buffer} target\n   * @method copy\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  copy: function(target) {\n    const ret = Buffer.prototype.copy.apply(this, arguments);\n\n    if (target && target.isMongooseBuffer) {\n      target._markModified();\n    }\n\n    return ret;\n  }\n};\n\n/*!\n * Compile other Buffer methods marking this buffer as modified.\n */\n\nutils.each(\n  [\n    // node < 0.5\n    'writeUInt8', 'writeUInt16', 'writeUInt32', 'writeInt8', 'writeInt16', 'writeInt32',\n    'writeFloat', 'writeDouble', 'fill',\n    'utf8Write', 'binaryWrite', 'asciiWrite', 'set',\n\n    // node >= 0.5\n    'writeUInt16LE', 'writeUInt16BE', 'writeUInt32LE', 'writeUInt32BE',\n    'writeInt16LE', 'writeInt16BE', 'writeInt32LE', 'writeInt32BE', 'writeFloatLE', 'writeFloatBE', 'writeDoubleLE', 'writeDoubleBE']\n  , function(method) {\n    if (!Buffer.prototype[method]) {\n      return;\n    }\n    MongooseBuffer.mixin[method] = function() {\n      const ret = Buffer.prototype[method].apply(this, arguments);\n      this._markModified();\n      return ret;\n    };\n  });\n\n/**\n * Converts this buffer to its Binary type representation.\n *\n * #### SubTypes:\n *\n *     const bson = require('bson')\n *     bson.BSON_BINARY_SUBTYPE_DEFAULT\n *     bson.BSON_BINARY_SUBTYPE_FUNCTION\n *     bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *     bson.BSON_BINARY_SUBTYPE_UUID\n *     bson.BSON_BINARY_SUBTYPE_MD5\n *     bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *     doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);\n *\n * @see bsonspec https://bsonspec.org/#/specification\n * @param {Hex} [subtype]\n * @return {Binary}\n * @api public\n * @method toObject\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.toObject = function(options) {\n  const subtype = typeof options === 'number'\n    ? options\n    : (this._subtype || 0);\n  return new Binary(Buffer.from(this), subtype);\n};\n\nMongooseBuffer.mixin.$toObject = MongooseBuffer.mixin.toObject;\n\n/**\n * Converts this buffer for storage in MongoDB, including subtype\n *\n * @return {Binary}\n * @api public\n * @method toBSON\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.toBSON = function() {\n  return new Binary(this, this._subtype || 0);\n};\n\n/**\n * Determines if this buffer is equals to `other` buffer\n *\n * @param {Buffer} other\n * @return {Boolean}\n * @method equals\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.equals = function(other) {\n  if (!Buffer.isBuffer(other)) {\n    return false;\n  }\n\n  if (this.length !== other.length) {\n    return false;\n  }\n\n  for (let i = 0; i < this.length; ++i) {\n    if (this[i] !== other[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Sets the subtype option and marks the buffer modified.\n *\n * #### SubTypes:\n *\n *     const bson = require('bson')\n *     bson.BSON_BINARY_SUBTYPE_DEFAULT\n *     bson.BSON_BINARY_SUBTYPE_FUNCTION\n *     bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *     bson.BSON_BINARY_SUBTYPE_UUID\n *     bson.BSON_BINARY_SUBTYPE_MD5\n *     bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *\n *     doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);\n *\n * @see bsonspec https://bsonspec.org/#/specification\n * @param {Hex} subtype\n * @api public\n * @method subtype\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.subtype = function(subtype) {\n  if (typeof subtype !== 'number') {\n    throw new TypeError('Invalid subtype. Expected a number');\n  }\n\n  if (this._subtype !== subtype) {\n    this._markModified();\n  }\n\n  this._subtype = subtype;\n};\n\n/*!\n * Module exports.\n */\n\nMongooseBuffer.Binary = Binary;\n\nmodule.exports = MongooseBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixlQUFlLDBGQUFzQjtBQUNyQyxjQUFjLG1CQUFPLENBQUMsb0VBQVU7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTyw2QkFBNkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcdHlwZXNcXGJ1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCaW5hcnkgPSByZXF1aXJlKCdic29uJykuQmluYXJ5O1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIE1vbmdvb3NlIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBWYWx1ZXMgYWx3YXlzIGhhdmUgdG8gYmUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciB0byBpbml0aWFsaXplLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IGVuY29kZVxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuICogQGFwaSBwcml2YXRlXG4gKiBAaW5oZXJpdHMgQnVmZmVyIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvYnVmZmVyLmh0bWxcbiAqIEBzZWUgaHR0cHM6Ly9iaXQubHkvZjZDblpVXG4gKi9cblxuZnVuY3Rpb24gTW9uZ29vc2VCdWZmZXIodmFsdWUsIGVuY29kZSwgb2Zmc2V0KSB7XG4gIGxldCB2YWwgPSB2YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB2YWwgPSAwO1xuICB9XG5cbiAgbGV0IGVuY29kaW5nO1xuICBsZXQgcGF0aDtcbiAgbGV0IGRvYztcblxuICBpZiAoQXJyYXkuaXNBcnJheShlbmNvZGUpKSB7XG4gICAgLy8gaW50ZXJuYWwgY2FzdGluZ1xuICAgIHBhdGggPSBlbmNvZGVbMF07XG4gICAgZG9jID0gZW5jb2RlWzFdO1xuICB9IGVsc2Uge1xuICAgIGVuY29kaW5nID0gZW5jb2RlO1xuICB9XG5cbiAgbGV0IGJ1ZjtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInIHx8IHZhbCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvYyh2YWwpO1xuICB9IGVsc2UgeyAvLyBzdHJpbmcsIGFycmF5IG9yIG9iamVjdCB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbLi4uXSB9XG4gICAgYnVmID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZywgb2Zmc2V0KTtcbiAgfVxuICB1dGlscy5kZWNvcmF0ZShidWYsIE1vbmdvb3NlQnVmZmVyLm1peGluKTtcbiAgYnVmLmlzTW9uZ29vc2VCdWZmZXIgPSB0cnVlO1xuXG4gIC8vIG1ha2Ugc3VyZSB0aGVzZSBpbnRlcm5hbCBwcm9wcyBkb24ndCBzaG93IHVwIGluIE9iamVjdC5rZXlzKClcbiAgYnVmW01vbmdvb3NlQnVmZmVyLnBhdGhTeW1ib2xdID0gcGF0aDtcbiAgYnVmW3BhcmVudFN5bWJvbF0gPSBkb2M7XG5cbiAgYnVmLl9zdWJ0eXBlID0gMDtcbiAgcmV0dXJuIGJ1Zjtcbn1cblxuY29uc3QgcGF0aFN5bWJvbCA9IFN5bWJvbC5mb3IoJ21vbmdvb3NlI0J1ZmZlciNfcGF0aCcpO1xuY29uc3QgcGFyZW50U3ltYm9sID0gU3ltYm9sLmZvcignbW9uZ29vc2UjQnVmZmVyI19wYXJlbnQnKTtcbk1vbmdvb3NlQnVmZmVyLnBhdGhTeW1ib2wgPSBwYXRoU3ltYm9sO1xuXG4vKiFcbiAqIEluaGVyaXQgZnJvbSBCdWZmZXIuXG4gKi9cblxuTW9uZ29vc2VCdWZmZXIubWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgc3VidHlwZSBmb3IgdGhlIEJpbmFyeSByZXByZXNlbnRpbmcgdGhpcyBCdWZmZXJcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwcm9wZXJ0eSBfc3VidHlwZVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VCdWZmZXIubWl4aW5cbiAgICogQHN0YXRpY1xuICAgKi9cblxuICBfc3VidHlwZTogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBNYXJrcyB0aGlzIGJ1ZmZlciBhcyBtb2RpZmllZC5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZXRob2QgX21hcmtNb2RpZmllZFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VCdWZmZXIubWl4aW5cbiAgICogQHN0YXRpY1xuICAgKi9cblxuICBfbWFya01vZGlmaWVkOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzW3BhcmVudFN5bWJvbF07XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQubWFya01vZGlmaWVkKHRoaXNbTW9uZ29vc2VCdWZmZXIucGF0aFN5bWJvbF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogV3JpdGVzIHRoZSBidWZmZXIuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2Qgd3JpdGVcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQnVmZmVyLm1peGluXG4gICAqIEBzdGF0aWNcbiAgICovXG5cbiAgd3JpdGU6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHdyaXR0ZW4gPSBCdWZmZXIucHJvdG90eXBlLndyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAod3JpdHRlbiA+IDApIHtcbiAgICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB3cml0dGVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIGJ1ZmZlci5cbiAgICpcbiAgICogIyMjIyBOb3RlOlxuICAgKlxuICAgKiBgQnVmZmVyI2NvcHlgIGRvZXMgbm90IG1hcmsgYHRhcmdldGAgYXMgbW9kaWZpZWQgc28geW91IG11c3QgY29weSBmcm9tIGEgYE1vbmdvb3NlQnVmZmVyYCBmb3IgaXQgdG8gd29yayBhcyBleHBlY3RlZC4gVGhpcyBpcyBhIHdvcmsgYXJvdW5kIHNpbmNlIGBjb3B5YCBtb2RpZmllcyB0aGUgdGFyZ2V0LCBub3QgdGhpcy5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGJ5dGVzIGNvcGllZC5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IHRhcmdldFxuICAgKiBAbWV0aG9kIGNvcHlcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQnVmZmVyLm1peGluXG4gICAqIEBzdGF0aWNcbiAgICovXG5cbiAgY29weTogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgY29uc3QgcmV0ID0gQnVmZmVyLnByb3RvdHlwZS5jb3B5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5pc01vbmdvb3NlQnVmZmVyKSB7XG4gICAgICB0YXJnZXQuX21hcmtNb2RpZmllZCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cbn07XG5cbi8qIVxuICogQ29tcGlsZSBvdGhlciBCdWZmZXIgbWV0aG9kcyBtYXJraW5nIHRoaXMgYnVmZmVyIGFzIG1vZGlmaWVkLlxuICovXG5cbnV0aWxzLmVhY2goXG4gIFtcbiAgICAvLyBub2RlIDwgMC41XG4gICAgJ3dyaXRlVUludDgnLCAnd3JpdGVVSW50MTYnLCAnd3JpdGVVSW50MzInLCAnd3JpdGVJbnQ4JywgJ3dyaXRlSW50MTYnLCAnd3JpdGVJbnQzMicsXG4gICAgJ3dyaXRlRmxvYXQnLCAnd3JpdGVEb3VibGUnLCAnZmlsbCcsXG4gICAgJ3V0ZjhXcml0ZScsICdiaW5hcnlXcml0ZScsICdhc2NpaVdyaXRlJywgJ3NldCcsXG5cbiAgICAvLyBub2RlID49IDAuNVxuICAgICd3cml0ZVVJbnQxNkxFJywgJ3dyaXRlVUludDE2QkUnLCAnd3JpdGVVSW50MzJMRScsICd3cml0ZVVJbnQzMkJFJyxcbiAgICAnd3JpdGVJbnQxNkxFJywgJ3dyaXRlSW50MTZCRScsICd3cml0ZUludDMyTEUnLCAnd3JpdGVJbnQzMkJFJywgJ3dyaXRlRmxvYXRMRScsICd3cml0ZUZsb2F0QkUnLCAnd3JpdGVEb3VibGVMRScsICd3cml0ZURvdWJsZUJFJ11cbiAgLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBpZiAoIUJ1ZmZlci5wcm90b3R5cGVbbWV0aG9kXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBNb25nb29zZUJ1ZmZlci5taXhpblttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCByZXQgPSBCdWZmZXIucHJvdG90eXBlW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGJ1ZmZlciB0byBpdHMgQmluYXJ5IHR5cGUgcmVwcmVzZW50YXRpb24uXG4gKlxuICogIyMjIyBTdWJUeXBlczpcbiAqXG4gKiAgICAgY29uc3QgYnNvbiA9IHJlcXVpcmUoJ2Jzb24nKVxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX0ZVTkNUSU9OXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX0JZVEVfQVJSQVlcbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfVVVJRFxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9NRDVcbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfVVNFUl9ERUZJTkVEXG4gKiAgICAgZG9jLmJ1ZmZlci50b09iamVjdChic29uLkJTT05fQklOQVJZX1NVQlRZUEVfVVNFUl9ERUZJTkVEKTtcbiAqXG4gKiBAc2VlIGJzb25zcGVjIGh0dHBzOi8vYnNvbnNwZWMub3JnLyMvc3BlY2lmaWNhdGlvblxuICogQHBhcmFtIHtIZXh9IFtzdWJ0eXBlXVxuICogQHJldHVybiB7QmluYXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgdG9PYmplY3RcbiAqIEBtZW1iZXJPZiBNb25nb29zZUJ1ZmZlclxuICovXG5cbk1vbmdvb3NlQnVmZmVyLm1peGluLnRvT2JqZWN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBjb25zdCBzdWJ0eXBlID0gdHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInXG4gICAgPyBvcHRpb25zXG4gICAgOiAodGhpcy5fc3VidHlwZSB8fCAwKTtcbiAgcmV0dXJuIG5ldyBCaW5hcnkoQnVmZmVyLmZyb20odGhpcyksIHN1YnR5cGUpO1xufTtcblxuTW9uZ29vc2VCdWZmZXIubWl4aW4uJHRvT2JqZWN0ID0gTW9uZ29vc2VCdWZmZXIubWl4aW4udG9PYmplY3Q7XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgZm9yIHN0b3JhZ2UgaW4gTW9uZ29EQiwgaW5jbHVkaW5nIHN1YnR5cGVcbiAqXG4gKiBAcmV0dXJuIHtCaW5hcnl9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCB0b0JTT05cbiAqIEBtZW1iZXJPZiBNb25nb29zZUJ1ZmZlclxuICovXG5cbk1vbmdvb3NlQnVmZmVyLm1peGluLnRvQlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEJpbmFyeSh0aGlzLCB0aGlzLl9zdWJ0eXBlIHx8IDApO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoaXMgYnVmZmVyIGlzIGVxdWFscyB0byBgb3RoZXJgIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBvdGhlclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBtZXRob2QgZXF1YWxzXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VCdWZmZXJcbiAqL1xuXG5Nb25nb29zZUJ1ZmZlci5taXhpbi5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvdGhlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0aGlzW2ldICE9PSBvdGhlcltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdWJ0eXBlIG9wdGlvbiBhbmQgbWFya3MgdGhlIGJ1ZmZlciBtb2RpZmllZC5cbiAqXG4gKiAjIyMjIFN1YlR5cGVzOlxuICpcbiAqICAgICBjb25zdCBic29uID0gcmVxdWlyZSgnYnNvbicpXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFRcbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfRlVOQ1RJT05cbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfQllURV9BUlJBWVxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX01ENVxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VU0VSX0RFRklORURcbiAqXG4gKiAgICAgZG9jLmJ1ZmZlci5zdWJ0eXBlKGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEKTtcbiAqXG4gKiBAc2VlIGJzb25zcGVjIGh0dHBzOi8vYnNvbnNwZWMub3JnLyMvc3BlY2lmaWNhdGlvblxuICogQHBhcmFtIHtIZXh9IHN1YnR5cGVcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHN1YnR5cGVcbiAqIEBtZW1iZXJPZiBNb25nb29zZUJ1ZmZlclxuICovXG5cbk1vbmdvb3NlQnVmZmVyLm1peGluLnN1YnR5cGUgPSBmdW5jdGlvbihzdWJ0eXBlKSB7XG4gIGlmICh0eXBlb2Ygc3VidHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN1YnR5cGUuIEV4cGVjdGVkIGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAodGhpcy5fc3VidHlwZSAhPT0gc3VidHlwZSkge1xuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICB9XG5cbiAgdGhpcy5fc3VidHlwZSA9IHN1YnR5cGU7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbk1vbmdvb3NlQnVmZmVyLkJpbmFyeSA9IEJpbmFyeTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb25nb29zZUJ1ZmZlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/buffer.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/decimal128.js":
/*!***************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/decimal128.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Decimal128 type constructor\n *\n * #### Example:\n *\n *     const id = new mongoose.Types.Decimal128('3.1415');\n *\n * @constructor Decimal128\n */\n\n\n\nmodule.exports = __webpack_require__(/*! bson */ \"(api)/../server/node_modules/bson/lib/bson.cjs\").Decimal128;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvZGVjaW1hbDEyOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsNkdBQTJDIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcdHlwZXNcXGRlY2ltYWwxMjguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZWNpbWFsMTI4IHR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGlkID0gbmV3IG1vbmdvb3NlLlR5cGVzLkRlY2ltYWwxMjgoJzMuMTQxNScpO1xuICpcbiAqIEBjb25zdHJ1Y3RvciBEZWNpbWFsMTI4XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2Jzb24nKS5EZWNpbWFsMTI4O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/decimal128.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/index.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module exports.\n */\n\n\n\nexports.Array = __webpack_require__(/*! ./array */ \"(api)/../server/node_modules/mongoose/lib/types/array/index.js\");\nexports.Buffer = __webpack_require__(/*! ./buffer */ \"(api)/../server/node_modules/mongoose/lib/types/buffer.js\");\n\nexports.Document = // @deprecate\nexports.Embedded = __webpack_require__(/*! ./ArraySubdocument */ \"(api)/../server/node_modules/mongoose/lib/types/ArraySubdocument.js\");\n\nexports.DocumentArray = __webpack_require__(/*! ./DocumentArray */ \"(api)/../server/node_modules/mongoose/lib/types/DocumentArray/index.js\");\nexports.Decimal128 = __webpack_require__(/*! ./decimal128 */ \"(api)/../server/node_modules/mongoose/lib/types/decimal128.js\");\nexports.ObjectId = __webpack_require__(/*! ./objectid */ \"(api)/../server/node_modules/mongoose/lib/types/objectid.js\");\n\nexports.Map = __webpack_require__(/*! ./map */ \"(api)/../server/node_modules/mongoose/lib/types/map.js\");\n\nexports.Subdocument = __webpack_require__(/*! ./subdocument */ \"(api)/../server/node_modules/mongoose/lib/types/subdocument.js\");\n\nexports.UUID = __webpack_require__(/*! ./uuid */ \"(api)/../server/node_modules/mongoose/lib/types/uuid.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixvSEFBa0M7QUFDbEMsaUhBQW9DOztBQUVwQyxnQkFBZ0I7QUFDaEIsdUlBQWdEOztBQUVoRCw0SUFBa0Q7QUFDbEQsNkhBQTRDO0FBQzVDLHVIQUF3Qzs7QUFFeEMsd0dBQThCOztBQUU5QixnSUFBOEM7O0FBRTlDLDJHQUFnQyIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHR5cGVzXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkFycmF5ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuZXhwb3J0cy5CdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5leHBvcnRzLkRvY3VtZW50ID0gLy8gQGRlcHJlY2F0ZVxuZXhwb3J0cy5FbWJlZGRlZCA9IHJlcXVpcmUoJy4vQXJyYXlTdWJkb2N1bWVudCcpO1xuXG5leHBvcnRzLkRvY3VtZW50QXJyYXkgPSByZXF1aXJlKCcuL0RvY3VtZW50QXJyYXknKTtcbmV4cG9ydHMuRGVjaW1hbDEyOCA9IHJlcXVpcmUoJy4vZGVjaW1hbDEyOCcpO1xuZXhwb3J0cy5PYmplY3RJZCA9IHJlcXVpcmUoJy4vb2JqZWN0aWQnKTtcblxuZXhwb3J0cy5NYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG5leHBvcnRzLlN1YmRvY3VtZW50ID0gcmVxdWlyZSgnLi9zdWJkb2N1bWVudCcpO1xuXG5leHBvcnRzLlVVSUQgPSByZXF1aXJlKCcuL3V1aWQnKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/index.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/map.js":
/*!********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/map.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Mixed = __webpack_require__(/*! ../schema/mixed */ \"(api)/../server/node_modules/mongoose/lib/schema/mixed.js\");\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"(api)/../server/node_modules/mongoose/lib/error/mongooseError.js\");\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst deepEqual = (__webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\").deepEqual);\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst handleSpreadDoc = __webpack_require__(/*! ../helpers/document/handleSpreadDoc */ \"(api)/../server/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst specialProperties = __webpack_require__(/*! ../helpers/specialProperties */ \"(api)/../server/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst populateModelSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\n\n/*!\n * ignore\n */\n\nclass MongooseMap extends Map {\n  constructor(v, path, doc, schemaType) {\n    if (getConstructorName(v) === 'Object') {\n      v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);\n    }\n    super(v);\n    this.$__parent = doc != null && doc.$__ != null ? doc : null;\n    this.$__path = path;\n    this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;\n\n    this.$__runDeferred();\n  }\n\n  $init(key, value) {\n    checkValidKey(key);\n\n    super.set(key, value);\n\n    if (value != null && value.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n    }\n  }\n\n  $__set(key, value) {\n    super.set(key, value);\n  }\n\n  /**\n   * Overwrites native Map's `get()` function to support Mongoose getters.\n   *\n   * @api public\n   * @method get\n   * @memberOf Map\n   */\n\n  get(key, options) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    options = options || {};\n    if (options.getters === false) {\n      return super.get(key);\n    }\n    return this.$__schemaType.applyGetters(super.get(key), this.$__parent);\n  }\n\n  /**\n   * Overwrites native Map's `set()` function to support setters, `populate()`,\n   * and change tracking. Note that Mongoose maps _only_ support strings and\n   * ObjectIds as keys.\n   *\n   * #### Example:\n   *\n   *     doc.myMap.set('test', 42); // works\n   *     doc.myMap.set({ obj: 42 }, 42); // Throws \"Mongoose maps only support string keys\"\n   *\n   * @api public\n   * @method set\n   * @memberOf Map\n   */\n\n  set(key, value) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    checkValidKey(key);\n    value = handleSpreadDoc(value);\n\n    // Weird, but because you can't assign to `this` before calling `super()`\n    // you can't get access to `$__schemaType` to cast in the initial call to\n    // `set()` from the `super()` constructor.\n\n    if (this.$__schemaType == null) {\n      this.$__deferred = this.$__deferred || [];\n      this.$__deferred.push({ key: key, value: value });\n      return;\n    }\n\n    let _fullPath;\n    const parent = this.$__parent;\n    const populated = parent != null && parent.$__ && parent.$__.populated ?\n      parent.$populated(fullPath.call(this), true) || parent.$populated(this.$__path, true) :\n      null;\n    const priorVal = this.get(key);\n\n    if (populated != null) {\n      if (this.$__schemaType.$isSingleNested) {\n        throw new MongooseError(\n          'Cannot manually populate single nested subdoc underneath Map ' +\n          `at path \"${this.$__path}\". Try using an array instead of a Map.`\n        );\n      }\n      if (Array.isArray(value) && this.$__schemaType.$isMongooseArray) {\n        value = value.map(v => {\n          if (v.$__ == null) {\n            v = new populated.options[populateModelSymbol](v);\n          }\n          // Doesn't support single nested \"in-place\" populate\n          v.$__.wasPopulated = { value: v._id };\n          return v;\n        });\n      } else {\n        if (value.$__ == null) {\n          value = new populated.options[populateModelSymbol](value);\n        }\n        // Doesn't support single nested \"in-place\" populate\n        value.$__.wasPopulated = { value: value._id };\n      }\n    } else {\n      try {\n        const options = this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested ?\n          { path: fullPath.call(this) } :\n          null;\n        value = this.$__schemaType.applySetters(\n          value,\n          this.$__parent,\n          false,\n          this.get(key),\n          options\n        );\n      } catch (error) {\n        if (this.$__parent != null && this.$__parent.$__ != null) {\n          this.$__parent.invalidate(fullPath.call(this), error);\n          return;\n        }\n        throw error;\n      }\n    }\n\n    super.set(key, value);\n\n    if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {\n      parent.markModified(fullPath.call(this));\n    }\n\n    // Delay calculating full path unless absolutely necessary, because string\n    // concatenation is a bottleneck re: #13171\n    function fullPath() {\n      if (_fullPath) {\n        return _fullPath;\n      }\n      _fullPath = this.$__path + '.' + key;\n      return _fullPath;\n    }\n  }\n\n  /**\n   * Overwrites native Map's `clear()` function to support change tracking.\n   *\n   * @api public\n   * @method clear\n   * @memberOf Map\n   */\n\n  clear() {\n    super.clear();\n    const parent = this.$__parent;\n    if (parent != null) {\n      parent.markModified(this.$__path);\n    }\n  }\n\n  /**\n   * Overwrites native Map's `delete()` function to support change tracking.\n   *\n   * @api public\n   * @method delete\n   * @memberOf Map\n   */\n\n  delete(key) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    this.set(key, undefined);\n    return super.delete(key);\n  }\n\n  /**\n   * Converts this map to a native JavaScript Map so the MongoDB driver can serialize it.\n   *\n   * @api public\n   * @method toBSON\n   * @memberOf Map\n   */\n\n  toBSON() {\n    return new Map(this);\n  }\n\n  toObject(options) {\n    if (options && options.flattenMaps) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = clone(this.get(key), options);\n      }\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  }\n\n  /**\n   * Converts this map to a native JavaScript Map for `JSON.stringify()`. Set\n   * the `flattenMaps` option to convert this map to a POJO instead.\n   *\n   * #### Example:\n   *\n   *     doc.myMap.toJSON() instanceof Map; // true\n   *     doc.myMap.toJSON({ flattenMaps: true }) instanceof Map; // false\n   *\n   * @api public\n   * @method toJSON\n   * @param {Object} [options]\n   * @param {Boolean} [options.flattenMaps=false] set to `true` to convert the map to a POJO rather than a native JavaScript map\n   * @memberOf Map\n   */\n\n  toJSON(options) {\n    if (typeof (options && options.flattenMaps) === 'boolean' ? options.flattenMaps : true) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = clone(this.get(key), options);\n      }\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  inspect() {\n    return new Map(this);\n  }\n\n  $__runDeferred() {\n    if (!this.$__deferred) {\n      return;\n    }\n\n    for (const keyValueObject of this.$__deferred) {\n      this.set(keyValueObject.key, keyValueObject.value);\n    }\n\n    this.$__deferred = null;\n  }\n}\n\nif (util.inspect.custom) {\n  Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: MongooseMap.prototype.inspect\n  });\n}\n\nObject.defineProperty(MongooseMap.prototype, '$__set', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__parent', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__path', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__schemaType', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\n/**\n * Set to `true` for all Mongoose map instances\n *\n * @api public\n * @property $isMongooseMap\n * @memberOf MongooseMap\n * @instance\n */\n\nObject.defineProperty(MongooseMap.prototype, '$isMongooseMap', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__deferredCalls', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\n/**\n * Since maps are stored as objects under the hood, keys must be strings\n * and can't contain any invalid characters\n * @param {String} key\n * @api private\n */\n\nfunction checkValidKey(key) {\n  const keyType = typeof key;\n  if (keyType !== 'string') {\n    throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);\n  }\n  if (key.startsWith('$')) {\n    throw new Error(`Mongoose maps do not support keys that start with \"$\", got \"${key}\"`);\n  }\n  if (key.includes('.')) {\n    throw new Error(`Mongoose maps do not support keys that contain \".\", got \"${key}\"`);\n  }\n  if (specialProperties.has(key)) {\n    throw new Error(`Mongoose maps do not support reserved key name \"${key}\"`);\n  }\n}\n\nmodule.exports = MongooseMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvbWFwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxrRkFBaUI7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQXdCO0FBQ3RELGNBQWMsbUJBQU8sQ0FBQyxvRkFBa0I7QUFDeEMsa0JBQWtCLHFHQUE2QjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyw4R0FBK0I7QUFDbEUsd0JBQXdCLG1CQUFPLENBQUMsMEhBQXFDO0FBQ3JFLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQiwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBOEI7QUFDaEUsbUJBQW1CLG1CQUFPLENBQUMsOEZBQXVCOztBQUVsRCw0QkFBNEIsbUlBQWlEOztBQUU3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHlCQUF5QixTQUFTLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNEJBQTRCLG1CQUFtQixrQkFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsUUFBUTtBQUMvRTtBQUNBO0FBQ0EsbUZBQW1GLElBQUk7QUFDdkY7QUFDQTtBQUNBLGdGQUFnRixJQUFJO0FBQ3BGO0FBQ0E7QUFDQSx1RUFBdUUsSUFBSTtBQUMzRTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcdHlwZXNcXG1hcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1peGVkID0gcmVxdWlyZSgnLi4vc2NoZW1hL21peGVkJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBkZWVwRXF1YWwgPSByZXF1aXJlKCcuLi91dGlscycpLmRlZXBFcXVhbDtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBoYW5kbGVTcHJlYWREb2MgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvY3VtZW50L2hhbmRsZVNwcmVhZERvYycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHNwZWNpYWxQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaGVscGVycy9zcGVjaWFsUHJvcGVydGllcycpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuXG5jb25zdCBwb3B1bGF0ZU1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykucG9wdWxhdGVNb2RlbFN5bWJvbDtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jbGFzcyBNb25nb29zZU1hcCBleHRlbmRzIE1hcCB7XG4gIGNvbnN0cnVjdG9yKHYsIHBhdGgsIGRvYywgc2NoZW1hVHlwZSkge1xuICAgIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUodikgPT09ICdPYmplY3QnKSB7XG4gICAgICB2ID0gT2JqZWN0LmtleXModikucmVkdWNlKChhcnIsIGtleSkgPT4gYXJyLmNvbmNhdChbW2tleSwgdltrZXldXV0pLCBbXSk7XG4gICAgfVxuICAgIHN1cGVyKHYpO1xuICAgIHRoaXMuJF9fcGFyZW50ID0gZG9jICE9IG51bGwgJiYgZG9jLiRfXyAhPSBudWxsID8gZG9jIDogbnVsbDtcbiAgICB0aGlzLiRfX3BhdGggPSBwYXRoO1xuICAgIHRoaXMuJF9fc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGUgPT0gbnVsbCA/IG5ldyBNaXhlZChwYXRoKSA6IHNjaGVtYVR5cGU7XG5cbiAgICB0aGlzLiRfX3J1bkRlZmVycmVkKCk7XG4gIH1cblxuICAkaW5pdChrZXksIHZhbHVlKSB7XG4gICAgY2hlY2tWYWxpZEtleShrZXkpO1xuXG4gICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICB2YWx1ZS4kYmFzZVBhdGggPSB0aGlzLiRfX3BhdGggKyAnLicgKyBrZXk7XG4gICAgfVxuICB9XG5cbiAgJF9fc2V0KGtleSwgdmFsdWUpIHtcbiAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcndyaXRlcyBuYXRpdmUgTWFwJ3MgYGdldCgpYCBmdW5jdGlvbiB0byBzdXBwb3J0IE1vbmdvb3NlIGdldHRlcnMuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgZ2V0XG4gICAqIEBtZW1iZXJPZiBNYXBcbiAgICovXG5cbiAgZ2V0KGtleSwgb3B0aW9ucykge1xuICAgIGlmIChpc0Jzb25UeXBlKGtleSwgJ09iamVjdElkJykpIHtcbiAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChvcHRpb25zLmdldHRlcnMgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRfX3NjaGVtYVR5cGUuYXBwbHlHZXR0ZXJzKHN1cGVyLmdldChrZXkpLCB0aGlzLiRfX3BhcmVudCk7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcndyaXRlcyBuYXRpdmUgTWFwJ3MgYHNldCgpYCBmdW5jdGlvbiB0byBzdXBwb3J0IHNldHRlcnMsIGBwb3B1bGF0ZSgpYCxcbiAgICogYW5kIGNoYW5nZSB0cmFja2luZy4gTm90ZSB0aGF0IE1vbmdvb3NlIG1hcHMgX29ubHlfIHN1cHBvcnQgc3RyaW5ncyBhbmRcbiAgICogT2JqZWN0SWRzIGFzIGtleXMuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICpcbiAgICogICAgIGRvYy5teU1hcC5zZXQoJ3Rlc3QnLCA0Mik7IC8vIHdvcmtzXG4gICAqICAgICBkb2MubXlNYXAuc2V0KHsgb2JqOiA0MiB9LCA0Mik7IC8vIFRocm93cyBcIk1vbmdvb3NlIG1hcHMgb25seSBzdXBwb3J0IHN0cmluZyBrZXlzXCJcbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBzZXRcbiAgICogQG1lbWJlck9mIE1hcFxuICAgKi9cblxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc0Jzb25UeXBlKGtleSwgJ09iamVjdElkJykpIHtcbiAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGNoZWNrVmFsaWRLZXkoa2V5KTtcbiAgICB2YWx1ZSA9IGhhbmRsZVNwcmVhZERvYyh2YWx1ZSk7XG5cbiAgICAvLyBXZWlyZCwgYnV0IGJlY2F1c2UgeW91IGNhbid0IGFzc2lnbiB0byBgdGhpc2AgYmVmb3JlIGNhbGxpbmcgYHN1cGVyKClgXG4gICAgLy8geW91IGNhbid0IGdldCBhY2Nlc3MgdG8gYCRfX3NjaGVtYVR5cGVgIHRvIGNhc3QgaW4gdGhlIGluaXRpYWwgY2FsbCB0b1xuICAgIC8vIGBzZXQoKWAgZnJvbSB0aGUgYHN1cGVyKClgIGNvbnN0cnVjdG9yLlxuXG4gICAgaWYgKHRoaXMuJF9fc2NoZW1hVHlwZSA9PSBudWxsKSB7XG4gICAgICB0aGlzLiRfX2RlZmVycmVkID0gdGhpcy4kX19kZWZlcnJlZCB8fCBbXTtcbiAgICAgIHRoaXMuJF9fZGVmZXJyZWQucHVzaCh7IGtleToga2V5LCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IF9mdWxsUGF0aDtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLiRfX3BhcmVudDtcbiAgICBjb25zdCBwb3B1bGF0ZWQgPSBwYXJlbnQgIT0gbnVsbCAmJiBwYXJlbnQuJF9fICYmIHBhcmVudC4kX18ucG9wdWxhdGVkID9cbiAgICAgIHBhcmVudC4kcG9wdWxhdGVkKGZ1bGxQYXRoLmNhbGwodGhpcyksIHRydWUpIHx8IHBhcmVudC4kcG9wdWxhdGVkKHRoaXMuJF9fcGF0aCwgdHJ1ZSkgOlxuICAgICAgbnVsbDtcbiAgICBjb25zdCBwcmlvclZhbCA9IHRoaXMuZ2V0KGtleSk7XG5cbiAgICBpZiAocG9wdWxhdGVkICE9IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLiRfX3NjaGVtYVR5cGUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKFxuICAgICAgICAgICdDYW5ub3QgbWFudWFsbHkgcG9wdWxhdGUgc2luZ2xlIG5lc3RlZCBzdWJkb2MgdW5kZXJuZWF0aCBNYXAgJyArXG4gICAgICAgICAgYGF0IHBhdGggXCIke3RoaXMuJF9fcGF0aH1cIi4gVHJ5IHVzaW5nIGFuIGFycmF5IGluc3RlYWQgb2YgYSBNYXAuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHRoaXMuJF9fc2NoZW1hVHlwZS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHYgPT4ge1xuICAgICAgICAgIGlmICh2LiRfXyA9PSBudWxsKSB7XG4gICAgICAgICAgICB2ID0gbmV3IHBvcHVsYXRlZC5vcHRpb25zW3BvcHVsYXRlTW9kZWxTeW1ib2xdKHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEb2Vzbid0IHN1cHBvcnQgc2luZ2xlIG5lc3RlZCBcImluLXBsYWNlXCIgcG9wdWxhdGVcbiAgICAgICAgICB2LiRfXy53YXNQb3B1bGF0ZWQgPSB7IHZhbHVlOiB2Ll9pZCB9O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZS4kX18gPT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlID0gbmV3IHBvcHVsYXRlZC5vcHRpb25zW3BvcHVsYXRlTW9kZWxTeW1ib2xdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2Vzbid0IHN1cHBvcnQgc2luZ2xlIG5lc3RlZCBcImluLXBsYWNlXCIgcG9wdWxhdGVcbiAgICAgICAgdmFsdWUuJF9fLndhc1BvcHVsYXRlZCA9IHsgdmFsdWU6IHZhbHVlLl9pZCB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy4kX19zY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSB8fCB0aGlzLiRfX3NjaGVtYVR5cGUuJGlzU2luZ2xlTmVzdGVkID9cbiAgICAgICAgICB7IHBhdGg6IGZ1bGxQYXRoLmNhbGwodGhpcykgfSA6XG4gICAgICAgICAgbnVsbDtcbiAgICAgICAgdmFsdWUgPSB0aGlzLiRfX3NjaGVtYVR5cGUuYXBwbHlTZXR0ZXJzKFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHRoaXMuJF9fcGFyZW50LFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRoaXMuZ2V0KGtleSksXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuJF9fcGFyZW50ICE9IG51bGwgJiYgdGhpcy4kX19wYXJlbnQuJF9fICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLiRfX3BhcmVudC5pbnZhbGlkYXRlKGZ1bGxQYXRoLmNhbGwodGhpcyksIGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuXG4gICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC4kX18gIT0gbnVsbCAmJiAhZGVlcEVxdWFsKHZhbHVlLCBwcmlvclZhbCkpIHtcbiAgICAgIHBhcmVudC5tYXJrTW9kaWZpZWQoZnVsbFBhdGguY2FsbCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gRGVsYXkgY2FsY3VsYXRpbmcgZnVsbCBwYXRoIHVubGVzcyBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSwgYmVjYXVzZSBzdHJpbmdcbiAgICAvLyBjb25jYXRlbmF0aW9uIGlzIGEgYm90dGxlbmVjayByZTogIzEzMTcxXG4gICAgZnVuY3Rpb24gZnVsbFBhdGgoKSB7XG4gICAgICBpZiAoX2Z1bGxQYXRoKSB7XG4gICAgICAgIHJldHVybiBfZnVsbFBhdGg7XG4gICAgICB9XG4gICAgICBfZnVsbFBhdGggPSB0aGlzLiRfX3BhdGggKyAnLicgKyBrZXk7XG4gICAgICByZXR1cm4gX2Z1bGxQYXRoO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyd3JpdGVzIG5hdGl2ZSBNYXAncyBgY2xlYXIoKWAgZnVuY3Rpb24gdG8gc3VwcG9ydCBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgY2xlYXJcbiAgICogQG1lbWJlck9mIE1hcFxuICAgKi9cblxuICBjbGVhcigpIHtcbiAgICBzdXBlci5jbGVhcigpO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuJF9fcGFyZW50O1xuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgcGFyZW50Lm1hcmtNb2RpZmllZCh0aGlzLiRfX3BhdGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyd3JpdGVzIG5hdGl2ZSBNYXAncyBgZGVsZXRlKClgIGZ1bmN0aW9uIHRvIHN1cHBvcnQgY2hhbmdlIHRyYWNraW5nLlxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIGRlbGV0ZVxuICAgKiBAbWVtYmVyT2YgTWFwXG4gICAqL1xuXG4gIGRlbGV0ZShrZXkpIHtcbiAgICBpZiAoaXNCc29uVHlwZShrZXksICdPYmplY3RJZCcpKSB7XG4gICAgICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldChrZXksIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHN1cGVyLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgbWFwIHRvIGEgbmF0aXZlIEphdmFTY3JpcHQgTWFwIHNvIHRoZSBNb25nb0RCIGRyaXZlciBjYW4gc2VyaWFsaXplIGl0LlxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHRvQlNPTlxuICAgKiBAbWVtYmVyT2YgTWFwXG4gICAqL1xuXG4gIHRvQlNPTigpIHtcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzKTtcbiAgfVxuXG4gIHRvT2JqZWN0KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZsYXR0ZW5NYXBzKSB7XG4gICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgcmV0W2tleV0gPSBjbG9uZSh0aGlzLmdldChrZXkpLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcyk7XG4gIH1cblxuICAkdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnRvT2JqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBtYXAgdG8gYSBuYXRpdmUgSmF2YVNjcmlwdCBNYXAgZm9yIGBKU09OLnN0cmluZ2lmeSgpYC4gU2V0XG4gICAqIHRoZSBgZmxhdHRlbk1hcHNgIG9wdGlvbiB0byBjb252ZXJ0IHRoaXMgbWFwIHRvIGEgUE9KTyBpbnN0ZWFkLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBkb2MubXlNYXAudG9KU09OKCkgaW5zdGFuY2VvZiBNYXA7IC8vIHRydWVcbiAgICogICAgIGRvYy5teU1hcC50b0pTT04oeyBmbGF0dGVuTWFwczogdHJ1ZSB9KSBpbnN0YW5jZW9mIE1hcDsgLy8gZmFsc2VcbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCB0b0pTT05cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZsYXR0ZW5NYXBzPWZhbHNlXSBzZXQgdG8gYHRydWVgIHRvIGNvbnZlcnQgdGhlIG1hcCB0byBhIFBPSk8gcmF0aGVyIHRoYW4gYSBuYXRpdmUgSmF2YVNjcmlwdCBtYXBcbiAgICogQG1lbWJlck9mIE1hcFxuICAgKi9cblxuICB0b0pTT04ob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0dGVuTWFwcykgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZmxhdHRlbk1hcHMgOiB0cnVlKSB7XG4gICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgcmV0W2tleV0gPSBjbG9uZSh0aGlzLmdldChrZXkpLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcyk7XG4gIH1cblxuICBpbnNwZWN0KCkge1xuICAgIHJldHVybiBuZXcgTWFwKHRoaXMpO1xuICB9XG5cbiAgJF9fcnVuRGVmZXJyZWQoKSB7XG4gICAgaWYgKCF0aGlzLiRfX2RlZmVycmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXlWYWx1ZU9iamVjdCBvZiB0aGlzLiRfX2RlZmVycmVkKSB7XG4gICAgICB0aGlzLnNldChrZXlWYWx1ZU9iamVjdC5rZXksIGtleVZhbHVlT2JqZWN0LnZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLiRfX2RlZmVycmVkID0gbnVsbDtcbiAgfVxufVxuXG5pZiAodXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VNYXAucHJvdG90eXBlLCB1dGlsLmluc3BlY3QuY3VzdG9tLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IE1vbmdvb3NlTWFwLnByb3RvdHlwZS5pbnNwZWN0XG4gIH0pO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VNYXAucHJvdG90eXBlLCAnJF9fc2V0Jywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VNYXAucHJvdG90eXBlLCAnJF9fcGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VNYXAucHJvdG90eXBlLCAnJF9fcGF0aCcsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vbmdvb3NlTWFwLnByb3RvdHlwZSwgJyRfX3NjaGVtYVR5cGUnLCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufSk7XG5cbi8qKlxuICogU2V0IHRvIGB0cnVlYCBmb3IgYWxsIE1vbmdvb3NlIG1hcCBpbnN0YW5jZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5ICRpc01vbmdvb3NlTWFwXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VNYXBcbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZU1hcC5wcm90b3R5cGUsICckaXNNb25nb29zZU1hcCcsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VNYXAucHJvdG90eXBlLCAnJF9fZGVmZXJyZWRDYWxscycsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG4vKipcbiAqIFNpbmNlIG1hcHMgYXJlIHN0b3JlZCBhcyBvYmplY3RzIHVuZGVyIHRoZSBob29kLCBrZXlzIG11c3QgYmUgc3RyaW5nc1xuICogYW5kIGNhbid0IGNvbnRhaW4gYW55IGludmFsaWQgY2hhcmFjdGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tWYWxpZEtleShrZXkpIHtcbiAgY29uc3Qga2V5VHlwZSA9IHR5cGVvZiBrZXk7XG4gIGlmIChrZXlUeXBlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE1vbmdvb3NlIG1hcHMgb25seSBzdXBwb3J0IHN0cmluZyBrZXlzLCBnb3QgJHtrZXlUeXBlfWApO1xuICB9XG4gIGlmIChrZXkuc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNb25nb29zZSBtYXBzIGRvIG5vdCBzdXBwb3J0IGtleXMgdGhhdCBzdGFydCB3aXRoIFwiJFwiLCBnb3QgXCIke2tleX1cImApO1xuICB9XG4gIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTW9uZ29vc2UgbWFwcyBkbyBub3Qgc3VwcG9ydCBrZXlzIHRoYXQgY29udGFpbiBcIi5cIiwgZ290IFwiJHtrZXl9XCJgKTtcbiAgfVxuICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKGtleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1vbmdvb3NlIG1hcHMgZG8gbm90IHN1cHBvcnQgcmVzZXJ2ZWQga2V5IG5hbWUgXCIke2tleX1cImApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9uZ29vc2VNYXA7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/map.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/objectid.js":
/*!*************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/objectid.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * ObjectId type constructor\n *\n * #### Example:\n *\n *     const id = new mongoose.Types.ObjectId;\n *\n * @constructor ObjectId\n */\n\n\n\nconst ObjectId = (__webpack_require__(/*! bson */ \"(api)/../server/node_modules/bson/lib/bson.cjs\").ObjectId);\nconst objectIdSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"(api)/../server/node_modules/mongoose/lib/helpers/symbols.js\").objectIdSymbol);\n\n/**\n * Getter for convenience with populate, see gh-6115\n * @api private\n */\n\nObject.defineProperty(ObjectId.prototype, '_id', {\n  enumerable: false,\n  configurable: true,\n  get: function() {\n    return this;\n  }\n});\n\n/*!\n * Convenience `valueOf()` to allow comparing ObjectIds using double equals re: gh-7299\n */\n\nif (!ObjectId.prototype.hasOwnProperty('valueOf')) {\n  ObjectId.prototype.valueOf = function objectIdValueOf() {\n    return this.toString();\n  };\n}\n\nObjectId.prototype[objectIdSymbol] = true;\n\nmodule.exports = ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvb2JqZWN0aWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGlCQUFpQiw0RkFBd0I7QUFDekMsdUJBQXVCLDhIQUE0Qzs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHR5cGVzXFxvYmplY3RpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9iamVjdElkIHR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGlkID0gbmV3IG1vbmdvb3NlLlR5cGVzLk9iamVjdElkO1xuICpcbiAqIEBjb25zdHJ1Y3RvciBPYmplY3RJZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgT2JqZWN0SWQgPSByZXF1aXJlKCdic29uJykuT2JqZWN0SWQ7XG5jb25zdCBvYmplY3RJZFN5bWJvbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc3ltYm9scycpLm9iamVjdElkU3ltYm9sO1xuXG4vKipcbiAqIEdldHRlciBmb3IgY29udmVuaWVuY2Ugd2l0aCBwb3B1bGF0ZSwgc2VlIGdoLTYxMTVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3RJZC5wcm90b3R5cGUsICdfaWQnLCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG4vKiFcbiAqIENvbnZlbmllbmNlIGB2YWx1ZU9mKClgIHRvIGFsbG93IGNvbXBhcmluZyBPYmplY3RJZHMgdXNpbmcgZG91YmxlIGVxdWFscyByZTogZ2gtNzI5OVxuICovXG5cbmlmICghT2JqZWN0SWQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCd2YWx1ZU9mJykpIHtcbiAgT2JqZWN0SWQucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiBvYmplY3RJZFZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuT2JqZWN0SWQucHJvdG90eXBlW29iamVjdElkU3ltYm9sXSA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0SWQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/objectid.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/subdocument.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/subdocument.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Document = __webpack_require__(/*! ../document */ \"(api)/../server/node_modules/mongoose/lib/document.js\");\nconst immediate = __webpack_require__(/*! ../helpers/immediate */ \"(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../options */ \"(api)/../server/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ../utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = Subdocument;\n\n/**\n * Subdocument constructor.\n *\n * @inherits Document\n * @api private\n */\n\nfunction Subdocument(value, fields, parent, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null && options == null) {\n    options = skipId;\n    skipId = undefined;\n  }\n  if (parent != null) {\n    // If setting a nested path, should copy isNew from parent re: gh-7048\n    const parentOptions = { isNew: parent.isNew };\n    if ('defaults' in parent.$__) {\n      parentOptions.defaults = parent.$__.defaults;\n    }\n    options = Object.assign(parentOptions, options);\n  }\n  if (options != null && options.path != null) {\n    this.$basePath = options.path;\n  }\n  Document.call(this, value, fields, skipId, options);\n\n  delete this.$__.priorDoc;\n}\n\nSubdocument.prototype = Object.create(Document.prototype);\n\nObject.defineProperty(Subdocument.prototype, '$isSubdocument', {\n  configurable: false,\n  writable: false,\n  value: true\n});\n\nObject.defineProperty(Subdocument.prototype, '$isSingleNested', {\n  configurable: false,\n  writable: false,\n  value: true\n});\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Used as a stub for middleware\n *\n * #### Note:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @return {Promise} resolved Promise\n * @api private\n */\n\nSubdocument.prototype.save = async function save(options) {\n  options = options || {};\n\n  if (!options.suppressWarning) {\n    utils.warn('mongoose: calling `save()` on a subdoc does **not** save ' +\n      'the document to MongoDB, it only runs save middleware. ' +\n      'Use `subdoc.save({ suppressWarning: true })` to hide this warning ' +\n      'if you\\'re sure this behavior is right for your app.');\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__save((err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(this);\n    });\n  });\n};\n\n/**\n * Given a path relative to this document, return the path relative\n * to the top-level document.\n * @param {String} path\n * @method $__fullPath\n * @memberOf Subdocument\n * @instance\n * @returns {String}\n * @api private\n */\n\nSubdocument.prototype.$__fullPath = function(path) {\n  if (!this.$__.fullPath) {\n    this.ownerDocument();\n  }\n\n  return path ?\n    this.$__.fullPath + '.' + path :\n    this.$__.fullPath;\n};\n\n/**\n * Given a path relative to this document, return the path relative\n * to the top-level document.\n * @param {String} p\n * @returns {String}\n * @method $__pathRelativeToParent\n * @memberOf Subdocument\n * @instance\n * @api private\n */\n\nSubdocument.prototype.$__pathRelativeToParent = function(p) {\n  if (p == null) {\n    return this.$basePath;\n  }\n  return [this.$basePath, p].join('.');\n};\n\n/**\n * Used as a stub for middleware\n *\n * #### Note:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @method $__save\n * @api private\n */\n\nSubdocument.prototype.$__save = function(fn) {\n  return immediate(() => fn(null, this));\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$isValid = function(path) {\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    return parent.$isValid(fullPath);\n  }\n  return Document.prototype.$isValid.call(this, path);\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.markModified = function(path) {\n  Document.prototype.markModified.call(this, path);\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n\n  if (parent == null || fullPath == null) {\n    return;\n  }\n\n  const myPath = this.$__pathRelativeToParent().replace(/\\.$/, '');\n  if (parent.isDirectModified(myPath) || this.isNew) {\n    return;\n  }\n  this.$__parent.markModified(fullPath, this);\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.isModified = function(paths, options, modifiedPaths) {\n  const parent = this.$parent();\n  if (parent != null) {\n    if (Array.isArray(paths) || typeof paths === 'string') {\n      paths = (Array.isArray(paths) ? paths : paths.split(' '));\n      paths = paths.map(p => this.$__pathRelativeToParent(p)).filter(p => p != null);\n    } else if (!paths) {\n      paths = this.$__pathRelativeToParent();\n    }\n\n    return parent.$isModified(paths, options, modifiedPaths);\n  }\n\n  return Document.prototype.isModified.call(this, paths, options, modifiedPaths);\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api private\n * @method $markValid\n * @memberOf Subdocument\n */\n\nSubdocument.prototype.$markValid = function(path) {\n  Document.prototype.$markValid.call(this, path);\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    parent.$markValid(fullPath);\n  }\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.invalidate = function(path, err, val) {\n  Document.prototype.invalidate.call(this, path, err, val);\n\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    parent.invalidate(fullPath, err, val);\n  } else if (err.kind === 'cast' || err.name === 'CastError' || fullPath == null) {\n    throw err;\n  }\n\n  return this.ownerDocument().$__.validationError;\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$ignore = function(path) {\n  Document.prototype.$ignore.call(this, path);\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    parent.$ignore(fullPath);\n  }\n};\n\n/**\n * Returns the top level document of this sub-document.\n *\n * @return {Document}\n */\n\nSubdocument.prototype.ownerDocument = function() {\n  if (this.$__.ownerDocument) {\n    return this.$__.ownerDocument;\n  }\n\n  let parent = this; // eslint-disable-line consistent-this\n  const paths = [];\n  const seenDocs = new Set([parent]);\n\n  while (true) {\n    if (typeof parent.$__pathRelativeToParent !== 'function') {\n      break;\n    }\n    paths.unshift(parent.$__pathRelativeToParent(void 0, true));\n    const _parent = parent.$parent();\n    if (_parent == null) {\n      break;\n    }\n    parent = _parent;\n    if (seenDocs.has(parent)) {\n      throw new Error('Infinite subdocument loop: subdoc with _id ' + parent._id + ' is a parent of itself');\n    }\n\n    seenDocs.add(parent);\n  }\n\n  this.$__.fullPath = paths.join('.');\n\n  this.$__.ownerDocument = parent;\n  return this.$__.ownerDocument;\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$__fullPathWithIndexes = function() {\n  let parent = this; // eslint-disable-line consistent-this\n  const paths = [];\n  const seenDocs = new Set([parent]);\n\n  while (true) {\n    if (typeof parent.$__pathRelativeToParent !== 'function') {\n      break;\n    }\n    paths.unshift(parent.$__pathRelativeToParent(void 0, false));\n    const _parent = parent.$parent();\n    if (_parent == null) {\n      break;\n    }\n    parent = _parent;\n    if (seenDocs.has(parent)) {\n      throw new Error('Infinite subdocument loop: subdoc with _id ' + parent._id + ' is a parent of itself');\n    }\n\n    seenDocs.add(parent);\n  }\n\n  return paths.join('.');\n};\n\n/**\n * Returns this sub-documents parent document.\n *\n * @api public\n */\n\nSubdocument.prototype.parent = function() {\n  return this.$__parent;\n};\n\n/**\n * Returns this sub-documents parent document.\n *\n * @api public\n * @method $parent\n */\n\nSubdocument.prototype.$parent = Subdocument.prototype.parent;\n\n/**\n * no-op for hooks\n * @param {Function} cb\n * @method $__deleteOne\n * @memberOf Subdocument\n * @instance\n * @api private\n */\n\nSubdocument.prototype.$__deleteOne = function(cb) {\n  if (cb == null) {\n    return;\n  }\n  return cb(null, this);\n};\n\n/**\n * ignore\n * @method $__removeFromParent\n * @memberOf Subdocument\n * @instance\n * @api private\n */\n\nSubdocument.prototype.$__removeFromParent = function() {\n  this.$__parent.set(this.$basePath, null);\n};\n\n/**\n * Null-out this subdoc\n *\n * @param {Object} [options]\n * @param {Function} [callback] optional callback for compatibility with Document.prototype.remove\n */\n\nSubdocument.prototype.deleteOne = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  registerRemoveListener(this);\n\n  // If removing entire doc, no need to remove subdoc\n  if (!options || !options.noop) {\n    this.$__removeFromParent();\n  }\n\n  return this.$__deleteOne(callback);\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.populate = function() {\n  throw new Error('Mongoose does not support calling populate() on nested ' +\n    'docs. Instead of `doc.nested.populate(\"path\")`, use ' +\n    '`doc.populate(\"nested.path\")`');\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n */\n\nSubdocument.prototype.inspect = function() {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    flattenDecimals: false\n  });\n};\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Subdocument.prototype[util.inspect.custom] = Subdocument.prototype.inspect;\n}\n\n/**\n * Registers remove event listeners for triggering\n * on subdocuments.\n *\n * @param {Subdocument} sub\n * @api private\n */\n\nfunction registerRemoveListener(sub) {\n  let owner = sub.ownerDocument();\n\n  function emitRemove() {\n    owner.$removeListener('save', emitRemove);\n    owner.$removeListener('deleteOne', emitRemove);\n    sub.emit('deleteOne', sub);\n    sub.constructor.emit('deleteOne', sub);\n    owner = sub = null;\n  }\n\n  owner.$on('save', emitRemove);\n  owner.$on('deleteOne', emitRemove);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvc3ViZG9jdW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUJBQWlCLG1CQUFPLENBQUMsMEVBQWE7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsNEZBQXNCO0FBQ2hELGdDQUFnQyx1SEFBNkM7QUFDN0UsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxvRUFBVTs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHR5cGVzXFxzdWJkb2N1bWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERvY3VtZW50ID0gcmVxdWlyZSgnLi4vZG9jdW1lbnQnKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaW1tZWRpYXRlJyk7XG5jb25zdCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ViZG9jdW1lbnQ7XG5cbi8qKlxuICogU3ViZG9jdW1lbnQgY29uc3RydWN0b3IuXG4gKlxuICogQGluaGVyaXRzIERvY3VtZW50XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBTdWJkb2N1bWVudCh2YWx1ZSwgZmllbGRzLCBwYXJlbnQsIHNraXBJZCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHNraXBJZCA9PT0gJ29iamVjdCcgJiYgc2tpcElkICE9IG51bGwgJiYgb3B0aW9ucyA9PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHNraXBJZDtcbiAgICBza2lwSWQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgLy8gSWYgc2V0dGluZyBhIG5lc3RlZCBwYXRoLCBzaG91bGQgY29weSBpc05ldyBmcm9tIHBhcmVudCByZTogZ2gtNzA0OFxuICAgIGNvbnN0IHBhcmVudE9wdGlvbnMgPSB7IGlzTmV3OiBwYXJlbnQuaXNOZXcgfTtcbiAgICBpZiAoJ2RlZmF1bHRzJyBpbiBwYXJlbnQuJF9fKSB7XG4gICAgICBwYXJlbnRPcHRpb25zLmRlZmF1bHRzID0gcGFyZW50LiRfXy5kZWZhdWx0cztcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ocGFyZW50T3B0aW9ucywgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnBhdGggIT0gbnVsbCkge1xuICAgIHRoaXMuJGJhc2VQYXRoID0gb3B0aW9ucy5wYXRoO1xuICB9XG4gIERvY3VtZW50LmNhbGwodGhpcywgdmFsdWUsIGZpZWxkcywgc2tpcElkLCBvcHRpb25zKTtcblxuICBkZWxldGUgdGhpcy4kX18ucHJpb3JEb2M7XG59XG5cblN1YmRvY3VtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRG9jdW1lbnQucHJvdG90eXBlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YmRvY3VtZW50LnByb3RvdHlwZSwgJyRpc1N1YmRvY3VtZW50Jywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIHZhbHVlOiB0cnVlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YmRvY3VtZW50LnByb3RvdHlwZSwgJyRpc1NpbmdsZU5lc3RlZCcsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLnRvQlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFVzZWQgYXMgYSBzdHViIGZvciBtaWRkbGV3YXJlXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIF9UaGlzIGlzIGEgbm8tb3AuIERvZXMgbm90IGFjdHVhbGx5IHNhdmUgdGhlIGRvYyB0byB0aGUgZGIuX1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1Byb21pc2V9IHJlc29sdmVkIFByb21pc2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5zYXZlID0gYXN5bmMgZnVuY3Rpb24gc2F2ZShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmICghb3B0aW9ucy5zdXBwcmVzc1dhcm5pbmcpIHtcbiAgICB1dGlscy53YXJuKCdtb25nb29zZTogY2FsbGluZyBgc2F2ZSgpYCBvbiBhIHN1YmRvYyBkb2VzICoqbm90Kiogc2F2ZSAnICtcbiAgICAgICd0aGUgZG9jdW1lbnQgdG8gTW9uZ29EQiwgaXQgb25seSBydW5zIHNhdmUgbWlkZGxld2FyZS4gJyArXG4gICAgICAnVXNlIGBzdWJkb2Muc2F2ZSh7IHN1cHByZXNzV2FybmluZzogdHJ1ZSB9KWAgdG8gaGlkZSB0aGlzIHdhcm5pbmcgJyArXG4gICAgICAnaWYgeW91XFwncmUgc3VyZSB0aGlzIGJlaGF2aW9yIGlzIHJpZ2h0IGZvciB5b3VyIGFwcC4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy4kX19zYXZlKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHRoaXMpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBwYXRoIHJlbGF0aXZlIHRvIHRoaXMgZG9jdW1lbnQsIHJldHVybiB0aGUgcGF0aCByZWxhdGl2ZVxuICogdG8gdGhlIHRvcC1sZXZlbCBkb2N1bWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAbWV0aG9kICRfX2Z1bGxQYXRoXG4gKiBAbWVtYmVyT2YgU3ViZG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19mdWxsUGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYgKCF0aGlzLiRfXy5mdWxsUGF0aCkge1xuICAgIHRoaXMub3duZXJEb2N1bWVudCgpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGggP1xuICAgIHRoaXMuJF9fLmZ1bGxQYXRoICsgJy4nICsgcGF0aCA6XG4gICAgdGhpcy4kX18uZnVsbFBhdGg7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgcGF0aCByZWxhdGl2ZSB0byB0aGlzIGRvY3VtZW50LCByZXR1cm4gdGhlIHBhdGggcmVsYXRpdmVcbiAqIHRvIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcFxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBtZXRob2QgJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnRcbiAqIEBtZW1iZXJPZiBTdWJkb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQgPSBmdW5jdGlvbihwKSB7XG4gIGlmIChwID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy4kYmFzZVBhdGg7XG4gIH1cbiAgcmV0dXJuIFt0aGlzLiRiYXNlUGF0aCwgcF0uam9pbignLicpO1xufTtcblxuLyoqXG4gKiBVc2VkIGFzIGEgc3R1YiBmb3IgbWlkZGxld2FyZVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBfVGhpcyBpcyBhIG5vLW9wLiBEb2VzIG5vdCBhY3R1YWxseSBzYXZlIHRoZSBkb2MgdG8gdGhlIGRiLl9cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAbWV0aG9kICRfX3NhdmVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19zYXZlID0gZnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIGltbWVkaWF0ZSgoKSA9PiBmbihudWxsLCB0aGlzKSk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kaXNWYWxpZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgY29uc3QgcGFyZW50ID0gdGhpcy4kcGFyZW50KCk7XG4gIGNvbnN0IGZ1bGxQYXRoID0gdGhpcy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudChwYXRoKTtcbiAgaWYgKHBhcmVudCAhPSBudWxsICYmIGZ1bGxQYXRoICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyZW50LiRpc1ZhbGlkKGZ1bGxQYXRoKTtcbiAgfVxuICByZXR1cm4gRG9jdW1lbnQucHJvdG90eXBlLiRpc1ZhbGlkLmNhbGwodGhpcywgcGF0aCk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5tYXJrTW9kaWZpZWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIERvY3VtZW50LnByb3RvdHlwZS5tYXJrTW9kaWZpZWQuY2FsbCh0aGlzLCBwYXRoKTtcbiAgY29uc3QgcGFyZW50ID0gdGhpcy4kcGFyZW50KCk7XG4gIGNvbnN0IGZ1bGxQYXRoID0gdGhpcy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudChwYXRoKTtcblxuICBpZiAocGFyZW50ID09IG51bGwgfHwgZnVsbFBhdGggPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG15UGF0aCA9IHRoaXMuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQoKS5yZXBsYWNlKC9cXC4kLywgJycpO1xuICBpZiAocGFyZW50LmlzRGlyZWN0TW9kaWZpZWQobXlQYXRoKSB8fCB0aGlzLmlzTmV3KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuJF9fcGFyZW50Lm1hcmtNb2RpZmllZChmdWxsUGF0aCwgdGhpcyk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5pc01vZGlmaWVkID0gZnVuY3Rpb24ocGF0aHMsIG9wdGlvbnMsIG1vZGlmaWVkUGF0aHMpIHtcbiAgY29uc3QgcGFyZW50ID0gdGhpcy4kcGFyZW50KCk7XG4gIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGhzKSB8fCB0eXBlb2YgcGF0aHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXRocyA9IChBcnJheS5pc0FycmF5KHBhdGhzKSA/IHBhdGhzIDogcGF0aHMuc3BsaXQoJyAnKSk7XG4gICAgICBwYXRocyA9IHBhdGhzLm1hcChwID0+IHRoaXMuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQocCkpLmZpbHRlcihwID0+IHAgIT0gbnVsbCk7XG4gICAgfSBlbHNlIGlmICghcGF0aHMpIHtcbiAgICAgIHBhdGhzID0gdGhpcy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnQuJGlzTW9kaWZpZWQocGF0aHMsIG9wdGlvbnMsIG1vZGlmaWVkUGF0aHMpO1xuICB9XG5cbiAgcmV0dXJuIERvY3VtZW50LnByb3RvdHlwZS5pc01vZGlmaWVkLmNhbGwodGhpcywgcGF0aHMsIG9wdGlvbnMsIG1vZGlmaWVkUGF0aHMpO1xufTtcblxuLyoqXG4gKiBNYXJrcyBhIHBhdGggYXMgdmFsaWQsIHJlbW92aW5nIGV4aXN0aW5nIHZhbGlkYXRpb24gZXJyb3JzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBmaWVsZCB0byBtYXJrIGFzIHZhbGlkXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJG1hcmtWYWxpZFxuICogQG1lbWJlck9mIFN1YmRvY3VtZW50XG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRtYXJrVmFsaWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIERvY3VtZW50LnByb3RvdHlwZS4kbWFya1ZhbGlkLmNhbGwodGhpcywgcGF0aCk7XG4gIGNvbnN0IHBhcmVudCA9IHRoaXMuJHBhcmVudCgpO1xuICBjb25zdCBmdWxsUGF0aCA9IHRoaXMuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQocGF0aCk7XG4gIGlmIChwYXJlbnQgIT0gbnVsbCAmJiBmdWxsUGF0aCAhPSBudWxsKSB7XG4gICAgcGFyZW50LiRtYXJrVmFsaWQoZnVsbFBhdGgpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24ocGF0aCwgZXJyLCB2YWwpIHtcbiAgRG9jdW1lbnQucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzLCBwYXRoLCBlcnIsIHZhbCk7XG5cbiAgY29uc3QgcGFyZW50ID0gdGhpcy4kcGFyZW50KCk7XG4gIGNvbnN0IGZ1bGxQYXRoID0gdGhpcy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudChwYXRoKTtcbiAgaWYgKHBhcmVudCAhPSBudWxsICYmIGZ1bGxQYXRoICE9IG51bGwpIHtcbiAgICBwYXJlbnQuaW52YWxpZGF0ZShmdWxsUGF0aCwgZXJyLCB2YWwpO1xuICB9IGVsc2UgaWYgKGVyci5raW5kID09PSAnY2FzdCcgfHwgZXJyLm5hbWUgPT09ICdDYXN0RXJyb3InIHx8IGZ1bGxQYXRoID09IG51bGwpIHtcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50KCkuJF9fLnZhbGlkYXRpb25FcnJvcjtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRpZ25vcmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIERvY3VtZW50LnByb3RvdHlwZS4kaWdub3JlLmNhbGwodGhpcywgcGF0aCk7XG4gIGNvbnN0IHBhcmVudCA9IHRoaXMuJHBhcmVudCgpO1xuICBjb25zdCBmdWxsUGF0aCA9IHRoaXMuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQocGF0aCk7XG4gIGlmIChwYXJlbnQgIT0gbnVsbCAmJiBmdWxsUGF0aCAhPSBudWxsKSB7XG4gICAgcGFyZW50LiRpZ25vcmUoZnVsbFBhdGgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHRvcCBsZXZlbCBkb2N1bWVudCBvZiB0aGlzIHN1Yi1kb2N1bWVudC5cbiAqXG4gKiBAcmV0dXJuIHtEb2N1bWVudH1cbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUub3duZXJEb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy4kX18ub3duZXJEb2N1bWVudCkge1xuICAgIHJldHVybiB0aGlzLiRfXy5vd25lckRvY3VtZW50O1xuICB9XG5cbiAgbGV0IHBhcmVudCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gIGNvbnN0IHBhdGhzID0gW107XG4gIGNvbnN0IHNlZW5Eb2NzID0gbmV3IFNldChbcGFyZW50XSk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHBhcmVudC4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhzLnVuc2hpZnQocGFyZW50LiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KHZvaWQgMCwgdHJ1ZSkpO1xuICAgIGNvbnN0IF9wYXJlbnQgPSBwYXJlbnQuJHBhcmVudCgpO1xuICAgIGlmIChfcGFyZW50ID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXJlbnQgPSBfcGFyZW50O1xuICAgIGlmIChzZWVuRG9jcy5oYXMocGFyZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBzdWJkb2N1bWVudCBsb29wOiBzdWJkb2Mgd2l0aCBfaWQgJyArIHBhcmVudC5faWQgKyAnIGlzIGEgcGFyZW50IG9mIGl0c2VsZicpO1xuICAgIH1cblxuICAgIHNlZW5Eb2NzLmFkZChwYXJlbnQpO1xuICB9XG5cbiAgdGhpcy4kX18uZnVsbFBhdGggPSBwYXRocy5qb2luKCcuJyk7XG5cbiAgdGhpcy4kX18ub3duZXJEb2N1bWVudCA9IHBhcmVudDtcbiAgcmV0dXJuIHRoaXMuJF9fLm93bmVyRG9jdW1lbnQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19mdWxsUGF0aFdpdGhJbmRleGVzID0gZnVuY3Rpb24oKSB7XG4gIGxldCBwYXJlbnQgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuICBjb25zdCBwYXRocyA9IFtdO1xuICBjb25zdCBzZWVuRG9jcyA9IG5ldyBTZXQoW3BhcmVudF0pO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJlbnQuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRocy51bnNoaWZ0KHBhcmVudC4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCh2b2lkIDAsIGZhbHNlKSk7XG4gICAgY29uc3QgX3BhcmVudCA9IHBhcmVudC4kcGFyZW50KCk7XG4gICAgaWYgKF9wYXJlbnQgPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhcmVudCA9IF9wYXJlbnQ7XG4gICAgaWYgKHNlZW5Eb2NzLmhhcyhwYXJlbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIHN1YmRvY3VtZW50IGxvb3A6IHN1YmRvYyB3aXRoIF9pZCAnICsgcGFyZW50Ll9pZCArICcgaXMgYSBwYXJlbnQgb2YgaXRzZWxmJyk7XG4gICAgfVxuXG4gICAgc2VlbkRvY3MuYWRkKHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gcGF0aHMuam9pbignLicpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgc3ViLWRvY3VtZW50cyBwYXJlbnQgZG9jdW1lbnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLiRfX3BhcmVudDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIHN1Yi1kb2N1bWVudHMgcGFyZW50IGRvY3VtZW50LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kICRwYXJlbnRcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuJHBhcmVudCA9IFN1YmRvY3VtZW50LnByb3RvdHlwZS5wYXJlbnQ7XG5cbi8qKlxuICogbm8tb3AgZm9yIGhvb2tzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQG1ldGhvZCAkX19kZWxldGVPbmVcbiAqIEBtZW1iZXJPZiBTdWJkb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuJF9fZGVsZXRlT25lID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKGNiID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIGNiKG51bGwsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBpZ25vcmVcbiAqIEBtZXRob2QgJF9fcmVtb3ZlRnJvbVBhcmVudFxuICogQG1lbWJlck9mIFN1YmRvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19yZW1vdmVGcm9tUGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuJF9fcGFyZW50LnNldCh0aGlzLiRiYXNlUGF0aCwgbnVsbCk7XG59O1xuXG4vKipcbiAqIE51bGwtb3V0IHRoaXMgc3ViZG9jXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBvcHRpb25hbCBjYWxsYmFjayBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIERvY3VtZW50LnByb3RvdHlwZS5yZW1vdmVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuZGVsZXRlT25lID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyUmVtb3ZlTGlzdGVuZXIodGhpcyk7XG5cbiAgLy8gSWYgcmVtb3ZpbmcgZW50aXJlIGRvYywgbm8gbmVlZCB0byByZW1vdmUgc3ViZG9jXG4gIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5ub29wKSB7XG4gICAgdGhpcy4kX19yZW1vdmVGcm9tUGFyZW50KCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy4kX19kZWxldGVPbmUoY2FsbGJhY2spO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUucG9wdWxhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdNb25nb29zZSBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmcgcG9wdWxhdGUoKSBvbiBuZXN0ZWQgJyArXG4gICAgJ2RvY3MuIEluc3RlYWQgb2YgYGRvYy5uZXN0ZWQucG9wdWxhdGUoXCJwYXRoXCIpYCwgdXNlICcgK1xuICAgICdgZG9jLnBvcHVsYXRlKFwibmVzdGVkLnBhdGhcIilgJyk7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgY29uc29sZS5sb2dcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvT2JqZWN0KHtcbiAgICB0cmFuc2Zvcm06IGZhbHNlLFxuICAgIHZpcnR1YWxzOiBmYWxzZSxcbiAgICBmbGF0dGVuRGVjaW1hbHM6IGZhbHNlXG4gIH0pO1xufTtcblxuaWYgKHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgLy8gQXZvaWQgTm9kZSBkZXByZWNhdGlvbiB3YXJuaW5nIERFUDAwNzlcbiAgU3ViZG9jdW1lbnQucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gU3ViZG9jdW1lbnQucHJvdG90eXBlLmluc3BlY3Q7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZm9yIHRyaWdnZXJpbmdcbiAqIG9uIHN1YmRvY3VtZW50cy5cbiAqXG4gKiBAcGFyYW0ge1N1YmRvY3VtZW50fSBzdWJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVtb3ZlTGlzdGVuZXIoc3ViKSB7XG4gIGxldCBvd25lciA9IHN1Yi5vd25lckRvY3VtZW50KCk7XG5cbiAgZnVuY3Rpb24gZW1pdFJlbW92ZSgpIHtcbiAgICBvd25lci4kcmVtb3ZlTGlzdGVuZXIoJ3NhdmUnLCBlbWl0UmVtb3ZlKTtcbiAgICBvd25lci4kcmVtb3ZlTGlzdGVuZXIoJ2RlbGV0ZU9uZScsIGVtaXRSZW1vdmUpO1xuICAgIHN1Yi5lbWl0KCdkZWxldGVPbmUnLCBzdWIpO1xuICAgIHN1Yi5jb25zdHJ1Y3Rvci5lbWl0KCdkZWxldGVPbmUnLCBzdWIpO1xuICAgIG93bmVyID0gc3ViID0gbnVsbDtcbiAgfVxuXG4gIG93bmVyLiRvbignc2F2ZScsIGVtaXRSZW1vdmUpO1xuICBvd25lci4kb24oJ2RlbGV0ZU9uZScsIGVtaXRSZW1vdmUpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/subdocument.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/types/uuid.js":
/*!*********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/types/uuid.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * UUID type constructor\n *\n * #### Example:\n *\n *     const id = new mongoose.Types.UUID();\n *\n * @constructor UUID\n */\n\n\n\nmodule.exports = __webpack_require__(/*! bson */ \"(api)/../server/node_modules/bson/lib/bson.cjs\").UUID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvdXVpZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsdUdBQXFDIiwic291cmNlcyI6WyJEOlxcc2Fsb25pXFxhcHByYWlzYWwtc3lzdGVtXFxzZXJ2ZXJcXG5vZGVfbW9kdWxlc1xcbW9uZ29vc2VcXGxpYlxcdHlwZXNcXHV1aWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVVUlEIHR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGlkID0gbmV3IG1vbmdvb3NlLlR5cGVzLlVVSUQoKTtcbiAqXG4gKiBAY29uc3RydWN0b3IgVVVJRFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdic29uJykuVVVJRDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/types/uuid.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/utils.js":
/*!****************************************************!*\
  !*** ../server/node_modules/mongoose/lib/utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst UUID = (__webpack_require__(/*! bson */ \"(api)/../server/node_modules/bson/lib/bson.cjs\").UUID);\nconst ms = __webpack_require__(/*! ms */ \"(api)/../server/node_modules/mongoose/node_modules/ms/index.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(api)/../server/node_modules/mpath/index.js\");\nconst ObjectId = __webpack_require__(/*! ./types/objectid */ \"(api)/../server/node_modules/mongoose/lib/types/objectid.js\");\nconst PopulateOptions = __webpack_require__(/*! ./options/PopulateOptions */ \"(api)/../server/node_modules/mongoose/lib/options/PopulateOptions.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(api)/../server/node_modules/mongoose/lib/helpers/clone.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(api)/../server/node_modules/mongoose/lib/helpers/immediate.js\");\nconst isObject = __webpack_require__(/*! ./helpers/isObject */ \"(api)/../server/node_modules/mongoose/lib/helpers/isObject.js\");\nconst isMongooseArray = __webpack_require__(/*! ./types/array/isMongooseArray */ \"(api)/../server/node_modules/mongoose/lib/types/array/isMongooseArray.js\");\nconst isMongooseDocumentArray = __webpack_require__(/*! ./types/DocumentArray/isMongooseDocumentArray */ \"(api)/../server/node_modules/mongoose/lib/types/DocumentArray/isMongooseDocumentArray.js\");\nconst isBsonType = __webpack_require__(/*! ./helpers/isBsonType */ \"(api)/../server/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst getFunctionName = __webpack_require__(/*! ./helpers/getFunctionName */ \"(api)/../server/node_modules/mongoose/lib/helpers/getFunctionName.js\");\nconst isMongooseObject = __webpack_require__(/*! ./helpers/isMongooseObject */ \"(api)/../server/node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst promiseOrCallback = __webpack_require__(/*! ./helpers/promiseOrCallback */ \"(api)/../server/node_modules/mongoose/lib/helpers/promiseOrCallback.js\");\nconst schemaMerge = __webpack_require__(/*! ./helpers/schema/merge */ \"(api)/../server/node_modules/mongoose/lib/helpers/schema/merge.js\");\nconst specialProperties = __webpack_require__(/*! ./helpers/specialProperties */ \"(api)/../server/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst { trustedSymbol } = __webpack_require__(/*! ./helpers/query/trusted */ \"(api)/../server/node_modules/mongoose/lib/helpers/query/trusted.js\");\n\nlet Document;\n\nexports.specialProperties = specialProperties;\n\nexports.isMongooseArray = isMongooseArray.isMongooseArray;\nexports.isMongooseDocumentArray = isMongooseDocumentArray.isMongooseDocumentArray;\nexports.registerMongooseArray = isMongooseArray.registerMongooseArray;\nexports.registerMongooseDocumentArray = isMongooseDocumentArray.registerMongooseDocumentArray;\n\nconst oneSpaceRE = /\\s/;\nconst manySpaceRE = /\\s+/;\n\n/**\n * Produces a collection name from model `name`. By default, just returns\n * the model name\n *\n * @param {String} name a model name\n * @param {Function} pluralize function that pluralizes the collection name\n * @return {String} a collection name\n * @api private\n */\n\nexports.toCollectionName = function(name, pluralize) {\n  if (name === 'system.profile') {\n    return name;\n  }\n  if (name === 'system.indexes') {\n    return name;\n  }\n  if (typeof pluralize === 'function') {\n    return pluralize(name);\n  }\n  return name;\n};\n\n/**\n * Determines if `a` and `b` are deep equal.\n *\n * Modified from node/lib/assert.js\n *\n * @param {any} a a value to compare to `b`\n * @param {any} b a value to compare to `a`\n * @return {Boolean}\n * @api private\n */\n\nexports.deepEqual = function deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== 'object' || typeof b !== 'object') {\n    return a === b;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n\n  if ((isBsonType(a, 'ObjectId') && isBsonType(b, 'ObjectId')) ||\n      (isBsonType(a, 'Decimal128') && isBsonType(b, 'Decimal128'))) {\n    return a.toString() === b.toString();\n  }\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source &&\n        a.ignoreCase === b.ignoreCase &&\n        a.multiline === b.multiline &&\n        a.global === b.global &&\n        a.dotAll === b.dotAll &&\n        a.unicode === b.unicode &&\n        a.sticky === b.sticky &&\n        a.hasIndices === b.hasIndices;\n  }\n\n  if (a == null || b == null) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  if (a instanceof Map || b instanceof Map) {\n    if (!(a instanceof Map) || !(b instanceof Map)) {\n      return false;\n    }\n    return deepEqual(Array.from(a.keys()), Array.from(b.keys())) &&\n      deepEqual(Array.from(a.values()), Array.from(b.values()));\n  }\n\n  // Handle MongooseNumbers\n  if (a instanceof Number && b instanceof Number) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (Buffer.isBuffer(a)) {\n    return exports.buffer.areEqual(a, b);\n  }\n\n  if (Array.isArray(a) || Array.isArray(b)) {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n      return false;\n    }\n    const len = a.length;\n    if (len !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < len; ++i) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (a.$__ != null) {\n    a = a._doc;\n  } else if (isMongooseObject(a)) {\n    a = a.toObject();\n  }\n\n  if (b.$__ != null) {\n    b = b._doc;\n  } else if (isMongooseObject(b)) {\n    b = b.toObject();\n  }\n\n  const ka = Object.keys(a);\n  const kb = Object.keys(b);\n  const kaLength = ka.length;\n\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (kaLength !== kb.length) {\n    return false;\n  }\n\n  // ~~~cheap key test\n  for (let i = kaLength - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i]) {\n      return false;\n    }\n  }\n\n  // equivalent values for every corresponding key, and\n  // ~~~possibly expensive deep test\n  for (const key of ka) {\n    if (!deepEqual(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Get the last element of an array\n * @param {Array} arr\n */\n\nexports.last = function(arr) {\n  if (arr.length > 0) {\n    return arr[arr.length - 1];\n  }\n  return void 0;\n};\n\n/*!\n * ignore\n */\n\nexports.promiseOrCallback = promiseOrCallback;\n\n/*!\n * ignore\n */\n\nexports.cloneArrays = function cloneArrays(arr) {\n  if (!Array.isArray(arr)) {\n    return arr;\n  }\n\n  return arr.map(el => exports.cloneArrays(el));\n};\n\n/*!\n * ignore\n */\n\nexports.omit = function omit(obj, keys) {\n  if (keys == null) {\n    return Object.assign({}, obj);\n  }\n  if (!Array.isArray(keys)) {\n    keys = [keys];\n  }\n\n  const ret = Object.assign({}, obj);\n  for (const key of keys) {\n    delete ret[key];\n  }\n  return ret;\n};\n\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @param {Object} [options]\n * @param {String} [path]\n * @api private\n */\n\nexports.merge = function merge(to, from, options, path) {\n  options = options || {};\n\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n\n  if (from[trustedSymbol]) {\n    to[trustedSymbol] = from[trustedSymbol];\n  }\n\n  path = path || '';\n  const omitNested = options.omitNested || {};\n\n  while (i < len) {\n    key = keys[i++];\n    if (options.omit && options.omit[key]) {\n      continue;\n    }\n    if (omitNested[path]) {\n      continue;\n    }\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (exports.isObject(from[key])) {\n      if (!exports.isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null) {\n        // Skip merging schemas if we're creating a discriminator schema and\n        // base schema has a given path as a single nested but discriminator schema\n        // has the path as a document array, or vice versa (gh-9534)\n        if (options.isDiscriminatorSchemaMerge &&\n            (from[key].$isSingleNested && to[key].$isMongooseDocumentArray) ||\n            (from[key].$isMongooseDocumentArray && to[key].$isSingleNested)) {\n          continue;\n        } else if (from[key].instanceOfSchema) {\n          if (to[key].instanceOfSchema) {\n            schemaMerge(to[key], from[key].clone(), options.isDiscriminatorSchemaMerge);\n          } else {\n            to[key] = from[key].clone();\n          }\n          continue;\n        } else if (isBsonType(from[key], 'ObjectId')) {\n          to[key] = new ObjectId(from[key]);\n          continue;\n        }\n      }\n      merge(to[key], from[key], options, path ? path + '.' + key : key);\n    } else if (options.overwrite) {\n      to[key] = from[key];\n    }\n  }\n\n  return to;\n};\n\n/**\n * Applies toObject recursively.\n *\n * @param {Document|Array|Object} obj\n * @return {Object}\n * @api private\n */\n\nexports.toObject = function toObject(obj) {\n  Document || (Document = __webpack_require__(/*! ./document */ \"(api)/../server/node_modules/mongoose/lib/document.js\"));\n  let ret;\n\n  if (obj == null) {\n    return obj;\n  }\n\n  if (obj instanceof Document) {\n    return obj.toObject();\n  }\n\n  if (Array.isArray(obj)) {\n    ret = [];\n\n    for (const doc of obj) {\n      ret.push(toObject(doc));\n    }\n\n    return ret;\n  }\n\n  if (exports.isPOJO(obj)) {\n    ret = {};\n\n    if (obj[trustedSymbol]) {\n      ret[trustedSymbol] = obj[trustedSymbol];\n    }\n\n    for (const k of Object.keys(obj)) {\n      if (specialProperties.has(k)) {\n        continue;\n      }\n      ret[k] = toObject(obj[k]);\n    }\n\n    return ret;\n  }\n\n  return obj;\n};\n\nexports.isObject = isObject;\n\n/**\n * Determines if `arg` is a plain old JavaScript object (POJO). Specifically,\n * `arg` must be an object but not an instance of any special class, like String,\n * ObjectId, etc.\n *\n * `Object.getPrototypeOf()` is part of ES5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nexports.isPOJO = __webpack_require__(/*! ./helpers/isPOJO */ \"(api)/../server/node_modules/mongoose/lib/helpers/isPOJO.js\");\n\n/**\n * Determines if `arg` is an object that isn't an instance of a built-in value\n * class, like Array, Buffer, ObjectId, etc.\n * @param {Any} val\n */\n\nexports.isNonBuiltinObject = function isNonBuiltinObject(val) {\n  return typeof val === 'object' &&\n    !exports.isNativeObject(val) &&\n    !exports.isMongooseType(val) &&\n    !(val instanceof UUID) &&\n    val != null;\n};\n\n/**\n * Determines if `obj` is a built-in object like an array, date, boolean,\n * etc.\n * @param {Any} arg\n */\n\nexports.isNativeObject = function(arg) {\n  return Array.isArray(arg) ||\n    arg instanceof Date ||\n    arg instanceof Boolean ||\n    arg instanceof Number ||\n    arg instanceof String;\n};\n\n/**\n * Determines if `val` is an object that has no own keys\n * @param {Any} val\n */\n\nexports.isEmptyObject = function(val) {\n  return val != null &&\n    typeof val === 'object' &&\n    Object.keys(val).length === 0;\n};\n\n/**\n * Search if `obj` or any POJOs nested underneath `obj` has a property named\n * `key`\n * @param {Object} obj\n * @param {String} key\n */\n\nexports.hasKey = function hasKey(obj, key) {\n  const props = Object.keys(obj);\n  for (const prop of props) {\n    if (prop === key) {\n      return true;\n    }\n    if (exports.isPOJO(obj[prop]) && exports.hasKey(obj[prop], key)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * process.nextTick helper.\n *\n * Wraps `callback` in a try/catch + nextTick.\n *\n * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.\n *\n * @param {Function} callback\n * @api private\n */\n\nexports.tick = function tick(callback) {\n  if (typeof callback !== 'function') {\n    return;\n  }\n  return function() {\n    try {\n      callback.apply(this, arguments);\n    } catch (err) {\n      // only nextTick on err to get out of\n      // the event loop and avoid state corruption.\n      immediate(function() {\n        throw err;\n      });\n    }\n  };\n};\n\n/**\n * Returns true if `v` is an object that can be serialized as a primitive in\n * MongoDB\n * @param {Any} v\n */\n\nexports.isMongooseType = function(v) {\n  return isBsonType(v, 'ObjectId') || isBsonType(v, 'Decimal128') || v instanceof Buffer;\n};\n\nexports.isMongooseObject = isMongooseObject;\n\n/**\n * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.\n *\n * @param {Object} object\n * @api private\n */\n\nexports.expires = function expires(object) {\n  if (!(object && object.constructor.name === 'Object')) {\n    return;\n  }\n  if (!('expires' in object)) {\n    return;\n  }\n\n  object.expireAfterSeconds = (typeof object.expires !== 'string')\n    ? object.expires\n    : Math.round(ms(object.expires) / 1000);\n  delete object.expires;\n};\n\n/**\n * populate helper\n * @param {String} path\n * @param {String} select\n * @param {Model} model\n * @param {Object} match\n * @param {Object} options\n * @param {Any} subPopulate\n * @param {Boolean} justOne\n * @param {Boolean} count\n */\n\nexports.populate = function populate(path, select, model, match, options, subPopulate, justOne, count) {\n  // might have passed an object specifying all arguments\n  let obj = null;\n  if (arguments.length === 1) {\n    if (path instanceof PopulateOptions) {\n      // If reusing old populate docs, avoid reusing `_docs` because that may\n      // lead to bugs and memory leaks. See gh-11641\n      path._docs = [];\n      path._childDocs = [];\n      return [path];\n    }\n\n    if (Array.isArray(path)) {\n      const singles = makeSingles(path);\n      return singles.map(o => exports.populate(o)[0]);\n    }\n\n    if (exports.isObject(path)) {\n      obj = Object.assign({}, path);\n    } else {\n      obj = { path: path };\n    }\n  } else if (typeof model === 'object') {\n    obj = {\n      path: path,\n      select: select,\n      match: model,\n      options: match\n    };\n  } else {\n    obj = {\n      path: path,\n      select: select,\n      model: model,\n      match: match,\n      options: options,\n      populate: subPopulate,\n      justOne: justOne,\n      count: count\n    };\n  }\n\n  if (typeof obj.path !== 'string') {\n    throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');\n  }\n\n  return _populateObj(obj);\n\n  // The order of select/conditions args is opposite Model.find but\n  // necessary to keep backward compatibility (select could be\n  // an array, string, or object literal).\n  function makeSingles(arr) {\n    const ret = [];\n    arr.forEach(function(obj) {\n      if (oneSpaceRE.test(obj.path)) {\n        const paths = obj.path.split(manySpaceRE);\n        paths.forEach(function(p) {\n          const copy = Object.assign({}, obj);\n          copy.path = p;\n          ret.push(copy);\n        });\n      } else {\n        ret.push(obj);\n      }\n    });\n\n    return ret;\n  }\n};\n\nfunction _populateObj(obj) {\n  if (Array.isArray(obj.populate)) {\n    const ret = [];\n    obj.populate.forEach(function(obj) {\n      if (oneSpaceRE.test(obj.path)) {\n        const copy = Object.assign({}, obj);\n        const paths = copy.path.split(manySpaceRE);\n        paths.forEach(function(p) {\n          copy.path = p;\n          ret.push(exports.populate(copy)[0]);\n        });\n      } else {\n        ret.push(exports.populate(obj)[0]);\n      }\n    });\n    obj.populate = exports.populate(ret);\n  } else if (obj.populate != null && typeof obj.populate === 'object') {\n    obj.populate = exports.populate(obj.populate);\n  }\n\n  const ret = [];\n  const paths = oneSpaceRE.test(obj.path) ? obj.path.split(manySpaceRE) : [obj.path];\n  if (obj.options != null) {\n    obj.options = clone(obj.options);\n  }\n\n  for (const path of paths) {\n    ret.push(new PopulateOptions(Object.assign({}, obj, { path: path })));\n  }\n\n  return ret;\n}\n\n/**\n * Return the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Object} obj\n * @param {Any} map\n */\n\nexports.getValue = function(path, obj, map) {\n  return mpath.get(path, obj, getValueLookup, map);\n};\n\n/*!\n * ignore\n */\n\nconst mapGetterOptions = Object.freeze({ getters: false });\n\nfunction getValueLookup(obj, part) {\n  let _from = obj?._doc || obj;\n  if (_from != null && _from.isMongooseArrayProxy) {\n    _from = _from.__array;\n  }\n  return _from instanceof Map ?\n    _from.get(part, mapGetterOptions) :\n    _from[part];\n}\n\n/**\n * Sets the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Anything} val\n * @param {Object} obj\n * @param {Any} map\n * @param {Any} _copying\n */\n\nexports.setValue = function(path, val, obj, map, _copying) {\n  mpath.set(path, val, obj, '_doc', map, _copying);\n};\n\n/**\n * Returns an array of values from object `o`.\n *\n * @param {Object} o\n * @return {Array}\n * @api private\n */\n\nexports.object = {};\nexports.object.vals = function vals(o) {\n  const keys = Object.keys(o);\n  let i = keys.length;\n  const ret = [];\n\n  while (i--) {\n    ret.push(o[keys[i]]);\n  }\n\n  return ret;\n};\n\nconst hop = Object.prototype.hasOwnProperty;\n\n/**\n * Safer helper for hasOwnProperty checks\n *\n * @param {Object} obj\n * @param {String} prop\n */\n\nexports.object.hasOwnProperty = function(obj, prop) {\n  return hop.call(obj, prop);\n};\n\n/**\n * Determine if `val` is null or undefined\n *\n * @param {Any} val\n * @return {Boolean}\n */\n\nexports.isNullOrUndefined = function(val) {\n  return val === null || val === undefined;\n};\n\n/*!\n * ignore\n */\n\nexports.array = {};\n\n/**\n * Flattens an array.\n *\n * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]\n *\n * @param {Array} arr\n * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsy value, the item will not be included in the results.\n * @param {Array} ret\n * @return {Array}\n * @api private\n */\n\nexports.array.flatten = function flatten(arr, filter, ret) {\n  ret || (ret = []);\n\n  arr.forEach(function(item) {\n    if (Array.isArray(item)) {\n      flatten(item, filter, ret);\n    } else {\n      if (!filter || filter(item)) {\n        ret.push(item);\n      }\n    }\n  });\n\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexports.hasUserDefinedProperty = function(obj, key) {\n  if (obj == null) {\n    return false;\n  }\n\n  if (Array.isArray(key)) {\n    for (const k of key) {\n      if (exports.hasUserDefinedProperty(obj, k)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if (_hasOwnProperty.call(obj, key)) {\n    return true;\n  }\n  if (typeof obj === 'object' && key in obj) {\n    const v = obj[key];\n    return v !== Object.prototype[key] && v !== Array.prototype[key];\n  }\n\n  return false;\n};\n\n/*!\n * ignore\n */\n\nconst MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;\n\nexports.isArrayIndex = function(val) {\n  if (typeof val === 'number') {\n    return val >= 0 && val <= MAX_ARRAY_INDEX;\n  }\n  if (typeof val === 'string') {\n    if (!/^\\d+$/.test(val)) {\n      return false;\n    }\n    val = +val;\n    return val >= 0 && val <= MAX_ARRAY_INDEX;\n  }\n\n  return false;\n};\n\n/**\n * Removes duplicate values from an array\n *\n * [1, 2, 3, 3, 5] => [1, 2, 3, 5]\n * [ ObjectId(\"550988ba0c19d57f697dc45e\"), ObjectId(\"550988ba0c19d57f697dc45e\") ]\n *    => [ObjectId(\"550988ba0c19d57f697dc45e\")]\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.array.unique = function(arr) {\n  const primitives = new Set();\n  const ids = new Set();\n  const ret = [];\n\n  for (const item of arr) {\n    if (typeof item === 'number' || typeof item === 'string' || item == null) {\n      if (primitives.has(item)) {\n        continue;\n      }\n      ret.push(item);\n      primitives.add(item);\n    } else if (isBsonType(item, 'ObjectId')) {\n      if (ids.has(item.toString())) {\n        continue;\n      }\n      ret.push(item);\n      ids.add(item.toString());\n    } else {\n      ret.push(item);\n    }\n  }\n\n  return ret;\n};\n\nexports.buffer = {};\n\n/**\n * Determines if two buffers are equal.\n *\n * @param {Buffer} a\n * @param {Object} b\n */\n\nexports.buffer.areEqual = function(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    return false;\n  }\n  if (!Buffer.isBuffer(b)) {\n    return false;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0, len = a.length; i < len; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexports.getFunctionName = getFunctionName;\n\n/**\n * Decorate buffers\n * @param {Object} destination\n * @param {Object} source\n */\n\nexports.decorate = function(destination, source) {\n  for (const key in source) {\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    destination[key] = source[key];\n  }\n};\n\n/**\n * merges to with a copy of from\n *\n * @param {Object} to\n * @param {Object} fromObj\n * @api private\n */\n\nexports.mergeClone = function(to, fromObj) {\n  if (isMongooseObject(fromObj)) {\n    fromObj = fromObj.toObject({\n      transform: false,\n      virtuals: false,\n      depopulate: true,\n      getters: false,\n      flattenDecimals: false\n    });\n  }\n  const keys = Object.keys(fromObj);\n  const len = keys.length;\n  let i = 0;\n  let key;\n\n  while (i < len) {\n    key = keys[i++];\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (typeof to[key] === 'undefined') {\n      to[key] = clone(fromObj[key], {\n        transform: false,\n        virtuals: false,\n        depopulate: true,\n        getters: false,\n        flattenDecimals: false\n      });\n    } else {\n      let val = fromObj[key];\n      if (val != null && val.valueOf && !(val instanceof Date)) {\n        val = val.valueOf();\n      }\n      if (exports.isObject(val)) {\n        let obj = val;\n        if (isMongooseObject(val) && !val.isMongooseBuffer) {\n          obj = obj.toObject({\n            transform: false,\n            virtuals: false,\n            depopulate: true,\n            getters: false,\n            flattenDecimals: false\n          });\n        }\n        if (val.isMongooseBuffer) {\n          obj = Buffer.from(obj);\n        }\n        exports.mergeClone(to[key], obj);\n      } else {\n        to[key] = clone(val, {\n          flattenDecimals: false\n        });\n      }\n    }\n  }\n};\n\n/**\n * Executes a function on each element of an array (like _.each)\n *\n * @param {Array} arr\n * @param {Function} fn\n * @api private\n */\n\nexports.each = function(arr, fn) {\n  for (const item of arr) {\n    fn(item);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.getOption = function(name) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n\n  for (const source of sources) {\n    if (source == null) {\n      continue;\n    }\n    if (source[name] != null) {\n      return source[name];\n    }\n  }\n\n  return null;\n};\n\n/*!\n * ignore\n */\n\nexports.noop = function() {};\n\nexports.errorToPOJO = function errorToPOJO(error) {\n  const isError = error instanceof Error;\n  if (!isError) {\n    throw new Error('`error` must be `instanceof Error`.');\n  }\n\n  const ret = {};\n  for (const properyName of Object.getOwnPropertyNames(error)) {\n    ret[properyName] = error[properyName];\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nexports.warn = function warn(message) {\n  return process.emitWarning(message, { code: 'MONGOOSE' });\n};\n\n\nexports.injectTimestampsOption = function injectTimestampsOption(writeOperation, timestampsOption) {\n  if (timestampsOption == null) {\n    return;\n  }\n  writeOperation.timestamps = timestampsOption;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGFBQWEsd0ZBQW9CO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQywwRUFBSTtBQUN2QixjQUFjLG1CQUFPLENBQUMsMERBQU87QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMscUZBQWtCO0FBQzNDLHdCQUF3QixtQkFBTyxDQUFDLHVHQUEyQjtBQUMzRCxjQUFjLG1CQUFPLENBQUMsbUZBQWlCO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLDJGQUFxQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBb0I7QUFDN0Msd0JBQXdCLG1CQUFPLENBQUMsK0dBQStCO0FBQy9ELGdDQUFnQyxtQkFBTyxDQUFDLCtJQUErQztBQUN2RixtQkFBbUIsbUJBQU8sQ0FBQyw2RkFBc0I7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsdUdBQTJCO0FBQzNELHlCQUF5QixtQkFBTyxDQUFDLHlHQUE0QjtBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQywyR0FBNkI7QUFDL0Qsb0JBQW9CLG1CQUFPLENBQUMsaUdBQXdCO0FBQ3BELDBCQUEwQixtQkFBTyxDQUFDLDJHQUE2QjtBQUMvRCxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsbUdBQXlCOztBQUUzRDs7QUFFQSx5QkFBeUI7O0FBRXpCLHVCQUF1QjtBQUN2QiwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNo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QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1osd0NBQXdDLGtCQUFrQjtBQUMxRDs7O0FBR0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbGliXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBVVUlEID0gcmVxdWlyZSgnYnNvbicpLlVVSUQ7XG5jb25zdCBtcyA9IHJlcXVpcmUoJ21zJyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5jb25zdCBPYmplY3RJZCA9IHJlcXVpcmUoJy4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IFBvcHVsYXRlT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9ucy9Qb3B1bGF0ZU9wdGlvbnMnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBpbW1lZGlhdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaW1tZWRpYXRlJyk7XG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc09iamVjdCcpO1xuY29uc3QgaXNNb25nb29zZUFycmF5ID0gcmVxdWlyZSgnLi90eXBlcy9hcnJheS9pc01vbmdvb3NlQXJyYXknKTtcbmNvbnN0IGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ID0gcmVxdWlyZSgnLi90eXBlcy9Eb2N1bWVudEFycmF5L2lzTW9uZ29vc2VEb2N1bWVudEFycmF5Jyk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQnNvblR5cGUnKTtcbmNvbnN0IGdldEZ1bmN0aW9uTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXRGdW5jdGlvbk5hbWUnKTtcbmNvbnN0IGlzTW9uZ29vc2VPYmplY3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNNb25nb29zZU9iamVjdCcpO1xuY29uc3QgcHJvbWlzZU9yQ2FsbGJhY2sgPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvbWlzZU9yQ2FsbGJhY2snKTtcbmNvbnN0IHNjaGVtYU1lcmdlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9tZXJnZScpO1xuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3BlY2lhbFByb3BlcnRpZXMnKTtcbmNvbnN0IHsgdHJ1c3RlZFN5bWJvbCB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L3RydXN0ZWQnKTtcblxubGV0IERvY3VtZW50O1xuXG5leHBvcnRzLnNwZWNpYWxQcm9wZXJ0aWVzID0gc3BlY2lhbFByb3BlcnRpZXM7XG5cbmV4cG9ydHMuaXNNb25nb29zZUFycmF5ID0gaXNNb25nb29zZUFycmF5LmlzTW9uZ29vc2VBcnJheTtcbmV4cG9ydHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkgPSBpc01vbmdvb3NlRG9jdW1lbnRBcnJheS5pc01vbmdvb3NlRG9jdW1lbnRBcnJheTtcbmV4cG9ydHMucmVnaXN0ZXJNb25nb29zZUFycmF5ID0gaXNNb25nb29zZUFycmF5LnJlZ2lzdGVyTW9uZ29vc2VBcnJheTtcbmV4cG9ydHMucmVnaXN0ZXJNb25nb29zZURvY3VtZW50QXJyYXkgPSBpc01vbmdvb3NlRG9jdW1lbnRBcnJheS5yZWdpc3Rlck1vbmdvb3NlRG9jdW1lbnRBcnJheTtcblxuY29uc3Qgb25lU3BhY2VSRSA9IC9cXHMvO1xuY29uc3QgbWFueVNwYWNlUkUgPSAvXFxzKy87XG5cbi8qKlxuICogUHJvZHVjZXMgYSBjb2xsZWN0aW9uIG5hbWUgZnJvbSBtb2RlbCBgbmFtZWAuIEJ5IGRlZmF1bHQsIGp1c3QgcmV0dXJuc1xuICogdGhlIG1vZGVsIG5hbWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBhIG1vZGVsIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBsdXJhbGl6ZSBmdW5jdGlvbiB0aGF0IHBsdXJhbGl6ZXMgdGhlIGNvbGxlY3Rpb24gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfSBhIGNvbGxlY3Rpb24gbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy50b0NvbGxlY3Rpb25OYW1lID0gZnVuY3Rpb24obmFtZSwgcGx1cmFsaXplKSB7XG4gIGlmIChuYW1lID09PSAnc3lzdGVtLnByb2ZpbGUnKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgaWYgKG5hbWUgPT09ICdzeXN0ZW0uaW5kZXhlcycpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBpZiAodHlwZW9mIHBsdXJhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwbHVyYWxpemUobmFtZSk7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYGFgIGFuZCBgYmAgYXJlIGRlZXAgZXF1YWwuXG4gKlxuICogTW9kaWZpZWQgZnJvbSBub2RlL2xpYi9hc3NlcnQuanNcbiAqXG4gKiBAcGFyYW0ge2FueX0gYSBhIHZhbHVlIHRvIGNvbXBhcmUgdG8gYGJgXG4gKiBAcGFyYW0ge2FueX0gYiBhIHZhbHVlIHRvIGNvbXBhcmUgdG8gYGFgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuXG4gIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCk7XG4gIH1cblxuICBpZiAoKGlzQnNvblR5cGUoYSwgJ09iamVjdElkJykgJiYgaXNCc29uVHlwZShiLCAnT2JqZWN0SWQnKSkgfHxcbiAgICAgIChpc0Jzb25UeXBlKGEsICdEZWNpbWFsMTI4JykgJiYgaXNCc29uVHlwZShiLCAnRGVjaW1hbDEyOCcpKSkge1xuICAgIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcbiAgfVxuXG4gIGlmIChhIGluc3RhbmNlb2YgUmVnRXhwICYmIGIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmXG4gICAgICAgIGEuaWdub3JlQ2FzZSA9PT0gYi5pZ25vcmVDYXNlICYmXG4gICAgICAgIGEubXVsdGlsaW5lID09PSBiLm11bHRpbGluZSAmJlxuICAgICAgICBhLmdsb2JhbCA9PT0gYi5nbG9iYWwgJiZcbiAgICAgICAgYS5kb3RBbGwgPT09IGIuZG90QWxsICYmXG4gICAgICAgIGEudW5pY29kZSA9PT0gYi51bmljb2RlICYmXG4gICAgICAgIGEuc3RpY2t5ID09PSBiLnN0aWNreSAmJlxuICAgICAgICBhLmhhc0luZGljZXMgPT09IGIuaGFzSW5kaWNlcztcbiAgfVxuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhIGluc3RhbmNlb2YgTWFwIHx8IGIgaW5zdGFuY2VvZiBNYXApIHtcbiAgICBpZiAoIShhIGluc3RhbmNlb2YgTWFwKSB8fCAhKGIgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkZWVwRXF1YWwoQXJyYXkuZnJvbShhLmtleXMoKSksIEFycmF5LmZyb20oYi5rZXlzKCkpKSAmJlxuICAgICAgZGVlcEVxdWFsKEFycmF5LmZyb20oYS52YWx1ZXMoKSksIEFycmF5LmZyb20oYi52YWx1ZXMoKSkpO1xuICB9XG5cbiAgLy8gSGFuZGxlIE1vbmdvb3NlTnVtYmVyc1xuICBpZiAoYSBpbnN0YW5jZW9mIE51bWJlciAmJiBiIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYSkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5idWZmZXIuYXJlRXF1YWwoYSwgYik7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSB8fCBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGEpIHx8ICFBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IGEubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYS4kX18gIT0gbnVsbCkge1xuICAgIGEgPSBhLl9kb2M7XG4gIH0gZWxzZSBpZiAoaXNNb25nb29zZU9iamVjdChhKSkge1xuICAgIGEgPSBhLnRvT2JqZWN0KCk7XG4gIH1cblxuICBpZiAoYi4kX18gIT0gbnVsbCkge1xuICAgIGIgPSBiLl9kb2M7XG4gIH0gZWxzZSBpZiAoaXNNb25nb29zZU9iamVjdChiKSkge1xuICAgIGIgPSBiLnRvT2JqZWN0KCk7XG4gIH1cblxuICBjb25zdCBrYSA9IE9iamVjdC5rZXlzKGEpO1xuICBjb25zdCBrYiA9IE9iamVjdC5rZXlzKGIpO1xuICBjb25zdCBrYUxlbmd0aCA9IGthLmxlbmd0aDtcblxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2FMZW5ndGggIT09IGtiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIH5+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAobGV0IGkgPSBrYUxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vIH5+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChjb25zdCBrZXkgb2Yga2EpIHtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICovXG5cbmV4cG9ydHMubGFzdCA9IGZ1bmN0aW9uKGFycikge1xuICBpZiAoYXJyLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLnByb21pc2VPckNhbGxiYWNrID0gcHJvbWlzZU9yQ2FsbGJhY2s7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5jbG9uZUFycmF5cyA9IGZ1bmN0aW9uIGNsb25lQXJyYXlzKGFycikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICByZXR1cm4gYXJyLm1hcChlbCA9PiBleHBvcnRzLmNsb25lQXJyYXlzKGVsKSk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMub21pdCA9IGZ1bmN0aW9uIG9taXQob2JqLCBrZXlzKSB7XG4gIGlmIChrZXlzID09IG51bGwpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICBrZXlzID0gW2tleXNdO1xuICB9XG5cbiAgY29uc3QgcmV0ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGRlbGV0ZSByZXRba2V5XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBNZXJnZXMgYGZyb21gIGludG8gYHRvYCB3aXRob3V0IG92ZXJ3cml0aW5nIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKHRvLCBmcm9tLCBvcHRpb25zLCBwYXRoKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGtleTtcblxuICBpZiAoZnJvbVt0cnVzdGVkU3ltYm9sXSkge1xuICAgIHRvW3RydXN0ZWRTeW1ib2xdID0gZnJvbVt0cnVzdGVkU3ltYm9sXTtcbiAgfVxuXG4gIHBhdGggPSBwYXRoIHx8ICcnO1xuICBjb25zdCBvbWl0TmVzdGVkID0gb3B0aW9ucy5vbWl0TmVzdGVkIHx8IHt9O1xuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAga2V5ID0ga2V5c1tpKytdO1xuICAgIGlmIChvcHRpb25zLm9taXQgJiYgb3B0aW9ucy5vbWl0W2tleV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAob21pdE5lc3RlZFtwYXRoXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0b1trZXldID09IG51bGwpIHtcbiAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgfSBlbHNlIGlmIChleHBvcnRzLmlzT2JqZWN0KGZyb21ba2V5XSkpIHtcbiAgICAgIGlmICghZXhwb3J0cy5pc09iamVjdCh0b1trZXldKSkge1xuICAgICAgICB0b1trZXldID0ge307XG4gICAgICB9XG4gICAgICBpZiAoZnJvbVtrZXldICE9IG51bGwpIHtcbiAgICAgICAgLy8gU2tpcCBtZXJnaW5nIHNjaGVtYXMgaWYgd2UncmUgY3JlYXRpbmcgYSBkaXNjcmltaW5hdG9yIHNjaGVtYSBhbmRcbiAgICAgICAgLy8gYmFzZSBzY2hlbWEgaGFzIGEgZ2l2ZW4gcGF0aCBhcyBhIHNpbmdsZSBuZXN0ZWQgYnV0IGRpc2NyaW1pbmF0b3Igc2NoZW1hXG4gICAgICAgIC8vIGhhcyB0aGUgcGF0aCBhcyBhIGRvY3VtZW50IGFycmF5LCBvciB2aWNlIHZlcnNhIChnaC05NTM0KVxuICAgICAgICBpZiAob3B0aW9ucy5pc0Rpc2NyaW1pbmF0b3JTY2hlbWFNZXJnZSAmJlxuICAgICAgICAgICAgKGZyb21ba2V5XS4kaXNTaW5nbGVOZXN0ZWQgJiYgdG9ba2V5XS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHx8XG4gICAgICAgICAgICAoZnJvbVtrZXldLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJiB0b1trZXldLiRpc1NpbmdsZU5lc3RlZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChmcm9tW2tleV0uaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgICAgICAgIGlmICh0b1trZXldLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYU1lcmdlKHRvW2tleV0sIGZyb21ba2V5XS5jbG9uZSgpLCBvcHRpb25zLmlzRGlzY3JpbWluYXRvclNjaGVtYU1lcmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XS5jbG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jzb25UeXBlKGZyb21ba2V5XSwgJ09iamVjdElkJykpIHtcbiAgICAgICAgICB0b1trZXldID0gbmV3IE9iamVjdElkKGZyb21ba2V5XSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1lcmdlKHRvW2tleV0sIGZyb21ba2V5XSwgb3B0aW9ucywgcGF0aCA/IHBhdGggKyAnLicgKyBrZXkgOiBrZXkpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vdmVyd3JpdGUpIHtcbiAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHRvT2JqZWN0IHJlY3Vyc2l2ZWx5LlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR8QXJyYXl8T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChvYmopIHtcbiAgRG9jdW1lbnQgfHwgKERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudCcpKTtcbiAgbGV0IHJldDtcblxuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgcmV0dXJuIG9iai50b09iamVjdCgpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldCA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBkb2Mgb2Ygb2JqKSB7XG4gICAgICByZXQucHVzaCh0b09iamVjdChkb2MpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgaWYgKGV4cG9ydHMuaXNQT0pPKG9iaikpIHtcbiAgICByZXQgPSB7fTtcblxuICAgIGlmIChvYmpbdHJ1c3RlZFN5bWJvbF0pIHtcbiAgICAgIHJldFt0cnVzdGVkU3ltYm9sXSA9IG9ialt0cnVzdGVkU3ltYm9sXTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldFtrXSA9IHRvT2JqZWN0KG9ialtrXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYXJnYCBpcyBhIHBsYWluIG9sZCBKYXZhU2NyaXB0IG9iamVjdCAoUE9KTykuIFNwZWNpZmljYWxseSxcbiAqIGBhcmdgIG11c3QgYmUgYW4gb2JqZWN0IGJ1dCBub3QgYW4gaW5zdGFuY2Ugb2YgYW55IHNwZWNpYWwgY2xhc3MsIGxpa2UgU3RyaW5nLFxuICogT2JqZWN0SWQsIGV0Yy5cbiAqXG4gKiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKClgIGlzIHBhcnQgb2YgRVM1OiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZ2V0UHJvdG90eXBlT2ZcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheXxTdHJpbmd8RnVuY3Rpb258UmVnRXhwfGFueX0gYXJnXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1BPSk8gPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQT0pPJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYXJnYCBpcyBhbiBvYmplY3QgdGhhdCBpc24ndCBhbiBpbnN0YW5jZSBvZiBhIGJ1aWx0LWluIHZhbHVlXG4gKiBjbGFzcywgbGlrZSBBcnJheSwgQnVmZmVyLCBPYmplY3RJZCwgZXRjLlxuICogQHBhcmFtIHtBbnl9IHZhbFxuICovXG5cbmV4cG9ydHMuaXNOb25CdWlsdGluT2JqZWN0ID0gZnVuY3Rpb24gaXNOb25CdWlsdGluT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiZcbiAgICAhZXhwb3J0cy5pc05hdGl2ZU9iamVjdCh2YWwpICYmXG4gICAgIWV4cG9ydHMuaXNNb25nb29zZVR5cGUodmFsKSAmJlxuICAgICEodmFsIGluc3RhbmNlb2YgVVVJRCkgJiZcbiAgICB2YWwgIT0gbnVsbDtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgb2JqYCBpcyBhIGJ1aWx0LWluIG9iamVjdCBsaWtlIGFuIGFycmF5LCBkYXRlLCBib29sZWFuLFxuICogZXRjLlxuICogQHBhcmFtIHtBbnl9IGFyZ1xuICovXG5cbmV4cG9ydHMuaXNOYXRpdmVPYmplY3QgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKSB8fFxuICAgIGFyZyBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICBhcmcgaW5zdGFuY2VvZiBCb29sZWFuIHx8XG4gICAgYXJnIGluc3RhbmNlb2YgTnVtYmVyIHx8XG4gICAgYXJnIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGB2YWxgIGlzIGFuIG9iamVjdCB0aGF0IGhhcyBubyBvd24ga2V5c1xuICogQHBhcmFtIHtBbnl9IHZhbFxuICovXG5cbmV4cG9ydHMuaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJlxuICAgIE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAwO1xufTtcblxuLyoqXG4gKiBTZWFyY2ggaWYgYG9iamAgb3IgYW55IFBPSk9zIG5lc3RlZCB1bmRlcm5lYXRoIGBvYmpgIGhhcyBhIHByb3BlcnR5IG5hbWVkXG4gKiBga2V5YFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICovXG5cbmV4cG9ydHMuaGFzS2V5ID0gZnVuY3Rpb24gaGFzS2V5KG9iaiwga2V5KSB7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKSB7XG4gICAgaWYgKHByb3AgPT09IGtleSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChleHBvcnRzLmlzUE9KTyhvYmpbcHJvcF0pICYmIGV4cG9ydHMuaGFzS2V5KG9ialtwcm9wXSwga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogcHJvY2Vzcy5uZXh0VGljayBoZWxwZXIuXG4gKlxuICogV3JhcHMgYGNhbGxiYWNrYCBpbiBhIHRyeS9jYXRjaCArIG5leHRUaWNrLlxuICpcbiAqIG5vZGUtbW9uZ29kYi1uYXRpdmUgaGFzIGEgaGFiaXQgb2Ygc3RhdGUgY29ycnVwdGlvbiB3aGVuIGFuIGVycm9yIGlzIGltbWVkaWF0ZWx5IHRocm93biBmcm9tIHdpdGhpbiBhIGNvbGxlY3Rpb24gY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudGljayA9IGZ1bmN0aW9uIHRpY2soY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBvbmx5IG5leHRUaWNrIG9uIGVyciB0byBnZXQgb3V0IG9mXG4gICAgICAvLyB0aGUgZXZlbnQgbG9vcCBhbmQgYXZvaWQgc3RhdGUgY29ycnVwdGlvbi5cbiAgICAgIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZgIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBzZXJpYWxpemVkIGFzIGEgcHJpbWl0aXZlIGluXG4gKiBNb25nb0RCXG4gKiBAcGFyYW0ge0FueX0gdlxuICovXG5cbmV4cG9ydHMuaXNNb25nb29zZVR5cGUgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBpc0Jzb25UeXBlKHYsICdPYmplY3RJZCcpIHx8IGlzQnNvblR5cGUodiwgJ0RlY2ltYWwxMjgnKSB8fCB2IGluc3RhbmNlb2YgQnVmZmVyO1xufTtcblxuZXhwb3J0cy5pc01vbmdvb3NlT2JqZWN0ID0gaXNNb25nb29zZU9iamVjdDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgZXhwaXJlc2Agb3B0aW9ucyBvZiBpbmRleCBvYmplY3RzIHRvIGBleHBpcmVzQWZ0ZXJTZWNvbmRzYCBvcHRpb25zIGZvciBNb25nb0RCLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZXhwaXJlcyA9IGZ1bmN0aW9uIGV4cGlyZXMob2JqZWN0KSB7XG4gIGlmICghKG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdleHBpcmVzJyBpbiBvYmplY3QpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb2JqZWN0LmV4cGlyZUFmdGVyU2Vjb25kcyA9ICh0eXBlb2Ygb2JqZWN0LmV4cGlyZXMgIT09ICdzdHJpbmcnKVxuICAgID8gb2JqZWN0LmV4cGlyZXNcbiAgICA6IE1hdGgucm91bmQobXMob2JqZWN0LmV4cGlyZXMpIC8gMTAwMCk7XG4gIGRlbGV0ZSBvYmplY3QuZXhwaXJlcztcbn07XG5cbi8qKlxuICogcG9wdWxhdGUgaGVscGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdFxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QW55fSBzdWJQb3B1bGF0ZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0T25lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvdW50XG4gKi9cblxuZXhwb3J0cy5wb3B1bGF0ZSA9IGZ1bmN0aW9uIHBvcHVsYXRlKHBhdGgsIHNlbGVjdCwgbW9kZWwsIG1hdGNoLCBvcHRpb25zLCBzdWJQb3B1bGF0ZSwganVzdE9uZSwgY291bnQpIHtcbiAgLy8gbWlnaHQgaGF2ZSBwYXNzZWQgYW4gb2JqZWN0IHNwZWNpZnlpbmcgYWxsIGFyZ3VtZW50c1xuICBsZXQgb2JqID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFBvcHVsYXRlT3B0aW9ucykge1xuICAgICAgLy8gSWYgcmV1c2luZyBvbGQgcG9wdWxhdGUgZG9jcywgYXZvaWQgcmV1c2luZyBgX2RvY3NgIGJlY2F1c2UgdGhhdCBtYXlcbiAgICAgIC8vIGxlYWQgdG8gYnVncyBhbmQgbWVtb3J5IGxlYWtzLiBTZWUgZ2gtMTE2NDFcbiAgICAgIHBhdGguX2RvY3MgPSBbXTtcbiAgICAgIHBhdGguX2NoaWxkRG9jcyA9IFtdO1xuICAgICAgcmV0dXJuIFtwYXRoXTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgY29uc3Qgc2luZ2xlcyA9IG1ha2VTaW5nbGVzKHBhdGgpO1xuICAgICAgcmV0dXJuIHNpbmdsZXMubWFwKG8gPT4gZXhwb3J0cy5wb3B1bGF0ZShvKVswXSk7XG4gICAgfVxuXG4gICAgaWYgKGV4cG9ydHMuaXNPYmplY3QocGF0aCkpIHtcbiAgICAgIG9iaiA9IE9iamVjdC5hc3NpZ24oe30sIHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmogPSB7IHBhdGg6IHBhdGggfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZGVsID09PSAnb2JqZWN0Jykge1xuICAgIG9iaiA9IHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBzZWxlY3Q6IHNlbGVjdCxcbiAgICAgIG1hdGNoOiBtb2RlbCxcbiAgICAgIG9wdGlvbnM6IG1hdGNoXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBvYmogPSB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgc2VsZWN0OiBzZWxlY3QsXG4gICAgICBtb2RlbDogbW9kZWwsXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgcG9wdWxhdGU6IHN1YlBvcHVsYXRlLFxuICAgICAganVzdE9uZToganVzdE9uZSxcbiAgICAgIGNvdW50OiBjb3VudFxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIG9iai5wYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3V0aWxzLnBvcHVsYXRlOiBpbnZhbGlkIHBhdGguIEV4cGVjdGVkIHN0cmluZy4gR290IHR5cGVvZiBgJyArIHR5cGVvZiBwYXRoICsgJ2AnKTtcbiAgfVxuXG4gIHJldHVybiBfcG9wdWxhdGVPYmoob2JqKTtcblxuICAvLyBUaGUgb3JkZXIgb2Ygc2VsZWN0L2NvbmRpdGlvbnMgYXJncyBpcyBvcHBvc2l0ZSBNb2RlbC5maW5kIGJ1dFxuICAvLyBuZWNlc3NhcnkgdG8ga2VlcCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IChzZWxlY3QgY291bGQgYmVcbiAgLy8gYW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGxpdGVyYWwpLlxuICBmdW5jdGlvbiBtYWtlU2luZ2xlcyhhcnIpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBhcnIuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvbmVTcGFjZVJFLnRlc3Qob2JqLnBhdGgpKSB7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gb2JqLnBhdGguc3BsaXQobWFueVNwYWNlUkUpO1xuICAgICAgICBwYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgICBjb3B5LnBhdGggPSBwO1xuICAgICAgICAgIHJldC5wdXNoKGNvcHkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5wdXNoKG9iaik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG59O1xuXG5mdW5jdGlvbiBfcG9wdWxhdGVPYmoob2JqKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iai5wb3B1bGF0ZSkpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBvYmoucG9wdWxhdGUuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvbmVTcGFjZVJFLnRlc3Qob2JqLnBhdGgpKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICAgICAgICBjb25zdCBwYXRocyA9IGNvcHkucGF0aC5zcGxpdChtYW55U3BhY2VSRSk7XG4gICAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGNvcHkucGF0aCA9IHA7XG4gICAgICAgICAgcmV0LnB1c2goZXhwb3J0cy5wb3B1bGF0ZShjb3B5KVswXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LnB1c2goZXhwb3J0cy5wb3B1bGF0ZShvYmopWzBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYmoucG9wdWxhdGUgPSBleHBvcnRzLnBvcHVsYXRlKHJldCk7XG4gIH0gZWxzZSBpZiAob2JqLnBvcHVsYXRlICE9IG51bGwgJiYgdHlwZW9mIG9iai5wb3B1bGF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBvYmoucG9wdWxhdGUgPSBleHBvcnRzLnBvcHVsYXRlKG9iai5wb3B1bGF0ZSk7XG4gIH1cblxuICBjb25zdCByZXQgPSBbXTtcbiAgY29uc3QgcGF0aHMgPSBvbmVTcGFjZVJFLnRlc3Qob2JqLnBhdGgpID8gb2JqLnBhdGguc3BsaXQobWFueVNwYWNlUkUpIDogW29iai5wYXRoXTtcbiAgaWYgKG9iai5vcHRpb25zICE9IG51bGwpIHtcbiAgICBvYmoub3B0aW9ucyA9IGNsb25lKG9iai5vcHRpb25zKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIHJldC5wdXNoKG5ldyBQb3B1bGF0ZU9wdGlvbnMoT2JqZWN0LmFzc2lnbih7fSwgb2JqLCB7IHBhdGg6IHBhdGggfSkpKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSB2YWx1ZSBvZiBgb2JqYCBhdCB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0FueX0gbWFwXG4gKi9cblxuZXhwb3J0cy5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHBhdGgsIG9iaiwgbWFwKSB7XG4gIHJldHVybiBtcGF0aC5nZXQocGF0aCwgb2JqLCBnZXRWYWx1ZUxvb2t1cCwgbWFwKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3QgbWFwR2V0dGVyT3B0aW9ucyA9IE9iamVjdC5mcmVlemUoeyBnZXR0ZXJzOiBmYWxzZSB9KTtcblxuZnVuY3Rpb24gZ2V0VmFsdWVMb29rdXAob2JqLCBwYXJ0KSB7XG4gIGxldCBfZnJvbSA9IG9iaj8uX2RvYyB8fCBvYmo7XG4gIGlmIChfZnJvbSAhPSBudWxsICYmIF9mcm9tLmlzTW9uZ29vc2VBcnJheVByb3h5KSB7XG4gICAgX2Zyb20gPSBfZnJvbS5fX2FycmF5O1xuICB9XG4gIHJldHVybiBfZnJvbSBpbnN0YW5jZW9mIE1hcCA/XG4gICAgX2Zyb20uZ2V0KHBhcnQsIG1hcEdldHRlck9wdGlvbnMpIDpcbiAgICBfZnJvbVtwYXJ0XTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBgb2JqYCBhdCB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge0FueXRoaW5nfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7QW55fSBtYXBcbiAqIEBwYXJhbSB7QW55fSBfY29weWluZ1xuICovXG5cbmV4cG9ydHMuc2V0VmFsdWUgPSBmdW5jdGlvbihwYXRoLCB2YWwsIG9iaiwgbWFwLCBfY29weWluZykge1xuICBtcGF0aC5zZXQocGF0aCwgdmFsLCBvYmosICdfZG9jJywgbWFwLCBfY29weWluZyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzIGZyb20gb2JqZWN0IGBvYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLm9iamVjdCA9IHt9O1xuZXhwb3J0cy5vYmplY3QudmFscyA9IGZ1bmN0aW9uIHZhbHMobykge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobyk7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIGNvbnN0IHJldCA9IFtdO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXQucHVzaChvW2tleXNbaV1dKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5jb25zdCBob3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFNhZmVyIGhlbHBlciBmb3IgaGFzT3duUHJvcGVydHkgY2hlY2tzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqL1xuXG5leHBvcnRzLm9iamVjdC5oYXNPd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iaiwgcHJvcCkge1xuICByZXR1cm4gaG9wLmNhbGwob2JqLCBwcm9wKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGB2YWxgIGlzIG51bGwgb3IgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuYXJyYXkgPSB7fTtcblxuLyoqXG4gKiBGbGF0dGVucyBhbiBhcnJheS5cbiAqXG4gKiBbIDEsIFsgMiwgMywgWzRdIF1dIC0+IFsxLDIsMyw0XVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZpbHRlcl0gSWYgcGFzc2VkLCB3aWxsIGJlIGludm9rZWQgd2l0aCBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LiBJZiBgZmlsdGVyYCByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIHRoZSBpdGVtIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRzLlxuICogQHBhcmFtIHtBcnJheX0gcmV0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuYXJyYXkuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCBmaWx0ZXIsIHJldCkge1xuICByZXQgfHwgKHJldCA9IFtdKTtcblxuICBhcnIuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIGZsYXR0ZW4oaXRlbSwgZmlsdGVyLCByZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5leHBvcnRzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleSkge1xuICAgICAgaWYgKGV4cG9ydHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGtleSBpbiBvYmopIHtcbiAgICBjb25zdCB2ID0gb2JqW2tleV07XG4gICAgcmV0dXJuIHYgIT09IE9iamVjdC5wcm90b3R5cGVba2V5XSAmJiB2ICE9PSBBcnJheS5wcm90b3R5cGVba2V5XTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3QgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcblxuZXhwb3J0cy5pc0FycmF5SW5kZXggPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbCA+PSAwICYmIHZhbCA8PSBNQVhfQVJSQVlfSU5ERVg7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCEvXlxcZCskLy50ZXN0KHZhbCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFsID0gK3ZhbDtcbiAgICByZXR1cm4gdmFsID49IDAgJiYgdmFsIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGUgdmFsdWVzIGZyb20gYW4gYXJyYXlcbiAqXG4gKiBbMSwgMiwgMywgMywgNV0gPT4gWzEsIDIsIDMsIDVdXG4gKiBbIE9iamVjdElkKFwiNTUwOTg4YmEwYzE5ZDU3ZjY5N2RjNDVlXCIpLCBPYmplY3RJZChcIjU1MDk4OGJhMGMxOWQ1N2Y2OTdkYzQ1ZVwiKSBdXG4gKiAgICA9PiBbT2JqZWN0SWQoXCI1NTA5ODhiYTBjMTlkNTdmNjk3ZGM0NWVcIildXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuYXJyYXkudW5pcXVlID0gZnVuY3Rpb24oYXJyKSB7XG4gIGNvbnN0IHByaW1pdGl2ZXMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgcmV0ID0gW107XG5cbiAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnIHx8IGl0ZW0gPT0gbnVsbCkge1xuICAgICAgaWYgKHByaW1pdGl2ZXMuaGFzKGl0ZW0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgICBwcmltaXRpdmVzLmFkZChpdGVtKTtcbiAgICB9IGVsc2UgaWYgKGlzQnNvblR5cGUoaXRlbSwgJ09iamVjdElkJykpIHtcbiAgICAgIGlmIChpZHMuaGFzKGl0ZW0udG9TdHJpbmcoKSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXQucHVzaChpdGVtKTtcbiAgICAgIGlkcy5hZGQoaXRlbS50b1N0cmluZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydHMuYnVmZmVyID0ge307XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0d28gYnVmZmVycyBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKi9cblxuZXhwb3J0cy5idWZmZXIuYXJlRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydHMuZ2V0RnVuY3Rpb25OYW1lID0gZ2V0RnVuY3Rpb25OYW1lO1xuXG4vKipcbiAqIERlY29yYXRlIGJ1ZmZlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZVxuICovXG5cbmV4cG9ydHMuZGVjb3JhdGUgPSBmdW5jdGlvbihkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGRlc3RpbmF0aW9uW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxufTtcblxuLyoqXG4gKiBtZXJnZXMgdG8gd2l0aCBhIGNvcHkgb2YgZnJvbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21PYmpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMubWVyZ2VDbG9uZSA9IGZ1bmN0aW9uKHRvLCBmcm9tT2JqKSB7XG4gIGlmIChpc01vbmdvb3NlT2JqZWN0KGZyb21PYmopKSB7XG4gICAgZnJvbU9iaiA9IGZyb21PYmoudG9PYmplY3Qoe1xuICAgICAgdHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgIHZpcnR1YWxzOiBmYWxzZSxcbiAgICAgIGRlcG9wdWxhdGU6IHRydWUsXG4gICAgICBnZXR0ZXJzOiBmYWxzZSxcbiAgICAgIGZsYXR0ZW5EZWNpbWFsczogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZnJvbU9iaik7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIGxldCBrZXk7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBrZXkgPSBrZXlzW2krK107XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0b1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdG9ba2V5XSA9IGNsb25lKGZyb21PYmpba2V5XSwge1xuICAgICAgICB0cmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICB2aXJ0dWFsczogZmFsc2UsXG4gICAgICAgIGRlcG9wdWxhdGU6IHRydWUsXG4gICAgICAgIGdldHRlcnM6IGZhbHNlLFxuICAgICAgICBmbGF0dGVuRGVjaW1hbHM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHZhbCA9IGZyb21PYmpba2V5XTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwudmFsdWVPZiAmJiAhKHZhbCBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgIHZhbCA9IHZhbC52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3J0cy5pc09iamVjdCh2YWwpKSB7XG4gICAgICAgIGxldCBvYmogPSB2YWw7XG4gICAgICAgIGlmIChpc01vbmdvb3NlT2JqZWN0KHZhbCkgJiYgIXZhbC5pc01vbmdvb3NlQnVmZmVyKSB7XG4gICAgICAgICAgb2JqID0gb2JqLnRvT2JqZWN0KHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgICB2aXJ0dWFsczogZmFsc2UsXG4gICAgICAgICAgICBkZXBvcHVsYXRlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0dGVyczogZmFsc2UsXG4gICAgICAgICAgICBmbGF0dGVuRGVjaW1hbHM6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbC5pc01vbmdvb3NlQnVmZmVyKSB7XG4gICAgICAgICAgb2JqID0gQnVmZmVyLmZyb20ob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLm1lcmdlQ2xvbmUodG9ba2V5XSwgb2JqKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvW2tleV0gPSBjbG9uZSh2YWwsIHtcbiAgICAgICAgICBmbGF0dGVuRGVjaW1hbHM6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiBhbiBhcnJheSAobGlrZSBfLmVhY2gpXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lYWNoID0gZnVuY3Rpb24oYXJyLCBmbikge1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgZm4oaXRlbSk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5nZXRPcHRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoc291cmNlW25hbWVdICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBzb3VyY2VbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMubm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbmV4cG9ydHMuZXJyb3JUb1BPSk8gPSBmdW5jdGlvbiBlcnJvclRvUE9KTyhlcnJvcikge1xuICBjb25zdCBpc0Vycm9yID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvcjtcbiAgaWYgKCFpc0Vycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZXJyb3JgIG11c3QgYmUgYGluc3RhbmNlb2YgRXJyb3JgLicpO1xuICB9XG5cbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAoY29uc3QgcHJvcGVyeU5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXJyb3IpKSB7XG4gICAgcmV0W3Byb3BlcnlOYW1lXSA9IGVycm9yW3Byb3BlcnlOYW1lXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLndhcm4gPSBmdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW1pdFdhcm5pbmcobWVzc2FnZSwgeyBjb2RlOiAnTU9OR09PU0UnIH0pO1xufTtcblxuXG5leHBvcnRzLmluamVjdFRpbWVzdGFtcHNPcHRpb24gPSBmdW5jdGlvbiBpbmplY3RUaW1lc3RhbXBzT3B0aW9uKHdyaXRlT3BlcmF0aW9uLCB0aW1lc3RhbXBzT3B0aW9uKSB7XG4gIGlmICh0aW1lc3RhbXBzT3B0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd3JpdGVPcGVyYXRpb24udGltZXN0YW1wcyA9IHRpbWVzdGFtcHNPcHRpb247XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/utils.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/validoptions.js":
/*!***********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/validoptions.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\n/*!\n * Valid mongoose options\n */\n\n\n\nconst VALID_OPTIONS = Object.freeze([\n  'allowDiskUse',\n  'applyPluginsToChildSchemas',\n  'applyPluginsToDiscriminators',\n  'autoCreate',\n  'autoIndex',\n  'bufferCommands',\n  'bufferTimeoutMS',\n  'cloneSchemas',\n  'debug',\n  'id',\n  'timestamps.createdAt.immutable',\n  'maxTimeMS',\n  'objectIdGetter',\n  'overwriteModels',\n  'returnOriginal',\n  'runValidators',\n  'sanitizeFilter',\n  'sanitizeProjection',\n  'selectPopulatedPaths',\n  'setDefaultsOnInsert',\n  'strict',\n  'strictPopulate',\n  'strictQuery',\n  'toJSON',\n  'toObject',\n  'transactionAsyncLocalStorage',\n  'translateAliases'\n]);\n\nmodule.exports = VALID_OPTIONS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdmFsaWRvcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHZhbGlkb3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogVmFsaWQgbW9uZ29vc2Ugb3B0aW9uc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgVkFMSURfT1BUSU9OUyA9IE9iamVjdC5mcmVlemUoW1xuICAnYWxsb3dEaXNrVXNlJyxcbiAgJ2FwcGx5UGx1Z2luc1RvQ2hpbGRTY2hlbWFzJyxcbiAgJ2FwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnMnLFxuICAnYXV0b0NyZWF0ZScsXG4gICdhdXRvSW5kZXgnLFxuICAnYnVmZmVyQ29tbWFuZHMnLFxuICAnYnVmZmVyVGltZW91dE1TJyxcbiAgJ2Nsb25lU2NoZW1hcycsXG4gICdkZWJ1ZycsXG4gICdpZCcsXG4gICd0aW1lc3RhbXBzLmNyZWF0ZWRBdC5pbW11dGFibGUnLFxuICAnbWF4VGltZU1TJyxcbiAgJ29iamVjdElkR2V0dGVyJyxcbiAgJ292ZXJ3cml0ZU1vZGVscycsXG4gICdyZXR1cm5PcmlnaW5hbCcsXG4gICdydW5WYWxpZGF0b3JzJyxcbiAgJ3Nhbml0aXplRmlsdGVyJyxcbiAgJ3Nhbml0aXplUHJvamVjdGlvbicsXG4gICdzZWxlY3RQb3B1bGF0ZWRQYXRocycsXG4gICdzZXREZWZhdWx0c09uSW5zZXJ0JyxcbiAgJ3N0cmljdCcsXG4gICdzdHJpY3RQb3B1bGF0ZScsXG4gICdzdHJpY3RRdWVyeScsXG4gICd0b0pTT04nLFxuICAndG9PYmplY3QnLFxuICAndHJhbnNhY3Rpb25Bc3luY0xvY2FsU3RvcmFnZScsXG4gICd0cmFuc2xhdGVBbGlhc2VzJ1xuXSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVkFMSURfT1BUSU9OUztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/validoptions.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/lib/virtualtype.js":
/*!**********************************************************!*\
  !*** ../server/node_modules/mongoose/lib/virtualtype.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ./utils */ \"(api)/../server/node_modules/mongoose/lib/utils.js\");\n\n/**\n * VirtualType constructor\n *\n * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.\n *\n * #### Example:\n *\n *     const fullname = schema.virtual('fullname');\n *     fullname instanceof mongoose.VirtualType // true\n *\n * @param {Object} options\n * @param {String|Function} [options.ref] if `ref` is not nullish, this becomes a [populated virtual](https://mongoosejs.com/docs/populate.html#populate-virtuals)\n * @param {String|Function} [options.localField] the local field to populate on if this is a populated virtual.\n * @param {String|Function} [options.foreignField] the foreign field to populate on if this is a populated virtual.\n * @param {Boolean} [options.justOne=false] by default, a populated virtual is an array. If you set `justOne`, the populated virtual will be a single doc or `null`.\n * @param {Boolean} [options.getters=false] if you set this to `true`, Mongoose will call any custom getters you defined on this virtual\n * @param {Boolean} [options.count=false] if you set this to `true`, `populate()` will set this virtual to the number of populated documents, as opposed to the documents themselves, using [`Query#countDocuments()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.countDocuments())\n * @param {Object|Function} [options.match=null] add an extra match condition to `populate()`\n * @param {Number} [options.limit=null] add a default `limit` to the `populate()` query\n * @param {Number} [options.skip=null] add a default `skip` to the `populate()` query\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {String} name\n * @api public\n */\n\nfunction VirtualType(options, name) {\n  this.path = name;\n  this.getters = [];\n  this.setters = [];\n  this.options = Object.assign({}, options);\n}\n\n/**\n * If no getters/setters, add a default\n *\n * @api private\n */\n\nVirtualType.prototype._applyDefaultGetters = function() {\n  if (this.getters.length > 0 || this.setters.length > 0) {\n    return;\n  }\n\n  const path = this.path;\n  const internalProperty = '$' + path;\n  this.getters.push(function() {\n    return this.$locals[internalProperty];\n  });\n  this.setters.push(function(v) {\n    this.$locals[internalProperty] = v;\n  });\n};\n\n/*!\n * ignore\n */\n\nVirtualType.prototype.clone = function() {\n  const clone = new VirtualType(this.options, this.path);\n  clone.getters = [].concat(this.getters);\n  clone.setters = [].concat(this.setters);\n  return clone;\n};\n\n/**\n * Adds a custom getter to this virtual.\n *\n * Mongoose calls the getter function with the below 3 parameters.\n *\n * - `value`: the value returned by the previous getter. If there is only one getter, `value` will be `undefined`.\n * - `virtual`: the virtual object you called `.get()` on.\n * - `doc`: the document this virtual is attached to. Equivalent to `this`.\n *\n * #### Example:\n *\n *     const virtual = schema.virtual('fullname');\n *     virtual.get(function(value, virtual, doc) {\n *       return this.name.first + ' ' + this.name.last;\n *     });\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.get = function(fn) {\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Adds a custom setter to this virtual.\n *\n * Mongoose calls the setter function with the below 3 parameters.\n *\n * - `value`: the value being set.\n * - `virtual`: the virtual object you're calling `.set()` on.\n * - `doc`: the document this virtual is attached to. Equivalent to `this`.\n *\n * #### Example:\n *\n *     const virtual = schema.virtual('fullname');\n *     virtual.set(function(value, virtual, doc) {\n *       const parts = value.split(' ');\n *       this.name.first = parts[0];\n *       this.name.last = parts[1];\n *     });\n *\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model();\n *     // Calls the setter with `value = 'Jean-Luc Picard'`\n *     doc.fullname = 'Jean-Luc Picard';\n *     doc.name.first; // 'Jean-Luc'\n *     doc.name.last; // 'Picard'\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.set = function(fn) {\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Applies getters to `value`.\n *\n * @param {Object} value\n * @param {Document} doc The document this virtual is attached to\n * @return {Any} the value after applying all getters\n * @api public\n */\n\nVirtualType.prototype.applyGetters = function(value, doc) {\n  if (utils.hasUserDefinedProperty(this.options, ['ref', 'refPath']) &&\n      doc.$$populatedVirtuals &&\n      doc.$$populatedVirtuals.hasOwnProperty(this.path)) {\n    value = doc.$$populatedVirtuals[this.path];\n  }\n\n  let v = value;\n  for (const getter of this.getters) {\n    v = getter.call(doc, v, this, doc);\n  }\n  return v;\n};\n\n/**\n * Applies setters to `value`.\n *\n * @param {Object} value\n * @param {Document} doc\n * @return {Any} the value after applying all setters\n * @api public\n */\n\nVirtualType.prototype.applySetters = function(value, doc) {\n  let v = value;\n  for (const setter of this.setters) {\n    v = setter.call(doc, v, this, doc);\n  }\n  return v;\n};\n\n/*!\n * exports\n */\n\nmodule.exports = VirtualType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdmlydHVhbHR5cGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLG1FQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSx3V0FBd1csbUNBQW1DO0FBQzlaLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksYUFBYTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksYUFBYTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVksS0FBSztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHNhbG9uaVxcYXBwcmFpc2FsLXN5c3RlbVxcc2VydmVyXFxub2RlX21vZHVsZXNcXG1vbmdvb3NlXFxsaWJcXHZpcnR1YWx0eXBlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogVmlydHVhbFR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiBUaGlzIGlzIHdoYXQgbW9uZ29vc2UgdXNlcyB0byBkZWZpbmUgdmlydHVhbCBhdHRyaWJ1dGVzIHZpYSBgU2NoZW1hLnByb3RvdHlwZS52aXJ0dWFsYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGZ1bGxuYW1lID0gc2NoZW1hLnZpcnR1YWwoJ2Z1bGxuYW1lJyk7XG4gKiAgICAgZnVsbG5hbWUgaW5zdGFuY2VvZiBtb25nb29zZS5WaXJ0dWFsVHlwZSAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb3B0aW9ucy5yZWZdIGlmIGByZWZgIGlzIG5vdCBudWxsaXNoLCB0aGlzIGJlY29tZXMgYSBbcG9wdWxhdGVkIHZpcnR1YWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3BvcHVsYXRlLXZpcnR1YWxzKVxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtvcHRpb25zLmxvY2FsRmllbGRdIHRoZSBsb2NhbCBmaWVsZCB0byBwb3B1bGF0ZSBvbiBpZiB0aGlzIGlzIGEgcG9wdWxhdGVkIHZpcnR1YWwuXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW29wdGlvbnMuZm9yZWlnbkZpZWxkXSB0aGUgZm9yZWlnbiBmaWVsZCB0byBwb3B1bGF0ZSBvbiBpZiB0aGlzIGlzIGEgcG9wdWxhdGVkIHZpcnR1YWwuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmp1c3RPbmU9ZmFsc2VdIGJ5IGRlZmF1bHQsIGEgcG9wdWxhdGVkIHZpcnR1YWwgaXMgYW4gYXJyYXkuIElmIHlvdSBzZXQgYGp1c3RPbmVgLCB0aGUgcG9wdWxhdGVkIHZpcnR1YWwgd2lsbCBiZSBhIHNpbmdsZSBkb2Mgb3IgYG51bGxgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5nZXR0ZXJzPWZhbHNlXSBpZiB5b3Ugc2V0IHRoaXMgdG8gYHRydWVgLCBNb25nb29zZSB3aWxsIGNhbGwgYW55IGN1c3RvbSBnZXR0ZXJzIHlvdSBkZWZpbmVkIG9uIHRoaXMgdmlydHVhbFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb3VudD1mYWxzZV0gaWYgeW91IHNldCB0aGlzIHRvIGB0cnVlYCwgYHBvcHVsYXRlKClgIHdpbGwgc2V0IHRoaXMgdmlydHVhbCB0byB0aGUgbnVtYmVyIG9mIHBvcHVsYXRlZCBkb2N1bWVudHMsIGFzIG9wcG9zZWQgdG8gdGhlIGRvY3VtZW50cyB0aGVtc2VsdmVzLCB1c2luZyBbYFF1ZXJ5I2NvdW50RG9jdW1lbnRzKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmNvdW50RG9jdW1lbnRzKCkpXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW29wdGlvbnMubWF0Y2g9bnVsbF0gYWRkIGFuIGV4dHJhIG1hdGNoIGNvbmRpdGlvbiB0byBgcG9wdWxhdGUoKWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5saW1pdD1udWxsXSBhZGQgYSBkZWZhdWx0IGBsaW1pdGAgdG8gdGhlIGBwb3B1bGF0ZSgpYCBxdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNraXA9bnVsbF0gYWRkIGEgZGVmYXVsdCBgc2tpcGAgdG8gdGhlIGBwb3B1bGF0ZSgpYCBxdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlckRvY3VtZW50TGltaXQ9bnVsbF0gRm9yIGxlZ2FjeSByZWFzb25zLCBgbGltaXRgIHdpdGggYHBvcHVsYXRlKClgIG1heSBnaXZlIGluY29ycmVjdCByZXN1bHRzIGJlY2F1c2UgaXQgb25seSBleGVjdXRlcyBhIHNpbmdsZSBxdWVyeSBmb3IgZXZlcnkgZG9jdW1lbnQgYmVpbmcgcG9wdWxhdGVkLiBJZiB5b3Ugc2V0IGBwZXJEb2N1bWVudExpbWl0YCwgTW9uZ29vc2Ugd2lsbCBlbnN1cmUgY29ycmVjdCBgbGltaXRgIHBlciBkb2N1bWVudCBieSBleGVjdXRpbmcgYSBzZXBhcmF0ZSBxdWVyeSBmb3IgZWFjaCBkb2N1bWVudCB0byBgcG9wdWxhdGUoKWAuIEZvciBleGFtcGxlLCBgLmZpbmQoKS5wb3B1bGF0ZSh7IHBhdGg6ICd0ZXN0JywgcGVyRG9jdW1lbnRMaW1pdDogMiB9KWAgd2lsbCBleGVjdXRlIDIgYWRkaXRpb25hbCBxdWVyaWVzIGlmIGAuZmluZCgpYCByZXR1cm5zIDIgZG9jdW1lbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm9wdGlvbnM9bnVsbF0gQWRkaXRpb25hbCBvcHRpb25zIGxpa2UgYGxpbWl0YCBhbmQgYGxlYW5gLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gVmlydHVhbFR5cGUob3B0aW9ucywgbmFtZSkge1xuICB0aGlzLnBhdGggPSBuYW1lO1xuICB0aGlzLmdldHRlcnMgPSBbXTtcbiAgdGhpcy5zZXR0ZXJzID0gW107XG4gIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIElmIG5vIGdldHRlcnMvc2V0dGVycywgYWRkIGEgZGVmYXVsdFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblZpcnR1YWxUeXBlLnByb3RvdHlwZS5fYXBwbHlEZWZhdWx0R2V0dGVycyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5nZXR0ZXJzLmxlbmd0aCA+IDAgfHwgdGhpcy5zZXR0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYXRoID0gdGhpcy5wYXRoO1xuICBjb25zdCBpbnRlcm5hbFByb3BlcnR5ID0gJyQnICsgcGF0aDtcbiAgdGhpcy5nZXR0ZXJzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGxvY2Fsc1tpbnRlcm5hbFByb3BlcnR5XTtcbiAgfSk7XG4gIHRoaXMuc2V0dGVycy5wdXNoKGZ1bmN0aW9uKHYpIHtcbiAgICB0aGlzLiRsb2NhbHNbaW50ZXJuYWxQcm9wZXJ0eV0gPSB2O1xuICB9KTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuVmlydHVhbFR5cGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGNsb25lID0gbmV3IFZpcnR1YWxUeXBlKHRoaXMub3B0aW9ucywgdGhpcy5wYXRoKTtcbiAgY2xvbmUuZ2V0dGVycyA9IFtdLmNvbmNhdCh0aGlzLmdldHRlcnMpO1xuICBjbG9uZS5zZXR0ZXJzID0gW10uY29uY2F0KHRoaXMuc2V0dGVycyk7XG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGN1c3RvbSBnZXR0ZXIgdG8gdGhpcyB2aXJ0dWFsLlxuICpcbiAqIE1vbmdvb3NlIGNhbGxzIHRoZSBnZXR0ZXIgZnVuY3Rpb24gd2l0aCB0aGUgYmVsb3cgMyBwYXJhbWV0ZXJzLlxuICpcbiAqIC0gYHZhbHVlYDogdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBnZXR0ZXIuIElmIHRoZXJlIGlzIG9ubHkgb25lIGdldHRlciwgYHZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLlxuICogLSBgdmlydHVhbGA6IHRoZSB2aXJ0dWFsIG9iamVjdCB5b3UgY2FsbGVkIGAuZ2V0KClgIG9uLlxuICogLSBgZG9jYDogdGhlIGRvY3VtZW50IHRoaXMgdmlydHVhbCBpcyBhdHRhY2hlZCB0by4gRXF1aXZhbGVudCB0byBgdGhpc2AuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB2aXJ0dWFsID0gc2NoZW1hLnZpcnR1YWwoJ2Z1bGxuYW1lJyk7XG4gKiAgICAgdmlydHVhbC5nZXQoZnVuY3Rpb24odmFsdWUsIHZpcnR1YWwsIGRvYykge1xuICogICAgICAgcmV0dXJuIHRoaXMubmFtZS5maXJzdCArICcgJyArIHRoaXMubmFtZS5sYXN0O1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtWaXJ0dWFsVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5WaXJ0dWFsVHlwZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZm4pIHtcbiAgdGhpcy5nZXR0ZXJzLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGN1c3RvbSBzZXR0ZXIgdG8gdGhpcyB2aXJ0dWFsLlxuICpcbiAqIE1vbmdvb3NlIGNhbGxzIHRoZSBzZXR0ZXIgZnVuY3Rpb24gd2l0aCB0aGUgYmVsb3cgMyBwYXJhbWV0ZXJzLlxuICpcbiAqIC0gYHZhbHVlYDogdGhlIHZhbHVlIGJlaW5nIHNldC5cbiAqIC0gYHZpcnR1YWxgOiB0aGUgdmlydHVhbCBvYmplY3QgeW91J3JlIGNhbGxpbmcgYC5zZXQoKWAgb24uXG4gKiAtIGBkb2NgOiB0aGUgZG9jdW1lbnQgdGhpcyB2aXJ0dWFsIGlzIGF0dGFjaGVkIHRvLiBFcXVpdmFsZW50IHRvIGB0aGlzYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHZpcnR1YWwgPSBzY2hlbWEudmlydHVhbCgnZnVsbG5hbWUnKTtcbiAqICAgICB2aXJ0dWFsLnNldChmdW5jdGlvbih2YWx1ZSwgdmlydHVhbCwgZG9jKSB7XG4gKiAgICAgICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNwbGl0KCcgJyk7XG4gKiAgICAgICB0aGlzLm5hbWUuZmlyc3QgPSBwYXJ0c1swXTtcbiAqICAgICAgIHRoaXMubmFtZS5sYXN0ID0gcGFydHNbMV07XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCgpO1xuICogICAgIC8vIENhbGxzIHRoZSBzZXR0ZXIgd2l0aCBgdmFsdWUgPSAnSmVhbi1MdWMgUGljYXJkJ2BcbiAqICAgICBkb2MuZnVsbG5hbWUgPSAnSmVhbi1MdWMgUGljYXJkJztcbiAqICAgICBkb2MubmFtZS5maXJzdDsgLy8gJ0plYW4tTHVjJ1xuICogICAgIGRvYy5uYW1lLmxhc3Q7IC8vICdQaWNhcmQnXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1ZpcnR1YWxUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblZpcnR1YWxUeXBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihmbikge1xuICB0aGlzLnNldHRlcnMucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGdldHRlcnMgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBUaGUgZG9jdW1lbnQgdGhpcyB2aXJ0dWFsIGlzIGF0dGFjaGVkIHRvXG4gKiBAcmV0dXJuIHtBbnl9IHRoZSB2YWx1ZSBhZnRlciBhcHBseWluZyBhbGwgZ2V0dGVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5WaXJ0dWFsVHlwZS5wcm90b3R5cGUuYXBwbHlHZXR0ZXJzID0gZnVuY3Rpb24odmFsdWUsIGRvYykge1xuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh0aGlzLm9wdGlvbnMsIFsncmVmJywgJ3JlZlBhdGgnXSkgJiZcbiAgICAgIGRvYy4kJHBvcHVsYXRlZFZpcnR1YWxzICYmXG4gICAgICBkb2MuJCRwb3B1bGF0ZWRWaXJ0dWFscy5oYXNPd25Qcm9wZXJ0eSh0aGlzLnBhdGgpKSB7XG4gICAgdmFsdWUgPSBkb2MuJCRwb3B1bGF0ZWRWaXJ0dWFsc1t0aGlzLnBhdGhdO1xuICB9XG5cbiAgbGV0IHYgPSB2YWx1ZTtcbiAgZm9yIChjb25zdCBnZXR0ZXIgb2YgdGhpcy5nZXR0ZXJzKSB7XG4gICAgdiA9IGdldHRlci5jYWxsKGRvYywgdiwgdGhpcywgZG9jKTtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQXBwbGllcyBzZXR0ZXJzIHRvIGB2YWx1ZWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge0FueX0gdGhlIHZhbHVlIGFmdGVyIGFwcGx5aW5nIGFsbCBzZXR0ZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblZpcnR1YWxUeXBlLnByb3RvdHlwZS5hcHBseVNldHRlcnMgPSBmdW5jdGlvbih2YWx1ZSwgZG9jKSB7XG4gIGxldCB2ID0gdmFsdWU7XG4gIGZvciAoY29uc3Qgc2V0dGVyIG9mIHRoaXMuc2V0dGVycykge1xuICAgIHYgPSBzZXR0ZXIuY2FsbChkb2MsIHYsIHRoaXMsIGRvYyk7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpcnR1YWxUeXBlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/lib/virtualtype.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/node_modules/ms/index.js":
/*!****************************************************************!*\
  !*** ../server/node_modules/mongoose/node_modules/ms/index.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vc2VydmVyL25vZGVfbW9kdWxlcy9tb25nb29zZS9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxzYWxvbmlcXGFwcHJhaXNhbC1zeXN0ZW1cXHNlcnZlclxcbm9kZV9tb2R1bGVzXFxtb25nb29zZVxcbm9kZV9tb2R1bGVzXFxtc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/../server/node_modules/mongoose/node_modules/ms/index.js\n");

/***/ }),

/***/ "(api)/../server/node_modules/mongoose/package.json":
/*!****************************************************!*\
  !*** ../server/node_modules/mongoose/package.json ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"mongoose","description":"Mongoose MongoDB ODM","version":"7.8.2","author":"Guillermo Rauch <guillermo@learnboost.com>","keywords":["mongodb","document","model","schema","database","odm","data","datastore","query","nosql","orm","db"],"license":"MIT","dependencies":{"bson":"^5.5.0","kareem":"2.5.1","mongodb":"5.9.2","mpath":"0.9.0","mquery":"5.0.0","ms":"2.1.3","sift":"16.0.1"},"devDependencies":{"@babel/core":"7.23.0","@babel/preset-env":"7.22.20","@typescript-eslint/eslint-plugin":"5.62.0","@typescript-eslint/parser":"5.62.0","acquit":"1.3.0","acquit-ignore":"0.2.1","acquit-require":"0.1.1","assert-browserify":"2.0.0","axios":"1.1.3","babel-loader":"8.2.5","benchmark":"2.1.4","broken-link-checker":"^0.7.8","buffer":"^5.6.0","cheerio":"1.0.0-rc.12","crypto-browserify":"3.12.0","dotenv":"16.3.1","dox":"1.0.0","eslint":"8.50.0","eslint-plugin-markdown":"^3.0.0","eslint-plugin-mocha-no-only":"1.1.1","express":"^4.18.1","fs-extra":"~11.1.1","highlight.js":"11.8.0","lodash.isequal":"4.5.0","lodash.isequalwith":"4.4.0","markdownlint-cli2":"^0.10.0","marked":"4.3.0","mkdirp":"^3.0.1","mocha":"10.2.0","moment":"2.x","mongodb-memory-server":"9.2.0","ncp":"^2.0.0","nyc":"15.1.0","pug":"3.0.2","q":"1.5.1","sinon":"16.0.0","stream-browserify":"3.0.0","tsd":"0.29.0","typescript":"5.2.2","uuid":"9.0.1","webpack":"5.88.2"},"directories":{"lib":"./lib/mongoose"},"scripts":{"docs:clean":"npm run docs:clean:stable","docs:clean:stable":"rimraf index.html && rimraf -rf ./docs/*.html  && rimraf -rf ./docs/api && rimraf -rf ./docs/tutorials/*.html && rimraf -rf ./docs/typescript/*.html && rimraf -rf ./docs/*.html && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:clean:5x":"rimraf index.html && rimraf -rf ./docs/5.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:clean:6x":"rimraf index.html && rimraf -rf ./docs/6.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:copy:tmp":"mkdirp ./tmp/docs/css && mkdirp ./tmp/docs/js && mkdirp ./tmp/docs/images && mkdirp ./tmp/docs/tutorials && mkdirp ./tmp/docs/typescript && mkdirp ./tmp/docs/api && ncp ./docs/css ./tmp/docs/css --filter=.css$ && ncp ./docs/js ./tmp/docs/js --filter=.js$ && ncp ./docs/images ./tmp/docs/images && ncp ./docs/tutorials ./tmp/docs/tutorials && ncp ./docs/typescript ./tmp/docs/typescript && ncp ./docs/api ./tmp/docs/api && cp index.html ./tmp && cp docs/*.html ./tmp/docs/","docs:copy:tmp:5x":"rimraf ./docs/5.x && ncp ./tmp ./docs/5.x","docs:move:6x:tmp":"mv ./docs/6.x ./tmp","docs:copy:tmp:6x":"rimraf ./docs/6.x && ncp ./tmp ./docs/6.x","docs:checkout:gh-pages":"git checkout gh-pages","docs:checkout:5x":"git checkout 5.x","docs:checkout:6x":"git checkout 6.x","docs:generate":"node ./scripts/website.js","docs:generate:search":"node ./scripts/generateSearch.js","docs:generate:sponsorData":"node ./scripts/loadSponsorData.js","docs:merge:stable":"git merge master","docs:merge:5x":"git merge 5.x","docs:merge:6x":"git merge 6.x","docs:test":"npm run docs:generate && npm run docs:generate:search","docs:view":"node ./scripts/static.js","docs:prepare:publish:stable":"npm run docs:checkout:gh-pages && npm run docs:merge:stable && npm run docs:generate && npm run docs:generate:search","docs:prepare:publish:5x":"npm run docs:checkout:5x && npm run docs:merge:5x && npm run docs:clean:stable && npm run docs:generate && npm run docs:copy:tmp && npm run docs:checkout:gh-pages && npm run docs:copy:tmp:5x","docs:prepare:publish:6x":"npm run docs:checkout:6x && npm run docs:merge:6x && npm run docs:clean:stable && env DOCS_DEPLOY=true npm run docs:generate && npm run docs:move:6x:tmp && npm run docs:checkout:gh-pages && npm run docs:copy:tmp:6x","docs:prepare:publish:7x":"env DOCS_DEPLOY=true npm run docs:generate && npm run docs:checkout:gh-pages && rimraf ./docs/7.x && mv ./tmp ./docs/7.x","docs:check-links":"blc http://127.0.0.1:8089 -ro","lint":"eslint .","lint-js":"eslint . --ext .js --ext .cjs","lint-ts":"eslint . --ext .ts","lint-md":"markdownlint-cli2 \\"**/*.md\\"","build-browser":"(rm ./dist/* || true) && node ./scripts/build-browser.js","prepublishOnly":"npm run build-browser","release":"git pull && git push origin master --tags && npm publish","release-5x":"git pull origin 5.x && git push origin 5.x && git push origin 5.x --tags && npm publish --tag 5x","release-6x":"git pull origin 6.x && git push origin 6.x && git push origin 6.x --tags && npm publish --tag 6x","mongo":"node ./tools/repl.js","publish-7x":"npm publish --tag 7x","test":"mocha --exit ./test/*.test.js","test-deno":"deno run --allow-env --allow-read --allow-net --allow-run --allow-sys --allow-write ./test/deno.js","test-rs":"START_REPLICA_SET=1 mocha --timeout 30000 --exit ./test/*.test.js","test-tsd":"node ./test/types/check-types-filename && tsd","tdd":"mocha ./test/*.test.js --inspect --watch --recursive --watch-files ./**/*.{js,ts}","test-coverage":"nyc --reporter=html --reporter=text npm test","ts-benchmark":"cd ./benchmarks/typescript/simple && npm install && npm run benchmark | node ../../../scripts/tsc-diagnostics-check"},"main":"./index.js","types":"./types/index.d.ts","engines":{"node":">=14.20.1"},"bugs":{"url":"https://github.com/Automattic/mongoose/issues/new"},"repository":{"type":"git","url":"git://github.com/Automattic/mongoose.git"},"homepage":"https://mongoosejs.com","browser":"./dist/browser.umd.js","config":{"mongodbMemoryServer":{"disablePostinstall":true}},"funding":{"type":"opencollective","url":"https://opencollective.com/mongoose"},"tsd":{"directory":"test/types","compilerOptions":{"esModuleInterop":false,"strict":true,"allowSyntheticDefaultImports":true,"strictPropertyInitialization":false,"noImplicitAny":false,"strictNullChecks":true,"module":"commonjs","target":"ES2017"}}}');

/***/ })

};
;